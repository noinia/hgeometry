-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Reading and Writing ipe7 files.
--   
--   Reading and Writing ipe7 files and converting them to and from
--   HGeometry types.
@package hgeometry-ipe
@version 0.12.0.0

module Data.Geometry.Ipe.Layer
newtype LayerName
LayerName :: Text -> LayerName
layerName :: Iso' LayerName Text
instance Data.String.IsString Data.Geometry.Ipe.Layer.LayerName
instance GHC.Classes.Ord Data.Geometry.Ipe.Layer.LayerName
instance GHC.Classes.Eq Data.Geometry.Ipe.Layer.LayerName
instance GHC.Read.Read Data.Geometry.Ipe.Layer.LayerName
instance GHC.Show.Show Data.Geometry.Ipe.Layer.LayerName

module Data.Geometry.Ipe.Literal
literally :: String -> Q Exp
lit :: QuasiQuoter
litFile :: QuasiQuoter
xmlLiteral :: String -> Node Text Text

module Data.Geometry.Ipe.Path

-- | A path is a non-empty sequence of PathSegments.
newtype Path r
Path :: LSeq 1 (PathSegment r) -> Path r
pathSegments :: forall r_asjx r_aCKU. Iso (Path r_asjx) (Path r_aCKU) (LSeq 1 (PathSegment r_asjx)) (LSeq 1 (PathSegment r_aCKU))

-- | Paths
--   
--   Paths consist of Path Segments. PathSegments come in the following
--   forms:
data PathSegment r
PolyLineSegment :: PolyLine 2 () r -> PathSegment r
PolygonPath :: SimplePolygon () r -> PathSegment r
CubicBezierSegment :: BezierSpline 3 2 r -> PathSegment r
QuadraticBezierSegment :: BezierSpline 2 2 r -> PathSegment r
EllipseSegment :: Ellipse r -> PathSegment r
ArcSegment :: PathSegment r
SplineSegment :: PathSegment r
ClosedSplineSegment :: PathSegment r
_PolyLineSegment :: forall r_aqir. Prism' (PathSegment r_aqir) (PolyLine 2 () r_aqir)
_PolygonPath :: forall r_aqir. Prism' (PathSegment r_aqir) (SimplePolygon () r_aqir)
_CubicBezierSegment :: forall r_aqir. Prism' (PathSegment r_aqir) (BezierSpline 3 2 r_aqir)
_QuadraticBezierSegment :: forall r_aqir. Prism' (PathSegment r_aqir) (BezierSpline 2 2 r_aqir)
_EllipseSegment :: forall r_aqir. Prism' (PathSegment r_aqir) (Ellipse r_aqir)
_ArcSegment :: forall r_aqir. Prism' (PathSegment r_aqir) ()
_SplineSegment :: forall r_aqir. Prism' (PathSegment r_aqir) ()
_ClosedSplineSegment :: forall r_aqir. Prism' (PathSegment r_aqir) ()

-- | type that represents a path in ipe.
data Operation r
MoveTo :: Point 2 r -> Operation r
LineTo :: Point 2 r -> Operation r
CurveTo :: Point 2 r -> Point 2 r -> Point 2 r -> Operation r
QCurveTo :: Point 2 r -> Point 2 r -> Operation r
Ellipse :: Matrix 3 3 r -> Operation r
ArcTo :: Matrix 3 3 r -> Point 2 r -> Operation r
Spline :: [Point 2 r] -> Operation r
ClosedSpline :: [Point 2 r] -> Operation r
ClosePath :: Operation r
_MoveTo :: forall r_aCL7. Prism' (Operation r_aCL7) (Point 2 r_aCL7)
_LineTo :: forall r_aCL7. Prism' (Operation r_aCL7) (Point 2 r_aCL7)
_CurveTo :: forall r_aCL7. Prism' (Operation r_aCL7) (Point 2 r_aCL7, Point 2 r_aCL7, Point 2 r_aCL7)
_QCurveTo :: forall r_aCL7. Prism' (Operation r_aCL7) (Point 2 r_aCL7, Point 2 r_aCL7)
_Ellipse :: forall r_aCL7. Prism' (Operation r_aCL7) (Matrix 3 3 r_aCL7)
_ArcTo :: forall r_aCL7. Prism' (Operation r_aCL7) (Matrix 3 3 r_aCL7, Point 2 r_aCL7)
_Spline :: forall r_aCL7. Prism' (Operation r_aCL7) [Point 2 r_aCL7]
_ClosedSpline :: forall r_aCL7. Prism' (Operation r_aCL7) [Point 2 r_aCL7]
_ClosePath :: forall r_aCL7. Prism' (Operation r_aCL7) ()
instance Data.Traversable.Traversable Data.Geometry.Ipe.Path.Operation
instance Data.Foldable.Foldable Data.Geometry.Ipe.Path.Operation
instance GHC.Base.Functor Data.Geometry.Ipe.Path.Operation
instance GHC.Show.Show r => GHC.Show.Show (Data.Geometry.Ipe.Path.Operation r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Data.Geometry.Ipe.Path.Operation r)
instance GHC.Real.Fractional r => Data.Geometry.Transformation.IsTransformable (Data.Geometry.Ipe.Path.Path r)
instance Data.Traversable.Traversable Data.Geometry.Ipe.Path.Path
instance Data.Foldable.Foldable Data.Geometry.Ipe.Path.Path
instance GHC.Base.Functor Data.Geometry.Ipe.Path.Path
instance GHC.Classes.Eq r => GHC.Classes.Eq (Data.Geometry.Ipe.Path.Path r)
instance GHC.Show.Show r => GHC.Show.Show (Data.Geometry.Ipe.Path.Path r)
instance GHC.Base.Functor Data.Geometry.Ipe.Path.PathSegment
instance Data.Foldable.Foldable Data.Geometry.Ipe.Path.PathSegment
instance Data.Traversable.Traversable Data.Geometry.Ipe.Path.PathSegment
instance GHC.Real.Fractional r => Data.Geometry.Transformation.IsTransformable (Data.Geometry.Ipe.Path.PathSegment r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Data.Geometry.Ipe.Path.PathSegment r)
instance GHC.Show.Show r => GHC.Show.Show (Data.Geometry.Ipe.Path.PathSegment r)

module Data.Geometry.Ipe.PathParser

-- | Represent stuff that can be used as a coordinate in ipe. (similar to
--   show/read)
class Fractional r => Coordinate r
fromSeq :: Coordinate r => Integer -> Maybe (Int, Integer) -> r
fromSeq :: (Coordinate r, Ord r, Fractional r) => Integer -> Maybe (Int, Integer) -> r
defaultFromSeq :: (Ord r, Fractional r) => Integer -> Maybe (Int, Integer) -> r

-- | Running the parsers
readCoordinate :: Coordinate r => Text -> Either Text r
readPoint :: Coordinate r => Text -> Either Text (Point 2 r)
runParser :: Parser a -> Text -> Either Text a
data Either' l r
Left' :: l -> Either' l r
Right' :: r -> Either' l r
either' :: (l -> a) -> (r -> a) -> Either' l r -> a
readPathOperations :: Coordinate r => Text -> Either Text [Operation r]
errorText :: ParseError -> Text
combineErrors :: [ParseError] -> Text
splitKeepDelims :: [Char] -> Text -> [Text]
readMatrix :: Coordinate r => Text -> Either Text (Matrix 3 3 r)
readRectangle :: Coordinate r => Text -> Either Text (Rectangle () r)

-- | The parsers themselves
pOperation :: forall r. Coordinate r => Parser (Operation r)
pPoint :: Coordinate r => Parser (Point 2 r)
pCoordinate :: Coordinate r => Parser r
pRectangle :: Coordinate r => Parser (Rectangle () r)
pMatrix :: Coordinate r => Parser (Matrix 3 3 r)

-- | Generate a matrix from a list of 6 coordinates.
mkMatrix :: Coordinate r => [r] -> Matrix 3 3 r
instance (GHC.Classes.Eq l, GHC.Classes.Eq r) => GHC.Classes.Eq (Data.Geometry.Ipe.PathParser.Either' l r)
instance (GHC.Show.Show l, GHC.Show.Show r) => GHC.Show.Show (Data.Geometry.Ipe.PathParser.Either' l r)
instance (GHC.Base.Semigroup l, GHC.Base.Semigroup r) => GHC.Base.Semigroup (Data.Geometry.Ipe.PathParser.Either' l r)
instance (GHC.Base.Semigroup l, GHC.Base.Semigroup r, GHC.Base.Monoid r) => GHC.Base.Monoid (Data.Geometry.Ipe.PathParser.Either' l r)
instance Data.Geometry.Ipe.PathParser.Coordinate GHC.Types.Double
instance Data.Geometry.Ipe.PathParser.Coordinate GHC.Types.Float
instance Data.Geometry.Ipe.PathParser.Coordinate (GHC.Real.Ratio GHC.Integer.Type.Integer)
instance Data.Geometry.Ipe.PathParser.Coordinate (Data.RealNumber.Rational.RealNumber p)


-- | Data type for representing values in ipe.
module Data.Geometry.Ipe.Value

-- | Many types either consist of a symbolc value, or a value of type v
data IpeValue v
Named :: Text -> IpeValue v
Valued :: v -> IpeValue v
instance Data.Traversable.Traversable Data.Geometry.Ipe.Value.IpeValue
instance Data.Foldable.Foldable Data.Geometry.Ipe.Value.IpeValue
instance GHC.Base.Functor Data.Geometry.Ipe.Value.IpeValue
instance GHC.Classes.Ord v => GHC.Classes.Ord (Data.Geometry.Ipe.Value.IpeValue v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Data.Geometry.Ipe.Value.IpeValue v)
instance GHC.Read.Read v => GHC.Read.Read (Data.Geometry.Ipe.Value.IpeValue v)
instance GHC.Show.Show v => GHC.Show.Show (Data.Geometry.Ipe.Value.IpeValue v)
instance Data.String.IsString (Data.Geometry.Ipe.Value.IpeValue v)


-- | Data type for representing colors in ipe as well as the colors
--   available in the standard ipe stylesheet.
module Data.Geometry.Ipe.Color
newtype IpeColor r
IpeColor :: IpeValue (RGB r) -> IpeColor r

-- | Creates a named color
named :: Text -> IpeColor r
red :: IpeColor r
green :: IpeColor r
blue :: IpeColor r
yellow :: IpeColor r
orange :: IpeColor r
gold :: IpeColor r
purple :: IpeColor r
gray :: IpeColor r
brown :: IpeColor r
navy :: IpeColor r
pink :: IpeColor r
seagreen :: IpeColor r
turquoise :: IpeColor r
violet :: IpeColor r
darkblue :: IpeColor r
darkcyan :: IpeColor r
darkgray :: IpeColor r
darkgreen :: IpeColor r
darkmagenta :: IpeColor r
darkorange :: IpeColor r
darkred :: IpeColor r
lightblue :: IpeColor r
lightcyan :: IpeColor r
lightgray :: IpeColor r
lightgreen :: IpeColor r
lightyellow :: IpeColor r
instance GHC.Classes.Eq r => GHC.Classes.Eq (Data.Geometry.Ipe.Color.IpeColor r)
instance GHC.Read.Read r => GHC.Read.Read (Data.Geometry.Ipe.Color.IpeColor r)
instance GHC.Show.Show r => GHC.Show.Show (Data.Geometry.Ipe.Color.IpeColor r)
instance GHC.Classes.Ord r => GHC.Classes.Ord (Data.Geometry.Ipe.Color.IpeColor r)
instance GHC.Base.Functor Data.Geometry.Ipe.Color.IpeColor
instance Data.Foldable.Foldable Data.Geometry.Ipe.Color.IpeColor
instance Data.Traversable.Traversable Data.Geometry.Ipe.Color.IpeColor


-- | Possible Attributes we can assign to items in an Ipe file
module Data.Geometry.Ipe.Attributes
data AttributeUniverse
Layer :: AttributeUniverse
Matrix :: AttributeUniverse
Pin :: AttributeUniverse
Transformations :: AttributeUniverse
Stroke :: AttributeUniverse
Fill :: AttributeUniverse
Pen :: AttributeUniverse
Size :: AttributeUniverse
Dash :: AttributeUniverse
LineCap :: AttributeUniverse
LineJoin :: AttributeUniverse
FillRule :: AttributeUniverse
Arrow :: AttributeUniverse
RArrow :: AttributeUniverse
Opacity :: AttributeUniverse
Tiling :: AttributeUniverse
Gradient :: AttributeUniverse
Clip :: AttributeUniverse
type LayerSym0 = 'Layer
type MatrixSym0 = 'Matrix
type PinSym0 = 'Pin
type TransformationsSym0 = 'Transformations
type StrokeSym0 = 'Stroke
type FillSym0 = 'Fill
type PenSym0 = 'Pen
type SizeSym0 = 'Size
type DashSym0 = 'Dash
type LineCapSym0 = 'LineCap
type LineJoinSym0 = 'LineJoin
type FillRuleSym0 = 'FillRule
type ArrowSym0 = 'Arrow
type RArrowSym0 = 'RArrow
type OpacitySym0 = 'Opacity
type TilingSym0 = 'Tiling
type GradientSym0 = 'Gradient
type ClipSym0 = 'Clip
data SAttributeUniverse :: AttributeUniverse -> Type
[SLayer] :: SAttributeUniverse 'Layer
[SMatrix] :: SAttributeUniverse 'Matrix
[SPin] :: SAttributeUniverse 'Pin
[STransformations] :: SAttributeUniverse 'Transformations
[SStroke] :: SAttributeUniverse 'Stroke
[SFill] :: SAttributeUniverse 'Fill
[SPen] :: SAttributeUniverse 'Pen
[SSize] :: SAttributeUniverse 'Size
[SDash] :: SAttributeUniverse 'Dash
[SLineCap] :: SAttributeUniverse 'LineCap
[SLineJoin] :: SAttributeUniverse 'LineJoin
[SFillRule] :: SAttributeUniverse 'FillRule
[SArrow] :: SAttributeUniverse 'Arrow
[SRArrow] :: SAttributeUniverse 'RArrow
[SOpacity] :: SAttributeUniverse 'Opacity
[STiling] :: SAttributeUniverse 'Tiling
[SGradient] :: SAttributeUniverse 'Gradient
[SClip] :: SAttributeUniverse 'Clip
type CommonAttributes = [Layer, Matrix, Pin, Transformations]
type TextLabelAttributes = CommonAttributes
type MiniPageAttributes = CommonAttributes
type ImageAttributes = CommonAttributes
type SymbolAttributes = CommonAttributes ++ [Stroke, Fill, Pen, Size]
type PathAttributes = CommonAttributes ++ [Stroke, Fill, Dash, Pen, LineCap, LineJoin, FillRule, Arrow, RArrow, Opacity, Tiling, Gradient]
type GroupAttributes = CommonAttributes ++ '[ 'Clip]

-- | Attr implements the mapping from labels to types as specified by the
--   (symbol representing) the type family <tt>f</tt>
newtype Attr (f :: TyFun u * -> *) (label :: u)
GAttr :: Maybe (Apply f label) -> Attr (f :: TyFun u * -> *) (label :: u)
[_getAttr] :: Attr (f :: TyFun u * -> *) (label :: u) -> Maybe (Apply f label)
getAttr :: forall f_a19Qq label_a19Qr f_a1b3c label_a1b3d. Iso (Attr f_a19Qq label_a19Qr) (Attr f_a1b3c label_a1b3d) (Maybe (Apply f_a19Qq label_a19Qr)) (Maybe (Apply f_a1b3c label_a1b3d))

-- | Constructor for constructing an Attr given an actual value.
pattern Attr :: Apply f label -> Attr f label

-- | An Attribute that is not set
pattern NoAttr :: Attr f label
traverseAttr :: Applicative h => (Apply f label -> h (Apply g label)) -> Attr f label -> h (Attr g label)

-- | Traverse for the situation where the type is not actually
--   parameterized.
pureAttr :: (Applicative h, Apply f a ~ Apply g a) => Attr f a -> h (Attr g a)

-- | A collection of Attributes.
newtype Attributes (f :: TyFun u * -> *) (ats :: [u])
Attrs :: Rec (Attr f) ats -> Attributes (f :: TyFun u * -> *) (ats :: [u])
unAttrs :: Lens (Attributes f ats) (Attributes f' ats') (Rec (Attr f) ats) (Rec (Attr f') ats')
traverseAttrs :: Applicative h => (forall label. Attr f label -> h (Attr g label)) -> Attributes f ats -> h (Attributes g ats)
zipRecsWith :: (forall a. f a -> g a -> h a) -> Rec f as -> Rec g as -> Rec h as

-- | Lens into a specific attribute, if it is set.
ixAttr :: forall at ats proxy f. at ∈ ats => proxy at -> Lens' (Attributes f ats) (Maybe (Apply f at))

-- | Prism into a particular attribute.
_Attr :: forall at ats proxy f. (at ∈ ats, RecApplicative ats) => proxy at -> Prism' (Attributes f ats) (Apply f at)

-- | Looks up a particular attribute.
lookupAttr :: at ∈ ats => proxy at -> Attributes f ats -> Maybe (Apply f at)

-- | Sets a particular attribute
setAttr :: forall proxy at ats f. at ∈ ats => proxy at -> Apply f at -> Attributes f ats -> Attributes f ats

-- | gets and removes the attribute from Attributes
takeAttr :: forall proxy at ats f. at ∈ ats => proxy at -> Attributes f ats -> (Maybe (Apply f at), Attributes f ats)

-- | unsets/Removes an attribute
unSetAttr :: forall proxy at ats f. at ∈ ats => proxy at -> Attributes f ats -> Attributes f ats

-- | Creates a singleton attribute
attr :: (at ∈ ats, RecApplicative ats) => proxy at -> Apply f at -> Attributes f ats

-- | Common Attributes
--   
--   Possible values for Pin
data PinType
No :: PinType
Yes :: PinType
Horizontal :: PinType
Vertical :: PinType

-- | Possible values for Transformation
data TransformationTypes
Affine :: TransformationTypes
Rigid :: TransformationTypes
Translations :: TransformationTypes

-- | TODO
--   
--   Symbol Attributes
--   
--   The optional Attributes for a symbol data SymbolAttributeUniverse =
--   SymbolStroke | SymbolFill | SymbolPen | Size deriving (Show,Eq)
newtype IpeSize r
IpeSize :: IpeValue r -> IpeSize r
newtype IpePen r
IpePen :: IpeValue r -> IpePen r

-- | Path Attributes
--   
--   Possible attributes for a path data PathAttributeUniverse = Stroke |
--   Fill | Dash | Pen | LineCap | LineJoin | FillRule | Arrow | RArrow |
--   Opacity | Tiling | Gradient deriving (Show,Eq)
--   
--   Possible values for Dash
data IpeDash r
DashNamed :: Text -> IpeDash r
DashPattern :: [r] -> r -> IpeDash r

-- | Allowed Fill types
data FillType
Wind :: FillType
EOFill :: FillType

-- | IpeOpacity, IpeTyling, and IpeGradient are all symbolic values
type IpeOpacity = Text
type IpeTiling = Text
type IpeGradient = Text

-- | Possible values for an ipe arrow
data IpeArrow r
IpeArrow :: Text -> IpeSize r -> IpeArrow r
[_arrowName] :: IpeArrow r -> Text
[_arrowSize] :: IpeArrow r -> IpeSize r
arrowSize :: forall r_a1b3W r_a1drX. Lens (IpeArrow r_a1b3W) (IpeArrow r_a1drX) (IpeSize r_a1b3W) (IpeSize r_a1drX)
arrowName :: forall r_a1b3W. Lens' (IpeArrow r_a1b3W) Text
normalArrow :: IpeArrow r

-- | For the types representing attribute values we can get the name/key to
--   use when serializing to ipe.
class IpeAttrName (a :: AttributeUniverse)
attrName :: IpeAttrName a => proxy a -> Text

-- | Writing Attribute names
writeAttrNames :: AllConstrained IpeAttrName rs => Rec f rs -> Rec (Const Text) rs
instance Data.Geometry.Ipe.Attributes.IpeAttrName 'Data.Geometry.Ipe.Attributes.Layer
instance Data.Geometry.Ipe.Attributes.IpeAttrName 'Data.Geometry.Ipe.Attributes.Matrix
instance Data.Geometry.Ipe.Attributes.IpeAttrName 'Data.Geometry.Ipe.Attributes.Pin
instance Data.Geometry.Ipe.Attributes.IpeAttrName 'Data.Geometry.Ipe.Attributes.Transformations
instance Data.Geometry.Ipe.Attributes.IpeAttrName 'Data.Geometry.Ipe.Attributes.Stroke
instance Data.Geometry.Ipe.Attributes.IpeAttrName 'Data.Geometry.Ipe.Attributes.Fill
instance Data.Geometry.Ipe.Attributes.IpeAttrName 'Data.Geometry.Ipe.Attributes.Pen
instance Data.Geometry.Ipe.Attributes.IpeAttrName 'Data.Geometry.Ipe.Attributes.Size
instance Data.Geometry.Ipe.Attributes.IpeAttrName 'Data.Geometry.Ipe.Attributes.Dash
instance Data.Geometry.Ipe.Attributes.IpeAttrName 'Data.Geometry.Ipe.Attributes.LineCap
instance Data.Geometry.Ipe.Attributes.IpeAttrName 'Data.Geometry.Ipe.Attributes.LineJoin
instance Data.Geometry.Ipe.Attributes.IpeAttrName 'Data.Geometry.Ipe.Attributes.FillRule
instance Data.Geometry.Ipe.Attributes.IpeAttrName 'Data.Geometry.Ipe.Attributes.Arrow
instance Data.Geometry.Ipe.Attributes.IpeAttrName 'Data.Geometry.Ipe.Attributes.RArrow
instance Data.Geometry.Ipe.Attributes.IpeAttrName 'Data.Geometry.Ipe.Attributes.Opacity
instance Data.Geometry.Ipe.Attributes.IpeAttrName 'Data.Geometry.Ipe.Attributes.Tiling
instance Data.Geometry.Ipe.Attributes.IpeAttrName 'Data.Geometry.Ipe.Attributes.Gradient
instance Data.Geometry.Ipe.Attributes.IpeAttrName 'Data.Geometry.Ipe.Attributes.Clip
instance Data.Traversable.Traversable Data.Geometry.Ipe.Attributes.IpeArrow
instance Data.Foldable.Foldable Data.Geometry.Ipe.Attributes.IpeArrow
instance GHC.Base.Functor Data.Geometry.Ipe.Attributes.IpeArrow
instance GHC.Classes.Eq r => GHC.Classes.Eq (Data.Geometry.Ipe.Attributes.IpeArrow r)
instance GHC.Show.Show r => GHC.Show.Show (Data.Geometry.Ipe.Attributes.IpeArrow r)
instance GHC.Classes.Eq Data.Geometry.Ipe.Attributes.FillType
instance GHC.Read.Read Data.Geometry.Ipe.Attributes.FillType
instance GHC.Show.Show Data.Geometry.Ipe.Attributes.FillType
instance Data.Traversable.Traversable Data.Geometry.Ipe.Attributes.IpeDash
instance Data.Foldable.Foldable Data.Geometry.Ipe.Attributes.IpeDash
instance GHC.Base.Functor Data.Geometry.Ipe.Attributes.IpeDash
instance GHC.Classes.Eq r => GHC.Classes.Eq (Data.Geometry.Ipe.Attributes.IpeDash r)
instance GHC.Show.Show r => GHC.Show.Show (Data.Geometry.Ipe.Attributes.IpeDash r)
instance Data.Traversable.Traversable Data.Geometry.Ipe.Attributes.IpePen
instance Data.Foldable.Foldable Data.Geometry.Ipe.Attributes.IpePen
instance GHC.Base.Functor Data.Geometry.Ipe.Attributes.IpePen
instance GHC.Classes.Ord r => GHC.Classes.Ord (Data.Geometry.Ipe.Attributes.IpePen r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Data.Geometry.Ipe.Attributes.IpePen r)
instance GHC.Show.Show r => GHC.Show.Show (Data.Geometry.Ipe.Attributes.IpePen r)
instance Data.Traversable.Traversable Data.Geometry.Ipe.Attributes.IpeSize
instance Data.Foldable.Foldable Data.Geometry.Ipe.Attributes.IpeSize
instance GHC.Base.Functor Data.Geometry.Ipe.Attributes.IpeSize
instance GHC.Classes.Ord r => GHC.Classes.Ord (Data.Geometry.Ipe.Attributes.IpeSize r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Data.Geometry.Ipe.Attributes.IpeSize r)
instance GHC.Show.Show r => GHC.Show.Show (Data.Geometry.Ipe.Attributes.IpeSize r)
instance GHC.Classes.Eq Data.Geometry.Ipe.Attributes.TransformationTypes
instance GHC.Read.Read Data.Geometry.Ipe.Attributes.TransformationTypes
instance GHC.Show.Show Data.Geometry.Ipe.Attributes.TransformationTypes
instance GHC.Read.Read Data.Geometry.Ipe.Attributes.PinType
instance GHC.Show.Show Data.Geometry.Ipe.Attributes.PinType
instance GHC.Classes.Eq Data.Geometry.Ipe.Attributes.PinType
instance forall u (ats :: [u]) (f :: Data.Singletons.Internal.TyFun u * -> *). (Data.Vinyl.Core.RMap ats, Data.Vinyl.Core.ReifyConstraint GHC.Show.Show (Data.Geometry.Ipe.Attributes.Attr f) ats, Data.Vinyl.Core.RecordToList ats, Data.Vinyl.TypeLevel.RecAll (Data.Geometry.Ipe.Attributes.Attr f) ats GHC.Show.Show) => GHC.Show.Show (Data.Geometry.Ipe.Attributes.Attributes f ats)
instance forall u (f :: Data.Singletons.Internal.TyFun u * -> *) (ats :: [u]). (Data.Vinyl.Core.ReifyConstraint GHC.Classes.Eq (Data.Geometry.Ipe.Attributes.Attr f) ats, Data.Vinyl.Core.RecordToList ats, Data.Vinyl.TypeLevel.RecAll (Data.Geometry.Ipe.Attributes.Attr f) ats GHC.Classes.Eq) => GHC.Classes.Eq (Data.Geometry.Ipe.Attributes.Attributes f ats)
instance forall u (ats :: [u]) (f :: Data.Singletons.Internal.TyFun u * -> *). Data.Vinyl.Core.RecApplicative ats => GHC.Base.Monoid (Data.Geometry.Ipe.Attributes.Attributes f ats)
instance forall u (f :: Data.Singletons.Internal.TyFun u * -> *) (ats :: [u]). GHC.Base.Semigroup (Data.Geometry.Ipe.Attributes.Attributes f ats)
instance forall u (f :: u Data.Singletons.Internal.~> *) (label :: u). GHC.Show.Show (Data.Singletons.Internal.Apply f label) => GHC.Show.Show (Data.Geometry.Ipe.Attributes.Attr f label)
instance forall u (f :: u Data.Singletons.Internal.~> *) (label :: u). GHC.Read.Read (Data.Singletons.Internal.Apply f label) => GHC.Read.Read (Data.Geometry.Ipe.Attributes.Attr f label)
instance forall u (f :: Data.Singletons.Internal.TyFun u * -> *) (l :: u). GHC.Base.Semigroup (Data.Geometry.Ipe.Attributes.Attr f l)
instance forall u (f :: Data.Singletons.Internal.TyFun u * -> *) (l :: u). GHC.Base.Monoid (Data.Geometry.Ipe.Attributes.Attr f l)
instance forall u (f :: u Data.Singletons.Internal.~> *) (label :: u). GHC.Classes.Eq (Data.Singletons.Internal.Apply f label) => GHC.Classes.Eq (Data.Geometry.Ipe.Attributes.Attr f label)
instance forall u (f :: u Data.Singletons.Internal.~> *) (label :: u). GHC.Classes.Ord (Data.Singletons.Internal.Apply f label) => GHC.Classes.Ord (Data.Geometry.Ipe.Attributes.Attr f label)
instance Data.Singletons.Internal.SingKind Data.Geometry.Ipe.Attributes.AttributeUniverse
instance Data.Singletons.Internal.SingI 'Data.Geometry.Ipe.Attributes.Layer
instance Data.Singletons.Internal.SingI 'Data.Geometry.Ipe.Attributes.Matrix
instance Data.Singletons.Internal.SingI 'Data.Geometry.Ipe.Attributes.Pin
instance Data.Singletons.Internal.SingI 'Data.Geometry.Ipe.Attributes.Transformations
instance Data.Singletons.Internal.SingI 'Data.Geometry.Ipe.Attributes.Stroke
instance Data.Singletons.Internal.SingI 'Data.Geometry.Ipe.Attributes.Fill
instance Data.Singletons.Internal.SingI 'Data.Geometry.Ipe.Attributes.Pen
instance Data.Singletons.Internal.SingI 'Data.Geometry.Ipe.Attributes.Size
instance Data.Singletons.Internal.SingI 'Data.Geometry.Ipe.Attributes.Dash
instance Data.Singletons.Internal.SingI 'Data.Geometry.Ipe.Attributes.LineCap
instance Data.Singletons.Internal.SingI 'Data.Geometry.Ipe.Attributes.LineJoin
instance Data.Singletons.Internal.SingI 'Data.Geometry.Ipe.Attributes.FillRule
instance Data.Singletons.Internal.SingI 'Data.Geometry.Ipe.Attributes.Arrow
instance Data.Singletons.Internal.SingI 'Data.Geometry.Ipe.Attributes.RArrow
instance Data.Singletons.Internal.SingI 'Data.Geometry.Ipe.Attributes.Opacity
instance Data.Singletons.Internal.SingI 'Data.Geometry.Ipe.Attributes.Tiling
instance Data.Singletons.Internal.SingI 'Data.Geometry.Ipe.Attributes.Gradient
instance Data.Singletons.Internal.SingI 'Data.Geometry.Ipe.Attributes.Clip
instance GHC.Classes.Eq Data.Geometry.Ipe.Attributes.AttributeUniverse
instance GHC.Read.Read Data.Geometry.Ipe.Attributes.AttributeUniverse
instance GHC.Show.Show Data.Geometry.Ipe.Attributes.AttributeUniverse

module Data.Geometry.Ipe.Content

-- | Image Objects
data Image r
Image :: () -> Rectangle () r -> Image r
imageData :: forall r_a1kaI. Lens' (Image r_a1kaI) ()
rect :: forall r_a1kaI r_a1kkD. Lens (Image r_a1kaI) (Image r_a1kkD) (Rectangle () r_a1kaI) (Rectangle () r_a1kkD)

-- | Text Objects
data TextLabel r
Label :: Text -> Point 2 r -> TextLabel r
data MiniPage r
MiniPage :: Text -> Point 2 r -> r -> MiniPage r
width :: MiniPage t -> t

-- | Ipe Symbols, i.e. Points
--   
--   A symbol (point) in ipe
data IpeSymbol r
Symbol :: Point 2 r -> Text -> IpeSymbol r
symbolPoint :: forall r_a1kkX r_a1l73. Lens (IpeSymbol r_a1kkX) (IpeSymbol r_a1l73) (Point 2 r_a1kkX) (Point 2 r_a1l73)
symbolName :: forall r_a1kkX. Lens' (IpeSymbol r_a1kkX) Text

-- | A path is a non-empty sequence of PathSegments.
newtype Path r
Path :: LSeq 1 (PathSegment r) -> Path r
pathSegments :: forall r_asjx r_aCKU. Iso (Path r_asjx) (Path r_aCKU) (LSeq 1 (PathSegment r_asjx)) (LSeq 1 (PathSegment r_aCKU))

-- | Paths
--   
--   Paths consist of Path Segments. PathSegments come in the following
--   forms:
data PathSegment r
PolyLineSegment :: PolyLine 2 () r -> PathSegment r
PolygonPath :: SimplePolygon () r -> PathSegment r
CubicBezierSegment :: BezierSpline 3 2 r -> PathSegment r
QuadraticBezierSegment :: BezierSpline 2 2 r -> PathSegment r
EllipseSegment :: Ellipse r -> PathSegment r
ArcSegment :: PathSegment r
SplineSegment :: PathSegment r
ClosedSplineSegment :: PathSegment r

-- | Groups and Objects
--   
--   Group Attributes
--   
--   A group is essentially a list of IpeObjects.
newtype Group r
Group :: [IpeObject r] -> Group r
groupItems :: Lens (Group r) (Group s) [IpeObject r] [IpeObject s]
data IpeObject r
IpeGroup :: IpeObject' Group r -> IpeObject r
IpeImage :: IpeObject' Image r -> IpeObject r
IpeTextLabel :: IpeObject' TextLabel r -> IpeObject r
IpeMiniPage :: IpeObject' MiniPage r -> IpeObject r
IpeUse :: IpeObject' IpeSymbol r -> IpeObject r
IpePath :: IpeObject' Path r -> IpeObject r
_IpeGroup :: forall r_a1len. Prism' (IpeObject r_a1len) (IpeObject' Group r_a1len)
_IpeImage :: forall r_a1len. Prism' (IpeObject r_a1len) (IpeObject' Image r_a1len)
_IpeTextLabel :: forall r_a1len. Prism' (IpeObject r_a1len) (IpeObject' TextLabel r_a1len)
_IpeMiniPage :: forall r_a1len. Prism' (IpeObject r_a1len) (IpeObject' MiniPage r_a1len)
_IpeUse :: forall r_a1len. Prism' (IpeObject r_a1len) (IpeObject' IpeSymbol r_a1len)
_IpePath :: forall r_a1len. Prism' (IpeObject r_a1len) (IpeObject' Path r_a1len)

-- | An IpeObject' is essentially the oject ogether with its attributes
type IpeObject' g r = g r :+ IpeAttributes g r

-- | Shorthand for constructing ipeObjects
ipeObject' :: ToObject i => i r -> IpeAttributes i r -> IpeObject r
class ToObject i
mkIpeObject :: ToObject i => IpeObject' i r -> IpeObject r
type IpeAttributes g r = Attributes' r (AttributesOf g)

-- | Attributes' :: * -&gt; [AttributeUniverse] -&gt; *
type Attributes' r = Attributes (AttrMapSym1 r)
type family AttributesOf (t :: * -> *) :: [AttributeUniverse]

-- | The mapping between the labels of the the attributes and the types of
--   the attributes with these labels. For example, the <a>Matrix</a>
--   label/attribute should have a value of type 'Matrix 3 3 r'.
type family AttrMap (r :: *) (l :: AttributeUniverse) :: *
data AttrMapSym1 (r6989586621679329293 :: Type) :: (~>) AttributeUniverse Type
attributes :: Lens' (IpeObject' g r) (IpeAttributes g r)

-- | traverse for ipe attributes
traverseIpeAttrs :: (Applicative f, AllConstrained TraverseIpeAttr (AttributesOf g)) => proxy g -> (r -> f s) -> IpeAttributes g r -> f (IpeAttributes g s)
commonAttributes :: Lens' (IpeObject r) (Attributes (AttrMapSym1 r) CommonAttributes)

-- | collect all non-group objects
flattenGroups :: [IpeObject r] -> [IpeObject r]
instance Data.Geometry.Ipe.Content.ToObject Data.Geometry.Ipe.Content.Group
instance Data.Geometry.Ipe.Content.ToObject Data.Geometry.Ipe.Content.Image
instance Data.Geometry.Ipe.Content.ToObject Data.Geometry.Ipe.Content.TextLabel
instance Data.Geometry.Ipe.Content.ToObject Data.Geometry.Ipe.Content.MiniPage
instance Data.Geometry.Ipe.Content.ToObject Data.Geometry.Ipe.Content.IpeSymbol
instance Data.Geometry.Ipe.Content.ToObject Data.Geometry.Ipe.Path.Path
instance GHC.Real.Fractional r => Data.Geometry.Transformation.IsTransformable (Data.Geometry.Ipe.Content.IpeObject r)
instance Data.Traversable.Traversable Data.Geometry.Ipe.Content.Group
instance Data.Foldable.Foldable Data.Geometry.Ipe.Content.Group
instance GHC.Base.Functor Data.Geometry.Ipe.Content.Group
instance GHC.Classes.Eq r => GHC.Classes.Eq (Data.Geometry.Ipe.Content.Group r)
instance GHC.Show.Show r => GHC.Show.Show (Data.Geometry.Ipe.Content.Group r)
instance GHC.Show.Show r => GHC.Show.Show (Data.Geometry.Ipe.Content.IpeObject r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Data.Geometry.Ipe.Content.IpeObject r)
instance GHC.Real.Fractional r => Data.Geometry.Transformation.IsTransformable (Data.Geometry.Ipe.Content.Group r)
instance GHC.Base.Functor Data.Geometry.Ipe.Content.IpeObject
instance Data.Foldable.Foldable Data.Geometry.Ipe.Content.IpeObject
instance Data.Traversable.Traversable Data.Geometry.Ipe.Content.IpeObject
instance Data.Geometry.Ipe.Content.TraverseIpeAttr 'Data.Geometry.Ipe.Attributes.Layer
instance Data.Geometry.Ipe.Content.TraverseIpeAttr 'Data.Geometry.Ipe.Attributes.Matrix
instance Data.Geometry.Ipe.Content.TraverseIpeAttr 'Data.Geometry.Ipe.Attributes.Pin
instance Data.Geometry.Ipe.Content.TraverseIpeAttr 'Data.Geometry.Ipe.Attributes.Transformations
instance Data.Geometry.Ipe.Content.TraverseIpeAttr 'Data.Geometry.Ipe.Attributes.Stroke
instance Data.Geometry.Ipe.Content.TraverseIpeAttr 'Data.Geometry.Ipe.Attributes.Fill
instance Data.Geometry.Ipe.Content.TraverseIpeAttr 'Data.Geometry.Ipe.Attributes.Pen
instance Data.Geometry.Ipe.Content.TraverseIpeAttr 'Data.Geometry.Ipe.Attributes.Size
instance Data.Geometry.Ipe.Content.TraverseIpeAttr 'Data.Geometry.Ipe.Attributes.Dash
instance Data.Geometry.Ipe.Content.TraverseIpeAttr 'Data.Geometry.Ipe.Attributes.LineCap
instance Data.Geometry.Ipe.Content.TraverseIpeAttr 'Data.Geometry.Ipe.Attributes.LineJoin
instance Data.Geometry.Ipe.Content.TraverseIpeAttr 'Data.Geometry.Ipe.Attributes.FillRule
instance Data.Geometry.Ipe.Content.TraverseIpeAttr 'Data.Geometry.Ipe.Attributes.Arrow
instance Data.Geometry.Ipe.Content.TraverseIpeAttr 'Data.Geometry.Ipe.Attributes.RArrow
instance Data.Geometry.Ipe.Content.TraverseIpeAttr 'Data.Geometry.Ipe.Attributes.Opacity
instance Data.Geometry.Ipe.Content.TraverseIpeAttr 'Data.Geometry.Ipe.Attributes.Tiling
instance Data.Geometry.Ipe.Content.TraverseIpeAttr 'Data.Geometry.Ipe.Attributes.Gradient
instance Data.Geometry.Ipe.Content.TraverseIpeAttr 'Data.Geometry.Ipe.Attributes.Clip
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Data.Geometry.Ipe.Content.AttrMapSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Data.Geometry.Ipe.Content.AttrMapSym1 r6989586621679329293)
instance GHC.Real.Fractional r => Data.Geometry.Transformation.IsTransformable (Data.Geometry.Ipe.Content.IpeSymbol r)
instance Data.Traversable.Traversable Data.Geometry.Ipe.Content.IpeSymbol
instance Data.Foldable.Foldable Data.Geometry.Ipe.Content.IpeSymbol
instance GHC.Base.Functor Data.Geometry.Ipe.Content.IpeSymbol
instance GHC.Classes.Ord r => GHC.Classes.Ord (Data.Geometry.Ipe.Content.IpeSymbol r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Data.Geometry.Ipe.Content.IpeSymbol r)
instance GHC.Show.Show r => GHC.Show.Show (Data.Geometry.Ipe.Content.IpeSymbol r)
instance Data.Traversable.Traversable Data.Geometry.Ipe.Content.MiniPage
instance Data.Foldable.Foldable Data.Geometry.Ipe.Content.MiniPage
instance GHC.Base.Functor Data.Geometry.Ipe.Content.MiniPage
instance GHC.Classes.Ord r => GHC.Classes.Ord (Data.Geometry.Ipe.Content.MiniPage r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Data.Geometry.Ipe.Content.MiniPage r)
instance GHC.Show.Show r => GHC.Show.Show (Data.Geometry.Ipe.Content.MiniPage r)
instance Data.Traversable.Traversable Data.Geometry.Ipe.Content.TextLabel
instance Data.Foldable.Foldable Data.Geometry.Ipe.Content.TextLabel
instance GHC.Base.Functor Data.Geometry.Ipe.Content.TextLabel
instance GHC.Classes.Ord r => GHC.Classes.Ord (Data.Geometry.Ipe.Content.TextLabel r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Data.Geometry.Ipe.Content.TextLabel r)
instance GHC.Show.Show r => GHC.Show.Show (Data.Geometry.Ipe.Content.TextLabel r)
instance GHC.Real.Fractional r => Data.Geometry.Transformation.IsTransformable (Data.Geometry.Ipe.Content.MiniPage r)
instance GHC.Real.Fractional r => Data.Geometry.Transformation.IsTransformable (Data.Geometry.Ipe.Content.TextLabel r)
instance GHC.Real.Fractional r => Data.Geometry.Transformation.IsTransformable (Data.Geometry.Ipe.Content.Image r)
instance GHC.Base.Functor Data.Geometry.Ipe.Content.Image
instance Data.Foldable.Foldable Data.Geometry.Ipe.Content.Image
instance Data.Traversable.Traversable Data.Geometry.Ipe.Content.Image
instance GHC.Classes.Ord r => GHC.Classes.Ord (Data.Geometry.Ipe.Content.Image r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Data.Geometry.Ipe.Content.Image r)
instance GHC.Show.Show r => GHC.Show.Show (Data.Geometry.Ipe.Content.Image r)


-- | Data type modeling the various elements in Ipe files.
module Data.Geometry.Ipe.Types
newtype LayerName
LayerName :: Text -> LayerName
layerName :: Iso' LayerName Text

-- | Image Objects
data Image r
Image :: () -> Rectangle () r -> Image r
imageData :: forall r_a1kaI. Lens' (Image r_a1kaI) ()
rect :: forall r_a1kaI r_a1kkD. Lens (Image r_a1kaI) (Image r_a1kkD) (Rectangle () r_a1kaI) (Rectangle () r_a1kkD)

-- | Text Objects
data TextLabel r
Label :: Text -> Point 2 r -> TextLabel r
data MiniPage r
MiniPage :: Text -> Point 2 r -> r -> MiniPage r
width :: MiniPage t -> t

-- | Ipe Symbols, i.e. Points
--   
--   A symbol (point) in ipe
data IpeSymbol r
Symbol :: Point 2 r -> Text -> IpeSymbol r
symbolPoint :: forall r_a1kkX r_a1l73. Lens (IpeSymbol r_a1kkX) (IpeSymbol r_a1l73) (Point 2 r_a1kkX) (Point 2 r_a1l73)
symbolName :: forall r_a1kkX. Lens' (IpeSymbol r_a1kkX) Text

-- | A path is a non-empty sequence of PathSegments.
newtype Path r
Path :: LSeq 1 (PathSegment r) -> Path r
pathSegments :: forall r_asjx r_aCKU. Iso (Path r_asjx) (Path r_aCKU) (LSeq 1 (PathSegment r_asjx)) (LSeq 1 (PathSegment r_aCKU))

-- | Paths
--   
--   Paths consist of Path Segments. PathSegments come in the following
--   forms:
data PathSegment r
PolyLineSegment :: PolyLine 2 () r -> PathSegment r
PolygonPath :: SimplePolygon () r -> PathSegment r
CubicBezierSegment :: BezierSpline 3 2 r -> PathSegment r
QuadraticBezierSegment :: BezierSpline 2 2 r -> PathSegment r
EllipseSegment :: Ellipse r -> PathSegment r
ArcSegment :: PathSegment r
SplineSegment :: PathSegment r
ClosedSplineSegment :: PathSegment r

-- | Groups and Objects
--   
--   Group Attributes
--   
--   A group is essentially a list of IpeObjects.
newtype Group r
Group :: [IpeObject r] -> Group r
groupItems :: Lens (Group r) (Group s) [IpeObject r] [IpeObject s]
data IpeObject r
IpeGroup :: IpeObject' Group r -> IpeObject r
IpeImage :: IpeObject' Image r -> IpeObject r
IpeTextLabel :: IpeObject' TextLabel r -> IpeObject r
IpeMiniPage :: IpeObject' MiniPage r -> IpeObject r
IpeUse :: IpeObject' IpeSymbol r -> IpeObject r
IpePath :: IpeObject' Path r -> IpeObject r
_IpeGroup :: forall r_a1len. Prism' (IpeObject r_a1len) (IpeObject' Group r_a1len)
_IpeImage :: forall r_a1len. Prism' (IpeObject r_a1len) (IpeObject' Image r_a1len)
_IpeTextLabel :: forall r_a1len. Prism' (IpeObject r_a1len) (IpeObject' TextLabel r_a1len)
_IpeMiniPage :: forall r_a1len. Prism' (IpeObject r_a1len) (IpeObject' MiniPage r_a1len)
_IpeUse :: forall r_a1len. Prism' (IpeObject r_a1len) (IpeObject' IpeSymbol r_a1len)
_IpePath :: forall r_a1len. Prism' (IpeObject r_a1len) (IpeObject' Path r_a1len)

-- | An IpeObject' is essentially the oject ogether with its attributes
type IpeObject' g r = g r :+ IpeAttributes g r

-- | Shorthand for constructing ipeObjects
ipeObject' :: ToObject i => i r -> IpeAttributes i r -> IpeObject r
class ToObject i
mkIpeObject :: ToObject i => IpeObject' i r -> IpeObject r
type IpeAttributes g r = Attributes' r (AttributesOf g)

-- | Attributes' :: * -&gt; [AttributeUniverse] -&gt; *
type Attributes' r = Attributes (AttrMapSym1 r)
type family AttributesOf (t :: * -> *) :: [AttributeUniverse]

-- | The mapping between the labels of the the attributes and the types of
--   the attributes with these labels. For example, the <a>Matrix</a>
--   label/attribute should have a value of type 'Matrix 3 3 r'.
type family AttrMap (r :: *) (l :: AttributeUniverse) :: *
data AttrMapSym1 (r6989586621679329293 :: Type) :: (~>) AttributeUniverse Type
attributes :: Lens' (IpeObject' g r) (IpeAttributes g r)

-- | traverse for ipe attributes
traverseIpeAttrs :: (Applicative f, AllConstrained TraverseIpeAttr (AttributesOf g)) => proxy g -> (r -> f s) -> IpeAttributes g r -> f (IpeAttributes g s)
commonAttributes :: Lens' (IpeObject r) (Attributes (AttrMapSym1 r) CommonAttributes)

-- | collect all non-group objects
flattenGroups :: [IpeObject r] -> [IpeObject r]

-- | The definition of a view make active layer into an index ?
data View
View :: [LayerName] -> LayerName -> View
layerNames :: Lens' View [LayerName]
activeLayer :: Lens' View LayerName

-- | for now we pretty much ignore these
data IpeStyle
IpeStyle :: Maybe Text -> Node Text Text -> IpeStyle
styleName :: Lens' IpeStyle (Maybe Text)
styleData :: Lens' IpeStyle (Node Text Text)
basicIpeStyle :: IpeStyle

-- | The maybe string is the encoding
data IpePreamble
IpePreamble :: Maybe Text -> Text -> IpePreamble
encoding :: Lens' IpePreamble (Maybe Text)
preambleData :: Lens' IpePreamble Text
type IpeBitmap = Text

-- | An IpePage is essentially a Group, together with a list of layers and
--   a list of views.
data IpePage r
IpePage :: [LayerName] -> [View] -> [IpeObject r] -> IpePage r
layers :: forall r_a1xw4. Lens' (IpePage r_a1xw4) [LayerName]
views :: forall r_a1xw4. Lens' (IpePage r_a1xw4) [View]
content :: forall r_a1xw4 r_a1xzN. Lens (IpePage r_a1xw4) (IpePage r_a1xzN) [IpeObject r_a1xw4] [IpeObject r_a1xzN]

-- | Creates an empty page with one layer and view.
emptyPage :: IpePage r

-- | Creates a simple page with a single view.
fromContent :: [IpeObject r] -> IpePage r

-- | This allows you to filter the objects on some layer.
--   
--   <pre>
--   &gt;&gt;&gt; let page = IpePage [] [] []
--   
--   &gt;&gt;&gt; page^..content.onLayer "myLayer"
--   []
--   </pre>
onLayer :: LayerName -> Getting (Endo [IpeObject r]) [IpeObject r] (IpeObject r)

-- | Gets all objects that are visible in the given view.
--   
--   Note that views are indexed starting from 0. If the page does not have
--   any explicit view definitions, this function returns an empty list.
--   
--   <pre>
--   &gt;&gt;&gt; let page = IpePage [] [] []
--   
--   &gt;&gt;&gt; page^.contentInView 0
--   []
--   </pre>
contentInView :: Word -> Getter (IpePage r) [IpeObject r]

-- | Makes sure that the page has at least one layer and at least one view,
--   essentially matching the behaviour of ipe. In particular,
--   
--   <ul>
--   <li>if the page does not have any layers, it creates a layer named
--   "alpha", and</li>
--   <li>if the page does not have any views, it creates a view in which
--   all layers are visible.</li>
--   </ul>
withDefaults :: IpePage r -> IpePage r

-- | A complete ipe file
data IpeFile r
IpeFile :: Maybe IpePreamble -> [IpeStyle] -> NonEmpty (IpePage r) -> IpeFile r
preamble :: forall r_a1xAg. Lens' (IpeFile r_a1xAg) (Maybe IpePreamble)
styles :: forall r_a1xAg. Lens' (IpeFile r_a1xAg) [IpeStyle]
pages :: forall r_a1xAg r_a1xUq. Lens (IpeFile r_a1xAg) (IpeFile r_a1xUq) (NonEmpty (IpePage r_a1xAg)) (NonEmpty (IpePage r_a1xUq))

-- | Convenience constructor for creating an ipe file without preamble and
--   with the default stylesheet.
ipeFile :: NonEmpty (IpePage r) -> IpeFile r

-- | Convenience function to construct an ipe file consisting of a single
--   page.
singlePageFile :: IpePage r -> IpeFile r

-- | Create a single page ipe file from a list of IpeObjects
singlePageFromContent :: [IpeObject r] -> IpeFile r
instance GHC.Show.Show r => GHC.Show.Show (Data.Geometry.Ipe.Types.IpeFile r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Data.Geometry.Ipe.Types.IpeFile r)
instance GHC.Show.Show r => GHC.Show.Show (Data.Geometry.Ipe.Types.IpePage r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Data.Geometry.Ipe.Types.IpePage r)
instance GHC.Classes.Ord Data.Geometry.Ipe.Types.IpePreamble
instance GHC.Show.Show Data.Geometry.Ipe.Types.IpePreamble
instance GHC.Read.Read Data.Geometry.Ipe.Types.IpePreamble
instance GHC.Classes.Eq Data.Geometry.Ipe.Types.IpePreamble
instance GHC.Show.Show Data.Geometry.Ipe.Types.IpeStyle
instance GHC.Classes.Eq Data.Geometry.Ipe.Types.IpeStyle
instance GHC.Show.Show Data.Geometry.Ipe.Types.View
instance GHC.Classes.Ord Data.Geometry.Ipe.Types.View
instance GHC.Classes.Eq Data.Geometry.Ipe.Types.View

module Data.Geometry.Ipe.Matrix

-- | Takes and applies the ipe Matrix attribute of this item.
applyMatrix' :: (IsTransformable (i r), Matrix ∈ AttributesOf i, Dimension (i r) ~ 2, r ~ NumType (i r)) => IpeObject' i r -> IpeObject' i r

-- | Applies the matrix to an ipe object if it has one.
applyMatrix :: Fractional r => IpeObject r -> IpeObject r
applyMatrices :: Fractional r => IpeFile r -> IpeFile r
applyMatricesPage :: Fractional r => IpePage r -> IpePage r

module Data.Geometry.Ipe.Reader

-- | Given a file path, tries to read an ipe file
readRawIpeFile :: (Coordinate r, Eq r) => FilePath -> IO (Either ConversionError (IpeFile r))

-- | Given a file path, tries to read an ipe file.
--   
--   This function applies all matrices to objects.
readIpeFile :: (Coordinate r, Eq r) => FilePath -> IO (Either ConversionError (IpeFile r))

-- | Since most Ipe file contain only one page, we provide a shortcut for
--   that as well.
--   
--   This function applies all matrices, and it makes sure there is at
--   least one layer and view in the page.
readSinglePageFile :: (Coordinate r, Eq r) => FilePath -> IO (Either ConversionError (IpePage r))

-- | Tries to read a single page file, throws an error when this fails. See
--   <a>readSinglePageFile</a> for further details.
readSinglePageFileThrow :: (Coordinate r, Eq r) => FilePath -> IO (IpePage r)
type ConversionError = Text

-- | Given a Bytestring, try to parse the bytestring into anything that is
--   IpeReadable, i.e. any of the Ipe elements.
fromIpeXML :: IpeRead (t r) => ByteString -> Either ConversionError (t r)

-- | Reads the data from a Bytestring into a proper Node
readXML :: ByteString -> Either ConversionError (Node Text Text)

-- | Reading an ipe elemtn from a Text value
class IpeReadText t
ipeReadText :: IpeReadText t => Text -> Either ConversionError t

-- | Reading an ipe lement from Xml
class IpeRead t
ipeRead :: IpeRead t => Node Text Text -> Either ConversionError t

-- | Basically IpeReadText for attributes. This class is not really meant
--   to be implemented directly. Just define an IpeReadText instance for
--   the type (Apply f at), then the generic instance below takes care of
--   looking up the name of the attribute, and calling the right
--   ipeReadText value. This class is just so that reifyConstraint in
--   <a>ipeReadRec</a> can select the right typeclass when building the
--   rec.
class IpeReadAttr t
ipeReadAttr :: IpeReadAttr t => Text -> Node Text Text -> Either ConversionError t
ipeReadTextWith :: (Text -> Either t v) -> Text -> Either ConversionError (IpeValue v)

-- | If we can ipeRead an ipe element, and we can ipeReadAttrs its
--   attributes we can properly read an ipe object using ipeReadObject
ipeReadObject :: (IpeRead (i r), f ~ AttrMapSym1 r, ats ~ AttributesOf i, RecApplicative ats, ReifyConstraint IpeReadAttr (Attr f) ats, RecAll (Attr f) ats IpeReadAttr, AllConstrained IpeAttrName ats) => Proxy i -> proxy r -> Node Text Text -> Either ConversionError (i r :+ IpeAttributes i r)

-- | Reader for records. Given a proxy of some ipe type i, and a proxy of
--   an coordinate type r, read the IpeAttributes for i from the xml node.
ipeReadAttrs :: forall proxy proxy' i r f ats. (f ~ AttrMapSym1 r, ats ~ AttributesOf i, ReifyConstraint IpeReadAttr (Attr f) ats, RecApplicative ats, RecAll (Attr f) ats IpeReadAttr, AllConstrained IpeAttrName ats) => proxy i -> proxy' r -> Node Text Text -> Either ConversionError (IpeAttributes i r)

-- | Reading the Attributes into a Rec (Attr f), all based on the types of
--   f (the type family mapping labels to types), and a list of labels
--   (ats).
ipeReadRec :: forall f ats. (RecApplicative ats, ReifyConstraint IpeReadAttr (Attr f) ats, RecAll (Attr f) ats IpeReadAttr, AllConstrained IpeAttrName ats) => Proxy f -> Proxy ats -> Node Text Text -> Either ConversionError (Rec (Attr f) ats)

-- | Represent stuff that can be used as a coordinate in ipe. (similar to
--   show/read)
class Fractional r => Coordinate r
fromSeq :: Coordinate r => Integer -> Maybe (Int, Integer) -> r
fromSeq :: (Coordinate r, Ord r, Fractional r) => Integer -> Maybe (Int, Integer) -> r
instance forall u (f :: u Data.Singletons.Internal.~> *) (at :: u). Data.Geometry.Ipe.Reader.IpeReadText (Data.Singletons.Internal.Apply f at) => Data.Geometry.Ipe.Reader.IpeReadAttr (Data.Geometry.Ipe.Attributes.Attr f at)
instance Data.Geometry.Ipe.PathParser.Coordinate r => Data.Geometry.Ipe.Reader.IpeRead (Data.Geometry.Ipe.Content.IpeSymbol r)
instance (Data.Geometry.Ipe.PathParser.Coordinate r, GHC.Classes.Eq r) => Data.Geometry.Ipe.Reader.IpeRead (Data.Geometry.Ipe.Path.Path r)
instance Data.Geometry.Ipe.PathParser.Coordinate r => Data.Geometry.Ipe.Reader.IpeRead (Data.Geometry.Ipe.Content.TextLabel r)
instance Data.Geometry.Ipe.PathParser.Coordinate r => Data.Geometry.Ipe.Reader.IpeRead (Data.Geometry.Ipe.Content.MiniPage r)
instance Data.Geometry.Ipe.PathParser.Coordinate r => Data.Geometry.Ipe.Reader.IpeRead (Data.Geometry.Ipe.Content.Image r)
instance (Data.Geometry.Ipe.PathParser.Coordinate r, GHC.Classes.Eq r) => Data.Geometry.Ipe.Reader.IpeRead (Data.Geometry.Ipe.Content.IpeObject r)
instance (Data.Geometry.Ipe.PathParser.Coordinate r, GHC.Classes.Eq r) => Data.Geometry.Ipe.Reader.IpeRead (Data.Geometry.Ipe.Content.Group r)
instance Data.Geometry.Ipe.Reader.IpeRead Data.Geometry.Ipe.Layer.LayerName
instance Data.Geometry.Ipe.Reader.IpeRead Data.Geometry.Ipe.Types.View
instance (Data.Geometry.Ipe.PathParser.Coordinate r, GHC.Classes.Eq r) => Data.Geometry.Ipe.Reader.IpeRead (Data.Geometry.Ipe.Types.IpePage r)
instance (Data.Geometry.Ipe.PathParser.Coordinate r, GHC.Classes.Eq r) => Data.Geometry.Ipe.Reader.IpeRead (Data.Geometry.Ipe.Types.IpeFile r)
instance Data.Geometry.Ipe.Reader.IpeReadText Data.Text.Internal.Text
instance Data.Geometry.Ipe.Reader.IpeReadText GHC.Types.Int
instance Data.Geometry.Ipe.PathParser.Coordinate r => Data.Geometry.Ipe.Reader.IpeReadText (Data.Geometry.Point.Internal.Point 2 r)
instance Data.Geometry.Ipe.PathParser.Coordinate r => Data.Geometry.Ipe.Reader.IpeReadText (Data.Geometry.Matrix.Matrix 3 3 r)
instance Data.Geometry.Ipe.Reader.IpeReadText Data.Geometry.Ipe.Layer.LayerName
instance Data.Geometry.Ipe.Reader.IpeReadText Data.Geometry.Ipe.Attributes.PinType
instance Data.Geometry.Ipe.Reader.IpeReadText Data.Geometry.Ipe.Attributes.TransformationTypes
instance Data.Geometry.Ipe.Reader.IpeReadText Data.Geometry.Ipe.Attributes.FillType
instance Data.Geometry.Ipe.PathParser.Coordinate r => Data.Geometry.Ipe.Reader.IpeReadText (Data.Geometry.Ipe.Attributes.IpeArrow r)
instance Data.Geometry.Ipe.PathParser.Coordinate r => Data.Geometry.Ipe.Reader.IpeReadText (Data.Geometry.Ipe.Attributes.IpeDash r)
instance Data.Geometry.Ipe.PathParser.Coordinate r => Data.Geometry.Ipe.Reader.IpeReadText (Data.Geometry.Box.Internal.Rectangle () r)
instance Data.Geometry.Ipe.PathParser.Coordinate r => Data.Geometry.Ipe.Reader.IpeReadText (Data.Colour.RGB.RGB r)
instance Data.Geometry.Ipe.PathParser.Coordinate r => Data.Geometry.Ipe.Reader.IpeReadText (Data.Geometry.Ipe.Color.IpeColor r)
instance Data.Geometry.Ipe.PathParser.Coordinate r => Data.Geometry.Ipe.Reader.IpeReadText (Data.Geometry.Ipe.Attributes.IpePen r)
instance Data.Geometry.Ipe.PathParser.Coordinate r => Data.Geometry.Ipe.Reader.IpeReadText (Data.Geometry.Ipe.Attributes.IpeSize r)
instance Data.Geometry.Ipe.PathParser.Coordinate r => Data.Geometry.Ipe.Reader.IpeReadText [Data.Geometry.Ipe.Path.Operation r]
instance (Data.Geometry.Ipe.PathParser.Coordinate r, GHC.Classes.Eq r) => Data.Geometry.Ipe.Reader.IpeReadText (GHC.Base.NonEmpty (Data.Geometry.Ipe.Path.PathSegment r))
instance (Data.Geometry.Ipe.PathParser.Coordinate r, GHC.Classes.Eq r) => Data.Geometry.Ipe.Reader.IpeReadText (Data.Geometry.Ipe.Path.Path r)


-- | Functions that help reading geometric values from ipe images.
module Data.Geometry.Ipe.FromIpe

-- | Extracts the point from a Symbol. When creating a symbol this creates
--   a disk that supports a stroke color.
_asPoint :: Prism' (IpeSymbol r) (Point 2 r)

-- | Try to convert a path into a line segment, fails if the path is not a
--   line segment or a polyline with more than two points.
_asLineSegment :: Prism' (Path r) (LineSegment 2 () r)

-- | Tries to convert a path into a rectangle.
_asRectangle :: forall r. (Num r, Ord r) => Prism' (Path r) (Rectangle () r)

-- | Convert to a triangle
_asTriangle :: Prism' (Path r) (Triangle 2 () r)

-- | Convert to a polyline. Ignores all non-polyline parts
--   
--   <pre>
--   &gt;&gt;&gt; testPath ^? _asPolyLine
--   Just (PolyLine {_points = LSeq (fromList [Point2 [0,0] :+ (),Point2 [10,10] :+ (),Point2 [200,100] :+ ()])})
--   </pre>
_asPolyLine :: Prism' (Path r) (PolyLine 2 () r)
_asSomePolygon :: Prism' (Path r) (SomePolygon () r)

-- | Convert to a simple polygon
_asSimplePolygon :: Prism' (Path r) (Polygon Simple () r)

-- | Convert to a multipolygon
_asMultiPolygon :: Prism' (Path r) (MultiPolygon () r)

-- | Use the first prism to select the ipe object to depicle with, and the
--   second how to select the geometry object from there on. Then we can
--   select the geometry object, directly with its attributes here.
--   
--   <pre>
--   &gt;&gt;&gt; testObject ^? _withAttrs _IpePath _asPolyLine
--   Just (PolyLine {_points = LSeq (fromList [Point2 [0,0] :+ (),Point2 [10,10] :+ (),Point2 [200,100] :+ ()])} :+ Attrs {NoAttr, NoAttr, NoAttr, NoAttr, Attr IpeColor (Named "red"), NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr})
--   </pre>
_withAttrs :: Prism' (IpeObject r) (i r :+ IpeAttributes i r) -> Prism' (i r) g -> Prism' (IpeObject r) (g :+ IpeAttributes i r)
class HasDefaultFromIpe g where {
    type family DefaultFromIpe g :: * -> *;
}
defaultFromIpe :: (HasDefaultFromIpe g, r ~ NumType g) => Prism' (IpeObject r) (g :+ IpeAttributes (DefaultFromIpe g) r)

-- | Read all g's from some ipe page(s).
readAll :: forall g r. (HasDefaultFromIpe g, r ~ NumType g) => IpePage r -> [g :+ IpeAttributes (DefaultFromIpe g) r]

-- | Convenience function from reading all g's from an ipe file. If there
--   is an error reading or parsing the file the error is "thrown away".
readAllFrom :: (HasDefaultFromIpe g, r ~ NumType g, Coordinate r, Eq r) => FilePath -> IO [g :+ IpeAttributes (DefaultFromIpe g) r]
instance Data.Geometry.Ipe.FromIpe.HasDefaultFromIpe (Data.Geometry.Point.Internal.Point 2 r)
instance Data.Geometry.Ipe.FromIpe.HasDefaultFromIpe (Data.Geometry.LineSegment.Internal.LineSegment 2 () r)
instance Data.Geometry.Ipe.FromIpe.HasDefaultFromIpe (Data.Geometry.Ellipse.Ellipse r)
instance (GHC.Float.Floating r, GHC.Classes.Eq r) => Data.Geometry.Ipe.FromIpe.HasDefaultFromIpe (Data.Geometry.Ball.Circle () r)
instance (GHC.Float.Floating r, GHC.Classes.Eq r) => Data.Geometry.Ipe.FromIpe.HasDefaultFromIpe (Data.Geometry.Ball.Disk () r)
instance Data.Geometry.Ipe.FromIpe.HasDefaultFromIpe (Data.Geometry.PolyLine.PolyLine 2 () r)
instance Data.Geometry.Ipe.FromIpe.HasDefaultFromIpe (Data.Geometry.Polygon.Core.SimplePolygon () r)
instance Data.Geometry.Ipe.FromIpe.HasDefaultFromIpe (Data.Geometry.Polygon.Core.MultiPolygon () r)


-- | Functions that help drawing geometric values in ipe. An <a>IpeOut</a>
--   is essenitally a function that converts a geometric type g into an
--   IpeObject.
--   
--   We also proivde a <a>HasDefaultIpeOut</a> typeclass that defines a
--   default conversion function from a geometry type g to an ipe type.
module Data.Geometry.Ipe.IpeOut
type IpeOut g i r = g -> IpeObject' i r

-- | Add attributes to an IpeObject'
(!) :: IpeObject' i r -> IpeAttributes i r -> IpeObject' i r

-- | Render an ipe object
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     iO $ defIO myPolygon ! attr SFill (IpeColor "blue")
--                          ! attr SLayer "alpha"
--                          ! attr SLayer "beta"
--   :}
--   IpePath (Path {_pathSegments = LSeq (fromList [PolygonPath SimplePolygon CSeq [Point2 [0,0] :+ (),Point2 [10,10] :+ (),Point2 [100,200] :+ ()]])} :+ Attrs {Attr LayerName {_layerName = "beta"}, NoAttr, NoAttr, NoAttr, NoAttr, Attr IpeColor (Named "blue"), NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     iO $ ipeGroup [ iO $ ipePolygon myPolygon ! attr SFill (IpeColor "red")
--                   ] ! attr SLayer "alpha"
--   :}
--   IpeGroup (Group [IpePath (Path {_pathSegments = LSeq (fromList [PolygonPath SimplePolygon CSeq [Point2 [0,0] :+ (),Point2 [10,10] :+ (),Point2 [100,200] :+ ()]])} :+ Attrs {NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, Attr IpeColor (Named "red"), NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr})] :+ Attrs {Attr LayerName {_layerName = "alpha"}, NoAttr, NoAttr, NoAttr, NoAttr})
--   </pre>
iO :: ToObject i => IpeObject' i r -> IpeObject r

-- | Render to an ipe object using the defIO IpeOut
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     iO'' myPolygon $  attr SFill (IpeColor "red")
--                    &lt;&gt; attr SLayer "alpha"
--                    &lt;&gt; attr SLayer "beta"
--   :}
--   IpePath (Path {_pathSegments = LSeq (fromList [PolygonPath SimplePolygon CSeq [Point2 [0,0] :+ (),Point2 [10,10] :+ (),Point2 [100,200] :+ ()]])} :+ Attrs {Attr LayerName {_layerName = "beta"}, NoAttr, NoAttr, NoAttr, NoAttr, Attr IpeColor (Named "red"), NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iO'' [ myPolygon , myPolygon ] $ attr SLayer "alpha"
--   IpeGroup (Group [IpePath (Path {_pathSegments = LSeq (fromList [PolygonPath SimplePolygon CSeq [Point2 [0,0] :+ (),Point2 [10,10] :+ (),Point2 [100,200] :+ ()]])} :+ Attrs {NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr}),IpePath (Path {_pathSegments = LSeq (fromList [PolygonPath SimplePolygon CSeq [Point2 [0,0] :+ (),Point2 [10,10] :+ (),Point2 [100,200] :+ ()]])} :+ Attrs {NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr, NoAttr})] :+ Attrs {Attr LayerName {_layerName = "alpha"}, NoAttr, NoAttr, NoAttr, NoAttr})
--   </pre>
iO'' :: (HasDefaultIpeOut g, NumType g ~ r, DefaultIpeOut g ~ i, ToObject i) => g -> IpeAttributes i r -> IpeObject r

-- | generate an ipe object without any specific attributes
iO' :: HasDefaultIpeOut g => g -> IpeObject (NumType g)

-- | Class that specifies a default conversion from a geometry type g into
--   an ipe object.
class ToObject (DefaultIpeOut g) => HasDefaultIpeOut g where {
    type family DefaultIpeOut g :: * -> *;
}
defIO :: HasDefaultIpeOut g => IpeOut g (DefaultIpeOut g) (NumType g)
ipeMark :: Text -> IpeOut (Point 2 r) IpeSymbol r
ipeDiskMark :: IpeOut (Point 2 r) IpeSymbol r

-- | Size of the default bounding box used to clip lines and half-lines in
--   the default IpeOuts.
defaultBox :: Num r => Rectangle () r

-- | Renders a line as a Path. The line is clipped to the <a>defaultBox</a>
ipeLine :: (Ord r, Fractional r) => IpeOut (Line 2 r) Path r

-- | Renders the line in the given box.
--   
--   pre: the intersection of the box with the line is non-empty
ipeLineIn :: forall p r. (Ord r, Fractional r) => Rectangle p r -> IpeOut (Line 2 r) Path r

-- | Renders an Halfine.
--   
--   pre: the intersection of the box with the line is non-empty
ipeHalfLine :: (Ord r, Fractional r) => IpeOut (HalfLine 2 r) Path r

-- | Renders the HalfLine in the given box.
--   
--   pre: the intersection of the box with the line is non-empty
ipeHalfLineIn :: forall p r. (Ord r, Fractional r) => Rectangle p r -> IpeOut (HalfLine 2 r) Path r
ipeLineSegment :: IpeOut (LineSegment 2 p r) Path r
ipePolyLine :: IpeOut (PolyLine 2 p r) Path r
ipeEllipse :: IpeOut (Ellipse r) Path r
ipeCircle :: Floating r => IpeOut (Circle p r) Path r
ipeDisk :: Floating r => IpeOut (Disk p r) Path r

-- | Helper to construct a path from a singleton item
path :: PathSegment r -> Path r
pathSegment :: LineSegment 2 p r -> PathSegment r

-- | Draw a polygon
ipePolygon :: IpeOut (Polygon t p r) Path r

-- | Draw a Rectangle
ipeRectangle :: Num r => IpeOut (Rectangle p r) Path r
ipeGroup :: Foldable f => IpeOut (f (IpeObject r)) Group r

-- | Creates an text label
ipeLabel :: IpeOut (Text :+ Point 2 r) TextLabel r

-- | Annotate an IpeOut with a label
labelled :: (Show lbl, NumType g ~ r, ToObject i) => (g -> Point 2 r) -> IpeOut g i r -> IpeOut (g :+ lbl) Group r
instance (Data.Geometry.Ipe.IpeOut.HasDefaultIpeOut g, a GHC.Types.~ Data.Geometry.Ipe.Content.IpeAttributes (Data.Geometry.Ipe.IpeOut.DefaultIpeOut g) (Data.Geometry.Properties.NumType g)) => Data.Geometry.Ipe.IpeOut.HasDefaultIpeOut (g Data.Ext.:+ a)
instance Data.Geometry.Ipe.IpeOut.HasDefaultIpeOut a => Data.Geometry.Ipe.IpeOut.HasDefaultIpeOut [a]
instance Data.Geometry.Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.Point.Internal.Point 2 r)
instance Data.Geometry.Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.LineSegment.Internal.LineSegment 2 p r)
instance Data.Geometry.Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.PolyLine.PolyLine 2 p r)
instance (GHC.Real.Fractional r, GHC.Classes.Ord r) => Data.Geometry.Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.Line.Internal.Line 2 r)
instance (GHC.Real.Fractional r, GHC.Classes.Ord r) => Data.Geometry.Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.HalfLine.HalfLine 2 r)
instance Data.Geometry.Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.Polygon.Core.Polygon t p r)
instance Data.Geometry.Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.Polygon.Core.SomePolygon p r)
instance Data.Geometry.Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.Polygon.Convex.ConvexPolygon p r)
instance Data.Geometry.Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.Ellipse.Ellipse r)
instance GHC.Float.Floating r => Data.Geometry.Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.Ball.Disk p r)
instance GHC.Float.Floating r => Data.Geometry.Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.Ball.Circle p r)
instance GHC.Num.Num r => Data.Geometry.Ipe.IpeOut.HasDefaultIpeOut (Data.Geometry.Box.Internal.Rectangle p r)


module Data.Geometry.Ipe.Writer

-- | Given a prism to convert something of type g into an ipe file, a file
--   path, and a g. Convert the geometry and write it to file.
--   
--   Write an IpeFiele to file.
writeIpeFile :: IpeWriteText r => FilePath -> IpeFile r -> IO ()

-- | Convert to ipe XML and write the output to a file.
writeIpeFile' :: IpeWrite t => t -> FilePath -> IO ()

-- | Creates a single page ipe file with the given page
writeIpePage :: IpeWriteText r => FilePath -> IpePage r -> IO ()

-- | Convert to Ipe xml
toIpeXML :: IpeWrite t => t -> Maybe ByteString

-- | Convert the input to ipeXml, and prints it to standard out in such a
--   way that the copied text can be pasted into ipe as a geometry object.
printAsIpeSelection :: IpeWrite t => t -> IO ()

-- | Convert input into an ipe selection.
toIpeSelectionXML :: IpeWrite t => t -> Maybe ByteString

-- | Types that correspond to an XML Element. All instances should produce
--   an Element. If the type should produce a Node with the Text
--   constructor, use the <a>IpeWriteText</a> typeclass instead.
class IpeWrite t
ipeWrite :: IpeWrite t => t -> Maybe (Node Text Text)

-- | For types that can produce a text value
class IpeWriteText t
ipeWriteText :: IpeWriteText t => t -> Maybe Text

-- | Functon to write all attributes in a Rec
ipeWriteAttrs :: (RecordToList rs, RMap rs, ReifyConstraint IpeWriteText (Attr f) rs, AllConstrained IpeAttrName rs, RecAll (Attr f) rs IpeWriteText) => Attributes f rs -> [(Text, Text)]

-- | Writing the attribute values
writeAttrValues :: (RMap rs, ReifyConstraint IpeWriteText f rs, RecAll f rs IpeWriteText) => Rec f rs -> Rec (Const (Maybe Text)) rs
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWriteText (Data.Geometry.Ipe.Attributes.IpeSize r)
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWriteText (Data.Geometry.Ipe.Attributes.IpePen r)
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWriteText (Data.Geometry.Ipe.Color.IpeColor r)
instance Data.Geometry.Ipe.Writer.IpeWriteText Data.Geometry.Ipe.Layer.LayerName
instance Data.Geometry.Ipe.Writer.IpeWrite t => Data.Geometry.Ipe.Writer.IpeWrite [t]
instance Data.Geometry.Ipe.Writer.IpeWrite t => Data.Geometry.Ipe.Writer.IpeWrite (GHC.Base.NonEmpty t)
instance (Data.Geometry.Ipe.Writer.IpeWrite l, Data.Geometry.Ipe.Writer.IpeWrite r) => Data.Geometry.Ipe.Writer.IpeWrite (Data.Either.Either l r)
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWrite (Data.Geometry.Ipe.Content.IpeSymbol r)
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWrite (Data.Geometry.Ipe.Path.Path r)
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWrite (Data.Geometry.Ipe.Content.Group r)
instance (Data.Vinyl.TypeLevel.AllConstrained Data.Geometry.Ipe.Attributes.IpeAttrName rs, Data.Vinyl.Core.RecordToList rs, Data.Vinyl.Core.RMap rs, Data.Vinyl.Core.ReifyConstraint Data.Geometry.Ipe.Writer.IpeWriteText (Data.Geometry.Ipe.Attributes.Attr f) rs, Data.Vinyl.TypeLevel.RecAll (Data.Geometry.Ipe.Attributes.Attr f) rs Data.Geometry.Ipe.Writer.IpeWriteText, Data.Geometry.Ipe.Writer.IpeWrite g) => Data.Geometry.Ipe.Writer.IpeWrite (g Data.Ext.:+ Data.Geometry.Ipe.Attributes.Attributes f rs)
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWrite (Data.Geometry.Ipe.Content.MiniPage r)
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWrite (Data.Geometry.Ipe.Content.Image r)
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWrite (Data.Geometry.Ipe.Content.TextLabel r)
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWrite (Data.Geometry.Ipe.Content.IpeObject r)
instance Data.Geometry.Ipe.Writer.IpeWrite Data.Geometry.Ipe.Layer.LayerName
instance Data.Geometry.Ipe.Writer.IpeWrite Data.Geometry.Ipe.Types.View
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWrite (Data.Geometry.Ipe.Types.IpePage r)
instance Data.Geometry.Ipe.Writer.IpeWrite Data.Geometry.Ipe.Types.IpeStyle
instance Data.Geometry.Ipe.Writer.IpeWrite Data.Geometry.Ipe.Types.IpePreamble
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWrite (Data.Geometry.Ipe.Types.IpeFile r)
instance (Data.Geometry.Ipe.Writer.IpeWriteText r, Data.Geometry.Ipe.Writer.IpeWrite p) => Data.Geometry.Ipe.Writer.IpeWrite (Data.Geometry.PolyLine.PolyLine 2 p r)
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWrite (Data.Geometry.LineSegment.Internal.LineSegment 2 p r)
instance Data.Geometry.Ipe.Writer.IpeWrite ()
instance forall u (f :: u Data.Singletons.Internal.~> *) (at :: u). Data.Geometry.Ipe.Writer.IpeWriteText (Data.Singletons.Internal.Apply f at) => Data.Geometry.Ipe.Writer.IpeWriteText (Data.Geometry.Ipe.Attributes.Attr f at)
instance (Data.Geometry.Ipe.Writer.IpeWriteText l, Data.Geometry.Ipe.Writer.IpeWriteText r) => Data.Geometry.Ipe.Writer.IpeWriteText (Data.Either.Either l r)
instance Data.Geometry.Ipe.Writer.IpeWriteText Data.Text.Internal.Text
instance Data.Geometry.Ipe.Writer.IpeWriteText GHC.Base.String
instance Data.Geometry.Ipe.Writer.IpeWriteText GHC.Types.Double
instance Data.Geometry.Ipe.Writer.IpeWriteText GHC.Types.Float
instance Data.Geometry.Ipe.Writer.IpeWriteText GHC.Types.Int
instance Data.Geometry.Ipe.Writer.IpeWriteText GHC.Integer.Type.Integer
instance Data.Geometry.Ipe.Writer.IpeWriteText (Data.RealNumber.Rational.RealNumber p)
instance Data.Fixed.HasResolution p => Data.Geometry.Ipe.Writer.IpeWriteText (Data.Fixed.Fixed p)
instance GHC.Real.Integral a => Data.Geometry.Ipe.Writer.IpeWriteText (GHC.Real.Ratio a)
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWriteText (Data.Geometry.Point.Internal.Point 2 r)
instance Data.Geometry.Ipe.Writer.IpeWriteText v => Data.Geometry.Ipe.Writer.IpeWriteText (Data.Geometry.Ipe.Value.IpeValue v)
instance Data.Geometry.Ipe.Writer.IpeWriteText Data.Geometry.Ipe.Attributes.TransformationTypes
instance Data.Geometry.Ipe.Writer.IpeWriteText Data.Geometry.Ipe.Attributes.PinType
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWriteText (Data.Colour.RGB.RGB r)
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWriteText (Data.Geometry.Ipe.Attributes.IpeDash r)
instance Data.Geometry.Ipe.Writer.IpeWriteText Data.Geometry.Ipe.Attributes.FillType
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWriteText (Data.Geometry.Ipe.Attributes.IpeArrow r)
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWriteText (Data.Geometry.Ipe.Path.Path r)
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWriteText (Data.Geometry.Matrix.Matrix 3 3 r)
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWriteText (Data.Geometry.Ipe.Path.Operation r)
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWriteText (Data.Geometry.PolyLine.PolyLine 2 () r)
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWriteText (Data.Geometry.Polygon.Core.Polygon t () r)
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWriteText (Data.Geometry.BezierSpline.BezierSpline 3 2 r)
instance Data.Geometry.Ipe.Writer.IpeWriteText r => Data.Geometry.Ipe.Writer.IpeWriteText (Data.Geometry.Ipe.Path.PathSegment r)
instance Data.Geometry.Ipe.Writer.IpeWriteText ()


-- | Reexports the functionality for reading and writing Ipe files.
module Data.Geometry.Ipe
newtype IpeColor r
IpeColor :: IpeValue (RGB r) -> IpeColor r

module Data.Geometry.PlanarSubdivision.Draw
drawColoredPlanarSubdivision :: IpeOut (PlanarSubdivision s v e (Maybe (IpeColor r)) r) Group r

-- | Draws only the values for which we have a Just attribute
drawPlanarSubdivision :: forall s r. IpeOut (PlanarSubdivision s (Maybe (IpeAttributes IpeSymbol r)) (Maybe (IpeAttributes Path r)) (Maybe (IpeAttributes Path r)) r) Group r

-- | Draw everything using the defaults
drawPlanarSubdivision' :: forall s v e f r. IpeOut (PlanarSubdivision s v e f r) Group r
type MIO g i r = g -> Maybe (IpeObject' i r)
drawPlanarSubdivisionWith :: (ToObject vi, ToObject ei, ToObject fi) => MIO (VertexId' s, VertexData r v) vi r -> MIO (Dart s, LineSegment 2 v r :+ e) ei r -> MIO (FaceId' s, SomePolygon v r :+ f) fi r -> IpeOut (PlanarSubdivision s v e f r) Group r


-- | Functions for Drawing arrangements
module Data.Geometry.Arrangement.Draw

-- | Draws an arrangement
drawArrangement :: IpeOut (Arrangement s l v e f r) Group r

-- | Draws an arrangement
drawColoredArrangement :: IpeOut (Arrangement s l v e (Maybe (IpeColor r)) r) Group r

module Data.Geometry.QuadTree.Draw
drawCell :: Fractional r => IpeOut (Cell r) Path r
drawQuadTree :: (Fractional r, Ord r) => IpeOut (QuadTree v p r) Group r
drawQuadTreeWith :: (ToObject i, Fractional r, Ord r) => IpeOut (p :+ Cell r) i r -> IpeOut (QuadTree v p r) Group r
quadTreeLevels :: forall i r v p. (ToObject i, Fractional r, Ord r) => IpeOut (TreeNode v p :+ Cell r) i r -> IpeOut (QuadTree v p r) Group r

module Data.Geometry.Triangulation.Draw

-- | Draws a triangulation
drawTriangulation :: IpeOut (Triangulation p r) Group r

module Data.PlaneGraph.Draw

-- | Draws a planegraph using Marks, LineSegments, and simple polygons for
--   vertices, edges, and faces, respectively. Uses the default IpeOuts to
--   draw these elements.
drawPlaneGraph :: forall s v e f r. IpeOut (PlaneGraph s v e f r) Group r

-- | Draws a planegraph using Marks, LineSegments, and simple polygons for
--   vertices, edges, and faces, respectively.
drawPlaneGraphWith :: (Point 2 r -> v -> Maybe (IpeObject r)) -> (LineSegment 2 v r -> e -> Maybe (IpeObject r)) -> (SimplePolygon v r -> f -> Maybe (IpeObject r)) -> IpeOut (PlaneGraph s v e f r) Group r

-- | Draw a planegraph using the given functions. Fully generic in how we
--   draw the objects.
genericDrawPlaneGraphWith :: ((VertexId' s :+ v) -> IpeObject r) -> ((Dart s :+ e) -> IpeObject r) -> ((FaceId' s :+ f) -> IpeObject r) -> IpeOut (PlaneGraph s v e f r) Group r

module Data.Tree.Draw

-- | Draws a tree
drawTree' :: IpeOut (Tree (Point 2 r :+ p)) Group r
treeEdges :: Tree a -> [(a, a)]
