<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><span id="line-2"></span><span class="hs-comment">--------------------------------------------------------------------------------</span><span>
</span><span id="line-3"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-4"></span><span class="hs-comment">-- Module      :  Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer</span><span>
</span><span id="line-5"></span><span class="hs-comment">-- Copyright   :  (C) Frank Staals</span><span>
</span><span id="line-6"></span><span class="hs-comment">-- License     :  see the LICENSE file</span><span>
</span><span id="line-7"></span><span class="hs-comment">-- Maintainer  :  Frank Staals</span><span>
</span><span id="line-8"></span><span class="hs-comment">--------------------------------------------------------------------------------</span><span>
</span><span id="line-9"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer</span><span>
</span><span id="line-10"></span><span>  </span><span class="hs-special">(</span><span>
</span><span id="line-11"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Divide &amp; Conqueror Delaunay Triangulation</span></span><span>
</span><span id="line-12"></span><span>    </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delaunayTriangulation"><span class="hs-identifier">delaunayTriangulation</span></a></span><span>
</span><span id="line-13"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-14"></span><span>
</span><span id="line-15"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Algorithms.Geometry.ConvexHull.GrahamScan.html"><span class="hs-identifier">Algorithms.Geometry.ConvexHull.GrahamScan</span></a></span><span>       </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">GS</span></span><span>
</span><span id="line-16"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html"><span class="hs-identifier">Algorithms.Geometry.DelaunayTriangulation.Types</span></a></span><span>
</span><span id="line-17"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Lens</span></span><span>
</span><span id="line-18"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Monad.Reader</span></span><span>
</span><span id="line-19"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Monad.State</span></span><span>
</span><span id="line-20"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.BinaryTree</span></span><span>
</span><span id="line-21"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.CircularList</span></span><span>                               </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">CL</span></span><span>
</span><span id="line-22"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.CircularList.Util</span></span><span>                          </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">CU</span></span><span>
</span><span id="line-23"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Ext</span></span><span>
</span><span id="line-24"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Foldable</span></span><span>                                   </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">F</span></span><span>
</span><span id="line-25"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Function</span></span><span>                                   </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">on</span></span><span class="hs-special">)</span><span>
</span><span id="line-26"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Data.Geometry.html"><span class="hs-identifier">Data.Geometry</span></a></span><span>                                   </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Geometry.Transformation.html#rotateTo"><span class="hs-identifier">rotateTo</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-27"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Data.Geometry.Ball.html"><span class="hs-identifier">Data.Geometry.Ball</span></a></span><span>                              </span><span class="hs-special">(</span><span class="annot"><a href="Data.Geometry.Ball.html#disk"><span class="hs-identifier">disk</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Geometry.Ball.html#insideBall"><span class="hs-identifier">insideBall</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-28"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Data.Geometry.Polygon.Convex.html"><span class="hs-identifier">Data.Geometry.Polygon.Convex</span></a></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Data.Geometry.Polygon.Convex.html#ConvexPolygon"><span class="hs-identifier">ConvexPolygon</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Geometry.Polygon.Convex.html#simplePolygon"><span class="hs-identifier">simplePolygon</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-29"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Data.Geometry.Polygon.Convex.html"><span class="hs-identifier">Data.Geometry.Polygon.Convex</span></a></span><span>                    </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Convex</span></span><span>
</span><span id="line-30"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.IntMap.Strict</span></span><span>                              </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">IM</span></span><span>
</span><span id="line-31"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.List</span></span><span>                                       </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">L</span></span><span>
</span><span id="line-32"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.List.NonEmpty</span></span><span>                              </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">NonEmpty</span></span><span>
</span><span id="line-33"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map</span></span><span>                                        </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">M</span></span><span>
</span><span id="line-34"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span>                                      </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">fromJust</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">fromMaybe</span></span><span class="hs-special">)</span><span>
</span><span id="line-35"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Measured.Size</span></span><span>
</span><span id="line-36"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Vector</span></span><span>                                     </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">V</span></span><span>
</span><span id="line-37"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Vector.Circular.Util</span></span><span>                       </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">CV</span></span><span>
</span><span id="line-38"></span><span>
</span><span id="line-39"></span><span class="hs-comment">-------------------------------------------------------------------------------</span><span>
</span><span id="line-40"></span><span class="hs-comment">-- * Divide &amp; Conqueror Delaunay Triangulation</span><span>
</span><span id="line-41"></span><span class="hs-comment">--</span><span>
</span><span id="line-42"></span><span class="hs-comment">-- Implementation of the Divide &amp; Conqueror algorithm as described in:</span><span>
</span><span id="line-43"></span><span class="hs-comment">--</span><span>
</span><span id="line-44"></span><span class="hs-comment">-- Two Algorithms for Constructing a Delaunay Triangulation</span><span>
</span><span id="line-45"></span><span class="hs-comment">-- Lee and Schachter</span><span>
</span><span id="line-46"></span><span class="hs-comment">-- International Journal of Computer and Information Sciences, Vol 9, No. 3, 1980</span><span>
</span><span id="line-47"></span><span class="hs-comment">--</span><span>
</span><span id="line-48"></span><span class="hs-comment">-- We store all adjacency lists in clockwise order</span><span>
</span><span id="line-49"></span><span class="hs-comment">--</span><span>
</span><span id="line-50"></span><span class="hs-comment">-- : If v on the convex hull, then its first entry in the adj. lists is its CCW</span><span>
</span><span id="line-51"></span><span class="hs-comment">-- successor (i.e. its predecessor) on the convex hull</span><span>
</span><span id="line-52"></span><span class="hs-comment">--</span><span>
</span><span id="line-53"></span><span class="hs-comment">-- Rotating Right &lt;-&gt; rotate clockwise</span><span>
</span><span id="line-54"></span><span>
</span><span id="line-55"></span><span class="hs-comment">-- | Computes the delaunay triangulation of a set of points.</span><span>
</span><span id="line-56"></span><span class="hs-comment">--</span><span>
</span><span id="line-57"></span><span class="hs-comment">-- Running time: \(O(n \log n)\)</span><span>
</span><span id="line-58"></span><span class="hs-comment">-- (note: We use an IntMap in the implementation. So maybe actually \(O(n \log^2 n)\))</span><span>
</span><span id="line-59"></span><span class="hs-comment">--</span><span>
</span><span id="line-60"></span><span class="hs-comment">-- pre: the input is a *SET*, i.e. contains no duplicate points. (If the</span><span>
</span><span id="line-61"></span><span class="hs-comment">-- input does contain duplicate points, the implementation throws them away)</span><span>
</span><span id="line-62"></span><span id="local-6989586621679968232"><span id="local-6989586621679968233"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delaunayTriangulation"><span class="hs-identifier hs-type">delaunayTriangulation</span></a></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679968233"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fractional</span></span><span> </span><span class="annot"><a href="#local-6989586621679968233"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-63"></span><span>                           </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NonEmpty.NonEmpty</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Geometry.Point.Internal.html#Point"><span class="hs-identifier hs-type">Point</span></a></span><span> </span><span class="annot"><span class="hs-number">2</span></span><span> </span><span class="annot"><a href="#local-6989586621679968233"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="#local-6989586621679968232"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Triangulation"><span class="hs-identifier hs-type">Triangulation</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968232"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968233"><span class="hs-identifier hs-type">r</span></a></span></span></span><span>
</span><span id="line-64"></span><span id="delaunayTriangulation"><span class="annot"><span class="annottext">delaunayTriangulation :: NonEmpty (Point 2 r :+ p) -&gt; Triangulation p r
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delaunayTriangulation"><span class="hs-identifier hs-var hs-var">delaunayTriangulation</span></a></span></span><span> </span><span id="local-6989586621679968231"><span class="annot"><span class="annottext">pts' :: NonEmpty (Point 2 r :+ p)
</span><a href="#local-6989586621679968231"><span class="hs-identifier hs-var">pts'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
-&gt; Vector (Point 2 r :+ p)
-&gt; Vector (CList VertexID)
-&gt; Triangulation p r
forall p r.
Map (Point 2 r) VertexID
-&gt; Vector (Point 2 r :+ p)
-&gt; Vector (CList VertexID)
-&gt; Triangulation p r
</span><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Triangulation"><span class="hs-identifier hs-var">Triangulation</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><a href="#local-6989586621679968229"><span class="hs-identifier hs-var">vtxMap</span></a></span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621679968228"><span class="hs-identifier hs-var">ptsV</span></a></span><span> </span><span class="annot"><span class="annottext">Vector (CList VertexID)
</span><a href="#local-6989586621679968227"><span class="hs-identifier hs-var">adjV</span></a></span><span>
</span><span id="line-65"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-66"></span><span>    </span><span id="local-6989586621679968226"><span class="annot"><span class="annottext">pts :: NonEmpty (Point 2 r :+ p)
</span><a href="#local-6989586621679968226"><span class="hs-identifier hs-var hs-var">pts</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NonEmpty (Point 2 r :+ p) -&gt; NonEmpty (Point 2 r :+ p)
forall a b. Eq a =&gt; NonEmpty (a :+ b) -&gt; NonEmpty (a :+ b)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#nub%27"><span class="hs-identifier hs-var">nub'</span></a></span><span> </span><span class="annot"><span class="annottext">(NonEmpty (Point 2 r :+ p) -&gt; NonEmpty (Point 2 r :+ p))
-&gt; (NonEmpty (Point 2 r :+ p) -&gt; NonEmpty (Point 2 r :+ p))
-&gt; NonEmpty (Point 2 r :+ p)
-&gt; NonEmpty (Point 2 r :+ p)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">((Point 2 r :+ p) -&gt; (Point 2 r :+ p) -&gt; Ordering)
-&gt; NonEmpty (Point 2 r :+ p) -&gt; NonEmpty (Point 2 r :+ p)
forall a. (a -&gt; a -&gt; Ordering) -&gt; NonEmpty a -&gt; NonEmpty a
</span><span class="hs-identifier hs-var">NonEmpty.sortBy</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Point 2 r -&gt; Point 2 r -&gt; Ordering
forall a. Ord a =&gt; a -&gt; a -&gt; Ordering
</span><span class="hs-identifier hs-var">compare</span></span><span> </span><span class="annot"><span class="annottext">(Point 2 r -&gt; Point 2 r -&gt; Ordering)
-&gt; ((Point 2 r :+ p) -&gt; Point 2 r)
-&gt; (Point 2 r :+ p)
-&gt; (Point 2 r :+ p)
-&gt; Ordering
forall b c a. (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c
</span><span class="hs-operator hs-var">`on`</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Point 2 r :+ p)
-&gt; Getting (Point 2 r) (Point 2 r :+ p) (Point 2 r) -&gt; Point 2 r
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">Getting (Point 2 r) (Point 2 r :+ p) (Point 2 r)
forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(NonEmpty (Point 2 r :+ p) -&gt; NonEmpty (Point 2 r :+ p))
-&gt; NonEmpty (Point 2 r :+ p) -&gt; NonEmpty (Point 2 r :+ p)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">NonEmpty (Point 2 r :+ p)
</span><a href="#local-6989586621679968231"><span class="hs-identifier hs-var">pts'</span></a></span><span>
</span><span id="line-67"></span><span>    </span><span id="local-6989586621679968228"><span class="annot"><span class="annottext">ptsV :: Vector (Point 2 r :+ p)
</span><a href="#local-6989586621679968228"><span class="hs-identifier hs-var hs-var">ptsV</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Point 2 r :+ p] -&gt; Vector (Point 2 r :+ p)
forall a. [a] -&gt; Vector a
</span><span class="hs-identifier hs-var">V.fromList</span></span><span> </span><span class="annot"><span class="annottext">([Point 2 r :+ p] -&gt; Vector (Point 2 r :+ p))
-&gt; (NonEmpty (Point 2 r :+ p) -&gt; [Point 2 r :+ p])
-&gt; NonEmpty (Point 2 r :+ p)
-&gt; Vector (Point 2 r :+ p)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">NonEmpty (Point 2 r :+ p) -&gt; [Point 2 r :+ p]
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; [a]
</span><span class="hs-identifier hs-var">F.toList</span></span><span> </span><span class="annot"><span class="annottext">(NonEmpty (Point 2 r :+ p) -&gt; Vector (Point 2 r :+ p))
-&gt; NonEmpty (Point 2 r :+ p) -&gt; Vector (Point 2 r :+ p)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">NonEmpty (Point 2 r :+ p)
</span><a href="#local-6989586621679968226"><span class="hs-identifier hs-var">pts</span></a></span><span>
</span><span id="line-68"></span><span>    </span><span id="local-6989586621679968229"><span class="annot"><span class="annottext">vtxMap :: Map (Point 2 r) VertexID
</span><a href="#local-6989586621679968229"><span class="hs-identifier hs-var hs-var">vtxMap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Point 2 r, VertexID)] -&gt; Map (Point 2 r) VertexID
forall k a. Ord k =&gt; [(k, a)] -&gt; Map k a
</span><span class="hs-identifier hs-var">M.fromList</span></span><span> </span><span class="annot"><span class="annottext">([(Point 2 r, VertexID)] -&gt; Map (Point 2 r) VertexID)
-&gt; [(Point 2 r, VertexID)] -&gt; Map (Point 2 r) VertexID
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Point 2 r] -&gt; [VertexID] -&gt; [(Point 2 r, VertexID)]
forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">((Point 2 r :+ p) -&gt; Point 2 r) -&gt; [Point 2 r :+ p] -&gt; [Point 2 r]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Point 2 r :+ p)
-&gt; Getting (Point 2 r) (Point 2 r :+ p) (Point 2 r) -&gt; Point 2 r
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">Getting (Point 2 r) (Point 2 r :+ p) (Point 2 r)
forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([Point 2 r :+ p] -&gt; [Point 2 r])
-&gt; (Vector (Point 2 r :+ p) -&gt; [Point 2 r :+ p])
-&gt; Vector (Point 2 r :+ p)
-&gt; [Point 2 r]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p) -&gt; [Point 2 r :+ p]
forall a. Vector a -&gt; [a]
</span><span class="hs-identifier hs-var">V.toList</span></span><span> </span><span class="annot"><span class="annottext">(Vector (Point 2 r :+ p) -&gt; [Point 2 r])
-&gt; Vector (Point 2 r :+ p) -&gt; [Point 2 r]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621679968228"><span class="hs-identifier hs-var">ptsV</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-number">0</span></span><span class="hs-glyph">..</span><span class="hs-special">]</span><span>
</span><span id="line-69"></span><span>
</span><span id="line-70"></span><span>    </span><span id="local-6989586621679968215"><span class="annot"><span class="annottext">tr :: BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621679968215"><span class="hs-identifier hs-var hs-var">tr</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Elem (Point 2 r :+ p) -&gt; Point 2 r :+ p
forall a. Elem a -&gt; a
</span><span class="hs-identifier hs-var hs-var">_unElem</span></span><span> </span><span class="annot"><span class="annottext">(Elem (Point 2 r :+ p) -&gt; Point 2 r :+ p)
-&gt; BinLeafTree Size (Elem (Point 2 r :+ p))
-&gt; BinLeafTree Size (Point 2 r :+ p)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">NonEmpty (Point 2 r :+ p)
-&gt; BinLeafTree Size (Elem (Point 2 r :+ p))
forall a. NonEmpty a -&gt; BinLeafTree Size (Elem a)
</span><span class="hs-identifier hs-var">asBalancedBinLeafTree</span></span><span> </span><span class="annot"><span class="annottext">NonEmpty (Point 2 r :+ p)
</span><a href="#local-6989586621679968226"><span class="hs-identifier hs-var">pts</span></a></span><span>
</span><span id="line-71"></span><span>
</span><span id="line-72"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679968211"><span class="annot"><span class="annottext">adj :: Adj
</span><a href="#local-6989586621679968211"><span class="hs-identifier hs-var">adj</span></a></span></span><span class="hs-special">,</span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
-&gt; Mapping p r -&gt; (Adj, ConvexPolygon (p :+ VertexID) r)
forall r p.
(Ord r, Fractional r) =&gt;
BinLeafTree Size (Point 2 r :+ p)
-&gt; Mapping p r -&gt; (Adj, ConvexPolygon (p :+ VertexID) r)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delaunayTriangulation%27"><span class="hs-identifier hs-var">delaunayTriangulation'</span></a></span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621679968215"><span class="hs-identifier hs-var">tr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><a href="#local-6989586621679968229"><span class="hs-identifier hs-var">vtxMap</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621679968228"><span class="hs-identifier hs-var">ptsV</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-73"></span><span>    </span><span id="local-6989586621679968227"><span class="annot"><span class="annottext">adjV :: Vector (CList VertexID)
</span><a href="#local-6989586621679968227"><span class="hs-identifier hs-var hs-var">adjV</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[CList VertexID] -&gt; Vector (CList VertexID)
forall a. [a] -&gt; Vector a
</span><span class="hs-identifier hs-var">V.fromList</span></span><span> </span><span class="annot"><span class="annottext">([CList VertexID] -&gt; Vector (CList VertexID))
-&gt; (Adj -&gt; [CList VertexID]) -&gt; Adj -&gt; Vector (CList VertexID)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Adj -&gt; [CList VertexID]
forall a. IntMap a -&gt; [a]
</span><span class="hs-identifier hs-var">IM.elems</span></span><span> </span><span class="annot"><span class="annottext">(Adj -&gt; Vector (CList VertexID)) -&gt; Adj -&gt; Vector (CList VertexID)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Adj
</span><a href="#local-6989586621679968211"><span class="hs-identifier hs-var">adj</span></a></span><span>
</span><span id="line-74"></span><span>
</span><span id="line-75"></span><span>
</span><span id="line-76"></span><span>
</span><span id="line-77"></span><span class="hs-comment">-- : pre: - Input points are sorted lexicographically</span><span>
</span><span id="line-78"></span><span id="local-6989586621679968478"><span id="local-6989586621679968479"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delaunayTriangulation%27"><span class="hs-identifier hs-type">delaunayTriangulation'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679968479"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fractional</span></span><span> </span><span class="annot"><a href="#local-6989586621679968479"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-79"></span><span>                       </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">BinLeafTree</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Size</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Geometry.Point.Internal.html#Point"><span class="hs-identifier hs-type">Point</span></a></span><span> </span><span class="annot"><span class="hs-number">2</span></span><span> </span><span class="annot"><a href="#local-6989586621679968479"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="#local-6989586621679968478"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-80"></span><span>                       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Mapping"><span class="hs-identifier hs-type">Mapping</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968478"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968479"><span class="hs-identifier hs-type">r</span></a></span><span>
</span><span id="line-81"></span><span>                       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Adj"><span class="hs-identifier hs-type">Adj</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Geometry.Polygon.Convex.html#ConvexPolygon"><span class="hs-identifier hs-type">ConvexPolygon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679968478"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679968479"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-82"></span><span id="delaunayTriangulation%27"><span class="annot"><span class="annottext">delaunayTriangulation' :: BinLeafTree Size (Point 2 r :+ p)
-&gt; Mapping p r -&gt; (Adj, ConvexPolygon (p :+ VertexID) r)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delaunayTriangulation%27"><span class="hs-identifier hs-var hs-var">delaunayTriangulation'</span></a></span></span><span> </span><span id="local-6989586621679968208"><span class="annot"><span class="annottext">pts :: BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621679968208"><span class="hs-identifier hs-var">pts</span></a></span></span><span> </span><span id="local-6989586621679968207"><span class="annot"><span class="annottext">mapping' :: Mapping p r
</span><a href="#local-6989586621679968207"><span class="hs-identifier hs-var">mapping'</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span id="local-6989586621679968206"><span class="annot"><span class="annottext">vtxMap :: Map (Point 2 r) VertexID
</span><a href="#local-6989586621679968206"><span class="hs-identifier hs-var">vtxMap</span></a></span></span><span class="hs-special">,</span><span class="hs-identifier">_</span><span class="hs-special">)</span><span>
</span><span id="line-83"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p) -&gt; Size
forall a. BinLeafTree Size a -&gt; Size
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#size%27"><span class="hs-identifier hs-var">size'</span></a></span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621679968208"><span class="hs-identifier hs-var">pts</span></a></span><span> </span><span class="annot"><span class="annottext">Size -&gt; Size -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Leaf</span></span><span> </span><span id="local-6989586621679968203"><span class="annot"><span class="annottext">p :: Point 2 r :+ p
</span><a href="#local-6989586621679968203"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621679968208"><span class="hs-identifier hs-var">pts</span></a></span><span>
</span><span id="line-84"></span><span>                         </span><span id="local-6989586621679968202"><span class="annot"><span class="annottext">i :: VertexID
</span><a href="#local-6989586621679968202"><span class="hs-identifier hs-var hs-var">i</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID -&gt; Point 2 r -&gt; VertexID
forall k a. Ord k =&gt; Map k a -&gt; k -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27"><span class="hs-identifier hs-var">lookup'</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><a href="#local-6989586621679968206"><span class="hs-identifier hs-var">vtxMap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621679968203"><span class="hs-identifier hs-var">p</span></a></span><span class="annot"><span class="annottext">(Point 2 r :+ p)
-&gt; Getting (Point 2 r) (Point 2 r :+ p) (Point 2 r) -&gt; Point 2 r
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">Getting (Point 2 r) (Point 2 r :+ p) (Point 2 r)
forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span>
</span><span id="line-85"></span><span>                     </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VertexID -&gt; CList VertexID -&gt; Adj
forall a. VertexID -&gt; a -&gt; IntMap a
</span><span class="hs-identifier hs-var">IM.singleton</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968202"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
forall a. CList a
</span><span class="hs-identifier hs-var">CL.empty</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">SimplePolygon (p :+ VertexID) r -&gt; ConvexPolygon (p :+ VertexID) r
forall p r. SimplePolygon p r -&gt; ConvexPolygon p r
</span><a href="Data.Geometry.Polygon.Convex.html#ConvexPolygon"><span class="hs-identifier hs-var">ConvexPolygon</span></a></span><span> </span><span class="annot"><span class="annottext">(SimplePolygon (p :+ VertexID) r
 -&gt; ConvexPolygon (p :+ VertexID) r)
-&gt; SimplePolygon (p :+ VertexID) r
-&gt; ConvexPolygon (p :+ VertexID) r
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Point 2 r :+ (p :+ VertexID)] -&gt; SimplePolygon (p :+ VertexID) r
forall r p. [Point 2 r :+ p] -&gt; SimplePolygon p r
</span><a href="Data.Geometry.Polygon.Core.html#unsafeFromPoints"><span class="hs-identifier hs-var">unsafeFromPoints</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">(Point 2 r :+ p) -&gt; VertexID -&gt; Point 2 r :+ (p :+ VertexID)
forall c e e'. (c :+ e) -&gt; e' -&gt; c :+ (e :+ e')
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#withID"><span class="hs-identifier hs-var">withID</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621679968203"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968202"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-86"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p) -&gt; Size
forall a. BinLeafTree Size a -&gt; Size
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#size%27"><span class="hs-identifier hs-var">size'</span></a></span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621679968208"><span class="hs-identifier hs-var">pts</span></a></span><span> </span><span class="annot"><span class="annottext">Size -&gt; Size -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;=</span></span><span> </span><span class="annot"><span class="hs-number">3</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679968194"><span class="annot"><span class="annottext">pts' :: NonEmpty (Point 2 r :+ (p :+ VertexID))
</span><a href="#local-6989586621679968194"><span class="hs-identifier hs-var hs-var">pts'</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Point 2 r :+ (p :+ VertexID)]
-&gt; NonEmpty (Point 2 r :+ (p :+ VertexID))
forall a. [a] -&gt; NonEmpty a
</span><span class="hs-identifier hs-var">NonEmpty.fromList</span></span><span>
</span><span id="line-87"></span><span>                               </span><span class="annot"><span class="annottext">([Point 2 r :+ (p :+ VertexID)]
 -&gt; NonEmpty (Point 2 r :+ (p :+ VertexID)))
-&gt; (BinLeafTree Size (Point 2 r :+ p)
    -&gt; [Point 2 r :+ (p :+ VertexID)])
-&gt; BinLeafTree Size (Point 2 r :+ p)
-&gt; NonEmpty (Point 2 r :+ (p :+ VertexID))
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">((Point 2 r :+ p) -&gt; Point 2 r :+ (p :+ VertexID))
-&gt; [Point 2 r :+ p] -&gt; [Point 2 r :+ (p :+ VertexID)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679968192"><span class="annot"><span class="annottext">p :: Point 2 r :+ p
</span><a href="#local-6989586621679968192"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Point 2 r :+ p) -&gt; VertexID -&gt; Point 2 r :+ (p :+ VertexID)
forall c e e'. (c :+ e) -&gt; e' -&gt; c :+ (e :+ e')
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#withID"><span class="hs-identifier hs-var">withID</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621679968192"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID -&gt; Point 2 r -&gt; VertexID
forall k a. Ord k =&gt; Map k a -&gt; k -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27"><span class="hs-identifier hs-var">lookup'</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><a href="#local-6989586621679968206"><span class="hs-identifier hs-var">vtxMap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621679968192"><span class="hs-identifier hs-var">p</span></a></span><span class="annot"><span class="annottext">(Point 2 r :+ p)
-&gt; Getting (Point 2 r) (Point 2 r :+ p) (Point 2 r) -&gt; Point 2 r
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">Getting (Point 2 r) (Point 2 r :+ p) (Point 2 r)
forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-88"></span><span>                               </span><span class="annot"><span class="annottext">([Point 2 r :+ p] -&gt; [Point 2 r :+ (p :+ VertexID)])
-&gt; (BinLeafTree Size (Point 2 r :+ p) -&gt; [Point 2 r :+ p])
-&gt; BinLeafTree Size (Point 2 r :+ p)
-&gt; [Point 2 r :+ (p :+ VertexID)]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p) -&gt; [Point 2 r :+ p]
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; [a]
</span><span class="hs-identifier hs-var">F.toList</span></span><span> </span><span class="annot"><span class="annottext">(BinLeafTree Size (Point 2 r :+ p)
 -&gt; NonEmpty (Point 2 r :+ (p :+ VertexID)))
-&gt; BinLeafTree Size (Point 2 r :+ p)
-&gt; NonEmpty (Point 2 r :+ (p :+ VertexID))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621679968208"><span class="hs-identifier hs-var">pts</span></a></span><span>
</span><span id="line-89"></span><span>                         </span><span id="local-6989586621679968191"><span class="annot"><span class="annottext">ch :: ConvexPolygon (p :+ VertexID) r
</span><a href="#local-6989586621679968191"><span class="hs-identifier hs-var hs-var">ch</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NonEmpty (Point 2 r :+ (p :+ VertexID))
-&gt; ConvexPolygon (p :+ VertexID) r
forall r p.
(Ord r, Num r) =&gt;
NonEmpty (Point 2 r :+ p) -&gt; ConvexPolygon p r
</span><a href="Algorithms.Geometry.ConvexHull.GrahamScan.html#convexHull"><span class="hs-identifier hs-var">GS.convexHull</span></a></span><span> </span><span class="annot"><span class="annottext">NonEmpty (Point 2 r :+ (p :+ VertexID))
</span><a href="#local-6989586621679968194"><span class="hs-identifier hs-var">pts'</span></a></span><span>
</span><span id="line-90"></span><span>                     </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Mapping p r -&gt; ConvexPolygon (p :+ VertexID) r -&gt; Adj
forall r p q.
Ord r =&gt;
Mapping p r -&gt; ConvexPolygon (p :+ q) r -&gt; Adj
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#fromHull"><span class="hs-identifier hs-var">fromHull</span></a></span><span> </span><span class="annot"><span class="annottext">Mapping p r
</span><a href="#local-6989586621679968207"><span class="hs-identifier hs-var">mapping'</span></a></span><span> </span><span class="annot"><span class="annottext">ConvexPolygon (p :+ VertexID) r
</span><a href="#local-6989586621679968191"><span class="hs-identifier hs-var">ch</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ConvexPolygon (p :+ VertexID) r
</span><a href="#local-6989586621679968191"><span class="hs-identifier hs-var">ch</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-91"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Node</span></span><span> </span><span id="local-6989586621679968187"><span class="annot"><span class="annottext">lt :: BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621679968187"><span class="hs-identifier hs-var">lt</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679968186"><span class="annot"><span class="annottext">rt :: BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621679968186"><span class="hs-identifier hs-var">rt</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621679968208"><span class="hs-identifier hs-var">pts</span></a></span><span>
</span><span id="line-92"></span><span>                         </span><span class="hs-special">(</span><span id="local-6989586621679968185"><span class="annot"><span class="annottext">ld :: Adj
</span><a href="#local-6989586621679968185"><span class="hs-identifier hs-var">ld</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679968184"><span class="annot"><span class="annottext">lch :: ConvexPolygon (p :+ VertexID) r
</span><a href="#local-6989586621679968184"><span class="hs-identifier hs-var">lch</span></a></span></span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
-&gt; Mapping p r -&gt; (Adj, ConvexPolygon (p :+ VertexID) r)
forall r p.
(Ord r, Fractional r) =&gt;
BinLeafTree Size (Point 2 r :+ p)
-&gt; Mapping p r -&gt; (Adj, ConvexPolygon (p :+ VertexID) r)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delaunayTriangulation%27"><span class="hs-identifier hs-var">delaunayTriangulation'</span></a></span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621679968187"><span class="hs-identifier hs-var">lt</span></a></span><span> </span><span class="annot"><span class="annottext">Mapping p r
</span><a href="#local-6989586621679968207"><span class="hs-identifier hs-var">mapping'</span></a></span><span>
</span><span id="line-93"></span><span>                         </span><span class="hs-special">(</span><span id="local-6989586621679968183"><span class="annot"><span class="annottext">rd :: Adj
</span><a href="#local-6989586621679968183"><span class="hs-identifier hs-var">rd</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679968182"><span class="annot"><span class="annottext">rch :: ConvexPolygon (p :+ VertexID) r
</span><a href="#local-6989586621679968182"><span class="hs-identifier hs-var">rch</span></a></span></span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
-&gt; Mapping p r -&gt; (Adj, ConvexPolygon (p :+ VertexID) r)
forall r p.
(Ord r, Fractional r) =&gt;
BinLeafTree Size (Point 2 r :+ p)
-&gt; Mapping p r -&gt; (Adj, ConvexPolygon (p :+ VertexID) r)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delaunayTriangulation%27"><span class="hs-identifier hs-var">delaunayTriangulation'</span></a></span><span> </span><span class="annot"><span class="annottext">BinLeafTree Size (Point 2 r :+ p)
</span><a href="#local-6989586621679968186"><span class="hs-identifier hs-var">rt</span></a></span><span> </span><span class="annot"><span class="annottext">Mapping p r
</span><a href="#local-6989586621679968207"><span class="hs-identifier hs-var">mapping'</span></a></span><span>
</span><span id="line-94"></span><span>                         </span><span class="hs-special">(</span><span id="local-6989586621679968181"><span class="annot"><span class="annottext">ch :: ConvexPolygon (p :+ VertexID) r
</span><a href="#local-6989586621679968181"><span class="hs-identifier hs-var">ch</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679968180"><span class="annot"><span class="annottext">bt :: LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621679968180"><span class="hs-identifier hs-var">bt</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679968179"><span class="annot"><span class="annottext">ut :: LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621679968179"><span class="hs-identifier hs-var">ut</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConvexPolygon (p :+ VertexID) r
-&gt; ConvexPolygon (p :+ VertexID) r
-&gt; (ConvexPolygon (p :+ VertexID) r,
    LineSegment 2 (p :+ VertexID) r, LineSegment 2 (p :+ VertexID) r)
forall r p.
(Num r, Ord r) =&gt;
ConvexPolygon p r
-&gt; ConvexPolygon p r
-&gt; (ConvexPolygon p r, LineSegment 2 p r, LineSegment 2 p r)
</span><a href="Data.Geometry.Polygon.Convex.html#merge"><span class="hs-identifier hs-var">Convex.merge</span></a></span><span> </span><span class="annot"><span class="annottext">ConvexPolygon (p :+ VertexID) r
</span><a href="#local-6989586621679968184"><span class="hs-identifier hs-var">lch</span></a></span><span> </span><span class="annot"><span class="annottext">ConvexPolygon (p :+ VertexID) r
</span><a href="#local-6989586621679968182"><span class="hs-identifier hs-var">rch</span></a></span><span>
</span><span id="line-95"></span><span>                     </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Adj
-&gt; Adj
-&gt; LineSegment 2 (p :+ VertexID) r
-&gt; LineSegment 2 (p :+ VertexID) r
-&gt; Mapping p r
-&gt; Firsts
-&gt; Adj
forall r p.
(Ord r, Fractional r) =&gt;
Adj
-&gt; Adj
-&gt; LineSegment 2 (p :+ VertexID) r
-&gt; LineSegment 2 (p :+ VertexID) r
-&gt; Mapping p r
-&gt; Firsts
-&gt; Adj
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#merge"><span class="hs-identifier hs-var">merge</span></a></span><span> </span><span class="annot"><span class="annottext">Adj
</span><a href="#local-6989586621679968185"><span class="hs-identifier hs-var">ld</span></a></span><span> </span><span class="annot"><span class="annottext">Adj
</span><a href="#local-6989586621679968183"><span class="hs-identifier hs-var">rd</span></a></span><span> </span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621679968180"><span class="hs-identifier hs-var">bt</span></a></span><span> </span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621679968179"><span class="hs-identifier hs-var">ut</span></a></span><span> </span><span class="annot"><span class="annottext">Mapping p r
</span><a href="#local-6989586621679968207"><span class="hs-identifier hs-var">mapping'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConvexPolygon (p :+ VertexID) r -&gt; Firsts
forall p r. ConvexPolygon (p :+ VertexID) r -&gt; Firsts
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#firsts"><span class="hs-identifier hs-var">firsts</span></a></span><span> </span><span class="annot"><span class="annottext">ConvexPolygon (p :+ VertexID) r
</span><a href="#local-6989586621679968181"><span class="hs-identifier hs-var">ch</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ConvexPolygon (p :+ VertexID) r
</span><a href="#local-6989586621679968181"><span class="hs-identifier hs-var">ch</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-96"></span><span>
</span><span id="line-97"></span><span class="hs-comment">--------------------------------------------------------------------------------</span><span>
</span><span id="line-98"></span><span class="hs-comment">-- * Implementation</span><span>
</span><span id="line-99"></span><span>
</span><span id="line-100"></span><span class="hs-comment">-- | Mapping that says for each vtx in the convex hull what the first entry in</span><span>
</span><span id="line-101"></span><span class="hs-comment">-- the adj. list should be. The input polygon is given in Clockwise order</span><span>
</span><span id="line-102"></span><span id="local-6989586621679968446"><span id="local-6989586621679968447"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#firsts"><span class="hs-identifier hs-type">firsts</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Geometry.Polygon.Convex.html#ConvexPolygon"><span class="hs-identifier hs-type">ConvexPolygon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679968447"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679968446"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IM.IntMap</span></span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span></span></span><span>
</span><span id="line-103"></span><span id="firsts"><span class="annot"><span class="annottext">firsts :: ConvexPolygon (p :+ VertexID) r -&gt; Firsts
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#firsts"><span class="hs-identifier hs-var hs-var">firsts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(VertexID, VertexID)] -&gt; Firsts
forall a. [(VertexID, a)] -&gt; IntMap a
</span><span class="hs-identifier hs-var">IM.fromList</span></span><span> </span><span class="annot"><span class="annottext">([(VertexID, VertexID)] -&gt; Firsts)
-&gt; (ConvexPolygon (p :+ VertexID) r -&gt; [(VertexID, VertexID)])
-&gt; ConvexPolygon (p :+ VertexID) r
-&gt; Firsts
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(LineSegment 2 (p :+ VertexID) r -&gt; (VertexID, VertexID))
-&gt; [LineSegment 2 (p :+ VertexID) r] -&gt; [(VertexID, VertexID)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679968174"><span class="annot"><span class="annottext">s :: LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621679968174"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621679968174"><span class="hs-identifier hs-var">s</span></a></span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
-&gt; Getting VertexID (LineSegment 2 (p :+ VertexID) r) VertexID
-&gt; VertexID
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">((Point 2 r :+ (p :+ VertexID))
 -&gt; Const VertexID (Point 2 r :+ (p :+ VertexID)))
-&gt; LineSegment 2 (p :+ VertexID) r
-&gt; Const VertexID (LineSegment 2 (p :+ VertexID) r)
forall t. HasEnd t =&gt; Lens' t (EndCore t :+ EndExtra t)
</span><a href="Data.Geometry.Interval.html#end"><span class="hs-identifier hs-var">end</span></a></span><span class="annot"><span class="annottext">(((Point 2 r :+ (p :+ VertexID))
  -&gt; Const VertexID (Point 2 r :+ (p :+ VertexID)))
 -&gt; LineSegment 2 (p :+ VertexID) r
 -&gt; Const VertexID (LineSegment 2 (p :+ VertexID) r))
-&gt; ((VertexID -&gt; Const VertexID VertexID)
    -&gt; (Point 2 r :+ (p :+ VertexID))
    -&gt; Const VertexID (Point 2 r :+ (p :+ VertexID)))
-&gt; Getting VertexID (LineSegment 2 (p :+ VertexID) r) VertexID
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span class="annot"><span class="annottext">((p :+ VertexID) -&gt; Const VertexID (p :+ VertexID))
-&gt; (Point 2 r :+ (p :+ VertexID))
-&gt; Const VertexID (Point 2 r :+ (p :+ VertexID))
forall core extra extra'.
Lens (core :+ extra) (core :+ extra') extra extra'
</span><span class="hs-identifier hs-var">extra</span></span><span class="annot"><span class="annottext">(((p :+ VertexID) -&gt; Const VertexID (p :+ VertexID))
 -&gt; (Point 2 r :+ (p :+ VertexID))
 -&gt; Const VertexID (Point 2 r :+ (p :+ VertexID)))
-&gt; ((VertexID -&gt; Const VertexID VertexID)
    -&gt; (p :+ VertexID) -&gt; Const VertexID (p :+ VertexID))
-&gt; (VertexID -&gt; Const VertexID VertexID)
-&gt; (Point 2 r :+ (p :+ VertexID))
-&gt; Const VertexID (Point 2 r :+ (p :+ VertexID))
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span class="annot"><span class="annottext">(VertexID -&gt; Const VertexID VertexID)
-&gt; (p :+ VertexID) -&gt; Const VertexID (p :+ VertexID)
forall core extra extra'.
Lens (core :+ extra) (core :+ extra') extra extra'
</span><span class="hs-identifier hs-var">extra</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621679968174"><span class="hs-identifier hs-var">s</span></a></span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
-&gt; Getting VertexID (LineSegment 2 (p :+ VertexID) r) VertexID
-&gt; VertexID
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">((Point 2 r :+ (p :+ VertexID))
 -&gt; Const VertexID (Point 2 r :+ (p :+ VertexID)))
-&gt; LineSegment 2 (p :+ VertexID) r
-&gt; Const VertexID (LineSegment 2 (p :+ VertexID) r)
forall t. HasStart t =&gt; Lens' t (StartCore t :+ StartExtra t)
</span><a href="Data.Geometry.Interval.html#start"><span class="hs-identifier hs-var">start</span></a></span><span class="annot"><span class="annottext">(((Point 2 r :+ (p :+ VertexID))
  -&gt; Const VertexID (Point 2 r :+ (p :+ VertexID)))
 -&gt; LineSegment 2 (p :+ VertexID) r
 -&gt; Const VertexID (LineSegment 2 (p :+ VertexID) r))
-&gt; ((VertexID -&gt; Const VertexID VertexID)
    -&gt; (Point 2 r :+ (p :+ VertexID))
    -&gt; Const VertexID (Point 2 r :+ (p :+ VertexID)))
-&gt; Getting VertexID (LineSegment 2 (p :+ VertexID) r) VertexID
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span class="annot"><span class="annottext">((p :+ VertexID) -&gt; Const VertexID (p :+ VertexID))
-&gt; (Point 2 r :+ (p :+ VertexID))
-&gt; Const VertexID (Point 2 r :+ (p :+ VertexID))
forall core extra extra'.
Lens (core :+ extra) (core :+ extra') extra extra'
</span><span class="hs-identifier hs-var">extra</span></span><span class="annot"><span class="annottext">(((p :+ VertexID) -&gt; Const VertexID (p :+ VertexID))
 -&gt; (Point 2 r :+ (p :+ VertexID))
 -&gt; Const VertexID (Point 2 r :+ (p :+ VertexID)))
-&gt; ((VertexID -&gt; Const VertexID VertexID)
    -&gt; (p :+ VertexID) -&gt; Const VertexID (p :+ VertexID))
-&gt; (VertexID -&gt; Const VertexID VertexID)
-&gt; (Point 2 r :+ (p :+ VertexID))
-&gt; Const VertexID (Point 2 r :+ (p :+ VertexID))
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span class="annot"><span class="annottext">(VertexID -&gt; Const VertexID VertexID)
-&gt; (p :+ VertexID) -&gt; Const VertexID (p :+ VertexID)
forall core extra extra'.
Lens (core :+ extra) (core :+ extra') extra extra'
</span><span class="hs-identifier hs-var">extra</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-104"></span><span>       </span><span class="annot"><span class="annottext">([LineSegment 2 (p :+ VertexID) r] -&gt; [(VertexID, VertexID)])
-&gt; (ConvexPolygon (p :+ VertexID) r
    -&gt; [LineSegment 2 (p :+ VertexID) r])
-&gt; ConvexPolygon (p :+ VertexID) r
-&gt; [(VertexID, VertexID)]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">CircularVector (LineSegment 2 (p :+ VertexID) r)
-&gt; [LineSegment 2 (p :+ VertexID) r]
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; [a]
</span><span class="hs-identifier hs-var">F.toList</span></span><span> </span><span class="annot"><span class="annottext">(CircularVector (LineSegment 2 (p :+ VertexID) r)
 -&gt; [LineSegment 2 (p :+ VertexID) r])
-&gt; (ConvexPolygon (p :+ VertexID) r
    -&gt; CircularVector (LineSegment 2 (p :+ VertexID) r))
-&gt; ConvexPolygon (p :+ VertexID) r
-&gt; [LineSegment 2 (p :+ VertexID) r]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Polygon 'Simple (p :+ VertexID) r
-&gt; CircularVector (LineSegment 2 (p :+ VertexID) r)
forall (t :: PolygonType) p r.
Polygon t p r -&gt; CircularVector (LineSegment 2 p r)
</span><a href="Data.Geometry.Polygon.Core.html#outerBoundaryEdges"><span class="hs-identifier hs-var">outerBoundaryEdges</span></a></span><span> </span><span class="annot"><span class="annottext">(Polygon 'Simple (p :+ VertexID) r
 -&gt; CircularVector (LineSegment 2 (p :+ VertexID) r))
-&gt; (ConvexPolygon (p :+ VertexID) r
    -&gt; Polygon 'Simple (p :+ VertexID) r)
-&gt; ConvexPolygon (p :+ VertexID) r
-&gt; CircularVector (LineSegment 2 (p :+ VertexID) r)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">ConvexPolygon (p :+ VertexID) r
-&gt; Polygon 'Simple (p :+ VertexID) r
forall p r. ConvexPolygon p r -&gt; SimplePolygon p r
</span><a href="Data.Geometry.Polygon.Convex.html#_simplePolygon"><span class="hs-identifier hs-var hs-var">_simplePolygon</span></a></span><span>
</span><span id="line-105"></span><span>
</span><span id="line-106"></span><span>
</span><span id="line-107"></span><span class="hs-comment">-- | Given a polygon; construct the adjacency list representation</span><span>
</span><span id="line-108"></span><span class="hs-comment">-- pre: at least two elements</span><span>
</span><span id="line-109"></span><span id="local-6989586621679968454"><span id="local-6989586621679968455"><span id="local-6989586621679968456"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#fromHull"><span class="hs-identifier hs-type">fromHull</span></a></span><span>              </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679968456"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Mapping"><span class="hs-identifier hs-type">Mapping</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968455"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968456"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Geometry.Polygon.Convex.html#ConvexPolygon"><span class="hs-identifier hs-type">ConvexPolygon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679968455"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="#local-6989586621679968454"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679968456"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Adj"><span class="hs-identifier hs-type">Adj</span></a></span></span></span></span><span>
</span><span id="line-110"></span><span id="fromHull"><span class="annot"><span class="annottext">fromHull :: Mapping p r -&gt; ConvexPolygon (p :+ q) r -&gt; Adj
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#fromHull"><span class="hs-identifier hs-var hs-var">fromHull</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679968168"><span class="annot"><span class="annottext">vtxMap :: Map (Point 2 r) VertexID
</span><a href="#local-6989586621679968168"><span class="hs-identifier hs-var">vtxMap</span></a></span></span><span class="hs-special">,</span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span id="local-6989586621679968167"><span class="annot"><span class="annottext">p :: ConvexPolygon (p :+ q) r
</span><a href="#local-6989586621679968167"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679968166"><span class="annot"><span class="annottext">vs :: [VertexID]
</span><a href="#local-6989586621679968166"><span class="hs-identifier hs-var">vs</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span id="local-6989586621679968165"><span class="annot"><span class="annottext">u :: VertexID
</span><a href="#local-6989586621679968165"><span class="hs-identifier hs-var">u</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679968164"><span class="annot"><span class="annottext">v :: VertexID
</span><a href="#local-6989586621679968164"><span class="hs-identifier hs-var">v</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679968163"><span class="annot"><span class="annottext">vs' :: [VertexID]
</span><a href="#local-6989586621679968163"><span class="hs-identifier hs-var">vs'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((Point 2 r :+ (p :+ q)) -&gt; VertexID)
-&gt; [Point 2 r :+ (p :+ q)] -&gt; [VertexID]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID -&gt; Point 2 r -&gt; VertexID
forall k a. Ord k =&gt; Map k a -&gt; k -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27"><span class="hs-identifier hs-var">lookup'</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><a href="#local-6989586621679968168"><span class="hs-identifier hs-var">vtxMap</span></a></span><span> </span><span class="annot"><span class="annottext">(Point 2 r -&gt; VertexID)
-&gt; ((Point 2 r :+ (p :+ q)) -&gt; Point 2 r)
-&gt; (Point 2 r :+ (p :+ q))
-&gt; VertexID
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Point 2 r :+ (p :+ q))
-&gt; Getting (Point 2 r) (Point 2 r :+ (p :+ q)) (Point 2 r)
-&gt; Point 2 r
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">Getting (Point 2 r) (Point 2 r :+ (p :+ q)) (Point 2 r)
forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-111"></span><span>                                         </span><span class="annot"><span class="annottext">([Point 2 r :+ (p :+ q)] -&gt; [VertexID])
-&gt; (CircularVector (Point 2 r :+ (p :+ q))
    -&gt; [Point 2 r :+ (p :+ q)])
-&gt; CircularVector (Point 2 r :+ (p :+ q))
-&gt; [VertexID]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">NonEmptyVector (Point 2 r :+ (p :+ q)) -&gt; [Point 2 r :+ (p :+ q)]
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; [a]
</span><span class="hs-identifier hs-var">F.toList</span></span><span> </span><span class="annot"><span class="annottext">(NonEmptyVector (Point 2 r :+ (p :+ q)) -&gt; [Point 2 r :+ (p :+ q)])
-&gt; (CircularVector (Point 2 r :+ (p :+ q))
    -&gt; NonEmptyVector (Point 2 r :+ (p :+ q)))
-&gt; CircularVector (Point 2 r :+ (p :+ q))
-&gt; [Point 2 r :+ (p :+ q)]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">CircularVector (Point 2 r :+ (p :+ q))
-&gt; NonEmptyVector (Point 2 r :+ (p :+ q))
forall a. CircularVector a -&gt; NonEmptyVector a
</span><span class="hs-identifier hs-var">CV.rightElements</span></span><span>
</span><span id="line-112"></span><span>                                         </span><span class="annot"><span class="annottext">(CircularVector (Point 2 r :+ (p :+ q)) -&gt; [VertexID])
-&gt; CircularVector (Point 2 r :+ (p :+ q)) -&gt; [VertexID]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">ConvexPolygon (p :+ q) r
</span><a href="#local-6989586621679968167"><span class="hs-identifier hs-var">p</span></a></span><span class="annot"><span class="annottext">ConvexPolygon (p :+ q) r
-&gt; Getting
     (CircularVector (Point 2 r :+ (p :+ q)))
     (ConvexPolygon (p :+ q) r)
     (CircularVector (Point 2 r :+ (p :+ q)))
-&gt; CircularVector (Point 2 r :+ (p :+ q))
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">(SimplePolygon (p :+ q) r
 -&gt; Const
      (CircularVector (Point 2 r :+ (p :+ q)))
      (SimplePolygon (p :+ q) r))
-&gt; ConvexPolygon (p :+ q) r
-&gt; Const
     (CircularVector (Point 2 r :+ (p :+ q))) (ConvexPolygon (p :+ q) r)
forall p1 r1 p2 r2.
Iso
  (ConvexPolygon p1 r1)
  (ConvexPolygon p2 r2)
  (SimplePolygon p1 r1)
  (SimplePolygon p2 r2)
</span><a href="Data.Geometry.Polygon.Convex.html#simplePolygon"><span class="hs-identifier hs-var">simplePolygon</span></a></span><span class="annot"><span class="annottext">((SimplePolygon (p :+ q) r
  -&gt; Const
       (CircularVector (Point 2 r :+ (p :+ q)))
       (SimplePolygon (p :+ q) r))
 -&gt; ConvexPolygon (p :+ q) r
 -&gt; Const
      (CircularVector (Point 2 r :+ (p :+ q)))
      (ConvexPolygon (p :+ q) r))
-&gt; ((CircularVector (Point 2 r :+ (p :+ q))
     -&gt; Const
          (CircularVector (Point 2 r :+ (p :+ q)))
          (CircularVector (Point 2 r :+ (p :+ q))))
    -&gt; SimplePolygon (p :+ q) r
    -&gt; Const
         (CircularVector (Point 2 r :+ (p :+ q)))
         (SimplePolygon (p :+ q) r))
-&gt; Getting
     (CircularVector (Point 2 r :+ (p :+ q)))
     (ConvexPolygon (p :+ q) r)
     (CircularVector (Point 2 r :+ (p :+ q)))
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span class="annot"><span class="annottext">(CircularVector (Point 2 r :+ (p :+ q))
 -&gt; Const
      (CircularVector (Point 2 r :+ (p :+ q)))
      (CircularVector (Point 2 r :+ (p :+ q))))
-&gt; SimplePolygon (p :+ q) r
-&gt; Const
     (CircularVector (Point 2 r :+ (p :+ q))) (SimplePolygon (p :+ q) r)
forall (t :: PolygonType) p r.
Getter (Polygon t p r) (CircularVector (Point 2 r :+ p))
</span><a href="Data.Geometry.Polygon.Core.html#outerBoundaryVector"><span class="hs-identifier hs-var">outerBoundaryVector</span></a></span><span>
</span><span id="line-113"></span><span>                            </span><span id="local-6989586621679968160"><span class="annot"><span class="annottext">es :: [(VertexID, CList VertexID)]
</span><a href="#local-6989586621679968160"><span class="hs-identifier hs-var hs-var">es</span></a></span></span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(VertexID -&gt; VertexID -&gt; VertexID -&gt; (VertexID, CList VertexID))
-&gt; [VertexID]
-&gt; [VertexID]
-&gt; [VertexID]
-&gt; [(VertexID, CList VertexID)]
forall a b c d. (a -&gt; b -&gt; c -&gt; d) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d]
</span><span class="hs-identifier hs-var">zipWith3</span></span><span> </span><span class="annot"><span class="annottext">VertexID -&gt; VertexID -&gt; VertexID -&gt; (VertexID, CList VertexID)
forall a a. Eq a =&gt; a -&gt; a -&gt; a -&gt; (a, CList a)
</span><a href="#local-6989586621679968158"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">[VertexID]
</span><a href="#local-6989586621679968166"><span class="hs-identifier hs-var">vs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[VertexID] -&gt; [VertexID]
forall a. [a] -&gt; [a]
</span><span class="hs-identifier hs-var">tail</span></span><span> </span><span class="annot"><span class="annottext">[VertexID]
</span><a href="#local-6989586621679968166"><span class="hs-identifier hs-var">vs</span></a></span><span> </span><span class="annot"><span class="annottext">[VertexID] -&gt; [VertexID] -&gt; [VertexID]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968165"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[VertexID]
</span><a href="#local-6989586621679968163"><span class="hs-identifier hs-var">vs'</span></a></span><span> </span><span class="annot"><span class="annottext">[VertexID] -&gt; [VertexID] -&gt; [VertexID]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968165"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968164"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-114"></span><span>                            </span><span id="local-6989586621679968158"><span class="annot"><span class="annottext">f :: a -&gt; a -&gt; a -&gt; (a, CList a)
</span><a href="#local-6989586621679968158"><span class="hs-identifier hs-var hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679968156"><span class="annot"><span class="annottext">prv :: a
</span><a href="#local-6989586621679968156"><span class="hs-identifier hs-var">prv</span></a></span></span><span> </span><span id="local-6989586621679968155"><span class="annot"><span class="annottext">c :: a
</span><a href="#local-6989586621679968155"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679968154"><span class="annot"><span class="annottext">nxt :: a
</span><a href="#local-6989586621679968154"><span class="hs-identifier hs-var">nxt</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679968155"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">[a] -&gt; CList a
forall a. [a] -&gt; CList a
</span><span class="hs-identifier hs-var">CL.fromList</span></span><span> </span><span class="annot"><span class="annottext">([a] -&gt; CList a) -&gt; ([a] -&gt; [a]) -&gt; [a] -&gt; CList a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; [a]
forall a. Eq a =&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">L.nub</span></span><span> </span><span class="annot"><span class="annottext">([a] -&gt; CList a) -&gt; [a] -&gt; CList a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679968156"><span class="hs-identifier hs-var">prv</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679968154"><span class="hs-identifier hs-var">nxt</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-115"></span><span>                        </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">[(VertexID, CList VertexID)] -&gt; Adj
forall a. [(VertexID, a)] -&gt; IntMap a
</span><span class="hs-identifier hs-var">IM.fromList</span></span><span> </span><span class="annot"><span class="annottext">[(VertexID, CList VertexID)]
</span><a href="#local-6989586621679968160"><span class="hs-identifier hs-var">es</span></a></span><span>
</span><span id="line-116"></span><span>
</span><span id="line-117"></span><span>
</span><span id="line-118"></span><span class="hs-comment">-- | Merge the two delaunay triangulations.</span><span>
</span><span id="line-119"></span><span class="hs-comment">--</span><span>
</span><span id="line-120"></span><span class="hs-comment">-- running time: \(O(n)\) (although we cheat a bit by using a IntMap)</span><span>
</span><span id="line-121"></span><span id="local-6989586621679968448"><span id="local-6989586621679968449"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#merge"><span class="hs-identifier hs-type">merge</span></a></span><span>                            </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679968449"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fractional</span></span><span> </span><span class="annot"><a href="#local-6989586621679968449"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-122"></span><span>                                 </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Adj"><span class="hs-identifier hs-type">Adj</span></a></span><span>
</span><span id="line-123"></span><span>                                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Adj"><span class="hs-identifier hs-type">Adj</span></a></span><span>
</span><span id="line-124"></span><span>                                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Geometry.LineSegment.html#LineSegment"><span class="hs-identifier hs-type">LineSegment</span></a></span><span> </span><span class="annot"><span class="hs-number">2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679968448"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679968449"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-comment">-- ^ lower tangent</span><span>
</span><span id="line-125"></span><span>                                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Geometry.LineSegment.html#LineSegment"><span class="hs-identifier hs-type">LineSegment</span></a></span><span> </span><span class="annot"><span class="hs-number">2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679968448"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679968449"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-comment">-- ^ upper tangent</span><span>
</span><span id="line-126"></span><span>                                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Mapping"><span class="hs-identifier hs-type">Mapping</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968448"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968449"><span class="hs-identifier hs-type">r</span></a></span><span>
</span><span id="line-127"></span><span>                                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Firsts"><span class="hs-identifier hs-type">Firsts</span></a></span><span>
</span><span id="line-128"></span><span>                                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Adj"><span class="hs-identifier hs-type">Adj</span></a></span></span></span><span>
</span><span id="line-129"></span><span id="merge"><span class="annot"><span class="annottext">merge :: Adj
-&gt; Adj
-&gt; LineSegment 2 (p :+ VertexID) r
-&gt; LineSegment 2 (p :+ VertexID) r
-&gt; Mapping p r
-&gt; Firsts
-&gt; Adj
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#merge"><span class="hs-identifier hs-var hs-var">merge</span></a></span></span><span> </span><span id="local-6989586621679968151"><span class="annot"><span class="annottext">ld :: Adj
</span><a href="#local-6989586621679968151"><span class="hs-identifier hs-var">ld</span></a></span></span><span> </span><span id="local-6989586621679968150"><span class="annot"><span class="annottext">rd :: Adj
</span><a href="#local-6989586621679968150"><span class="hs-identifier hs-var">rd</span></a></span></span><span> </span><span id="local-6989586621679968149"><span class="annot"><span class="annottext">bt :: LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621679968149"><span class="hs-identifier hs-var">bt</span></a></span></span><span> </span><span id="local-6989586621679968148"><span class="annot"><span class="annottext">ut :: LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621679968148"><span class="hs-identifier hs-var">ut</span></a></span></span><span> </span><span id="local-6989586621679968147"><span class="annot"><span class="annottext">mapping' :: Mapping p r
</span><a href="#local-6989586621679968147"><span class="hs-identifier hs-var">mapping'</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span id="local-6989586621679968146"><span class="annot"><span class="annottext">vtxMap :: Map (Point 2 r) VertexID
</span><a href="#local-6989586621679968146"><span class="hs-identifier hs-var">vtxMap</span></a></span></span><span class="hs-special">,</span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span id="local-6989586621679968145"><span class="annot"><span class="annottext">fsts :: Firsts
</span><a href="#local-6989586621679968145"><span class="hs-identifier hs-var">fsts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-130"></span><span>    </span><span class="annot"><span class="annottext">(Reader (Mapping p r, Firsts) Adj -&gt; (Mapping p r, Firsts) -&gt; Adj)
-&gt; (Mapping p r, Firsts) -&gt; Reader (Mapping p r, Firsts) Adj -&gt; Adj
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">Reader (Mapping p r, Firsts) Adj -&gt; (Mapping p r, Firsts) -&gt; Adj
forall r a. Reader r a -&gt; r -&gt; a
</span><span class="hs-identifier hs-var">runReader</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Mapping p r
</span><a href="#local-6989586621679968147"><span class="hs-identifier hs-var">mapping'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Firsts
</span><a href="#local-6989586621679968145"><span class="hs-identifier hs-var">fsts</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Reader (Mapping p r, Firsts) Adj -&gt; Adj)
-&gt; (StateT Adj (ReaderT (Mapping p r, Firsts) Identity) ()
    -&gt; Reader (Mapping p r, Firsts) Adj)
-&gt; StateT Adj (ReaderT (Mapping p r, Firsts) Identity) ()
-&gt; Adj
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(StateT Adj (ReaderT (Mapping p r, Firsts) Identity) ()
 -&gt; Adj -&gt; Reader (Mapping p r, Firsts) Adj)
-&gt; Adj
-&gt; StateT Adj (ReaderT (Mapping p r, Firsts) Identity) ()
-&gt; Reader (Mapping p r, Firsts) Adj
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">StateT Adj (ReaderT (Mapping p r, Firsts) Identity) ()
-&gt; Adj -&gt; Reader (Mapping p r, Firsts) Adj
forall (m :: * -&gt; *) s a. Monad m =&gt; StateT s m a -&gt; s -&gt; m s
</span><span class="hs-identifier hs-var">execStateT</span></span><span> </span><span class="annot"><span class="annottext">Adj
</span><a href="#local-6989586621679968141"><span class="hs-identifier hs-var">adj</span></a></span><span> </span><span class="annot"><span class="annottext">(StateT Adj (ReaderT (Mapping p r, Firsts) Identity) () -&gt; Adj)
-&gt; StateT Adj (ReaderT (Mapping p r, Firsts) Identity) () -&gt; Adj
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(VertexID, VertexID)
-&gt; VertexID
-&gt; VertexID
-&gt; StateT Adj (ReaderT (Mapping p r, Firsts) Identity) ()
forall r p.
(Ord r, Fractional r) =&gt;
(VertexID, VertexID) -&gt; VertexID -&gt; VertexID -&gt; Merge p r ()
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#moveUp"><span class="hs-identifier hs-var">moveUp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968139"><span class="hs-identifier hs-var">tl</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968138"><span class="hs-identifier hs-var">tr</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968137"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968136"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-131"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-132"></span><span>    </span><span id="local-6989586621679968137"><span class="annot"><span class="annottext">l :: VertexID
</span><a href="#local-6989586621679968137"><span class="hs-identifier hs-var hs-var">l</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID -&gt; Point 2 r -&gt; VertexID
forall k a. Ord k =&gt; Map k a -&gt; k -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27"><span class="hs-identifier hs-var">lookup'</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><a href="#local-6989586621679968146"><span class="hs-identifier hs-var">vtxMap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621679968149"><span class="hs-identifier hs-var">bt</span></a></span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
-&gt; Getting
     (Point 2 r) (LineSegment 2 (p :+ VertexID) r) (Point 2 r)
-&gt; Point 2 r
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">((Point 2 r :+ (p :+ VertexID))
 -&gt; Const (Point 2 r) (Point 2 r :+ (p :+ VertexID)))
-&gt; LineSegment 2 (p :+ VertexID) r
-&gt; Const (Point 2 r) (LineSegment 2 (p :+ VertexID) r)
forall t. HasStart t =&gt; Lens' t (StartCore t :+ StartExtra t)
</span><a href="Data.Geometry.Interval.html#start"><span class="hs-identifier hs-var">start</span></a></span><span class="annot"><span class="annottext">(((Point 2 r :+ (p :+ VertexID))
  -&gt; Const (Point 2 r) (Point 2 r :+ (p :+ VertexID)))
 -&gt; LineSegment 2 (p :+ VertexID) r
 -&gt; Const (Point 2 r) (LineSegment 2 (p :+ VertexID) r))
-&gt; ((Point 2 r -&gt; Const (Point 2 r) (Point 2 r))
    -&gt; (Point 2 r :+ (p :+ VertexID))
    -&gt; Const (Point 2 r) (Point 2 r :+ (p :+ VertexID)))
-&gt; Getting
     (Point 2 r) (LineSegment 2 (p :+ VertexID) r) (Point 2 r)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span class="annot"><span class="annottext">(Point 2 r -&gt; Const (Point 2 r) (Point 2 r))
-&gt; (Point 2 r :+ (p :+ VertexID))
-&gt; Const (Point 2 r) (Point 2 r :+ (p :+ VertexID))
forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span>
</span><span id="line-133"></span><span>    </span><span id="local-6989586621679968136"><span class="annot"><span class="annottext">r :: VertexID
</span><a href="#local-6989586621679968136"><span class="hs-identifier hs-var hs-var">r</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID -&gt; Point 2 r -&gt; VertexID
forall k a. Ord k =&gt; Map k a -&gt; k -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27"><span class="hs-identifier hs-var">lookup'</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><a href="#local-6989586621679968146"><span class="hs-identifier hs-var">vtxMap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621679968149"><span class="hs-identifier hs-var">bt</span></a></span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
-&gt; Getting
     (Point 2 r) (LineSegment 2 (p :+ VertexID) r) (Point 2 r)
-&gt; Point 2 r
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">((Point 2 r :+ (p :+ VertexID))
 -&gt; Const (Point 2 r) (Point 2 r :+ (p :+ VertexID)))
-&gt; LineSegment 2 (p :+ VertexID) r
-&gt; Const (Point 2 r) (LineSegment 2 (p :+ VertexID) r)
forall t. HasEnd t =&gt; Lens' t (EndCore t :+ EndExtra t)
</span><a href="Data.Geometry.Interval.html#end"><span class="hs-identifier hs-var">end</span></a></span><span class="annot"><span class="annottext">(((Point 2 r :+ (p :+ VertexID))
  -&gt; Const (Point 2 r) (Point 2 r :+ (p :+ VertexID)))
 -&gt; LineSegment 2 (p :+ VertexID) r
 -&gt; Const (Point 2 r) (LineSegment 2 (p :+ VertexID) r))
-&gt; ((Point 2 r -&gt; Const (Point 2 r) (Point 2 r))
    -&gt; (Point 2 r :+ (p :+ VertexID))
    -&gt; Const (Point 2 r) (Point 2 r :+ (p :+ VertexID)))
-&gt; Getting
     (Point 2 r) (LineSegment 2 (p :+ VertexID) r) (Point 2 r)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span class="annot"><span class="annottext">(Point 2 r -&gt; Const (Point 2 r) (Point 2 r))
-&gt; (Point 2 r :+ (p :+ VertexID))
-&gt; Const (Point 2 r) (Point 2 r :+ (p :+ VertexID))
forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span>
</span><span id="line-134"></span><span>    </span><span id="local-6989586621679968139"><span class="annot"><span class="annottext">tl :: VertexID
</span><a href="#local-6989586621679968139"><span class="hs-identifier hs-var hs-var">tl</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID -&gt; Point 2 r -&gt; VertexID
forall k a. Ord k =&gt; Map k a -&gt; k -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27"><span class="hs-identifier hs-var">lookup'</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><a href="#local-6989586621679968146"><span class="hs-identifier hs-var">vtxMap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621679968148"><span class="hs-identifier hs-var">ut</span></a></span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
-&gt; Getting
     (Point 2 r) (LineSegment 2 (p :+ VertexID) r) (Point 2 r)
-&gt; Point 2 r
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">((Point 2 r :+ (p :+ VertexID))
 -&gt; Const (Point 2 r) (Point 2 r :+ (p :+ VertexID)))
-&gt; LineSegment 2 (p :+ VertexID) r
-&gt; Const (Point 2 r) (LineSegment 2 (p :+ VertexID) r)
forall t. HasStart t =&gt; Lens' t (StartCore t :+ StartExtra t)
</span><a href="Data.Geometry.Interval.html#start"><span class="hs-identifier hs-var">start</span></a></span><span class="annot"><span class="annottext">(((Point 2 r :+ (p :+ VertexID))
  -&gt; Const (Point 2 r) (Point 2 r :+ (p :+ VertexID)))
 -&gt; LineSegment 2 (p :+ VertexID) r
 -&gt; Const (Point 2 r) (LineSegment 2 (p :+ VertexID) r))
-&gt; ((Point 2 r -&gt; Const (Point 2 r) (Point 2 r))
    -&gt; (Point 2 r :+ (p :+ VertexID))
    -&gt; Const (Point 2 r) (Point 2 r :+ (p :+ VertexID)))
-&gt; Getting
     (Point 2 r) (LineSegment 2 (p :+ VertexID) r) (Point 2 r)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span class="annot"><span class="annottext">(Point 2 r -&gt; Const (Point 2 r) (Point 2 r))
-&gt; (Point 2 r :+ (p :+ VertexID))
-&gt; Const (Point 2 r) (Point 2 r :+ (p :+ VertexID))
forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span>
</span><span id="line-135"></span><span>    </span><span id="local-6989586621679968138"><span class="annot"><span class="annottext">tr :: VertexID
</span><a href="#local-6989586621679968138"><span class="hs-identifier hs-var hs-var">tr</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID -&gt; Point 2 r -&gt; VertexID
forall k a. Ord k =&gt; Map k a -&gt; k -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27"><span class="hs-identifier hs-var">lookup'</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Point 2 r) VertexID
</span><a href="#local-6989586621679968146"><span class="hs-identifier hs-var">vtxMap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
</span><a href="#local-6989586621679968148"><span class="hs-identifier hs-var">ut</span></a></span><span class="annot"><span class="annottext">LineSegment 2 (p :+ VertexID) r
-&gt; Getting
     (Point 2 r) (LineSegment 2 (p :+ VertexID) r) (Point 2 r)
-&gt; Point 2 r
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">((Point 2 r :+ (p :+ VertexID))
 -&gt; Const (Point 2 r) (Point 2 r :+ (p :+ VertexID)))
-&gt; LineSegment 2 (p :+ VertexID) r
-&gt; Const (Point 2 r) (LineSegment 2 (p :+ VertexID) r)
forall t. HasEnd t =&gt; Lens' t (EndCore t :+ EndExtra t)
</span><a href="Data.Geometry.Interval.html#end"><span class="hs-identifier hs-var">end</span></a></span><span class="annot"><span class="annottext">(((Point 2 r :+ (p :+ VertexID))
  -&gt; Const (Point 2 r) (Point 2 r :+ (p :+ VertexID)))
 -&gt; LineSegment 2 (p :+ VertexID) r
 -&gt; Const (Point 2 r) (LineSegment 2 (p :+ VertexID) r))
-&gt; ((Point 2 r -&gt; Const (Point 2 r) (Point 2 r))
    -&gt; (Point 2 r :+ (p :+ VertexID))
    -&gt; Const (Point 2 r) (Point 2 r :+ (p :+ VertexID)))
-&gt; Getting
     (Point 2 r) (LineSegment 2 (p :+ VertexID) r) (Point 2 r)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span class="annot"><span class="annottext">(Point 2 r -&gt; Const (Point 2 r) (Point 2 r))
-&gt; (Point 2 r :+ (p :+ VertexID))
-&gt; Const (Point 2 r) (Point 2 r :+ (p :+ VertexID))
forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span>
</span><span id="line-136"></span><span>    </span><span id="local-6989586621679968141"><span class="annot"><span class="annottext">adj :: Adj
</span><a href="#local-6989586621679968141"><span class="hs-identifier hs-var hs-var">adj</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Adj
</span><a href="#local-6989586621679968151"><span class="hs-identifier hs-var">ld</span></a></span><span> </span><span class="annot"><span class="annottext">Adj -&gt; Adj -&gt; Adj
forall a. IntMap a -&gt; IntMap a -&gt; IntMap a
</span><span class="hs-operator hs-var">`IM.union`</span></span><span> </span><span class="annot"><span class="annottext">Adj
</span><a href="#local-6989586621679968150"><span class="hs-identifier hs-var">rd</span></a></span><span>
</span><span id="line-137"></span><span>
</span><span id="line-138"></span><span class="hs-keyword">type</span><span> </span><span id="Merge"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-var">Merge</span></a></span></span><span> </span><span id="local-6989586621679968134"><span class="annot"><a href="#local-6989586621679968134"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621679968133"><span class="annot"><a href="#local-6989586621679968133"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">StateT</span></span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Adj"><span class="hs-identifier hs-type">Adj</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Reader</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Mapping"><span class="hs-identifier hs-type">Mapping</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968134"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968133"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Firsts"><span class="hs-identifier hs-type">Firsts</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-139"></span><span>
</span><span id="line-140"></span><span class="hs-keyword">type</span><span> </span><span id="Firsts"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Firsts"><span class="hs-identifier hs-var">Firsts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IM.IntMap</span></span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span>
</span><span id="line-141"></span><span>
</span><span id="line-142"></span><span class="hs-comment">-- | Merges the two delaunay traingulations.</span><span>
</span><span id="line-143"></span><span id="local-6989586621679968383"><span id="local-6989586621679968384"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#moveUp"><span class="hs-identifier hs-type">moveUp</span></a></span><span>          </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679968384"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fractional</span></span><span> </span><span class="annot"><a href="#local-6989586621679968384"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-144"></span><span>                </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span class="hs-special">,</span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-type">Merge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968383"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968384"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-145"></span><span id="moveUp"><span class="annot"><span class="annottext">moveUp :: (VertexID, VertexID) -&gt; VertexID -&gt; VertexID -&gt; Merge p r ()
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#moveUp"><span class="hs-identifier hs-var hs-var">moveUp</span></a></span></span><span> </span><span id="local-6989586621679968132"><span class="annot"><span class="annottext">ut :: (VertexID, VertexID)
</span><a href="#local-6989586621679968132"><span class="hs-identifier hs-var">ut</span></a></span></span><span> </span><span id="local-6989586621679968131"><span class="annot"><span class="annottext">l :: VertexID
</span><a href="#local-6989586621679968131"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679968130"><span class="annot"><span class="annottext">r :: VertexID
</span><a href="#local-6989586621679968130"><span class="hs-identifier hs-var">r</span></a></span></span><span>
</span><span id="line-146"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968131"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968130"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(VertexID, VertexID) -&gt; (VertexID, VertexID) -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">(VertexID, VertexID)
</span><a href="#local-6989586621679968132"><span class="hs-identifier hs-var">ut</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">VertexID -&gt; VertexID -&gt; Merge p r ()
forall r p. (Num r, Ord r) =&gt; VertexID -&gt; VertexID -&gt; Merge p r ()
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#insert"><span class="hs-identifier hs-var">insert</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968131"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968130"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-147"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-148"></span><span>                     </span><span class="annot"><span class="annottext">VertexID -&gt; VertexID -&gt; Merge p r ()
forall r p. (Num r, Ord r) =&gt; VertexID -&gt; VertexID -&gt; Merge p r ()
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#insert"><span class="hs-identifier hs-var">insert</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968131"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968130"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-149"></span><span>                     </span><span class="hs-comment">-- Get the neighbours of r and l along the convex hull</span><span>
</span><span id="line-150"></span><span>                     </span><span id="local-6989586621679968128"><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968128"><span class="hs-identifier hs-var">r1</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(Adj -&gt; CList VertexID)
-&gt; StateT Adj (Reader (Mapping p r, Firsts)) (CList VertexID)
forall s (m :: * -&gt; *) a. MonadState s m =&gt; (s -&gt; a) -&gt; m a
</span><span class="hs-identifier hs-var">gets</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CList VertexID -&gt; CList VertexID
forall a. CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#pred%27"><span class="hs-identifier hs-var">pred'</span></a></span><span> </span><span class="annot"><span class="annottext">(CList VertexID -&gt; CList VertexID)
-&gt; (Adj -&gt; CList VertexID) -&gt; Adj -&gt; CList VertexID
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">VertexID -&gt; CList VertexID -&gt; CList VertexID
forall a. Eq a =&gt; a -&gt; CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateTo"><span class="hs-identifier hs-var">rotateTo</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968131"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">(CList VertexID -&gt; CList VertexID)
-&gt; (Adj -&gt; CList VertexID) -&gt; Adj -&gt; CList VertexID
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">VertexID -&gt; Adj -&gt; CList VertexID
forall a. VertexID -&gt; IntMap a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27%27"><span class="hs-identifier hs-var">lookup''</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968130"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-151"></span><span>                     </span><span id="local-6989586621679968123"><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968123"><span class="hs-identifier hs-var">l1</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(Adj -&gt; CList VertexID)
-&gt; StateT Adj (Reader (Mapping p r, Firsts)) (CList VertexID)
forall s (m :: * -&gt; *) a. MonadState s m =&gt; (s -&gt; a) -&gt; m a
</span><span class="hs-identifier hs-var">gets</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CList VertexID -&gt; CList VertexID
forall a. CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#succ%27"><span class="hs-identifier hs-var">succ'</span></a></span><span> </span><span class="annot"><span class="annottext">(CList VertexID -&gt; CList VertexID)
-&gt; (Adj -&gt; CList VertexID) -&gt; Adj -&gt; CList VertexID
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">VertexID -&gt; CList VertexID -&gt; CList VertexID
forall a. Eq a =&gt; a -&gt; CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateTo"><span class="hs-identifier hs-var">rotateTo</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968130"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">(CList VertexID -&gt; CList VertexID)
-&gt; (Adj -&gt; CList VertexID) -&gt; Adj -&gt; CList VertexID
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">VertexID -&gt; Adj -&gt; CList VertexID
forall a. VertexID -&gt; IntMap a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27%27"><span class="hs-identifier hs-var">lookup''</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968131"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-152"></span><span>
</span><span id="line-153"></span><span>                     </span><span class="hs-special">(</span><span id="local-6989586621679968121"><span class="annot"><span class="annottext">r1' :: CList VertexID
</span><a href="#local-6989586621679968121"><span class="hs-identifier hs-var">r1'</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679968120"><span class="annot"><span class="annottext">a :: Bool
</span><a href="#local-6989586621679968120"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">VertexID
-&gt; VertexID -&gt; CList VertexID -&gt; Merge p r (CList VertexID, Bool)
forall r p.
(Ord r, Fractional r) =&gt;
VertexID
-&gt; VertexID -&gt; CList VertexID -&gt; Merge p r (CList VertexID, Bool)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateR"><span class="hs-identifier hs-var">rotateR</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968131"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968130"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968128"><span class="hs-identifier hs-var">r1</span></a></span><span>
</span><span id="line-154"></span><span>                     </span><span class="hs-special">(</span><span id="local-6989586621679968118"><span class="annot"><span class="annottext">l1' :: CList VertexID
</span><a href="#local-6989586621679968118"><span class="hs-identifier hs-var">l1'</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679968117"><span class="annot"><span class="annottext">b :: Bool
</span><a href="#local-6989586621679968117"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">VertexID
-&gt; VertexID -&gt; CList VertexID -&gt; Merge p r (CList VertexID, Bool)
forall r p.
(Ord r, Fractional r) =&gt;
VertexID
-&gt; VertexID -&gt; CList VertexID -&gt; Merge p r (CList VertexID, Bool)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateL"><span class="hs-identifier hs-var">rotateL</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968131"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968130"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968123"><span class="hs-identifier hs-var">l1</span></a></span><span>
</span><span id="line-155"></span><span>                     </span><span id="local-6989586621679968115"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679968115"><span class="hs-identifier hs-var">c</span></a></span></span><span>       </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">VertexID
-&gt; VertexID -&gt; CList VertexID -&gt; CList VertexID -&gt; Merge p r Bool
forall r p.
(Ord r, Fractional r) =&gt;
VertexID
-&gt; VertexID -&gt; CList VertexID -&gt; CList VertexID -&gt; Merge p r Bool
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#qTest"><span class="hs-identifier hs-var">qTest</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968131"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968130"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968121"><span class="hs-identifier hs-var">r1'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968118"><span class="hs-identifier hs-var">l1'</span></a></span><span>
</span><span id="line-156"></span><span>                     </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679968113"><span class="annot"><span class="annottext">l' :: VertexID
</span><a href="#local-6989586621679968113"><span class="hs-identifier hs-var">l'</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679968112"><span class="annot"><span class="annottext">r' :: VertexID
</span><a href="#local-6989586621679968112"><span class="hs-identifier hs-var">r'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679968120"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679968117"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679968115"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-157"></span><span>                                     </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">True</span></span><span class="hs-special">,</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span class="hs-identifier">_</span><span class="hs-special">)</span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CList VertexID -&gt; VertexID
forall a. CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var">focus'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968118"><span class="hs-identifier hs-var">l1'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968130"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-158"></span><span>                                     </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">False</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">True</span></span><span class="hs-special">,</span><span class="hs-identifier">_</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968131"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span>          </span><span class="annot"><span class="annottext">CList VertexID -&gt; VertexID
forall a. CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var">focus'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968121"><span class="hs-identifier hs-var">r1'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-159"></span><span>                                     </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">False</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">False</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">True</span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968131"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span>          </span><span class="annot"><span class="annottext">CList VertexID -&gt; VertexID
forall a. CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var">focus'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968121"><span class="hs-identifier hs-var">r1'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-160"></span><span>                                     </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">False</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">False</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">False</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CList VertexID -&gt; VertexID
forall a. CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var">focus'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968118"><span class="hs-identifier hs-var">l1'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968130"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-161"></span><span>                     </span><span class="annot"><span class="annottext">(VertexID, VertexID) -&gt; VertexID -&gt; VertexID -&gt; Merge p r ()
forall r p.
(Ord r, Fractional r) =&gt;
(VertexID, VertexID) -&gt; VertexID -&gt; VertexID -&gt; Merge p r ()
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#moveUp"><span class="hs-identifier hs-var">moveUp</span></a></span><span> </span><span class="annot"><span class="annottext">(VertexID, VertexID)
</span><a href="#local-6989586621679968132"><span class="hs-identifier hs-var">ut</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968113"><span class="hs-identifier hs-var">l'</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968112"><span class="hs-identifier hs-var">r'</span></a></span><span>
</span><span id="line-162"></span><span>
</span><span id="line-163"></span><span>
</span><span id="line-164"></span><span class="hs-comment">-- | ''rotates'' around r and removes all neighbours of r that violate the</span><span>
</span><span id="line-165"></span><span class="hs-comment">-- delaunay condition. Returns the first vertex (as a Neighbour of r) that</span><span>
</span><span id="line-166"></span><span class="hs-comment">-- should remain in the Delaunay Triangulation, as well as a boolean A that</span><span>
</span><span id="line-167"></span><span class="hs-comment">-- helps deciding if we merge up by rotating left or rotating right (See</span><span>
</span><span id="line-168"></span><span class="hs-comment">-- description in the paper for more info)</span><span>
</span><span id="line-169"></span><span id="local-6989586621679968368"><span id="local-6989586621679968369"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateR"><span class="hs-identifier hs-type">rotateR</span></a></span><span>        </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679968369"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fractional</span></span><span> </span><span class="annot"><a href="#local-6989586621679968369"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-170"></span><span>               </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-type">Merge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968368"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968369"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-171"></span><span id="rotateR"><span class="annot"><span class="annottext">rotateR :: VertexID
-&gt; VertexID -&gt; CList VertexID -&gt; Merge p r (CList VertexID, Bool)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateR"><span class="hs-identifier hs-var hs-var">rotateR</span></a></span></span><span> </span><span id="local-6989586621679968109"><span class="annot"><span class="annottext">l :: VertexID
</span><a href="#local-6989586621679968109"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679968108"><span class="annot"><span class="annottext">r :: VertexID
</span><a href="#local-6989586621679968108"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span id="local-6989586621679968107"><span class="annot"><span class="annottext">r1 :: CList VertexID
</span><a href="#local-6989586621679968107"><span class="hs-identifier hs-var">r1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CList VertexID -&gt; VertexID
forall a. CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var">focus'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968107"><span class="hs-identifier hs-var">r1</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID -&gt; (VertexID, VertexID) -&gt; Merge p r Bool
forall r p.
(Ord r, Num r) =&gt;
VertexID -&gt; (VertexID, VertexID) -&gt; Merge p r Bool
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#isLeftOf"><span class="hs-operator hs-var">`isLeftOf`</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968109"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968108"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Merge p r Bool
-&gt; (Bool -&gt; Merge p r (CList VertexID, Bool))
-&gt; Merge p r (CList VertexID, Bool)
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-172"></span><span>                   </span><span class="annot"><span class="hs-identifier hs-type">True</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-special">,</span></span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(CList VertexID -&gt; (CList VertexID, Bool))
-&gt; StateT Adj (Reader (Mapping p r, Firsts)) (CList VertexID)
-&gt; Merge p r (CList VertexID, Bool)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">VertexID
-&gt; VertexID
-&gt; CList VertexID
-&gt; CList VertexID
-&gt; StateT Adj (Reader (Mapping p r, Firsts)) (CList VertexID)
forall r p.
(Ord r, Fractional r) =&gt;
VertexID
-&gt; VertexID
-&gt; CList VertexID
-&gt; CList VertexID
-&gt; Merge p r (CList VertexID)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateR%27"><span class="hs-identifier hs-var">rotateR'</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968109"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968108"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968107"><span class="hs-identifier hs-var">r1</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CList VertexID -&gt; CList VertexID
forall a. CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#pred%27"><span class="hs-identifier hs-var">pred'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968107"><span class="hs-identifier hs-var">r1</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-173"></span><span>                   </span><span class="annot"><span class="hs-identifier hs-type">False</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(CList VertexID, Bool) -&gt; Merge p r (CList VertexID, Bool)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968107"><span class="hs-identifier hs-var">r1</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span>
</span><span id="line-174"></span><span>
</span><span id="line-175"></span><span>
</span><span id="line-176"></span><span class="hs-comment">-- | The code that does the actual rotating</span><span>
</span><span id="line-177"></span><span id="local-6989586621679968356"><span id="local-6989586621679968357"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateR%27"><span class="hs-identifier hs-type">rotateR'</span></a></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679968357"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fractional</span></span><span> </span><span class="annot"><a href="#local-6989586621679968357"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-178"></span><span>             </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-type">Merge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968356"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968357"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span></span></span><span>
</span><span id="line-179"></span><span id="rotateR%27"><span class="annot"><span class="annottext">rotateR' :: VertexID
-&gt; VertexID
-&gt; CList VertexID
-&gt; CList VertexID
-&gt; Merge p r (CList VertexID)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateR%27"><span class="hs-identifier hs-var hs-var">rotateR'</span></a></span></span><span> </span><span id="local-6989586621679968104"><span class="annot"><span class="annottext">l :: VertexID
</span><a href="#local-6989586621679968104"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679968103"><span class="annot"><span class="annottext">r :: VertexID
</span><a href="#local-6989586621679968103"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CList VertexID -&gt; CList VertexID -&gt; Merge p r (CList VertexID)
</span><a href="#local-6989586621679968102"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-180"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-181"></span><span>    </span><span id="local-6989586621679968102"><span class="annot"><span class="annottext">go :: CList VertexID -&gt; CList VertexID -&gt; Merge p r (CList VertexID)
</span><a href="#local-6989586621679968102"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679968101"><span class="annot"><span class="annottext">r1 :: CList VertexID
</span><a href="#local-6989586621679968101"><span class="hs-identifier hs-var">r1</span></a></span></span><span> </span><span id="local-6989586621679968100"><span class="annot"><span class="annottext">r2 :: CList VertexID
</span><a href="#local-6989586621679968100"><span class="hs-identifier hs-var">r2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">VertexID
-&gt; VertexID -&gt; CList VertexID -&gt; CList VertexID -&gt; Merge p r Bool
forall r p.
(Ord r, Fractional r) =&gt;
VertexID
-&gt; VertexID -&gt; CList VertexID -&gt; CList VertexID -&gt; Merge p r Bool
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#qTest"><span class="hs-identifier hs-var">qTest</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968104"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968103"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968101"><span class="hs-identifier hs-var">r1</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968100"><span class="hs-identifier hs-var">r2</span></a></span><span> </span><span class="annot"><span class="annottext">Merge p r Bool
-&gt; (Bool -&gt; Merge p r (CList VertexID))
-&gt; Merge p r (CList VertexID)
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-182"></span><span>                 </span><span class="annot"><span class="hs-identifier hs-type">True</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">CList VertexID -&gt; Merge p r (CList VertexID)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968101"><span class="hs-identifier hs-var">r1</span></a></span><span>
</span><span id="line-183"></span><span>                 </span><span class="annot"><span class="hs-identifier hs-type">False</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="annot"><span class="annottext">(Adj -&gt; Adj) -&gt; StateT Adj (Reader (Mapping p r, Firsts)) ()
forall s (m :: * -&gt; *). MonadState s m =&gt; (s -&gt; s) -&gt; m ()
</span><span class="hs-identifier hs-var">modify</span></span><span> </span><span class="annot"><span class="annottext">((Adj -&gt; Adj) -&gt; StateT Adj (Reader (Mapping p r, Firsts)) ())
-&gt; (Adj -&gt; Adj) -&gt; StateT Adj (Reader (Mapping p r, Firsts)) ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">VertexID -&gt; VertexID -&gt; Adj -&gt; Adj
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delete"><span class="hs-identifier hs-var">delete</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968103"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CList VertexID -&gt; VertexID
forall a. CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var">focus'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968101"><span class="hs-identifier hs-var">r1</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-184"></span><span>                             </span><span class="annot"><span class="annottext">CList VertexID -&gt; CList VertexID -&gt; Merge p r (CList VertexID)
</span><a href="#local-6989586621679968102"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968100"><span class="hs-identifier hs-var">r2</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CList VertexID -&gt; CList VertexID
forall a. CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#pred%27"><span class="hs-identifier hs-var">pred'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968100"><span class="hs-identifier hs-var">r2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-185"></span><span>
</span><span id="line-186"></span><span>
</span><span id="line-187"></span><span class="hs-comment">-- | Symmetric to rotateR</span><span>
</span><span id="line-188"></span><span id="local-6989586621679968096"><span id="local-6989586621679968097"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateL"><span class="hs-identifier hs-type">rotateL</span></a></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679968097"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fractional</span></span><span> </span><span class="annot"><a href="#local-6989586621679968097"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-189"></span><span>                     </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-type">Merge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968096"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968097"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-190"></span><span id="rotateL"><span class="annot"><span class="annottext">rotateL :: VertexID
-&gt; VertexID -&gt; CList VertexID -&gt; Merge p r (CList VertexID, Bool)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateL"><span class="hs-identifier hs-var hs-var">rotateL</span></a></span></span><span> </span><span id="local-6989586621679968095"><span class="annot"><span class="annottext">l :: VertexID
</span><a href="#local-6989586621679968095"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679968094"><span class="annot"><span class="annottext">r :: VertexID
</span><a href="#local-6989586621679968094"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span id="local-6989586621679968093"><span class="annot"><span class="annottext">l1 :: CList VertexID
</span><a href="#local-6989586621679968093"><span class="hs-identifier hs-var">l1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CList VertexID -&gt; VertexID
forall a. CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var">focus'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968093"><span class="hs-identifier hs-var">l1</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID -&gt; (VertexID, VertexID) -&gt; Merge p r Bool
forall r p.
(Ord r, Num r) =&gt;
VertexID -&gt; (VertexID, VertexID) -&gt; Merge p r Bool
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#isRightOf"><span class="hs-operator hs-var">`isRightOf`</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968094"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968095"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Merge p r Bool
-&gt; (Bool -&gt; Merge p r (CList VertexID, Bool))
-&gt; Merge p r (CList VertexID, Bool)
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-191"></span><span>                   </span><span class="annot"><span class="hs-identifier hs-type">True</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-special">,</span></span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(CList VertexID -&gt; (CList VertexID, Bool))
-&gt; StateT Adj (Reader (Mapping p r, Firsts)) (CList VertexID)
-&gt; Merge p r (CList VertexID, Bool)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">VertexID
-&gt; VertexID
-&gt; CList VertexID
-&gt; CList VertexID
-&gt; StateT Adj (Reader (Mapping p r, Firsts)) (CList VertexID)
forall r p.
(Ord r, Fractional r) =&gt;
VertexID
-&gt; VertexID
-&gt; CList VertexID
-&gt; CList VertexID
-&gt; Merge p r (CList VertexID)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateL%27"><span class="hs-identifier hs-var">rotateL'</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968095"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968094"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968093"><span class="hs-identifier hs-var">l1</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CList VertexID -&gt; CList VertexID
forall a. CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#succ%27"><span class="hs-identifier hs-var">succ'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968093"><span class="hs-identifier hs-var">l1</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-192"></span><span>                   </span><span class="annot"><span class="hs-identifier hs-type">False</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(CList VertexID, Bool) -&gt; Merge p r (CList VertexID, Bool)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968093"><span class="hs-identifier hs-var">l1</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span>
</span><span id="line-193"></span><span>
</span><span id="line-194"></span><span class="hs-comment">-- | The code that does the actual rotating. Symmetric to rotateR'</span><span>
</span><span id="line-195"></span><span id="local-6989586621679968089"><span id="local-6989586621679968090"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateL%27"><span class="hs-identifier hs-type">rotateL'</span></a></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679968090"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fractional</span></span><span> </span><span class="annot"><a href="#local-6989586621679968090"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-196"></span><span>             </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-type">Merge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968089"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968090"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span></span></span><span>
</span><span id="line-197"></span><span id="rotateL%27"><span class="annot"><span class="annottext">rotateL' :: VertexID
-&gt; VertexID
-&gt; CList VertexID
-&gt; CList VertexID
-&gt; Merge p r (CList VertexID)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateL%27"><span class="hs-identifier hs-var hs-var">rotateL'</span></a></span></span><span> </span><span id="local-6989586621679968088"><span class="annot"><span class="annottext">l :: VertexID
</span><a href="#local-6989586621679968088"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679968087"><span class="annot"><span class="annottext">r :: VertexID
</span><a href="#local-6989586621679968087"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CList VertexID -&gt; CList VertexID -&gt; Merge p r (CList VertexID)
</span><a href="#local-6989586621679968086"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-198"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-199"></span><span>    </span><span id="local-6989586621679968086"><span class="annot"><span class="annottext">go :: CList VertexID -&gt; CList VertexID -&gt; Merge p r (CList VertexID)
</span><a href="#local-6989586621679968086"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679968085"><span class="annot"><span class="annottext">l1 :: CList VertexID
</span><a href="#local-6989586621679968085"><span class="hs-identifier hs-var">l1</span></a></span></span><span> </span><span id="local-6989586621679968084"><span class="annot"><span class="annottext">l2 :: CList VertexID
</span><a href="#local-6989586621679968084"><span class="hs-identifier hs-var">l2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">VertexID
-&gt; VertexID -&gt; CList VertexID -&gt; CList VertexID -&gt; Merge p r Bool
forall r p.
(Ord r, Fractional r) =&gt;
VertexID
-&gt; VertexID -&gt; CList VertexID -&gt; CList VertexID -&gt; Merge p r Bool
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#qTest"><span class="hs-identifier hs-var">qTest</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968088"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968087"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968085"><span class="hs-identifier hs-var">l1</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968084"><span class="hs-identifier hs-var">l2</span></a></span><span> </span><span class="annot"><span class="annottext">Merge p r Bool
-&gt; (Bool -&gt; Merge p r (CList VertexID))
-&gt; Merge p r (CList VertexID)
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-200"></span><span>                 </span><span class="annot"><span class="hs-identifier hs-type">True</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">CList VertexID -&gt; Merge p r (CList VertexID)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968085"><span class="hs-identifier hs-var">l1</span></a></span><span>
</span><span id="line-201"></span><span>                 </span><span class="annot"><span class="hs-identifier hs-type">False</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="annot"><span class="annottext">(Adj -&gt; Adj) -&gt; StateT Adj (Reader (Mapping p r, Firsts)) ()
forall s (m :: * -&gt; *). MonadState s m =&gt; (s -&gt; s) -&gt; m ()
</span><span class="hs-identifier hs-var">modify</span></span><span> </span><span class="annot"><span class="annottext">((Adj -&gt; Adj) -&gt; StateT Adj (Reader (Mapping p r, Firsts)) ())
-&gt; (Adj -&gt; Adj) -&gt; StateT Adj (Reader (Mapping p r, Firsts)) ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">VertexID -&gt; VertexID -&gt; Adj -&gt; Adj
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delete"><span class="hs-identifier hs-var">delete</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968088"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CList VertexID -&gt; VertexID
forall a. CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var">focus'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968085"><span class="hs-identifier hs-var">l1</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-202"></span><span>                             </span><span class="annot"><span class="annottext">CList VertexID -&gt; CList VertexID -&gt; Merge p r (CList VertexID)
</span><a href="#local-6989586621679968086"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968084"><span class="hs-identifier hs-var">l2</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CList VertexID -&gt; CList VertexID
forall a. CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#succ%27"><span class="hs-identifier hs-var">succ'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968084"><span class="hs-identifier hs-var">l2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-203"></span><span>
</span><span id="line-204"></span><span class="hs-comment">--------------------------------------------------------------------------------</span><span>
</span><span id="line-205"></span><span class="hs-comment">-- * Primitives used by the Algorithm</span><span>
</span><span id="line-206"></span><span>
</span><span id="line-207"></span><span class="hs-comment">-- | returns True if the forth point (vertex) does not lie in the disk defined</span><span>
</span><span id="line-208"></span><span class="hs-comment">-- by the first three points.</span><span>
</span><span id="line-209"></span><span id="local-6989586621679968366"><span id="local-6989586621679968367"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#qTest"><span class="hs-identifier hs-type">qTest</span></a></span><span>         </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679968367"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fractional</span></span><span> </span><span class="annot"><a href="#local-6989586621679968367"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-210"></span><span>              </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Vertex"><span class="hs-identifier hs-type">Vertex</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-type">Merge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968366"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968367"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span><span>
</span><span id="line-211"></span><span id="qTest"><span class="annot"><span class="annottext">qTest :: VertexID
-&gt; VertexID -&gt; CList VertexID -&gt; CList VertexID -&gt; Merge p r Bool
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#qTest"><span class="hs-identifier hs-var hs-var">qTest</span></a></span></span><span> </span><span id="local-6989586621679968083"><span class="annot"><span class="annottext">h :: VertexID
</span><a href="#local-6989586621679968083"><span class="hs-identifier hs-var">h</span></a></span></span><span> </span><span id="local-6989586621679968082"><span class="annot"><span class="annottext">i :: VertexID
</span><a href="#local-6989586621679968082"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span id="local-6989586621679968081"><span class="annot"><span class="annottext">j :: CList VertexID
</span><a href="#local-6989586621679968081"><span class="hs-identifier hs-var">j</span></a></span></span><span> </span><span id="local-6989586621679968080"><span class="annot"><span class="annottext">k :: CList VertexID
</span><a href="#local-6989586621679968080"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(((Map (Point 2 r) VertexID, Vector (Point 2 r :+ p)), Firsts)
 -&gt; Bool)
-&gt; Merge p r Bool
forall r (m :: * -&gt; *) a. MonadReader r m =&gt; (r -&gt; a) -&gt; m a
</span><span class="hs-identifier hs-var">asks</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p) -&gt; Bool
</span><a href="#local-6989586621679968078"><span class="hs-identifier hs-var">withPtMap</span></a></span><span> </span><span class="annot"><span class="annottext">(Vector (Point 2 r :+ p) -&gt; Bool)
-&gt; (((Map (Point 2 r) VertexID, Vector (Point 2 r :+ p)), Firsts)
    -&gt; Vector (Point 2 r :+ p))
-&gt; ((Map (Point 2 r) VertexID, Vector (Point 2 r :+ p)), Firsts)
-&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Map (Point 2 r) VertexID, Vector (Point 2 r :+ p))
-&gt; Vector (Point 2 r :+ p)
forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span> </span><span class="annot"><span class="annottext">((Map (Point 2 r) VertexID, Vector (Point 2 r :+ p))
 -&gt; Vector (Point 2 r :+ p))
-&gt; (((Map (Point 2 r) VertexID, Vector (Point 2 r :+ p)), Firsts)
    -&gt; (Map (Point 2 r) VertexID, Vector (Point 2 r :+ p)))
-&gt; ((Map (Point 2 r) VertexID, Vector (Point 2 r :+ p)), Firsts)
-&gt; Vector (Point 2 r :+ p)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">((Map (Point 2 r) VertexID, Vector (Point 2 r :+ p)), Firsts)
-&gt; (Map (Point 2 r) VertexID, Vector (Point 2 r :+ p))
forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span>
</span><span id="line-212"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-213"></span><span>    </span><span id="local-6989586621679968078"><span class="annot"><span class="annottext">withPtMap :: Vector (Point 2 r :+ p) -&gt; Bool
</span><a href="#local-6989586621679968078"><span class="hs-identifier hs-var hs-var">withPtMap</span></a></span></span><span> </span><span id="local-6989586621679968077"><span class="annot"><span class="annottext">ptMap :: Vector (Point 2 r :+ p)
</span><a href="#local-6989586621679968077"><span class="hs-identifier hs-var">ptMap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679968076"><span class="annot"><span class="annottext">h' :: Point 2 r :+ p
</span><a href="#local-6989586621679968076"><span class="hs-identifier hs-var hs-var">h'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621679968077"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p) -&gt; VertexID -&gt; Point 2 r :+ p
forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968083"><span class="hs-identifier hs-var">h</span></a></span><span>
</span><span id="line-214"></span><span>                          </span><span id="local-6989586621679968074"><span class="annot"><span class="annottext">i' :: Point 2 r :+ p
</span><a href="#local-6989586621679968074"><span class="hs-identifier hs-var hs-var">i'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621679968077"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p) -&gt; VertexID -&gt; Point 2 r :+ p
forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968082"><span class="hs-identifier hs-var">i</span></a></span><span>
</span><span id="line-215"></span><span>                          </span><span id="local-6989586621679968073"><span class="annot"><span class="annottext">j' :: Point 2 r :+ p
</span><a href="#local-6989586621679968073"><span class="hs-identifier hs-var hs-var">j'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621679968077"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p) -&gt; VertexID -&gt; Point 2 r :+ p
forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">CList VertexID -&gt; VertexID
forall a. CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var">focus'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968081"><span class="hs-identifier hs-var">j</span></a></span><span>
</span><span id="line-216"></span><span>                          </span><span id="local-6989586621679968072"><span class="annot"><span class="annottext">k' :: Point 2 r :+ p
</span><a href="#local-6989586621679968072"><span class="hs-identifier hs-var hs-var">k'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621679968077"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p) -&gt; VertexID -&gt; Point 2 r :+ p
forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">CList VertexID -&gt; VertexID
forall a. CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var">focus'</span></a></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968080"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-217"></span><span>                      </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; Bool)
-&gt; (Maybe (Ball 2 () r) -&gt; Bool) -&gt; Maybe (Ball 2 () r) -&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; (Ball 2 () r -&gt; Bool) -&gt; Maybe (Ball 2 () r) -&gt; Bool
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621679968072"><span class="hs-identifier hs-var">k'</span></a></span><span class="annot"><span class="annottext">(Point 2 r :+ p)
-&gt; Getting (Point 2 r) (Point 2 r :+ p) (Point 2 r) -&gt; Point 2 r
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">Getting (Point 2 r) (Point 2 r :+ p) (Point 2 r)
forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Point 2 r -&gt; Ball 2 () r -&gt; Bool
forall (d :: Nat) r p.
(Arity d, Ord r, Num r) =&gt;
Point d r -&gt; Ball d p r -&gt; Bool
</span><a href="Data.Geometry.Ball.html#insideBall"><span class="hs-operator hs-var">`insideBall`</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Maybe (Ball 2 () r) -&gt; Bool) -&gt; Maybe (Ball 2 () r) -&gt; Bool
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Point 2 r :+ p)
-&gt; (Point 2 r :+ p) -&gt; (Point 2 r :+ p) -&gt; Maybe (Ball 2 () r)
forall r extra extra extra.
(Eq r, Fractional r) =&gt;
(Point 2 r :+ extra)
-&gt; (Point 2 r :+ extra)
-&gt; (Point 2 r :+ extra)
-&gt; Maybe (Disk () r)
</span><a href="#local-6989586621679968069"><span class="hs-identifier hs-var">disk'</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621679968076"><span class="hs-identifier hs-var">h'</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621679968074"><span class="hs-identifier hs-var">i'</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621679968073"><span class="hs-identifier hs-var">j'</span></a></span><span>
</span><span id="line-218"></span><span>    </span><span id="local-6989586621679968069"><span class="annot"><span class="annottext">disk' :: (Point 2 r :+ extra)
-&gt; (Point 2 r :+ extra)
-&gt; (Point 2 r :+ extra)
-&gt; Maybe (Disk () r)
</span><a href="#local-6989586621679968069"><span class="hs-identifier hs-var hs-var">disk'</span></a></span></span><span> </span><span id="local-6989586621679968068"><span class="annot"><span class="annottext">p :: Point 2 r :+ extra
</span><a href="#local-6989586621679968068"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679968067"><span class="annot"><span class="annottext">q :: Point 2 r :+ extra
</span><a href="#local-6989586621679968067"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span id="local-6989586621679968066"><span class="annot"><span class="annottext">r :: Point 2 r :+ extra
</span><a href="#local-6989586621679968066"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Point 2 r -&gt; Point 2 r -&gt; Point 2 r -&gt; Maybe (Disk () r)
forall r.
(Eq r, Fractional r) =&gt;
Point 2 r -&gt; Point 2 r -&gt; Point 2 r -&gt; Maybe (Disk () r)
</span><a href="Data.Geometry.Ball.html#disk"><span class="hs-identifier hs-var">disk</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Point 2 r :+ extra
</span><a href="#local-6989586621679968068"><span class="hs-identifier hs-var">p</span></a></span><span class="annot"><span class="annottext">(Point 2 r :+ extra)
-&gt; Getting (Point 2 r) (Point 2 r :+ extra) (Point 2 r)
-&gt; Point 2 r
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">Getting (Point 2 r) (Point 2 r :+ extra) (Point 2 r)
forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Point 2 r :+ extra
</span><a href="#local-6989586621679968067"><span class="hs-identifier hs-var">q</span></a></span><span class="annot"><span class="annottext">(Point 2 r :+ extra)
-&gt; Getting (Point 2 r) (Point 2 r :+ extra) (Point 2 r)
-&gt; Point 2 r
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">Getting (Point 2 r) (Point 2 r :+ extra) (Point 2 r)
forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Point 2 r :+ extra
</span><a href="#local-6989586621679968066"><span class="hs-identifier hs-var">r</span></a></span><span class="annot"><span class="annottext">(Point 2 r :+ extra)
-&gt; Getting (Point 2 r) (Point 2 r :+ extra) (Point 2 r)
-&gt; Point 2 r
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">Getting (Point 2 r) (Point 2 r :+ extra) (Point 2 r)
forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span>
</span><span id="line-219"></span><span>
</span><span id="line-220"></span><span class="hs-comment">-- | Inserts an edge into the right position.</span><span>
</span><span id="line-221"></span><span id="local-6989586621679968377"><span id="local-6989586621679968378"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#insert"><span class="hs-identifier hs-type">insert</span></a></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Num</span></span><span> </span><span class="annot"><a href="#local-6989586621679968378"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679968378"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-type">Merge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968377"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968378"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-222"></span><span id="insert"><span class="annot"><span class="annottext">insert :: VertexID -&gt; VertexID -&gt; Merge p r ()
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#insert"><span class="hs-identifier hs-var hs-var">insert</span></a></span></span><span> </span><span id="local-6989586621679968065"><span class="annot"><span class="annottext">u :: VertexID
</span><a href="#local-6989586621679968065"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span id="local-6989586621679968064"><span class="annot"><span class="annottext">v :: VertexID
</span><a href="#local-6989586621679968064"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-223"></span><span>               </span><span class="hs-special">(</span><span id="local-6989586621679968063"><span class="annot"><span class="annottext">mapping' :: Mapping p r
</span><a href="#local-6989586621679968063"><span class="hs-identifier hs-var">mapping'</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679968062"><span class="annot"><span class="annottext">fsts :: Firsts
</span><a href="#local-6989586621679968062"><span class="hs-identifier hs-var">fsts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">StateT Adj (Reader (Mapping p r, Firsts)) (Mapping p r, Firsts)
forall r (m :: * -&gt; *). MonadReader r m =&gt; m r
</span><span class="hs-identifier hs-var">ask</span></span><span>
</span><span id="line-224"></span><span>               </span><span class="annot"><span class="annottext">(Adj -&gt; Adj) -&gt; Merge p r ()
forall s (m :: * -&gt; *). MonadState s m =&gt; (s -&gt; s) -&gt; m ()
</span><span class="hs-identifier hs-var">modify</span></span><span> </span><span class="annot"><span class="annottext">((Adj -&gt; Adj) -&gt; Merge p r ()) -&gt; (Adj -&gt; Adj) -&gt; Merge p r ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">VertexID -&gt; VertexID -&gt; Mapping p r -&gt; Adj -&gt; Adj
forall r p.
(Num r, Ord r) =&gt;
VertexID -&gt; VertexID -&gt; Mapping p r -&gt; Adj -&gt; Adj
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#insert%27"><span class="hs-identifier hs-var">insert'</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968065"><span class="hs-identifier hs-var">u</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968064"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Mapping p r
</span><a href="#local-6989586621679968063"><span class="hs-identifier hs-var">mapping'</span></a></span><span>
</span><span id="line-225"></span><span>               </span><span class="annot"><span class="annottext">VertexID -&gt; Firsts -&gt; Merge p r ()
forall p r. VertexID -&gt; Firsts -&gt; Merge p r ()
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateToFirst"><span class="hs-identifier hs-var">rotateToFirst</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968065"><span class="hs-identifier hs-var">u</span></a></span><span> </span><span class="annot"><span class="annottext">Firsts
</span><a href="#local-6989586621679968062"><span class="hs-identifier hs-var">fsts</span></a></span><span>
</span><span id="line-226"></span><span>               </span><span class="annot"><span class="annottext">VertexID -&gt; Firsts -&gt; Merge p r ()
forall p r. VertexID -&gt; Firsts -&gt; Merge p r ()
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateToFirst"><span class="hs-identifier hs-var">rotateToFirst</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968064"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Firsts
</span><a href="#local-6989586621679968062"><span class="hs-identifier hs-var">fsts</span></a></span><span>
</span><span id="line-227"></span><span>
</span><span id="line-228"></span><span>
</span><span id="line-229"></span><span class="hs-comment">-- | make sure that the first vtx in the adj list of v is its predecessor on the CH</span><span>
</span><span id="line-230"></span><span id="local-6989586621679968314"><span id="local-6989586621679968315"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateToFirst"><span class="hs-identifier hs-type">rotateToFirst</span></a></span><span>        </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Firsts"><span class="hs-identifier hs-type">Firsts</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-type">Merge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968315"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968314"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-231"></span><span id="rotateToFirst"><span class="annot"><span class="annottext">rotateToFirst :: VertexID -&gt; Firsts -&gt; Merge p r ()
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateToFirst"><span class="hs-identifier hs-var hs-var">rotateToFirst</span></a></span></span><span> </span><span id="local-6989586621679968058"><span class="annot"><span class="annottext">v :: VertexID
</span><a href="#local-6989586621679968058"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span id="local-6989586621679968057"><span class="annot"><span class="annottext">fsts :: Firsts
</span><a href="#local-6989586621679968057"><span class="hs-identifier hs-var">fsts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Adj -&gt; Adj) -&gt; Merge p r ()
forall s (m :: * -&gt; *). MonadState s m =&gt; (s -&gt; s) -&gt; m ()
</span><span class="hs-identifier hs-var">modify</span></span><span> </span><span class="annot"><span class="annottext">((Adj -&gt; Adj) -&gt; Merge p r ()) -&gt; (Adj -&gt; Adj) -&gt; Merge p r ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(CList VertexID -&gt; CList VertexID) -&gt; VertexID -&gt; Adj -&gt; Adj
forall a. (a -&gt; a) -&gt; VertexID -&gt; IntMap a -&gt; IntMap a
</span><span class="hs-identifier hs-var">IM.adjust</span></span><span> </span><span class="annot"><span class="annottext">CList VertexID -&gt; CList VertexID
</span><a href="#local-6989586621679968055"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968058"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-232"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-233"></span><span>    </span><span id="local-6989586621679968054"><span class="annot"><span class="annottext">mfst :: Maybe VertexID
</span><a href="#local-6989586621679968054"><span class="hs-identifier hs-var hs-var">mfst</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">VertexID -&gt; Firsts -&gt; Maybe VertexID
forall a. VertexID -&gt; IntMap a -&gt; Maybe a
</span><span class="hs-identifier hs-var">IM.lookup</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968058"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Firsts
</span><a href="#local-6989586621679968057"><span class="hs-identifier hs-var">fsts</span></a></span><span>
</span><span id="line-234"></span><span>    </span><span id="local-6989586621679968055"><span class="annot"><span class="annottext">f :: CList VertexID -&gt; CList VertexID
</span><a href="#local-6989586621679968055"><span class="hs-identifier hs-var hs-var">f</span></a></span></span><span>  </span><span id="local-6989586621679968052"><span class="annot"><span class="annottext">cl :: CList VertexID
</span><a href="#local-6989586621679968052"><span class="hs-identifier hs-var">cl</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CList VertexID -&gt; Maybe (CList VertexID) -&gt; CList VertexID
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968052"><span class="hs-identifier hs-var">cl</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe (CList VertexID) -&gt; CList VertexID)
-&gt; Maybe (CList VertexID) -&gt; CList VertexID
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Maybe VertexID
</span><a href="#local-6989586621679968054"><span class="hs-identifier hs-var">mfst</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe VertexID
-&gt; (VertexID -&gt; Maybe (CList VertexID)) -&gt; Maybe (CList VertexID)
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="annot"><span class="annottext">(VertexID -&gt; CList VertexID -&gt; Maybe (CList VertexID))
-&gt; CList VertexID -&gt; VertexID -&gt; Maybe (CList VertexID)
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">VertexID -&gt; CList VertexID -&gt; Maybe (CList VertexID)
forall a. Eq a =&gt; a -&gt; CList a -&gt; Maybe (CList a)
</span><span class="hs-identifier hs-var">CL.rotateTo</span></span><span> </span><span class="annot"><span class="annottext">CList VertexID
</span><a href="#local-6989586621679968052"><span class="hs-identifier hs-var">cl</span></a></span><span>
</span><span id="line-235"></span><span>
</span><span id="line-236"></span><span>
</span><span id="line-237"></span><span class="hs-comment">-- | Inserts an edge (and makes sure that the vertex is inserted in the</span><span>
</span><span id="line-238"></span><span class="hs-comment">-- correct. pos in the adjacency lists)</span><span>
</span><span id="line-239"></span><span id="local-6989586621679968316"><span id="local-6989586621679968317"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#insert%27"><span class="hs-identifier hs-type">insert'</span></a></span><span>               </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Num</span></span><span> </span><span class="annot"><a href="#local-6989586621679968317"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679968317"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-240"></span><span>                      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Mapping"><span class="hs-identifier hs-type">Mapping</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968316"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968317"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Adj"><span class="hs-identifier hs-type">Adj</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Adj"><span class="hs-identifier hs-type">Adj</span></a></span></span></span><span>
</span><span id="line-241"></span><span id="insert%27"><span class="annot"><span class="annottext">insert' :: VertexID -&gt; VertexID -&gt; Mapping p r -&gt; Adj -&gt; Adj
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#insert%27"><span class="hs-identifier hs-var hs-var">insert'</span></a></span></span><span> </span><span id="local-6989586621679968050"><span class="annot"><span class="annottext">u :: VertexID
</span><a href="#local-6989586621679968050"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span id="local-6989586621679968049"><span class="annot"><span class="annottext">v :: VertexID
</span><a href="#local-6989586621679968049"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-special">(</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span id="local-6989586621679968048"><span class="annot"><span class="annottext">ptMap :: Vector (Point 2 r :+ p)
</span><a href="#local-6989586621679968048"><span class="hs-identifier hs-var">ptMap</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(VertexID -&gt; CList VertexID -&gt; CList VertexID)
-&gt; VertexID -&gt; Adj -&gt; Adj
forall a. (VertexID -&gt; a -&gt; a) -&gt; VertexID -&gt; IntMap a -&gt; IntMap a
</span><span class="hs-identifier hs-var">IM.adjustWithKey</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VertexID -&gt; VertexID -&gt; CList VertexID -&gt; CList VertexID
</span><a href="#local-6989586621679968046"><span class="hs-identifier hs-var">insert''</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968049"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968050"><span class="hs-identifier hs-var">u</span></a></span><span>
</span><span id="line-242"></span><span>                      </span><span class="annot"><span class="annottext">(Adj -&gt; Adj) -&gt; (Adj -&gt; Adj) -&gt; Adj -&gt; Adj
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(VertexID -&gt; CList VertexID -&gt; CList VertexID)
-&gt; VertexID -&gt; Adj -&gt; Adj
forall a. (VertexID -&gt; a -&gt; a) -&gt; VertexID -&gt; IntMap a -&gt; IntMap a
</span><span class="hs-identifier hs-var">IM.adjustWithKey</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VertexID -&gt; VertexID -&gt; CList VertexID -&gt; CList VertexID
</span><a href="#local-6989586621679968046"><span class="hs-identifier hs-var">insert''</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968050"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968049"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-243"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-244"></span><span>    </span><span class="hs-comment">-- inserts b into the adjacency list of a</span><span>
</span><span id="line-245"></span><span>    </span><span id="local-6989586621679968046"><span class="annot"><span class="annottext">insert'' :: VertexID -&gt; VertexID -&gt; CList VertexID -&gt; CList VertexID
</span><a href="#local-6989586621679968046"><span class="hs-identifier hs-var hs-var">insert''</span></a></span></span><span> </span><span id="local-6989586621679968045"><span class="annot"><span class="annottext">bi :: VertexID
</span><a href="#local-6989586621679968045"><span class="hs-identifier hs-var">bi</span></a></span></span><span> </span><span id="local-6989586621679968044"><span class="annot"><span class="annottext">ai :: VertexID
</span><a href="#local-6989586621679968044"><span class="hs-identifier hs-var">ai</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(VertexID -&gt; VertexID -&gt; Ordering)
-&gt; VertexID -&gt; CList VertexID -&gt; CList VertexID
forall a. (a -&gt; a -&gt; Ordering) -&gt; a -&gt; CList a -&gt; CList a
</span><span class="hs-identifier hs-var">CU.insertOrdBy</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Point 2 r :+ p)
-&gt; (Point 2 r :+ p) -&gt; (Point 2 r :+ p) -&gt; Ordering
forall r c p q.
(Num r, Ord r) =&gt;
(Point 2 r :+ c)
-&gt; (Point 2 r :+ p) -&gt; (Point 2 r :+ q) -&gt; Ordering
</span><a href="#local-6989586621679968042"><span class="hs-identifier hs-var">cmp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621679968048"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p) -&gt; VertexID -&gt; Point 2 r :+ p
forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968044"><span class="hs-identifier hs-var">ai</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">((Point 2 r :+ p) -&gt; (Point 2 r :+ p) -&gt; Ordering)
-&gt; (VertexID -&gt; Point 2 r :+ p) -&gt; VertexID -&gt; VertexID -&gt; Ordering
forall b c a. (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c
</span><span class="hs-operator hs-var">`on`</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621679968048"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p) -&gt; VertexID -&gt; Point 2 r :+ p
forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968045"><span class="hs-identifier hs-var">bi</span></a></span><span>
</span><span id="line-246"></span><span>    </span><span id="local-6989586621679968042"><span class="annot"><span class="annottext">cmp :: (Point 2 r :+ c)
-&gt; (Point 2 r :+ p) -&gt; (Point 2 r :+ q) -&gt; Ordering
</span><a href="#local-6989586621679968042"><span class="hs-identifier hs-var hs-var">cmp</span></a></span></span><span> </span><span id="local-6989586621679968041"><span class="annot"><span class="annottext">c :: Point 2 r :+ c
</span><a href="#local-6989586621679968041"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679968040"><span class="annot"><span class="annottext">p :: Point 2 r :+ p
</span><a href="#local-6989586621679968040"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679968039"><span class="annot"><span class="annottext">q :: Point 2 r :+ q
</span><a href="#local-6989586621679968039"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Point 2 r :+ c)
-&gt; (Point 2 r :+ p) -&gt; (Point 2 r :+ q) -&gt; Ordering
forall r c p q.
(Num r, Ord r) =&gt;
(Point 2 r :+ c)
-&gt; (Point 2 r :+ p) -&gt; (Point 2 r :+ q) -&gt; Ordering
</span><a href="Data.Geometry.Point.Orientation.Degenerate.html#cwCmpAround%27"><span class="hs-identifier hs-var">cwCmpAround'</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ c
</span><a href="#local-6989586621679968041"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621679968040"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ q
</span><a href="#local-6989586621679968039"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">Ordering -&gt; Ordering -&gt; Ordering
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">(Point 2 r :+ c)
-&gt; (Point 2 r :+ p) -&gt; (Point 2 r :+ q) -&gt; Ordering
forall r (d :: Nat) c p q.
(Ord r, Num r, Arity d) =&gt;
(Point d r :+ c)
-&gt; (Point d r :+ p) -&gt; (Point d r :+ q) -&gt; Ordering
</span><a href="Data.Geometry.Point.Internal.html#cmpByDistanceTo%27"><span class="hs-identifier hs-var">cmpByDistanceTo'</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ c
</span><a href="#local-6989586621679968041"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ p
</span><a href="#local-6989586621679968040"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ q
</span><a href="#local-6989586621679968039"><span class="hs-identifier hs-var">q</span></a></span><span>
</span><span id="line-247"></span><span>
</span><span id="line-248"></span><span>
</span><span id="line-249"></span><span class="hs-comment">-- | Deletes an edge</span><span>
</span><span id="line-250"></span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delete"><span class="hs-identifier hs-type">delete</span></a></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Adj"><span class="hs-identifier hs-type">Adj</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#Adj"><span class="hs-identifier hs-type">Adj</span></a></span><span>
</span><span id="line-251"></span><span id="delete"><span class="annot"><span class="annottext">delete :: VertexID -&gt; VertexID -&gt; Adj -&gt; Adj
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#delete"><span class="hs-identifier hs-var hs-var">delete</span></a></span></span><span> </span><span id="local-6989586621679968036"><span class="annot"><span class="annottext">u :: VertexID
</span><a href="#local-6989586621679968036"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span id="local-6989586621679968035"><span class="annot"><span class="annottext">v :: VertexID
</span><a href="#local-6989586621679968035"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(CList VertexID -&gt; CList VertexID) -&gt; VertexID -&gt; Adj -&gt; Adj
forall a. (a -&gt; a) -&gt; VertexID -&gt; IntMap a -&gt; IntMap a
</span><span class="hs-identifier hs-var">IM.adjust</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VertexID -&gt; CList VertexID -&gt; CList VertexID
forall a. Eq a =&gt; a -&gt; CList a -&gt; CList a
</span><a href="#local-6989586621679968034"><span class="hs-identifier hs-var">delete'</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968035"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968036"><span class="hs-identifier hs-var">u</span></a></span><span> </span><span class="annot"><span class="annottext">(Adj -&gt; Adj) -&gt; (Adj -&gt; Adj) -&gt; Adj -&gt; Adj
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(CList VertexID -&gt; CList VertexID) -&gt; VertexID -&gt; Adj -&gt; Adj
forall a. (a -&gt; a) -&gt; VertexID -&gt; IntMap a -&gt; IntMap a
</span><span class="hs-identifier hs-var">IM.adjust</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VertexID -&gt; CList VertexID -&gt; CList VertexID
forall a. Eq a =&gt; a -&gt; CList a -&gt; CList a
</span><a href="#local-6989586621679968034"><span class="hs-identifier hs-var">delete'</span></a></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968036"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968035"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-252"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-253"></span><span>    </span><span id="local-6989586621679968034"><span class="annot"><span class="annottext">delete' :: a -&gt; CList a -&gt; CList a
</span><a href="#local-6989586621679968034"><span class="hs-identifier hs-var hs-var">delete'</span></a></span></span><span> </span><span id="local-6989586621679968033"><span class="annot"><span class="annottext">x :: a
</span><a href="#local-6989586621679968033"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; Bool) -&gt; CList a -&gt; CList a
forall a. (a -&gt; Bool) -&gt; CList a -&gt; CList a
</span><span class="hs-identifier hs-var">CL.filterL</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; a -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679968033"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- should we rotate left or right if it is the focus?</span><span>
</span><span id="line-254"></span><span>
</span><span id="line-255"></span><span>
</span><span id="line-256"></span><span class="hs-comment">-- | Lifted version of Convex.IsLeftOf</span><span>
</span><span id="line-257"></span><span id="local-6989586621679968361"><span id="local-6989586621679968362"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#isLeftOf"><span class="hs-identifier hs-type">isLeftOf</span></a></span><span>           </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679968362"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Num</span></span><span> </span><span class="annot"><a href="#local-6989586621679968362"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-258"></span><span>                   </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-type">Merge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968361"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968362"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span><span>
</span><span id="line-259"></span><span id="local-6989586621679968030"><span class="annot"><span class="annottext">p :: VertexID
</span><a href="#local-6989586621679968030"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="isLeftOf"><span class="annot"><span class="annottext">isLeftOf :: VertexID -&gt; (VertexID, VertexID) -&gt; Merge p r Bool
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#isLeftOf"><span class="hs-operator hs-var hs-var">`isLeftOf`</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679968029"><span class="annot"><span class="annottext">l :: VertexID
</span><a href="#local-6989586621679968029"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679968028"><span class="annot"><span class="annottext">r :: VertexID
</span><a href="#local-6989586621679968028"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(((Map (Point 2 r) VertexID, Vector (Point 2 r :+ p)), Firsts)
 -&gt; Bool)
-&gt; Merge p r Bool
forall r (m :: * -&gt; *) a. MonadReader r m =&gt; (r -&gt; a) -&gt; m a
</span><span class="hs-identifier hs-var">asks</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p) -&gt; Bool
</span><a href="#local-6989586621679968027"><span class="hs-identifier hs-var">withPtMap</span></a></span><span> </span><span class="annot"><span class="annottext">(Vector (Point 2 r :+ p) -&gt; Bool)
-&gt; (((Map (Point 2 r) VertexID, Vector (Point 2 r :+ p)), Firsts)
    -&gt; Vector (Point 2 r :+ p))
-&gt; ((Map (Point 2 r) VertexID, Vector (Point 2 r :+ p)), Firsts)
-&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Map (Point 2 r) VertexID, Vector (Point 2 r :+ p))
-&gt; Vector (Point 2 r :+ p)
forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span> </span><span class="annot"><span class="annottext">((Map (Point 2 r) VertexID, Vector (Point 2 r :+ p))
 -&gt; Vector (Point 2 r :+ p))
-&gt; (((Map (Point 2 r) VertexID, Vector (Point 2 r :+ p)), Firsts)
    -&gt; (Map (Point 2 r) VertexID, Vector (Point 2 r :+ p)))
-&gt; ((Map (Point 2 r) VertexID, Vector (Point 2 r :+ p)), Firsts)
-&gt; Vector (Point 2 r :+ p)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">((Map (Point 2 r) VertexID, Vector (Point 2 r :+ p)), Firsts)
-&gt; (Map (Point 2 r) VertexID, Vector (Point 2 r :+ p))
forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span>
</span><span id="line-260"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-261"></span><span>    </span><span id="local-6989586621679968027"><span class="annot"><span class="annottext">withPtMap :: Vector (Point 2 r :+ p) -&gt; Bool
</span><a href="#local-6989586621679968027"><span class="hs-identifier hs-var hs-var">withPtMap</span></a></span></span><span> </span><span id="local-6989586621679968026"><span class="annot"><span class="annottext">ptMap :: Vector (Point 2 r :+ p)
</span><a href="#local-6989586621679968026"><span class="hs-identifier hs-var">ptMap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621679968026"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p) -&gt; VertexID -&gt; Point 2 r :+ p
forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968030"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Point 2 r :+ p) -&gt; (Point 2 r :+ p, Point 2 r :+ p) -&gt; Bool
forall r c a b.
(Ord r, Num r) =&gt;
(Point 2 r :+ c) -&gt; (Point 2 r :+ a, Point 2 r :+ b) -&gt; Bool
</span><a href="#local-6989586621679968025"><span class="hs-operator hs-var">`isLeftOf'`</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621679968026"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p) -&gt; VertexID -&gt; Point 2 r :+ p
forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968029"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621679968026"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p) -&gt; VertexID -&gt; Point 2 r :+ p
forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968028"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-262"></span><span>    </span><span id="local-6989586621679968024"><span class="annot"><span class="annottext">a :: Point 2 r :+ c
</span><a href="#local-6989586621679968024"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679968025"><span class="annot"><span class="annottext">isLeftOf' :: (Point 2 r :+ c) -&gt; (Point 2 r :+ a, Point 2 r :+ b) -&gt; Bool
</span><a href="#local-6989586621679968025"><span class="hs-operator hs-var hs-var">`isLeftOf'`</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679968023"><span class="annot"><span class="annottext">b :: Point 2 r :+ a
</span><a href="#local-6989586621679968023"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679968022"><span class="annot"><span class="annottext">c :: Point 2 r :+ b
</span><a href="#local-6989586621679968022"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Point 2 r :+ a) -&gt; (Point 2 r :+ b) -&gt; (Point 2 r :+ c) -&gt; CCW
forall r a b c.
(Ord r, Num r) =&gt;
(Point 2 r :+ a) -&gt; (Point 2 r :+ b) -&gt; (Point 2 r :+ c) -&gt; CCW
</span><a href="Data.Geometry.Point.Orientation.Degenerate.html#ccw%27"><span class="hs-identifier hs-var">ccw'</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ a
</span><a href="#local-6989586621679968023"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ b
</span><a href="#local-6989586621679968022"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ c
</span><a href="#local-6989586621679968024"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">CCW -&gt; CCW -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">CCW
</span><a href="Data.Geometry.Point.Orientation.Degenerate.html#CCW"><span class="hs-identifier hs-var">CCW</span></a></span><span>
</span><span id="line-263"></span><span>
</span><span id="line-264"></span><span class="hs-comment">-- | Lifted version of Convex.IsRightOf</span><span>
</span><span id="line-265"></span><span id="local-6989586621679968018"><span id="local-6989586621679968019"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#isRightOf"><span class="hs-identifier hs-type">isRightOf</span></a></span><span>           </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679968019"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Num</span></span><span> </span><span class="annot"><a href="#local-6989586621679968019"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-266"></span><span>                    </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.Types.html#VertexID"><span class="hs-identifier hs-type">VertexID</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#Merge"><span class="hs-identifier hs-type">Merge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968018"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968019"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span><span>
</span><span id="line-267"></span><span id="local-6989586621679968017"><span class="annot"><span class="annottext">p :: VertexID
</span><a href="#local-6989586621679968017"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="isRightOf"><span class="annot"><span class="annottext">isRightOf :: VertexID -&gt; (VertexID, VertexID) -&gt; Merge p r Bool
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#isRightOf"><span class="hs-operator hs-var hs-var">`isRightOf`</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679968016"><span class="annot"><span class="annottext">l :: VertexID
</span><a href="#local-6989586621679968016"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679968015"><span class="annot"><span class="annottext">r :: VertexID
</span><a href="#local-6989586621679968015"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(((Map (Point 2 r) VertexID, Vector (Point 2 r :+ p)), Firsts)
 -&gt; Bool)
-&gt; Merge p r Bool
forall r (m :: * -&gt; *) a. MonadReader r m =&gt; (r -&gt; a) -&gt; m a
</span><span class="hs-identifier hs-var">asks</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p) -&gt; Bool
</span><a href="#local-6989586621679968014"><span class="hs-identifier hs-var">withPtMap</span></a></span><span> </span><span class="annot"><span class="annottext">(Vector (Point 2 r :+ p) -&gt; Bool)
-&gt; (((Map (Point 2 r) VertexID, Vector (Point 2 r :+ p)), Firsts)
    -&gt; Vector (Point 2 r :+ p))
-&gt; ((Map (Point 2 r) VertexID, Vector (Point 2 r :+ p)), Firsts)
-&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Map (Point 2 r) VertexID, Vector (Point 2 r :+ p))
-&gt; Vector (Point 2 r :+ p)
forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span> </span><span class="annot"><span class="annottext">((Map (Point 2 r) VertexID, Vector (Point 2 r :+ p))
 -&gt; Vector (Point 2 r :+ p))
-&gt; (((Map (Point 2 r) VertexID, Vector (Point 2 r :+ p)), Firsts)
    -&gt; (Map (Point 2 r) VertexID, Vector (Point 2 r :+ p)))
-&gt; ((Map (Point 2 r) VertexID, Vector (Point 2 r :+ p)), Firsts)
-&gt; Vector (Point 2 r :+ p)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">((Map (Point 2 r) VertexID, Vector (Point 2 r :+ p)), Firsts)
-&gt; (Map (Point 2 r) VertexID, Vector (Point 2 r :+ p))
forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span>
</span><span id="line-268"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-269"></span><span>    </span><span id="local-6989586621679968014"><span class="annot"><span class="annottext">withPtMap :: Vector (Point 2 r :+ p) -&gt; Bool
</span><a href="#local-6989586621679968014"><span class="hs-identifier hs-var hs-var">withPtMap</span></a></span></span><span> </span><span id="local-6989586621679968013"><span class="annot"><span class="annottext">ptMap :: Vector (Point 2 r :+ p)
</span><a href="#local-6989586621679968013"><span class="hs-identifier hs-var">ptMap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621679968013"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p) -&gt; VertexID -&gt; Point 2 r :+ p
forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968017"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Point 2 r :+ p) -&gt; (Point 2 r :+ p, Point 2 r :+ p) -&gt; Bool
forall r c a b.
(Ord r, Num r) =&gt;
(Point 2 r :+ c) -&gt; (Point 2 r :+ a, Point 2 r :+ b) -&gt; Bool
</span><a href="#local-6989586621679968012"><span class="hs-operator hs-var">`isRightOf'`</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621679968013"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p) -&gt; VertexID -&gt; Point 2 r :+ p
forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968016"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p)
</span><a href="#local-6989586621679968013"><span class="hs-identifier hs-var">ptMap</span></a></span><span> </span><span class="annot"><span class="annottext">Vector (Point 2 r :+ p) -&gt; VertexID -&gt; Point 2 r :+ p
forall a. Vector a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">V.!</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679968015"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-270"></span><span>    </span><span id="local-6989586621679968011"><span class="annot"><span class="annottext">a :: Point 2 r :+ c
</span><a href="#local-6989586621679968011"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679968012"><span class="annot"><span class="annottext">isRightOf' :: (Point 2 r :+ c) -&gt; (Point 2 r :+ a, Point 2 r :+ b) -&gt; Bool
</span><a href="#local-6989586621679968012"><span class="hs-operator hs-var hs-var">`isRightOf'`</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679968010"><span class="annot"><span class="annottext">b :: Point 2 r :+ a
</span><a href="#local-6989586621679968010"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679968009"><span class="annot"><span class="annottext">c :: Point 2 r :+ b
</span><a href="#local-6989586621679968009"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Point 2 r :+ a) -&gt; (Point 2 r :+ b) -&gt; (Point 2 r :+ c) -&gt; CCW
forall r a b c.
(Ord r, Num r) =&gt;
(Point 2 r :+ a) -&gt; (Point 2 r :+ b) -&gt; (Point 2 r :+ c) -&gt; CCW
</span><a href="Data.Geometry.Point.Orientation.Degenerate.html#ccw%27"><span class="hs-identifier hs-var">ccw'</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ a
</span><a href="#local-6989586621679968010"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ b
</span><a href="#local-6989586621679968009"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">Point 2 r :+ c
</span><a href="#local-6989586621679968011"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">CCW -&gt; CCW -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">CCW
</span><a href="Data.Geometry.Point.Orientation.Degenerate.html#CW"><span class="hs-identifier hs-var">CW</span></a></span><span>
</span><span id="line-271"></span><span>
</span><span id="line-272"></span><span class="hs-comment">--------------------------------------------------------------------------------</span><span>
</span><span id="line-273"></span><span class="hs-comment">-- * Some Helper functions</span><span>
</span><span id="line-274"></span><span>
</span><span id="line-275"></span><span>
</span><span id="line-276"></span><span id="local-6989586621679968470"><span id="local-6989586621679968471"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27"><span class="hs-identifier hs-type">lookup'</span></a></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679968471"><span class="hs-identifier hs-type">k</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">M.Map</span></span><span> </span><span class="annot"><a href="#local-6989586621679968471"><span class="hs-identifier hs-type">k</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679968470"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679968471"><span class="hs-identifier hs-type">k</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679968470"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-277"></span><span id="lookup%27"><span class="annot"><span class="annottext">lookup' :: Map k a -&gt; k -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27"><span class="hs-identifier hs-var hs-var">lookup'</span></a></span></span><span> </span><span id="local-6989586621679968007"><span class="annot"><span class="annottext">m :: Map k a
</span><a href="#local-6989586621679968007"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679968006"><span class="annot"><span class="annottext">x :: k
</span><a href="#local-6989586621679968006"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe a -&gt; a
forall a. HasCallStack =&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromJust</span></span><span> </span><span class="annot"><span class="annottext">(Maybe a -&gt; a) -&gt; Maybe a -&gt; a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">k -&gt; Map k a -&gt; Maybe a
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><span class="hs-identifier hs-var">M.lookup</span></span><span> </span><span class="annot"><span class="annottext">k
</span><a href="#local-6989586621679968006"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Map k a
</span><a href="#local-6989586621679968007"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-278"></span><span>
</span><span id="line-279"></span><span id="local-6989586621679968473"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#size%27"><span class="hs-identifier hs-type">size'</span></a></span><span>              </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">BinLeafTree</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Size</span></span><span> </span><span class="annot"><a href="#local-6989586621679968473"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Size</span></span></span><span>
</span><span id="line-280"></span><span id="size%27"><span class="annot"><span class="annottext">size' :: BinLeafTree Size a -&gt; Size
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#size%27"><span class="hs-identifier hs-var hs-var">size'</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Leaf</span></span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-number">1</span></span><span>
</span><span id="line-281"></span><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#size%27"><span class="hs-identifier hs-var">size'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Node</span></span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679968004"><span class="annot"><span class="annottext">s :: Size
</span><a href="#local-6989586621679968004"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Size
</span><a href="#local-6989586621679968004"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-282"></span><span>
</span><span id="line-283"></span><span class="hs-comment">-- | an 'unsafe' version of rotateTo that assumes the element to rotate to</span><span>
</span><span id="line-284"></span><span class="hs-comment">-- occurs in the list.</span><span>
</span><span id="line-285"></span><span id="local-6989586621679968371"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateTo"><span class="hs-identifier hs-type">rotateTo</span></a></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679968371"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679968371"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">CL.CList</span></span><span> </span><span class="annot"><a href="#local-6989586621679968371"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">CL.CList</span></span><span> </span><span class="annot"><a href="#local-6989586621679968371"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-286"></span><span id="rotateTo"><span class="annot"><span class="annottext">rotateTo :: a -&gt; CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#rotateTo"><span class="hs-identifier hs-var hs-var">rotateTo</span></a></span></span><span> </span><span id="local-6989586621679968003"><span class="annot"><span class="annottext">x :: a
</span><a href="#local-6989586621679968003"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (CList a) -&gt; CList a
forall a. HasCallStack =&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromJust</span></span><span> </span><span class="annot"><span class="annottext">(Maybe (CList a) -&gt; CList a)
-&gt; (CList a -&gt; Maybe (CList a)) -&gt; CList a -&gt; CList a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; CList a -&gt; Maybe (CList a)
forall a. Eq a =&gt; a -&gt; CList a -&gt; Maybe (CList a)
</span><span class="hs-identifier hs-var">CL.rotateTo</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679968003"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-287"></span><span>
</span><span id="line-288"></span><span class="hs-comment">-- | Adjacency lists are stored in clockwise order, so pred means rotate right</span><span>
</span><span id="line-289"></span><span id="local-6989586621679968372"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#pred%27"><span class="hs-identifier hs-type">pred'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">CL.CList</span></span><span> </span><span class="annot"><a href="#local-6989586621679968372"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">CL.CList</span></span><span> </span><span class="annot"><a href="#local-6989586621679968372"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-290"></span><span id="pred%27"><span class="annot"><span class="annottext">pred' :: CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#pred%27"><span class="hs-identifier hs-var hs-var">pred'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CList a -&gt; CList a
forall a. CList a -&gt; CList a
</span><span class="hs-identifier hs-var">CL.rotR</span></span><span>
</span><span id="line-291"></span><span>
</span><span id="line-292"></span><span class="hs-comment">-- | Adjacency lists are stored in clockwise order, so pred and succ rotate left</span><span>
</span><span id="line-293"></span><span id="local-6989586621679968001"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#succ%27"><span class="hs-identifier hs-type">succ'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">CL.CList</span></span><span> </span><span class="annot"><a href="#local-6989586621679968001"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">CL.CList</span></span><span> </span><span class="annot"><a href="#local-6989586621679968001"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-294"></span><span id="succ%27"><span class="annot"><span class="annottext">succ' :: CList a -&gt; CList a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#succ%27"><span class="hs-identifier hs-var hs-var">succ'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CList a -&gt; CList a
forall a. CList a -&gt; CList a
</span><span class="hs-identifier hs-var">CL.rotL</span></span><span>
</span><span id="line-295"></span><span>
</span><span id="line-296"></span><span class="hs-comment">-- | Return the focus of the CList, throwing an exception if the list is empty.</span><span>
</span><span id="line-297"></span><span id="local-6989586621679968365"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-type">focus'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">CL.CList</span></span><span> </span><span class="annot"><a href="#local-6989586621679968365"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679968365"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-298"></span><span id="focus%27"><span class="annot"><span class="annottext">focus' :: CList a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#focus%27"><span class="hs-identifier hs-var hs-var">focus'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe a -&gt; a
forall a. HasCallStack =&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromJust</span></span><span> </span><span class="annot"><span class="annottext">(Maybe a -&gt; a) -&gt; (CList a -&gt; Maybe a) -&gt; CList a -&gt; a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">CList a -&gt; Maybe a
forall a. CList a -&gt; Maybe a
</span><span class="hs-identifier hs-var">CL.focus</span></span><span>
</span><span id="line-299"></span><span>
</span><span id="line-300"></span><span class="hs-comment">-- | Removes duplicates from a sorted list</span><span>
</span><span id="line-301"></span><span id="local-6989586621679968519"><span id="local-6989586621679968520"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#nub%27"><span class="hs-identifier hs-type">nub'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679968520"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NonEmpty.NonEmpty</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679968520"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="#local-6989586621679968519"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NonEmpty.NonEmpty</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679968520"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="#local-6989586621679968519"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-302"></span><span id="nub%27"><span class="annot"><span class="annottext">nub' :: NonEmpty (a :+ b) -&gt; NonEmpty (a :+ b)
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#nub%27"><span class="hs-identifier hs-var hs-var">nub'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(NonEmpty (a :+ b) -&gt; a :+ b)
-&gt; NonEmpty (NonEmpty (a :+ b)) -&gt; NonEmpty (a :+ b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">NonEmpty (a :+ b) -&gt; a :+ b
forall a. NonEmpty a -&gt; a
</span><span class="hs-identifier hs-var">NonEmpty.head</span></span><span> </span><span class="annot"><span class="annottext">(NonEmpty (NonEmpty (a :+ b)) -&gt; NonEmpty (a :+ b))
-&gt; (NonEmpty (a :+ b) -&gt; NonEmpty (NonEmpty (a :+ b)))
-&gt; NonEmpty (a :+ b)
-&gt; NonEmpty (a :+ b)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">((a :+ b) -&gt; (a :+ b) -&gt; Bool)
-&gt; NonEmpty (a :+ b) -&gt; NonEmpty (NonEmpty (a :+ b))
forall a. (a -&gt; a -&gt; Bool) -&gt; NonEmpty a -&gt; NonEmpty (NonEmpty a)
</span><span class="hs-identifier hs-var">NonEmpty.groupBy1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; a -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">(==)</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; a -&gt; Bool) -&gt; ((a :+ b) -&gt; a) -&gt; (a :+ b) -&gt; (a :+ b) -&gt; Bool
forall b c a. (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c
</span><span class="hs-operator hs-var">`on`</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a :+ b) -&gt; Getting a (a :+ b) a -&gt; a
forall s a. s -&gt; Getting a s a -&gt; a
</span><span class="hs-operator hs-var">^.</span></span><span class="annot"><span class="annottext">Getting a (a :+ b) a
forall core extra core'.
Lens (core :+ extra) (core' :+ extra) core core'
</span><span class="hs-identifier hs-var">core</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-303"></span><span>
</span><span id="line-304"></span><span>
</span><span id="line-305"></span><span id="local-6989586621679968460"><span id="local-6989586621679968461"><span id="local-6989586621679968462"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#withID"><span class="hs-identifier hs-type">withID</span></a></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679968462"><span class="hs-identifier hs-type">c</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="#local-6989586621679968461"><span class="hs-identifier hs-type">e</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679968460"><span class="hs-identifier hs-type">e'</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679968462"><span class="hs-identifier hs-type">c</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679968461"><span class="hs-identifier hs-type">e</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+</span></span><span> </span><span class="annot"><a href="#local-6989586621679968460"><span class="hs-identifier hs-type">e'</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-306"></span><span id="withID"><span class="annot"><span class="annottext">withID :: (c :+ e) -&gt; e' -&gt; c :+ (e :+ e')
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#withID"><span class="hs-identifier hs-var hs-var">withID</span></a></span></span><span> </span><span id="local-6989586621679967996"><span class="annot"><span class="annottext">p :: c :+ e
</span><a href="#local-6989586621679967996"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679967995"><span class="annot"><span class="annottext">i :: e'
</span><a href="#local-6989586621679967995"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">c :+ e
</span><a href="#local-6989586621679967996"><span class="hs-identifier hs-var">p</span></a></span><span class="annot"><span class="annottext">(c :+ e) -&gt; ((c :+ e) -&gt; c :+ (e :+ e')) -&gt; c :+ (e :+ e')
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span><span class="hs-operator hs-var">&amp;</span></span><span class="annot"><span class="annottext">(e -&gt; Identity (e :+ e')) -&gt; (c :+ e) -&gt; Identity (c :+ (e :+ e'))
forall core extra extra'.
Lens (core :+ extra) (core :+ extra') extra extra'
</span><span class="hs-identifier hs-var">extra</span></span><span> </span><span class="annot"><span class="annottext">((e -&gt; Identity (e :+ e'))
 -&gt; (c :+ e) -&gt; Identity (c :+ (e :+ e')))
-&gt; (e -&gt; e :+ e') -&gt; (c :+ e) -&gt; c :+ (e :+ e')
forall s t a b. ASetter s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
</span><span class="hs-operator hs-var">%~</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">e -&gt; e' -&gt; e :+ e'
forall core extra. core -&gt; extra -&gt; core :+ extra
</span><span class="hs-operator hs-var">:+</span></span><span class="annot"><span class="annottext">e'
</span><a href="#local-6989586621679967995"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-307"></span><span>
</span><span id="line-308"></span><span id="local-6989586621679968370"><span class="annot"><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27%27"><span class="hs-identifier hs-type">lookup''</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IM.IntMap</span></span><span> </span><span class="annot"><a href="#local-6989586621679968370"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679968370"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-309"></span><span id="lookup%27%27"><span class="annot"><span class="annottext">lookup'' :: VertexID -&gt; IntMap a -&gt; a
</span><a href="Algorithms.Geometry.DelaunayTriangulation.DivideAndConquer.html#lookup%27%27"><span class="hs-identifier hs-var hs-var">lookup''</span></a></span></span><span> </span><span id="local-6989586621679967991"><span class="annot"><span class="annottext">k :: VertexID
</span><a href="#local-6989586621679967991"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679967990"><span class="annot"><span class="annottext">m :: IntMap a
</span><a href="#local-6989586621679967990"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">IntMap a
</span><a href="#local-6989586621679967990"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap a -&gt; VertexID -&gt; a
forall a. IntMap a -&gt; VertexID -&gt; a
</span><span class="hs-operator hs-var">IM.!</span></span><span> </span><span class="annot"><span class="annottext">VertexID
</span><a href="#local-6989586621679967991"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-310"></span></pre></body></html>