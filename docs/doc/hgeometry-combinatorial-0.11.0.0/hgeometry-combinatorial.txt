-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Data structures, and Data types.
--   
--   The Non-geometric data types and algorithms used in HGeometry.
@package hgeometry-combinatorial
@version 0.11.0.0


module Algorithms.BinarySearch

-- | Given a monotonic predicate p, a lower bound l, and an upper bound u,
--   with: p l = False p u = True l &lt; u.
--   
--   Get the index h such that everything strictly smaller than h has: p i
--   = False, and all i &gt;= h, we have p h = True
--   
--   running time: &lt;math&gt;
binarySearch :: Integral a => (a -> Bool) -> a -> a -> a

-- | Given a value &lt;math&gt;, a monotone predicate &lt;math&gt;, and two
--   values &lt;math&gt; and &lt;math&gt; with:
--   
--   <ul>
--   <li>&lt;math&gt; = False</li>
--   <li>&lt;math&gt; = True</li>
--   <li>&lt;math&gt;</li>
--   </ul>
--   
--   we find a value &lt;math&gt; such that:
--   
--   <ul>
--   <li>&lt;math&gt; = True</li>
--   <li>&lt;math&gt; = False</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; binarySearchUntil (0.1) (&gt;= 0.5) 0 (1 :: Double)
--   0.5
--   
--   &gt;&gt;&gt; binarySearchUntil (0.1) (&gt;= 0.51) 0 (1 :: Double)
--   0.5625
--   
--   &gt;&gt;&gt; binarySearchUntil (0.01) (&gt;= 0.51) 0 (1 :: Double)
--   0.515625
--   </pre>
binarySearchUntil :: (Fractional r, Ord r) => r -> (r -> Bool) -> r -> r -> r

-- | Given a monotonic predicate, Get the index h such that everything
--   strictly smaller than h has: p i = False, and all i &gt;= h, we have p
--   h = True
--   
--   returns Nothing if no element satisfies p
--   
--   running time: &lt;math&gt;, where &lt;math&gt; is the time to execute
--   the predicate.
binarySearchSeq :: (a -> Bool) -> Seq a -> Maybe Int

-- | Given a monotonic predicate, get the index h such that everything
--   strictly smaller than h has: p i = False, and all i &gt;= h, we have p
--   h = True
--   
--   returns Nothing if no element satisfies p
--   
--   running time: &lt;math&gt;, where &lt;math&gt; is the time to execute
--   the predicate.
binarySearchVec :: Vector v a => (a -> Bool) -> v a -> Maybe Int


module Algorithms.DivideAndConquer

-- | Divide and conquer strategy. See <a>divideAndConquer1</a>.
divideAndConquer :: (Foldable f, Monoid s) => (a -> s) -> f a -> s

-- | Divide and conquer strategy
--   
--   the running time satifies T(n) = 2T(n/2) + M(n),
--   
--   where M(n) is the time corresponding to the semigroup operation of s
--   on n elements.
divideAndConquer1 :: (Foldable1 f, Semigroup s) => (a -> s) -> f a -> s

-- | Divide and conquer strategy
--   
--   the running time satifies T(n) = 2T(n/2) + M(n),
--   
--   where M(n) is the time corresponding to the semigroup operation of s
--   on n elements.
divideAndConquer1With :: Foldable1 f => (s -> s -> s) -> (a -> s) -> f a -> s

-- | Merges two sorted non-Empty lists in linear time.
mergeSorted :: Ord a => NonEmpty a -> NonEmpty a -> NonEmpty a

-- | Merges two sorted lists in linear time.
mergeSortedLists :: Ord a => [a] -> [a] -> [a]

-- | Given an ordering and two nonempty sequences ordered according to that
--   ordering, merge them.
--   
--   running time: &lt;math&gt;, where &lt;math&gt; is the length of the
--   list, and &lt;math&gt; the time required to compare two elements.
mergeSortedBy :: (a -> a -> Ordering) -> NonEmpty a -> NonEmpty a -> NonEmpty a

-- | Given an ordering and two nonempty sequences ordered according to that
--   ordering, merge them
--   
--   running time: &lt;math&gt;, where &lt;math&gt; is the length of the
--   list, and &lt;math&gt; the time required to compare two elements.
mergeSortedListsBy :: (a -> a -> Ordering) -> [a] -> [a] -> [a]


-- | Implementation of Floyd-Warshall shortest path algorithm.
--   
--   See Wikipedia article for details:
--   <a>https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm</a>
module Algorithms.FloydWarshall
mkIndex :: Num a => a -> (a, a) -> a
mkGraph :: (Unbox a, Num a) => Int -> a -> [(Int, Int, a)] -> ST s (MVector s (a, Int))

-- | &lt;math&gt;
floydWarshall :: (Unbox a, Fractional a, Ord a) => Int -> MVector s (a, Int) -> ST s ()


-- | Implementation of Knuth-Morris-Pratt String-searching algorithm. The
--   exposition is based on that of Goodrich and Tamassia in "Data
--   Structures and Algorithms in Java 2nd Edition".
module Algorithms.StringSearch.KMP

-- | Test if the first argument, the pattern p, occurs as a consecutive
--   subsequence in t.
--   
--   running time: &lt;math&gt;, where p has length &lt;math&gt; and t has
--   length &lt;math&gt;.
isSubStringOf :: (Eq a, Foldable p, Foldable t) => p a -> t a -> Maybe Int

-- | Test if the first argument, the pattern p, occurs as a consecutive
--   subsequence in t.
--   
--   running time: &lt;math&gt;, where p has length &lt;math&gt; and t has
--   length &lt;math&gt;.
kmpMatch :: Eq a => Vector a -> Vector a -> Maybe Int

-- | Constructs the failure function.
--   
--   running time: &lt;math&gt;.
buildFailureFunction :: forall a. Eq a => Vector a -> Vector Int


module Control.CanAquire

-- | Run a computation on something that can aquire i's.
runAcquire :: forall t a b. Traversable t => (forall s. CanAquire (I s a) a => t (I s a) -> b) -> t a -> b
class HasIndex i Int => CanAquire i a

-- | A value of type i can obtain something of type <tt>a</tt>
aquire :: CanAquire i a => i -> a
class HasIndex t i | t -> i

-- | Types that have an instance of this class can act as indices.
indexOf :: HasIndex t i => t -> i

-- | Replaces every element by an index. Returns the new traversable
--   containing only these indices, as well as a vector with the values.
--   (such that indexing in this value gives the original value).
replaceByIndex :: forall t a. Traversable t => t a -> (Vector a, t Int)

-- | Label each element with its index. Returns the new collection as well
--   as its size.
labelWithIndex :: Traversable t => t a -> (t (Int, a), Int)

-- | A type that can act as an Index.
data I (s :: *) a
instance forall s k (a :: k). GHC.Enum.Enum (Control.CanAquire.I s a)
instance forall s k (a :: k). GHC.Classes.Ord (Control.CanAquire.I s a)
instance forall s k (a :: k). GHC.Classes.Eq (Control.CanAquire.I s a)
instance forall k s (a :: k). GHC.Show.Show (Control.CanAquire.I s a)
instance forall k s (a :: k). Control.CanAquire.HasIndex (Control.CanAquire.I s a) GHC.Types.Int
instance Data.Reflection.Reifies s (Data.Vector.Vector a) => Control.CanAquire.CanAquire (Control.CanAquire.I s a) a


module Control.Monad.State.Persistent

-- | A State monad that can store earlier versions of the state.
data PersistentStateT s m a

-- | A State monad that can store earlier versions of the state.
type PersistentState s = PersistentStateT s Identity

-- | Create a snapshot of the current state and add it to the list of
--   states that we store.
store :: Monad m => PersistentStateT s m ()

-- | Run a persistentStateT, returns a triplet with the value, the last
--   state and a list of all states (including the last one) in
--   chronological order
runPersistentStateT :: Functor m => PersistentStateT s m a -> s -> m (a, s, [s])

-- | Run a persistentStateT, returns a triplet with the value, the last
--   state and a list of all states (including the last one) in
--   chronological order
runPersistentState :: PersistentState s a -> s -> (a, s, [s])
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.State.Persistent.PersistentStateT s m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Monad.State.Persistent.PersistentStateT s m)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.State.Persistent.PersistentStateT s m)
instance GHC.Base.Monad m => Control.Monad.State.Class.MonadState s (Control.Monad.State.Persistent.PersistentStateT s m)


module Data.CircularList.Util

-- | Given a circular list, whose elements are in increasing order, insert
--   the new element into the Circular list in its sorted order.
--   
--   <pre>
--   &gt;&gt;&gt; insertOrd 1 C.empty
--   fromList [1]
--   
--   &gt;&gt;&gt; insertOrd 1 $ C.fromList [2]
--   fromList [2,1]
--   
--   &gt;&gt;&gt; insertOrd 2 $ C.fromList [1,3]
--   fromList [1,2,3]
--   
--   &gt;&gt;&gt; insertOrd 31 ordList
--   fromList [5,6,10,20,30,31,1,2,3]
--   
--   &gt;&gt;&gt; insertOrd 1 ordList
--   fromList [5,6,10,20,30,1,1,2,3]
--   
--   &gt;&gt;&gt; insertOrd 4 ordList
--   fromList [5,6,10,20,30,1,2,3,4]
--   
--   &gt;&gt;&gt; insertOrd 11 ordList
--   fromList [5,6,10,11,20,30,1,2,3]
--   </pre>
insertOrd :: Ord a => a -> CList a -> CList a

-- | Insert an element into an increasingly ordered circular list, with
--   specified compare operator.
insertOrdBy :: (a -> a -> Ordering) -> a -> CList a -> CList a

-- | List version of insertOrdBy; i.e. the list contains the elements in
--   cirulcar order. Again produces a list that has the items in circular
--   order.
insertOrdBy' :: (a -> a -> Ordering) -> a -> [a] -> [a]

-- | Given a list of elements that is supposedly a a cyclic-shift of a list
--   of increasing items, find the splitting point. I.e. returns a pair of
--   lists (ys,zs) such that xs = zs ++ ys, and ys ++ zs is (supposedly) in
--   sorted order.
splitIncr :: (a -> a -> Ordering) -> [a] -> ([a], [a])

-- | Test if the circular list is a cyclic shift of the second list.
--   Running time: O(n), where n is the size of the smallest list
isShiftOf :: Eq a => CList a -> CList a -> Bool


module Data.DynamicOrd

-- | Values of type <tt>a</tt> in our dynamically constructed <a>Ord</a>
--   instance
newtype O (s :: *) (a :: *)
O :: a -> O (s :: *) (a :: *)
[runO] :: O (s :: *) (a :: *) -> a

-- | An Ord Dictionary
newtype OrdDict a
OrdDict :: (a -> a -> Ordering) -> OrdDict a
[compare_] :: OrdDict a -> a -> a -> Ordering

-- | Run a computation with a given ordering
withOrd :: (a -> a -> Ordering) -> (forall s. Reifies s (OrdDict a) => O s b) -> b

-- | Lifts a container f whose values (of type a) depend on <tt>s</tt> into
--   a more general computation in that produces a 'f a' (depending on s).
--   
--   running time: &lt;math&gt;
extractOrd1 :: f (O s a) -> O s (f a)

-- | Introduce dynamic order in a container <tt>f</tt>.
--   
--   running time: &lt;math&gt;
introOrd1 :: f a -> f (O s a)

-- | Lifts a function that works on a container <tt>f</tt> of
--   orderable-things into one that works on dynamically ordered ones.
liftOrd1 :: (f (O s a) -> f (O s a)) -> f a -> O s (f a)

-- | Lifts a container f whose keys (of type k) depend on <tt>s</tt> into a
--   more general computation in that produces a 'f k v' (depending on s).
--   
--   running time: &lt;math&gt;
extractOrd2 :: f (O s k) v -> O s (f k v)

-- | Introduce dynamic order in a container <tt>f</tt> that has keys of
--   type k.
--   
--   running time: &lt;math&gt;
introOrd2 :: f k v -> f (O s k) v
instance GHC.Show.Show a => GHC.Show.Show (Data.DynamicOrd.O s a)
instance Data.Reflection.Reifies s (Data.DynamicOrd.OrdDict a) => GHC.Classes.Eq (Data.DynamicOrd.O s a)
instance (GHC.Classes.Eq (Data.DynamicOrd.O s a), Data.Reflection.Reifies s (Data.DynamicOrd.OrdDict a)) => GHC.Classes.Ord (Data.DynamicOrd.O s a)


-- | A pair-like data type to represent a <a>core</a> type that has extra
--   information as well.
module Data.Ext

-- | Our Ext type that represents the core datatype core extended with
--   extra information of type <a>extra</a>.
data core :+ extra
(:+) :: core -> extra -> (:+) core extra
infixr 1 :+
infixr 1 :+

-- | Access the core of an extended value.
_core :: (core :+ extra) -> core

-- | Access the extra part of an extended value.
_extra :: (core :+ extra) -> extra

-- | Lens access to the core of an extended value.
core :: Lens (core :+ extra) (core' :+ extra) core core'

-- | Lens access to the extra part of an extended value.
extra :: Lens (core :+ extra) (core :+ extra') extra extra'

-- | Tag a value with the unit type.
ext :: a -> a :+ ()
instance (Control.DeepSeq.NFData core, Control.DeepSeq.NFData extra) => Control.DeepSeq.NFData (core Data.Ext.:+ extra)
instance GHC.Generics.Generic (core Data.Ext.:+ extra)
instance (GHC.Enum.Bounded core, GHC.Enum.Bounded extra) => GHC.Enum.Bounded (core Data.Ext.:+ extra)
instance (GHC.Classes.Ord core, GHC.Classes.Ord extra) => GHC.Classes.Ord (core Data.Ext.:+ extra)
instance (GHC.Classes.Eq core, GHC.Classes.Eq extra) => GHC.Classes.Eq (core Data.Ext.:+ extra)
instance (GHC.Read.Read core, GHC.Read.Read extra) => GHC.Read.Read (core Data.Ext.:+ extra)
instance (GHC.Show.Show core, GHC.Show.Show extra) => GHC.Show.Show (core Data.Ext.:+ extra)
instance Data.Bifunctor.Bifunctor (Data.Ext.:+)
instance Data.Functor.Bind.Class.Biapply (Data.Ext.:+)
instance Data.Biapplicative.Biapplicative (Data.Ext.:+)
instance Data.Bifoldable.Bifoldable (Data.Ext.:+)
instance Data.Bitraversable.Bitraversable (Data.Ext.:+)
instance Data.Semigroup.Foldable.Class.Bifoldable1 (Data.Ext.:+)
instance Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Ext.:+)
instance (GHC.Base.Semigroup core, GHC.Base.Semigroup extra) => GHC.Base.Semigroup (core Data.Ext.:+ extra)
instance (Data.Aeson.Types.ToJSON.ToJSON core, Data.Aeson.Types.ToJSON.ToJSON extra) => Data.Aeson.Types.ToJSON.ToJSON (core Data.Ext.:+ extra)
instance (Data.Aeson.Types.FromJSON.FromJSON core, Data.Aeson.Types.FromJSON.FromJSON extra) => Data.Aeson.Types.FromJSON.FromJSON (core Data.Ext.:+ extra)
instance (Test.QuickCheck.Arbitrary.Arbitrary c, Test.QuickCheck.Arbitrary.Arbitrary e) => Test.QuickCheck.Arbitrary.Arbitrary (c Data.Ext.:+ e)


module Data.CircularSeq

-- | Nonempty circular sequence
data CSeq a

-- | smart constructor that automatically balances the seq
cseq :: Seq a -> a -> Seq a -> CSeq a

-- | <i>O(1)</i> CSeq with exactly one element.
singleton :: a -> CSeq a

-- | builds a CSeq
fromNonEmpty :: NonEmpty a -> CSeq a

-- | <i>O(n)</i> Convert from a list to a CSeq.
--   
--   Warning: the onus is on the user to ensure that their list is not
--   empty, otherwise all bets are off!
fromList :: [a] -> CSeq a

-- | Gets the focus of the CSeq.
--   
--   running time: O(1)
focus :: CSeq a -> a

-- | Access the i^th item (w.r.t the focus; elements numbered in increasing
--   order towards the right) in the CSeq (indices modulo n).
--   
--   running time: &lt;math&gt;
--   
--   <pre>
--   &gt;&gt;&gt; index (fromList [0..5]) 1
--   1
--   
--   &gt;&gt;&gt; index (fromList [0..5]) 2
--   2
--   
--   &gt;&gt;&gt; index (fromList [0..5]) 5
--   5
--   
--   &gt;&gt;&gt; index (fromList [0..5]) 10
--   4
--   
--   &gt;&gt;&gt; index (fromList [0..5]) 6
--   0
--   
--   &gt;&gt;&gt; index (fromList [0..5]) (-1)
--   5
--   
--   &gt;&gt;&gt; index (fromList [0..5]) (-6)
--   0
--   </pre>
index :: CSeq a -> Int -> a

-- | Adjusts the i^th element w.r.t the focus in the CSeq
--   
--   running time: &lt;math&gt;
--   
--   <pre>
--   &gt;&gt;&gt; adjust (const 1000) 2 (fromList [0..5])
--   CSeq [0,1,1000,3,4,5]
--   </pre>
adjust :: (a -> a) -> Int -> CSeq a -> CSeq a

-- | Access the ith item in the CSeq (w.r.t the focus) as a lens
item :: Int -> Lens' (CSeq a) a

-- | rotates the focus to the left
--   
--   running time: O(1) (amortized)
--   
--   <pre>
--   &gt;&gt;&gt; rotateL $ fromList [3,4,5,1,2]
--   CSeq [2,3,4,5,1]
--   
--   &gt;&gt;&gt; mapM_ print . take 5 $ iterate rotateL $ fromList [1..5]
--   CSeq [1,2,3,4,5]
--   CSeq [5,1,2,3,4]
--   CSeq [4,5,1,2,3]
--   CSeq [3,4,5,1,2]
--   CSeq [2,3,4,5,1]
--   </pre>
rotateL :: CSeq a -> CSeq a

-- | rotates one to the right
--   
--   running time: O(1) (amortized)
--   
--   <pre>
--   &gt;&gt;&gt; rotateR $ fromList [3,4,5,1,2]
--   CSeq [4,5,1,2,3]
--   </pre>
rotateR :: CSeq a -> CSeq a

-- | Rotates i elements to the left.
--   
--   pre: 0 &lt;= i &lt; n
--   
--   running time: &lt;math&gt; amoritzed
--   
--   <pre>
--   &gt;&gt;&gt; rotateNL 0 $ fromList [1..5]
--   CSeq [1,2,3,4,5]
--   
--   &gt;&gt;&gt; rotateNL 1 $ fromList [1..5]
--   CSeq [5,1,2,3,4]
--   
--   &gt;&gt;&gt; rotateNL 2 $ fromList [1..5]
--   CSeq [4,5,1,2,3]
--   
--   &gt;&gt;&gt; rotateNL 3 $ fromList [1..5]
--   CSeq [3,4,5,1,2]
--   
--   &gt;&gt;&gt; rotateNL 4 $ fromList [1..5]
--   CSeq [2,3,4,5,1]
--   </pre>
rotateNL :: Int -> CSeq a -> CSeq a

-- | Rotates i elements to the right.
--   
--   pre: 0 &lt;= i &lt; n
--   
--   running time: &lt;math&gt; amortized
--   
--   <pre>
--   &gt;&gt;&gt; rotateNR 0 $ fromList [1..5]
--   CSeq [1,2,3,4,5]
--   
--   &gt;&gt;&gt; rotateNR 1 $ fromList [1..5]
--   CSeq [2,3,4,5,1]
--   
--   &gt;&gt;&gt; rotateNR 4 $ fromList [1..5]
--   CSeq [5,1,2,3,4]
--   </pre>
rotateNR :: Int -> CSeq a -> CSeq a

-- | All elements, starting with the focus, going to the right
rightElements :: CSeq a -> Seq a

-- | All elements, starting with the focus, going to the left
--   
--   <pre>
--   &gt;&gt;&gt; leftElements $ fromList [3,4,5,1,2]
--   fromList [3,2,1,5,4]
--   </pre>
leftElements :: CSeq a -> Seq a

-- | Convert to a single Seq, starting with the focus.
asSeq :: CSeq a -> Seq a

-- | Label the elements with indices.
--   
--   <pre>
--   &gt;&gt;&gt; withIndices $ fromList [0..5]
--   CSeq [0 :+ 0,1 :+ 1,2 :+ 2,3 :+ 3,4 :+ 4,5 :+ 5]
--   </pre>
withIndices :: CSeq a -> CSeq (Int :+ a)

-- | Reverses the direction of the CSeq
--   
--   running time: &lt;math&gt;
--   
--   <pre>
--   &gt;&gt;&gt; reverseDirection $ fromList [1..5]
--   CSeq [1,5,4,3,2]
--   </pre>
reverseDirection :: CSeq a -> CSeq a

-- | All rotations, the input CSeq is the focus.
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ print . allRotations $ fromList [1..5]
--   CSeq [1,2,3,4,5]
--   CSeq [2,3,4,5,1]
--   CSeq [3,4,5,1,2]
--   CSeq [4,5,1,2,3]
--   CSeq [5,1,2,3,4]
--   </pre>
allRotations :: CSeq a -> CSeq (CSeq a)

-- | Finds an element in the CSeq
--   
--   <pre>
--   &gt;&gt;&gt; findRotateTo (== 3) $ fromList [1..5]
--   Just (CSeq [3,4,5,1,2])
--   
--   &gt;&gt;&gt; findRotateTo (== 7) $ fromList [1..5]
--   Nothing
--   </pre>
findRotateTo :: (a -> Bool) -> CSeq a -> Maybe (CSeq a)

-- | Rotate to a specific element in the CSeq.
rotateTo :: Eq a => a -> CSeq a -> Maybe (CSeq a)

-- | "Left zip": zip the two CLists, pairing up every element in the *left*
--   list with its corresponding element in the right list. If there are
--   more items in the right clist they are discarded.
zipLWith :: (a -> b -> c) -> CSeq a -> CSeq b -> CSeq c

-- | see 'zipLWith
zipL :: CSeq a -> CSeq b -> CSeq (a, b)

-- | same as zipLWith but with three items
zip3LWith :: (a -> b -> c -> d) -> CSeq a -> CSeq b -> CSeq c -> CSeq d

-- | Given a circular seq, whose elements are in increasing order, insert
--   the new element into the Circular seq in its sorted order.
--   
--   <pre>
--   &gt;&gt;&gt; insertOrd 1 $ fromList [2]
--   CSeq [2,1]
--   
--   &gt;&gt;&gt; insertOrd 2 $ fromList [1,3]
--   CSeq [1,2,3]
--   
--   &gt;&gt;&gt; insertOrd 31 ordList
--   CSeq [5,6,10,20,30,31,1,2,3]
--   
--   &gt;&gt;&gt; insertOrd 1 ordList
--   CSeq [5,6,10,20,30,1,1,2,3]
--   
--   &gt;&gt;&gt; insertOrd 4 ordList
--   CSeq [5,6,10,20,30,1,2,3,4]
--   
--   &gt;&gt;&gt; insertOrd 11 ordList
--   CSeq [5,6,10,11,20,30,1,2,3]
--   </pre>
--   
--   running time: &lt;math&gt;
insertOrd :: Ord a => a -> CSeq a -> CSeq a

-- | Insert an element into an increasingly ordered circular list, with
--   specified compare operator.
--   
--   running time: &lt;math&gt;
insertOrdBy :: (a -> a -> Ordering) -> a -> CSeq a -> CSeq a

-- | Test if the circular list is a cyclic shift of the second list. We
--   have that
--   
--   <pre>
--   (xs `isShiftOf` ys) == (xs `elem` allRotations (ys :: CSeq Int))
--   </pre>
--   
--   Running time: &lt;math&gt;, where &lt;math&gt; and &lt;math&gt; are
--   the sizes of the lists.
isShiftOf :: Eq a => CSeq a -> CSeq a -> Bool
instance GHC.Generics.Generic (Data.CircularSeq.CSeq a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.CircularSeq.CSeq a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.CircularSeq.CSeq a)
instance GHC.Show.Show a => GHC.Show.Show (Data.CircularSeq.CSeq a)
instance GHC.Read.Read a => GHC.Read.Read (Data.CircularSeq.CSeq a)
instance Data.Traversable.Traversable Data.CircularSeq.CSeq
instance Data.Semigroup.Foldable.Class.Foldable1 Data.CircularSeq.CSeq
instance Data.Foldable.Foldable Data.CircularSeq.CSeq
instance GHC.Base.Functor Data.CircularSeq.CSeq
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.CircularSeq.CSeq a)


-- | Defines a data type for representing intersections. Mostly useful for
--   the more geometric types.
module Data.Intersection

-- | A simple data type expressing that there are no intersections
data NoIntersection
NoIntersection :: NoIntersection

-- | The result of interesecting two geometries is a CoRec,
type Intersection g h = CoRec Identity (IntersectionOf g h)

-- | The type family specifying the list of possible result types of an
--   intersection.
type family IntersectionOf g h :: [*]

-- | Helper to produce a corec
coRec :: a ∈ as => a -> CoRec Identity as
class IsIntersectableWith g h
intersect :: IsIntersectableWith g h => g -> h -> Intersection g h

-- | g <a>intersects</a> h <a>=</a> The intersection of g and h is
--   non-empty.
--   
--   The default implementation computes the intersection of g and h, and
--   uses nonEmptyIntersection to determine if the intersection is
--   non-empty.
intersects :: IsIntersectableWith g h => g -> h -> Bool

-- | Helper to implement <a>intersects</a>.
nonEmptyIntersection :: IsIntersectableWith g h => proxy g -> proxy h -> Intersection g h -> Bool

-- | Helper to implement <a>intersects</a>.
nonEmptyIntersection :: (IsIntersectableWith g h, NoIntersection ∈ IntersectionOf g h, RecApplicative (IntersectionOf g h)) => proxy g -> proxy h -> Intersection g h -> Bool

-- | When using IntersectionOf we may need some constraints that are always
--   true anyway.
type AlwaysTrueIntersection g h = RecApplicative (IntersectionOf g h)

-- | Returns True iff the result is *not* a NoIntersection
defaultNonEmptyIntersection :: forall g h proxy. (NoIntersection ∈ IntersectionOf g h, RecApplicative (IntersectionOf g h)) => proxy g -> proxy h -> Intersection g h -> Bool
instance GHC.Classes.Ord Data.Intersection.NoIntersection
instance GHC.Classes.Eq Data.Intersection.NoIntersection
instance GHC.Read.Read Data.Intersection.NoIntersection
instance GHC.Show.Show Data.Intersection.NoIntersection


module Data.LSeq

-- | LSeq n a certifies that the sequence has *at least* n items
data LSeq (n :: Nat) a

-- | The empty sequence.
pattern EmptyL :: LSeq n a

-- | A bidirectional pattern synonym viewing the front of a non-empty
--   sequence.
pattern (:<|) :: a -> LSeq n a -> LSeq (1 + n) a

-- | A unidirectional pattern synonym viewing the front of a non-empty
--   sequence.
pattern (:<<) :: a -> LSeq 0 a -> LSeq n a

-- | A bidirectional pattern synonym viewing the rear of a non-empty
--   sequence.
pattern (:|>) :: forall n a. LSeq n a -> a -> LSeq (1 + n) a
infixr 5 :<|
infixr 5 :<<
infixl 5 :|>

-- | &lt;math&gt; Convert to a sequence by dropping the type-level size.
toSeq :: LSeq n a -> Seq a

-- | &lt;math&gt; The empty sequence.
empty :: LSeq 0 a

-- | &lt;math&gt;. Create an l-sequence from a finite list of elements.
fromList :: Foldable f => f a -> LSeq 0 a

-- | &lt;math&gt;. Create an l-sequence from a non-empty list.
fromNonEmpty :: NonEmpty a -> LSeq 1 a

-- | &lt;math&gt;. Create an l-sequence from a sequence of elements.
fromSeq :: Seq a -> LSeq 0 a

-- | &lt;math&gt; Add an element to the left end of a sequence. Mnemonic: a
--   triangle with the single element at the pointy end.
(<|) :: a -> LSeq n a -> LSeq (1 + n) a
infixr 5 <|

-- | &lt;math&gt; Add an element to the right end of a sequence. Mnemonic:
--   a triangle with the single element at the pointy end.
(|>) :: LSeq n a -> a -> LSeq (1 + n) a
infixl 5 |>

-- | &lt;math&gt; Concatenate two sequences.
(><) :: LSeq n a -> LSeq m a -> LSeq (n + m) a
infix 5 ><

-- | &lt;math&gt; Prove a sequence has at least <tt>n</tt> elements.
--   
--   <pre>
--   &gt;&gt;&gt; eval (Proxy :: Proxy 3) (fromList [1,2,3])
--   Just (LSeq (fromList [1,2,3]))
--   
--   &gt;&gt;&gt; eval (Proxy :: Proxy 3) (fromList [1,2])
--   Nothing
--   
--   &gt;&gt;&gt; eval (Proxy :: Proxy 3) (fromList [1..10])
--   Just (LSeq (fromList [1,2,3,4,5,6,7,8,9,10]))
--   </pre>
eval :: forall proxy n m a. KnownNat n => proxy n -> LSeq m a -> Maybe (LSeq n a)

-- | &lt;math&gt; Get the element with index i, counting from the left and
--   starting at 0.
index :: LSeq n a -> Int -> a

-- | &lt;math&gt; Update the element at the specified position. If the
--   position is out of range, the original sequence is returned. adjust
--   can lead to poor performance and even memory leaks, because it does
--   not force the new value before installing it in the sequence. adjust'
--   should usually be preferred.
adjust :: (a -> a) -> Int -> LSeq n a -> LSeq n a

-- | &lt;math&gt; The partition function takes a predicate p and a sequence
--   xs and returns sequences of those elements which do and do not satisfy
--   the predicate.
partition :: (a -> Bool) -> LSeq n a -> (LSeq 0 a, LSeq 0 a)

-- | A generalization of <a>fmap</a>, <a>mapWithIndex</a> takes a mapping
--   function that also depends on the element's index, and applies it to
--   every element in the sequence.
mapWithIndex :: (Int -> a -> b) -> LSeq n a -> LSeq n b

-- | &lt;math&gt;. The first <tt>i</tt> elements of a sequence. If
--   <tt>i</tt> is negative, <tt><a>take</a> i s</tt> yields the empty
--   sequence. If the sequence contains fewer than <tt>i</tt> elements, the
--   whole sequence is returned.
take :: Int -> LSeq n a -> LSeq 0 a

-- | &lt;math&gt;. Elements of a sequence after the first <tt>i</tt>. If
--   <tt>i</tt> is negative, <tt><a>drop</a> i s</tt> yields the whole
--   sequence. If the sequence contains fewer than <tt>i</tt> elements, the
--   empty sequence is returned.
drop :: Int -> LSeq n a -> LSeq 0 a

-- | &lt;math&gt;. <a>unstableSort</a> sorts the specified <tt>Seq</tt> by
--   the natural ordering of its elements, but the sort is not stable. This
--   algorithm is frequently faster and uses less memory than
--   <tt>sort</tt>.
unstableSort :: Ord a => LSeq n a -> LSeq n a

-- | &lt;math&gt;. A generalization of <a>unstableSort</a>,
--   <a>unstableSortBy</a> takes an arbitrary comparator and sorts the
--   specified sequence. The sort is not stable. This algorithm is
--   frequently faster and uses less memory than <tt>sortBy</tt>.
unstableSortBy :: (a -> a -> Ordering) -> LSeq n a -> LSeq n a

-- | Gets the first element of the LSeq
--   
--   <pre>
--   &gt;&gt;&gt; head $ forceLSeq (Proxy :: Proxy 3) $ fromList [1,2,3]
--   1
--   </pre>
head :: LSeq (1 + n) a -> a

-- | Get the LSeq without its first element -- &gt;&gt;&gt; head $
--   forceLSeq (Proxy :: Proxy 3) $ fromList [1,2,3] LSeq (fromList [2,3])
tail :: LSeq (1 + n) a -> LSeq n a

-- | Get the last element of the LSeq
--   
--   <pre>
--   &gt;&gt;&gt; last $ forceLSeq (Proxy :: Proxy 3) $ fromList [1,2,3]
--   3
--   </pre>
last :: LSeq (1 + n) a -> a

-- | The sequence without its last element
--   
--   <pre>
--   &gt;&gt;&gt; init $ forceLSeq (Proxy :: Proxy 3) $ fromList [1,2,3]
--   LSeq (fromList [1,2])
--   </pre>
init :: LSeq (1 + n) a -> LSeq n a

-- | appends two sequences.
append :: LSeq n a -> LSeq m a -> LSeq (n + m) a

-- | View of the left end of a sequence.
data ViewL n a
[:<] :: a -> LSeq n a -> ViewL (1 + n) a
infixr 5 :<

-- | ( O(1) ). Analyse the left end of a sequence.
viewl :: LSeq (1 + n) a -> ViewL (1 + n) a

-- | View of the right end of a sequence.
data ViewR n a
[:>] :: LSeq n a -> a -> ViewR (1 + n) a
infixl 5 :>

-- | &lt;math&gt;. Analyse the right end of a sequence.
viewr :: LSeq (1 + n) a -> ViewR (1 + n) a

-- | Zips two equal length LSeqs
zipWith :: (a -> b -> c) -> LSeq n a -> LSeq n b -> LSeq n c

-- | Promises that the length of this LSeq is actually n. This is not
--   checked.
--   
--   This function should be a noop
promise :: forall m n a. LSeq m a -> LSeq n a

-- | Forces the first n elements of the LSeq
forceLSeq :: KnownNat n => proxy n -> LSeq m a -> LSeq n a
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.LSeq.LSeq n a)
instance GHC.Generics.Generic (Data.LSeq.LSeq n a)
instance Data.Traversable.Traversable (Data.LSeq.LSeq n)
instance GHC.Base.Functor (Data.LSeq.LSeq n)
instance Data.Foldable.Foldable (Data.LSeq.LSeq n)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.LSeq.LSeq n a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.LSeq.LSeq n a)
instance GHC.Read.Read a => GHC.Read.Read (Data.LSeq.LSeq n a)
instance GHC.Show.Show a => GHC.Show.Show (Data.LSeq.LSeq n a)
instance GHC.Show.Show a => GHC.Show.Show (Data.LSeq.ViewL n a)
instance GHC.Show.Show a => GHC.Show.Show (Data.LSeq.ViewR n a)
instance GHC.Base.Semigroup (Data.LSeq.ViewR n a)
instance GHC.Base.Functor (Data.LSeq.ViewR n)
instance Data.Foldable.Foldable (Data.LSeq.ViewR n)
instance Data.Traversable.Traversable (Data.LSeq.ViewR n)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.LSeq.ViewR n a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.LSeq.ViewR n a)
instance GHC.Base.Semigroup (Data.LSeq.ViewL n a)
instance GHC.Base.Functor (Data.LSeq.ViewL n)
instance Data.Foldable.Foldable (Data.LSeq.ViewL n)
instance Data.Traversable.Traversable (Data.LSeq.ViewL n)
instance (1 GHC.TypeNats.<= n) => Data.Semigroup.Foldable.Class.Foldable1 (Data.LSeq.ViewL n)
instance (1 GHC.TypeNats.<= n) => Data.Semigroup.Traversable.Class.Traversable1 (Data.LSeq.ViewL n)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.LSeq.ViewL n a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.LSeq.ViewL n a)
instance GHC.Base.Semigroup (Data.LSeq.LSeq n a)
instance GHC.Base.Monoid (Data.LSeq.LSeq 0 a)
instance (GHC.TypeNats.KnownNat n, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Data.LSeq.LSeq n a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Data.LSeq.LSeq n a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Data.LSeq.LSeq n a)
instance Control.Lens.At.Ixed (Data.LSeq.LSeq n a)
instance (1 GHC.TypeNats.<= n) => Data.Semigroup.Foldable.Class.Foldable1 (Data.LSeq.LSeq n)


module Data.List.Alternating

-- | A (non-empty) alternating list of a's and b's
data Alternating a b
Alternating :: a -> [b :+ a] -> Alternating a b

-- | Computes a b with all its neighbours
--   
--   <pre>
--   &gt;&gt;&gt; withNeighbours (Alternating 0 ['a' :+ 1, 'b' :+ 2, 'c' :+ 3])
--   [(0,'a' :+ 1),(1,'b' :+ 2),(2,'c' :+ 3)]
--   </pre>
withNeighbours :: Alternating a b -> [(a, b :+ a)]

-- | Generic merging scheme that merges two Alternatings and applies the
--   function <tt>f</tt>, with the current/new value at every event. So
--   note that if the alternating consists of 'Alternating a0 [t1 :+ a1]'
--   then the function is applied to a1, not to a0 (i.e. every value ai is
--   considered alive on the interval [ti,t(i+1))
--   
--   <pre>
--   &gt;&gt;&gt; let odds  = Alternating "a" [3 :+ "c", 5 :+ "e", 7 :+ "g"]
--   
--   &gt;&gt;&gt; let evens = Alternating "b" [4 :+ "d", 6 :+ "f", 8 :+ "h"]
--   
--   &gt;&gt;&gt; mergeAlternating (\_ a b -&gt; a &lt;&gt; b) odds evens
--   [3 :+ "cb",4 :+ "cd",5 :+ "ed",6 :+ "ef",7 :+ "gf",8 :+ "gh"]
--   
--   &gt;&gt;&gt; mergeAlternating (\t a b -&gt; if t `mod` 2 == 0 then a else b) odds evens
--   [3 :+ "b",4 :+ "c",5 :+ "d",6 :+ "e",7 :+ "f",8 :+ "g"]
--   
--   &gt;&gt;&gt; mergeAlternating (\_ a b -&gt; a &lt;&gt; b) odds (Alternating "b" [0 :+ "d", 5 :+ "e", 8 :+ "h"])
--   [0 :+ "ad",3 :+ "cd",5 :+ "ee",7 :+ "ge",8 :+ "gh"]
--   </pre>
mergeAlternating :: Ord t => (t -> a -> b -> c) -> Alternating a t -> Alternating b t -> [t :+ c]

-- | Adds additional t-values in the alternating, (in sorted order). I.e.
--   if we insert a "breakpoint" at time t the current <tt>a</tt> value is
--   used at that time.
--   
--   <pre>
--   &gt;&gt;&gt; insertBreakPoints [0,2,4,6,8,10] $ Alternating "a" [3 :+ "c", 5 :+ "e", 7 :+ "g"]
--   Alternating "a" [0 :+ "a",2 :+ "a",3 :+ "c",4 :+ "c",5 :+ "e",6 :+ "e",7 :+ "g",8 :+ "g",10 :+ "g"]
--   </pre>
insertBreakPoints :: Ord t => [t] -> Alternating a t -> Alternating a t

-- | Reverses an alternating list.
--   
--   <pre>
--   &gt;&gt;&gt; reverse $ Alternating "a" [3 :+ "c", 5 :+ "e", 7 :+ "g"]
--   Alternating "g" [7 :+ "e",5 :+ "c",3 :+ "a"]
--   </pre>
reverse :: Alternating a b -> Alternating a b
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (Data.List.Alternating.Alternating a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Data.List.Alternating.Alternating a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.List.Alternating.Alternating a b)
instance Data.Bifunctor.Bifunctor Data.List.Alternating.Alternating
instance Data.Bifoldable.Bifoldable Data.List.Alternating.Alternating
instance Data.Bitraversable.Bitraversable Data.List.Alternating.Alternating


module Data.List.Set

-- | A Set of <tt>a</tt>s, implemented using a simple list. The only
--   advantage of this implementation over <a>Set</a> from containers is
--   that most operations require only 'Eq a' rather than 'Ord a'.
data Set a

-- | Creates a singleton set.
singleton :: a -> Set a

-- | &lt;math&gt; Inserts an element in the set
insert :: Eq a => a -> Set a -> Set a

-- | &lt;math&gt; Deletes an element from the set
delete :: Eq a => a -> Set a -> Set a

-- | &lt;math&gt; Computes the union of two sets
union :: Eq a => Set a -> Set a -> Set a

-- | &lt;math&gt; Computes the intersection of two sets
intersection :: Eq a => Set a -> Set a -> Set a

-- | &lt;math&gt; Computes the difference of two sets
difference :: Eq a => Set a -> Set a -> Set a

-- | &lt;math&gt; Create a set from a finite list of elements.
fromList :: Eq a => [a] -> Set a

-- | &lt;math&gt; Insert an element in a set.
insertAll :: Eq a => [a] -> Set a -> Set a
instance Data.Traversable.Traversable Data.List.Set.Set
instance Data.Foldable.Foldable Data.List.Set.Set
instance GHC.Base.Functor Data.List.Set.Set
instance GHC.Read.Read a => GHC.Read.Read (Data.List.Set.Set a)
instance GHC.Show.Show a => GHC.Show.Show (Data.List.Set.Set a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.List.Set.Set a)
instance GHC.Classes.Eq a => GHC.Base.Semigroup (Data.List.Set.Set a)
instance GHC.Classes.Eq a => GHC.Base.Monoid (Data.List.Set.Set a)


module Data.List.Zipper

-- | Simple Zipper for Lists.
data Zipper a
Zipper :: [a] -> [a] -> Zipper a

-- | Construct a Zipper from a list
--   
--   running time: &lt;math&gt;
fromList :: [a] -> Zipper a

-- | Go to the Next Element
--   
--   running time: &lt;math&gt;
goNext :: Zipper a -> Maybe (Zipper a)

-- | Go to the previous Element
--   
--   running time: &lt;math&gt;
goPrev :: Zipper a -> Maybe (Zipper a)

-- | Computes all nexts, even one that has no elements initially or at the
--   end.
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ print $ allNexts $ fromList [1..5]
--   Zipper [] [1,2,3,4,5]
--   Zipper [1] [2,3,4,5]
--   Zipper [2,1] [3,4,5]
--   Zipper [3,2,1] [4,5]
--   Zipper [4,3,2,1] [5]
--   Zipper [5,4,3,2,1] []
--   </pre>
allNexts :: Zipper a -> [Zipper a]

-- | Returns the next element, and the zipper without it
extractNext :: Zipper a -> Maybe (a, Zipper a)

-- | Drops the next element in the zipper.
--   
--   running time: &lt;math&gt;
dropNext :: Zipper a -> Maybe (Zipper a)

-- | Computes all list that still have next elements.
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ print $ allNonEmptyNexts $ fromList [1..5]
--   Zipper [] [1,2,3,4,5]
--   Zipper [1] [2,3,4,5]
--   Zipper [2,1] [3,4,5]
--   Zipper [3,2,1] [4,5]
--   Zipper [4,3,2,1] [5]
--   </pre>
allNonEmptyNexts :: Zipper a -> [Zipper a]
instance GHC.Base.Functor Data.List.Zipper.Zipper
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.List.Zipper.Zipper a)
instance GHC.Show.Show a => GHC.Show.Show (Data.List.Zipper.Zipper a)
instance Data.Foldable.Foldable Data.List.Zipper.Zipper


module Data.List.Util

-- | Given an input list, computes all lists in which just one element is
--   missing.
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ print $ leaveOutOne [1..5]
--   (1,[2,3,4,5])
--   (2,[1,3,4,5])
--   (3,[1,2,4,5])
--   (4,[1,2,3,5])
--   (5,[1,2,3,4])
--   
--   &gt;&gt;&gt; leaveOutOne []
--   []
--   
--   &gt;&gt;&gt; leaveOutOne [1]
--   [(1,[])]
--   </pre>
leaveOutOne :: [a] -> [(a, [a])]

-- | Safe variant of Prelude.minimum.
--   
--   <pre>
--   &gt;&gt;&gt; minimum1 [] :: Maybe ()
--   Nothing
--   
--   &gt;&gt;&gt; minimum1 [1,2,3]
--   Just 1
--   </pre>
minimum1 :: Ord a => [a] -> Maybe a

-- | Safe variant of Prelude.maximum.
--   
--   <pre>
--   &gt;&gt;&gt; maximum1 [] :: Maybe ()
--   Nothing
--   
--   &gt;&gt;&gt; maximum1 [1,2,3]
--   Just 3
--   </pre>
maximum1 :: Ord a => [a] -> Maybe a

-- | Total variant of Data.List.minimumBy.
--   
--   <pre>
--   &gt;&gt;&gt; minimum1By (comparing abs) [] :: Maybe Int
--   Nothing
--   
--   &gt;&gt;&gt; minimum1By (comparing abs) [1,-2,3]
--   Just 1
--   </pre>
minimum1By :: (a -> a -> Ordering) -> [a] -> Maybe a

-- | Computes all minima by comparing some property.
--   
--   <pre>
--   &gt;&gt;&gt; minimaOn (max 2) [1,2,3,4,5,-1]
--   [-1,2,1]
--   </pre>
minimaOn :: Ord b => (a -> b) -> [a] -> [a]

-- | Computes all minima.
--   
--   <pre>
--   &gt;&gt;&gt; minimaBy (comparing abs) [1,2,3,2,1,-1]
--   [-1,1,1]
--   </pre>
minimaBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | extracts all minima from the list. The result consists of the list of
--   minima, and all remaining points. Both lists are returned in the order
--   in which they occur in the input.
--   
--   <pre>
--   &gt;&gt;&gt; extractMinimaBy compare [1,2,3,0,1,2,3,0,1,2,0,2]
--   [0,0,0] :+ [2,3,1,2,3,1,2,1,2]
--   </pre>
extractMinimaBy :: (a -> a -> Ordering) -> [a] -> [a] :+ [a]


module Data.Measured.Class

-- | Things that can be measured.
class Semigroup v => Measured v a | a -> v
measure :: Measured v a => a -> v

-- | Things that can be inserted.
class Measured v a => CanInsert v a
insertA :: CanInsert v a => a -> v -> v

-- | Things that can be deleted.
class Measured v a => CanDelete v a
deleteA :: CanDelete v a => a -> v -> Maybe v


module Data.Measured


module Data.Measured.Size

-- | Measured size. Always non-negative.
newtype Size
Size :: Word -> Size

-- | Newtype wrapper for things for which we can measure the size
newtype Elem a
Elem :: a -> Elem a
[_unElem] :: Elem a -> a

-- | Things that have a size
data Sized a
Sized :: {-# UNPACK #-} !Size -> a -> Sized a
instance GHC.Generics.Generic (Data.Measured.Size.Sized a)
instance Data.Traversable.Traversable Data.Measured.Size.Sized
instance Data.Foldable.Foldable Data.Measured.Size.Sized
instance GHC.Base.Functor Data.Measured.Size.Sized
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Measured.Size.Sized a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Measured.Size.Sized a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Measured.Size.Sized a)
instance Data.Traversable.Traversable Data.Measured.Size.Elem
instance Data.Foldable.Foldable Data.Measured.Size.Elem
instance GHC.Base.Functor Data.Measured.Size.Elem
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Measured.Size.Elem a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Measured.Size.Elem a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Measured.Size.Elem a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Measured.Size.Elem a)
instance Control.DeepSeq.NFData Data.Measured.Size.Size
instance GHC.Generics.Generic Data.Measured.Size.Size
instance GHC.Classes.Ord Data.Measured.Size.Size
instance GHC.Real.Real Data.Measured.Size.Size
instance GHC.Enum.Enum Data.Measured.Size.Size
instance GHC.Real.Integral Data.Measured.Size.Size
instance GHC.Num.Num Data.Measured.Size.Size
instance GHC.Classes.Eq Data.Measured.Size.Size
instance GHC.Read.Read Data.Measured.Size.Size
instance GHC.Show.Show Data.Measured.Size.Size
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Measured.Size.Sized a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Measured.Size.Sized a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Measured.Size.Sized a)
instance Data.Measured.Class.Measured Data.Measured.Size.Size (Data.Measured.Size.Elem a)
instance GHC.Base.Semigroup Data.Measured.Size.Size
instance GHC.Base.Monoid Data.Measured.Size.Size


module Data.OrdSeq

-- | Sequence of ordered elements.
data OrdSeq a

-- | Signature for functions that give the ordering of two values.
type Compare a = a -> a -> Ordering

-- | Insert into a monotone OrdSeq.
--   
--   pre: the comparator maintains monotonicity
--   
--   &lt;math&gt;
insertBy :: Compare a -> a -> OrdSeq a -> OrdSeq a

-- | Insert into a sorted OrdSeq
--   
--   &lt;math&gt;
insert :: Ord a => a -> OrdSeq a -> OrdSeq a

-- | &lt;math&gt;
splitBy :: Compare a -> a -> OrdSeq a -> (OrdSeq a, OrdSeq a, OrdSeq a)

-- | Given a monotonic function f that maps a to b, split the sequence s
--   depending on the b values. I.e. the result (l,m,r) is such that
--   
--   <ul>
--   <li><pre>all (&lt; x) . fmap f $ l</pre></li>
--   <li><pre>all (== x) . fmap f $ m</pre></li>
--   <li><pre>all (&gt; x) . fmap f $ r</pre></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; splitOn id 3 $ fromAscList [1..5]
--   (fromAscList [1,2],fromAscList [3],fromAscList [4,5])
--   
--   &gt;&gt;&gt; splitOn fst 2 $ fromAscList [(0,"-"),(1,"A"),(2,"B"),(2,"C"),(3,"D"),(4,"E")]
--   (fromAscList [(0,"-"),(1,"A")],fromAscList [(2,"B"),(2,"C")],fromAscList [(3,"D"),(4,"E")])
--   </pre>
splitOn :: Ord b => (a -> b) -> b -> OrdSeq a -> (OrdSeq a, OrdSeq a, OrdSeq a)

-- | Given a monotonic predicate p, splits the sequence s into two
--   sequences (as,bs) such that all (not p) as and all p bs
--   
--   &lt;math&gt;
splitMonotonic :: (a -> Bool) -> OrdSeq a -> (OrdSeq a, OrdSeq a)

-- | Deletes all elements from the OrdDeq
--   
--   &lt;math&gt;
deleteAll :: Ord a => a -> OrdSeq a -> OrdSeq a

-- | &lt;math&gt;. Delete all elements that compare as equal to <tt>x</tt>.
deleteAllBy :: Compare a -> a -> OrdSeq a -> OrdSeq a

-- | inserts all eleements in order &lt;math&gt;
fromListBy :: Compare a -> [a] -> OrdSeq a

-- | inserts all eleements in order &lt;math&gt;
fromListByOrd :: Ord a => [a] -> OrdSeq a

-- | &lt;math&gt;
fromAscList :: [a] -> OrdSeq a

-- | &lt;math&gt;
lookupBy :: Compare a -> a -> OrdSeq a -> Maybe a

-- | &lt;math&gt;. Queries for the existance of any elements that compare
--   as equal to <tt>x</tt>.
memberBy :: Compare a -> a -> OrdSeq a -> Bool

-- | &lt;math&gt; Fmap, assumes the order does not change
mapMonotonic :: (a -> b) -> OrdSeq a -> OrdSeq b

-- | &lt;math&gt; Gets the first element from the sequence
viewl :: OrdSeq a -> ViewL OrdSeq a

-- | &lt;math&gt; Gets the last element from the sequence
viewr :: OrdSeq a -> ViewR OrdSeq a

-- | &lt;math&gt;
minView :: OrdSeq a -> Maybe (a, OrdSeq a)

-- | &lt;math&gt;
lookupMin :: OrdSeq a -> Maybe a

-- | &lt;math&gt;
maxView :: OrdSeq a -> Maybe (a, OrdSeq a)

-- | &lt;math&gt;
lookupMax :: OrdSeq a -> Maybe a
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.OrdSeq.OrdSeq a)
instance GHC.Base.Functor Data.OrdSeq.Elem
instance Data.Foldable.Foldable Data.OrdSeq.Elem
instance Data.Traversable.Traversable Data.OrdSeq.Elem
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.OrdSeq.Elem a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.OrdSeq.Elem a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.OrdSeq.Key a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.OrdSeq.Key a)
instance GHC.Show.Show a => GHC.Show.Show (Data.OrdSeq.Key a)
instance GHC.Show.Show a => GHC.Show.Show (Data.OrdSeq.OrdSeq a)
instance GHC.Base.Semigroup (Data.OrdSeq.OrdSeq a)
instance GHC.Base.Monoid (Data.OrdSeq.OrdSeq a)
instance Data.Foldable.Foldable Data.OrdSeq.OrdSeq
instance (Test.QuickCheck.Arbitrary.Arbitrary a, GHC.Classes.Ord a) => Test.QuickCheck.Arbitrary.Arbitrary (Data.OrdSeq.OrdSeq a)
instance GHC.Show.Show a => GHC.Show.Show (Data.OrdSeq.Elem a)
instance Data.FingerTree.Measured (Data.OrdSeq.Key a) (Data.OrdSeq.Elem a)
instance GHC.Base.Semigroup (Data.OrdSeq.Key a)
instance GHC.Base.Monoid (Data.OrdSeq.Key a)


-- | Data type for representing a Permutation
module Data.Permutation

-- | Orbits (Cycles) are represented by vectors
type Orbit a = Vector a

-- | Cyclic representation of a permutation.
data Permutation a
Permutation :: Vector (Orbit a) -> Vector (Int, Int) -> Permutation a
[_orbits] :: Permutation a -> Vector (Orbit a)

-- | idxes (fromEnum a) = (i,j) implies that a is the j^th item in the i^th
--   orbit
[_indexes] :: Permutation a -> Vector (Int, Int)
orbits :: forall a_aHzV a_aHSK. Lens (Permutation a_aHzV) (Permutation a_aHSK) (Vector (Orbit a_aHzV)) (Vector (Orbit a_aHSK))
indexes :: forall a_aHzV. Lens' (Permutation a_aHzV) (Vector (Int, Int))
elems :: Permutation a -> Vector a
size :: Permutation a -> Int

-- | The cycle containing a given item
cycleOf :: Enum a => Permutation a -> a -> Orbit a

-- | Next item in a cyclic permutation
next :: Vector v a => v a -> Int -> a

-- | Previous item in a cyclic permutation
previous :: Vector v a => v a -> Int -> a

-- | Lookup the indices of an element, i.e. in which orbit the item is, and
--   the index within the orbit.
--   
--   runnign time: &lt;math&gt;
lookupIdx :: Enum a => Permutation a -> a -> (Int, Int)

-- | Apply the permutation, i.e. consider the permutation as a function.
apply :: Enum a => Permutation a -> a -> a

-- | Find the cycle in the permutation starting at element s
orbitFrom :: Eq a => a -> (a -> a) -> [a]

-- | Given a vector with items in the permutation, and a permutation (by
--   its functional representation) construct the cyclic representation of
--   the permutation.
cycleRep :: (Vector v a, Enum a, Eq a) => v a -> (a -> a) -> Permutation a

-- | Given the size n, and a list of Cycles, turns the cycles into a cyclic
--   representation of the Permutation.
toCycleRep :: Enum a => Int -> [[a]] -> Permutation a
genIndexes :: Enum a => Int -> [[a]] -> Vector (Int, Int)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Permutation.Permutation a)
instance GHC.Base.Functor Data.Permutation.Permutation
instance Data.Foldable.Foldable Data.Permutation.Permutation
instance Data.Traversable.Traversable Data.Permutation.Permutation
instance GHC.Generics.Generic (Data.Permutation.Permutation a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Permutation.Permutation a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Permutation.Permutation a)


-- | Data types that to represent a planar graph as Adjacency Lists. The
--   main purpose is to help encode<i>decode a PlanarGraph as a
--   JSON</i>YAML file.
module Data.PlanarGraph.AdjRep

-- | Data type representing the graph in its JSON/Yaml format
data Gr v f
Gr :: [v] -> [f] -> Gr v f
[adjacencies] :: Gr v f -> [v]
[faces] :: Gr v f -> [f]

-- | A vertex, represented by an id, its adjacencies, and its data.
data Vtx v e
Vtx :: Int -> [(Int, e)] -> v -> Vtx v e
[id] :: Vtx v e -> Int

-- | adjacent vertices + data on the edge. Some functions, like
--   <tt>fromAdjRep</tt> may assume that the adjacencies are given in
--   counterclockwise order around the vertices. This is not (yet) enforced
--   by the data type.
[adj] :: Vtx v e -> [(Int, e)]
[vData] :: Vtx v e -> v

-- | Faces
data Face f
Face :: (Int, Int) -> f -> Face f

-- | an edge (u,v) s.t. the face is right from (u,v)
[incidentEdge] :: Face f -> (Int, Int)
[fData] :: Face f -> f
instance GHC.Base.Functor Data.PlanarGraph.AdjRep.Face
instance GHC.Generics.Generic (Data.PlanarGraph.AdjRep.Face f)
instance GHC.Generics.Generic (Data.PlanarGraph.AdjRep.Vtx v e)
instance GHC.Generics.Generic (Data.PlanarGraph.AdjRep.Gr v f)
instance Data.Aeson.Types.ToJSON.ToJSON f => Data.Aeson.Types.ToJSON.ToJSON (Data.PlanarGraph.AdjRep.Face f)
instance Data.Aeson.Types.FromJSON.FromJSON f => Data.Aeson.Types.FromJSON.FromJSON (Data.PlanarGraph.AdjRep.Face f)
instance Data.Bifunctor.Bifunctor Data.PlanarGraph.AdjRep.Vtx
instance (Data.Aeson.Types.ToJSON.ToJSON v, Data.Aeson.Types.ToJSON.ToJSON e) => Data.Aeson.Types.ToJSON.ToJSON (Data.PlanarGraph.AdjRep.Vtx v e)
instance (Data.Aeson.Types.FromJSON.FromJSON v, Data.Aeson.Types.FromJSON.FromJSON e) => Data.Aeson.Types.FromJSON.FromJSON (Data.PlanarGraph.AdjRep.Vtx v e)
instance Data.Bifunctor.Bifunctor Data.PlanarGraph.AdjRep.Gr
instance (Data.Aeson.Types.ToJSON.ToJSON v, Data.Aeson.Types.ToJSON.ToJSON f) => Data.Aeson.Types.ToJSON.ToJSON (Data.PlanarGraph.AdjRep.Gr v f)
instance (Data.Aeson.Types.FromJSON.FromJSON v, Data.Aeson.Types.FromJSON.FromJSON f) => Data.Aeson.Types.FromJSON.FromJSON (Data.PlanarGraph.AdjRep.Gr v f)


-- | Data type for representing Darts (edges) in a planar graph.
module Data.PlanarGraph.Dart

-- | An Arc is a directed edge in a planar graph. The type s is used to tie
--   this arc to a particular graph.
newtype Arc s
Arc :: Int -> Arc s
[_unArc] :: Arc s -> Int

-- | Darts have a direction which is either Positive or Negative (shown as
--   +1 or -1, respectively).
data Direction
Negative :: Direction
Positive :: Direction

-- | Reverse the direcion
rev :: Direction -> Direction

-- | A dart represents a bi-directed edge. I.e. a dart has a direction,
--   however the dart of the oposite direction is always present in the
--   planar graph as well.
data Dart s
Dart :: !Arc s -> !Direction -> Dart s
[_arc] :: Dart s -> !Arc s
[_direction] :: Dart s -> !Direction
direction :: forall s_aKQp. Lens' (Dart s_aKQp) Direction
arc :: forall s_aKQp s_aLgN. Lens (Dart s_aKQp) (Dart s_aLgN) (Arc s_aKQp) (Arc s_aLgN)

-- | Get the twin of this dart (edge)
--   
--   <pre>
--   &gt;&gt;&gt; twin (dart 0 "+1")
--   Dart (Arc 0) -1
--   
--   &gt;&gt;&gt; twin (dart 0 "-1")
--   Dart (Arc 0) +1
--   </pre>
twin :: Dart s -> Dart s

-- | test if a dart is Positive
isPositive :: Dart s -> Bool

-- | Enumerates all darts such that allDarts !! i = d <a>=</a> i ==
--   fromEnum d
allDarts :: [Dart s]
instance forall k (s :: k). Control.DeepSeq.NFData (Data.PlanarGraph.Dart.Dart s)
instance forall k (s :: k). GHC.Show.Show (Data.PlanarGraph.Dart.Dart s)
instance forall k (s :: k). Test.QuickCheck.Arbitrary.Arbitrary (Data.PlanarGraph.Dart.Dart s)
instance forall k (s :: k). GHC.Enum.Enum (Data.PlanarGraph.Dart.Dart s)
instance forall k (s :: k). GHC.Generics.Generic (Data.PlanarGraph.Dart.Dart s)
instance forall k (s :: k). GHC.Classes.Ord (Data.PlanarGraph.Dart.Dart s)
instance forall k (s :: k). GHC.Classes.Eq (Data.PlanarGraph.Dart.Dart s)
instance GHC.Generics.Generic Data.PlanarGraph.Dart.Direction
instance GHC.Enum.Enum Data.PlanarGraph.Dart.Direction
instance GHC.Enum.Bounded Data.PlanarGraph.Dart.Direction
instance GHC.Classes.Ord Data.PlanarGraph.Dart.Direction
instance GHC.Classes.Eq Data.PlanarGraph.Dart.Direction
instance forall k (s :: k). Control.DeepSeq.NFData (Data.PlanarGraph.Dart.Arc s)
instance forall k (s :: k). GHC.Generics.Generic (Data.PlanarGraph.Dart.Arc s)
instance forall k (s :: k). GHC.Enum.Bounded (Data.PlanarGraph.Dart.Arc s)
instance forall k (s :: k). GHC.Enum.Enum (Data.PlanarGraph.Dart.Arc s)
instance forall k (s :: k). GHC.Classes.Ord (Data.PlanarGraph.Dart.Arc s)
instance forall k (s :: k). GHC.Classes.Eq (Data.PlanarGraph.Dart.Arc s)
instance Control.DeepSeq.NFData Data.PlanarGraph.Dart.Direction
instance GHC.Show.Show Data.PlanarGraph.Dart.Direction
instance GHC.Read.Read Data.PlanarGraph.Dart.Direction
instance Test.QuickCheck.Arbitrary.Arbitrary Data.PlanarGraph.Dart.Direction
instance forall k (s :: k). GHC.Show.Show (Data.PlanarGraph.Dart.Arc s)
instance forall k (s :: k). Test.QuickCheck.Arbitrary.Arbitrary (Data.PlanarGraph.Dart.Arc s)


-- | Data type for representing connected planar graphs
module Data.PlanarGraph.Core

-- | The world in which the graph lives
data World
Primal :: World
Dual :: World

-- | We can take the dual of a world. For the Primal this gives us the
--   Dual, for the Dual this gives us the Primal.
type family DualOf (sp :: World)

-- | The Dual of the Dual is the Primal.
dualDualIdentity :: forall w. DualOf (DualOf w) :~: w

-- | A vertex in a planar graph. A vertex is tied to a particular planar
--   graph by the phantom type s, and to a particular world w.
newtype VertexId s (w :: World)
VertexId :: Int -> VertexId s (w :: World)
[_unVertexId] :: VertexId s (w :: World) -> Int

-- | Shorthand for vertices in the primal.
type VertexId' s = VertexId s Primal
unVertexId :: Getter (VertexId s w) Int

-- | The type to represent FaceId's
newtype FaceId s w
FaceId :: VertexId s (DualOf w) -> FaceId s w
[_unFaceId] :: FaceId s w -> VertexId s (DualOf w)

-- | Shorthand for FaceId's in the primal.
type FaceId' s = FaceId s Primal

-- | A *connected* Planar graph with bidirected edges. I.e. the edges
--   (darts) are directed, however, for every directed edge, the edge in
--   the oposite direction is also in the graph.
--   
--   The types v, e, and f are the are the types of the data associated
--   with the vertices, edges, and faces, respectively.
--   
--   The orbits in the embedding are assumed to be in counterclockwise
--   order. Therefore, every dart directly bounds the face to its right.
data PlanarGraph s (w :: World) v e f
PlanarGraph :: Permutation (Dart s) -> Vector v -> Vector e -> Vector f -> PlanarGraph s (DualOf w) f e v -> PlanarGraph s (w :: World) v e f
[_embedding] :: PlanarGraph s (w :: World) v e f -> Permutation (Dart s)
[_vertexData] :: PlanarGraph s (w :: World) v e f -> Vector v
[_rawDartData] :: PlanarGraph s (w :: World) v e f -> Vector e
[_faceData] :: PlanarGraph s (w :: World) v e f -> Vector f
[_dual] :: PlanarGraph s (w :: World) v e f -> PlanarGraph s (DualOf w) f e v

-- | Get the embedding, represented as a permutation of the darts, of this
--   graph.
embedding :: Getter (PlanarGraph s w v e f) (Permutation (Dart s))
vertexData :: Lens (PlanarGraph s w v e f) (PlanarGraph s w v' e f) (Vector v) (Vector v')
rawDartData :: Lens (PlanarGraph s w v e f) (PlanarGraph s w v e' f) (Vector e) (Vector e')
faceData :: Lens (PlanarGraph s w v e f) (PlanarGraph s w v e f') (Vector f) (Vector f')

-- | Get the dual graph of this graph.
dual :: Getter (PlanarGraph s w v e f) (PlanarGraph s (DualOf w) f e v)

-- | lens to access the Dart Data
dartData :: Lens (PlanarGraph s w v e f) (PlanarGraph s w v e' f) (Vector (Dart s, e)) (Vector (Dart s, e'))

-- | edgeData is just an alias for <a>dartData</a>
edgeData :: Lens (PlanarGraph s w v e f) (PlanarGraph s w v e' f) (Vector (Dart s, e)) (Vector (Dart s, e'))

-- | Helper function to update the data in a planar graph. Takes care to
--   update both the data in the original graph as well as in the dual.
updateData :: forall s w v e f v' e' f'. (Vector v -> Vector v') -> (Vector e -> Vector e') -> (Vector f -> Vector f') -> PlanarGraph s w v e f -> PlanarGraph s w v' e' f'

-- | The function that does the actual work for <a>updateData</a>
updateData' :: DualOf (DualOf w) ~ w => (Vector v -> Vector v') -> (Vector e -> Vector e') -> (Vector f -> Vector f') -> PlanarGraph s w v e f -> PlanarGraph s w v' e' f'

-- | Reorders the edge data to be in the right order to set edgeData
reorderEdgeData :: Foldable f => f (Dart s, e) -> Vector e

-- | Traverse the vertices
--   
--   <pre>
--   &gt;&gt;&gt; (^.vertexData) &lt;$&gt; traverseVertices (\i x -&gt; Just (i,x)) myGraph
--   Just [(VertexId 0,()),(VertexId 1,()),(VertexId 2,()),(VertexId 3,())]
--   
--   &gt;&gt;&gt; traverseVertices (\i x -&gt; print (i,x)) myGraph &gt;&gt; pure ()
--   (VertexId 0,())
--   (VertexId 1,())
--   (VertexId 2,())
--   (VertexId 3,())
--   </pre>
traverseVertices :: Applicative m => (VertexId s w -> v -> m v') -> PlanarGraph s w v e f -> m (PlanarGraph s w v' e f)

-- | Traverses the darts
--   
--   <pre>
--   &gt;&gt;&gt; traverseDarts (\d x -&gt; print (d,x)) myGraph &gt;&gt; pure ()
--   (Dart (Arc 0) +1,"a+")
--   (Dart (Arc 0) -1,"a-")
--   (Dart (Arc 1) +1,"b+")
--   (Dart (Arc 1) -1,"b-")
--   (Dart (Arc 2) +1,"c+")
--   (Dart (Arc 2) -1,"c-")
--   (Dart (Arc 3) +1,"d+")
--   (Dart (Arc 3) -1,"d-")
--   (Dart (Arc 4) +1,"e+")
--   (Dart (Arc 4) -1,"e-")
--   (Dart (Arc 5) +1,"g+")
--   (Dart (Arc 5) -1,"g-")
--   </pre>
traverseDarts :: Applicative m => (Dart s -> e -> m e') -> PlanarGraph s w v e f -> m (PlanarGraph s w v e' f)

-- | Traverses the faces
--   
--   <pre>
--   &gt;&gt;&gt; traverseFaces (\i x -&gt; print (i,x)) myGraph &gt;&gt; pure ()
--   (FaceId 0,())
--   (FaceId 1,())
--   (FaceId 2,())
--   (FaceId 3,())
--   </pre>
traverseFaces :: Applicative m => (FaceId s w -> f -> m f') -> PlanarGraph s w v e f -> m (PlanarGraph s w v e f')

-- | Construct a planar graph
--   
--   running time: &lt;math&gt;.
planarGraph' :: Permutation (Dart s) -> PlanarGraph s w () () ()

-- | Construct a planar graph, given the darts in cyclic order around each
--   vertex.
--   
--   running time: &lt;math&gt;.
planarGraph :: [[(Dart s, e)]] -> PlanarGraph s Primal () e ()

-- | Produces the adjacencylists for all vertices in the graph. For every
--   vertex, the adjacent vertices are given in counter clockwise order.
--   
--   Note that in case a vertex u as a self loop, we have that this
--   vertexId occurs twice in the list of neighbours, i.e.: u :
--   [...,u,..,u,...]. Similarly, if there are multiple darts between a
--   pair of edges they occur multiple times.
--   
--   running time: &lt;math&gt;
toAdjacencyLists :: PlanarGraph s w v e f -> [(VertexId s w, Vector (VertexId s w))]

-- | Get the number of vertices
--   
--   <pre>
--   &gt;&gt;&gt; numVertices myGraph
--   4
--   </pre>
numVertices :: PlanarGraph s w v e f -> Int

-- | Get the number of Darts
--   
--   <pre>
--   &gt;&gt;&gt; numDarts myGraph
--   12
--   </pre>
numDarts :: PlanarGraph s w v e f -> Int

-- | Get the number of Edges
--   
--   <pre>
--   &gt;&gt;&gt; numEdges myGraph
--   6
--   </pre>
numEdges :: PlanarGraph s w v e f -> Int

-- | Get the number of faces
--   
--   <pre>
--   &gt;&gt;&gt; numFaces myGraph
--   4
--   </pre>
numFaces :: PlanarGraph s w v e f -> Int

-- | Enumerate all vertices
--   
--   <pre>
--   &gt;&gt;&gt; vertices' myGraph
--   [VertexId 0,VertexId 1,VertexId 2,VertexId 3]
--   </pre>
vertices' :: PlanarGraph s w v e f -> Vector (VertexId s w)

-- | Enumerate all vertices, together with their vertex data
vertices :: PlanarGraph s w v e f -> Vector (VertexId s w, v)

-- | Enumerate all darts
darts' :: PlanarGraph s w v e f -> Vector (Dart s)

-- | Get all darts together with their data
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ print $ darts myGraph
--   (Dart (Arc 0) -1,"a-")
--   (Dart (Arc 2) +1,"c+")
--   (Dart (Arc 1) +1,"b+")
--   (Dart (Arc 0) +1,"a+")
--   (Dart (Arc 4) -1,"e-")
--   (Dart (Arc 1) -1,"b-")
--   (Dart (Arc 3) -1,"d-")
--   (Dart (Arc 5) +1,"g+")
--   (Dart (Arc 4) +1,"e+")
--   (Dart (Arc 3) +1,"d+")
--   (Dart (Arc 2) -1,"c-")
--   (Dart (Arc 5) -1,"g-")
--   </pre>
darts :: PlanarGraph s w v e f -> Vector (Dart s, e)

-- | Enumerate all edges. We report only the Positive darts
edges' :: PlanarGraph s w v e f -> Vector (Dart s)

-- | Enumerate all edges with their edge data. We report only the Positive
--   darts.
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ print $ edges myGraph
--   (Dart (Arc 2) +1,"c+")
--   (Dart (Arc 1) +1,"b+")
--   (Dart (Arc 0) +1,"a+")
--   (Dart (Arc 5) +1,"g+")
--   (Dart (Arc 4) +1,"e+")
--   (Dart (Arc 3) +1,"d+")
--   </pre>
edges :: PlanarGraph s w v e f -> Vector (Dart s, e)

-- | The tail of a dart, i.e. the vertex this dart is leaving from
--   
--   running time: &lt;math&gt;
tailOf :: Dart s -> PlanarGraph s w v e f -> VertexId s w

-- | The vertex this dart is heading in to
--   
--   running time: &lt;math&gt;
headOf :: Dart s -> PlanarGraph s w v e f -> VertexId s w

-- | endPoints d g = (tailOf d g, headOf d g)
--   
--   running time: &lt;math&gt;
endPoints :: Dart s -> PlanarGraph s w v e f -> (VertexId s w, VertexId s w)

-- | All edges incident to vertex v, in counterclockwise order around v.
--   
--   running time: &lt;math&gt;, where &lt;math&gt; is the output size
incidentEdges :: VertexId s w -> PlanarGraph s w v e f -> Vector (Dart s)

-- | All edges incident to vertex v in incoming direction (i.e. pointing
--   into v) in counterclockwise order around v.
--   
--   running time: &lt;math&gt;, where (k) is the total number of incident
--   edges of v
incomingEdges :: VertexId s w -> PlanarGraph s w v e f -> Vector (Dart s)

-- | All edges incident to vertex v in outgoing direction (i.e. pointing
--   away from v) in counterclockwise order around v.
--   
--   running time: &lt;math&gt;, where (k) is the total number of incident
--   edges of v
outgoingEdges :: VertexId s w -> PlanarGraph s w v e f -> Vector (Dart s)

-- | Gets the neighbours of a particular vertex, in counterclockwise order
--   around the vertex.
--   
--   running time: &lt;math&gt;, where &lt;math&gt; is the output size
neighboursOf :: VertexId s w -> PlanarGraph s w v e f -> Vector (VertexId s w)

-- | Given a dart d that points into some vertex v, report the next dart in
--   the cyclic order around v.
--   
--   running time: &lt;math&gt;
nextIncidentEdge :: Dart s -> PlanarGraph s w v e f -> Dart s

-- | Given a dart d that points into some vertex v, report the next dart in
--   the cyclic order around v.
--   
--   running time: &lt;math&gt;
prevIncidentEdge :: Dart s -> PlanarGraph s w v e f -> Dart s
class HasDataOf g i where {
    type family DataOf g i;
}

-- | get the data associated with the value i.
--   
--   running time: &lt;math&gt; to read the data, &lt;math&gt; to write it.
dataOf :: HasDataOf g i => i -> Lens' g (DataOf g i)

-- | Data corresponding to the endpoints of the dart
endPointDataOf :: Dart s -> Getter (PlanarGraph s w v e f) (v, v)

-- | Data corresponding to the endpoints of the dart
--   
--   running time: &lt;math&gt;
endPointData :: Dart s -> PlanarGraph s w v e f -> (v, v)

-- | The dual of this graph
--   
--   <pre>
--   &gt;&gt;&gt; :{
--    let fromList = V.fromList
--        answer = fromList [ fromList [dart 0 "-1"]
--                          , fromList [dart 2 "+1",dart 4 "+1",dart 1 "-1",dart 0 "+1"]
--                          , fromList [dart 1 "+1",dart 3 "-1",dart 2 "-1"]
--                          , fromList [dart 4 "-1",dart 3 "+1",dart 5 "+1",dart 5 "-1"]
--                          ]
--    in (computeDual myGraph)^.embedding.orbits == answer
--   :}
--   True
--   </pre>
--   
--   running time: &lt;math&gt;.
computeDual :: forall s w v e f. PlanarGraph s w v e f -> PlanarGraph s (DualOf w) f e v

-- | Does the actual work for dualGraph
computeDual' :: DualOf (DualOf w) ~ w => PlanarGraph s w v e f -> PlanarGraph s (DualOf w) f e v
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World) v e f. GHC.Generics.Generic (Data.PlanarGraph.Core.PlanarGraph s w v e f)
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World). Data.Aeson.Types.FromJSON.FromJSON (Data.PlanarGraph.Core.FaceId s w)
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World). Data.Aeson.Types.ToJSON.ToJSON (Data.PlanarGraph.Core.FaceId s w)
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World). GHC.Enum.Enum (Data.PlanarGraph.Core.FaceId s w)
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World). GHC.Classes.Ord (Data.PlanarGraph.Core.FaceId s w)
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World). GHC.Classes.Eq (Data.PlanarGraph.Core.FaceId s w)
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World). Control.DeepSeq.NFData (Data.PlanarGraph.Core.VertexId s w)
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World). GHC.Generics.Generic (Data.PlanarGraph.Core.VertexId s w)
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World). Data.Aeson.Types.FromJSON.FromJSON (Data.PlanarGraph.Core.VertexId s w)
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World). Data.Aeson.Types.ToJSON.ToJSON (Data.PlanarGraph.Core.VertexId s w)
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World). GHC.Enum.Enum (Data.PlanarGraph.Core.VertexId s w)
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World). GHC.Classes.Ord (Data.PlanarGraph.Core.VertexId s w)
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World). GHC.Classes.Eq (Data.PlanarGraph.Core.VertexId s w)
instance GHC.Classes.Eq Data.PlanarGraph.Core.World
instance GHC.Show.Show Data.PlanarGraph.Core.World
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World) v e f. Data.PlanarGraph.Core.HasDataOf (Data.PlanarGraph.Core.PlanarGraph s w v e f) (Data.PlanarGraph.Core.VertexId s w)
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World) v e f. Data.PlanarGraph.Core.HasDataOf (Data.PlanarGraph.Core.PlanarGraph s w v e f) (Data.PlanarGraph.Dart.Dart s)
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World) v e f. Data.PlanarGraph.Core.HasDataOf (Data.PlanarGraph.Core.PlanarGraph s w v e f) (Data.PlanarGraph.Core.FaceId s w)
instance forall k v e f (s :: k) (w :: Data.PlanarGraph.Core.World). (GHC.Show.Show v, GHC.Show.Show e, GHC.Show.Show f) => GHC.Show.Show (Data.PlanarGraph.Core.PlanarGraph s w v e f)
instance forall k v e f (s :: k) (w :: Data.PlanarGraph.Core.World). (GHC.Classes.Eq v, GHC.Classes.Eq e, GHC.Classes.Eq f) => GHC.Classes.Eq (Data.PlanarGraph.Core.PlanarGraph s w v e f)
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World). GHC.Show.Show (Data.PlanarGraph.Core.FaceId s w)
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World). GHC.Show.Show (Data.PlanarGraph.Core.VertexId s w)


-- | Data type for representing connected planar graphs. This module
--   contains everything that has to do with the dual graph (i.e. computing
--   it/ operations on faces etc.)
module Data.PlanarGraph.Dual

-- | Enumerate all faces in the planar graph
faces' :: PlanarGraph s w v e f -> Vector (FaceId s w)

-- | All faces with their face data.
faces :: PlanarGraph s w v e f -> Vector (FaceId s w, f)

-- | The face to the left of the dart
--   
--   <pre>
--   &gt;&gt;&gt; leftFace (dart 1 "+1") myGraph
--   FaceId 1
--   
--   &gt;&gt;&gt; leftFace (dart 1 "-1") myGraph
--   FaceId 2
--   
--   &gt;&gt;&gt; leftFace (dart 2 "+1") myGraph
--   FaceId 2
--   
--   &gt;&gt;&gt; leftFace (dart 0 "+1") myGraph
--   FaceId 0
--   </pre>
--   
--   running time: &lt;math&gt;.
leftFace :: Dart s -> PlanarGraph s w v e f -> FaceId s w

-- | The face to the right of the dart
--   
--   <pre>
--   &gt;&gt;&gt; rightFace (dart 1 "+1") myGraph
--   FaceId 2
--   
--   &gt;&gt;&gt; rightFace (dart 1 "-1") myGraph
--   FaceId 1
--   
--   &gt;&gt;&gt; rightFace (dart 2 "+1") myGraph
--   FaceId 1
--   
--   &gt;&gt;&gt; rightFace (dart 0 "+1") myGraph
--   FaceId 1
--   </pre>
--   
--   running time: &lt;math&gt;.
rightFace :: Dart s -> PlanarGraph s w v e f -> FaceId s w

-- | Get the next edge along the face
--   
--   running time: &lt;math&gt;.
nextEdge :: Dart s -> PlanarGraph s w v e f -> Dart s

-- | Get the previous edge along the face
--   
--   running time: &lt;math&gt;.
prevEdge :: Dart s -> PlanarGraph s w v e f -> Dart s

-- | Gets a dart bounding this face. I.e. a dart d such that the face lies
--   to the right of the dart.
boundaryDart :: FaceId s w -> PlanarGraph s w v e f -> Dart s

-- | The darts bounding this face, for internal faces in clockwise order,
--   for the outer face in counter clockwise order.
--   
--   running time: &lt;math&gt;, where &lt;math&gt; is the output size.
boundary :: FaceId s w -> PlanarGraph s w v e f -> Vector (Dart s)

-- | Generates the darts incident to a face, starting with the given dart.
--   
--   &lt;math&gt;, where &lt;math&gt; is the number of darts reported
boundary' :: Dart s -> PlanarGraph s w v e f -> Vector (Dart s)

-- | The vertices bounding this face, for internal faces in clockwise
--   order, for the outer face in counter clockwise order.
--   
--   running time: &lt;math&gt;, where &lt;math&gt; is the output size.
boundaryVertices :: FaceId s w -> PlanarGraph s w v e f -> Vector (VertexId s w)


-- | Data structure to represent a planar graph with which we can test in
--   &lt;math&gt; time if an edge between a pair of vertices exists.
module Data.PlanarGraph.EdgeOracle

-- | Edge Oracle:
--   
--   main idea: store adjacency lists in such a way that we store an edge
--   (u,v) either in u's adjacency list or in v's. This can be done s.t.
--   all adjacency lists have length at most 6.
--   
--   note: Every edge is stored exactly once (i.e. either at u or at v, but
--   not both)
newtype EdgeOracle s w a
EdgeOracle :: Vector (Vector (VertexId s w :+ a)) -> EdgeOracle s w a
[_unEdgeOracle] :: EdgeOracle s w a -> Vector (Vector (VertexId s w :+ a))

-- | Given a planar graph, construct an edge oracle. Given a pair of
--   vertices this allows us to efficiently find the dart representing this
--   edge in the graph.
--   
--   pre: No self-loops and no multi-edges!!!
--   
--   running time: &lt;math&gt;
edgeOracle :: PlanarGraph s w v e f -> EdgeOracle s w (Dart s)

-- | Builds an edge oracle that can be used to efficiently test if two
--   vertices are connected by an edge.
--   
--   running time: &lt;math&gt;
buildEdgeOracle :: forall f s w e. Foldable f => [(VertexId s w, f (VertexId s w :+ e))] -> EdgeOracle s w e

-- | Test if u and v are connected by an edge.
--   
--   running time: &lt;math&gt;
hasEdge :: VertexId s w -> VertexId s w -> EdgeOracle s w a -> Bool

-- | Find the edge data corresponding to edge (u,v) if such an edge exists
--   
--   running time: &lt;math&gt;
findEdge :: VertexId s w -> VertexId s w -> EdgeOracle s w a -> Maybe a

-- | Given a pair of vertices (u,v) returns the dart, oriented from u to v,
--   corresponding to these vertices.
--   
--   running time: &lt;math&gt;
findDart :: VertexId s w -> VertexId s w -> EdgeOracle s w (Dart s) -> Maybe (Dart s)
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World) a. GHC.Classes.Eq a => GHC.Classes.Eq (Data.PlanarGraph.EdgeOracle.EdgeOracle s w a)
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World) a. GHC.Show.Show a => GHC.Show.Show (Data.PlanarGraph.EdgeOracle.EdgeOracle s w a)
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World). GHC.Base.Functor (Data.PlanarGraph.EdgeOracle.EdgeOracle s w)
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World). Data.Foldable.Foldable (Data.PlanarGraph.EdgeOracle.EdgeOracle s w)
instance forall k (s :: k) (w :: Data.PlanarGraph.Core.World). Data.Traversable.Traversable (Data.PlanarGraph.EdgeOracle.EdgeOracle s w)


-- | Converting from<i>to our JSON</i>Yaml representation of the plane
--   graph
module Data.PlanarGraph.IO

-- | Transforms the planar graph into a format that can be easily converted
--   into JSON format. For every vertex, the adjacent vertices are given in
--   counter-clockwise order.
--   
--   See <a>toAdjacencyLists</a> for notes on how we handle self-loops.
--   
--   running time: &lt;math&gt;
toAdjRep :: PlanarGraph s w v e f -> Gr (Vtx v e) (Face f)

-- | Read a planar graph, given in JSON format into a planar graph. The
--   adjacencylists should be in counter clockwise order.
--   
--   running time: &lt;math&gt;
fromAdjRep :: proxy s -> Gr (Vtx v e) (Face f) -> PlanarGraph s Primal v e f

-- | Builds the graph from the adjacency lists (but ignores all associated
--   data)
buildGraph :: proxy s -> Gr (Vtx v e) (Face f) -> PlanarGraph s Primal () () ()
reorder :: Vector (i :+ a) -> (i -> Int) -> Vector a

-- | Construct a planar graph from a adjacency matrix. For every vertex,
--   all vertices should be given in counter-clockwise order.
--   
--   pre: No self-loops, and no multi-edges
--   
--   running time: &lt;math&gt;.
fromAdjacencyLists :: forall s w h. (Foldable h, Functor h) => [(VertexId s w, h (VertexId s w))] -> PlanarGraph s w () () ()
assignArcs :: EdgeOracle s w e -> EdgeOracle s w (Int :+ e)
instance forall k v e f (s :: k) (w :: Data.PlanarGraph.Core.World). (Data.Aeson.Types.ToJSON.ToJSON v, Data.Aeson.Types.ToJSON.ToJSON e, Data.Aeson.Types.ToJSON.ToJSON f) => Data.Aeson.Types.ToJSON.ToJSON (Data.PlanarGraph.Core.PlanarGraph s w v e f)
instance forall k v e f (s :: k). (Data.Aeson.Types.FromJSON.FromJSON v, Data.Aeson.Types.FromJSON.FromJSON e, Data.Aeson.Types.FromJSON.FromJSON f) => Data.Aeson.Types.FromJSON.FromJSON (Data.PlanarGraph.Core.PlanarGraph s 'Data.PlanarGraph.Core.Primal v e f)


-- | Data type for representing connected planar graphs
module Data.PlanarGraph

-- | A *connected* Planar graph with bidirected edges. I.e. the edges
--   (darts) are directed, however, for every directed edge, the edge in
--   the oposite direction is also in the graph.
--   
--   The types v, e, and f are the are the types of the data associated
--   with the vertices, edges, and faces, respectively.
--   
--   The orbits in the embedding are assumed to be in counterclockwise
--   order. Therefore, every dart directly bounds the face to its right.
data PlanarGraph s (w :: World) v e f

-- | Get the embedding, represented as a permutation of the darts, of this
--   graph.
embedding :: Getter (PlanarGraph s w v e f) (Permutation (Dart s))
vertexData :: Lens (PlanarGraph s w v e f) (PlanarGraph s w v' e f) (Vector v) (Vector v')

-- | lens to access the Dart Data
dartData :: Lens (PlanarGraph s w v e f) (PlanarGraph s w v e' f) (Vector (Dart s, e)) (Vector (Dart s, e'))
faceData :: Lens (PlanarGraph s w v e f) (PlanarGraph s w v e f') (Vector f) (Vector f')
rawDartData :: Lens (PlanarGraph s w v e f) (PlanarGraph s w v e' f) (Vector e) (Vector e')

-- | edgeData is just an alias for <a>dartData</a>
edgeData :: Lens (PlanarGraph s w v e f) (PlanarGraph s w v e' f) (Vector (Dart s, e)) (Vector (Dart s, e'))

-- | The world in which the graph lives
data World
Primal :: World
Dual :: World

-- | We can take the dual of a world. For the Primal this gives us the
--   Dual, for the Dual this gives us the Primal.
type family DualOf (sp :: World)

-- | An Arc is a directed edge in a planar graph. The type s is used to tie
--   this arc to a particular graph.
newtype Arc s
Arc :: Int -> Arc s
[_unArc] :: Arc s -> Int

-- | Darts have a direction which is either Positive or Negative (shown as
--   +1 or -1, respectively).
data Direction
Negative :: Direction
Positive :: Direction

-- | Reverse the direcion
rev :: Direction -> Direction

-- | A dart represents a bi-directed edge. I.e. a dart has a direction,
--   however the dart of the oposite direction is always present in the
--   planar graph as well.
data Dart s
Dart :: !Arc s -> !Direction -> Dart s
[_arc] :: Dart s -> !Arc s
[_direction] :: Dart s -> !Direction
arc :: forall s_aKQp s_aLgN. Lens (Dart s_aKQp) (Dart s_aLgN) (Arc s_aKQp) (Arc s_aLgN)
direction :: forall s_aKQp. Lens' (Dart s_aKQp) Direction

-- | Get the twin of this dart (edge)
--   
--   <pre>
--   &gt;&gt;&gt; twin (dart 0 "+1")
--   Dart (Arc 0) -1
--   
--   &gt;&gt;&gt; twin (dart 0 "-1")
--   Dart (Arc 0) +1
--   </pre>
twin :: Dart s -> Dart s

-- | test if a dart is Positive
isPositive :: Dart s -> Bool

-- | A vertex in a planar graph. A vertex is tied to a particular planar
--   graph by the phantom type s, and to a particular world w.
newtype VertexId s (w :: World)
VertexId :: Int -> VertexId s (w :: World)
[_unVertexId] :: VertexId s (w :: World) -> Int

-- | Shorthand for vertices in the primal.
type VertexId' s = VertexId s Primal

-- | Construct a planar graph, given the darts in cyclic order around each
--   vertex.
--   
--   running time: &lt;math&gt;.
planarGraph :: [[(Dart s, e)]] -> PlanarGraph s Primal () e ()

-- | Construct a planar graph
--   
--   running time: &lt;math&gt;.
planarGraph' :: Permutation (Dart s) -> PlanarGraph s w () () ()

-- | Construct a planar graph from a adjacency matrix. For every vertex,
--   all vertices should be given in counter-clockwise order.
--   
--   pre: No self-loops, and no multi-edges
--   
--   running time: &lt;math&gt;.
fromAdjacencyLists :: forall s w h. (Foldable h, Functor h) => [(VertexId s w, h (VertexId s w))] -> PlanarGraph s w () () ()

-- | Produces the adjacencylists for all vertices in the graph. For every
--   vertex, the adjacent vertices are given in counter clockwise order.
--   
--   Note that in case a vertex u as a self loop, we have that this
--   vertexId occurs twice in the list of neighbours, i.e.: u :
--   [...,u,..,u,...]. Similarly, if there are multiple darts between a
--   pair of edges they occur multiple times.
--   
--   running time: &lt;math&gt;
toAdjacencyLists :: PlanarGraph s w v e f -> [(VertexId s w, Vector (VertexId s w))]

-- | Read a planar graph, given in JSON format into a planar graph. The
--   adjacencylists should be in counter clockwise order.
--   
--   running time: &lt;math&gt;
fromAdjRep :: proxy s -> Gr (Vtx v e) (Face f) -> PlanarGraph s Primal v e f

-- | Transforms the planar graph into a format that can be easily converted
--   into JSON format. For every vertex, the adjacent vertices are given in
--   counter-clockwise order.
--   
--   See <a>toAdjacencyLists</a> for notes on how we handle self-loops.
--   
--   running time: &lt;math&gt;
toAdjRep :: PlanarGraph s w v e f -> Gr (Vtx v e) (Face f)

-- | Get the number of vertices
--   
--   <pre>
--   &gt;&gt;&gt; numVertices myGraph
--   4
--   </pre>
numVertices :: PlanarGraph s w v e f -> Int

-- | Get the number of Darts
--   
--   <pre>
--   &gt;&gt;&gt; numDarts myGraph
--   12
--   </pre>
numDarts :: PlanarGraph s w v e f -> Int

-- | Get the number of Edges
--   
--   <pre>
--   &gt;&gt;&gt; numEdges myGraph
--   6
--   </pre>
numEdges :: PlanarGraph s w v e f -> Int

-- | Get the number of faces
--   
--   <pre>
--   &gt;&gt;&gt; numFaces myGraph
--   4
--   </pre>
numFaces :: PlanarGraph s w v e f -> Int

-- | Enumerate all darts
darts' :: PlanarGraph s w v e f -> Vector (Dart s)

-- | Get all darts together with their data
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ print $ darts myGraph
--   (Dart (Arc 0) -1,"a-")
--   (Dart (Arc 2) +1,"c+")
--   (Dart (Arc 1) +1,"b+")
--   (Dart (Arc 0) +1,"a+")
--   (Dart (Arc 4) -1,"e-")
--   (Dart (Arc 1) -1,"b-")
--   (Dart (Arc 3) -1,"d-")
--   (Dart (Arc 5) +1,"g+")
--   (Dart (Arc 4) +1,"e+")
--   (Dart (Arc 3) +1,"d+")
--   (Dart (Arc 2) -1,"c-")
--   (Dart (Arc 5) -1,"g-")
--   </pre>
darts :: PlanarGraph s w v e f -> Vector (Dart s, e)

-- | Enumerate all edges. We report only the Positive darts
edges' :: PlanarGraph s w v e f -> Vector (Dart s)

-- | Enumerate all edges with their edge data. We report only the Positive
--   darts.
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ print $ edges myGraph
--   (Dart (Arc 2) +1,"c+")
--   (Dart (Arc 1) +1,"b+")
--   (Dart (Arc 0) +1,"a+")
--   (Dart (Arc 5) +1,"g+")
--   (Dart (Arc 4) +1,"e+")
--   (Dart (Arc 3) +1,"d+")
--   </pre>
edges :: PlanarGraph s w v e f -> Vector (Dart s, e)

-- | Enumerate all vertices
--   
--   <pre>
--   &gt;&gt;&gt; vertices' myGraph
--   [VertexId 0,VertexId 1,VertexId 2,VertexId 3]
--   </pre>
vertices' :: PlanarGraph s w v e f -> Vector (VertexId s w)

-- | Enumerate all vertices, together with their vertex data
vertices :: PlanarGraph s w v e f -> Vector (VertexId s w, v)

-- | Enumerate all faces in the planar graph
faces' :: PlanarGraph s w v e f -> Vector (FaceId s w)

-- | All faces with their face data.
faces :: PlanarGraph s w v e f -> Vector (FaceId s w, f)

-- | Traverse the vertices
--   
--   <pre>
--   &gt;&gt;&gt; (^.vertexData) &lt;$&gt; traverseVertices (\i x -&gt; Just (i,x)) myGraph
--   Just [(VertexId 0,()),(VertexId 1,()),(VertexId 2,()),(VertexId 3,())]
--   
--   &gt;&gt;&gt; traverseVertices (\i x -&gt; print (i,x)) myGraph &gt;&gt; pure ()
--   (VertexId 0,())
--   (VertexId 1,())
--   (VertexId 2,())
--   (VertexId 3,())
--   </pre>
traverseVertices :: Applicative m => (VertexId s w -> v -> m v') -> PlanarGraph s w v e f -> m (PlanarGraph s w v' e f)

-- | Traverses the darts
--   
--   <pre>
--   &gt;&gt;&gt; traverseDarts (\d x -&gt; print (d,x)) myGraph &gt;&gt; pure ()
--   (Dart (Arc 0) +1,"a+")
--   (Dart (Arc 0) -1,"a-")
--   (Dart (Arc 1) +1,"b+")
--   (Dart (Arc 1) -1,"b-")
--   (Dart (Arc 2) +1,"c+")
--   (Dart (Arc 2) -1,"c-")
--   (Dart (Arc 3) +1,"d+")
--   (Dart (Arc 3) -1,"d-")
--   (Dart (Arc 4) +1,"e+")
--   (Dart (Arc 4) -1,"e-")
--   (Dart (Arc 5) +1,"g+")
--   (Dart (Arc 5) -1,"g-")
--   </pre>
traverseDarts :: Applicative m => (Dart s -> e -> m e') -> PlanarGraph s w v e f -> m (PlanarGraph s w v e' f)

-- | Traverses the faces
--   
--   <pre>
--   &gt;&gt;&gt; traverseFaces (\i x -&gt; print (i,x)) myGraph &gt;&gt; pure ()
--   (FaceId 0,())
--   (FaceId 1,())
--   (FaceId 2,())
--   (FaceId 3,())
--   </pre>
traverseFaces :: Applicative m => (FaceId s w -> f -> m f') -> PlanarGraph s w v e f -> m (PlanarGraph s w v e f')

-- | The tail of a dart, i.e. the vertex this dart is leaving from
--   
--   running time: &lt;math&gt;
tailOf :: Dart s -> PlanarGraph s w v e f -> VertexId s w

-- | The vertex this dart is heading in to
--   
--   running time: &lt;math&gt;
headOf :: Dart s -> PlanarGraph s w v e f -> VertexId s w

-- | endPoints d g = (tailOf d g, headOf d g)
--   
--   running time: &lt;math&gt;
endPoints :: Dart s -> PlanarGraph s w v e f -> (VertexId s w, VertexId s w)

-- | All edges incident to vertex v, in counterclockwise order around v.
--   
--   running time: &lt;math&gt;, where &lt;math&gt; is the output size
incidentEdges :: VertexId s w -> PlanarGraph s w v e f -> Vector (Dart s)

-- | All edges incident to vertex v in incoming direction (i.e. pointing
--   into v) in counterclockwise order around v.
--   
--   running time: &lt;math&gt;, where (k) is the total number of incident
--   edges of v
incomingEdges :: VertexId s w -> PlanarGraph s w v e f -> Vector (Dart s)

-- | All edges incident to vertex v in outgoing direction (i.e. pointing
--   away from v) in counterclockwise order around v.
--   
--   running time: &lt;math&gt;, where (k) is the total number of incident
--   edges of v
outgoingEdges :: VertexId s w -> PlanarGraph s w v e f -> Vector (Dart s)

-- | Gets the neighbours of a particular vertex, in counterclockwise order
--   around the vertex.
--   
--   running time: &lt;math&gt;, where &lt;math&gt; is the output size
neighboursOf :: VertexId s w -> PlanarGraph s w v e f -> Vector (VertexId s w)

-- | Given a dart d that points into some vertex v, report the next dart in
--   the cyclic order around v.
--   
--   running time: &lt;math&gt;
nextIncidentEdge :: Dart s -> PlanarGraph s w v e f -> Dart s

-- | Given a dart d that points into some vertex v, report the next dart in
--   the cyclic order around v.
--   
--   running time: &lt;math&gt;
prevIncidentEdge :: Dart s -> PlanarGraph s w v e f -> Dart s
class HasDataOf g i where {
    type family DataOf g i;
}

-- | get the data associated with the value i.
--   
--   running time: &lt;math&gt; to read the data, &lt;math&gt; to write it.
dataOf :: HasDataOf g i => i -> Lens' g (DataOf g i)

-- | Data corresponding to the endpoints of the dart
endPointDataOf :: Dart s -> Getter (PlanarGraph s w v e f) (v, v)

-- | Data corresponding to the endpoints of the dart
--   
--   running time: &lt;math&gt;
endPointData :: Dart s -> PlanarGraph s w v e f -> (v, v)

-- | Get the dual graph of this graph.
dual :: Getter (PlanarGraph s w v e f) (PlanarGraph s (DualOf w) f e v)

-- | The type to represent FaceId's
newtype FaceId s w
FaceId :: VertexId s (DualOf w) -> FaceId s w
[_unFaceId] :: FaceId s w -> VertexId s (DualOf w)

-- | Shorthand for FaceId's in the primal.
type FaceId' s = FaceId s Primal

-- | The face to the left of the dart
--   
--   <pre>
--   &gt;&gt;&gt; leftFace (dart 1 "+1") myGraph
--   FaceId 1
--   
--   &gt;&gt;&gt; leftFace (dart 1 "-1") myGraph
--   FaceId 2
--   
--   &gt;&gt;&gt; leftFace (dart 2 "+1") myGraph
--   FaceId 2
--   
--   &gt;&gt;&gt; leftFace (dart 0 "+1") myGraph
--   FaceId 0
--   </pre>
--   
--   running time: &lt;math&gt;.
leftFace :: Dart s -> PlanarGraph s w v e f -> FaceId s w

-- | The face to the right of the dart
--   
--   <pre>
--   &gt;&gt;&gt; rightFace (dart 1 "+1") myGraph
--   FaceId 2
--   
--   &gt;&gt;&gt; rightFace (dart 1 "-1") myGraph
--   FaceId 1
--   
--   &gt;&gt;&gt; rightFace (dart 2 "+1") myGraph
--   FaceId 1
--   
--   &gt;&gt;&gt; rightFace (dart 0 "+1") myGraph
--   FaceId 1
--   </pre>
--   
--   running time: &lt;math&gt;.
rightFace :: Dart s -> PlanarGraph s w v e f -> FaceId s w

-- | Gets a dart bounding this face. I.e. a dart d such that the face lies
--   to the right of the dart.
boundaryDart :: FaceId s w -> PlanarGraph s w v e f -> Dart s

-- | The darts bounding this face, for internal faces in clockwise order,
--   for the outer face in counter clockwise order.
--   
--   running time: &lt;math&gt;, where &lt;math&gt; is the output size.
boundary :: FaceId s w -> PlanarGraph s w v e f -> Vector (Dart s)

-- | Generates the darts incident to a face, starting with the given dart.
--   
--   &lt;math&gt;, where &lt;math&gt; is the number of darts reported
boundary' :: Dart s -> PlanarGraph s w v e f -> Vector (Dart s)

-- | The vertices bounding this face, for internal faces in clockwise
--   order, for the outer face in counter clockwise order.
--   
--   running time: &lt;math&gt;, where &lt;math&gt; is the output size.
boundaryVertices :: FaceId s w -> PlanarGraph s w v e f -> Vector (VertexId s w)

-- | Get the next edge along the face
--   
--   running time: &lt;math&gt;.
nextEdge :: Dart s -> PlanarGraph s w v e f -> Dart s

-- | Get the previous edge along the face
--   
--   running time: &lt;math&gt;.
prevEdge :: Dart s -> PlanarGraph s w v e f -> Dart s


module Algorithms.Graph.DFS

-- | DFS on a planar graph.
--   
--   Running time: &lt;math&gt;
--   
--   Note that since our planar graphs are always connected there is no
--   need need for dfs to take a list of start vertices.
dfs :: forall s w v e f. PlanarGraph s w v e f -> VertexId s w -> Tree (VertexId s w)

-- | Adjacency list representation of a graph: for each vertex we simply
--   list all connected neighbours.
type AdjacencyLists s w = Vector [VertexId s w]

-- | Transform into adjacencylist representation
adjacencyLists :: PlanarGraph s w v e f -> AdjacencyLists s w

-- | DFS, from a given vertex, on a graph in AdjacencyLists representation.
--   
--   Running time: &lt;math&gt;
dfs' :: forall s w. AdjacencyLists s w -> VertexId s w -> Tree (VertexId s w)

-- | DFS, from a given vertex, on a graph in AdjacencyLists representation.
--   Cycles are not removed. If your graph may contain cycles, see
--   <a>dfsFilterCycles</a>.
--   
--   Running time: &lt;math&gt;, where &lt;math&gt; is the number of nodes
--   consumed.
dfsSensitive :: forall s w. (VertexId s w -> [VertexId s w]) -> VertexId s w -> Tree (VertexId s w)

-- | Remove infinite cycles from a DFS search tree.
dfsFilterCycles :: Tree (VertexId s w) -> Tree (VertexId s w)


module Algorithms.Graph.MST

-- | Minimum spanning tree of the edges. The result is a rooted tree, in
--   which the nodes are the vertices in the planar graph together with the
--   edge weight of the edge to their parent. The root's weight is zero.
--   
--   The algorithm used is Kruskal's.
--   
--   running time: &lt;math&gt;
mst :: Ord e => PlanarGraph s w v e f -> Tree (VertexId s w)

-- | Computes the set of edges in the Minimum spanning tree
--   
--   running time: &lt;math&gt;
mstEdges :: Ord e => PlanarGraph s w v e f -> [Dart s]

-- | Given an underlying planar graph, and a set of edges that form a tree,
--   create the actual tree.
--   
--   pre: the planar graph has at least one vertex.
makeTree :: forall s w v e f. PlanarGraph s w v e f -> [Dart s] -> Tree (VertexId s w)


-- | Data type for representing Generic Ranges (Intervals) and functions
--   that work with them.
module Data.Range

-- | Endpoints of a range may either be open or closed.
data EndPoint a
Open :: !a -> EndPoint a
Closed :: !a -> EndPoint a

-- | True iff EndPoint is open.
isOpen :: EndPoint a -> Bool

-- | True iff EndPoint is closed.
isClosed :: EndPoint a -> Bool

-- | Access lens for EndPoint value regardless of whether it is open or
--   closed.
--   
--   <pre>
--   &gt;&gt;&gt; Open 5 ^. unEndPoint
--   5
--   
--   &gt;&gt;&gt; Closed 10 ^. unEndPoint
--   10
--   
--   &gt;&gt;&gt; Open 4 &amp; unEndPoint .~ 0
--   Open 0
--   </pre>
unEndPoint :: Lens (EndPoint a) (EndPoint b) a b

-- | Data type for representing ranges.
data Range a
Range :: !EndPoint a -> !EndPoint a -> Range a
[_lower] :: Range a -> !EndPoint a
[_upper] :: Range a -> !EndPoint a
pattern OpenRange :: a -> a -> Range a
pattern ClosedRange :: a -> a -> Range a

-- | A range from l to u, ignoring/forgetting the type of the endpoints
pattern Range' :: a -> a -> Range a

-- | Helper function to show a range in mathematical notation.
--   
--   <pre>
--   &gt;&gt;&gt; prettyShow $ OpenRange 0 2
--   "(0,2)"
--   
--   &gt;&gt;&gt; prettyShow $ ClosedRange 0 2
--   "[0,2]"
--   
--   &gt;&gt;&gt; prettyShow $ Range (Open 0) (Closed 5)
--   "(0,5]"
--   </pre>
prettyShow :: Show a => Range a -> String
lower :: forall a_aRdV. Lens' (Range a_aRdV) (EndPoint a_aRdV)
upper :: forall a_aRdV. Lens' (Range a_aRdV) (EndPoint a_aRdV)

-- | Test if a value lies in a range.
--   
--   <pre>
--   &gt;&gt;&gt; 1 `inRange` (OpenRange 0 2)
--   True
--   
--   &gt;&gt;&gt; 1 `inRange` (OpenRange 0 1)
--   False
--   
--   &gt;&gt;&gt; 1 `inRange` (ClosedRange 0 1)
--   True
--   
--   &gt;&gt;&gt; 1 `inRange` (ClosedRange 1 1)
--   True
--   
--   &gt;&gt;&gt; 10 `inRange` (OpenRange 1 10)
--   False
--   
--   &gt;&gt;&gt; 10 `inRange` (ClosedRange 0 1)
--   False
--   </pre>
--   
--   This one is kind of weird
--   
--   <pre>
--   &gt;&gt;&gt; 0 `inRange` Range (Closed 0) (Open 0)
--   False
--   </pre>
inRange :: Ord a => a -> Range a -> Bool

-- | Get the width of the interval
--   
--   <pre>
--   &gt;&gt;&gt; width $ ClosedRange 1 10
--   9
--   
--   &gt;&gt;&gt; width $ OpenRange 5 10
--   5
--   </pre>
width :: Num r => Range r -> r

-- | Clip the interval from below. I.e. intersect with the interval
--   {l,infty), where { is either open, (, orr closed, [.
clipLower :: Ord a => EndPoint a -> Range a -> Maybe (Range a)

-- | Clip the interval from above. I.e. intersect with (-infty, u}, where }
--   is either open, ), or closed, ],
clipUpper :: Ord a => EndPoint a -> Range a -> Maybe (Range a)
midPoint :: Fractional r => Range r -> r

-- | Clamps a value to a range. I.e. if the value lies outside the range we
--   report the closest value "in the range". Note that if an endpoint of
--   the range is open we report that value anyway, so we return a value
--   that is truely inside the range only if that side of the range is
--   closed.
--   
--   <pre>
--   &gt;&gt;&gt; clampTo (ClosedRange 0 10) 20
--   10
--   
--   &gt;&gt;&gt; clampTo (ClosedRange 0 10) (-20)
--   0
--   
--   &gt;&gt;&gt; clampTo (ClosedRange 0 10) 5
--   5
--   
--   &gt;&gt;&gt; clampTo (OpenRange 0 10) 20
--   10
--   
--   &gt;&gt;&gt; clampTo (OpenRange 0 10) (-20)
--   0
--   
--   &gt;&gt;&gt; clampTo (OpenRange 0 10) 5
--   5
--   </pre>
clampTo :: Ord r => Range r -> r -> r

-- | Check if the range is valid and nonEmpty, i.e. if the lower endpoint
--   is indeed smaller than the right endpoint. Note that we treat empty
--   open-ranges as invalid as well.
isValid :: Ord a => Range a -> Bool

-- | Wether or not the first range completely covers the second one
covers :: forall a. Ord a => Range a -> Range a -> Bool

-- | Shift a range x units to the left
--   
--   <pre>
--   &gt;&gt;&gt; prettyShow $ shiftLeft 10 (ClosedRange 10 20)
--   "[0,10]"
--   
--   &gt;&gt;&gt; prettyShow $ shiftLeft 10 (OpenRange 15 25)
--   "(5,15)"
--   </pre>
shiftLeft :: Num r => r -> Range r -> Range r

-- | Shifts the range to the right
--   
--   <pre>
--   &gt;&gt;&gt; prettyShow $ shiftRight 10 (ClosedRange 10 20)
--   "[20,30]"
--   
--   &gt;&gt;&gt; prettyShow $ shiftRight 10 (OpenRange 15 25)
--   "(25,35)"
--   </pre>
shiftRight :: Num r => r -> Range r -> Range r
instance GHC.Show.Show a => GHC.Show.Show (Data.Range.Range a)
instance (Test.QuickCheck.Arbitrary.Arbitrary r, GHC.Classes.Ord r) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Range.Range r)
instance GHC.Classes.Ord a => Data.Intersection.IsIntersectableWith (Data.Range.Range a) (Data.Range.Range a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Range.Range a)
instance GHC.Generics.Generic (Data.Range.Range a)
instance Data.Traversable.Traversable Data.Range.Range
instance Data.Foldable.Foldable Data.Range.Range
instance GHC.Base.Functor Data.Range.Range
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Range.Range a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Range.EndPoint a)
instance GHC.Generics.Generic (Data.Range.EndPoint a)
instance Data.Traversable.Traversable Data.Range.EndPoint
instance Data.Foldable.Foldable Data.Range.EndPoint
instance GHC.Base.Functor Data.Range.EndPoint
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Range.EndPoint a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Range.EndPoint a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Range.EndPoint a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Range.EndPoint a)
instance Test.QuickCheck.Arbitrary.Arbitrary r => Test.QuickCheck.Arbitrary.Arbitrary (Data.Range.EndPoint r)


module Data.RealNumber.Rational

-- | Real Numbers represented using Rational numbers. The number type
--   itself is exact in the sense that we can represent any rational
--   number.
--   
--   The parameter, a natural number, represents the precision (in number
--   of decimals behind the period) with which we display the numbers when
--   printing them (using Show).
--   
--   If the number cannot be displayed exactly a '~' is printed after the
--   number.
newtype RealNumber (p :: Nat)
RealNumber :: Rational -> RealNumber (p :: Nat)
data AsFixed p
Exact :: !Fixed p -> AsFixed p
Lossy :: !Fixed p -> AsFixed p
asFixed :: KnownNat p => RealNumber p -> AsFixed (NatPrec p)
toFixed :: KnownNat p => RealNumber p -> Fixed (NatPrec p)
fromFixed :: KnownNat p => Fixed (NatPrec p) -> RealNumber p

-- | (Kind) This is the kind of type-level natural numbers.
data Nat
instance GHC.Classes.Eq (Data.RealNumber.Rational.AsFixed p)
instance Data.Fixed.HasResolution p => GHC.Show.Show (Data.RealNumber.Rational.AsFixed p)
instance Data.Aeson.Types.FromJSON.FromJSON (Data.RealNumber.Rational.RealNumber p)
instance Data.Aeson.Types.ToJSON.ToJSON (Data.RealNumber.Rational.RealNumber p)
instance Data.Hashable.Class.Hashable (Data.RealNumber.Rational.RealNumber p)
instance GHC.Generics.Generic (Data.RealNumber.Rational.RealNumber p)
instance GHC.Real.RealFrac (Data.RealNumber.Rational.RealNumber p)
instance GHC.Real.Real (Data.RealNumber.Rational.RealNumber p)
instance GHC.Real.Fractional (Data.RealNumber.Rational.RealNumber p)
instance GHC.Num.Num (Data.RealNumber.Rational.RealNumber p)
instance GHC.TypeNats.KnownNat p => Data.Data.Data (Data.RealNumber.Rational.RealNumber p)
instance GHC.Classes.Ord (Data.RealNumber.Rational.RealNumber p)
instance GHC.Classes.Eq (Data.RealNumber.Rational.RealNumber p)
instance GHC.TypeNats.KnownNat p => GHC.Show.Show (Data.RealNumber.Rational.RealNumber p)
instance GHC.TypeNats.KnownNat p => Data.Fixed.HasResolution (Data.RealNumber.Rational.NatPrec p)
instance GHC.TypeNats.KnownNat p => GHC.Read.Read (Data.RealNumber.Rational.RealNumber p)
instance GHC.TypeNats.KnownNat p => Test.QuickCheck.Arbitrary.Arbitrary (Data.RealNumber.Rational.RealNumber p)
instance System.Random.Random (Data.RealNumber.Rational.RealNumber p)


module Data.Sequence.Util

-- | Partition the seq s given a monotone predicate p into (xs,ys) such
--   that
--   
--   all elements in xs do *not* satisfy the predicate p all elements in ys
--   do satisfy the predicate p
--   
--   all elements in s occur in either xs or ys.
--   
--   running time: &lt;math&gt;, where &lt;math&gt; is the time to execute
--   the predicate.
splitMonotone :: (a -> Bool) -> Seq a -> (Seq a, Seq a)


module Data.Set.Util

-- | Given a monotonic function f that maps a to b, split the sequence s
--   depending on the b values. I.e. the result (l,m,r) is such that * all
--   (&lt; x) . fmap f $ l * all (== x) . fmap f $ m * all (&gt; x) . fmap
--   f $ r
--   
--   running time: &lt;math&gt;
splitOn :: Ord b => (a -> b) -> b -> Set a -> (Set a, Set a, Set a)

-- | Constructs a Set using the given Order.
--   
--   Note that this is dangerous as the resulting set may not abide the
--   ordering expected of such sets.
--   
--   running time: &lt;math&gt;
fromListBy :: (a -> a -> Ordering) -> [a] -> Set a

-- | Given two sets l and r, such that all elements of l occur before r,
--   join the two sets into a combined set.
--   
--   running time: &lt;math&gt;
join :: Set a -> Set a -> Set a

-- | Inserts an element into the set, assuming that the set is ordered by
--   the given order.
--   
--   <pre>
--   &gt;&gt;&gt; insertBy cmpS (S "ccc") $ fromListBy cmpS [S "a" , S "bb" , S "dddd"]
--   fromList [S "a",S "bb",S "ccc",S "dddd"]
--   </pre>
--   
--   When trying to insert an element that equals an element already in the
--   set (according to the given comparator), this function replaces the
--   old element by the new one:
--   
--   <pre>
--   &gt;&gt;&gt; insertBy cmpS (S "cc") $ fromListBy cmpS [S "a" , S "bb" , S "dddd"]
--   fromList [S "a",S "cc",S "dddd"]
--   </pre>
--   
--   running time: &lt;math&gt;
insertBy :: (a -> a -> Ordering) -> a -> Set a -> Set a

-- | Deletes an element from the set, assuming the set is ordered by the
--   given ordering.
--   
--   <pre>
--   &gt;&gt;&gt; deleteAllBy cmpS (S "bb") $ fromListBy cmpS [S "a" , S "bb" , S "dddd"]
--   fromList [S "a",S "dddd"]
--   
--   &gt;&gt;&gt; deleteAllBy cmpS (S "bb") $ fromListBy cmpS [S "a" , S "bb" , S "cc", S "dd", S "ee", S "ff", S "dddd"]
--   fromList [S "a",S "dddd"]
--   </pre>
--   
--   running time: &lt;math&gt;
deleteAllBy :: (a -> a -> Ordering) -> a -> Set a -> Set a


-- | Tree-related utilities.
module Data.Tree.Util

-- | Nodes in a tree are typically either an internal node or a leaf node
data TreeNode v a
InternalNode :: v -> TreeNode v a
LeafNode :: a -> TreeNode v a

-- | A TreeNode is isomorphic to Either
_TreeNodeEither :: Iso' (TreeNode v p) (Either v p)

-- | Zipper for rose trees
data Zipper a
Zipper :: Tree a -> [([Tree a], a, [Tree a])] -> Zipper a
[focus] :: Zipper a -> Tree a
[ancestors] :: Zipper a -> [([Tree a], a, [Tree a])]

-- | Create a new zipper focussiong on the root.
root :: Tree a -> Zipper a

-- | Move the focus to the parent of this node.
up :: Zipper a -> Maybe (Zipper a)

-- | Move the focus to the first child of this node.
--   
--   <pre>
--   &gt;&gt;&gt; firstChild $ root myTree
--   Just (Zipper {focus = Node {rootLabel = 1, subForest = []}, ancestors = [([],0,[Node {rootLabel = 2, subForest = []},Node {rootLabel = 3, subForest = [Node {rootLabel = 4, subForest = []}]}])]})
--   </pre>
firstChild :: Zipper a -> Maybe (Zipper a)

-- | Move the focus to the next sibling of this node
--   
--   <pre>
--   &gt;&gt;&gt; (firstChild $ root myTree) &gt;&gt;= nextSibling
--   Just (Zipper {focus = Node {rootLabel = 2, subForest = []}, ancestors = [([Node {rootLabel = 1, subForest = []}],0,[Node {rootLabel = 3, subForest = [Node {rootLabel = 4, subForest = []}]}])]})
--   </pre>
nextSibling :: Zipper a -> Maybe (Zipper a)

-- | Move the focus to the next sibling of this node
prevSibling :: Zipper a -> Maybe (Zipper a)

-- | Given a zipper that focussses on some subtree t, construct a list with
--   zippers that focus on each child.
allChildren :: Zipper a -> [Zipper a]

-- | Given a zipper that focussses on some subtree t, construct a list with
--   zippers that focus on each of the nodes in the subtree of t.
allTrees :: Zipper a -> [Zipper a]

-- | Creates a new tree from the zipper that thas the current node as root.
--   The ancestorTree (if there is any) forms the first child in this new
--   root.
unZipperLocal :: Zipper a -> Tree a

-- | Constructs a tree from the list of ancestors (if there are any)
constructTree :: [([Tree a], a, [Tree a])] -> Maybe (Tree a)

-- | Given a predicate on an element, find a node that matches the
--   predicate, and turn that node into the root of the tree.
--   
--   running time: &lt;math&gt; where &lt;math&gt; is the size of the tree,
--   and &lt;math&gt; is the time to evaluate a predicate.
--   
--   <pre>
--   &gt;&gt;&gt; findEvert (== 4) myTree
--   Just (Node {rootLabel = 4, subForest = [Node {rootLabel = 3, subForest = [Node {rootLabel = 0, subForest = [Node {rootLabel = 1, subForest = []},Node {rootLabel = 2, subForest = []}]}]}]})
--   
--   &gt;&gt;&gt; findEvert (== 5) myTree
--   Nothing
--   </pre>
findEvert :: (a -> Bool) -> Tree a -> Maybe (Tree a)

-- | Given a predicate matching on a subtree, find a node that matches the
--   predicate, and turn that node into the root of the tree.
--   
--   running time: &lt;math&gt; where &lt;math&gt; is the size of the tree,
--   and &lt;math&gt; is the time to evaluate a predicate on a subtree of
--   size &lt;math&gt;.
findEvert' :: (Tree a -> Bool) -> Tree a -> Maybe (Tree a)

-- | Function to extract a path between a start node and an end node (if
--   such a path exists). If there are multiple paths, no guarantees are
--   given about which one is returned.
--   
--   running time: &lt;math&gt;, where &lt;math&gt; is the size of the
--   tree, and &lt;math&gt; and &lt;math&gt; are the times it takes to
--   evaluate the <tt>isStartingNode</tt> and <tt>isEndingNode</tt>
--   predicates.
--   
--   <pre>
--   &gt;&gt;&gt; findPath (== 1) (==4) myTree
--   Just [1,0,3,4]
--   
--   &gt;&gt;&gt; findPath (== 1) (==2) myTree
--   Just [1,0,2]
--   
--   &gt;&gt;&gt; findPath (== 1) (==1) myTree
--   Just [1]
--   
--   &gt;&gt;&gt; findPath (== 1) (==2) myTree
--   Just [1,0,2]
--   
--   &gt;&gt;&gt; findPath (== 4) (==2) myTree
--   Just [4,3,0,2]
--   </pre>
findPath :: (a -> Bool) -> (a -> Bool) -> Tree a -> Maybe [a]

-- | Given a predicate on a, find (the path to) a node that satisfies the
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; findNode (== 4) myTree
--   Just [0,3,4]
--   </pre>
findNode :: (a -> Bool) -> Tree a -> Maybe [a]

-- | Find all paths to nodes that satisfy the predicate
--   
--   running time: &lt;math&gt; where &lt;math&gt; is the size of the tree,
--   and &lt;math&gt; is the time to evaluate a predicate on a subtree of
--   size &lt;math&gt;.
--   
--   <pre>
--   &gt;&gt;&gt; findNodes ((&lt; 4) . rootLabel) myTree
--   [[0],[0,1],[0,2],[0,3]]
--   
--   &gt;&gt;&gt; findNodes (even . rootLabel) myTree
--   [[0],[0,2],[0,3,4]]
--   
--   &gt;&gt;&gt; let size = length in findNodes ((&gt; 1) . size) myTree
--   [[0],[0,3]]
--   </pre>
findNodes :: (Tree a -> Bool) -> Tree a -> [[a]]

-- | BFS Traversal of the rose tree that decomposes it into levels.
--   
--   running time: &lt;math&gt;
levels :: Tree a -> NonEmpty (NonEmpty a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Tree.Util.Zipper a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Tree.Util.Zipper a)
instance (GHC.Classes.Eq v, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Tree.Util.TreeNode v a)
instance (GHC.Show.Show v, GHC.Show.Show a) => GHC.Show.Show (Data.Tree.Util.TreeNode v a)
instance Data.Bifunctor.Bifunctor Data.Tree.Util.TreeNode
instance Data.Bifoldable.Bifoldable Data.Tree.Util.TreeNode
instance Data.Bitraversable.Bitraversable Data.Tree.Util.TreeNode


-- | Several types of Binary trees.
module Data.BinaryTree

-- | Binary tree that stores its values (of type a) in the leaves. Internal
--   nodes store something of type v.
data BinLeafTree v a
Leaf :: !a -> BinLeafTree v a
Node :: BinLeafTree v a -> !v -> BinLeafTree v a -> BinLeafTree v a

-- | smart constructor
node :: Measured v a => BinLeafTree v a -> BinLeafTree v a -> BinLeafTree v a

-- | Create a balanced tree, i.e. a tree of height &lt;math&gt; with the
--   elements in the leaves.
--   
--   &lt;math&gt; time.
asBalancedBinLeafTree :: NonEmpty a -> BinLeafTree Size (Elem a)

-- | Given a function to combine internal nodes into b's and leafs into
--   b's, traverse the tree bottom up, and combine everything into one b.
foldUp :: (b -> v -> b -> b) -> (a -> b) -> BinLeafTree v a -> b

-- | Traverses the tree bottom up, recomputing the assocated values.
foldUpData :: (w -> v -> w -> w) -> (a -> w) -> BinLeafTree v a -> BinLeafTree w a

-- | Takes two trees, that have the same structure, and uses the provided
--   functions to "zip" them together
zipExactWith :: (u -> v -> w) -> (a -> b -> c) -> BinLeafTree u a -> BinLeafTree v b -> BinLeafTree w c
toRoseTree :: BinLeafTree v a -> Tree (TreeNode v a)
drawTree :: (Show v, Show a) => BinLeafTree v a -> String

-- | Binary tree in which we store the values of type a in internal nodes.
data BinaryTree a
Nil :: BinaryTree a
Internal :: BinaryTree a -> !a -> BinaryTree a -> BinaryTree a

-- | Get the element stored at the root, if it exists
access :: BinaryTree a -> Maybe a

-- | Create a balanced binary tree.
--   
--   running time: &lt;math&gt;
asBalancedBinTree :: [a] -> BinaryTree a

-- | Fold function for folding over a binary tree.
foldBinaryUp :: b -> (a -> b -> b -> b) -> BinaryTree a -> BinaryTree (a, b)

-- | Convert a <tt>BinaryTree</tt> into a RoseTree
toRoseTree' :: BinaryTree a -> Maybe (Tree a)

-- | Draw a binary tree.
drawTree' :: Show a => BinaryTree a -> String
instance GHC.Generics.Generic (Data.BinaryTree.BinaryTree a)
instance Data.Traversable.Traversable Data.BinaryTree.BinaryTree
instance Data.Foldable.Foldable Data.BinaryTree.BinaryTree
instance GHC.Base.Functor Data.BinaryTree.BinaryTree
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.BinaryTree.BinaryTree a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.BinaryTree.BinaryTree a)
instance GHC.Read.Read a => GHC.Read.Read (Data.BinaryTree.BinaryTree a)
instance GHC.Show.Show a => GHC.Show.Show (Data.BinaryTree.BinaryTree a)
instance GHC.Generics.Generic (Data.BinaryTree.BinLeafTree v a)
instance GHC.Base.Functor (Data.BinaryTree.BinLeafTree v)
instance (GHC.Classes.Ord a, GHC.Classes.Ord v) => GHC.Classes.Ord (Data.BinaryTree.BinLeafTree v a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq v) => GHC.Classes.Eq (Data.BinaryTree.BinLeafTree v a)
instance (GHC.Read.Read a, GHC.Read.Read v) => GHC.Read.Read (Data.BinaryTree.BinLeafTree v a)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Data.BinaryTree.BinLeafTree v a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.BinaryTree.BinaryTree a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.BinaryTree.BinaryTree a)
instance (Control.DeepSeq.NFData v, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Data.BinaryTree.BinLeafTree v a)
instance Data.Bifunctor.Bifunctor Data.BinaryTree.BinLeafTree
instance Data.Measured.Class.Measured v a => Data.Measured.Class.Measured v (Data.BinaryTree.BinLeafTree v a)
instance Data.Foldable.Foldable (Data.BinaryTree.BinLeafTree v)
instance Data.Semigroup.Foldable.Class.Foldable1 (Data.BinaryTree.BinLeafTree v)
instance Data.Traversable.Traversable (Data.BinaryTree.BinLeafTree v)
instance Data.Measured.Class.Measured v a => GHC.Base.Semigroup (Data.BinaryTree.BinLeafTree v a)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, Test.QuickCheck.Arbitrary.Arbitrary v) => Test.QuickCheck.Arbitrary.Arbitrary (Data.BinaryTree.BinLeafTree v a)


module Data.BinaryTree.Zipper
data Ctx a
Top :: Ctx a
L :: Ctx a -> a -> BinaryTree a -> Ctx a
R :: BinaryTree a -> a -> Ctx a -> Ctx a
data BinaryTreeZipper a
Loc :: BinaryTree a -> Ctx a -> BinaryTreeZipper a

-- | Focus on the root
top :: BinaryTree a -> BinaryTreeZipper a

-- | Go to the left child
left :: BinaryTreeZipper a -> Maybe (BinaryTreeZipper a)

-- | Go to the right child
right :: BinaryTreeZipper a -> Maybe (BinaryTreeZipper a)

-- | Move to the parent
up :: BinaryTreeZipper a -> Maybe (BinaryTreeZipper a)

-- | Navigate to the root
toRoot :: BinaryTreeZipper a -> BinaryTreeZipper a

-- | Returns a list of zippers; one focussed on each node in the tree
visitAll :: BinaryTree a -> [BinaryTreeZipper a]

-- | Get the value stored at the current node
accessZ :: BinaryTreeZipper a -> Maybe a

-- | Returns all subtrees; i.e. every node with all its decendents
subTrees :: BinaryTree a -> [BinaryTree a]

-- | Splits the tree here, returns a pair (innerTree,outerTree)
splitTree :: BinaryTreeZipper a -> (BinaryTree a, BinaryTree a)
instance Data.Traversable.Traversable Data.BinaryTree.Zipper.BinaryTreeZipper
instance Data.Foldable.Foldable Data.BinaryTree.Zipper.BinaryTreeZipper
instance GHC.Base.Functor Data.BinaryTree.Zipper.BinaryTreeZipper
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.BinaryTree.Zipper.BinaryTreeZipper a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.BinaryTree.Zipper.BinaryTreeZipper a)
instance GHC.Read.Read a => GHC.Read.Read (Data.BinaryTree.Zipper.BinaryTreeZipper a)
instance GHC.Show.Show a => GHC.Show.Show (Data.BinaryTree.Zipper.BinaryTreeZipper a)
instance Data.Traversable.Traversable Data.BinaryTree.Zipper.Ctx
instance Data.Foldable.Foldable Data.BinaryTree.Zipper.Ctx
instance GHC.Base.Functor Data.BinaryTree.Zipper.Ctx
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.BinaryTree.Zipper.Ctx a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.BinaryTree.Zipper.Ctx a)
instance GHC.Read.Read a => GHC.Read.Read (Data.BinaryTree.Zipper.Ctx a)
instance GHC.Show.Show a => GHC.Show.Show (Data.BinaryTree.Zipper.Ctx a)


-- | Add an unbounded/infintity element to a data type. Essentially,
--   <a>Bottom</a> adds &lt;math&gt; (and is pretty much identical to
--   Maybe), whereas <a>Top</a> adds &lt;math&gt;. The Unbounded type adds
--   both.
module Data.UnBounded

-- | `Top a` represents the type a, together with a <a>Top</a> element,
--   i.e. an element that is greater than any other element. We can think
--   of `Top a` being defined as:
--   
--   <pre>
--   &gt;&gt;&gt; data Top a = ValT a | Top
--   </pre>
data Top a
topToMaybe :: Top a -> Maybe a
pattern ValT :: a -> Top a
pattern Top :: Top a
_ValT :: Prism (Top a) (Top b) a b
_Top :: Prism' (Top a) ()

-- | Iso between a 'Top a' and a 'Maybe a', interpreting a Top as a Nothing
--   and vice versa. Note that this reverses the ordering of the elements.
--   
--   <pre>
--   &gt;&gt;&gt; ValT 5 ^. _TopMaybe
--   Just 5
--   
--   &gt;&gt;&gt; Just 5 ^.re _TopMaybe
--   ValT 5
--   
--   &gt;&gt;&gt; Top ^. _TopMaybe
--   Nothing
--   
--   &gt;&gt;&gt; Nothing ^.re _TopMaybe
--   Top
--   </pre>
_TopMaybe :: Iso' (Top a) (Maybe a)

-- | `Bottom a` represents the type a, together with a <a>Bottom</a>
--   element, i.e. an element that is smaller than any other element. We
--   can think of `Bottom a` being defined as:
--   
--   <pre>
--   &gt;&gt;&gt; data Bottom a = Bottom | ValB a
--   </pre>
data Bottom a
bottomToMaybe :: Bottom a -> Maybe a
pattern Bottom :: Bottom a
pattern ValB :: a -> Bottom a
_ValB :: Prism (Bottom a) (Bottom b) a b
_Bottom :: Prism' (Bottom a) ()

-- | Iso between a 'Bottom a' and a 'Maybe a', interpreting a Bottom as a
--   Nothing and vice versa.
--   
--   <pre>
--   &gt;&gt;&gt; ValB 5 ^. _BottomMaybe
--   Just 5
--   
--   &gt;&gt;&gt; Just 5 ^.re _BottomMaybe
--   ValB 5
--   
--   &gt;&gt;&gt; Bottom ^. _BottomMaybe
--   Nothing
--   
--   &gt;&gt;&gt; Nothing ^.re _BottomMaybe
--   Bottom
--   </pre>
_BottomMaybe :: Iso' (Bottom a) (Maybe a)

-- | `UnBounded a` represents the type a, together with an element
--   <a>MaxInfinity</a> larger than any other element, and an element
--   <a>MinInfinity</a>, smaller than any other element.
data UnBounded a
MinInfinity :: UnBounded a
Val :: a -> UnBounded a
[_unUnBounded] :: UnBounded a -> a
MaxInfinity :: UnBounded a
unUnBounded :: forall a_aZRV a_a11vj. Traversal (UnBounded a_aZRV) (UnBounded a_a11vj) a_aZRV a_a11vj
_MinInfinity :: forall a_aZRV. Prism' (UnBounded a_aZRV) ()
_Val :: forall a_aZRV a_a11yc. Prism (UnBounded a_a11yc) (UnBounded a_aZRV) a_a11yc a_aZRV
_MaxInfinity :: forall a_aZRV. Prism' (UnBounded a_aZRV) ()

-- | Test if an Unbounded is actually bounded.
--   
--   <pre>
--   &gt;&gt;&gt; unBoundedToMaybe (Val 5)
--   Just 5
--   
--   &gt;&gt;&gt; unBoundedToMaybe MinInfinity
--   Nothing
--   
--   &gt;&gt;&gt; unBoundedToMaybe MaxInfinity
--   Nothing
--   </pre>
unBoundedToMaybe :: UnBounded a -> Maybe a
instance GHC.Show.Show a => GHC.Show.Show (Data.UnBounded.UnBounded a)
instance GHC.Num.Num a => GHC.Num.Num (Data.UnBounded.UnBounded a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.UnBounded.UnBounded a)
instance Data.Traversable.Traversable Data.UnBounded.UnBounded
instance Data.Foldable.Foldable Data.UnBounded.UnBounded
instance GHC.Base.Functor Data.UnBounded.UnBounded
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.UnBounded.UnBounded a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.UnBounded.UnBounded a)
instance Data.Functor.Classes.Ord1 Data.UnBounded.Bottom
instance Data.Functor.Classes.Eq1 Data.UnBounded.Bottom
instance GHC.Base.Monad Data.UnBounded.Bottom
instance GHC.Base.Applicative Data.UnBounded.Bottom
instance Data.Traversable.Traversable Data.UnBounded.Bottom
instance Data.Foldable.Foldable Data.UnBounded.Bottom
instance GHC.Base.Functor Data.UnBounded.Bottom
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.UnBounded.Bottom a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.UnBounded.Bottom a)
instance Data.Functor.Classes.Eq1 Data.UnBounded.Top
instance GHC.Base.Monad Data.UnBounded.Top
instance GHC.Base.Applicative Data.UnBounded.Top
instance Data.Traversable.Traversable Data.UnBounded.Top
instance Data.Foldable.Foldable Data.UnBounded.Top
instance GHC.Base.Functor Data.UnBounded.Top
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.UnBounded.Top a)
instance GHC.Show.Show a => GHC.Show.Show (Data.UnBounded.Bottom a)
instance Data.Functor.Classes.Ord1 Data.UnBounded.Top
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.UnBounded.Top a)
instance GHC.Show.Show a => GHC.Show.Show (Data.UnBounded.Top a)


-- | Some basic types, mostly strict triples and pairs.
module Data.Util

-- | strict triple
data STR a b c
STR :: !a -> !b -> !c -> STR a b c

-- | Strict Triple with all items the same
type Three = V3
pattern Three :: a -> a -> a -> Three a

-- | Generate All unique unordered triplets.
uniqueTriplets :: [a] -> [Three a]

-- | Strict pair
data SP a b
SP :: !a -> !b -> SP a b

-- | <ul>
--   <li>Strict pair whose elements are of the same type.</li>
--   </ul>
--   
--   Strict pair with both items the same
type Two = V2
pattern Two :: a -> a -> Two a

-- | Given a list xs, generate all unique (unordered) pairs.
uniquePairs :: [a] -> [Two a]

-- | A version of List.tails in which we remove the emptylist
nonEmptyTails :: [a] -> [[a]]
instance GHC.Generics.Generic (Data.Util.SP a b)
instance GHC.Base.Functor (Data.Util.SP a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (Data.Util.SP a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Data.Util.SP a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.Util.SP a b)
instance GHC.Generics.Generic (Data.Util.STR a b c)
instance GHC.Base.Functor (Data.Util.STR a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c) => GHC.Classes.Ord (Data.Util.STR a b c)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) => GHC.Classes.Eq (Data.Util.STR a b c)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c) => GHC.Show.Show (Data.Util.STR a b c)
instance (GHC.Base.Semigroup a, GHC.Base.Semigroup b) => GHC.Base.Semigroup (Data.Util.SP a b)
instance (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Monoid a, GHC.Base.Monoid b) => GHC.Base.Monoid (Data.Util.SP a b)
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b) => Control.DeepSeq.NFData (Data.Util.SP a b)
instance Control.Lens.Tuple.Field1 (Data.Util.SP a b) (Data.Util.SP c b) a c
instance Control.Lens.Tuple.Field2 (Data.Util.SP a b) (Data.Util.SP a c) b c
instance Data.Bifunctor.Bifunctor Data.Util.SP
instance (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c) => GHC.Base.Semigroup (Data.Util.STR a b c)
instance (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c, GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) => GHC.Base.Monoid (Data.Util.STR a b c)
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b, Control.DeepSeq.NFData c) => Control.DeepSeq.NFData (Data.Util.STR a b c)
instance Control.Lens.Tuple.Field1 (Data.Util.STR a b c) (Data.Util.STR d b c) a d
instance Control.Lens.Tuple.Field2 (Data.Util.STR a b c) (Data.Util.STR a d c) b d
instance Control.Lens.Tuple.Field3 (Data.Util.STR a b c) (Data.Util.STR a b d) c d


module Data.IndexedDoublyLinkedList.Bare

-- | Doubly linked list implemented by a mutable vector. So actually this
--   data type can represent a collection of Linked Lists that can
--   efficiently be concatenated and split.
--   
--   Supports O(1) indexing, and O(1) insertions, deletions
newtype IDLList s
IDLList :: MVector s Cell -> IDLList s
[llist] :: IDLList s -> MVector s Cell

-- | Cells in the Linked List
data Cell
Cell :: !Maybe Index -> !Maybe Index -> Cell
[prev] :: Cell -> !Maybe Index
[next] :: Cell -> !Maybe Index
emptyCell :: Cell

-- | Monad in which we can use the IndexedDoublyLinkedList.
data IDLListMonad s a

-- | Runs a DLList Computation, starting with n singleton values
runIDLListMonad :: Int -> (forall s. IDLListMonad s a) -> a
type Index = Int

-- | Constructs a new DoublyLinkedList, of size at most n
singletons :: (PrimMonad m, s ~ PrimState m) => Int -> m (IDLList s)

-- | Sets the DoublyLinkedList to the given List.
--   
--   Indices that do not occur in the list are not touched.
writeList :: NonEmpty Index -> IDLListMonad s ()

-- | Next element in the List
getNext :: Index -> IDLListMonad s (Maybe Index)

-- | Previous Element in the List
getPrev :: Index -> IDLListMonad s (Maybe Index)

-- | Computes a maximal length list starting from the Given index
--   
--   running time: &lt;math&gt;, where &lt;math&gt; is the length of the
--   output list
toListFrom :: Index -> IDLListMonad s (NonEmpty Index)

-- | Computes a maximal length list by walking backwards in the
--   DoublyLinkedList, starting from the Given index
--   
--   running time: &lt;math&gt;, where &lt;math&gt; is the length of the
--   output list
toListFromR :: Index -> IDLListMonad s (NonEmpty Index)

-- | Computes a maximal length list that contains the element i.
--   
--   running time: &lt;math&gt;, where &lt;math&gt; is the length of the
--   output list
toListContains :: Index -> IDLListMonad s (NonEmpty Index)

-- | Takes the current element and its k next's
toListFromK :: Index -> Int -> IDLListMonad s (NonEmpty Index)
toListFromRK :: Index -> Int -> IDLListMonad s (NonEmpty Index)

-- | Inserts the second argument after the first one into the linked list
insertAfter :: Index -> Index -> IDLListMonad s ()

-- | Inserts the second argument before the first one into the linked list
insertBefore :: Index -> Index -> IDLListMonad s ()

-- | Deletes the element from the linked list. This element thus
--   essentially becomes a singleton list.
delete :: Index -> IDLListMonad s ()

-- | For debugging purposes, dump the values and the cells
dump :: IDLListMonad s (Vector Cell)
instance GHC.Base.Monad (Data.IndexedDoublyLinkedList.Bare.IDLListMonad s)
instance GHC.Base.Applicative (Data.IndexedDoublyLinkedList.Bare.IDLListMonad s)
instance GHC.Base.Functor (Data.IndexedDoublyLinkedList.Bare.IDLListMonad s)
instance GHC.Classes.Eq Data.IndexedDoublyLinkedList.Bare.Cell
instance GHC.Show.Show Data.IndexedDoublyLinkedList.Bare.Cell
instance Control.Monad.Primitive.PrimMonad (Data.IndexedDoublyLinkedList.Bare.IDLListMonad s)
instance Control.Monad.Reader.Class.MonadReader (Data.IndexedDoublyLinkedList.Bare.IDLList s) (Data.IndexedDoublyLinkedList.Bare.IDLListMonad s)


module Data.IndexedDoublyLinkedList

-- | Doubly linked list implemented by a mutable vector. So actually this
--   data type can represent a collection of Linked Lists that can
--   efficiently be concatenated and split.
--   
--   Supports O(1) indexing, and O(1) insertions, deletions
data DLList s a
DLList :: !Vector a -> !MVector s Cell -> DLList s a
[values] :: DLList s a -> !Vector a
[llist] :: DLList s a -> !MVector s Cell

-- | Cells in the Linked List
data Cell
Cell :: Maybe Index -> Maybe Index -> Cell
[prev] :: Cell -> Maybe Index
[next] :: Cell -> Maybe Index
emptyCell :: Cell

-- | Monad in which we can use the IndexedDoublyLinkedList.
data DLListMonad s b a

-- | Runs a DLList Computation, starting with singleton values, crated from
--   the input vector.
runDLListMonad :: Vector b -> (forall s. DLListMonad s b a) -> a
type Index = Int

-- | Constructs a new DoublyLinkedList. Every element is its own singleton
--   list
singletons :: (PrimMonad m, s ~ PrimState m) => Vector b -> m (DLList s b)

-- | Sets the DoublyLinkedList to the given List.
--   
--   Indices that do not occur in the list are not touched.
writeList :: NonEmpty Index -> DLListMonad s b ()

-- | Gets the value at Index i
valueAt :: Index -> DLListMonad s b b

-- | Next element in the List
getNext :: Index -> DLListMonad s b (Maybe Index)

-- | Previous Element in the List
getPrev :: Index -> DLListMonad s b (Maybe Index)

-- | Computes a maximal length list starting from the Given index
--   
--   running time: &lt;math&gt;, where &lt;math&gt; is the length of the
--   output list
toListFrom :: Index -> DLListMonad s b (NonEmpty Index)

-- | Computes a maximal length list by walking backwards in the
--   DoublyLinkedList, starting from the Given index
--   
--   running time: &lt;math&gt;, where &lt;math&gt; is the length of the
--   output list
toListFromR :: Index -> DLListMonad s b (NonEmpty Index)

-- | Computes a maximal length list that contains the element i.
--   
--   running time: &lt;math&gt;, where &lt;math&gt; is the length of the
--   output list
toListContains :: Index -> DLListMonad s b (NonEmpty Index)

-- | Takes the current element and its k next's
toListFromK :: Index -> Int -> DLListMonad s b (NonEmpty Index)
toListFromRK :: Index -> Int -> DLListMonad s b (NonEmpty Index)

-- | Inserts the second argument after the first one into the linked list
insertAfter :: Index -> Index -> DLListMonad s b ()

-- | Inserts the second argument before the first one into the linked list
insertBefore :: Index -> Index -> DLListMonad s b ()

-- | Deletes the element from the linked list. This element thus
--   essentially becomes a singleton list. Returns the pair of indices that
--   now have become neighbours (i.e. the predecessor and successor of j
--   just before we deleted j).
delete :: Index -> DLListMonad s b (Maybe Index, Maybe Index)

-- | For debugging purposes, dump the values and the cells
dump :: DLListMonad s a (Vector a, Vector Cell)
instance GHC.Base.Monad (Data.IndexedDoublyLinkedList.DLListMonad s b)
instance GHC.Base.Applicative (Data.IndexedDoublyLinkedList.DLListMonad s b)
instance GHC.Base.Functor (Data.IndexedDoublyLinkedList.DLListMonad s b)
instance GHC.Classes.Eq Data.IndexedDoublyLinkedList.Cell
instance GHC.Show.Show Data.IndexedDoublyLinkedList.Cell
instance Control.Monad.Primitive.PrimMonad (Data.IndexedDoublyLinkedList.DLListMonad s b)
instance Control.Monad.Reader.Class.MonadReader (Data.IndexedDoublyLinkedList.DLList s b) (Data.IndexedDoublyLinkedList.DLListMonad s b)
instance GHC.Base.Functor (Data.IndexedDoublyLinkedList.DLList s)

module Data.Vector.Circular.Util

-- | Access the ith item in the CircularVector (w.r.t the rotation) as a
--   lens
item :: Int -> Lens' (CircularVector a) a

-- | All elements, starting with the focus, going to the right
--   
--   <pre>
--   &gt;&gt;&gt; rightElements $ unsafeFromList [3,4,5,1,2]
--   [3,4,5,1,2]
--   </pre>
rightElements :: CircularVector a -> NonEmptyVector a

-- | All elements, starting with the focus, going to the left
--   
--   <pre>
--   &gt;&gt;&gt; leftElements $ unsafeFromList [3,4,5,1,2]
--   [3,2,1,5,4]
--   </pre>
leftElements :: CircularVector a -> NonEmptyVector a

-- | Finds an element in the CircularVector
--   
--   <pre>
--   &gt;&gt;&gt; findRotateTo (== 3) $ unsafeFromList [1..5]
--   Just (CircularVector {vector = [1,2,3,4,5], rotation = 2})
--   
--   &gt;&gt;&gt; findRotateTo (== 7) $ unsafeFromList [1..5]
--   Nothing
--   </pre>
findRotateTo :: (a -> Bool) -> CircularVector a -> Maybe (CircularVector a)

-- | Test if the circular list is a cyclic shift of the second list.
--   
--   Running time: &lt;math&gt;, where &lt;math&gt; and &lt;math&gt; are
--   the sizes of the lists.
isShiftOf :: Eq a => CircularVector a -> CircularVector a -> Bool

-- | label the circular vector with indices, starting from zero at the
--   current focus, going right.
--   
--   Running time: &lt;math&gt;
withIndicesRight :: CircularVector a -> CircularVector (Int :+ a)
instance Data.Semigroup.Foldable.Class.Foldable1 Data.Vector.NonEmpty.Internal.NonEmptyVector
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.Vector.Circular.CircularVector a)


module Data.Yaml.Util

-- | Write the output to yaml
encodeYaml :: ToJSON a => a -> ByteString

-- | Encode a yaml file
encodeYamlFile :: ToJSON a => FilePath -> a -> IO ()

-- | alias for decodeEither' from the Yaml Package
decodeYaml :: FromJSON a => ByteString -> Either ParseException a

-- | alias for reading a yaml file
decodeYamlFile :: FromJSON a => FilePath -> IO (Either ParseException a)

-- | Prints the yaml
printYaml :: ToJSON a => a -> IO ()

-- | Given a list of candidate parsers, select the right one
parseVersioned :: [(Version -> Bool, Value -> Parser a)] -> Value -> Parser (Versioned a)

-- | Data type for things that have a version
data Versioned a
Versioned :: Version -> a -> Versioned a
unversioned :: Versioned a -> a
instance Data.Traversable.Traversable Data.Yaml.Util.Versioned
instance Data.Foldable.Foldable Data.Yaml.Util.Versioned
instance GHC.Base.Functor Data.Yaml.Util.Versioned
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Yaml.Util.Versioned a)
instance GHC.Generics.Generic (Data.Yaml.Util.Versioned a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Yaml.Util.Versioned a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Yaml.Util.Versioned a)
instance Data.Aeson.Types.FromJSON.FromJSON Data.Yaml.Util.V
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Data.Yaml.Util.Versioned a)


-- | Implements Fishyer-Yates shuffle.
module System.Random.Shuffle

-- | Fisher–Yates shuffle, which shuffles a list/foldable uniformly at
--   random.
--   
--   running time: &lt;math&gt;.
shuffle :: (Foldable f, MonadRandom m) => f a -> m (Vector a)
