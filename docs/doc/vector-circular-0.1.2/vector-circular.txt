-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | circular vectors
--   
--   nonempty circular vector data structure library. indexing always total
@package vector-circular
@version 0.1.2

module Data.Vector.Circular

-- | A circular, immutable vector. This type is equivalent to
--   <tt><a>cycle</a> xs</tt> for some finite, nonempty <tt>xs</tt>, but
--   with <i>O(1)</i> access and <i>O(1)</i> rotations. Indexing into this
--   type is always total.
data CircularVector a
CircularVector :: {-# UNPACK #-} !NonEmptyVector a -> {-# UNPACK #-} !Int -> CircularVector a
[vector] :: CircularVector a -> {-# UNPACK #-} !NonEmptyVector a
[rotation] :: CircularVector a -> {-# UNPACK #-} !Int

-- | <i>O(1)</i> Construct a singleton 'CircularVector.
singleton :: a -> CircularVector a

-- | <i>O(n)</i> Circular vector of the given length with the same value in
--   each position.
--   
--   When given a index n &lt;= 0, then <a>Nothing</a> is returned,
--   otherwise <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; replicate 3 "a"
--   Just (CircularVector {vector = ["a","a","a"], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate 0 "a"
--   Nothing
--   </pre>
replicate :: Int -> a -> Maybe (CircularVector a)

-- | <i>O(n)</i> Circular vector of the given length with the same value in
--   each position.
--   
--   This variant takes <tt>max n 1</tt> for the supplied length parameter.
--   
--   <pre>
--   &gt;&gt;&gt; replicate1 3 "a"
--   CircularVector {vector = ["a","a","a"], rotation = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate1 0 "a"
--   CircularVector {vector = ["a"], rotation = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate1 (-1) "a"
--   CircularVector {vector = ["a"], rotation = 0}
--   </pre>
replicate1 :: Int -> a -> CircularVector a

-- | <i>O(n)</i> Construct a circular vector of the given length by
--   applying the function to each index.
--   
--   When given a index n &lt;= 0, then <a>Nothing</a> is returned,
--   otherwise <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let f 0 = "a"; f _ = "k"; f :: Int -&gt; String
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate 1 f
--   Just (CircularVector {vector = ["a"], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate 0 f
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate 2 f
--   Just (CircularVector {vector = ["a","k"], rotation = 0})
--   </pre>
generate :: Int -> (Int -> a) -> Maybe (CircularVector a)

-- | <i>O(n)</i> Construct a circular vector of the given length by
--   applying the function to each index.
--   
--   This variant takes <tt>max n 1</tt> for the supplied length parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let f 0 = "a"; f _ = "k"; f :: Int -&gt; String
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList $ generate1 2 f
--   ["a","k"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList $ generate1 0 f
--   ["a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList $ generate1 (-1) f
--   ["a"]
--   </pre>
generate1 :: Int -> (Int -> a) -> CircularVector a

-- | <i>O(n)</i> Apply function n times to value. Zeroth element is
--   original value.
--   
--   When given a index n &lt;= 0, then <a>Nothing</a> is returned,
--   otherwise <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; iterateN 3 (+1) 0
--   Just (CircularVector {vector = [0,1,2], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateN 0 (+1) 0
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateN (-1) (+1) 0
--   Nothing
--   </pre>
iterateN :: Int -> (a -> a) -> a -> Maybe (CircularVector a)

-- | <i>O(n)</i> Apply function n times to value. Zeroth element is
--   original value.
--   
--   This variant takes <tt>max n 1</tt> for the supplied length parameter.
--   
--   <pre>
--   &gt;&gt;&gt; iterateN1 3 (+1) 0
--   CircularVector {vector = [0,1,2], rotation = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateN1 0 (+1) 0
--   CircularVector {vector = [0], rotation = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateN1 (-1) (+1) 0
--   CircularVector {vector = [0], rotation = 0}
--   </pre>
iterateN1 :: Int -> (a -> a) -> a -> CircularVector a

-- | <i>O(n)</i> Execute the monadic action the given number of times and
--   store the results in a circular vector.
--   
--   When given a index n &lt;= 0, then <a>Nothing</a> is returned,
--   otherwise <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; replicateM @Maybe 3 (Just "a")
--   Just (Just (CircularVector {vector = ["a","a","a"], rotation = 0}))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicateM @Maybe 3 Nothing
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicateM @Maybe 0 (Just "a")
--   Just Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicateM @Maybe (-1) (Just "a")
--   Just Nothing
--   </pre>
replicateM :: Monad m => Int -> m a -> m (Maybe (CircularVector a))

-- | <i>O(n)</i> Execute the monadic action the given number of times and
--   store the results in a circular vector.
--   
--   This variant takes <tt>max n 1</tt> for the supplied length parameter.
--   
--   <pre>
--   &gt;&gt;&gt; replicate1M @Maybe 3 (Just "a")
--   Just (CircularVector {vector = ["a","a","a"], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate1M @Maybe 3 Nothing
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate1M @Maybe 0 (Just "a")
--   Just (CircularVector {vector = ["a"], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate1M @Maybe (-1) (Just "a")
--   Just (CircularVector {vector = ["a"], rotation = 0})
--   </pre>
replicate1M :: Monad m => Int -> m a -> m (CircularVector a)

-- | <i>O(n)</i> Construct a circular vector of the given length by
--   applying the monadic action to each index
--   
--   When given a index n &lt;= 0, then <a>Nothing</a> is returned,
--   otherwise <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; generateM 3 (\i -&gt; if i &lt; 1 then ["a"] else ["b"])
--   [Just (CircularVector {vector = ["a","b","b"], rotation = 0})]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generateM @[] @Int 3 (const [])
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generateM @[] @Int 0 (const [1])
--   [Nothing]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generateM @Maybe @Int (-1) (const Nothing)
--   Just Nothing
--   </pre>
generateM :: Monad m => Int -> (Int -> m a) -> m (Maybe (CircularVector a))

-- | <i>O(n)</i> Construct a circular vector of the given length by
--   applying the monadic action to each index
--   
--   This variant takes <tt>max n 1</tt> for the supplied length parameter.
--   
--   <pre>
--   &gt;&gt;&gt; generate1M 3 (\i -&gt; if i &lt; 1 then Just "a" else Just "b")
--   Just (CircularVector {vector = ["a","b","b"], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate1M 3 (const [])
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate1M 0 (const $ Just 1)
--   Just (CircularVector {vector = [1], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate1M (-1) (const Nothing)
--   Nothing
--   </pre>
generate1M :: Monad m => Int -> (Int -> m a) -> m (CircularVector a)

-- | <i>O(n)</i> Apply monadic function n times to value. Zeroth element is
--   original value.
--   
--   When given a index n &lt;= 0, then <a>Nothing</a> is returned,
--   otherwise <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; iterateNM @Maybe 3 return "a"
--   Just (Just (CircularVector {vector = ["a","a","a"], rotation = 0}))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateNM @Maybe 3 (const Nothing) "a"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateNM @Maybe 0 return "a"
--   Just Nothing
--   </pre>
iterateNM :: Monad m => Int -> (a -> m a) -> a -> m (Maybe (CircularVector a))

-- | <i>O(n)</i> Apply monadic function n times to value. Zeroth element is
--   original value.
--   
--   This variant takes <tt>max n 1</tt> for the supplied length parameter.
--   
--   <pre>
--   &gt;&gt;&gt; iterateN1M @Maybe 3 return "a"
--   Just (CircularVector {vector = ["a","a","a"], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateN1M @Maybe 3 (const Nothing) "a"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateN1M @Maybe 0 return "a"
--   Just (CircularVector {vector = ["a"], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateN1M @Maybe (-1) return "a"
--   Just (CircularVector {vector = ["a"], rotation = 0})
--   </pre>
iterateN1M :: Monad m => Int -> (a -> m a) -> a -> m (CircularVector a)

-- | Execute the monadic action and freeze the resulting circular vector.
create :: (forall s. ST s (MVector s a)) -> Maybe (CircularVector a)

-- | Execute the monadic action and freeze the resulting circular vector,
--   bypassing emptiness checks.
--   
--   The onus is on the caller to guarantee the created vector is
--   non-empty.
unsafeCreate :: (forall s. ST s (MVector s a)) -> CircularVector a

-- | Execute the monadic action and freeze the resulting circular vector.
createT :: Traversable t => (forall s. ST s (t (MVector s a))) -> t (Maybe (CircularVector a))

-- | Execute the monadic action and freeze the resulting circular vector.
--   
--   The onus is on the caller to guarantee the created vector is
--   non-empty.
unsafeCreateT :: Traversable t => (forall s. ST s (t (MVector s a))) -> t (CircularVector a)

-- | <i>O(n)</i> Construct a circular vector by repeatedly applying the
--   generator function to a seed. The generator function yields
--   <a>Just</a> the next element and the new seed or <a>Nothing</a> if
--   there are no more elements.
--   
--   If an unfold does not create meaningful values, <a>Nothing</a> is
--   returned. Otherwise, <a>Just</a> containing a circular vector is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr (\b -&gt; case b of "a" -&gt; Just ("a", "b"); _ -&gt;  Nothing) "a"
--   Just (CircularVector {vector = ["a"], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr (const Nothing) "a"
--   Nothing
--   </pre>
unfoldr :: (b -> Maybe (a, b)) -> b -> Maybe (CircularVector a)

-- | <i>O(n)</i> Construct a circular vector by repeatedly applying the
--   generator function to a seed and a first element.
--   
--   This variant of <a>unfoldr</a> guarantees the resulting vector is non-
--   empty by supplying an initial element <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr1 (\b -&gt; case b of "a" -&gt; Just ("a", "b"); _ -&gt;  Nothing) "first" "a"
--   CircularVector {vector = ["first","a"], rotation = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr1 (const Nothing) "first" "a"
--   CircularVector {vector = ["first"], rotation = 0}
--   </pre>
unfoldr1 :: (b -> Maybe (a, b)) -> a -> b -> CircularVector a

-- | <i>O(n)</i> Construct a circular vector with at most n elements by
--   repeatedly applying the generator function to a seed. The generator
--   function yields <a>Just</a> the next element and the new seed or
--   <a>Nothing</a> if there are no more elements.
--   
--   If an unfold does not create meaningful values, <a>Nothing</a> is
--   returned. Otherwise, <a>Just</a> containing a circular vector is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; unfoldrN 3 (\b -&gt; Just (b+1, b+1)) 0
--   Just (CircularVector {vector = [1,2,3], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unfoldrN 3 (const Nothing) 0
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unfoldrN 0 (\b -&gt; Just (b+1, b+1)) 0
--   Nothing
--   </pre>
unfoldrN :: Int -> (b -> Maybe (a, b)) -> b -> Maybe (CircularVector a)

-- | <i>O(n)</i> Construct a circular vector with at most n elements by
--   repeatedly applying the generator function to a seed. The generator
--   function yields <a>Just</a> the next element and the new seed or
--   <a>Nothing</a> if there are no more elements.
--   
--   This variant of <a>unfoldrN</a> guarantees the resulting vector is
--   non- empty by supplying an initial element <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr1N 3 (\b -&gt; Just (b+1, b+1)) 0 0
--   CircularVector {vector = [0,1,2,3], rotation = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr1N 3 (const Nothing) 0 0
--   CircularVector {vector = [0], rotation = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr1N 0 (\b -&gt; Just (b+1, b+1)) 0 0
--   CircularVector {vector = [0], rotation = 0}
--   </pre>
unfoldr1N :: Int -> (b -> Maybe (a, b)) -> a -> b -> CircularVector a

-- | <i>O(n)</i> Construct a circular vector by repeatedly applying the
--   monadic generator function to a seed. The generator function yields
--   Just the next element and the new seed or Nothing if there are no more
--   elements.
--   
--   If an unfold does not create meaningful values, <a>Nothing</a> is
--   returned. Otherwise, <a>Just</a> containing a circular vector is
--   returned.
unfoldrM :: Monad m => (b -> m (Maybe (a, b))) -> b -> m (Maybe (CircularVector a))

-- | <i>O(n)</i> Construct a circular vector by repeatedly applying the
--   monadic generator function to a seed. The generator function yields
--   Just the next element and the new seed or Nothing if there are no more
--   elements.
--   
--   This variant of <a>unfoldrM</a> guarantees the resulting vector is
--   non- empty by supplying an initial element <tt>a</tt>.
unfoldr1M :: Monad m => (b -> m (Maybe (a, b))) -> a -> b -> m (CircularVector a)

-- | <i>O(n)</i> Construct a circular vector by repeatedly applying the
--   monadic generator function to a seed. The generator function yields
--   Just the next element and the new seed or Nothing if there are no more
--   elements.
--   
--   If an unfold does not create meaningful values, <a>Nothing</a> is
--   returned. Otherwise, <a>Just</a> containing a circular vector is
--   returned.
unfoldrNM :: Monad m => Int -> (b -> m (Maybe (a, b))) -> b -> m (Maybe (CircularVector a))

-- | <i>O(n)</i> Construct a circular vector by repeatedly applying the
--   monadic generator function to a seed. The generator function yields
--   Just the next element and the new seed or Nothing if there are no more
--   elements.
--   
--   This variant of <a>unfoldrNM</a> guarantees the resulting vector is
--   non- empty by supplying an initial element <tt>a</tt>.
unfoldr1NM :: Monad m => Int -> (b -> m (Maybe (a, b))) -> a -> b -> m (CircularVector a)

-- | <i>O(n)</i> Construct a circular vector with n elements by repeatedly
--   applying the generator function to the already constructed part of the
--   vector.
--   
--   If <a>constructN</a> does not create meaningful values, <a>Nothing</a>
--   is returned. Otherwise, <a>Just</a> containing a circular vector is
--   returned.
constructN :: Int -> (Vector a -> a) -> Maybe (CircularVector a)

-- | <i>O(n)</i> Construct a circular vector with n elements from right to
--   left by repeatedly applying the generator function to the already
--   constructed part of the vector.
--   
--   If <a>constructrN</a> does not create meaningful values,
--   <a>Nothing</a> is returned. Otherwise, <a>Just</a> containing a
--   circular vector is returned.
constructrN :: Int -> (Vector a -> a) -> Maybe (CircularVector a)

-- | <i>O(n)</i> Yield a circular vector of the given length containing the
--   values x, x+1 etc. This operation is usually more efficient than
--   <a>enumFromTo</a>.
--   
--   If an enumeration does not use meaningful indices, <a>Nothing</a> is
--   returned, otherwise, <a>Just</a> containing a circular vector.
enumFromN :: Num a => a -> Int -> Maybe (CircularVector a)

-- | <i>O(n)</i> Yield a circular vector of length <tt>max n 1</tt>
--   containing the values x, x+1 etc. This operation is usually more
--   efficient than <a>enumFromTo</a>.
enumFromN1 :: Num a => a -> Int -> CircularVector a

-- | <i>O(n)</i> Yield a circular vector of the given length containing the
--   values x, x+y, x+y+y etc. This operations is usually more efficient
--   than <a>enumFromThenTo</a>.
--   
--   If an enumeration does not use meaningful indices, <a>Nothing</a> is
--   returned, otherwise, <a>Just</a> containing a circular vector.
enumFromStepN :: Num a => a -> a -> Int -> Maybe (CircularVector a)

-- | <i>O(n)</i> Yield a circular vector of length <tt>max n 1</tt>
--   containing the values x, x+y, x+y+y etc. This operations is usually
--   more efficient than <a>enumFromThenTo</a>.
enumFromStepN1 :: Num a => a -> a -> Int -> CircularVector a

-- | <i>O(n)</i> Enumerate values from x to y.
--   
--   If an enumeration does not use meaningful indices, <a>Nothing</a> is
--   returned, otherwise, <a>Just</a> containing a circular vector.
--   
--   <i>WARNING</i>: This operation can be very inefficient. If at all
--   possible, use <a>enumFromN</a> instead.
enumFromTo :: Enum a => a -> a -> Maybe (CircularVector a)

-- | <i>O(n)</i> Enumerate values from x to y with a specific step z.
--   
--   If an enumeration does not use meaningful indices, <a>Nothing</a> is
--   returned, otherwise, <a>Just</a> containing a circular vector.
--   
--   <i>WARNING</i>: This operation can be very inefficient. If at all
--   possible, use <a>enumFromStepN</a> instead.
enumFromThenTo :: Enum a => a -> a -> a -> Maybe (CircularVector a)

-- | <i>O(n)</i> Prepend an element
--   
--   <pre>
--   &gt;&gt;&gt; cons 1 (unsafeFromList [2,3])
--   CircularVector {vector = [1,2,3], rotation = 0}
--   </pre>
cons :: a -> CircularVector a -> CircularVector a

-- | <i>O(n)</i> Prepend an element to a Vector
--   
--   <pre>
--   &gt;&gt;&gt; consV 1 (Vector.fromList [2,3])
--   CircularVector {vector = [1,2,3], rotation = 0}
--   </pre>
consV :: a -> Vector a -> CircularVector a

-- | <i>O(n)</i> Append an element
--   
--   <pre>
--   &gt;&gt;&gt; snoc (unsafeFromList [1,2]) 3
--   CircularVector {vector = [1,2,3], rotation = 0}
--   </pre>
snoc :: CircularVector a -> a -> CircularVector a

-- | <i>O(n)</i> Append an element to a Vector
--   
--   <pre>
--   &gt;&gt;&gt; snocV (Vector.fromList [1,2]) 3
--   CircularVector {vector = [1,2,3], rotation = 0}
--   </pre>
snocV :: Vector a -> a -> CircularVector a

-- | <i>O(m+n)</i> Concatenate two circular vectors
--   
--   <pre>
--   &gt;&gt;&gt; (unsafeFromList [1..3]) ++ (unsafeFromList [4..6])
--   CircularVector {vector = [1,2,3,4,5,6], rotation = 0}
--   </pre>
(++) :: CircularVector a -> CircularVector a -> CircularVector a

-- | <i>O(n)</i> Concatenate all circular vectors in the list
--   
--   If list is empty, <a>Nothing</a> is returned, otherwise <a>Just</a>
--   containing the concatenated circular vectors
--   
--   <pre>
--   &gt;&gt;&gt; concat [(unsafeFromList [1..3]), (unsafeFromList [4..6])]
--   Just (CircularVector {vector = [1,2,3,4,5,6], rotation = 0})
--   </pre>
concat :: [CircularVector a] -> Maybe (CircularVector a)

-- | O(n) Concatenate all circular vectors in a non-empty list.
--   
--   <pre>
--   &gt;&gt;&gt; concat1 ((unsafeFromList [1..3]) :| [(unsafeFromList [4..6])])
--   CircularVector {vector = [1,2,3,4,5,6], rotation = 0}
--   </pre>
concat1 :: NonEmpty (CircularVector a) -> CircularVector a

-- | a variant of <a>deepseq</a> that is useful in some circumstances:
--   
--   <pre>
--   force x = x `deepseq` x
--   </pre>
--   
--   <tt>force x</tt> fully evaluates <tt>x</tt>, and then returns it. Note
--   that <tt>force x</tt> only performs evaluation when the value of
--   <tt>force x</tt> itself is demanded, so essentially it turns shallow
--   evaluation into deep evaluation.
--   
--   <a>force</a> can be conveniently used in combination with
--   <tt>ViewPatterns</tt>:
--   
--   <pre>
--   {-# LANGUAGE BangPatterns, ViewPatterns #-}
--   import Control.DeepSeq
--   
--   someFun :: ComplexData -&gt; SomeResult
--   someFun (force -&gt; !arg) = {- 'arg' will be fully evaluated -}
--   </pre>
--   
--   Another useful application is to combine <a>force</a> with
--   <a>evaluate</a> in order to force deep evaluation relative to other
--   <a>IO</a> operations:
--   
--   <pre>
--   import Control.Exception (evaluate)
--   import Control.DeepSeq
--   
--   main = do
--     result &lt;- evaluate $ force $ pureComputation
--     {- 'result' will be fully evaluated at this point -}
--     return ()
--   </pre>
--   
--   Finally, here's an exception safe variant of the <tt>readFile'</tt>
--   example:
--   
--   <pre>
--   readFile' :: FilePath -&gt; IO String
--   readFile' fn = bracket (openFile fn ReadMode) hClose $ \h -&gt;
--                          evaluate . force =&lt;&lt; hGetContents h
--   </pre>
force :: NFData a => a -> a

-- | Construct a <a>CircularVector</a> at compile-time using typed Template
--   Haskell.
vec :: Lift a => [a] -> Q (TExp (CircularVector a))

-- | <i>O(n)</i> Construct a <a>Vector</a> from a <a>CircularVector</a>.
toVector :: CircularVector a -> Vector a

-- | <i>O(1)</i> Construct a <a>CircularVector</a> from a
--   <a>NonEmptyVector</a>.
fromVector :: NonEmptyVector a -> CircularVector a

-- | <i>O(1)</i> Construct a <a>CircularVector</a> from a
--   <a>NonEmptyVector</a>.
fromVector' :: Vector a -> Maybe (CircularVector a)

-- | <i>O(1)</i> Construct a <a>CircularVector</a> from a <a>Vector</a>.
--   
--   Calls <tt><a>error</a></tt> if the input vector is empty.
unsafeFromVector :: Vector a -> CircularVector a

-- | <i>O(n)</i> Construct a <a>NonEmptyVector</a> from a
--   <a>CircularVector</a>.
toNonEmptyVector :: CircularVector a -> NonEmptyVector a

-- | <i>O(n)</i> Convert from a circular vector to a list.
--   
--   <pre>
--   &gt;&gt;&gt; let nev = unsafeFromList [1..3] in toList nev
--   [1,2,3]
--   </pre>
toList :: CircularVector a -> [a]

-- | <i>O(n)</i> Construct a <a>CircularVector</a> from a list.
fromList :: [a] -> Maybe (CircularVector a)

-- | Construct a <a>CircularVector</a> from a list with a size hint.
fromListN :: Int -> [a] -> Maybe (CircularVector a)

-- | <i>O(n)</i> Construct a <a>CircularVector</a> from a list.
--   
--   Calls <tt><a>error</a></tt> if the input list is empty.
unsafeFromList :: [a] -> CircularVector a

-- | <i>O(n)</i> Construct a <a>CircularVector</a> from a list with a size
--   hint.
--   
--   Calls <tt><a>error</a></tt> if the input list is empty, or if the size
--   hint is <tt><a>&lt;=</a> 0</tt>.
unsafeFromListN :: Int -> [a] -> CircularVector a

-- | <i>O(1)</i> Rotate the vector to the left by <tt>n</tt> number of
--   elements.
--   
--   <i>Note</i>: Left rotations start to break down due to arithmetic
--   underflow when the size of the input vector is <tt><a>&gt;</a>
--   <a>maxBound</a> </tt><a>Int</a>@
rotateLeft :: Int -> CircularVector a -> CircularVector a

-- | <i>O(1)</i> Rotate the vector to left by <tt>n</tt> number of
--   elements.
--   
--   <i>Note</i>: Right rotations start to break down due to arithmetic
--   overflow when the size of the input vector is <tt><a>&gt;</a>
--   <a>maxBound</a> </tt><a>Int</a>@
rotateRight :: Int -> CircularVector a -> CircularVector a

equivalent :: Ord a => CircularVector a -> CircularVector a -> Bool

canonise :: Ord a => CircularVector a -> CircularVector a

leastRotation :: forall a. Ord a => Vector a -> Int

-- | Lazily-accumulating monoidal fold over a <a>CircularVector</a>. @since
--   0.1
foldMap :: Monoid m => (a -> m) -> CircularVector a -> m

-- | Strictly-accumulating monoidal fold over a <a>CircularVector</a>.
foldMap' :: Monoid m => (a -> m) -> CircularVector a -> m

foldr :: (a -> b -> b) -> b -> CircularVector a -> b

foldl :: (b -> a -> b) -> b -> CircularVector a -> b

foldr' :: (a -> b -> b) -> b -> CircularVector a -> b

foldl' :: (b -> a -> b) -> b -> CircularVector a -> b

foldr1 :: (a -> a -> a) -> CircularVector a -> a

foldl1 :: (a -> a -> a) -> CircularVector a -> a

-- | Lazily-accumulating semigroupoidal fold over a <a>CircularVector</a>.
foldMap1 :: Semigroup m => (a -> m) -> CircularVector a -> m

-- | Strictly-accumulating semigroupoidal fold over a
--   <a>CircularVector</a>.
foldMap1' :: Semigroup m => (a -> m) -> CircularVector a -> m

toNonEmpty :: CircularVector a -> NonEmpty a

-- | <i>O(n)</i> Check if all elements satisfy the predicate.
all :: (a -> Bool) -> CircularVector a -> Bool

-- | <i>O(n)</i> Check if any element satisfies the predicate.
any :: (a -> Bool) -> CircularVector a -> Bool

-- | <i>O(n)</i> Check if all elements are True.
and :: CircularVector Bool -> Bool

-- | <i>O(n)</i> Check if any element is True.
or :: CircularVector Bool -> Bool

-- | <i>O(n)</i> Compute the sum of the elements.
sum :: Num a => CircularVector a -> a

-- | <i>O(n)</i> Compute the product of the elements.
product :: Num a => CircularVector a -> a

-- | <i>O(n)</i> Yield the maximum element of the circular vector.
maximum :: Ord a => CircularVector a -> a

-- | <i>O(n)</i> Yield the maximum element of a circular vector according
--   to the given comparison function.
maximumBy :: (a -> a -> Ordering) -> CircularVector a -> a

-- | <i>O(n)</i> Yield the minimum element of the circular vector.
minimum :: Ord a => CircularVector a -> a

-- | <i>O(n)</i> Yield the minimum element of a circular vector according
--   to the given comparison function.
minimumBy :: (a -> a -> Ordering) -> CircularVector a -> a

-- | <i>O(n)</i> Rotate to the minimum element of the circular vector
--   according to the given comparison function.
rotateToMinimumBy :: (a -> a -> Ordering) -> CircularVector a -> CircularVector a

-- | <i>O(n)</i> Rotate to the maximum element of the circular vector
--   according to the given comparison function.
rotateToMaximumBy :: (a -> a -> Ordering) -> CircularVector a -> CircularVector a

-- | <i>O(1)</i> Index into a <a>CircularVector</a>. This is always total.
index :: CircularVector a -> Int -> a

-- | <i>O(1)</i> Get the first element of a <a>CircularVector</a>. This is
--   always total.
head :: CircularVector a -> a

-- | <i>O(1)</i> Get the last element of a <a>CircularVector</a>. This is
--   always total.
last :: CircularVector a -> a

-- | <i>O(n)</i> Map a function over a circular vector.
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) $ unsafeFromList [1..3]
--   CircularVector {vector = [2,3,4], rotation = 0}
--   </pre>
map :: (a -> b) -> CircularVector a -> CircularVector b

-- | <i>O(n)</i> Apply a function to every element of a circular vector and
--   its index.
--   
--   <pre>
--   &gt;&gt;&gt; imap (\i a -&gt; if i == 2 then a+1 else a+0) $ unsafeFromList [1..3]
--   CircularVector {vector = [1,2,4], rotation = 0}
--   </pre>
imap :: (Int -> a -> b) -> CircularVector a -> CircularVector b

-- | Map a function over a circular vector and concatenate the results.
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (\a -&gt; unsafeFromList [a,a]) (unsafeFromList [1,2,3])
--   CircularVector {vector = [1,1,2,2,3,3], rotation = 0}
--   </pre>
concatMap :: (a -> CircularVector b) -> CircularVector a -> CircularVector b

-- | <i>O(n)</i> Apply the monadic action to all elements of the circular
--   vector, yielding circular vector of results.
--   
--   <pre>
--   &gt;&gt;&gt; mapM Just (unsafeFromList [1..3])
--   Just (CircularVector {vector = [1,2,3], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapM (const Nothing) (unsafeFromList [1..3])
--   Nothing
--   </pre>
mapM :: Monad m => (a -> m b) -> CircularVector a -> m (CircularVector b)

-- | <i>O(n)</i> Apply the monadic action to every element of a circular
--   vector and its index, yielding a circular vector of results.
--   
--   <pre>
--   &gt;&gt;&gt; imapM (\i a -&gt; if i == 1 then Just a else Just 0) (unsafeFromList [1..3])
--   Just (CircularVector {vector = [0,2,0], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; imapM (\_ _ -&gt; Nothing) (unsafeFromList [1..3])
--   Nothing
--   </pre>
imapM :: Monad m => (Int -> a -> m b) -> CircularVector a -> m (CircularVector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a circular
--   vector and ignore the results.
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ (const $ Just ()) (unsafeFromList [1..3])
--   Just ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ (const Nothing) (unsafeFromList [1..3])
--   Nothing
--   </pre>
mapM_ :: Monad m => (a -> m b) -> CircularVector a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of a circular
--   vector and its index, ignoring the results
--   
--   <pre>
--   &gt;&gt;&gt; imapM_ (\i a -&gt; if i == 1 then print a else putStrLn "0") (unsafeFromList [1..3])
--   0
--   2
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; imapM_ (\_ _ -&gt; Nothing) (unsafeFromList [1..3])
--   Nothing
--   </pre>
imapM_ :: Monad m => (Int -> a -> m b) -> CircularVector a -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the circular
--   vector, yielding a circular vector of results.
--   
--   Equivalent to <tt>flip <a>mapM</a></tt>.
forM :: Monad m => CircularVector a -> (a -> m b) -> m (CircularVector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a circular
--   vector and ignore the results.
--   
--   Equivalent to <tt>flip <a>mapM_</a></tt>.
forM_ :: Monad m => CircularVector a -> (a -> m b) -> m ()

-- | <i>O(min(m,n))</i> Zip two circular vectors with the given function.
zipWith :: (a -> b -> c) -> CircularVector a -> CircularVector b -> CircularVector c

-- | Zip three circular vectors with the given function.
zipWith3 :: (a -> b -> c -> d) -> CircularVector a -> CircularVector b -> CircularVector c -> CircularVector d

-- | <i>O(min(n,m))</i> Elementwise pairing of circular vector elements.
--   This is a special case of <a>zipWith</a> where the function argument
--   is <tt>(,)</tt>
zip :: CircularVector a -> CircularVector b -> CircularVector (a, b)

-- | Zip together three circular vectors.
zip3 :: CircularVector a -> CircularVector b -> CircularVector c -> CircularVector (a, b, c)

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | <i>O(n)</i> Drop repeated adjacent elements.
--   
--   <pre>
--   &gt;&gt;&gt; toList $ uniq $ unsafeFromList [1,1,2,2,3,3,1]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList $ uniq $ unsafeFromList [1,2,3,1]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList $ uniq $ unsafeFromList [1]
--   [1]
--   </pre>
uniq :: Eq a => CircularVector a -> CircularVector a

-- | <i>O(n)</i> Drop elements when predicate returns Nothing
--   
--   If no elements satisfy the predicate, the resulting vector may be
--   empty.
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe (\a -&gt; if a == 2 then Nothing else Just a) (unsafeFromList [1..3])
--   [1,3]
--   </pre>
mapMaybe :: (a -> Maybe b) -> CircularVector a -> Vector b

-- | <i>O(n)</i> Drop elements when predicate, applied to index and value,
--   returns Nothing
--   
--   If no elements satisfy the predicate, the resulting vector may be
--   empty.
--   
--   <pre>
--   &gt;&gt;&gt; imapMaybe (\i a -&gt; if a == 2 || i == 2 then Nothing else Just a) (unsafeFromList [1..3])
--   [1]
--   </pre>
imapMaybe :: (Int -> a -> Maybe b) -> CircularVector a -> Vector b

-- | <i>O(n)</i>. <a>filter</a>, applied to a predicate and a list, returns
--   the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | <i>O(n)</i> Drop elements that do not satisfy the predicate which is
--   applied to values and their indices.
--   
--   If no elements satisfy the predicate, the resulting vector may be
--   empty.
--   
--   <pre>
--   &gt;&gt;&gt; ifilter (\i a -&gt; if a == 2 || i == 0 then False else True) (unsafeFromList [1..3])
--   [3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ifilter (\_ _ -&gt; False) (unsafeFromList [1..3])
--   []
--   </pre>
ifilter :: (Int -> a -> Bool) -> CircularVector a -> Vector a

-- | <i>O(n)</i> Drop elements that do not satisfy the monadic predicate.
--   
--   If no elements satisfy the predicate, the resulting vector may be
--   empty.
--   
--   <pre>
--   &gt;&gt;&gt; filterM (\a -&gt; if a == 2 then Just False else Just True) (unsafeFromList [1..3])
--   Just [1,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filterM (\a -&gt; if a == 2 then Nothing else Just True) (unsafeFromList [1..3])
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filterM (const $ Just False) (unsafeFromList [1..3])
--   Just []
--   </pre>
filterM :: Monad m => (a -> m Bool) -> CircularVector a -> m (Vector a)

-- | <i>O(n)</i> Drop elements that do not satisfy the monadic predicate
--   that is a function of index and value.
--   
--   If no elements satisfy the predicate, the resulting vector may be
--   empty.
--   
--   <pre>
--   &gt;&gt;&gt; ifilterM (\i a -&gt; if a == 2 || i == 0 then Just False else Just True) (unsafeFromList [1..3])
--   Just [3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ifilterM (\i a -&gt; if a == 2 || i == 0 then Nothing else Just True) (unsafeFromList [1..3])
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ifilterM (\_ _ -&gt; Just False) (unsafeFromList [1..3])
--   Just []
--   </pre>
ifilterM :: Monad m => (Int -> a -> m Bool) -> CircularVector a -> m (Vector a)

-- | <i>O(n)</i> Yield the longest prefix of elements satisfying the
--   predicate without copying.
--   
--   If no elements satisfy the predicate, the resulting vector may be
--   empty.
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (/= 3) (unsafeFromList [1..3])
--   [1,2]
--   </pre>
takeWhile :: (a -> Bool) -> CircularVector a -> Vector a

-- | <i>O(n)</i> Drop the longest prefix of elements that satisfy the
--   predicate without copying.
--   
--   If all elements satisfy the predicate, the resulting vector may be
--   empty.
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (/= 3) (unsafeFromList [1..3])
--   [3]
--   </pre>
dropWhile :: (a -> Bool) -> CircularVector a -> Vector a

-- | <i>O(n)</i> Split the circular vector in two parts, the first one
--   containing those elements that satisfy the predicate and the second
--   one those that don't. The relative order of the elements is preserved
--   at the cost of a sometimes reduced performance compared to
--   <a>unstablePartition</a>.
--   
--   If all or no elements satisfy the predicate, one of the resulting
--   vectors may be empty.
--   
--   <pre>
--   &gt;&gt;&gt; partition (&lt; 3) (unsafeFromList [1..5])
--   ([1,2],[3,4,5])
--   </pre>
partition :: (a -> Bool) -> CircularVector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the circular vector in two parts, the first one
--   containing those elements that satisfy the predicate and the second
--   one those that don't. The order of the elements is not preserved but
--   the operation is often faster than <a>partition</a>.
--   
--   If all or no elements satisfy the predicate, one of the resulting
--   vectors may be empty.
unstablePartition :: (a -> Bool) -> CircularVector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the circular vector into the longest prefix of
--   elements that satisfy the predicate and the rest without copying.
--   
--   If all or no elements satisfy the predicate, one of the resulting
--   vectors may be empty.
--   
--   <pre>
--   &gt;&gt;&gt; span (== 1) (unsafeFromList [1,1,2,3,1])
--   ([1,1],[2,3,1])
--   </pre>
span :: (a -> Bool) -> CircularVector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the circular vector into the longest prefix of
--   elements that do not satisfy the predicate and the rest without
--   copying.
--   
--   If all or no elements satisfy the predicate, one of the resulting
--   vectors may be empty.
--   
--   <pre>
--   &gt;&gt;&gt; break (== 2) (unsafeFromList [1,1,2,3,1])
--   ([1,1],[2,3,1])
--   </pre>
break :: (a -> Bool) -> CircularVector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Check if the circular vector contains an element
--   
--   <pre>
--   &gt;&gt;&gt; elem 1 $ unsafeFromList [1..3]
--   True
--   
--   &gt;&gt;&gt; elem 4 $ unsafeFromList [1..3]
--   False
--   </pre>
elem :: Eq a => a -> CircularVector a -> Bool

-- | <i>O(n)</i> Check if the circular vector does not contain an element
--   (inverse of <a>elem</a>)
--   
--   <pre>
--   &gt;&gt;&gt; notElem 1 $ unsafeFromList [1..3]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notElem 4 $ unsafeFromList [1..3]
--   True
--   </pre>
notElem :: Eq a => a -> CircularVector a -> Bool

-- | <i>O(n)</i> Yield <a>Just</a> the first element matching the predicate
--   or <a>Nothing</a> if no such element exists.
--   
--   <pre>
--   &gt;&gt;&gt; find (&lt; 2) $ unsafeFromList [1..3]
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; find (&lt; 0) $ unsafeFromList [1..3]
--   Nothing
--   </pre>
find :: (a -> Bool) -> CircularVector a -> Maybe a

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first element matching
--   the predicate or <a>Nothing</a> if no such element exists.
--   
--   <pre>
--   &gt;&gt;&gt; findIndex (&lt; 2) $ unsafeFromList [1..3]
--   Just 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findIndex (&lt; 0) $ unsafeFromList [1..3]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findIndex (==1) $ rotateRight 1 (unsafeFromList [1..3])
--   Just 2
--   </pre>
findIndex :: (a -> Bool) -> CircularVector a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of elements satisfying the predicate in
--   ascending order.
--   
--   <pre>
--   &gt;&gt;&gt; findIndices (&lt; 3) $ unsafeFromList [1..3]
--   [0,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findIndices (&lt; 0) $ unsafeFromList [1..3]
--   []
--   </pre>
findIndices :: (a -> Bool) -> CircularVector a -> Vector Int

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first occurence of the
--   given element or <a>Nothing</a> if the circular vector does not
--   contain the element. This is a specialised version of
--   <a>findIndex</a>.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 1 $ unsafeFromList [1..3]
--   Just 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 0 $ unsafeFromList [1..3]
--   Nothing
--   </pre>
elemIndex :: Eq a => a -> CircularVector a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of all occurences of the given element
--   in ascending order. This is a specialised version of
--   <a>findIndices</a>.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndices 1 $ unsafeFromList [1,2,3,1]
--   [0,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elemIndices 0 $ unsafeFromList [1..3]
--   []
--   </pre>
elemIndices :: Eq a => a -> CircularVector a -> Vector Int

-- | <i>O(n)</i> Reverse a circular vector.
reverse :: CircularVector a -> CircularVector a

-- | <i>O(n)</i> Yield the circular vector obtained by replacing each
--   element <tt>i</tt> of the circular index vector by
--   <tt>xs<tt>!</tt>i</tt>. This is equivalent to <tt><a>map</a>
--   (xs<tt>!</tt>) is</tt> but is often much more efficient.
--   
--   <pre>
--   &gt;&gt;&gt; toList $ backpermute (unsafeFromList [1..3]) (unsafeFromList [2,0])
--   [3,1]
--   </pre>
backpermute :: CircularVector a -> CircularVector Int -> CircularVector a

-- | Same as <a>backpermute</a> but without bounds checking.
unsafeBackpermute :: CircularVector a -> CircularVector Int -> CircularVector a

-- | Apply a destructive operation to a circular vector. The operation will
--   be performed in place if it is safe to do so and will modify a copy of
--   the circular vector otherwise.
modify :: (forall s. MVector s a -> ST s ()) -> CircularVector a -> CircularVector a

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   As of base 4.8.0.0, <a>sequence_</a> is just <a>sequenceA_</a>,
--   specialized to <a>Monad</a>.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Vector.Circular.CircularVector a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Vector.Circular.CircularVector a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Vector.Circular.CircularVector a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Vector.Circular.CircularVector a)
instance GHC.Generics.Generic (Data.Vector.Circular.CircularVector a)
instance GHC.Base.Functor Data.Vector.Circular.CircularVector
instance Data.Traversable.Traversable Data.Vector.Circular.CircularVector
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Vector.Circular.CircularVector a)
instance Data.Functor.Classes.Eq1 Data.Vector.Circular.CircularVector
instance Data.Functor.Classes.Ord1 Data.Vector.Circular.CircularVector
instance Data.Functor.Classes.Show1 Data.Vector.Circular.CircularVector
instance Data.Functor.Classes.Read1 Data.Vector.Circular.CircularVector
instance GHC.Base.Semigroup (Data.Vector.Circular.CircularVector a)
instance Data.Foldable.Foldable Data.Vector.Circular.CircularVector
instance Data.Semigroup.Foldable.Class.Foldable1 Data.Vector.Circular.CircularVector
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Data.Vector.Circular.CircularVector a)

module Data.Vector.Circular.Generic

-- | A circular, immutable vector. This type is equivalent to
--   <tt><a>cycle</a> xs</tt> for some finite, nonempty <tt>xs</tt>, but
--   with <i>O(1)</i> access and <i>O(1)</i> rotations. Indexing into this
--   type is always total.
data CircularVector v a
CircularVector :: !v a -> {-# UNPACK #-} !Int -> CircularVector v a
[vector] :: CircularVector v a -> !v a
[rotation] :: CircularVector v a -> {-# UNPACK #-} !Int

-- | <i>O(1)</i> Construct a singleton 'CircularVector.
--   
--   since 0.1.2
singleton :: Vector v a => a -> CircularVector v a

-- | <i>O(n)</i> Circular vector of the given length with the same value in
--   each position.
--   
--   When given a index n &lt;= 0, then <a>Nothing</a> is returned,
--   otherwise <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; replicate @Vector 3 "a"
--   Just (CircularVector {vector = ["a","a","a"], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate @Vector 0 "a"
--   Nothing
--   </pre>
replicate :: Vector v a => Int -> a -> Maybe (CircularVector v a)

-- | <i>O(n)</i> Circular vector of the given length with the same value in
--   each position.
--   
--   This variant takes <tt>max n 1</tt> for the supplied length parameter.
--   
--   <pre>
--   &gt;&gt;&gt; toList $ replicate1 @Vector 3 "a"
--   ["a","a","a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList $ replicate1 @Vector 0 "a"
--   ["a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList $ replicate1 @Vector (-1) "a"
--   ["a"]
--   </pre>
replicate1 :: Vector v a => Int -> a -> CircularVector v a

-- | <i>O(n)</i> Construct a circular vector of the given length by
--   applying the function to each index.
--   
--   When given a index n &lt;= 0, then <a>Nothing</a> is returned,
--   otherwise <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let f 0 = "a"; f _ = "k"; f :: Int -&gt; String
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate @Vector 1 f
--   Just (CircularVector {vector = ["a"], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate @Vector 0 f
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate @Vector 2 f
--   Just (CircularVector {vector = ["a","k"], rotation = 0})
--   </pre>
generate :: Vector v a => Int -> (Int -> a) -> Maybe (CircularVector v a)

-- | <i>O(n)</i> Construct a circular vector of the given length by
--   applying the function to each index.
--   
--   This variant takes <tt>max n 1</tt> for the supplied length parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let f 0 = "a"; f _ = "k"; f :: Int -&gt; String
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList $ generate1 @Vector 2 f
--   ["a","k"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList $ generate1 @Vector 0 f
--   ["a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList $ generate1 @Vector (-1) f
--   ["a"]
--   </pre>
generate1 :: Vector v a => Int -> (Int -> a) -> CircularVector v a

-- | <i>O(n)</i> Apply function n times to value. Zeroth element is
--   original value.
--   
--   When given a index n &lt;= 0, then <a>Nothing</a> is returned,
--   otherwise <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; iterateN @Vector 3 (+1) 0
--   Just (CircularVector {vector = [0,1,2], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateN @Vector 0 (+1) 0
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateN @Vector (-1) (+1) 0
--   Nothing
--   </pre>
iterateN :: Vector v a => Int -> (a -> a) -> a -> Maybe (CircularVector v a)

-- | <i>O(n)</i> Apply function n times to value. Zeroth element is
--   original value.
--   
--   This variant takes <tt>max n 1</tt> for the supplied length parameter.
--   
--   <pre>
--   &gt;&gt;&gt; iterateN1 @Vector 3 (+1) 0
--   CircularVector {vector = [0,1,2], rotation = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateN1 @Vector 0 (+1) 0
--   CircularVector {vector = [0], rotation = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateN1 @Vector (-1) (+1) 0
--   CircularVector {vector = [0], rotation = 0}
--   </pre>
iterateN1 :: Vector v a => Int -> (a -> a) -> a -> CircularVector v a

-- | <i>O(n)</i> Execute the monadic action the given number of times and
--   store the results in a circular vector.
--   
--   When given a index n &lt;= 0, then <a>Nothing</a> is returned,
--   otherwise <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; replicateM @Maybe @Vector 3 (Just "a")
--   Just (Just (CircularVector {vector = ["a","a","a"], rotation = 0}))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicateM @Maybe @Vector 3 Nothing
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicateM @Maybe @Vector 0 (Just "a")
--   Just Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicateM @Maybe @Vector (-1) (Just "a")
--   Just Nothing
--   </pre>
replicateM :: (Monad m, Vector v a) => Int -> m a -> m (Maybe (CircularVector v a))

-- | <i>O(n)</i> Execute the monadic action the given number of times and
--   store the results in a circular vector.
--   
--   This variant takes <tt>max n 1</tt> for the supplied length parameter.
--   
--   <pre>
--   &gt;&gt;&gt; replicate1M @Maybe @Vector 3 (Just "a")
--   Just (CircularVector {vector = ["a","a","a"], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate1M @Maybe @Vector 3 Nothing
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate1M @Maybe @Vector 0 (Just "a")
--   Just (CircularVector {vector = ["a"], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate1M @Maybe @Vector (-1) (Just "a")
--   Just (CircularVector {vector = ["a"], rotation = 0})
--   </pre>
replicate1M :: (Monad m, Vector v a) => Int -> m a -> m (CircularVector v a)

-- | <i>O(n)</i> Construct a circular vector of the given length by
--   applying the monadic action to each index
--   
--   When given a index n &lt;= 0, then <a>Nothing</a> is returned,
--   otherwise <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; generateM @[] @Vector 3 (\i -&gt; if i &lt; 1 then ["a"] else ["b"])
--   [Just (CircularVector {vector = ["a","b","b"], rotation = 0})]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generateM @[] @Vector @Int 3 (const [])
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generateM @[] @Vector @Int 0 (const [1])
--   [Nothing]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generateM @Maybe @Vector @Int (-1) (const Nothing)
--   Just Nothing
--   </pre>
generateM :: (Monad m, Vector v a) => Int -> (Int -> m a) -> m (Maybe (CircularVector v a))

-- | <i>O(n)</i> Construct a circular vector of the given length by
--   applying the monadic action to each index
--   
--   This variant takes <tt>max n 1</tt> for the supplied length parameter.
--   
--   <pre>
--   &gt;&gt;&gt; generate1M @Maybe @Vector 3 (\i -&gt; if i &lt; 1 then Just "a" else Just "b")
--   Just (CircularVector {vector = ["a","b","b"], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate1M @[] @Vector 3 (const [])
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate1M @Maybe @Vector 0 (const $ Just 1)
--   Just (CircularVector {vector = [1], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate1M @Maybe @Vector (-1) (const Nothing)
--   Nothing
--   </pre>
generate1M :: (Monad m, Vector v a) => Int -> (Int -> m a) -> m (CircularVector v a)

-- | <i>O(n)</i> Apply monadic function n times to value. Zeroth element is
--   original value.
--   
--   When given a index n &lt;= 0, then <a>Nothing</a> is returned,
--   otherwise <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; iterateNM @Maybe @Vector 3 return "a"
--   Just (Just (CircularVector {vector = ["a","a","a"], rotation = 0}))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateNM @Maybe @Vector 3 (const Nothing) "a"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateNM @Maybe @Vector 0 return "a"
--   Just Nothing
--   </pre>
iterateNM :: (Monad m, Vector v a) => Int -> (a -> m a) -> a -> m (Maybe (CircularVector v a))

-- | <i>O(n)</i> Apply monadic function n times to value. Zeroth element is
--   original value.
--   
--   This variant takes <tt>max n 1</tt> for the supplied length parameter.
--   
--   <pre>
--   &gt;&gt;&gt; iterateN1M @Maybe @Vector 3 return "a"
--   Just (CircularVector {vector = ["a","a","a"], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateN1M @Maybe @Vector 3 (const Nothing) "a"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateN1M @Maybe @Vector 0 return "a"
--   Just (CircularVector {vector = ["a"], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateN1M @Maybe @Vector (-1) return "a"
--   Just (CircularVector {vector = ["a"], rotation = 0})
--   </pre>
iterateN1M :: (Monad m, Vector v a) => Int -> (a -> m a) -> a -> m (CircularVector v a)

-- | Execute the monadic action and freeze the resulting circular vector.
create :: Vector v a => (forall s. ST s (Mutable v s a)) -> Maybe (CircularVector v a)

-- | Execute the monadic action and freeze the resulting circular vector,
--   bypassing emptiness checks.
--   
--   The onus is on the caller to guarantee the created vector is
--   non-empty.
unsafeCreate :: Vector v a => (forall s. ST s (Mutable v s a)) -> CircularVector v a

-- | Execute the monadic action and freeze the resulting circular vector.
createT :: (Traversable t, Vector v a) => (forall s. ST s (t (Mutable v s a))) -> t (Maybe (CircularVector v a))

-- | Execute the monadic action and freeze the resulting circular vector.
--   
--   The onus is on the caller to guarantee the created vector is
--   non-empty.
unsafeCreateT :: (Traversable t, Vector v a) => (forall s. ST s (t (Mutable v s a))) -> t (CircularVector v a)

-- | <i>O(n)</i> Construct a circular vector by repeatedly applying the
--   generator function to a seed. The generator function yields
--   <a>Just</a> the next element and the new seed or <a>Nothing</a> if
--   there are no more elements.
--   
--   If an unfold does not create meaningful values, <a>Nothing</a> is
--   returned. Otherwise, <a>Just</a> containing a circular vector is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr @Vector (\b -&gt; case b of "a" -&gt; Just ("a", "b"); _ -&gt;  Nothing) "a"
--   Just (CircularVector {vector = ["a"], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr @Vector (const Nothing) "a"
--   Nothing
--   </pre>
unfoldr :: Vector v a => (b -> Maybe (a, b)) -> b -> Maybe (CircularVector v a)

-- | <i>O(n)</i> Construct a circular vector by repeatedly applying the
--   generator function to a seed and a first element.
--   
--   This variant of <a>unfoldr</a> guarantees the resulting vector is non-
--   empty by supplying an initial element <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr1 @Vector (\b -&gt; case b of "a" -&gt; Just ("a", "b"); _ -&gt;  Nothing) "first" "a"
--   CircularVector {vector = ["first","a"], rotation = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr1 @Vector (const Nothing) "first" "a"
--   CircularVector {vector = ["first"], rotation = 0}
--   </pre>
unfoldr1 :: Vector v a => (b -> Maybe (a, b)) -> a -> b -> CircularVector v a

-- | <i>O(n)</i> Construct a circular vector with at most n elements by
--   repeatedly applying the generator function to a seed. The generator
--   function yields <a>Just</a> the next element and the new seed or
--   <a>Nothing</a> if there are no more elements.
--   
--   If an unfold does not create meaningful values, <a>Nothing</a> is
--   returned. Otherwise, <a>Just</a> containing a circular vector is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; unfoldrN @Vector 3 (\b -&gt; Just (b+1, b+1)) 0
--   Just (CircularVector {vector = [1,2,3], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unfoldrN @Vector 3 (const Nothing) 0
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unfoldrN @Vector 0 (\b -&gt; Just (b+1, b+1)) 0
--   Nothing
--   </pre>
unfoldrN :: Vector v a => Int -> (b -> Maybe (a, b)) -> b -> Maybe (CircularVector v a)

-- | <i>O(n)</i> Construct a circular vector with at most n elements by
--   repeatedly applying the generator function to a seed. The generator
--   function yields <a>Just</a> the next element and the new seed or
--   <a>Nothing</a> if there are no more elements.
--   
--   This variant of <a>unfoldrN</a> guarantees the resulting vector is
--   non- empty by supplying an initial element <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr1N @Vector 3 (\b -&gt; Just (b+1, b+1)) 0 0
--   CircularVector {vector = [0,1,2,3], rotation = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr1N @Vector 3 (const Nothing) 0 0
--   CircularVector {vector = [0], rotation = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr1N @Vector 0 (\b -&gt; Just (b+1, b+1)) 0 0
--   CircularVector {vector = [0], rotation = 0}
--   </pre>
unfoldr1N :: Vector v a => Int -> (b -> Maybe (a, b)) -> a -> b -> CircularVector v a

-- | <i>O(n)</i> Construct a circular vector by repeatedly applying the
--   monadic generator function to a seed. The generator function yields
--   Just the next element and the new seed or Nothing if there are no more
--   elements.
--   
--   If an unfold does not create meaningful values, <a>Nothing</a> is
--   returned. Otherwise, <a>Just</a> containing a circular vector is
--   returned.
unfoldrM :: (Monad m, Vector v a) => (b -> m (Maybe (a, b))) -> b -> m (Maybe (CircularVector v a))

-- | <i>O(n)</i> Construct a circular vector by repeatedly applying the
--   monadic generator function to a seed. The generator function yields
--   Just the next element and the new seed or Nothing if there are no more
--   elements.
--   
--   This variant of <a>unfoldrM</a> guarantees the resulting vector is
--   non- empty by supplying an initial element <tt>a</tt>.
unfoldr1M :: (Monad m, Vector v a) => (b -> m (Maybe (a, b))) -> a -> b -> m (CircularVector v a)

-- | <i>O(n)</i> Construct a circular vector by repeatedly applying the
--   monadic generator function to a seed. The generator function yields
--   Just the next element and the new seed or Nothing if there are no more
--   elements.
--   
--   If an unfold does not create meaningful values, <a>Nothing</a> is
--   returned. Otherwise, <a>Just</a> containing a circular vector is
--   returned.
unfoldrNM :: (Monad m, Vector v a) => Int -> (b -> m (Maybe (a, b))) -> b -> m (Maybe (CircularVector v a))

-- | <i>O(n)</i> Construct a circular vector by repeatedly applying the
--   monadic generator function to a seed. The generator function yields
--   Just the next element and the new seed or Nothing if there are no more
--   elements.
--   
--   This variant of <a>unfoldrNM</a> guarantees the resulting vector is
--   non- empty by supplying an initial element <tt>a</tt>.
unfoldr1NM :: (Monad m, Vector v a) => Int -> (b -> m (Maybe (a, b))) -> a -> b -> m (CircularVector v a)

-- | <i>O(n)</i> Construct a circular vector with n elements by repeatedly
--   applying the generator function to the already constructed part of the
--   vector.
--   
--   If <a>constructN</a> does not create meaningful values, <a>Nothing</a>
--   is returned. Otherwise, <a>Just</a> containing a circular vector is
--   returned.
constructN :: Vector v a => Int -> (v a -> a) -> Maybe (CircularVector v a)

-- | <i>O(n)</i> Construct a circular vector with n elements from right to
--   left by repeatedly applying the generator function to the already
--   constructed part of the vector.
--   
--   If <a>constructrN</a> does not create meaningful values,
--   <a>Nothing</a> is returned. Otherwise, <a>Just</a> containing a
--   circular vector is returned.
constructrN :: Vector v a => Int -> (v a -> a) -> Maybe (CircularVector v a)

-- | <i>O(n)</i> Yield a circular vector of the given length containing the
--   values x, x+1 etc. This operation is usually more efficient than
--   <a>enumFromTo</a>.
--   
--   If an enumeration does not use meaningful indices, <a>Nothing</a> is
--   returned, otherwise, <a>Just</a> containing a circular vector.
enumFromN :: (Vector v a, Num a) => a -> Int -> Maybe (CircularVector v a)

-- | <i>O(n)</i> Yield a circular vector of length <tt>max n 1</tt>
--   containing the values x, x+1 etc. This operation is usually more
--   efficient than <a>enumFromTo</a>.
enumFromN1 :: (Vector v a, Num a) => a -> Int -> CircularVector v a

-- | <i>O(n)</i> Yield a circular vector of the given length containing the
--   values x, x+y, x+y+y etc. This operations is usually more efficient
--   than <a>enumFromThenTo</a>.
--   
--   If an enumeration does not use meaningful indices, <a>Nothing</a> is
--   returned, otherwise, <a>Just</a> containing a circular vector.
enumFromStepN :: (Vector v a, Num a) => a -> a -> Int -> Maybe (CircularVector v a)

-- | <i>O(n)</i> Yield a circular vector of length <tt>max n 1</tt>
--   containing the values x, x+y, x+y+y etc. This operations is usually
--   more efficient than <a>enumFromThenTo</a>.
enumFromStepN1 :: (Vector v a, Num a) => a -> a -> Int -> CircularVector v a

-- | <i>O(n)</i> Enumerate values from x to y.
--   
--   If an enumeration does not use meaningful indices, <a>Nothing</a> is
--   returned, otherwise, <a>Just</a> containing a circular vector.
--   
--   <i>WARNING</i>: This operation can be very inefficient. If at all
--   possible, use <a>enumFromN</a> instead.
enumFromTo :: (Vector v a, Enum a) => a -> a -> Maybe (CircularVector v a)

-- | <i>O(n)</i> Enumerate values from x to y with a specific step z.
--   
--   If an enumeration does not use meaningful indices, <a>Nothing</a> is
--   returned, otherwise, <a>Just</a> containing a circular vector.
--   
--   <i>WARNING</i>: This operation can be very inefficient. If at all
--   possible, use <a>enumFromStepN</a> instead.
enumFromThenTo :: (Vector v a, Enum a) => a -> a -> a -> Maybe (CircularVector v a)

-- | <i>O(n)</i> Prepend an element
--   
--   <pre>
--   &gt;&gt;&gt; cons 1 (unsafeFromList @Vector [2,3])
--   CircularVector {vector = [1,2,3], rotation = 0}
--   </pre>
cons :: Vector v a => a -> CircularVector v a -> CircularVector v a

-- | <i>O(n)</i> Prepend an element to a Vector
--   
--   <pre>
--   &gt;&gt;&gt; consV 1 (Data.Vector.fromList [2,3])
--   CircularVector {vector = [1,2,3], rotation = 0}
--   </pre>
consV :: Vector v a => a -> v a -> CircularVector v a

-- | <i>O(n)</i> Append an element
--   
--   <pre>
--   &gt;&gt;&gt; snoc (unsafeFromList @Vector [1,2]) 3
--   CircularVector {vector = [1,2,3], rotation = 0}
--   </pre>
snoc :: Vector v a => CircularVector v a -> a -> CircularVector v a

-- | <i>O(n)</i> Append an element to a Vector
--   
--   <pre>
--   &gt;&gt;&gt; snocV (Data.Vector.fromList [1,2]) 3
--   CircularVector {vector = [1,2,3], rotation = 0}
--   </pre>
snocV :: Vector v a => v a -> a -> CircularVector v a

-- | <i>O(m+n)</i> Concatenate two circular vectors
--   
--   <pre>
--   &gt;&gt;&gt; (unsafeFromList @Vector [1..3]) ++ (unsafeFromList [4..6])
--   CircularVector {vector = [1,2,3,4,5,6], rotation = 0}
--   </pre>
(++) :: Vector v a => CircularVector v a -> CircularVector v a -> CircularVector v a

-- | <i>O(n)</i> Concatenate all circular vectors in the list
--   
--   If list is empty, <a>Nothing</a> is returned, otherwise <a>Just</a>
--   containing the concatenated circular vectors
--   
--   <pre>
--   &gt;&gt;&gt; concat [(unsafeFromList @Vector [1..3]), (unsafeFromList [4..6])]
--   Just (CircularVector {vector = [1,2,3,4,5,6], rotation = 0})
--   </pre>
concat :: Vector v a => [CircularVector v a] -> Maybe (CircularVector v a)

-- | O(n) Concatenate all circular vectors in a non-empty list.
--   
--   <pre>
--   &gt;&gt;&gt; concat1 ((unsafeFromList @Vector [1..3]) :| [(unsafeFromList [4..6])])
--   CircularVector {vector = [1,2,3,4,5,6], rotation = 0}
--   </pre>
concat1 :: Vector v a => NonEmpty (CircularVector v a) -> CircularVector v a

-- | a variant of <a>deepseq</a> that is useful in some circumstances:
--   
--   <pre>
--   force x = x `deepseq` x
--   </pre>
--   
--   <tt>force x</tt> fully evaluates <tt>x</tt>, and then returns it. Note
--   that <tt>force x</tt> only performs evaluation when the value of
--   <tt>force x</tt> itself is demanded, so essentially it turns shallow
--   evaluation into deep evaluation.
--   
--   <a>force</a> can be conveniently used in combination with
--   <tt>ViewPatterns</tt>:
--   
--   <pre>
--   {-# LANGUAGE BangPatterns, ViewPatterns #-}
--   import Control.DeepSeq
--   
--   someFun :: ComplexData -&gt; SomeResult
--   someFun (force -&gt; !arg) = {- 'arg' will be fully evaluated -}
--   </pre>
--   
--   Another useful application is to combine <a>force</a> with
--   <a>evaluate</a> in order to force deep evaluation relative to other
--   <a>IO</a> operations:
--   
--   <pre>
--   import Control.Exception (evaluate)
--   import Control.DeepSeq
--   
--   main = do
--     result &lt;- evaluate $ force $ pureComputation
--     {- 'result' will be fully evaluated at this point -}
--     return ()
--   </pre>
--   
--   Finally, here's an exception safe variant of the <tt>readFile'</tt>
--   example:
--   
--   <pre>
--   readFile' :: FilePath -&gt; IO String
--   readFile' fn = bracket (openFile fn ReadMode) hClose $ \h -&gt;
--                          evaluate . force =&lt;&lt; hGetContents h
--   </pre>
force :: NFData a => a -> a

-- | <i>O(n)</i> Construct a <tt>Vector</tt> from a <a>CircularVector</a>.
--   
--   since 0.1.2
toVector :: Vector v a => CircularVector v a -> v a

-- | <i>O(1)</i> Construct a <a>CircularVector</a> from a vector.
--   
--   since 0.1.2
fromVector :: Vector v a => v a -> Maybe (CircularVector v a)

-- | <i>O(1)</i> Construct a <a>CircularVector</a> from a <tt>Vector</tt>.
--   
--   Calls <tt><a>error</a></tt> if the input vector is empty.
--   
--   since 0.1.2
unsafeFromVector :: Vector v a => v a -> CircularVector v a

-- | <i>O(n)</i> Construct a <a>NonEmptyVector</a> from a
--   <a>CircularVector</a>.
toNonEmptyVector :: Vector v a => CircularVector v a -> NonEmptyVector a

-- | <i>O(n)</i> Convert from a circular vector to a list.
--   
--   <pre>
--   &gt;&gt;&gt; let nev = unsafeFromList @Vector [1..3] in toList nev
--   [1,2,3]
--   </pre>
toList :: Vector v a => CircularVector v a -> [a]

-- | <i>O(n)</i> Construct a <a>CircularVector</a> from a list.
--   
--   since 0.1.2
fromList :: Vector v a => [a] -> Maybe (CircularVector v a)

-- | Construct a <a>CircularVector</a> from a list with a size hint.
--   
--   since 0.1.2
fromListN :: Vector v a => Int -> [a] -> Maybe (CircularVector v a)

-- | <i>O(n)</i> Construct a <a>CircularVector</a> from a list.
--   
--   Calls <tt><a>error</a></tt> if the input list is empty.
--   
--   since 0.1.2
unsafeFromList :: Vector v a => [a] -> CircularVector v a

-- | <i>O(n)</i> Construct a <a>CircularVector</a> from a list with a size
--   hint.
--   
--   Calls <tt><a>error</a></tt> if the input list is empty, or if the size
--   hint is <tt><a>&lt;=</a> 0</tt>.
--   
--   since 0.1.2
unsafeFromListN :: Vector v a => Int -> [a] -> CircularVector v a

-- | <i>O(1)</i> Rotate the vector to the left by <tt>n</tt> number of
--   elements.
--   
--   <i>Note</i>: Left rotations start to break down due to arithmetic
--   underflow when the size of the input vector is <tt><a>&gt;</a>
--   <a>maxBound</a> </tt><a>Int</a>@
--   
--   since 0.1.2
rotateLeft :: Vector v a => Int -> CircularVector v a -> CircularVector v a

-- | <i>O(1)</i> Rotate the vector to left by <tt>n</tt> number of
--   elements.
--   
--   <i>Note</i>: Right rotations start to break down due to arithmetic
--   overflow when the size of the input vector is <tt><a>&gt;</a>
--   <a>maxBound</a> </tt><a>Int</a>@
--   
--   since 0.1.2
rotateRight :: Vector v a => Int -> CircularVector v a -> CircularVector v a

-- | since 0.1.2
equivalent :: (Vector v a, Eq (v a), Ord a) => CircularVector v a -> CircularVector v a -> Bool

-- | since 0.1.2
canonise :: (Vector v a, Ord a) => CircularVector v a -> CircularVector v a

-- | since 0.1.2
leastRotation :: forall a. Ord a => NonEmptyVector a -> Int

-- | Lazily-accumulating monoidal fold over a <a>CircularVector</a>. since
--   0.1.2
foldMap :: (Monoid m, Vector v a) => (a -> m) -> CircularVector v a -> m

-- | Strictly-accumulating monoidal fold over a <a>CircularVector</a>.
--   
--   since 0.1.2
foldMap' :: (Monoid m, Vector v a) => (a -> m) -> CircularVector v a -> m

-- | since 0.1.2
foldr :: Vector v a => (a -> b -> b) -> b -> CircularVector v a -> b
foldl :: Vector v a => (b -> a -> b) -> b -> CircularVector v a -> b
foldr' :: Vector v a => (a -> b -> b) -> b -> CircularVector v a -> b
foldl' :: Vector v a => (b -> a -> b) -> b -> CircularVector v a -> b
foldr1 :: Vector v a => (a -> a -> a) -> CircularVector v a -> a
foldl1 :: Vector v a => (a -> a -> a) -> CircularVector v a -> a

-- | Lazily-accumulating semigroupoidal fold over a <a>CircularVector</a>.
--   
--   since 0.1.2
foldMap1 :: (Vector v a, Semigroup m) => (a -> m) -> CircularVector v a -> m

-- | Strictly-accumulating semigroupoidal fold over a
--   <a>CircularVector</a>.
--   
--   since 0.1.2
foldMap1' :: (Vector v a, Semigroup m) => (a -> m) -> CircularVector v a -> m

-- | since 0.1.2
toNonEmpty :: Vector v a => CircularVector v a -> NonEmpty a

-- | <i>O(n)</i> Check if all elements satisfy the predicate.
all :: Vector v a => (a -> Bool) -> CircularVector v a -> Bool

-- | <i>O(n)</i> Check if any element satisfies the predicate.
any :: Vector v a => (a -> Bool) -> CircularVector v a -> Bool

-- | <i>O(n)</i> Check if all elements are True.
and :: Vector v Bool => CircularVector v Bool -> Bool

-- | <i>O(n)</i> Check if any element is True.
or :: Vector v Bool => CircularVector v Bool -> Bool

-- | <i>O(n)</i> Compute the sum of the elements.
sum :: (Vector v a, Num a) => CircularVector v a -> a

-- | <i>O(n)</i> Compute the product of the elements.
product :: (Vector v a, Num a) => CircularVector v a -> a

-- | <i>O(n)</i> Yield the maximum element of the circular vector.
maximum :: (Vector v a, Ord a) => CircularVector v a -> a

-- | <i>O(n)</i> Yield the maximum element of a circular vector according
--   to the given comparison function.
maximumBy :: Vector v a => (a -> a -> Ordering) -> CircularVector v a -> a

-- | <i>O(n)</i> Yield the minimum element of the circular vector.
minimum :: (Vector v a, Ord a) => CircularVector v a -> a

-- | <i>O(n)</i> Yield the minimum element of a circular vector according
--   to the given comparison function.
minimumBy :: Vector v a => (a -> a -> Ordering) -> CircularVector v a -> a

-- | <i>O(n)</i> Rotate to the minimum element of the circular vector
--   according to the given comparison function.
rotateToMinimumBy :: Vector v a => (a -> a -> Ordering) -> CircularVector v a -> CircularVector v a

-- | <i>O(n)</i> Rotate to the maximum element of the circular vector
--   according to the given comparison function.
rotateToMaximumBy :: Vector v a => (a -> a -> Ordering) -> CircularVector v a -> CircularVector v a

-- | <i>O(1)</i> Index into a <a>CircularVector</a>. This is always total.
--   
--   since 0.1.2
index :: Vector v a => CircularVector v a -> Int -> a

-- | <i>O(1)</i> Get the first element of a <a>CircularVector</a>. This is
--   always total.
--   
--   since 0.1.2
head :: Vector v a => CircularVector v a -> a

-- | <i>O(1)</i> Get the last element of a <a>CircularVector</a>. This is
--   always total.
--   
--   since 0.1.2
last :: Vector v a => CircularVector v a -> a

-- | <i>O(n)</i> Map a function over a circular vector.
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) $ unsafeFromList @Vector [1..3]
--   CircularVector {vector = [2,3,4], rotation = 0}
--   </pre>
map :: (Vector v a, Vector v b) => (a -> b) -> CircularVector v a -> CircularVector v b

-- | <i>O(n)</i> Apply a function to every element of a circular vector and
--   its index.
--   
--   <pre>
--   &gt;&gt;&gt; imap (\i a -&gt; if i == 2 then a+1 else a+0) $ unsafeFromList @Vector [1..3]
--   CircularVector {vector = [1,2,4], rotation = 0}
--   </pre>
imap :: (Vector v a, Vector v b) => (Int -> a -> b) -> CircularVector v a -> CircularVector v b

-- | Map a function over a circular vector and concatenate the results.
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (\a -&gt; unsafeFromList @Vector [a,a]) (unsafeFromList [1,2,3])
--   CircularVector {vector = [1,1,2,2,3,3], rotation = 0}
--   </pre>
concatMap :: (Vector v a, Vector v b) => (a -> CircularVector v b) -> CircularVector v a -> CircularVector v b

-- | <i>O(n)</i> Apply the monadic action to all elements of the circular
--   vector, yielding circular vector of results.
--   
--   <pre>
--   &gt;&gt;&gt; mapM Just (unsafeFromList @Vector [1..3])
--   Just (CircularVector {vector = [1,2,3], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapM (const Nothing) (unsafeFromList @Vector [1..3])
--   Nothing
--   </pre>
mapM :: (Monad m, Vector v a, Vector v b) => (a -> m b) -> CircularVector v a -> m (CircularVector v b)

-- | <i>O(n)</i> Apply the monadic action to every element of a circular
--   vector and its index, yielding a circular vector of results.
--   
--   <pre>
--   &gt;&gt;&gt; imapM (\i a -&gt; if i == 1 then Just a else Just 0) (unsafeFromList @Vector [1..3])
--   Just (CircularVector {vector = [0,2,0], rotation = 0})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; imapM (\_ _ -&gt; Nothing) (unsafeFromList @Vector [1..3])
--   Nothing
--   </pre>
imapM :: (Monad m, Vector v a, Vector v b) => (Int -> a -> m b) -> CircularVector v a -> m (CircularVector v b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a circular
--   vector and ignore the results.
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ (const $ Just ()) (unsafeFromList @Vector [1..3])
--   Just ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ (const Nothing) (unsafeFromList @Vector [1..3])
--   Nothing
--   </pre>
mapM_ :: (Monad m, Vector v a, Vector v b) => (a -> m b) -> CircularVector v a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of a circular
--   vector and its index, ignoring the results
--   
--   <pre>
--   &gt;&gt;&gt; imapM_ (\i a -&gt; if i == 1 then print a else putStrLn "0") (unsafeFromList @Vector [1..3])
--   0
--   2
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; imapM_ (\_ _ -&gt; Nothing) (unsafeFromList @Vector [1..3])
--   Nothing
--   </pre>
imapM_ :: (Monad m, Vector v a) => (Int -> a -> m b) -> CircularVector v a -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the circular
--   vector, yielding a circular vector of results.
--   
--   Equivalent to <tt>flip <a>mapM</a></tt>.
forM :: (Monad m, Vector v a, Vector v b) => CircularVector v a -> (a -> m b) -> m (CircularVector v b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a circular
--   vector and ignore the results.
--   
--   Equivalent to <tt>flip <a>mapM_</a></tt>.
forM_ :: (Monad m, Vector v a) => CircularVector v a -> (a -> m b) -> m ()

-- | <i>O(min(m,n))</i> Zip two circular vectors with the given function.
zipWith :: (Vector v a, Vector v b, Vector v c) => (a -> b -> c) -> CircularVector v a -> CircularVector v b -> CircularVector v c

-- | Zip three circular vectors with the given function.
zipWith3 :: (Vector v a, Vector v b, Vector v c, Vector v d) => (a -> b -> c -> d) -> CircularVector v a -> CircularVector v b -> CircularVector v c -> CircularVector v d

-- | <i>O(min(n,m))</i> Elementwise pairing of circular vector elements.
--   This is a special case of <a>zipWith</a> where the function argument
--   is <tt>(,)</tt>
zip :: (Vector v a, Vector v b, Vector v (a, b)) => CircularVector v a -> CircularVector v b -> CircularVector v (a, b)

-- | Zip together three circular vectors.
zip3 :: (Vector v a, Vector v b, Vector v c, Vector v (a, b, c)) => CircularVector v a -> CircularVector v b -> CircularVector v c -> CircularVector v (a, b, c)

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | <i>O(n)</i> Drop repeated adjacent elements.
--   
--   <pre>
--   &gt;&gt;&gt; toList $ uniq $ unsafeFromList @Vector [1,1,2,2,3,3,1]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList $ uniq $ unsafeFromList @Vector [1,2,3,1]
--   [1,2,3]
--   </pre>
uniq :: (Vector v a, Eq a) => CircularVector v a -> CircularVector v a

-- | <i>O(n)</i> Drop elements when predicate returns Nothing
--   
--   If no elements satisfy the predicate, the resulting vector may be
--   empty.
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe (\a -&gt; if a == 2 then Nothing else Just a) (unsafeFromList @Vector [1..3])
--   [1,3]
--   </pre>
mapMaybe :: (Vector v a, Vector v b) => (a -> Maybe b) -> CircularVector v a -> v b

-- | <i>O(n)</i> Drop elements when predicate, applied to index and value,
--   returns Nothing
--   
--   If no elements satisfy the predicate, the resulting vector may be
--   empty.
--   
--   <pre>
--   &gt;&gt;&gt; imapMaybe (\i a -&gt; if a == 2 || i == 2 then Nothing else Just a) (unsafeFromList @Vector [1..3])
--   [1]
--   </pre>
imapMaybe :: (Vector v a, Vector v b) => (Int -> a -> Maybe b) -> CircularVector v a -> v b

-- | <i>O(n)</i>. <a>filter</a>, applied to a predicate and a list, returns
--   the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | <i>O(n)</i> Drop elements that do not satisfy the predicate which is
--   applied to values and their indices.
--   
--   If no elements satisfy the predicate, the resulting vector may be
--   empty.
--   
--   <pre>
--   &gt;&gt;&gt; ifilter (\i a -&gt; if a == 2 || i == 0 then False else True) (unsafeFromList @Vector [1..3])
--   [3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ifilter (\_ _ -&gt; False) (unsafeFromList @Vector [1..3])
--   []
--   </pre>
ifilter :: Vector v a => (Int -> a -> Bool) -> CircularVector v a -> v a

-- | <i>O(n)</i> Drop elements that do not satisfy the monadic predicate.
--   
--   If no elements satisfy the predicate, the resulting vector may be
--   empty.
--   
--   <pre>
--   &gt;&gt;&gt; filterM (\a -&gt; if a == 2 then Just False else Just True) (unsafeFromList @Vector [1..3])
--   Just [1,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filterM (\a -&gt; if a == 2 then Nothing else Just True) (unsafeFromList @Vector [1..3])
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filterM (const $ Just False) (unsafeFromList @Vector [1..3])
--   Just []
--   </pre>
filterM :: (Monad m, Vector v a) => (a -> m Bool) -> CircularVector v a -> m (v a)

-- | <i>O(n)</i> Yield the longest prefix of elements satisfying the
--   predicate without copying.
--   
--   If no elements satisfy the predicate, the resulting vector may be
--   empty.
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (/= 3) (unsafeFromList @Vector [1..3])
--   [1,2]
--   </pre>
takeWhile :: Vector v a => (a -> Bool) -> CircularVector v a -> v a

-- | <i>O(n)</i> Drop the longest prefix of elements that satisfy the
--   predicate without copying.
--   
--   If all elements satisfy the predicate, the resulting vector may be
--   empty.
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (/= 3) (unsafeFromList @Vector [1..3])
--   [3]
--   </pre>
dropWhile :: Vector v a => (a -> Bool) -> CircularVector v a -> v a

-- | <i>O(n)</i> Split the circular vector in two parts, the first one
--   containing those elements that satisfy the predicate and the second
--   one those that don't. The relative order of the elements is preserved
--   at the cost of a sometimes reduced performance compared to
--   <a>unstablePartition</a>.
--   
--   If all or no elements satisfy the predicate, one of the resulting
--   vectors may be empty.
--   
--   <pre>
--   &gt;&gt;&gt; partition (&lt; 3) (unsafeFromList @Vector [1..5])
--   ([1,2],[3,4,5])
--   </pre>
partition :: Vector v a => (a -> Bool) -> CircularVector v a -> (v a, v a)

-- | <i>O(n)</i> Split the circular vector in two parts, the first one
--   containing those elements that satisfy the predicate and the second
--   one those that don't. The order of the elements is not preserved but
--   the operation is often faster than <a>partition</a>.
--   
--   If all or no elements satisfy the predicate, one of the resulting
--   vectors may be empty.
unstablePartition :: Vector v a => (a -> Bool) -> CircularVector v a -> (v a, v a)

-- | <i>O(n)</i> Split the circular vector into the longest prefix of
--   elements that satisfy the predicate and the rest without copying.
--   
--   If all or no elements satisfy the predicate, one of the resulting
--   vectors may be empty.
--   
--   <pre>
--   &gt;&gt;&gt; span (== 1) (unsafeFromList @Vector [1,1,2,3,1])
--   ([1,1],[2,3,1])
--   </pre>
span :: Vector v a => (a -> Bool) -> CircularVector v a -> (v a, v a)

-- | <i>O(n)</i> Split the circular vector into the longest prefix of
--   elements that do not satisfy the predicate and the rest without
--   copying.
--   
--   If all or no elements satisfy the predicate, one of the resulting
--   vectors may be empty.
--   
--   <pre>
--   &gt;&gt;&gt; break (== 2) (unsafeFromList @Vector [1,1,2,3,1])
--   ([1,1],[2,3,1])
--   </pre>
break :: Vector v a => (a -> Bool) -> CircularVector v a -> (v a, v a)

-- | <i>O(n)</i> Check if the circular vector contains an element
--   
--   <pre>
--   &gt;&gt;&gt; elem 1 $ unsafeFromList @Vector [1..3]
--   True
--   
--   &gt;&gt;&gt; elem 4 $ unsafeFromList @Vector [1..3]
--   False
--   </pre>
elem :: (Vector v a, Eq a) => a -> CircularVector v a -> Bool

-- | <i>O(n)</i> Check if the circular vector does not contain an element
--   (inverse of <a>elem</a>)
--   
--   <pre>
--   &gt;&gt;&gt; notElem 1 $ unsafeFromList @Vector [1..3]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notElem 4 $ unsafeFromList @Vector [1..3]
--   True
--   </pre>
notElem :: (Vector v a, Eq a) => a -> CircularVector v a -> Bool

-- | <i>O(n)</i> Yield <a>Just</a> the first element matching the predicate
--   or <a>Nothing</a> if no such element exists.
--   
--   <pre>
--   &gt;&gt;&gt; find (&lt; 2) $ unsafeFromList @Vector [1..3]
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; find (&lt; 0) $ unsafeFromList @Vector [1..3]
--   Nothing
--   </pre>
find :: Vector v a => (a -> Bool) -> CircularVector v a -> Maybe a

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first element matching
--   the predicate or <a>Nothing</a> if no such element exists.
--   
--   <pre>
--   &gt;&gt;&gt; findIndex (&lt; 2) $ unsafeFromList @Vector [1..3]
--   Just 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findIndex (&lt; 0) $ unsafeFromList @Vector [1..3]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findIndex (==1) $ rotateRight 1 (unsafeFromList @Vector [1..3])
--   Just 2
--   </pre>
findIndex :: Vector v a => (a -> Bool) -> CircularVector v a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of elements satisfying the predicate in
--   ascending order.
--   
--   <pre>
--   &gt;&gt;&gt; findIndices (&lt; 3) $ unsafeFromList @Vector [1..3]
--   [0,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findIndices (&lt; 0) $ unsafeFromList @Vector [1..3]
--   []
--   </pre>
findIndices :: (Vector v a, Vector v Int) => (a -> Bool) -> CircularVector v a -> v Int

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first occurence of the
--   given element or <a>Nothing</a> if the circular vector does not
--   contain the element. This is a specialised version of
--   <a>findIndex</a>.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 1 $ unsafeFromList @Vector [1..3]
--   Just 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 0 $ unsafeFromList @Vector [1..3]
--   Nothing
--   </pre>
elemIndex :: (Vector v a, Eq a) => a -> CircularVector v a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of all occurences of the given element
--   in ascending order. This is a specialised version of
--   <a>findIndices</a>.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndices 1 $ unsafeFromList @Vector [1,2,3,1]
--   [0,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elemIndices 0 $ unsafeFromList @Vector [1..3]
--   []
--   </pre>
elemIndices :: (Vector v a, Vector v Int, Eq a) => a -> CircularVector v a -> v Int

-- | <i>O(n)</i> Reverse a circular vector.
reverse :: Vector v a => CircularVector v a -> CircularVector v a

-- | <i>O(n)</i> Yield the circular vector obtained by replacing each
--   element <tt>i</tt> of the circular index vector by
--   <tt>xs<tt>!</tt>i</tt>. This is equivalent to <tt><a>map</a>
--   (xs<tt>!</tt>) is</tt> but is often much more efficient.
--   
--   <pre>
--   &gt;&gt;&gt; toList $ backpermute @Vector (unsafeFromList @Vector [1..3]) (unsafeFromList @Vector [2,0])
--   [3,1]
--   </pre>
backpermute :: (Vector v a, Vector v Int) => CircularVector v a -> CircularVector v Int -> CircularVector v a

-- | Same as <a>backpermute</a> but without bounds checking.
unsafeBackpermute :: (Vector v a, Vector v Int) => CircularVector v a -> CircularVector v Int -> CircularVector v a

-- | Apply a destructive operation to a circular vector. The operation will
--   be performed in place if it is safe to do so and will modify a copy of
--   the circular vector otherwise.
modify :: Vector v a => (forall s. Mutable v s a -> ST s ()) -> CircularVector v a -> CircularVector v a

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   As of base 4.8.0.0, <a>sequence_</a> is just <a>sequenceA_</a>,
--   specialized to <a>Monad</a>.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
instance Control.DeepSeq.NFData (v a) => Control.DeepSeq.NFData (Data.Vector.Circular.Generic.CircularVector v a)
instance GHC.Show.Show (v a) => GHC.Show.Show (Data.Vector.Circular.Generic.CircularVector v a)
instance GHC.Read.Read (v a) => GHC.Read.Read (Data.Vector.Circular.Generic.CircularVector v a)
instance (Data.Vector.Generic.Base.Vector v a, GHC.Classes.Ord (v a), GHC.Classes.Eq a) => GHC.Classes.Ord (Data.Vector.Circular.Generic.CircularVector v a)
instance GHC.Generics.Generic (Data.Vector.Circular.Generic.CircularVector v a)
instance GHC.Base.Functor v => GHC.Base.Functor (Data.Vector.Circular.Generic.CircularVector v)
instance (Data.Vector.Generic.Base.Vector v a, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Vector.Circular.Generic.CircularVector v a)
instance Data.Vector.Generic.Base.Vector v a => GHC.Base.Semigroup (Data.Vector.Circular.Generic.CircularVector v a)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Data.Vector.Circular.Generic.CircularVector v a)
