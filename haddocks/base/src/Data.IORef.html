<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE Safe #-}</span><span>
</span><span id="line-2"></span><span>
</span><span id="line-3"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-4"></span><span class="hs-comment">--</span><span>
</span><span id="line-5"></span><span class="hs-comment">-- Module      :  Data.IORef</span><span>
</span><span id="line-6"></span><span class="hs-comment">-- Copyright   :  (c) The University of Glasgow 2001</span><span>
</span><span id="line-7"></span><span class="hs-comment">-- License     :  BSD-style (see the file libraries/base/LICENSE)</span><span>
</span><span id="line-8"></span><span class="hs-comment">--</span><span>
</span><span id="line-9"></span><span class="hs-comment">-- Maintainer  :  libraries@haskell.org</span><span>
</span><span id="line-10"></span><span class="hs-comment">-- Stability   :  stable</span><span>
</span><span id="line-11"></span><span class="hs-comment">-- Portability :  portable</span><span>
</span><span id="line-12"></span><span class="hs-comment">--</span><span>
</span><span id="line-13"></span><span class="hs-comment">-- Mutable references in the IO monad.</span><span>
</span><span id="line-14"></span><span class="hs-comment">--</span><span>
</span><span id="line-15"></span><span>
</span><span id="line-16"></span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Data.IORef.html"><span class="hs-identifier">Data.IORef</span></a></span><span>
</span><span id="line-17"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="hs-comment">-- *  IORefs</span></span><span>
</span><span id="line-18"></span><span>     </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.IORef.html#IORef"><span class="hs-identifier">IORef</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-19"></span><span>     </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.IORef.html#newIORef"><span class="hs-identifier">newIORef</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-20"></span><span>     </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.IORef.html#readIORef"><span class="hs-identifier">readIORef</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-21"></span><span>     </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.IORef.html#writeIORef"><span class="hs-identifier">writeIORef</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-22"></span><span>     </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Data.IORef.html#modifyIORef"><span class="hs-identifier">modifyIORef</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-23"></span><span>     </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Data.IORef.html#modifyIORef%27"><span class="hs-identifier">modifyIORef'</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-24"></span><span>     </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Data.IORef.html#atomicModifyIORef"><span class="hs-identifier">atomicModifyIORef</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-25"></span><span>     </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.IORef.html#atomicModifyIORef%27"><span class="hs-identifier">atomicModifyIORef'</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-26"></span><span>     </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Data.IORef.html#atomicWriteIORef"><span class="hs-identifier">atomicWriteIORef</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-27"></span><span>     </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Data.IORef.html#mkWeakIORef"><span class="hs-identifier">mkWeakIORef</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-28"></span><span>     </span><span class="annot"><span class="hs-comment">-- **  Memory Model</span></span><span>
</span><span id="line-29"></span><span>     </span><span class="annot"><span class="hs-comment">-- $memmodel</span></span><span>
</span><span id="line-30"></span><span>     </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-31"></span><span>
</span><span id="line-32"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Data.IORef.html"><span class="hs-identifier">GHC.Internal.Data.IORef</span></a></span><span>
</span><span id="line-33"></span><span>
</span><span id="line-34"></span><span class="annot"><span class="hs-comment">{- $memmodel
  #memmodel#

  Most modern CPU achitectures (e.g. x86/64, ARM) have a memory model which allows
  threads to reorder reads with earlier writes to different locations,
  e.g. see &lt;https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html the x86/64 architecture manual&gt;,
  8.2.3.4 Loads May Be Reordered with Earlier Stores to Different Locations.

  Because of that, in a concurrent program, 'IORef' operations may appear out-of-order
  to another thread. In the following example:

  &gt; import GHC.Internal.Data.IORef
  &gt; import GHC.Internal.Control.Monad (unless)
  &gt; import Control.Concurrent (forkIO, threadDelay)
  &gt;
  &gt; maybePrint :: IORef Bool -&gt; IORef Bool -&gt; IO ()
  &gt; maybePrint myRef yourRef = do
  &gt;   writeIORef myRef True
  &gt;   yourVal &lt;- readIORef yourRef
  &gt;   unless yourVal $ putStrLn &quot;critical section&quot;
  &gt;
  &gt; main :: IO ()
  &gt; main = do
  &gt;   r1 &lt;- newIORef False
  &gt;   r2 &lt;- newIORef False
  &gt;   forkIO $ maybePrint r1 r2
  &gt;   forkIO $ maybePrint r2 r1
  &gt;   threadDelay 1000000

  it is possible that the string @&quot;critical section&quot;@ is printed
  twice, even though there is no interleaving of the operations of the
  two threads that allows that outcome.  The memory model of x86/64
  allows 'readIORef' to happen before the earlier 'writeIORef'.

  The ARM memory order model is typically even weaker than x86/64, allowing
  any reordering of reads and writes as long as they are independent
  from the point of view of the current thread.

  The implementation is required to ensure that reordering of memory
  operations cannot cause type-correct code to go wrong.  In
  particular, when inspecting the value read from an 'IORef', the
  memory writes that created that value must have occurred from the
  point of view of the current thread.

  'atomicWriteIORef', 'atomicModifyIORef' and 'atomicModifyIORef'' act
  as a barrier to reordering. Multiple calls to these functions
  occur in strict program order, never taking place ahead of any
  earlier (in program order) 'IORef' operations, or after any later
  'IORef' operations.

-}</span></span><span>
</span><span id="line-85"></span></pre></body></html>