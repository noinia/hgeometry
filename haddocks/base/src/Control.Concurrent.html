<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE Trustworthy #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE CPP
           , MagicHash
           , UnboxedTuples
           , ScopedTypeVariables
           , RankNTypes
  #-}</span><span>
</span><span id="line-8"></span><span class="hs-pragma">{-# OPTIONS_GHC -Wno-deprecations #-}</span><span>
</span><span id="line-9"></span><span class="hs-comment">-- kludge for the Control.Concurrent.QSem, Control.Concurrent.QSemN</span><span>
</span><span id="line-10"></span><span class="hs-comment">-- and Control.Concurrent.SampleVar imports.</span><span>
</span><span id="line-11"></span><span>
</span><span id="line-12"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-13"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-14"></span><span class="hs-comment">-- Module      :  Control.Concurrent</span><span>
</span><span id="line-15"></span><span class="hs-comment">-- Copyright   :  (c) The University of Glasgow 2001</span><span>
</span><span id="line-16"></span><span class="hs-comment">-- License     :  BSD-style (see the file libraries/base/LICENSE)</span><span>
</span><span id="line-17"></span><span class="hs-comment">--</span><span>
</span><span id="line-18"></span><span class="hs-comment">-- Maintainer  :  libraries@haskell.org</span><span>
</span><span id="line-19"></span><span class="hs-comment">-- Stability   :  stable</span><span>
</span><span id="line-20"></span><span class="hs-comment">-- Portability :  non-portable (concurrency)</span><span>
</span><span id="line-21"></span><span class="hs-comment">--</span><span>
</span><span id="line-22"></span><span class="hs-comment">-- A common interface to a collection of useful concurrency</span><span>
</span><span id="line-23"></span><span class="hs-comment">-- abstractions.</span><span>
</span><span id="line-24"></span><span class="hs-comment">--</span><span>
</span><span id="line-25"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-26"></span><span>
</span><span id="line-27"></span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Control.Concurrent.html"><span class="hs-identifier">Control.Concurrent</span></a></span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-28"></span><span>        </span><span class="annot"><span class="hs-comment">-- * Concurrent Haskell</span></span><span>
</span><span id="line-29"></span><span>
</span><span id="line-30"></span><span>        </span><span class="annot"><span class="hs-comment">-- $conc_intro</span></span><span>
</span><span id="line-31"></span><span>
</span><span id="line-32"></span><span>        </span><span class="annot"><span class="hs-comment">-- * Basic concurrency operations</span></span><span>
</span><span id="line-33"></span><span>
</span><span id="line-34"></span><span>        </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Sync.html#ThreadId"><span class="hs-identifier">ThreadId</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-35"></span><span>        </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Sync.html#myThreadId"><span class="hs-identifier">myThreadId</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-36"></span><span>
</span><span id="line-37"></span><span>        </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Sync.html#forkIO"><span class="hs-identifier">forkIO</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-38"></span><span>        </span><span class="annot"><a href="Control.Concurrent.html#forkFinally"><span class="hs-identifier">forkFinally</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-39"></span><span>        </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Sync.html#forkIOWithUnmask"><span class="hs-identifier">forkIOWithUnmask</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-40"></span><span>        </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Sync.html#killThread"><span class="hs-identifier">killThread</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-41"></span><span>        </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Sync.html#throwTo"><span class="hs-identifier">throwTo</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-42"></span><span>
</span><span id="line-43"></span><span>        </span><span class="annot"><span class="hs-comment">-- ** Threads with affinity</span></span><span>
</span><span id="line-44"></span><span>        </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Sync.html#forkOn"><span class="hs-identifier">forkOn</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-45"></span><span>        </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Sync.html#forkOnWithUnmask"><span class="hs-identifier">forkOnWithUnmask</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-46"></span><span>        </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Sync.html#getNumCapabilities"><span class="hs-identifier">getNumCapabilities</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-47"></span><span>        </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Sync.html#setNumCapabilities"><span class="hs-identifier">setNumCapabilities</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-48"></span><span>        </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Sync.html#threadCapability"><span class="hs-identifier">threadCapability</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-49"></span><span>
</span><span id="line-50"></span><span>        </span><span class="annot"><span class="hs-comment">-- * Scheduling</span></span><span>
</span><span id="line-51"></span><span>
</span><span id="line-52"></span><span>        </span><span class="annot"><span class="hs-comment">-- $conc_scheduling</span></span><span>
</span><span id="line-53"></span><span>        </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Sync.html#yield"><span class="hs-identifier">yield</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-54"></span><span>
</span><span id="line-55"></span><span>        </span><span class="annot"><span class="hs-comment">-- ** Blocking</span></span><span>
</span><span id="line-56"></span><span>
</span><span id="line-57"></span><span>        </span><span class="annot"><span class="hs-comment">-- $blocking</span></span><span>
</span><span id="line-58"></span><span>
</span><span id="line-59"></span><span>        </span><span class="annot"><span class="hs-comment">-- ** Waiting</span></span><span>
</span><span id="line-60"></span><span>        </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.IO.html#threadDelay"><span class="hs-identifier">threadDelay</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-61"></span><span>        </span><span class="annot"><a href="Control.Concurrent.html#threadWaitRead"><span class="hs-identifier">threadWaitRead</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-62"></span><span>        </span><span class="annot"><a href="Control.Concurrent.html#threadWaitWrite"><span class="hs-identifier">threadWaitWrite</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-63"></span><span>        </span><span class="annot"><a href="Control.Concurrent.html#threadWaitReadSTM"><span class="hs-identifier">threadWaitReadSTM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-64"></span><span>        </span><span class="annot"><a href="Control.Concurrent.html#threadWaitWriteSTM"><span class="hs-identifier">threadWaitWriteSTM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-65"></span><span>
</span><span id="line-66"></span><span>        </span><span class="annot"><span class="hs-comment">-- * Communication abstractions</span></span><span>
</span><span id="line-67"></span><span>
</span><span id="line-68"></span><span>        </span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Control.Concurrent.MVar.html"><span class="hs-identifier">GHC.Internal.Control.Concurrent.MVar</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-69"></span><span>        </span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Control.Concurrent.Chan.html"><span class="hs-identifier">Control.Concurrent.Chan</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-70"></span><span>        </span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Control.Concurrent.QSem.html"><span class="hs-identifier">Control.Concurrent.QSem</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-71"></span><span>        </span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Control.Concurrent.QSemN.html"><span class="hs-identifier">Control.Concurrent.QSemN</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-72"></span><span>
</span><span id="line-73"></span><span>        </span><span class="annot"><span class="hs-comment">-- * Bound Threads</span></span><span>
</span><span id="line-74"></span><span>        </span><span class="annot"><span class="hs-comment">-- $boundthreads</span></span><span>
</span><span id="line-75"></span><span>        </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Bound.html#rtsSupportsBoundThreads"><span class="hs-identifier">rtsSupportsBoundThreads</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-76"></span><span>        </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Bound.html#forkOS"><span class="hs-identifier">forkOS</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-77"></span><span>        </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Bound.html#forkOSWithUnmask"><span class="hs-identifier">forkOSWithUnmask</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-78"></span><span>        </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Bound.html#isCurrentThreadBound"><span class="hs-identifier">isCurrentThreadBound</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-79"></span><span>        </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Bound.html#runInBoundThread"><span class="hs-identifier">runInBoundThread</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-80"></span><span>        </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Bound.html#runInUnboundThread"><span class="hs-identifier">runInUnboundThread</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-81"></span><span>
</span><span id="line-82"></span><span>        </span><span class="annot"><span class="hs-comment">-- * Weak references to ThreadIds</span></span><span>
</span><span id="line-83"></span><span>        </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Sync.html#mkWeakThreadId"><span class="hs-identifier">mkWeakThreadId</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-84"></span><span>
</span><span id="line-85"></span><span>        </span><span class="annot"><span class="hs-comment">-- * GHC's implementation of concurrency</span></span><span>
</span><span id="line-86"></span><span>
</span><span id="line-87"></span><span>        </span><span class="hs-comment">-- |This section describes features specific to GHC's</span><span>
</span><span id="line-88"></span><span>        </span><span class="hs-comment">-- implementation of Concurrent Haskell.</span><span>
</span><span id="line-89"></span><span>
</span><span id="line-90"></span><span>        </span><span class="annot"><span class="hs-comment">-- ** Haskell threads and Operating System threads</span></span><span>
</span><span id="line-91"></span><span>
</span><span id="line-92"></span><span>        </span><span class="annot"><span class="hs-comment">-- $osthreads</span></span><span>
</span><span id="line-93"></span><span>
</span><span id="line-94"></span><span>        </span><span class="annot"><span class="hs-comment">-- ** Terminating the program</span></span><span>
</span><span id="line-95"></span><span>
</span><span id="line-96"></span><span>        </span><span class="annot"><span class="hs-comment">-- $termination</span></span><span>
</span><span id="line-97"></span><span>
</span><span id="line-98"></span><span>        </span><span class="annot"><span class="hs-comment">-- ** Pre-emption</span></span><span>
</span><span id="line-99"></span><span>
</span><span id="line-100"></span><span>        </span><span class="annot"><span class="hs-comment">-- $preemption</span></span><span>
</span><span id="line-101"></span><span>
</span><span id="line-102"></span><span>        </span><span class="annot"><span class="hs-comment">-- ** Deadlock</span></span><span>
</span><span id="line-103"></span><span>
</span><span id="line-104"></span><span>        </span><span class="annot"><span class="hs-comment">-- $deadlock</span></span><span>
</span><span id="line-105"></span><span>
</span><span id="line-106"></span><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-107"></span><span>
</span><span id="line-108"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Prelude.html"><span class="hs-identifier">Prelude</span></a></span><span>
</span><span id="line-109"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Control.Exception.Base.html"><span class="hs-identifier">GHC.Internal.Control.Exception.Base</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Exception</span></span><span>
</span><span id="line-110"></span><span>
</span><span id="line-111"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Bound.html"><span class="hs-identifier">GHC.Internal.Conc.Bound</span></a></span><span>
</span><span id="line-112"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Conc.html"><span class="hs-identifier">GHC.Conc</span></a></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.IO.html#threadWaitRead"><span class="hs-identifier">threadWaitRead</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.IO.html#threadWaitWrite"><span class="hs-identifier">threadWaitWrite</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-113"></span><span>                        </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.IO.html#threadWaitReadSTM"><span class="hs-identifier">threadWaitReadSTM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.IO.html#threadWaitWriteSTM"><span class="hs-identifier">threadWaitWriteSTM</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-114"></span><span>
</span><span id="line-115"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.System.Posix.Types.html"><span class="hs-identifier">GHC.Internal.System.Posix.Types</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.System.Posix.Types.html#Fd"><span class="hs-identifier">Fd</span></a></span><span> </span><span class="hs-special">)</span><span class="hs-cpp">

#if defined(mingw32_HOST_OS)
</span><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">GHC.Internal.Foreign.C.Error</span><span>
</span><span id="line-119"></span><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">GHC.Internal.Foreign.C.Types</span><span>
</span><span id="line-120"></span><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">GHC.Internal.System.IO</span><span>
</span><span id="line-121"></span><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">GHC.Internal.Data.Functor</span><span> </span><span class="hs-special">(</span><span> </span><span class="hs-identifier">void</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-122"></span><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">GHC.Internal.Int</span><span> </span><span class="hs-special">(</span><span> </span><span class="hs-identifier">Int64</span><span> </span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.IO.html"><span class="hs-identifier">GHC.Internal.Conc.IO</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Conc</span></span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-127"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Control.Concurrent.MVar.html"><span class="hs-identifier">GHC.Internal.Control.Concurrent.MVar</span></a></span><span>
</span><span id="line-128"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Control.Concurrent.Chan.html"><span class="hs-identifier">Control.Concurrent.Chan</span></a></span><span>
</span><span id="line-129"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Control.Concurrent.QSem.html"><span class="hs-identifier">Control.Concurrent.QSem</span></a></span><span>
</span><span id="line-130"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Control.Concurrent.QSemN.html"><span class="hs-identifier">Control.Concurrent.QSemN</span></a></span><span>
</span><span id="line-131"></span><span>
</span><span id="line-132"></span><span class="annot"><span class="hs-comment">{- $conc_intro

The concurrency extension for Haskell is described in the paper
/Concurrent Haskell/
&lt;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&gt;.

Concurrency is \&quot;lightweight\&quot;, which means that both thread creation
and context switching overheads are extremely low.  Scheduling of
Haskell threads is done internally in the Haskell runtime system, and
doesn't make use of any operating system-supplied thread packages.

However, if you want to interact with a foreign library that expects your
program to use the operating system-supplied thread package, you can do so
by using 'forkOS' instead of 'forkIO'.

Haskell threads can communicate via 'MVar's, a kind of synchronised
mutable variable (see &quot;Control.Concurrent.MVar&quot;).  Several common
concurrency abstractions can be built from 'MVar's, and these are
provided by the &quot;Control.Concurrent&quot; module.
In GHC, threads may also communicate via exceptions.
-}</span></span><span>
</span><span id="line-153"></span><span>
</span><span id="line-154"></span><span class="annot"><span class="hs-comment">{- $conc_scheduling

    Scheduling may be either pre-emptive or co-operative,
    depending on the implementation of Concurrent Haskell (see below
    for information related to specific compilers).  In a co-operative
    system, context switches only occur when you use one of the
    primitives defined in this module.  This means that programs such
    as:


&gt;   main = forkIO (write 'a') &gt;&gt; write 'b'
&gt;     where write c = putChar c &gt;&gt; write c

    will print either @aaaaaaaaaaaaaa...@ or @bbbbbbbbbbbb...@,
    instead of some random interleaving of @a@s and @b@s.  In
    practice, cooperative multitasking is sufficient for writing
    simple graphical user interfaces.
-}</span></span><span>
</span><span id="line-172"></span><span>
</span><span id="line-173"></span><span class="annot"><span class="hs-comment">{- $blocking
Different Haskell implementations have different characteristics with
regard to which operations block /all/ threads.

Using GHC without the @-threaded@ option, all foreign calls will block
all other Haskell threads in the system, although I\/O operations will
not.  With the @-threaded@ option, only foreign calls with the @unsafe@
attribute will block all other threads.

-}</span></span><span>
</span><span id="line-183"></span><span>
</span><span id="line-184"></span><span class="hs-comment">-- | Fork a thread and call the supplied function when the thread is about</span><span>
</span><span id="line-185"></span><span class="hs-comment">-- to terminate, with an exception or a returned value.  The function is</span><span>
</span><span id="line-186"></span><span class="hs-comment">-- called with asynchronous exceptions masked.</span><span>
</span><span id="line-187"></span><span class="hs-comment">--</span><span>
</span><span id="line-188"></span><span class="hs-comment">-- &gt; forkFinally action and_then =</span><span>
</span><span id="line-189"></span><span class="hs-comment">-- &gt;   mask $ \restore -&gt;</span><span>
</span><span id="line-190"></span><span class="hs-comment">-- &gt;     forkIO $ try (restore action) &gt;&gt;= and_then</span><span>
</span><span id="line-191"></span><span class="hs-comment">--</span><span>
</span><span id="line-192"></span><span class="hs-comment">-- This function is useful for informing the parent when a child</span><span>
</span><span id="line-193"></span><span class="hs-comment">-- terminates, for example.</span><span>
</span><span id="line-194"></span><span class="hs-comment">--</span><span>
</span><span id="line-195"></span><span class="hs-comment">-- @since 4.6.0.0</span><span>
</span><span id="line-196"></span><span id="local-6989586621679162044"><span class="annot"><a href="Control.Concurrent.html#forkFinally"><span class="hs-identifier hs-type">forkFinally</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.13.0-e168/src/GHC.Types.html#IO"><span class="hs-identifier hs-type">IO</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679162044"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Data.Either.html#Either"><span class="hs-identifier hs-type">Either</span></a></span><span> </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Exception.Type.html#SomeException"><span class="hs-identifier hs-type">SomeException</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679162044"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.13.0-e168/src/GHC.Types.html#IO"><span class="hs-identifier hs-type">IO</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.13.0-e168/src/GHC.Types.html#IO"><span class="hs-identifier hs-type">IO</span></a></span><span> </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Sync.html#ThreadId"><span class="hs-identifier hs-type">ThreadId</span></a></span></span><span>
</span><span id="line-197"></span><span id="forkFinally"><span class="annot"><span class="annottext">forkFinally :: forall a. IO a -&gt; (Either SomeException a -&gt; IO ()) -&gt; IO ThreadId
</span><a href="Control.Concurrent.html#forkFinally"><span class="hs-identifier hs-var hs-var">forkFinally</span></a></span></span><span> </span><span id="local-6989586621679162095"><span class="annot"><span class="annottext">IO a
</span><a href="#local-6989586621679162095"><span class="hs-identifier hs-var">action</span></a></span></span><span> </span><span id="local-6989586621679162096"><span class="annot"><span class="annottext">Either SomeException a -&gt; IO ()
</span><a href="#local-6989586621679162096"><span class="hs-identifier hs-var">and_then</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-198"></span><span>  </span><span class="annot"><span class="annottext">((forall a. IO a -&gt; IO a) -&gt; IO ThreadId) -&gt; IO ThreadId
forall b. ((forall a. IO a -&gt; IO a) -&gt; IO b) -&gt; IO b
</span><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.IO.html#mask"><span class="hs-identifier hs-var">mask</span></a></span><span> </span><span class="annot"><span class="annottext">(((forall a. IO a -&gt; IO a) -&gt; IO ThreadId) -&gt; IO ThreadId)
-&gt; ((forall a. IO a -&gt; IO a) -&gt; IO ThreadId) -&gt; IO ThreadId
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679162098"><span class="annot"><span class="annottext">forall a. IO a -&gt; IO a
</span><a href="#local-6989586621679162098"><span class="hs-identifier hs-var">restore</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-199"></span><span>    </span><span class="annot"><span class="annottext">IO () -&gt; IO ThreadId
</span><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Sync.html#forkIO"><span class="hs-identifier hs-var">forkIO</span></a></span><span> </span><span class="annot"><span class="annottext">(IO () -&gt; IO ThreadId) -&gt; IO () -&gt; IO ThreadId
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">IO a -&gt; IO (Either SomeException a)
forall e a. Exception e =&gt; IO a -&gt; IO (Either e a)
</span><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Control.Exception.Base.html#try"><span class="hs-identifier hs-var">try</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IO a -&gt; IO a
forall a. IO a -&gt; IO a
</span><a href="#local-6989586621679162098"><span class="hs-identifier hs-var">restore</span></a></span><span> </span><span class="annot"><span class="annottext">IO a
</span><a href="#local-6989586621679162095"><span class="hs-identifier hs-var">action</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">IO (Either SomeException a)
-&gt; (Either SomeException a -&gt; IO ()) -&gt; IO ()
forall a b. IO a -&gt; (a -&gt; IO b) -&gt; IO b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Base.html#%3E%3E%3D"><span class="hs-operator hs-var">&gt;&gt;=</span></a></span><span> </span><span class="annot"><span class="annottext">Either SomeException a -&gt; IO ()
</span><a href="#local-6989586621679162096"><span class="hs-identifier hs-var">and_then</span></a></span><span>
</span><span id="line-200"></span><span>
</span><span id="line-201"></span><span class="hs-comment">-- ---------------------------------------------------------------------------</span><span>
</span><span id="line-202"></span><span class="hs-comment">-- Bound Threads</span><span>
</span><span id="line-203"></span><span>
</span><span id="line-204"></span><span class="annot"><span class="hs-comment">{- $boundthreads
   #boundthreads#

Support for multiple operating system threads and bound threads as described
below is currently only available in the GHC runtime system if you use the
/-threaded/ option when linking.

Other Haskell systems do not currently support multiple operating system threads.

A bound thread is a haskell thread that is /bound/ to an operating system
thread. While the bound thread is still scheduled by the Haskell run-time
system, the operating system thread takes care of all the foreign calls made
by the bound thread.

To a foreign library, the bound thread will look exactly like an ordinary
operating system thread created using OS functions like @pthread_create@
or @CreateThread@.

Bound threads can be created using the 'forkOS' function below. All foreign
exported functions are run in a bound thread (bound to the OS thread that
called the function). Also, the @main@ action of every Haskell program is
run in a bound thread.

Why do we need this? Because if a foreign library is called from a thread
created using 'forkIO', it won't have access to any /thread-local state/ -
state variables that have specific values for each OS thread
(see POSIX's @pthread_key_create@ or Win32's @TlsAlloc@). Therefore, some
libraries (OpenGL, for example) will not work from a thread created using
'forkIO'. They work fine in threads created using 'forkOS' or when called
from @main@ or from a @foreign export@.

In terms of performance, 'forkOS' (aka bound) threads are much more
expensive than 'forkIO' (aka unbound) threads, because a 'forkOS'
thread is tied to a particular OS thread, whereas a 'forkIO' thread
can be run by any OS thread.  Context-switching between a 'forkOS'
thread and a 'forkIO' thread is many times more expensive than between
two 'forkIO' threads.

Note in particular that the main program thread (the thread running
@Main.main@) is always a bound thread, so for good concurrency
performance you should ensure that the main thread is not doing
repeated communication with other threads in the system.  Typically
this means forking subthreads to do the work using 'forkIO', and
waiting for the results in the main thread.

-}</span></span><span>
</span><span id="line-250"></span><span>
</span><span id="line-251"></span><span class="hs-comment">-- ---------------------------------------------------------------------------</span><span>
</span><span id="line-252"></span><span class="hs-comment">-- threadWaitRead/threadWaitWrite</span><span>
</span><span id="line-253"></span><span>
</span><span id="line-254"></span><span class="hs-comment">-- | Block the current thread until data is available to read on the</span><span>
</span><span id="line-255"></span><span class="hs-comment">-- given file descriptor (GHC only).</span><span>
</span><span id="line-256"></span><span class="hs-comment">--</span><span>
</span><span id="line-257"></span><span class="hs-comment">-- This will throw an 'IOError' if the file descriptor was closed</span><span>
</span><span id="line-258"></span><span class="hs-comment">-- while this thread was blocked.  To safely close a file descriptor</span><span>
</span><span id="line-259"></span><span class="hs-comment">-- that has been used with 'threadWaitRead', use</span><span>
</span><span id="line-260"></span><span class="hs-comment">-- 'GHC.Conc.closeFdWith'.</span><span>
</span><span id="line-261"></span><span class="annot"><a href="Control.Concurrent.html#threadWaitRead"><span class="hs-identifier hs-type">threadWaitRead</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.System.Posix.Types.html#Fd"><span class="hs-identifier hs-type">Fd</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.13.0-e168/src/GHC.Types.html#IO"><span class="hs-identifier hs-type">IO</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-262"></span><span id="threadWaitRead"><span class="annot"><span class="annottext">threadWaitRead :: Fd -&gt; IO ()
</span><a href="Control.Concurrent.html#threadWaitRead"><span class="hs-identifier hs-var hs-var">threadWaitRead</span></a></span></span><span> </span><span id="local-6989586621679162102"><span class="annot"><span class="annottext">Fd
</span><a href="#local-6989586621679162102"><span class="hs-identifier hs-var">fd</span></a></span></span><span class="hs-cpp">
#if defined(mingw32_HOST_OS)
</span><span>  </span><span class="hs-comment">-- we have no IO manager implementing threadWaitRead on Windows.</span><span>
</span><span id="line-265"></span><span>  </span><span class="hs-comment">-- fdReady does the right thing, but we have to call it in a</span><span>
</span><span id="line-266"></span><span>  </span><span class="hs-comment">-- separate thread, otherwise threadWaitRead won't be interruptible,</span><span>
</span><span id="line-267"></span><span>  </span><span class="hs-comment">-- and this only works with -threaded.</span><span>
</span><span id="line-268"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">threaded</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">withThread</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">waitFd</span><span> </span><span class="hs-identifier">fd</span><span> </span><span class="hs-identifier">False</span><span class="hs-special">)</span><span>
</span><span id="line-269"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">otherwise</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">fd</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-270"></span><span>                  </span><span class="hs-number">0</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">hWaitForInput</span><span> </span><span class="hs-identifier">stdin</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">-</span><span class="hs-number">1</span><span class="hs-special">)</span><span>
</span><span id="line-271"></span><span>                          </span><span class="hs-identifier">return</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-272"></span><span>                        </span><span class="hs-comment">-- hWaitForInput does work properly, but we can only</span><span>
</span><span id="line-273"></span><span>                        </span><span class="hs-comment">-- do this for stdin since we know its FD.</span><span>
</span><span id="line-274"></span><span>                  </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">errorWithoutStackTrace</span><span> </span><span class="hs-string">&quot;threadWaitRead requires -threaded on Windows, or use GHC.System.IO.hWaitForInput&quot;</span><span class="hs-cpp">
#else
</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Fd -&gt; IO ()
</span><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.IO.html#threadWaitRead"><span class="hs-identifier hs-var">Conc.threadWaitRead</span></a></span><span> </span><span class="annot"><span class="annottext">Fd
</span><a href="#local-6989586621679162102"><span class="hs-identifier hs-var">fd</span></a></span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-279"></span><span class="hs-comment">-- | Block the current thread until data can be written to the</span><span>
</span><span id="line-280"></span><span class="hs-comment">-- given file descriptor (GHC only).</span><span>
</span><span id="line-281"></span><span class="hs-comment">--</span><span>
</span><span id="line-282"></span><span class="hs-comment">-- This will throw an 'IOError' if the file descriptor was closed</span><span>
</span><span id="line-283"></span><span class="hs-comment">-- while this thread was blocked.  To safely close a file descriptor</span><span>
</span><span id="line-284"></span><span class="hs-comment">-- that has been used with 'threadWaitWrite', use</span><span>
</span><span id="line-285"></span><span class="hs-comment">-- 'GHC.Conc.closeFdWith'.</span><span>
</span><span id="line-286"></span><span class="annot"><a href="Control.Concurrent.html#threadWaitWrite"><span class="hs-identifier hs-type">threadWaitWrite</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.System.Posix.Types.html#Fd"><span class="hs-identifier hs-type">Fd</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.13.0-e168/src/GHC.Types.html#IO"><span class="hs-identifier hs-type">IO</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-287"></span><span id="threadWaitWrite"><span class="annot"><span class="annottext">threadWaitWrite :: Fd -&gt; IO ()
</span><a href="Control.Concurrent.html#threadWaitWrite"><span class="hs-identifier hs-var hs-var">threadWaitWrite</span></a></span></span><span> </span><span id="local-6989586621679162103"><span class="annot"><span class="annottext">Fd
</span><a href="#local-6989586621679162103"><span class="hs-identifier hs-var">fd</span></a></span></span><span class="hs-cpp">
#if defined(mingw32_HOST_OS)
</span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">threaded</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">withThread</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">waitFd</span><span> </span><span class="hs-identifier">fd</span><span> </span><span class="hs-identifier">True</span><span class="hs-special">)</span><span>
</span><span id="line-290"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">otherwise</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">errorWithoutStackTrace</span><span> </span><span class="hs-string">&quot;threadWaitWrite requires -threaded on Windows&quot;</span><span class="hs-cpp">
#else
</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Fd -&gt; IO ()
</span><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.IO.html#threadWaitWrite"><span class="hs-identifier hs-var">Conc.threadWaitWrite</span></a></span><span> </span><span class="annot"><span class="annottext">Fd
</span><a href="#local-6989586621679162103"><span class="hs-identifier hs-var">fd</span></a></span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-295"></span><span class="hs-comment">-- | Returns an STM action that can be used to wait for data</span><span>
</span><span id="line-296"></span><span class="hs-comment">-- to read from a file descriptor. The second returned value</span><span>
</span><span id="line-297"></span><span class="hs-comment">-- is an IO action that can be used to deregister interest</span><span>
</span><span id="line-298"></span><span class="hs-comment">-- in the file descriptor.</span><span>
</span><span id="line-299"></span><span class="hs-comment">--</span><span>
</span><span id="line-300"></span><span class="hs-comment">-- @since 4.7.0.0</span><span>
</span><span id="line-301"></span><span class="annot"><a href="Control.Concurrent.html#threadWaitReadSTM"><span class="hs-identifier hs-type">threadWaitReadSTM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.System.Posix.Types.html#Fd"><span class="hs-identifier hs-type">Fd</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.13.0-e168/src/GHC.Types.html#IO"><span class="hs-identifier hs-type">IO</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Sync.html#STM"><span class="hs-identifier hs-type">STM</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.13.0-e168/src/GHC.Types.html#IO"><span class="hs-identifier hs-type">IO</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-302"></span><span id="threadWaitReadSTM"><span class="annot"><span class="annottext">threadWaitReadSTM :: Fd -&gt; IO (STM (), IO ())
</span><a href="Control.Concurrent.html#threadWaitReadSTM"><span class="hs-identifier hs-var hs-var">threadWaitReadSTM</span></a></span></span><span> </span><span id="local-6989586621679162104"><span class="annot"><span class="annottext">Fd
</span><a href="#local-6989586621679162104"><span class="hs-identifier hs-var">fd</span></a></span></span><span class="hs-cpp">
#if defined(mingw32_HOST_OS)
</span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">threaded</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-identifier">v</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">newTVarIO</span><span> </span><span class="hs-identifier">Nothing</span><span>
</span><span id="line-305"></span><span>                  </span><span class="hs-identifier">mask_</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">void</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">forkIO</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-identifier">result</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">try</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">waitFd</span><span> </span><span class="hs-identifier">fd</span><span> </span><span class="hs-identifier">False</span><span class="hs-special">)</span><span>
</span><span id="line-306"></span><span>                                             </span><span class="hs-identifier">atomically</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">writeTVar</span><span> </span><span class="hs-identifier">v</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">result</span><span class="hs-special">)</span><span>
</span><span id="line-307"></span><span>                  </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">waitAction</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-identifier">result</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">readTVar</span><span> </span><span class="hs-identifier">v</span><span>
</span><span id="line-308"></span><span>                                      </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">result</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-309"></span><span>                                        </span><span class="hs-identifier">Nothing</span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">retry</span><span>
</span><span id="line-310"></span><span>                                        </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Right</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">return</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-311"></span><span>                                        </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Left</span><span> </span><span class="hs-identifier">e</span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">throwSTM</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">e</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">IOException</span><span class="hs-special">)</span><span>
</span><span id="line-312"></span><span>                  </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">killAction</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">return</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-313"></span><span>                  </span><span class="hs-identifier">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">waitAction</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">killAction</span><span class="hs-special">)</span><span>
</span><span id="line-314"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">otherwise</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">errorWithoutStackTrace</span><span> </span><span class="hs-string">&quot;threadWaitReadSTM requires -threaded on Windows&quot;</span><span class="hs-cpp">
#else
</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Fd -&gt; IO (STM (), IO ())
</span><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.IO.html#threadWaitReadSTM"><span class="hs-identifier hs-var">Conc.threadWaitReadSTM</span></a></span><span> </span><span class="annot"><span class="annottext">Fd
</span><a href="#local-6989586621679162104"><span class="hs-identifier hs-var">fd</span></a></span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-319"></span><span class="hs-comment">-- | Returns an STM action that can be used to wait until data</span><span>
</span><span id="line-320"></span><span class="hs-comment">-- can be written to a file descriptor. The second returned value</span><span>
</span><span id="line-321"></span><span class="hs-comment">-- is an IO action that can be used to deregister interest</span><span>
</span><span id="line-322"></span><span class="hs-comment">-- in the file descriptor.</span><span>
</span><span id="line-323"></span><span class="hs-comment">--</span><span>
</span><span id="line-324"></span><span class="hs-comment">-- @since 4.7.0.0</span><span>
</span><span id="line-325"></span><span class="annot"><a href="Control.Concurrent.html#threadWaitWriteSTM"><span class="hs-identifier hs-type">threadWaitWriteSTM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.System.Posix.Types.html#Fd"><span class="hs-identifier hs-type">Fd</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.13.0-e168/src/GHC.Types.html#IO"><span class="hs-identifier hs-type">IO</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.Sync.html#STM"><span class="hs-identifier hs-type">STM</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.13.0-e168/src/GHC.Types.html#IO"><span class="hs-identifier hs-type">IO</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-326"></span><span id="threadWaitWriteSTM"><span class="annot"><span class="annottext">threadWaitWriteSTM :: Fd -&gt; IO (STM (), IO ())
</span><a href="Control.Concurrent.html#threadWaitWriteSTM"><span class="hs-identifier hs-var hs-var">threadWaitWriteSTM</span></a></span></span><span> </span><span id="local-6989586621679162105"><span class="annot"><span class="annottext">Fd
</span><a href="#local-6989586621679162105"><span class="hs-identifier hs-var">fd</span></a></span></span><span class="hs-cpp">
#if defined(mingw32_HOST_OS)
</span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">threaded</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-identifier">v</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">newTVarIO</span><span> </span><span class="hs-identifier">Nothing</span><span>
</span><span id="line-329"></span><span>                  </span><span class="hs-identifier">mask_</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">void</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">forkIO</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-identifier">result</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">try</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">waitFd</span><span> </span><span class="hs-identifier">fd</span><span> </span><span class="hs-identifier">True</span><span class="hs-special">)</span><span>
</span><span id="line-330"></span><span>                                             </span><span class="hs-identifier">atomically</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">writeTVar</span><span> </span><span class="hs-identifier">v</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">result</span><span class="hs-special">)</span><span>
</span><span id="line-331"></span><span>                  </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">waitAction</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-identifier">result</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">readTVar</span><span> </span><span class="hs-identifier">v</span><span>
</span><span id="line-332"></span><span>                                      </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">result</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-333"></span><span>                                        </span><span class="hs-identifier">Nothing</span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">retry</span><span>
</span><span id="line-334"></span><span>                                        </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Right</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">return</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-335"></span><span>                                        </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Left</span><span> </span><span class="hs-identifier">e</span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">throwSTM</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">e</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">IOException</span><span class="hs-special">)</span><span>
</span><span id="line-336"></span><span>                  </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">killAction</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">return</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-337"></span><span>                  </span><span class="hs-identifier">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">waitAction</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">killAction</span><span class="hs-special">)</span><span>
</span><span id="line-338"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">otherwise</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">errorWithoutStackTrace</span><span> </span><span class="hs-string">&quot;threadWaitWriteSTM requires -threaded on Windows&quot;</span><span class="hs-cpp">
#else
</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Fd -&gt; IO (STM (), IO ())
</span><a href="../../ghc-internal-9.1202.0-1465/src/GHC.Internal.Conc.IO.html#threadWaitWriteSTM"><span class="hs-identifier hs-var">Conc.threadWaitWriteSTM</span></a></span><span> </span><span class="annot"><span class="annottext">Fd
</span><a href="#local-6989586621679162105"><span class="hs-identifier hs-var">fd</span></a></span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">
#if defined(mingw32_HOST_OS)
</span><span class="hs-keyword">foreign</span><span> </span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">ccall</span><span> </span><span class="hs-keyword">unsafe</span><span> </span><span class="hs-string">&quot;rtsSupportsBoundThreads&quot;</span><span> </span><span class="hs-identifier">threaded</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Bool</span><span>
</span><span id="line-345"></span><span>
</span><span id="line-346"></span><span class="hs-identifier">withThread</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">IO</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">IO</span><span> </span><span class="hs-identifier">a</span><span>
</span><span id="line-347"></span><span class="hs-identifier">withThread</span><span> </span><span class="hs-identifier">io</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-348"></span><span>  </span><span class="hs-identifier">m</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">newEmptyMVar</span><span>
</span><span id="line-349"></span><span>  </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">mask_</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">forkIO</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">try</span><span> </span><span class="hs-identifier">io</span><span> </span><span class="hs-operator">&gt;&gt;=</span><span> </span><span class="hs-identifier">putMVar</span><span> </span><span class="hs-identifier">m</span><span>
</span><span id="line-350"></span><span>  </span><span class="hs-identifier">x</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">takeMVar</span><span> </span><span class="hs-identifier">m</span><span>
</span><span id="line-351"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">x</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-352"></span><span>    </span><span class="hs-identifier">Right</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">return</span><span> </span><span class="hs-identifier">a</span><span>
</span><span id="line-353"></span><span>    </span><span class="hs-identifier">Left</span><span> </span><span class="hs-identifier">e</span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">throwIO</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">e</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">IOException</span><span class="hs-special">)</span><span>
</span><span id="line-354"></span><span>
</span><span id="line-355"></span><span class="hs-identifier">waitFd</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Fd</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Bool</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">IO</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-356"></span><span class="hs-identifier">waitFd</span><span> </span><span class="hs-identifier">fd</span><span> </span><span class="hs-identifier">write</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-357"></span><span>   </span><span class="hs-identifier">throwErrnoIfMinus1_</span><span> </span><span class="hs-string">&quot;fdReady&quot;</span><span> </span><span class="hs-operator">$</span><span>
</span><span id="line-358"></span><span>        </span><span class="hs-identifier">fdReady</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">fromIntegral</span><span> </span><span class="hs-identifier">fd</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-keyword">if</span><span> </span><span class="hs-identifier">write</span><span> </span><span class="hs-keyword">then</span><span> </span><span class="hs-number">1</span><span> </span><span class="hs-keyword">else</span><span> </span><span class="hs-number">0</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">-</span><span class="hs-number">1</span><span class="hs-special">)</span><span> </span><span class="hs-number">0</span><span>
</span><span id="line-359"></span><span>
</span><span id="line-360"></span><span class="hs-keyword">foreign</span><span> </span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">ccall</span><span> </span><span class="hs-keyword">safe</span><span> </span><span class="hs-string">&quot;fdReady&quot;</span><span>
</span><span id="line-361"></span><span>  </span><span class="hs-identifier">fdReady</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">CInt</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">CBool</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Int64</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">CBool</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">IO</span><span> </span><span class="hs-identifier">CInt</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-364"></span><span class="hs-comment">-- ---------------------------------------------------------------------------</span><span>
</span><span id="line-365"></span><span class="hs-comment">-- More docs</span><span>
</span><span id="line-366"></span><span>
</span><span id="line-367"></span><span class="annot"><span class="hs-comment">{- $osthreads

      #osthreads# In GHC, threads created by 'forkIO' are lightweight threads, and
      are managed entirely by the GHC runtime.  Typically Haskell
      threads are an order of magnitude or two more efficient (in
      terms of both time and space) than operating system threads.

      The downside of having lightweight threads is that only one can
      run at a time, so if one thread blocks in a foreign call, for
      example, the other threads cannot continue.  The GHC runtime
      works around this by making use of full OS threads where
      necessary.  When the program is built with the @-threaded@
      option (to link against the multithreaded version of the
      runtime), a thread making a @safe@ foreign call will not block
      the other threads in the system; another OS thread will take
      over running Haskell threads until the original call returns.
      The runtime maintains a pool of these /worker/ threads so that
      multiple Haskell threads can be involved in external calls
      simultaneously.

      The &quot;System.IO&quot; module manages multiplexing in its own way.  On
      Windows systems it uses @safe@ foreign calls to ensure that
      threads doing I\/O operations don't block the whole runtime,
      whereas on Unix systems all the currently blocked I\/O requests
      are managed by a single thread (the /IO manager thread/) using
      a mechanism such as @epoll@ or @kqueue@, depending on what is
      provided by the host operating system.

      The runtime will run a Haskell thread using any of the available
      worker OS threads.  If you need control over which particular OS
      thread is used to run a given Haskell thread, perhaps because
      you need to call a foreign library that uses OS-thread-local
      state, then you need bound threads (see &quot;Control.Concurrent#boundthreads&quot;).

      If you don't use the @-threaded@ option, then the runtime does
      not make use of multiple OS threads.  Foreign calls will block
      all other running Haskell threads until the call returns.  The
      &quot;System.IO&quot; module still does multiplexing, so there can be multiple
      threads doing I\/O, and this is handled internally by the runtime using
      @select@.
-}</span></span><span>
</span><span id="line-408"></span><span>
</span><span id="line-409"></span><span class="annot"><span class="hs-comment">{- $termination

      In a standalone GHC program, only the main thread is
      required to terminate in order for the process to terminate.
      Thus all other forked threads will simply terminate at the same
      time as the main thread (the terminology for this kind of
      behaviour is \&quot;daemonic threads\&quot;).

      If you want the program to wait for child threads to
      finish before exiting, you need to program this yourself.  A
      simple mechanism is to have each child thread write to an
      'MVar' when it completes, and have the main
      thread wait on all the 'MVar's before
      exiting:

&gt;   myForkIO :: IO () -&gt; IO (MVar ())
&gt;   myForkIO io = do
&gt;     mvar &lt;- newEmptyMVar
&gt;     forkFinally io (\_ -&gt; putMVar mvar ())
&gt;     return mvar

      Note that we use 'forkFinally' to make sure that the
      'MVar' is written to even if the thread dies or
      is killed for some reason.

      A better method is to keep a global list of all child
      threads which we should wait for at the end of the program:

&gt;    children :: MVar [MVar ()]
&gt;    children = unsafePerformIO (newMVar [])
&gt;
&gt;    waitForChildren :: IO ()
&gt;    waitForChildren = do
&gt;      cs &lt;- takeMVar children
&gt;      case cs of
&gt;        []   -&gt; return ()
&gt;        m:ms -&gt; do
&gt;           putMVar children ms
&gt;           takeMVar m
&gt;           waitForChildren
&gt;
&gt;    forkChild :: IO () -&gt; IO ThreadId
&gt;    forkChild io = do
&gt;        mvar &lt;- newEmptyMVar
&gt;        childs &lt;- takeMVar children
&gt;        putMVar children (mvar:childs)
&gt;        forkFinally io (\_ -&gt; putMVar mvar ())
&gt;
&gt;     main =
&gt;       later waitForChildren $
&gt;       ...

      The main thread principle also applies to calls to Haskell from
      outside, using @foreign export@.  When the @foreign export@ed
      function is invoked, it starts a new main thread, and it returns
      when this main thread terminates.  If the call causes new
      threads to be forked, they may remain in the system after the
      @foreign export@ed function has returned.
-}</span></span><span>
</span><span id="line-468"></span><span>
</span><span id="line-469"></span><span class="annot"><span class="hs-comment">{- $preemption

      GHC implements pre-emptive multitasking: the execution of
      threads are interleaved in a random fashion.  More specifically,
      a thread may be pre-empted whenever it allocates some memory,
      which unfortunately means that tight loops which do no
      allocation tend to lock out other threads (this only seems to
      happen with pathological benchmark-style code, however).

      The rescheduling timer runs on a 20ms granularity by
      default, but this may be altered using the
      @-i\&lt;n\&gt;@ RTS option.  After a rescheduling
      \&quot;tick\&quot; the running thread is pre-empted as soon as
      possible.

      One final note: the
      @aaaa@ @bbbb@ example may not
      work too well on GHC (see Scheduling, above), due
      to the locking on a 'System.IO.Handle'.  Only one thread
      may hold the lock on a 'System.IO.Handle' at any one
      time, so if a reschedule happens while a thread is holding the
      lock, the other thread won't be able to run.  The upshot is that
      the switch from @aaaa@ to
      @bbbbb@ happens infrequently.  It can be
      improved by lowering the reschedule tick period.  We also have a
      patch that causes a reschedule whenever a thread waiting on a
      lock is woken up, but haven't found it to be useful for anything
      other than this example :-)
-}</span></span><span>
</span><span id="line-498"></span><span>
</span><span id="line-499"></span><span class="annot"><span class="hs-comment">{- $deadlock

GHC attempts to detect when threads are deadlocked using the garbage
collector.  A thread that is not reachable (cannot be found by
following pointers from live objects) must be deadlocked, and in this
case the thread is sent an exception.  The exception is either
'BlockedIndefinitelyOnMVar', 'BlockedIndefinitelyOnSTM',
'NonTermination', or 'Deadlock', depending on the way in which the
thread is deadlocked.

Note that this feature is intended for debugging, and should not be
relied on for the correct operation of your program.  There is no
guarantee that the garbage collector will be accurate enough to detect
your deadlock, and no guarantee that the garbage collector will run in
a timely enough manner.  Basically, the same caveats as for finalizers
apply to deadlock detection.

There is a subtle interaction between deadlock detection and
finalizers (as created by 'GHC.Foreign.Concurrent.newForeignPtr' or the
functions in &quot;System.Mem.Weak&quot;): if a thread is blocked waiting for a
finalizer to run, then the thread will be considered deadlocked and
sent an exception.  So preferably don't do this, but if you have no
alternative then it is possible to prevent the thread from being
considered deadlocked by making a 'StablePtr' pointing to it.  Don't
forget to release the 'StablePtr' later with 'freeStablePtr'.
-}</span></span><span>
</span><span id="line-525"></span></pre></body></html>