-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The library supporting GHC's interactive interpreter
--   
--   This library offers interfaces which mediate interactions between the
--   <tt>ghci</tt> interactive shell and <tt>iserv</tt>, GHC's
--   out-of-process interpreter backend.
@package ghci
@version 9.12.2


-- | Efficient serialisation for GHCi Instruction arrays
--   
--   Author: Ben Gamari
module GHCi.BinaryArray

-- | An efficient serialiser of <a>UArray</a>.
putArray :: Binary i => UArray i a -> Put

-- | An efficient deserialiser of <a>UArray</a>.
getArray :: (Binary i, Ix i, MArray IOUArray a IO) => Get (UArray i a)


-- | Break Arrays
--   
--   An array of words, indexed by a breakpoint number (breakpointId in
--   Tickish) containing the ignore count for every breakpoint. There is
--   one of these arrays per module.
--   
--   For each word with value n: n &gt; 1 : the corresponding breakpoint is
--   enabled. Next time the bp is hit, GHCi will decrement the ignore count
--   and continue processing. n == 0 : The breakpoint is enabled, GHCi will
--   stop next time it hits this breakpoint. n == -1: This breakpoint is
--   disabled. n &lt; -1 : Not used.
module GHCi.BreakArray
data BreakArray
BA :: MutableByteArray# RealWorld -> BreakArray
newBreakArray :: Int -> IO BreakArray
getBreak :: BreakArray -> Int -> IO (Maybe Int)
setupBreakpoint :: BreakArray -> Int -> Int -> IO Bool
breakOn :: Int
breakOff :: Int
showBreakArray :: BreakArray -> IO ()

module GHCi.FFI
data FFIType
FFIVoid :: FFIType
FFIPointer :: FFIType
FFIFloat :: FFIType
FFIDouble :: FFIType
FFISInt8 :: FFIType
FFISInt16 :: FFIType
FFISInt32 :: FFIType
FFISInt64 :: FFIType
FFIUInt8 :: FFIType
FFIUInt16 :: FFIType
FFIUInt32 :: FFIType
FFIUInt64 :: FFIType
data C_ffi_cif
prepForeignCall :: [FFIType] -> FFIType -> IO (Ptr C_ffi_cif)
freeForeignCallInfo :: Ptr C_ffi_cif -> IO ()
instance Data.Binary.Class.Binary GHCi.FFI.FFIType
instance GHC.Internal.Generics.Generic GHCi.FFI.FFIType
instance GHC.Internal.Show.Show GHCi.FFI.FFIType


-- | Run-time info table support. This module provides support for creating
--   and reading info tables <i>in the running program</i>. We use the RTS
--   data structures directly via hsc2hs.
module GHCi.InfoTable
mkConInfoTable :: Bool -> Int -> Int -> Int -> Int -> ByteString -> IO (Ptr StgInfoTable)


-- | Types for referring to remote objects in Remote GHCi. For more
--   details, see Note [External GHCi pointers] in
--   compiler<i>GHC</i>Runtime/Interpreter.hs
--   
--   For details on Remote GHCi, see Note [Remote GHCi] in
--   compiler<i>GHC</i>Runtime/Interpreter.hs.
module GHCi.RemoteTypes
newtype RemotePtr a
RemotePtr :: Word64 -> RemotePtr a
toRemotePtr :: Ptr a -> RemotePtr a
fromRemotePtr :: RemotePtr a -> Ptr a
castRemotePtr :: RemotePtr a -> RemotePtr b

-- | A reference to a heap object. Potentially in a remote heap! These are
--   allocated and freed explicitly.
newtype RemoteRef a
RemoteRef :: RemotePtr () -> RemoteRef a

-- | Make a reference to a local value that we can send remotely. This
--   reference will keep the value that it refers to alive until
--   <a>freeRemoteRef</a> is called.
mkRemoteRef :: a -> IO (RemoteRef a)

-- | Convert a RemoteRef to its carried type. Should only be used if the
--   RemoteRef originated in this process.
localRef :: RemoteRef a -> IO a

-- | Release a RemoteRef that originated in this process
freeRemoteRef :: RemoteRef a -> IO ()
castRemoteRef :: RemoteRef a -> RemoteRef b

-- | An RemoteRef with a finalizer
data ForeignRef a

-- | Create a <a>ForeignRef</a> from a <a>RemoteRef</a>. The finalizer
--   should arrange to call <a>freeRemoteRef</a> on the <a>RemoteRef</a>.
--   (since this function needs to be called in the process that created
--   the <a>RemoteRef</a>, it cannot be called directly from the
--   finalizer).
mkForeignRef :: RemoteRef a -> IO () -> IO (ForeignRef a)

-- | Use a <a>ForeignRef</a>
withForeignRef :: ForeignRef a -> (RemoteRef a -> IO b) -> IO b
finalizeForeignRef :: ForeignRef a -> IO ()
castForeignRef :: ForeignRef a -> ForeignRef b
unsafeForeignRefToRemoteRef :: ForeignRef a -> RemoteRef a
newtype HValue
HValue :: (Any :: Type) -> HValue
type HValueRef = RemoteRef HValue
type ForeignHValue = ForeignRef HValue
instance Data.Binary.Class.Binary (GHCi.RemoteTypes.RemotePtr a)
instance Data.Binary.Class.Binary (GHCi.RemoteTypes.RemoteRef a)
instance Control.DeepSeq.NFData (GHCi.RemoteTypes.ForeignRef a)
instance Control.DeepSeq.NFData (GHCi.RemoteTypes.RemotePtr a)
instance GHC.Internal.Show.Show GHCi.RemoteTypes.HValue
instance GHC.Internal.Show.Show (GHCi.RemoteTypes.RemotePtr a)
instance GHC.Internal.Show.Show (GHCi.RemoteTypes.RemoteRef a)

module GHCi.ResolvedBCO

-- | A <a>ResolvedBCO</a> is one in which all the <tt>Name</tt> references
--   have been resolved to actual addresses or <tt>RemoteHValues</tt>.
data ResolvedBCO
ResolvedBCO :: Bool -> {-# UNPACK #-} !Int -> BCOByteArray Word16 -> BCOByteArray Word -> BCOByteArray Word -> SizedSeq ResolvedBCOPtr -> ResolvedBCO
[resolvedBCOIsLE] :: ResolvedBCO -> Bool
[resolvedBCOArity] :: ResolvedBCO -> {-# UNPACK #-} !Int
[resolvedBCOInstrs] :: ResolvedBCO -> BCOByteArray Word16
[resolvedBCOBitmap] :: ResolvedBCO -> BCOByteArray Word
[resolvedBCOLits] :: ResolvedBCO -> BCOByteArray Word
[resolvedBCOPtrs] :: ResolvedBCO -> SizedSeq ResolvedBCOPtr
data ResolvedBCOPtr

-- | reference to the Nth BCO in the current set
ResolvedBCORef :: {-# UNPACK #-} !Int -> ResolvedBCOPtr

-- | reference to a previously created BCO
ResolvedBCOPtr :: {-# UNPACK #-} !RemoteRef HValue -> ResolvedBCOPtr

-- | reference to a static ptr
ResolvedBCOStaticPtr :: {-# UNPACK #-} !RemotePtr () -> ResolvedBCOPtr

-- | a nested BCO
ResolvedBCOPtrBCO :: ResolvedBCO -> ResolvedBCOPtr

-- | Resolves to the MutableArray# inside the BreakArray
ResolvedBCOPtrBreakArray :: {-# UNPACK #-} !RemoteRef BreakArray -> ResolvedBCOPtr
isLittleEndian :: Bool

-- | Wrapper for a <a>ByteArray#</a>. The phantom type tells what elements
--   are stored in the <a>ByteArray#</a>. Creating a <a>ByteArray#</a> can
--   be achieved using <tt>UArray'</tt>s API, where the underlying
--   <a>ByteArray#</a> can be unpacked.
data BCOByteArray a
BCOByteArray :: !ByteArray# -> BCOByteArray a
[getBCOByteArray] :: BCOByteArray a -> !ByteArray#
mkBCOByteArray :: UArray Int a -> BCOByteArray a
instance (Data.Binary.Class.Binary a, GHC.Internal.Foreign.Storable.Storable a, Data.Array.Base.IArray Data.Array.Base.UArray a) => Data.Binary.Class.Binary (GHCi.ResolvedBCO.BCOByteArray a)
instance Data.Binary.Class.Binary GHCi.ResolvedBCO.ResolvedBCO
instance Data.Binary.Class.Binary GHCi.ResolvedBCO.ResolvedBCOPtr
instance GHC.Internal.Generics.Generic GHCi.ResolvedBCO.ResolvedBCO
instance GHC.Internal.Generics.Generic GHCi.ResolvedBCO.ResolvedBCOPtr
instance GHC.Internal.Show.Show (GHCi.ResolvedBCO.BCOByteArray GHC.Internal.Word.Word16)
instance GHC.Internal.Show.Show (GHCi.ResolvedBCO.BCOByteArray GHC.Types.Word)
instance GHC.Internal.Show.Show GHCi.ResolvedBCO.ResolvedBCO
instance GHC.Internal.Show.Show GHCi.ResolvedBCO.ResolvedBCOPtr


-- | Create real byte-code objects from <a>ResolvedBCO</a>s.
module GHCi.CreateBCO
createBCOs :: [ResolvedBCO] -> IO [HValueRef]

module GHCi.Signals

-- | Install standard signal handlers for catching ^C, which just throw an
--   exception in the target thread. The current target thread is the
--   thread at the head of the list in the MVar passed to
--   installSignalHandlers.
installSignalHandlers :: IO ()

module GHCi.StaticPtrTable

-- | Used by GHCi to add an SPT entry for a set of interactive bindings.
sptAddEntry :: Fingerprint -> HValue -> IO ()

module GHCi.TH.Binary
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.AnnLookup
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.AnnTarget
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Bang
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.BndrVis
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Body
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Bytes
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Callconv
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Clause
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Con
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Dec
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.DecidedStrictness
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.DerivClause
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.DerivStrategy
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.DocLoc
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Exp
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.FamilyResultSig
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Fixity
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.FixityDirection
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Foreign
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.FunDep
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Guard
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Info
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.InjectivityAnn
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Inline
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Lit
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Loc
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Match
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.ModName
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Module
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.ModuleInfo
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Name
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.NameFlavour
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.NameSpace
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.NamespaceSpecifier
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.OccName
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Overlap
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Pat
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.PatSynArgs
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.PatSynDir
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Phases
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.PkgName
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Pragma
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Range
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Role
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.RuleBndr
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.RuleMatch
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Safety
instance Data.Binary.Class.Binary GHC.Serialized.Serialized
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.SourceStrictness
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.SourceUnpackedness
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Specificity
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Stmt
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.TyLit
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.TySynEqn
instance Data.Binary.Class.Binary flag => Data.Binary.Class.Binary (GHC.Internal.TH.Syntax.TyVarBndr flag)
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.Type
instance Data.Binary.Class.Binary GHC.Internal.TH.Syntax.TypeFamilyHead


-- | Remote GHCi message types and serialization.
--   
--   For details on Remote GHCi, see Note [Remote GHCi] in
--   compiler<i>GHC</i>Runtime/Interpreter.hs.
module GHCi.Message

-- | A <tt>Message a</tt> is a message that returns a value of type
--   <tt>a</tt>. These are requests sent from GHC to the server.
data Message a

-- | Exit the iserv process
[Shutdown] :: Message ()
[RtsRevertCAFs] :: Message ()
[InitLinker] :: Message ()
[LookupSymbol] :: String -> Message (Maybe (RemotePtr ()))
[LookupSymbolInDLL] :: RemotePtr LoadedDLL -> String -> Message (Maybe (RemotePtr ()))
[LookupClosure] :: String -> Message (Maybe HValueRef)
[LoadDLL] :: String -> Message (Either String (RemotePtr LoadedDLL))
[LoadArchive] :: String -> Message ()
[LoadObj] :: String -> Message ()
[UnloadObj] :: String -> Message ()
[AddLibrarySearchPath] :: String -> Message (RemotePtr ())
[RemoveLibrarySearchPath] :: RemotePtr () -> Message Bool
[ResolveObjs] :: Message Bool
[FindSystemLibrary] :: String -> Message (Maybe String)

-- | Create a set of BCO objects, and return HValueRefs to them See
--   <tt>createBCOs</tt> in compiler<i>GHC</i>Runtime/Interpreter.hs. NB:
--   this has a custom Binary behavior, see Note [Parallelize CreateBCOs
--   serialization]
[CreateBCOs] :: [ResolvedBCO] -> Message [HValueRef]

-- | Release <a>HValueRef</a>s
[FreeHValueRefs] :: [HValueRef] -> Message ()

-- | Add entries to the Static Pointer Table
[AddSptEntry] :: Fingerprint -> HValueRef -> Message ()

-- | Malloc some data and return a <a>RemotePtr</a> to it
[MallocData] :: ByteString -> Message (RemotePtr ())
[MallocStrings] :: [ByteString] -> Message [RemotePtr ()]

-- | Calls <a>prepareForeignCall</a>
[PrepFFI] :: [FFIType] -> FFIType -> Message (RemotePtr C_ffi_cif)

-- | Free data previously created by <a>PrepFFI</a>
[FreeFFI] :: RemotePtr C_ffi_cif -> Message ()

-- | Create an info table for a constructor
[MkConInfoTable] :: Bool -> Int -> Int -> Int -> Int -> ByteString -> Message (RemotePtr StgInfoTable)

-- | Evaluate a statement
[EvalStmt] :: EvalOpts -> EvalExpr HValueRef -> Message (EvalStatus_ [HValueRef] [HValueRef])

-- | Resume evaluation of a statement after a breakpoint
[ResumeStmt] :: EvalOpts -> RemoteRef (ResumeContext [HValueRef]) -> Message (EvalStatus_ [HValueRef] [HValueRef])

-- | Abandon evaluation of a statement after a breakpoint
[AbandonStmt] :: RemoteRef (ResumeContext [HValueRef]) -> Message ()

-- | Evaluate something of type <tt>IO String</tt>
[EvalString] :: HValueRef -> Message (EvalResult String)

-- | Evaluate something of type <tt>String -&gt; IO String</tt>
[EvalStringToString] :: HValueRef -> String -> Message (EvalResult String)

-- | Evaluate something of type <tt>IO ()</tt>
[EvalIO] :: HValueRef -> Message (EvalResult ())

-- | Create a set of CostCentres with the same module name
[MkCostCentres] :: String -> [(String, String)] -> Message [RemotePtr CostCentre]

-- | Show a <a>CostCentreStack</a> as a <tt>[String]</tt>
[CostCentreStackInfo] :: RemotePtr CostCentreStack -> Message [String]

-- | Create a new array of breakpoint flags
[NewBreakArray] :: Int -> Message (RemoteRef BreakArray)

-- | Set how many times a breakpoint should be ignored also used for
--   enable/disable
[SetupBreakpoint] :: RemoteRef BreakArray -> Int -> Int -> Message ()

-- | Query the status of a breakpoint (True <a>=</a> enabled)
[BreakpointStatus] :: RemoteRef BreakArray -> Int -> Message Bool

-- | Get a reference to a free variable at a breakpoint
[GetBreakpointVar] :: HValueRef -> Int -> Message (Maybe HValueRef)

-- | Start a new TH module, return a state token that should be
[StartTH] :: Message (RemoteRef (IORef QState))

-- | Evaluate a TH computation.
--   
--   Returns a ByteString, because we have to force the result before
--   returning it to ensure there are no errors lurking in it. The TH types
--   don't have NFData instances, and even if they did, we have to
--   serialize the value anyway, so we might as well serialize it to force
--   it.
[RunTH] :: RemoteRef (IORef QState) -> HValueRef -> THResultType -> Maybe Loc -> Message (QResult ByteString)

-- | Run the given mod finalizers.
[RunModFinalizers] :: RemoteRef (IORef QState) -> [RemoteRef (Q ())] -> Message (QResult ())

-- | Remote interface to GHC.Exts.Heap.getClosureData. This is used by the
--   GHCi debugger to inspect values in the heap for :print and type
--   reconstruction.
[GetClosure] :: HValueRef -> Message (GenClosure HValueRef)

-- | Evaluate something. This is used to support :force in GHCi.
[Seq] :: HValueRef -> Message (EvalStatus_ () ())

-- | Resume forcing a free variable in a breakpoint (#2950)
[ResumeSeq] :: RemoteRef (ResumeContext ()) -> Message (EvalStatus_ () ())

-- | Allocate a string for a breakpoint module name. This uses an empty
--   dummy type because <tt>ModuleName</tt> isn't available here.
[NewBreakModule] :: String -> Message (RemotePtr BreakModule)
data Msg
Msg :: Message a -> Msg

-- | Messages sent back to GHC from GHCi.TH, to implement the methods of
--   <tt>Quasi</tt>. For an overview of how TH works with Remote GHCi, see
--   Note [Remote Template Haskell] in GHCi.TH.
data THMessage a
[NewName] :: String -> THMessage (THResult Name)
[Report] :: Bool -> String -> THMessage (THResult ())
[LookupName] :: Bool -> String -> THMessage (THResult (Maybe Name))
[Reify] :: Name -> THMessage (THResult Info)
[ReifyFixity] :: Name -> THMessage (THResult (Maybe Fixity))
[ReifyType] :: Name -> THMessage (THResult Type)
[ReifyInstances] :: Name -> [Type] -> THMessage (THResult [Dec])
[ReifyRoles] :: Name -> THMessage (THResult [Role])
[ReifyAnnotations] :: AnnLookup -> TypeRep -> THMessage (THResult [ByteString])
[ReifyModule] :: Module -> THMessage (THResult ModuleInfo)
[ReifyConStrictness] :: Name -> THMessage (THResult [DecidedStrictness])
[GetPackageRoot] :: THMessage (THResult FilePath)
[AddDependentFile] :: FilePath -> THMessage (THResult ())
[AddTempFile] :: String -> THMessage (THResult FilePath)
[AddModFinalizer] :: RemoteRef (Q ()) -> THMessage (THResult ())
[AddCorePlugin] :: String -> THMessage (THResult ())
[AddTopDecls] :: [Dec] -> THMessage (THResult ())
[AddForeignFilePath] :: ForeignSrcLang -> FilePath -> THMessage (THResult ())
[IsExtEnabled] :: Extension -> THMessage (THResult Bool)
[ExtsEnabled] :: THMessage (THResult [Extension])
[PutDoc] :: DocLoc -> String -> THMessage (THResult ())
[GetDoc] :: DocLoc -> THMessage (THResult (Maybe String))
[StartRecover] :: THMessage ()
[EndRecover] :: Bool -> THMessage ()
[FailIfErrs] :: THMessage (THResult ())

-- | Indicates that this RunTH is finished, and the next message will be
--   the result of RunTH (a QResult).
[RunTHDone] :: THMessage ()
data THMsg
THMsg :: THMessage a -> THMsg

-- | Template Haskell return values
data QResult a

-- | RunTH finished successfully; return value follows
QDone :: a -> QResult a

-- | RunTH threw an exception
QException :: String -> QResult a

-- | RunTH called <a>fail</a>
QFail :: String -> QResult a
data EvalStatus_ a b
EvalComplete :: Word64 -> EvalResult a -> EvalStatus_ a b
EvalBreak :: HValueRef -> Maybe EvalBreakpoint -> RemoteRef (ResumeContext b) -> RemotePtr CostCentreStack -> EvalStatus_ a b
type EvalStatus a = EvalStatus_ a a
data EvalResult a
EvalException :: SerializableException -> EvalResult a
EvalSuccess :: a -> EvalResult a
data EvalOpts
EvalOpts :: Bool -> Bool -> Bool -> Bool -> EvalOpts
[useSandboxThread] :: EvalOpts -> Bool
[singleStep] :: EvalOpts -> Bool
[breakOnException] :: EvalOpts -> Bool
[breakOnError] :: EvalOpts -> Bool

-- | We can pass simple expressions to EvalStmt, consisting of values and
--   application. This allows us to wrap the statement to be executed in
--   another function, which is used by GHCi to implement :set args and
--   :set prog. It might be worthwhile to extend this little language in
--   the future.
data EvalExpr a
EvalThis :: a -> EvalExpr a
EvalApp :: EvalExpr a -> EvalExpr a -> EvalExpr a
data EvalBreakpoint
EvalBreakpoint :: String -> Int -> String -> Int -> EvalBreakpoint

-- | Breakpoint tick module
[eb_tick_mod] :: EvalBreakpoint -> String

-- | Breakpoint tick index
[eb_tick_index] :: EvalBreakpoint -> Int

-- | Breakpoint info module
[eb_info_mod] :: EvalBreakpoint -> String

-- | Breakpoint info index
[eb_info_index] :: EvalBreakpoint -> Int
data SerializableException
EUserInterrupt :: SerializableException
EExitCode :: ExitCode -> SerializableException
EOtherException :: String -> SerializableException
toSerializableException :: SomeException -> SerializableException
fromSerializableException :: SerializableException -> SomeException
data THResult a
THException :: String -> THResult a
THComplete :: a -> THResult a
data THResultType
THExp :: THResultType
THPat :: THResultType
THType :: THResultType
THDec :: THResultType
THAnnWrapper :: THResultType
data ResumeContext a
ResumeContext :: MVar () -> MVar (EvalStatus a) -> ThreadId -> ResumeContext a
[resumeBreakMVar] :: ResumeContext a -> MVar ()
[resumeStatusMVar] :: ResumeContext a -> MVar (EvalStatus a)
[resumeThreadId] :: ResumeContext a -> ThreadId

-- | The server-side Template Haskell state. This is created by the StartTH
--   message. A new one is created per module that GHC typechecks.
data QState
QState :: Map TypeRep Dynamic -> Maybe Loc -> Pipe -> QState

-- | persistent data between splices in a module
[qsMap] :: QState -> Map TypeRep Dynamic

-- | location for current splice, if any
[qsLocation] :: QState -> Maybe Loc

-- | pipe to communicate with GHC
[qsPipe] :: QState -> Pipe
getMessage :: Get Msg
putMessage :: Message a -> Put
getTHMessage :: Get THMsg
putTHMessage :: THMessage a -> Put
data Pipe
Pipe :: Handle -> Handle -> IORef (Maybe ByteString) -> Pipe
[pipeRead] :: Pipe -> Handle
[pipeWrite] :: Pipe -> Handle
[pipeLeftovers] :: Pipe -> IORef (Maybe ByteString)
remoteCall :: Binary a => Pipe -> Message a -> IO a
remoteTHCall :: Binary a => Pipe -> THMessage a -> IO a
readPipe :: Pipe -> Get a -> IO a
writePipe :: Pipe -> Put -> IO ()

-- | A dummy type that tags the pointer to a breakpoint's
--   <tt>ModuleName</tt>, because that type isn't available here.
data BreakModule

-- | A dummy type that tags pointers returned by <a>LoadDLL</a>.
data LoadedDLL
instance Data.Binary.Class.Binary GHC.Internal.ClosureTypes.ClosureType
instance Data.Binary.Class.Binary GHC.Exts.Heap.ProfInfo.Types.CostCentre
instance Data.Binary.Class.Binary GHC.Exts.Heap.ProfInfo.Types.CostCentreStack
instance Data.Binary.Class.Binary GHCi.Message.EvalBreakpoint
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (GHCi.Message.EvalExpr a)
instance Data.Binary.Class.Binary GHCi.Message.EvalOpts
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (GHCi.Message.EvalResult a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (GHCi.Message.EvalStatus_ a b)
instance Data.Binary.Class.Binary GHC.Internal.IO.Exception.ExitCode
instance Data.Binary.Class.Binary (GHC.Internal.Ptr.FunPtr a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (GHC.Exts.Heap.Closures.GenClosure a)
instance Data.Binary.Class.Binary GHC.Exts.Heap.ProfInfo.Types.IndexTable
instance Data.Binary.Class.Binary GHC.Exts.Heap.Closures.PrimType
instance Data.Binary.Class.Binary (GHC.Internal.Ptr.Ptr a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (GHCi.Message.QResult a)
instance Data.Binary.Class.Binary GHCi.Message.SerializableException
instance Data.Binary.Class.Binary GHC.Exts.Heap.InfoTable.Types.StgInfoTable
instance Data.Binary.Class.Binary GHC.Exts.Heap.ProfInfo.Types.StgTSOProfInfo
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (GHCi.Message.THResult a)
instance Data.Binary.Class.Binary GHCi.Message.THResultType
instance Data.Binary.Class.Binary GHC.Exts.Heap.Closures.TsoFlags
instance Data.Binary.Class.Binary GHC.Exts.Heap.Closures.WhatNext
instance Data.Binary.Class.Binary GHC.Exts.Heap.Closures.WhyBlocked
instance GHC.Internal.Enum.Enum GHCi.Message.THResultType
instance GHC.Internal.Generics.Generic GHCi.Message.EvalBreakpoint
instance GHC.Internal.Generics.Generic (GHCi.Message.EvalExpr a)
instance GHC.Internal.Generics.Generic GHCi.Message.EvalOpts
instance GHC.Internal.Generics.Generic (GHCi.Message.EvalResult a)
instance GHC.Internal.Generics.Generic (GHCi.Message.EvalStatus_ a b)
instance GHC.Internal.Generics.Generic (GHCi.Message.QResult a)
instance GHC.Internal.Generics.Generic GHCi.Message.SerializableException
instance GHC.Internal.Generics.Generic (GHCi.Message.THResult a)
instance GHC.Internal.Generics.Generic GHCi.Message.THResultType
instance GHC.Internal.Show.Show GHCi.Message.EvalBreakpoint
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHCi.Message.EvalExpr a)
instance GHC.Internal.Show.Show GHCi.Message.EvalOpts
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHCi.Message.EvalResult a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHCi.Message.EvalStatus_ a b)
instance GHC.Internal.Show.Show (GHCi.Message.Message a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHCi.Message.QResult a)
instance GHC.Internal.Show.Show GHCi.Message.QState
instance GHC.Internal.Show.Show GHCi.Message.SerializableException
instance GHC.Internal.Show.Show (GHCi.Message.THMessage a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHCi.Message.THResult a)
instance GHC.Internal.Show.Show GHCi.Message.THResultType


-- | Running TH splices
module GHCi.TH

-- | The implementation of the <a>StartTH</a> message: create a new IORef
--   QState, and return a RemoteRef to it.
startTH :: IO (RemoteRef (IORef QState))

-- | Runs the mod finalizers.
--   
--   The references must be created on the caller process.
runModFinalizerRefs :: Pipe -> RemoteRef (IORef QState) -> [RemoteRef (Q ())] -> IO ()

-- | The implementation of the <a>RunTH</a> message
runTH :: Pipe -> RemoteRef (IORef QState) -> HValueRef -> THResultType -> Maybe Loc -> IO ByteString

-- | The exception thrown by "fail" in the GHCiQ monad
data GHCiQException
GHCiQException :: QState -> String -> GHCiQException
instance GHC.Internal.Base.Applicative GHCi.TH.GHCiQ
instance GHC.Internal.Exception.Type.Exception GHCi.TH.GHCiQException
instance GHC.Internal.Base.Functor GHCi.TH.GHCiQ
instance GHC.Internal.Control.Monad.Fail.MonadFail GHCi.TH.GHCiQ
instance GHC.Internal.Base.Monad GHCi.TH.GHCiQ
instance GHC.Internal.Control.Monad.IO.Class.MonadIO GHCi.TH.GHCiQ
instance GHC.Internal.TH.Syntax.Quasi GHCi.TH.GHCiQ
instance GHC.Internal.Show.Show GHCi.TH.GHCiQException


-- | Primarily, this module consists of an interface to the C-land dynamic
--   linker.
module GHCi.ObjLink
initObjLinker :: ShouldRetainCAFs -> IO ()
data ShouldRetainCAFs

-- | Retain CAFs unconditionally in linked Haskell code. Note that this
--   prevents any code from being unloaded. It should not be necessary
--   unless you are GHCi or hs-plugins, which needs to be able call any
--   function in the compiled code.
RetainCAFs :: ShouldRetainCAFs

-- | Do not retain CAFs. Everything reachable from foreign exports will be
--   retained, due to the StablePtrs created by the module initialisation
--   code. unloadObj frees these StablePtrs, which will allow the CAFs to
--   be GC'd and the code to be removed.
DontRetainCAFs :: ShouldRetainCAFs

-- | loadDLL loads a dynamic library using the OS's native linker (i.e.
--   dlopen() on Unix, LoadLibrary() on Windows). It takes either an
--   absolute pathname to the file, or a relative filename (e.g.
--   "libfoo.so" or "foo.dll"). In the latter case, loadDLL searches the
--   standard locations for the appropriate library.
loadDLL :: String -> IO (Either String (Ptr LoadedDLL))
loadArchive :: String -> IO ()
loadObj :: String -> IO ()

-- | <tt>unloadObj</tt> drops the given dynamic library from the symbol
--   table as well as enables the library to be removed from memory during
--   a future major GC.
unloadObj :: String -> IO ()

-- | <tt>purgeObj</tt> drops the symbols for the dynamic library from the
--   symbol table. Unlike <a>unloadObj</a>, the library will not be dropped
--   memory during a future major GC.
purgeObj :: String -> IO ()
lookupSymbol :: String -> IO (Maybe (Ptr a))
lookupSymbolInDLL :: Ptr LoadedDLL -> String -> IO (Maybe (Ptr a))
lookupClosure :: String -> IO (Maybe HValueRef)
resolveObjs :: IO Bool
addLibrarySearchPath :: String -> IO (Ptr ())
removeLibrarySearchPath :: Ptr () -> IO Bool
findSystemLibrary :: String -> IO (Maybe String)


-- | Execute GHCi messages.
--   
--   For details on Remote GHCi, see Note [Remote GHCi] in
--   compiler<i>GHC</i>Runtime/Interpreter.hs.
module GHCi.Run
run :: Message a -> IO a
redirectInterrupts :: ThreadId -> IO a -> IO a

module GHCi.Utils

-- | Gets a GHC Handle File description from the given OS Handle or POSIX
--   fd.
getGhcHandle :: CInt -> IO Handle

-- | Read a handle passed on the command-line and prepare it to be used
--   with the IO manager
readGhcHandle :: String -> IO Handle

module GHCi.Server
serv :: Bool -> MessageHook -> Pipe -> (forall a. () => IO a -> IO a) -> IO ()

-- | Default server
defaultServer :: IO ()
