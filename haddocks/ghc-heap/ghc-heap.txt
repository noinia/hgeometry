-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Functions for walking GHC's heap
--   
--   This package provides functions for walking the GHC heap data
--   structures and retrieving information about those data structures.
@package ghc-heap
@version 9.12.2

module GHC.Exts.Heap.ClosureTypes

-- | Enum representing closure types This is a mirror of:
--   <tt>rts<i>include</i>rts<i>storage</i>ClosureTypes.h</tt>
data ClosureType
INVALID_OBJECT :: ClosureType
CONSTR :: ClosureType
CONSTR_1_0 :: ClosureType
CONSTR_0_1 :: ClosureType
CONSTR_2_0 :: ClosureType
CONSTR_1_1 :: ClosureType
CONSTR_0_2 :: ClosureType
CONSTR_NOCAF :: ClosureType
FUN :: ClosureType
FUN_1_0 :: ClosureType
FUN_0_1 :: ClosureType
FUN_2_0 :: ClosureType
FUN_1_1 :: ClosureType
FUN_0_2 :: ClosureType
FUN_STATIC :: ClosureType
THUNK :: ClosureType
THUNK_1_0 :: ClosureType
THUNK_0_1 :: ClosureType
THUNK_2_0 :: ClosureType
THUNK_1_1 :: ClosureType
THUNK_0_2 :: ClosureType
THUNK_STATIC :: ClosureType
THUNK_SELECTOR :: ClosureType
BCO :: ClosureType
AP :: ClosureType
PAP :: ClosureType
AP_STACK :: ClosureType
IND :: ClosureType
IND_STATIC :: ClosureType
RET_BCO :: ClosureType
RET_SMALL :: ClosureType
RET_BIG :: ClosureType
RET_FUN :: ClosureType
UPDATE_FRAME :: ClosureType
CATCH_FRAME :: ClosureType
UNDERFLOW_FRAME :: ClosureType
STOP_FRAME :: ClosureType
BLOCKING_QUEUE :: ClosureType
BLACKHOLE :: ClosureType
MVAR_CLEAN :: ClosureType
MVAR_DIRTY :: ClosureType
TVAR :: ClosureType
ARR_WORDS :: ClosureType
MUT_ARR_PTRS_CLEAN :: ClosureType
MUT_ARR_PTRS_DIRTY :: ClosureType
MUT_ARR_PTRS_FROZEN_DIRTY :: ClosureType
MUT_ARR_PTRS_FROZEN_CLEAN :: ClosureType
MUT_VAR_CLEAN :: ClosureType
MUT_VAR_DIRTY :: ClosureType
WEAK :: ClosureType
PRIM :: ClosureType
MUT_PRIM :: ClosureType
TSO :: ClosureType
STACK :: ClosureType
TREC_CHUNK :: ClosureType
ATOMICALLY_FRAME :: ClosureType
CATCH_RETRY_FRAME :: ClosureType
CATCH_STM_FRAME :: ClosureType
WHITEHOLE :: ClosureType
SMALL_MUT_ARR_PTRS_CLEAN :: ClosureType
SMALL_MUT_ARR_PTRS_DIRTY :: ClosureType
SMALL_MUT_ARR_PTRS_FROZEN_DIRTY :: ClosureType
SMALL_MUT_ARR_PTRS_FROZEN_CLEAN :: ClosureType
COMPACT_NFDATA :: ClosureType
CONTINUATION :: ClosureType
N_CLOSURE_TYPES :: ClosureType

-- | Return the size of the closures header in words
closureTypeHeaderSize :: ClosureType -> Int

module GHC.Exts.Heap.Constants
wORD_SIZE :: Int
tAG_MASK :: Int
wORD_SIZE_IN_BITS :: Int

module GHC.Exts.Heap.InfoTable.Types

-- | This is a somewhat faithful representation of an info table. See
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/storage/InfoTables.h</a>
--   for more details on this data structure.
data StgInfoTable
StgInfoTable :: Maybe EntryFunPtr -> HalfWord -> HalfWord -> ClosureType -> HalfWord -> Maybe ItblCodes -> StgInfoTable
[entry] :: StgInfoTable -> Maybe EntryFunPtr
[ptrs] :: StgInfoTable -> HalfWord
[nptrs] :: StgInfoTable -> HalfWord
[tipe] :: StgInfoTable -> ClosureType
[srtlen] :: StgInfoTable -> HalfWord
[code] :: StgInfoTable -> Maybe ItblCodes
type EntryFunPtr = FunPtr Ptr () -> IO Ptr ()
type HalfWord = Word32
type ItblCodes = Either [Word8] [Word32]
instance GHC.Classes.Eq GHC.Exts.Heap.InfoTable.Types.StgInfoTable
instance GHC.Internal.Generics.Generic GHC.Exts.Heap.InfoTable.Types.StgInfoTable
instance GHC.Internal.Show.Show GHC.Exts.Heap.InfoTable.Types.StgInfoTable

module GHC.Exts.Heap.InfoTable

-- | Size in bytes of a standard InfoTable
itblSize :: Int

-- | Read an InfoTable from the heap into a haskell type. WARNING: This
--   code assumes it is passed a pointer to a "standard" info table. If
--   tables_next_to_code is enabled, it will look 1 byte before the start
--   for the entry field.
peekItbl :: Ptr StgInfoTable -> IO StgInfoTable
pokeItbl :: Ptr StgInfoTable -> StgInfoTable -> IO ()

module GHC.Exts.Heap.InfoTableProf
itblSize :: Int

-- | Read an InfoTable from the heap into a haskell type. WARNING: This
--   code assumes it is passed a pointer to a "standard" info table. If
--   tables_next_to_code is enabled, it will look 1 byte before the start
--   for the entry field.
peekItbl :: Ptr StgInfoTable -> IO StgInfoTable
pokeItbl :: Ptr StgInfoTable -> StgInfoTable -> IO ()

module GHC.Exts.Heap.ProfInfo.Types

-- | This is a somewhat faithful representation of StgTSOProfInfo. See
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/storage/TSO.h</a>
--   for more details on this data structure.
newtype StgTSOProfInfo
StgTSOProfInfo :: Maybe CostCentreStack -> StgTSOProfInfo
[cccs] :: StgTSOProfInfo -> Maybe CostCentreStack

-- | This is a somewhat faithful representation of CostCentreStack. See
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/prof/CCS.h</a>
--   for more details on this data structure.
data CostCentreStack
CostCentreStack :: Int -> CostCentre -> Maybe CostCentreStack -> Maybe IndexTable -> Maybe CostCentreStack -> Word -> Word64 -> Word -> Word -> Word64 -> Word64 -> Word -> CostCentreStack
[ccs_ccsID] :: CostCentreStack -> Int
[ccs_cc] :: CostCentreStack -> CostCentre
[ccs_prevStack] :: CostCentreStack -> Maybe CostCentreStack
[ccs_indexTable] :: CostCentreStack -> Maybe IndexTable
[ccs_root] :: CostCentreStack -> Maybe CostCentreStack
[ccs_depth] :: CostCentreStack -> Word
[ccs_scc_count] :: CostCentreStack -> Word64
[ccs_selected] :: CostCentreStack -> Word
[ccs_time_ticks] :: CostCentreStack -> Word
[ccs_mem_alloc] :: CostCentreStack -> Word64
[ccs_inherited_alloc] :: CostCentreStack -> Word64
[ccs_inherited_ticks] :: CostCentreStack -> Word

-- | This is a somewhat faithful representation of CostCentre. See
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/prof/CCS.h</a>
--   for more details on this data structure.
data CostCentre
CostCentre :: Int -> String -> String -> Maybe String -> Word64 -> Word -> Bool -> Maybe CostCentre -> CostCentre
[cc_ccID] :: CostCentre -> Int
[cc_label] :: CostCentre -> String
[cc_module] :: CostCentre -> String
[cc_srcloc] :: CostCentre -> Maybe String
[cc_mem_alloc] :: CostCentre -> Word64
[cc_time_ticks] :: CostCentre -> Word
[cc_is_caf] :: CostCentre -> Bool
[cc_link] :: CostCentre -> Maybe CostCentre

-- | This is a somewhat faithful representation of IndexTable. See
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/prof/CCS.h</a>
--   for more details on this data structure.
data IndexTable
IndexTable :: CostCentre -> Maybe CostCentreStack -> Maybe IndexTable -> Bool -> IndexTable
[it_cc] :: IndexTable -> CostCentre
[it_ccs] :: IndexTable -> Maybe CostCentreStack
[it_next] :: IndexTable -> Maybe IndexTable
[it_back_edge] :: IndexTable -> Bool
instance GHC.Classes.Eq GHC.Exts.Heap.ProfInfo.Types.CostCentre
instance GHC.Classes.Eq GHC.Exts.Heap.ProfInfo.Types.CostCentreStack
instance GHC.Classes.Eq GHC.Exts.Heap.ProfInfo.Types.IndexTable
instance GHC.Classes.Eq GHC.Exts.Heap.ProfInfo.Types.StgTSOProfInfo
instance GHC.Internal.Generics.Generic GHC.Exts.Heap.ProfInfo.Types.CostCentre
instance GHC.Internal.Generics.Generic GHC.Exts.Heap.ProfInfo.Types.CostCentreStack
instance GHC.Internal.Generics.Generic GHC.Exts.Heap.ProfInfo.Types.IndexTable
instance GHC.Internal.Generics.Generic GHC.Exts.Heap.ProfInfo.Types.StgTSOProfInfo
instance GHC.Classes.Ord GHC.Exts.Heap.ProfInfo.Types.CostCentre
instance GHC.Classes.Ord GHC.Exts.Heap.ProfInfo.Types.CostCentreStack
instance GHC.Classes.Ord GHC.Exts.Heap.ProfInfo.Types.IndexTable
instance GHC.Classes.Ord GHC.Exts.Heap.ProfInfo.Types.StgTSOProfInfo
instance GHC.Internal.Show.Show GHC.Exts.Heap.ProfInfo.Types.CostCentre
instance GHC.Internal.Show.Show GHC.Exts.Heap.ProfInfo.Types.CostCentreStack
instance GHC.Internal.Show.Show GHC.Exts.Heap.ProfInfo.Types.IndexTable
instance GHC.Internal.Show.Show GHC.Exts.Heap.ProfInfo.Types.StgTSOProfInfo

module GHC.Exts.Heap.ProfInfo.PeekProfInfo_ProfilingEnabled
peekStgTSOProfInfo :: (Ptr b -> IO (Maybe CostCentreStack)) -> Ptr a -> IO (Maybe StgTSOProfInfo)
peekTopCCS :: Ptr b -> IO (Maybe CostCentreStack)

module GHC.Exts.Heap.ProfInfo.PeekProfInfo_ProfilingDisabled

-- | This implementation is used when PROFILING is undefined. It always
--   returns <a>Nothing</a>, because there is no profiling info available.
peekStgTSOProfInfo :: (Ptr a -> IO (Maybe CostCentreStack)) -> Ptr tsoPtr -> IO (Maybe StgTSOProfInfo)
peekTopCCS :: Ptr a -> IO (Maybe CostCentreStack)

module GHC.Exts.Heap.ProfInfo.PeekProfInfo

module GHC.Exts.Heap.Closures
type Closure = GenClosure Box

-- | This is the representation of a Haskell value on the heap. It reflects
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/storage/Closures.h</a>
--   
--   The data type is parametrized by <tt>b</tt>: the type to store
--   references in. Usually this is a <a>Box</a> with the type synonym
--   <a>Closure</a>.
--   
--   All Heap objects have the same basic layout. A header containing a
--   pointer to the info table and a payload with various fields. The
--   <tt>info</tt> field below always refers to the info table pointed to
--   by the header. The remaining fields are the payload.
--   
--   See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/commentary/rts/storage/heap-objects</a>
--   for more information.
data GenClosure b

-- | A data constructor
ConstrClosure :: !StgInfoTable -> ![b] -> ![Word] -> !String -> !String -> !String -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | Package name
[pkg] :: GenClosure b -> !String

-- | Module name
[modl] :: GenClosure b -> !String

-- | Constructor name
[name] :: GenClosure b -> !String

-- | A function
FunClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | A thunk, an expression not obviously in head normal form
ThunkClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | A thunk which performs a simple selection operation
SelectorClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to the object being selected from
[selectee] :: GenClosure b -> !b

-- | An unsaturated function application
PAPClosure :: !StgInfoTable -> !HalfWord -> !HalfWord -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | Size of the payload in words
[n_args] :: GenClosure b -> !HalfWord

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A function application
APClosure :: !StgInfoTable -> !HalfWord -> !HalfWord -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | Size of the payload in words
[n_args] :: GenClosure b -> !HalfWord

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A suspended thunk evaluation
APStackClosure :: !StgInfoTable -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A pointer to another closure, introduced when a thunk is updated to
--   point at its value
IndClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Target closure
[indirectee] :: GenClosure b -> !b

-- | A byte-code object (BCO) which can be interpreted by GHC's byte-code
--   interpreter (e.g. as used by GHCi)
BCOClosure :: !StgInfoTable -> !b -> !b -> !b -> !HalfWord -> !HalfWord -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | A pointer to an ArrWords of instructions
[instrs] :: GenClosure b -> !b

-- | A pointer to an ArrWords of literals
[literals] :: GenClosure b -> !b

-- | A pointer to an ArrWords of byte code objects
[bcoptrs] :: GenClosure b -> !b

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | The size of this BCO in words
[size] :: GenClosure b -> !HalfWord

-- | An StgLargeBitmap describing the pointerhood of its args/free vars
[bitmap] :: GenClosure b -> ![Word]

-- | A thunk under evaluation by another thread
BlackholeClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Target closure
[indirectee] :: GenClosure b -> !b

-- | A <tt>ByteArray#</tt>
ArrWordsClosure :: !StgInfoTable -> !Word -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Size of array in bytes
[bytes] :: GenClosure b -> !Word

-- | Array payload
[arrWords] :: GenClosure b -> ![Word]

-- | A <tt>MutableByteArray#</tt>
MutArrClosure :: !StgInfoTable -> !Word -> !Word -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Number of pointers
[mccPtrs] :: GenClosure b -> !Word

-- | ?? Closures.h vs ClosureMacros.h
[mccSize] :: GenClosure b -> !Word

-- | Array payload Card table ignored
[mccPayload] :: GenClosure b -> ![b]

-- | A <tt>SmallMutableArray#</tt>
SmallMutArrClosure :: !StgInfoTable -> !Word -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Number of pointers
[mccPtrs] :: GenClosure b -> !Word

-- | Array payload Card table ignored
[mccPayload] :: GenClosure b -> ![b]

-- | An <tt>MVar#</tt>, with a queue of thread state objects blocking on
--   them
MVarClosure :: !StgInfoTable -> !b -> !b -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to head of queue
[queueHead] :: GenClosure b -> !b

-- | Pointer to tail of queue
[queueTail] :: GenClosure b -> !b

-- | Pointer to closure
[value] :: GenClosure b -> !b

-- | An <tt>IOPort#</tt>, with a queue of thread state objects blocking on
--   them
IOPortClosure :: !StgInfoTable -> !b -> !b -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to head of queue
[queueHead] :: GenClosure b -> !b

-- | Pointer to tail of queue
[queueTail] :: GenClosure b -> !b

-- | Pointer to closure
[value] :: GenClosure b -> !b

-- | A <tt>MutVar#</tt>
MutVarClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to contents
[var] :: GenClosure b -> !b

-- | An STM blocking queue.
BlockingQueueClosure :: !StgInfoTable -> !b -> !b -> !b -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | ?? Here so it looks like an IND
[link] :: GenClosure b -> !b

-- | The blackhole closure
[blackHole] :: GenClosure b -> !b

-- | The owning thread state object
[owner] :: GenClosure b -> !b

-- | ??
[queue] :: GenClosure b -> !b
WeakClosure :: !StgInfoTable -> !b -> !b -> !b -> !b -> !Maybe b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable
[cfinalizers] :: GenClosure b -> !b
[key] :: GenClosure b -> !b

-- | Pointer to closure
[value] :: GenClosure b -> !b
[finalizer] :: GenClosure b -> !b

-- | next weak pointer for the capability
[weakLink] :: GenClosure b -> !Maybe b

-- | Representation of StgTSO: A Thread State Object. The values for
--   <a>what_next</a>, <a>why_blocked</a> and <a>flags</a> are defined in
--   <tt>Constants.h</tt>.
TSOClosure :: !StgInfoTable -> !b -> !b -> !b -> !b -> !b -> !b -> !Maybe b -> !WhatNext -> !WhyBlocked -> ![TsoFlags] -> !Word64 -> !Word32 -> !Word32 -> !Int64 -> !Word32 -> !Maybe StgTSOProfInfo -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | ?? Here so it looks like an IND
[link] :: GenClosure b -> !b
[global_link] :: GenClosure b -> !b

-- | stackobj from StgTSO
[tsoStack] :: GenClosure b -> !b
[trec] :: GenClosure b -> !b
[blocked_exceptions] :: GenClosure b -> !b
[bq] :: GenClosure b -> !b
[thread_label] :: GenClosure b -> !Maybe b
[what_next] :: GenClosure b -> !WhatNext
[why_blocked] :: GenClosure b -> !WhyBlocked
[flags] :: GenClosure b -> ![TsoFlags]
[threadId] :: GenClosure b -> !Word64
[saved_errno] :: GenClosure b -> !Word32

-- | non-zero =&gt; dirty
[tso_dirty] :: GenClosure b -> !Word32
[alloc_limit] :: GenClosure b -> !Int64
[tot_stack_size] :: GenClosure b -> !Word32
[prof] :: GenClosure b -> !Maybe StgTSOProfInfo

-- | Representation of StgStack: The 'tsoStack ' of a <a>TSOClosure</a>.
StackClosure :: !StgInfoTable -> !Word32 -> !Word8 -> !Word8 -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | stack size in *words*
[stack_size] :: GenClosure b -> !Word32

-- | non-zero =&gt; dirty
[stack_dirty] :: GenClosure b -> !Word8
[stack_marking] :: GenClosure b -> !Word8

-- | Primitive Int
IntClosure :: PrimType -> !Int -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[intVal] :: GenClosure b -> !Int

-- | Primitive Word
WordClosure :: PrimType -> !Word -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[wordVal] :: GenClosure b -> !Word

-- | Primitive Int64
Int64Closure :: PrimType -> !Int64 -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[int64Val] :: GenClosure b -> !Int64

-- | Primitive Word64
Word64Closure :: PrimType -> !Word64 -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[word64Val] :: GenClosure b -> !Word64

-- | Primitive Addr
AddrClosure :: PrimType -> !Ptr () -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[addrVal] :: GenClosure b -> !Ptr ()

-- | Primitive Float
FloatClosure :: PrimType -> !Float -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[floatVal] :: GenClosure b -> !Float

-- | Primitive Double
DoubleClosure :: PrimType -> !Double -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[doubleVal] :: GenClosure b -> !Double

-- | Another kind of closure
OtherClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable
[hvalues] :: GenClosure b -> ![b]
[rawWords] :: GenClosure b -> ![Word]
UnsupportedClosure :: !StgInfoTable -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | A primitive word from a bitmap encoded stack frame payload
--   
--   The type itself cannot be restored (i.e. it might represent a Word8#
--   or an Int#).
UnknownTypeWordSizedPrimitive :: !Word -> GenClosure b
[wordVal] :: GenClosure b -> !Word
data PrimType
PInt :: PrimType
PWord :: PrimType
PInt64 :: PrimType
PWord64 :: PrimType
PAddr :: PrimType
PFloat :: PrimType
PDouble :: PrimType
data WhatNext
ThreadRunGHC :: WhatNext
ThreadInterpret :: WhatNext
ThreadKilled :: WhatNext
ThreadComplete :: WhatNext

-- | Please report this as a bug
WhatNextUnknownValue :: Word16 -> WhatNext
data WhyBlocked
NotBlocked :: WhyBlocked
BlockedOnMVar :: WhyBlocked
BlockedOnMVarRead :: WhyBlocked
BlockedOnBlackHole :: WhyBlocked
BlockedOnRead :: WhyBlocked
BlockedOnWrite :: WhyBlocked
BlockedOnDelay :: WhyBlocked
BlockedOnSTM :: WhyBlocked
BlockedOnDoProc :: WhyBlocked
BlockedOnCCall :: WhyBlocked
BlockedOnCCall_Interruptible :: WhyBlocked
BlockedOnMsgThrowTo :: WhyBlocked
ThreadMigrating :: WhyBlocked

-- | Please report this as a bug
WhyBlockedUnknownValue :: Word16 -> WhyBlocked
data TsoFlags
TsoLocked :: TsoFlags
TsoBlockx :: TsoFlags
TsoInterruptible :: TsoFlags
TsoStoppedOnBreakpoint :: TsoFlags
TsoMarked :: TsoFlags
TsoSqueezed :: TsoFlags
TsoAllocLimit :: TsoFlags

-- | Please report this as a bug
TsoFlagsUnknownValue :: Word32 -> TsoFlags

-- | For generic code, this function returns all referenced closures.
allClosures :: GenClosure b -> [b]

-- | Get the size of the top-level closure in words. Includes header and
--   payload. Does not follow pointers.
closureSize :: Box -> Int
type StgStackClosure = GenStgStackClosure Box

-- | A decoded <tt>StgStack</tt> with <a>StackFrame</a>s
--   
--   Stack related data structures (<a>GenStgStackClosure</a>,
--   <a>GenStackField</a>, <a>GenStackFrame</a>) are defined separately
--   from <a>GenClosure</a> as their related functions are very different.
--   Though, both are closures in the sense of RTS structures, their
--   decoding logic differs: While it's safe to keep a reference to a heap
--   closure, the garbage collector does not update references to stack
--   located closures.
--   
--   Additionally, stack frames don't appear outside of the stack. Thus,
--   keeping <a>GenStackFrame</a> and <a>GenClosure</a> separated, makes
--   these types more precise (in the sense what values to expect.)
data GenStgStackClosure b
GenStgStackClosure :: !StgInfoTable -> !Word32 -> ![GenStackFrame b] -> GenStgStackClosure b
[ssc_info] :: GenStgStackClosure b -> !StgInfoTable

-- | stack size in *words*
[ssc_stack_size] :: GenStgStackClosure b -> !Word32
[ssc_stack] :: GenStgStackClosure b -> ![GenStackFrame b]
type StackFrame = GenStackFrame Box

-- | A single stack frame
data GenStackFrame b
UpdateFrame :: !StgInfoTable -> !b -> GenStackFrame b
[info_tbl] :: GenStackFrame b -> !StgInfoTable
[updatee] :: GenStackFrame b -> !b
CatchFrame :: !StgInfoTable -> !b -> GenStackFrame b
[info_tbl] :: GenStackFrame b -> !StgInfoTable
[handler] :: GenStackFrame b -> !b
CatchStmFrame :: !StgInfoTable -> !b -> !b -> GenStackFrame b
[info_tbl] :: GenStackFrame b -> !StgInfoTable
[catchFrameCode] :: GenStackFrame b -> !b
[handler] :: GenStackFrame b -> !b
CatchRetryFrame :: !StgInfoTable -> !Word -> !b -> !b -> GenStackFrame b
[info_tbl] :: GenStackFrame b -> !StgInfoTable
[running_alt_code] :: GenStackFrame b -> !Word
[first_code] :: GenStackFrame b -> !b
[alt_code] :: GenStackFrame b -> !b
AtomicallyFrame :: !StgInfoTable -> !b -> !b -> GenStackFrame b
[info_tbl] :: GenStackFrame b -> !StgInfoTable
[atomicallyFrameCode] :: GenStackFrame b -> !b
[result] :: GenStackFrame b -> !b
UnderflowFrame :: !StgInfoTable -> !GenStgStackClosure b -> GenStackFrame b
[info_tbl] :: GenStackFrame b -> !StgInfoTable
[nextChunk] :: GenStackFrame b -> !GenStgStackClosure b
StopFrame :: !StgInfoTable -> GenStackFrame b
[info_tbl] :: GenStackFrame b -> !StgInfoTable
RetSmall :: !StgInfoTable -> ![GenStackField b] -> GenStackFrame b
[info_tbl] :: GenStackFrame b -> !StgInfoTable
[stack_payload] :: GenStackFrame b -> ![GenStackField b]
RetBig :: !StgInfoTable -> ![GenStackField b] -> GenStackFrame b
[info_tbl] :: GenStackFrame b -> !StgInfoTable
[stack_payload] :: GenStackFrame b -> ![GenStackField b]
RetFun :: !StgInfoTable -> !Word -> !b -> ![GenStackField b] -> GenStackFrame b
[info_tbl] :: GenStackFrame b -> !StgInfoTable
[retFunSize] :: GenStackFrame b -> !Word
[retFunFun] :: GenStackFrame b -> !b
[retFunPayload] :: GenStackFrame b -> ![GenStackField b]
RetBCO :: !StgInfoTable -> !b -> ![GenStackField b] -> GenStackFrame b
[info_tbl] :: GenStackFrame b -> !StgInfoTable

-- | always a BCOClosure
[bco] :: GenStackFrame b -> !b
[bcoArgs] :: GenStackFrame b -> ![GenStackField b]
type StackField = GenStackField Box

-- | Bitmap-encoded payload on the stack
data GenStackField b

-- | A non-pointer field
StackWord :: !Word -> GenStackField b

-- | A pointer field
StackBox :: !b -> GenStackField b

-- | An arbitrary Haskell value in a safe Box. The point is that even
--   unevaluated thunks can safely be moved around inside the Box, and when
--   required, e.g. in <tt>getBoxedClosureData</tt>, the function knows how
--   far it has to evaluate the argument.
data Box
Box :: (Any :: Type) -> Box

-- | Boxes can be compared, but this is not pure, as different heap objects
--   can, after garbage collection, become the same object.
areBoxesEqual :: Box -> Box -> IO Bool

-- | This takes an arbitrary value and puts it into a box. Note that calls
--   like
--   
--   <pre>
--   asBox (head list)
--   </pre>
--   
--   will put the thunk "head list" into the box, <i>not</i> the element at
--   the head of the list. For that, use careful case expressions:
--   
--   <pre>
--   case list of x:_ -&gt; asBox x
--   </pre>
asBox :: a -> Box
instance GHC.Classes.Eq GHC.Exts.Heap.Closures.PrimType
instance GHC.Classes.Eq GHC.Exts.Heap.Closures.TsoFlags
instance GHC.Classes.Eq GHC.Exts.Heap.Closures.WhatNext
instance GHC.Classes.Eq GHC.Exts.Heap.Closures.WhyBlocked
instance GHC.Internal.Data.Foldable.Foldable GHC.Exts.Heap.Closures.GenClosure
instance GHC.Internal.Data.Foldable.Foldable GHC.Exts.Heap.Closures.GenStackField
instance GHC.Internal.Data.Foldable.Foldable GHC.Exts.Heap.Closures.GenStackFrame
instance GHC.Internal.Data.Foldable.Foldable GHC.Exts.Heap.Closures.GenStgStackClosure
instance GHC.Internal.Base.Functor GHC.Exts.Heap.Closures.GenClosure
instance GHC.Internal.Base.Functor GHC.Exts.Heap.Closures.GenStackField
instance GHC.Internal.Base.Functor GHC.Exts.Heap.Closures.GenStackFrame
instance GHC.Internal.Base.Functor GHC.Exts.Heap.Closures.GenStgStackClosure
instance GHC.Internal.Generics.Generic (GHC.Exts.Heap.Closures.GenClosure b)
instance GHC.Internal.Generics.Generic (GHC.Exts.Heap.Closures.GenStackField b)
instance GHC.Internal.Generics.Generic (GHC.Exts.Heap.Closures.GenStackFrame b)
instance GHC.Internal.Generics.Generic (GHC.Exts.Heap.Closures.GenStgStackClosure b)
instance GHC.Internal.Generics.Generic GHC.Exts.Heap.Closures.PrimType
instance GHC.Internal.Generics.Generic GHC.Exts.Heap.Closures.TsoFlags
instance GHC.Internal.Generics.Generic GHC.Exts.Heap.Closures.WhatNext
instance GHC.Internal.Generics.Generic GHC.Exts.Heap.Closures.WhyBlocked
instance GHC.Classes.Ord GHC.Exts.Heap.Closures.PrimType
instance GHC.Classes.Ord GHC.Exts.Heap.Closures.TsoFlags
instance GHC.Classes.Ord GHC.Exts.Heap.Closures.WhatNext
instance GHC.Classes.Ord GHC.Exts.Heap.Closures.WhyBlocked
instance GHC.Internal.Show.Show GHC.Exts.Heap.Closures.Box
instance GHC.Internal.Show.Show b => GHC.Internal.Show.Show (GHC.Exts.Heap.Closures.GenClosure b)
instance GHC.Internal.Show.Show b => GHC.Internal.Show.Show (GHC.Exts.Heap.Closures.GenStackField b)
instance GHC.Internal.Show.Show b => GHC.Internal.Show.Show (GHC.Exts.Heap.Closures.GenStackFrame b)
instance GHC.Internal.Show.Show b => GHC.Internal.Show.Show (GHC.Exts.Heap.Closures.GenStgStackClosure b)
instance GHC.Internal.Show.Show GHC.Exts.Heap.Closures.PrimType
instance GHC.Internal.Show.Show GHC.Exts.Heap.Closures.TsoFlags
instance GHC.Internal.Show.Show GHC.Exts.Heap.Closures.WhatNext
instance GHC.Internal.Show.Show GHC.Exts.Heap.Closures.WhyBlocked
instance GHC.Internal.Data.Traversable.Traversable GHC.Exts.Heap.Closures.GenClosure
instance GHC.Internal.Data.Traversable.Traversable GHC.Exts.Heap.Closures.GenStackField
instance GHC.Internal.Data.Traversable.Traversable GHC.Exts.Heap.Closures.GenStackFrame
instance GHC.Internal.Data.Traversable.Traversable GHC.Exts.Heap.Closures.GenStgStackClosure

module GHC.Exts.Heap.FFIClosures_ProfilingEnabled
data TSOFields
TSOFields :: WhatNext -> WhyBlocked -> [TsoFlags] -> Word64 -> Word32 -> Word32 -> Int64 -> Word32 -> Maybe StgTSOProfInfo -> TSOFields
[tso_what_next] :: TSOFields -> WhatNext
[tso_why_blocked] :: TSOFields -> WhyBlocked
[tso_flags] :: TSOFields -> [TsoFlags]
[tso_threadId] :: TSOFields -> Word64
[tso_saved_errno] :: TSOFields -> Word32
[tso_dirty] :: TSOFields -> Word32
[tso_alloc_limit] :: TSOFields -> Int64
[tso_tot_stack_size] :: TSOFields -> Word32
[tso_prof] :: TSOFields -> Maybe StgTSOProfInfo

-- | Get non-pointer fields from <tt>StgTSO_</tt> (<tt>TSO.h</tt>)
peekTSOFields :: (Ptr a -> IO (Maybe CostCentreStack)) -> Ptr tsoPtr -> IO TSOFields
parseWhatNext :: Word16 -> WhatNext
parseWhyBlocked :: Word16 -> WhyBlocked
parseTsoFlags :: Word32 -> [TsoFlags]
isSet :: Word32 -> Word32 -> Bool
unset :: Word32 -> Word32 -> Word32
data StackFields
StackFields :: Word32 -> Word8 -> Word8 -> Addr# -> StackFields
[stack_size] :: StackFields -> Word32
[stack_dirty] :: StackFields -> Word8
[stack_marking] :: StackFields -> Word8
[stack_sp] :: StackFields -> Addr#

-- | Get non-closure fields from <tt>StgStack_</tt> (<tt>TSO.h</tt>)
peekStackFields :: Ptr a -> IO StackFields

module GHC.Exts.Heap.FFIClosures_ProfilingDisabled
data TSOFields
TSOFields :: WhatNext -> WhyBlocked -> [TsoFlags] -> Word64 -> Word32 -> Word32 -> Int64 -> Word32 -> Maybe StgTSOProfInfo -> TSOFields
[tso_what_next] :: TSOFields -> WhatNext
[tso_why_blocked] :: TSOFields -> WhyBlocked
[tso_flags] :: TSOFields -> [TsoFlags]
[tso_threadId] :: TSOFields -> Word64
[tso_saved_errno] :: TSOFields -> Word32
[tso_dirty] :: TSOFields -> Word32
[tso_alloc_limit] :: TSOFields -> Int64
[tso_tot_stack_size] :: TSOFields -> Word32
[tso_prof] :: TSOFields -> Maybe StgTSOProfInfo

-- | Get non-pointer fields from <tt>StgTSO_</tt> (<tt>TSO.h</tt>)
peekTSOFields :: (Ptr a -> IO (Maybe CostCentreStack)) -> Ptr tsoPtr -> IO TSOFields
parseWhatNext :: Word16 -> WhatNext
parseWhyBlocked :: Word16 -> WhyBlocked
parseTsoFlags :: Word32 -> [TsoFlags]
isSet :: Word32 -> Word32 -> Bool
unset :: Word32 -> Word32 -> Word32
data StackFields
StackFields :: Word32 -> Word8 -> Word8 -> Addr# -> StackFields
[stack_size] :: StackFields -> Word32
[stack_dirty] :: StackFields -> Word8
[stack_marking] :: StackFields -> Word8
[stack_sp] :: StackFields -> Addr#

-- | Get non-closure fields from <tt>StgStack_</tt> (<tt>TSO.h</tt>)
peekStackFields :: Ptr a -> IO StackFields

module GHC.Exts.Heap.FFIClosures

module GHC.Exts.Heap.Utils
dataConNames :: Ptr StgInfoTable -> IO (String, String, String)


-- | With this module, you can investigate the heap representation of
--   Haskell values, i.e. to investigate sharing and lazy evaluation.
module GHC.Exts.Heap
type Closure = GenClosure Box

-- | This is the representation of a Haskell value on the heap. It reflects
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/storage/Closures.h</a>
--   
--   The data type is parametrized by <tt>b</tt>: the type to store
--   references in. Usually this is a <a>Box</a> with the type synonym
--   <a>Closure</a>.
--   
--   All Heap objects have the same basic layout. A header containing a
--   pointer to the info table and a payload with various fields. The
--   <tt>info</tt> field below always refers to the info table pointed to
--   by the header. The remaining fields are the payload.
--   
--   See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/commentary/rts/storage/heap-objects</a>
--   for more information.
data GenClosure b

-- | A data constructor
ConstrClosure :: !StgInfoTable -> ![b] -> ![Word] -> !String -> !String -> !String -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | Package name
[pkg] :: GenClosure b -> !String

-- | Module name
[modl] :: GenClosure b -> !String

-- | Constructor name
[name] :: GenClosure b -> !String

-- | A function
FunClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | A thunk, an expression not obviously in head normal form
ThunkClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | A thunk which performs a simple selection operation
SelectorClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to the object being selected from
[selectee] :: GenClosure b -> !b

-- | An unsaturated function application
PAPClosure :: !StgInfoTable -> !HalfWord -> !HalfWord -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | Size of the payload in words
[n_args] :: GenClosure b -> !HalfWord

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A function application
APClosure :: !StgInfoTable -> !HalfWord -> !HalfWord -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | Size of the payload in words
[n_args] :: GenClosure b -> !HalfWord

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A suspended thunk evaluation
APStackClosure :: !StgInfoTable -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A pointer to another closure, introduced when a thunk is updated to
--   point at its value
IndClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Target closure
[indirectee] :: GenClosure b -> !b

-- | A byte-code object (BCO) which can be interpreted by GHC's byte-code
--   interpreter (e.g. as used by GHCi)
BCOClosure :: !StgInfoTable -> !b -> !b -> !b -> !HalfWord -> !HalfWord -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | A pointer to an ArrWords of instructions
[instrs] :: GenClosure b -> !b

-- | A pointer to an ArrWords of literals
[literals] :: GenClosure b -> !b

-- | A pointer to an ArrWords of byte code objects
[bcoptrs] :: GenClosure b -> !b

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | The size of this BCO in words
[size] :: GenClosure b -> !HalfWord

-- | An StgLargeBitmap describing the pointerhood of its args/free vars
[bitmap] :: GenClosure b -> ![Word]

-- | A thunk under evaluation by another thread
BlackholeClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Target closure
[indirectee] :: GenClosure b -> !b

-- | A <tt>ByteArray#</tt>
ArrWordsClosure :: !StgInfoTable -> !Word -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Size of array in bytes
[bytes] :: GenClosure b -> !Word

-- | Array payload
[arrWords] :: GenClosure b -> ![Word]

-- | A <tt>MutableByteArray#</tt>
MutArrClosure :: !StgInfoTable -> !Word -> !Word -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Number of pointers
[mccPtrs] :: GenClosure b -> !Word

-- | ?? Closures.h vs ClosureMacros.h
[mccSize] :: GenClosure b -> !Word

-- | Array payload Card table ignored
[mccPayload] :: GenClosure b -> ![b]

-- | A <tt>SmallMutableArray#</tt>
SmallMutArrClosure :: !StgInfoTable -> !Word -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Number of pointers
[mccPtrs] :: GenClosure b -> !Word

-- | Array payload Card table ignored
[mccPayload] :: GenClosure b -> ![b]

-- | An <tt>MVar#</tt>, with a queue of thread state objects blocking on
--   them
MVarClosure :: !StgInfoTable -> !b -> !b -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to head of queue
[queueHead] :: GenClosure b -> !b

-- | Pointer to tail of queue
[queueTail] :: GenClosure b -> !b

-- | Pointer to closure
[value] :: GenClosure b -> !b

-- | An <tt>IOPort#</tt>, with a queue of thread state objects blocking on
--   them
IOPortClosure :: !StgInfoTable -> !b -> !b -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to head of queue
[queueHead] :: GenClosure b -> !b

-- | Pointer to tail of queue
[queueTail] :: GenClosure b -> !b

-- | Pointer to closure
[value] :: GenClosure b -> !b

-- | A <tt>MutVar#</tt>
MutVarClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to contents
[var] :: GenClosure b -> !b

-- | An STM blocking queue.
BlockingQueueClosure :: !StgInfoTable -> !b -> !b -> !b -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | ?? Here so it looks like an IND
[link] :: GenClosure b -> !b

-- | The blackhole closure
[blackHole] :: GenClosure b -> !b

-- | The owning thread state object
[owner] :: GenClosure b -> !b

-- | ??
[queue] :: GenClosure b -> !b
WeakClosure :: !StgInfoTable -> !b -> !b -> !b -> !b -> !Maybe b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable
[cfinalizers] :: GenClosure b -> !b
[key] :: GenClosure b -> !b

-- | Pointer to closure
[value] :: GenClosure b -> !b
[finalizer] :: GenClosure b -> !b

-- | next weak pointer for the capability
[weakLink] :: GenClosure b -> !Maybe b

-- | Representation of StgTSO: A Thread State Object. The values for
--   <a>what_next</a>, <a>why_blocked</a> and <a>flags</a> are defined in
--   <tt>Constants.h</tt>.
TSOClosure :: !StgInfoTable -> !b -> !b -> !b -> !b -> !b -> !b -> !Maybe b -> !WhatNext -> !WhyBlocked -> ![TsoFlags] -> !Word64 -> !Word32 -> !Word32 -> !Int64 -> !Word32 -> !Maybe StgTSOProfInfo -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | ?? Here so it looks like an IND
[link] :: GenClosure b -> !b
[global_link] :: GenClosure b -> !b

-- | stackobj from StgTSO
[tsoStack] :: GenClosure b -> !b
[trec] :: GenClosure b -> !b
[blocked_exceptions] :: GenClosure b -> !b
[bq] :: GenClosure b -> !b
[thread_label] :: GenClosure b -> !Maybe b
[what_next] :: GenClosure b -> !WhatNext
[why_blocked] :: GenClosure b -> !WhyBlocked
[flags] :: GenClosure b -> ![TsoFlags]
[threadId] :: GenClosure b -> !Word64
[saved_errno] :: GenClosure b -> !Word32

-- | non-zero =&gt; dirty
[tso_dirty] :: GenClosure b -> !Word32
[alloc_limit] :: GenClosure b -> !Int64
[tot_stack_size] :: GenClosure b -> !Word32
[prof] :: GenClosure b -> !Maybe StgTSOProfInfo

-- | Representation of StgStack: The 'tsoStack ' of a <a>TSOClosure</a>.
StackClosure :: !StgInfoTable -> !Word32 -> !Word8 -> !Word8 -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | stack size in *words*
[stack_size] :: GenClosure b -> !Word32

-- | non-zero =&gt; dirty
[stack_dirty] :: GenClosure b -> !Word8
[stack_marking] :: GenClosure b -> !Word8

-- | Primitive Int
IntClosure :: PrimType -> !Int -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[intVal] :: GenClosure b -> !Int

-- | Primitive Word
WordClosure :: PrimType -> !Word -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[wordVal] :: GenClosure b -> !Word

-- | Primitive Int64
Int64Closure :: PrimType -> !Int64 -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[int64Val] :: GenClosure b -> !Int64

-- | Primitive Word64
Word64Closure :: PrimType -> !Word64 -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[word64Val] :: GenClosure b -> !Word64

-- | Primitive Addr
AddrClosure :: PrimType -> !Ptr () -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[addrVal] :: GenClosure b -> !Ptr ()

-- | Primitive Float
FloatClosure :: PrimType -> !Float -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[floatVal] :: GenClosure b -> !Float

-- | Primitive Double
DoubleClosure :: PrimType -> !Double -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[doubleVal] :: GenClosure b -> !Double

-- | Another kind of closure
OtherClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable
[hvalues] :: GenClosure b -> ![b]
[rawWords] :: GenClosure b -> ![Word]
UnsupportedClosure :: !StgInfoTable -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | A primitive word from a bitmap encoded stack frame payload
--   
--   The type itself cannot be restored (i.e. it might represent a Word8#
--   or an Int#).
UnknownTypeWordSizedPrimitive :: !Word -> GenClosure b
[wordVal] :: GenClosure b -> !Word

-- | Enum representing closure types This is a mirror of:
--   <tt>rts<i>include</i>rts<i>storage</i>ClosureTypes.h</tt>
data ClosureType
INVALID_OBJECT :: ClosureType
CONSTR :: ClosureType
CONSTR_1_0 :: ClosureType
CONSTR_0_1 :: ClosureType
CONSTR_2_0 :: ClosureType
CONSTR_1_1 :: ClosureType
CONSTR_0_2 :: ClosureType
CONSTR_NOCAF :: ClosureType
FUN :: ClosureType
FUN_1_0 :: ClosureType
FUN_0_1 :: ClosureType
FUN_2_0 :: ClosureType
FUN_1_1 :: ClosureType
FUN_0_2 :: ClosureType
FUN_STATIC :: ClosureType
THUNK :: ClosureType
THUNK_1_0 :: ClosureType
THUNK_0_1 :: ClosureType
THUNK_2_0 :: ClosureType
THUNK_1_1 :: ClosureType
THUNK_0_2 :: ClosureType
THUNK_STATIC :: ClosureType
THUNK_SELECTOR :: ClosureType
BCO :: ClosureType
AP :: ClosureType
PAP :: ClosureType
AP_STACK :: ClosureType
IND :: ClosureType
IND_STATIC :: ClosureType
RET_BCO :: ClosureType
RET_SMALL :: ClosureType
RET_BIG :: ClosureType
RET_FUN :: ClosureType
UPDATE_FRAME :: ClosureType
CATCH_FRAME :: ClosureType
UNDERFLOW_FRAME :: ClosureType
STOP_FRAME :: ClosureType
BLOCKING_QUEUE :: ClosureType
BLACKHOLE :: ClosureType
MVAR_CLEAN :: ClosureType
MVAR_DIRTY :: ClosureType
TVAR :: ClosureType
ARR_WORDS :: ClosureType
MUT_ARR_PTRS_CLEAN :: ClosureType
MUT_ARR_PTRS_DIRTY :: ClosureType
MUT_ARR_PTRS_FROZEN_DIRTY :: ClosureType
MUT_ARR_PTRS_FROZEN_CLEAN :: ClosureType
MUT_VAR_CLEAN :: ClosureType
MUT_VAR_DIRTY :: ClosureType
WEAK :: ClosureType
PRIM :: ClosureType
MUT_PRIM :: ClosureType
TSO :: ClosureType
STACK :: ClosureType
TREC_CHUNK :: ClosureType
ATOMICALLY_FRAME :: ClosureType
CATCH_RETRY_FRAME :: ClosureType
CATCH_STM_FRAME :: ClosureType
WHITEHOLE :: ClosureType
SMALL_MUT_ARR_PTRS_CLEAN :: ClosureType
SMALL_MUT_ARR_PTRS_DIRTY :: ClosureType
SMALL_MUT_ARR_PTRS_FROZEN_DIRTY :: ClosureType
SMALL_MUT_ARR_PTRS_FROZEN_CLEAN :: ClosureType
COMPACT_NFDATA :: ClosureType
CONTINUATION :: ClosureType
N_CLOSURE_TYPES :: ClosureType
data PrimType
PInt :: PrimType
PWord :: PrimType
PInt64 :: PrimType
PWord64 :: PrimType
PAddr :: PrimType
PFloat :: PrimType
PDouble :: PrimType
data WhatNext
ThreadRunGHC :: WhatNext
ThreadInterpret :: WhatNext
ThreadKilled :: WhatNext
ThreadComplete :: WhatNext

-- | Please report this as a bug
WhatNextUnknownValue :: Word16 -> WhatNext
data WhyBlocked
NotBlocked :: WhyBlocked
BlockedOnMVar :: WhyBlocked
BlockedOnMVarRead :: WhyBlocked
BlockedOnBlackHole :: WhyBlocked
BlockedOnRead :: WhyBlocked
BlockedOnWrite :: WhyBlocked
BlockedOnDelay :: WhyBlocked
BlockedOnSTM :: WhyBlocked
BlockedOnDoProc :: WhyBlocked
BlockedOnCCall :: WhyBlocked
BlockedOnCCall_Interruptible :: WhyBlocked
BlockedOnMsgThrowTo :: WhyBlocked
ThreadMigrating :: WhyBlocked

-- | Please report this as a bug
WhyBlockedUnknownValue :: Word16 -> WhyBlocked
data TsoFlags
TsoLocked :: TsoFlags
TsoBlockx :: TsoFlags
TsoInterruptible :: TsoFlags
TsoStoppedOnBreakpoint :: TsoFlags
TsoMarked :: TsoFlags
TsoSqueezed :: TsoFlags
TsoAllocLimit :: TsoFlags

-- | Please report this as a bug
TsoFlagsUnknownValue :: Word32 -> TsoFlags
class HasHeapRep (a :: TYPE rep)

-- | Decode a closure to it's heap representation (<a>GenClosure</a>).
getClosureData :: HasHeapRep a => a -> IO Closure

-- | Convert an unpacked heap object, to a `GenClosure b`. The inputs to
--   this function can be generated from a heap object using
--   <a>unpackClosure#</a>.
getClosureDataFromHeapRep :: ByteArray# -> Ptr StgInfoTable -> [b] -> IO (GenClosure b)
getClosureDataFromHeapRepPrim :: IO (String, String, String) -> (Ptr a -> IO (Maybe CostCentreStack)) -> StgInfoTable -> ByteArray# -> [b] -> IO (GenClosure b)

-- | This is a somewhat faithful representation of an info table. See
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/storage/InfoTables.h</a>
--   for more details on this data structure.
data StgInfoTable
StgInfoTable :: Maybe EntryFunPtr -> HalfWord -> HalfWord -> ClosureType -> HalfWord -> Maybe ItblCodes -> StgInfoTable
[entry] :: StgInfoTable -> Maybe EntryFunPtr
[ptrs] :: StgInfoTable -> HalfWord
[nptrs] :: StgInfoTable -> HalfWord
[tipe] :: StgInfoTable -> ClosureType
[srtlen] :: StgInfoTable -> HalfWord
[code] :: StgInfoTable -> Maybe ItblCodes
type EntryFunPtr = FunPtr Ptr () -> IO Ptr ()
type HalfWord = Word32
type ItblCodes = Either [Word8] [Word32]

-- | Size in bytes of a standard InfoTable
itblSize :: Int

-- | Read an InfoTable from the heap into a haskell type. WARNING: This
--   code assumes it is passed a pointer to a "standard" info table. If
--   tables_next_to_code is enabled, it will look 1 byte before the start
--   for the entry field.
peekItbl :: Ptr StgInfoTable -> IO StgInfoTable
pokeItbl :: Ptr StgInfoTable -> StgInfoTable -> IO ()

-- | This is a somewhat faithful representation of StgTSOProfInfo. See
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/storage/TSO.h</a>
--   for more details on this data structure.
newtype StgTSOProfInfo
StgTSOProfInfo :: Maybe CostCentreStack -> StgTSOProfInfo
[cccs] :: StgTSOProfInfo -> Maybe CostCentreStack

-- | This is a somewhat faithful representation of IndexTable. See
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/prof/CCS.h</a>
--   for more details on this data structure.
data IndexTable
IndexTable :: CostCentre -> Maybe CostCentreStack -> Maybe IndexTable -> Bool -> IndexTable
[it_cc] :: IndexTable -> CostCentre
[it_ccs] :: IndexTable -> Maybe CostCentreStack
[it_next] :: IndexTable -> Maybe IndexTable
[it_back_edge] :: IndexTable -> Bool

-- | This is a somewhat faithful representation of CostCentre. See
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/prof/CCS.h</a>
--   for more details on this data structure.
data CostCentre
CostCentre :: Int -> String -> String -> Maybe String -> Word64 -> Word -> Bool -> Maybe CostCentre -> CostCentre
[cc_ccID] :: CostCentre -> Int
[cc_label] :: CostCentre -> String
[cc_module] :: CostCentre -> String
[cc_srcloc] :: CostCentre -> Maybe String
[cc_mem_alloc] :: CostCentre -> Word64
[cc_time_ticks] :: CostCentre -> Word
[cc_is_caf] :: CostCentre -> Bool
[cc_link] :: CostCentre -> Maybe CostCentre

-- | This is a somewhat faithful representation of CostCentreStack. See
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/prof/CCS.h</a>
--   for more details on this data structure.
data CostCentreStack
CostCentreStack :: Int -> CostCentre -> Maybe CostCentreStack -> Maybe IndexTable -> Maybe CostCentreStack -> Word -> Word64 -> Word -> Word -> Word64 -> Word64 -> Word -> CostCentreStack
[ccs_ccsID] :: CostCentreStack -> Int
[ccs_cc] :: CostCentreStack -> CostCentre
[ccs_prevStack] :: CostCentreStack -> Maybe CostCentreStack
[ccs_indexTable] :: CostCentreStack -> Maybe IndexTable
[ccs_root] :: CostCentreStack -> Maybe CostCentreStack
[ccs_depth] :: CostCentreStack -> Word
[ccs_scc_count] :: CostCentreStack -> Word64
[ccs_selected] :: CostCentreStack -> Word
[ccs_time_ticks] :: CostCentreStack -> Word
[ccs_mem_alloc] :: CostCentreStack -> Word64
[ccs_inherited_alloc] :: CostCentreStack -> Word64
[ccs_inherited_ticks] :: CostCentreStack -> Word

-- | Like <a>getClosureData</a>, but taking a <a>Box</a>, so it is easier
--   to work with.
getBoxedClosureData :: Box -> IO Closure

-- | For generic code, this function returns all referenced closures.
allClosures :: GenClosure b -> [b]

-- | An arbitrary Haskell value in a safe Box. The point is that even
--   unevaluated thunks can safely be moved around inside the Box, and when
--   required, e.g. in <tt>getBoxedClosureData</tt>, the function knows how
--   far it has to evaluate the argument.
data Box
Box :: (Any :: Type) -> Box

-- | This takes an arbitrary value and puts it into a box. Note that calls
--   like
--   
--   <pre>
--   asBox (head list)
--   </pre>
--   
--   will put the thunk "head list" into the box, <i>not</i> the element at
--   the head of the list. For that, use careful case expressions:
--   
--   <pre>
--   case list of x:_ -&gt; asBox x
--   </pre>
asBox :: a -> Box

-- | Boxes can be compared, but this is not pure, as different heap objects
--   can, after garbage collection, become the same object.
areBoxesEqual :: Box -> Box -> IO Bool
instance (GHC.Prim.Addr# GHC.Types.~ a) => GHC.Exts.Heap.HasHeapRep a
instance GHC.Exts.Heap.HasHeapRep a
instance GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Double# GHC.Types.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Float# GHC.Types.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Int64# GHC.Types.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Int# GHC.Types.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Word64# GHC.Types.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Word# GHC.Types.~ a) => GHC.Exts.Heap.HasHeapRep a

module GHC.Exts.Stack.Constants
newtype ByteOffset
ByteOffset :: Int -> ByteOffset
[offsetInBytes] :: ByteOffset -> Int
newtype WordOffset
WordOffset :: Int -> WordOffset
[offsetInWords] :: WordOffset -> Int
offsetStgCatchFrameHandler :: WordOffset
sizeStgCatchFrame :: Int
offsetStgCatchSTMFrameCode :: WordOffset
offsetStgCatchSTMFrameHandler :: WordOffset
sizeStgCatchSTMFrame :: Int
offsetStgUpdateFrameUpdatee :: WordOffset
sizeStgUpdateFrame :: Int
offsetStgAtomicallyFrameCode :: WordOffset
offsetStgAtomicallyFrameResult :: WordOffset
sizeStgAtomicallyFrame :: Int
offsetStgCatchRetryFrameRunningAltCode :: WordOffset
offsetStgCatchRetryFrameRunningFirstCode :: WordOffset
offsetStgCatchRetryFrameAltCode :: WordOffset
sizeStgCatchRetryFrame :: Int
offsetStgRetFunFrameSize :: WordOffset
offsetStgRetFunFrameFun :: WordOffset
offsetStgRetFunFramePayload :: WordOffset
sizeStgRetFunFrame :: Int
offsetStgBCOFrameInstrs :: ByteOffset
offsetStgBCOFrameLiterals :: ByteOffset
offsetStgBCOFramePtrs :: ByteOffset
offsetStgBCOFrameArity :: ByteOffset
offsetStgBCOFrameSize :: ByteOffset
offsetStgClosurePayload :: WordOffset
sizeStgClosure :: Int
byteOffsetToWordOffset :: ByteOffset -> WordOffset
bytesToWords :: Int -> Int
bytesInWord :: Int
instance GHC.Internal.Enum.Enum GHC.Exts.Stack.Constants.ByteOffset
instance GHC.Internal.Enum.Enum GHC.Exts.Stack.Constants.WordOffset
instance GHC.Classes.Eq GHC.Exts.Stack.Constants.ByteOffset
instance GHC.Classes.Eq GHC.Exts.Stack.Constants.WordOffset
instance GHC.Internal.Real.Integral GHC.Exts.Stack.Constants.ByteOffset
instance GHC.Internal.Real.Integral GHC.Exts.Stack.Constants.WordOffset
instance GHC.Internal.Num.Num GHC.Exts.Stack.Constants.ByteOffset
instance GHC.Internal.Num.Num GHC.Exts.Stack.Constants.WordOffset
instance GHC.Classes.Ord GHC.Exts.Stack.Constants.ByteOffset
instance GHC.Classes.Ord GHC.Exts.Stack.Constants.WordOffset
instance GHC.Internal.Real.Real GHC.Exts.Stack.Constants.ByteOffset
instance GHC.Internal.Real.Real GHC.Exts.Stack.Constants.WordOffset
instance GHC.Internal.Show.Show GHC.Exts.Stack.Constants.ByteOffset
instance GHC.Internal.Show.Show GHC.Exts.Stack.Constants.WordOffset

module GHC.Exts.Stack.Decode

-- | Decode <a>StackSnapshot</a> to a <a>StgStackClosure</a>
--   
--   The return value is the representation of the <tt>StgStack</tt>
--   itself.
--   
--   See <i>Note [Decoding the stack]</i>.
decodeStack :: StackSnapshot -> IO StgStackClosure
instance GHC.Internal.Show.Show GHC.Exts.Stack.Decode.Pointerness

module GHC.Exts.Stack

-- | Decode <a>StackSnapshot</a> to a <a>StgStackClosure</a>
--   
--   The return value is the representation of the <tt>StgStack</tt>
--   itself.
--   
--   See <i>Note [Decoding the stack]</i>.
decodeStack :: StackSnapshot -> IO StgStackClosure

-- | Get the size of the <a>StackFrame</a> in words.
--   
--   Includes header and payload. Does not follow pointers.
stackFrameSize :: StackFrame -> Int
