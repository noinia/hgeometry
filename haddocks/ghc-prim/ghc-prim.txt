-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | GHC primitives
--   
--   This package contains the primitive types and operations supplied by
--   GHC. It is an internal package, only for the use of GHC developers.
--   GHC users should not use it! If you do use it then expect breaking
--   changes at any time without warning. You should prefer to import
--   <tt>GHC.Exts</tt> from the <tt>base</tt> package instead.
@package ghc-prim
@version 0.13.0


-- | GHC type definitions. Use GHC.Exts from the base package instead of
--   importing this module directly.
module GHC.Types
data Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> represents Unicode codespace and its
--   elements are code points as in definitions <a>D9 and D10 of the
--   Unicode Standard</a>.
--   
--   Character literals in Haskell are single-quoted: <tt>'Q'</tt>,
--   <tt>'Ð¯'</tt> or <tt>'Î©'</tt>. To represent a single quote itself use
--   <tt>'\''</tt>, and to represent a backslash use <tt>'\\'</tt>. The
--   full grammar can be found in the section 2.6 of the <a>Haskell 2010
--   Language Report</a>.
--   
--   To specify a character by its code point one can use decimal,
--   hexadecimal or octal notation: <tt>'\65'</tt>, <tt>'\x41'</tt> and
--   <tt>'\o101'</tt> are all alternative forms of <tt>'A'</tt>. The
--   largest code point is <tt>'\x10ffff'</tt>.
--   
--   There is a special escape syntax for ASCII control characters:
--   
--   TODO: table
--   
--   <a>Data.Char</a> provides utilities to work with <a>Char</a>.
data Char
C# :: Char# -> Char

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int
I# :: Int# -> Int

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word
W# :: Word# -> Word

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float
F# :: Float# -> Float

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double
D# :: Double# -> Double
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
newtype IO a
IO :: (State# RealWorld -> (# State# RealWorld, a #)) -> IO a

-- | The builtin linked list type.
--   
--   In Haskell, lists are one of the most important data types as they are
--   often used analogous to loops in imperative programming languages.
--   These lists are singly linked, which makes them unsuited for
--   operations that require &lt;math&gt; access. Instead, they are
--   intended to be traversed.
--   
--   You can use <tt>List a</tt> or <tt>[a]</tt> in type signatures:
--   
--   <pre>
--   length :: [a] -&gt; Int
--   </pre>
--   
--   or
--   
--   <pre>
--   length :: List a -&gt; Int
--   </pre>
--   
--   They are fully equivalent, and <tt>List a</tt> will be normalised to
--   <tt>[a]</tt>.
--   
--   <h4>Usage</h4>
--   
--   Lists are constructed recursively using the right-associative
--   constructor operator (or <i>cons</i>) <tt>(:) :: a -&gt; [a] -&gt;
--   [a]</tt>, which prepends an element to a list, and the empty list
--   <tt>[]</tt>.
--   
--   <pre>
--   (1 : 2 : 3 : []) == (1 : (2 : (3 : []))) == [1, 2, 3]
--   </pre>
--   
--   Lists can also be constructed using list literals of the form
--   <tt>[x_1, x_2, ..., x_n]</tt> which are syntactic sugar and, unless
--   <tt>-XOverloadedLists</tt> is enabled, are translated into uses of
--   <tt>(:)</tt> and <tt>[]</tt>
--   
--   <a>String</a> literals, like <tt>"I ðŸ’œ hs"</tt>, are translated into
--   Lists of characters, <tt>['I', ' ', 'ðŸ’œ', ' ', 'h', 's']</tt>.
--   
--   <h4><b>Implementation</b></h4>
--   
--   Internally and in memory, all the above are represented like this,
--   with arrows being pointers to locations in memory.
--   
--   <pre>
--   â•­â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â•®   â•­â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â•®   â•­â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â•®   â•­â”€â”€â”€â”€â•®
--   â”‚(:)â”‚   â”‚ â”€â”¼â”€â”€&gt;â”‚(:)â”‚   â”‚ â”€â”¼â”€â”€&gt;â”‚(:)â”‚   â”‚ â”€â”¼â”€â”€&gt;â”‚ [] â”‚
--   â•°â”€â”€â”€â”´â”€â”¼â”€â”´â”€â”€â•¯   â•°â”€â”€â”€â”´â”€â”¼â”€â”´â”€â”€â•¯   â•°â”€â”€â”€â”´â”€â”¼â”€â”´â”€â”€â•¯   â•°â”€â”€â”€â”€â•¯
--         v              v              v
--         1              2              3
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; ['H', 'a', 's', 'k', 'e', 'l', 'l']
--   "Haskell"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 : [4, 1, 5, 9]
--   [1,4,1,5,9]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] : [] : []
--   [[],[]]
--   </pre>
data [] a

-- | Alias for <a>tagToEnum#</a>. Returns True if its parameter is 1# and
--   False if it is 0#.
isTrue# :: Int# -> Bool

-- | <a>SPEC</a> is used by GHC in the <tt>SpecConstr</tt> pass in order to
--   inform the compiler when to be particularly aggressive. In particular,
--   it tells GHC to specialize regardless of size or the number of
--   specializations. However, not all loops fall into this category.
--   
--   Libraries can specify this by using <a>SPEC</a> data type to inform
--   which loops should be aggressively specialized. For example, instead
--   of
--   
--   <pre>
--   loop x where loop arg = ...
--   </pre>
--   
--   write
--   
--   <pre>
--   loop SPEC x where loop !_ arg = ...
--   </pre>
--   
--   There is no semantic difference between <a>SPEC</a> and <a>SPEC2</a>,
--   we just need a type with two constructors lest it is optimised away
--   before <tt>SpecConstr</tt>.
--   
--   This type is reexported from <a>GHC.Exts</a> since GHC 9.0 and
--   <tt>base-4.15</tt>. For compatibility with earlier releases import it
--   from <a>GHC.Types</a> in <tt>ghc-prim</tt> package.
data SPEC
SPEC :: SPEC
SPEC2 :: SPEC

-- | (Kind) This is the kind of type-level symbols.
data Symbol

-- | The type constructor <tt>Any :: forall k. k</tt> is a type to which
--   you can unsafely coerce any type, and back.
--   
--   For <tt>unsafeCoerce</tt> this means for all lifted types <tt>t</tt>
--   that <tt>unsafeCoerce (unsafeCoerce x :: Any) :: t</tt> is equivalent
--   to <tt>x</tt> and safe.
--   
--   The same is true for *all* types when using <tt> unsafeCoerce# ::
--   forall (r1 :: RuntimeRep) (r2 :: RuntimeRep) (a :: TYPE r1) (b :: TYPE
--   r2). a -&gt; b </tt> but <i>only</i> if you instantiate <tt>r1</tt>
--   and <tt>r2</tt> to the <i>same</i> runtime representation. For example
--   using <tt>(unsafeCoerce# :: forall (a :: TYPE IntRep) (b :: TYPE
--   IntRep). a -&gt; b) x</tt> is fine, but <tt>(unsafeCoerce# :: forall
--   (a :: TYPE IntRep) (b :: TYPE FloatRep). a -&gt; b)</tt> will likely
--   cause seg-faults or worse. For this resason, users should always
--   prefer unsafeCoerce over unsafeCoerce# when possible.
--   
--   Here are some more examples: <tt> bad_a1 :: Any </tt>(TYPE 'IntRep)
--   bad_a1 = unsafeCoerce# True
--   
--   bad_a2 :: Any <tt>(TYPE ('BoxedRep 'UnliftedRep)) bad_a2 =
--   unsafeCoerce# True </tt> Here <tt>bad_a1</tt> is bad because we
--   started with <tt>True :: (Bool :: Type)</tt>, represented by a boxed
--   heap pointer, and coerced it to <tt>a1 :: Any </tt>(TYPE 'IntRep)<tt>,
--   whose representation is a non-pointer integer. That's why we had to
--   use <tt>unsafeCoerce#</tt>; it is really unsafe because it can change
--   representations. Similarly </tt>bad_a2<tt> is bad because although
--   both </tt>True<tt> and </tt>bad_a2<tt> are represented by a heap
--   pointer, </tt>True<tt> is lifted but </tt>bad_a2@ is not; bugs here
--   may be rather subtle.
--   
--   If you must use unsafeCoerce# to cast to <a>Any</a>, type annotations
--   are recommended to make sure that <tt>Any</tt> has the correct kind.
--   As casting between different runtimereps is unsound. For example to
--   cast a <tt>ByteArray#</tt> to <tt>Any</tt> you might use: <tt>
--   unsafeCoerce# b :: (Any :: TYPE ('BoxedRep 'Unlifted)) </tt>
type family Any :: k

-- | Lifted, homogeneous equality. By lifted, we mean that it can be bogus
--   (deferred type error). By homogeneous, the two types <tt>a</tt> and
--   <tt>b</tt> must have the same kinds.
class a ~# b => (a :: k) ~ (b :: k)
infix 4 ~

-- | Lifted, heterogeneous equality. By lifted, we mean that it can be
--   bogus (deferred type error). By heterogeneous, the two types
--   <tt>a</tt> and <tt>b</tt> might have different kinds. Because
--   <tt>~~</tt> can appear unexpectedly in error messages to users who do
--   not care about the difference between heterogeneous equality
--   <tt>~~</tt> and homogeneous equality <tt>~</tt>, this is printed as
--   <tt>~</tt> unless <tt>-fprint-equality-relations</tt> is set.
--   
--   In <tt>0.7.0</tt>, the fixity was set to <tt>infix 4</tt> to match the
--   fixity of <a>:~~:</a>.
class a ~# b => (a :: k0) ~~ (b :: k1)
infix 4 ~~

-- | <tt>Coercible</tt> is a two-parameter class that has instances for
--   types <tt>a</tt> and <tt>b</tt> if the compiler can infer that they
--   have the same representation. This class does not have regular
--   instances; instead they are created on-the-fly during type-checking.
--   Trying to manually declare an instance of <tt>Coercible</tt> is an
--   error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance Coercible a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class a ~R# b => Coercible (a :: k) (b :: k)
data TYPE (a :: RuntimeRep)
data CONSTRAINT (a :: RuntimeRep)

-- | Whether a boxed type is lifted or unlifted.
data Levity
Lifted :: Levity
Unlifted :: Levity

-- | GHC maintains a property that the kind of all inhabited types (as
--   distinct from type constructors or type-level data) tells us the
--   runtime representation of values of that type. This datatype encodes
--   the choice of runtime value. Note that <a>TYPE</a> is parameterised by
--   <a>RuntimeRep</a>; this is precisely what we mean by the fact that a
--   type's kind encodes the runtime representation.
--   
--   For boxed values (that is, values that are represented by a pointer),
--   a further distinction is made, between lifted types (that contain âŠ¥),
--   and unlifted ones (that don't).
data RuntimeRep

-- | a SIMD vector type
VecRep :: VecCount -> VecElem -> RuntimeRep

-- | An unboxed tuple of the given reps
TupleRep :: [RuntimeRep] -> RuntimeRep

-- | An unboxed sum of the given reps
SumRep :: [RuntimeRep] -> RuntimeRep

-- | boxed; represented by a pointer
BoxedRep :: Levity -> RuntimeRep

-- | signed, word-sized value
IntRep :: RuntimeRep

-- | signed, 8-bit value
Int8Rep :: RuntimeRep

-- | signed, 16-bit value
Int16Rep :: RuntimeRep

-- | signed, 32-bit value
Int32Rep :: RuntimeRep

-- | signed, 64-bit value
Int64Rep :: RuntimeRep

-- | unsigned, word-sized value
WordRep :: RuntimeRep

-- | unsigned, 8-bit value
Word8Rep :: RuntimeRep

-- | unsigned, 16-bit value
Word16Rep :: RuntimeRep

-- | unsigned, 32-bit value
Word32Rep :: RuntimeRep

-- | unsigned, 64-bit value
Word64Rep :: RuntimeRep

-- | A pointer, but <i>not</i> to a Haskell value
AddrRep :: RuntimeRep

-- | a 32-bit floating point number
FloatRep :: RuntimeRep

-- | a 64-bit floating point number
DoubleRep :: RuntimeRep

-- | The runtime representation of lifted types.
type LiftedRep = 'BoxedRep 'Lifted

-- | The runtime representation of unlifted types.
type UnliftedRep = 'BoxedRep 'Unlifted

-- | The kind of types with lifted values. For example <tt>Int ::
--   Type</tt>.
type Type = TYPE LiftedRep

-- | The kind of boxed, unlifted values, for example <tt>Array#</tt> or a
--   user-defined unlifted data type, using <tt>-XUnliftedDataTypes</tt>.
type UnliftedType = TYPE UnliftedRep

-- | The kind of lifted constraints
type Constraint = CONSTRAINT LiftedRep

-- | The runtime representation of a zero-width tuple, represented by no
--   bits at all
type ZeroBitRep = 'TupleRep '[] :: [RuntimeRep]

-- | The kind of the empty unboxed tuple type (# #)
type ZeroBitType = TYPE ZeroBitRep

-- | Length of a SIMD vector type
data VecCount
Vec2 :: VecCount
Vec4 :: VecCount
Vec8 :: VecCount
Vec16 :: VecCount
Vec32 :: VecCount
Vec64 :: VecCount

-- | Element of a SIMD vector type
data VecElem
Int8ElemRep :: VecElem
Int16ElemRep :: VecElem
Int32ElemRep :: VecElem
Int64ElemRep :: VecElem
Word8ElemRep :: VecElem
Word16ElemRep :: VecElem
Word32ElemRep :: VecElem
Word64ElemRep :: VecElem
FloatElemRep :: VecElem
DoubleElemRep :: VecElem

-- | <i>Deprecated: Void# is now an alias for the unboxed tuple (# #).</i>
type Void# = (# #)

-- | Data type <tt>Dict</tt> provides a simple way to wrap up a (lifted)
--   constraint as a type
data DictBox a
MkDictBox :: DictBox a
data WordBox (a :: TYPE 'WordRep)
MkWordBox :: a -> WordBox (a :: TYPE 'WordRep)
data IntBox (a :: TYPE 'IntRep)
MkIntBox :: a -> IntBox (a :: TYPE 'IntRep)
data FloatBox (a :: TYPE 'FloatRep)
MkFloatBox :: a -> FloatBox (a :: TYPE 'FloatRep)
data DoubleBox (a :: TYPE 'DoubleRep)
MkDoubleBox :: a -> DoubleBox (a :: TYPE 'DoubleRep)
data Multiplicity
One :: Multiplicity
Many :: Multiplicity
type family MultMul (a :: Multiplicity) (b :: Multiplicity) :: Multiplicity
data Module
Module :: TrName -> TrName -> Module
data TrName

-- | Static
TrNameS :: Addr# -> TrName

-- | Dynamic
TrNameD :: [Char] -> TrName
data TyCon
TyCon :: Word64# -> Word64# -> Module -> TrName -> Int# -> KindRep -> TyCon
data TypeLitSort
TypeLitSymbol :: TypeLitSort
TypeLitNat :: TypeLitSort
TypeLitChar :: TypeLitSort

-- | The representation produced by GHC for conjuring up the kind of a
--   <a>TypeRep</a>.
data KindRep
KindRepTyConApp :: TyCon -> [KindRep] -> KindRep
KindRepVar :: !KindBndr -> KindRep
KindRepApp :: KindRep -> KindRep -> KindRep
KindRepFun :: KindRep -> KindRep -> KindRep
KindRepTYPE :: !RuntimeRep -> KindRep
KindRepTypeLitS :: TypeLitSort -> Addr# -> KindRep
KindRepTypeLitD :: TypeLitSort -> [Char] -> KindRep

-- | A de Bruijn index for a binder within a <a>KindRep</a>.
type KindBndr = Int
data (##) :: ZeroBitType
data Solo# (a :: TYPE k) :: TYPE 'TupleRep '[k]
MkSolo# :: a -> Solo# (a :: TYPE k)
type Tuple0# = (# #)
type Tuple1# = Solo# :: Type -> TYPE 'TupleRep '[LiftedRep]
data (#,#) (a :: TYPE k0) (b :: TYPE k1) :: TYPE 'TupleRep '[k0, k1]
data (#,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) :: TYPE 'TupleRep '[k0, k1, k2]
data (#,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) :: TYPE 'TupleRep '[k0, k1, k2, k3]
data (#,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4]
data (#,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5]
data (#,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6]
data (#,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7]
data (#,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8]
data (#,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9]
data (#,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10]
data (#,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11]
data (#,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12]
data (#,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13]
data (#,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14]
data (#,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15]
data (#,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16]
data (#,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17]
data (#,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18]
data (#,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19]
data (#,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20]
data (#,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21]
data (#,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22]
data (#,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23]
data (#,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) (t53 :: TYPE k53) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52, k53]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) (t53 :: TYPE k53) (t54 :: TYPE k54) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52, k53, k54]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) (t53 :: TYPE k53) (t54 :: TYPE k54) (t55 :: TYPE k55) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52, k53, k54, k55]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) (t53 :: TYPE k53) (t54 :: TYPE k54) (t55 :: TYPE k55) (t56 :: TYPE k56) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52, k53, k54, k55, k56]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) (t53 :: TYPE k53) (t54 :: TYPE k54) (t55 :: TYPE k55) (t56 :: TYPE k56) (t57 :: TYPE k57) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52, k53, k54, k55, k56, k57]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) (t53 :: TYPE k53) (t54 :: TYPE k54) (t55 :: TYPE k55) (t56 :: TYPE k56) (t57 :: TYPE k57) (t58 :: TYPE k58) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52, k53, k54, k55, k56, k57, k58]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) (t53 :: TYPE k53) (t54 :: TYPE k54) (t55 :: TYPE k55) (t56 :: TYPE k56) (t57 :: TYPE k57) (t58 :: TYPE k58) (t59 :: TYPE k59) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52, k53, k54, k55, k56, k57, k58, k59]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) (t53 :: TYPE k53) (t54 :: TYPE k54) (t55 :: TYPE k55) (t56 :: TYPE k56) (t57 :: TYPE k57) (t58 :: TYPE k58) (t59 :: TYPE k59) (t60 :: TYPE k60) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52, k53, k54, k55, k56, k57, k58, k59, k60]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) (t53 :: TYPE k53) (t54 :: TYPE k54) (t55 :: TYPE k55) (t56 :: TYPE k56) (t57 :: TYPE k57) (t58 :: TYPE k58) (t59 :: TYPE k59) (t60 :: TYPE k60) (t61 :: TYPE k61) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52, k53, k54, k55, k56, k57, k58, k59, k60, k61]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) (t53 :: TYPE k53) (t54 :: TYPE k54) (t55 :: TYPE k55) (t56 :: TYPE k56) (t57 :: TYPE k57) (t58 :: TYPE k58) (t59 :: TYPE k59) (t60 :: TYPE k60) (t61 :: TYPE k61) (t62 :: TYPE k62) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52, k53, k54, k55, k56, k57, k58, k59, k60, k61, k62]
data (#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) (t53 :: TYPE k53) (t54 :: TYPE k54) (t55 :: TYPE k55) (t56 :: TYPE k56) (t57 :: TYPE k57) (t58 :: TYPE k58) (t59 :: TYPE k59) (t60 :: TYPE k60) (t61 :: TYPE k61) (t62 :: TYPE k62) (t63 :: TYPE k63) :: TYPE 'TupleRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52, k53, k54, k55, k56, k57, k58, k59, k60, k61, k62, k63]
data (# | #) (a :: TYPE k0) (b :: TYPE k1) :: TYPE 'SumRep '[k0, k1]
data (# | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) :: TYPE 'SumRep '[k0, k1, k2]
data (# | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) :: TYPE 'SumRep '[k0, k1, k2, k3]
data (# | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) :: TYPE 'SumRep '[k0, k1, k2, k3, k4]
data (# | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5]
data (# | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6]
data (# | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7]
data (# | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8]
data (# | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9]
data (# | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10]
data (# | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11]
data (# | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12]
data (# | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13]
data (# | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14]
data (# | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15]
data (# | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16]
data (# | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17]
data (# | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18]
data (# | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19]
data (# | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20]
data (# | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21]
data (# | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22]
data (# | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23]
data (# | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) (t53 :: TYPE k53) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52, k53]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) (t53 :: TYPE k53) (t54 :: TYPE k54) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52, k53, k54]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) (t53 :: TYPE k53) (t54 :: TYPE k54) (t55 :: TYPE k55) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52, k53, k54, k55]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) (t53 :: TYPE k53) (t54 :: TYPE k54) (t55 :: TYPE k55) (t56 :: TYPE k56) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52, k53, k54, k55, k56]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) (t53 :: TYPE k53) (t54 :: TYPE k54) (t55 :: TYPE k55) (t56 :: TYPE k56) (t57 :: TYPE k57) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52, k53, k54, k55, k56, k57]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) (t53 :: TYPE k53) (t54 :: TYPE k54) (t55 :: TYPE k55) (t56 :: TYPE k56) (t57 :: TYPE k57) (t58 :: TYPE k58) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52, k53, k54, k55, k56, k57, k58]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) (t53 :: TYPE k53) (t54 :: TYPE k54) (t55 :: TYPE k55) (t56 :: TYPE k56) (t57 :: TYPE k57) (t58 :: TYPE k58) (t59 :: TYPE k59) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52, k53, k54, k55, k56, k57, k58, k59]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) (t53 :: TYPE k53) (t54 :: TYPE k54) (t55 :: TYPE k55) (t56 :: TYPE k56) (t57 :: TYPE k57) (t58 :: TYPE k58) (t59 :: TYPE k59) (t60 :: TYPE k60) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52, k53, k54, k55, k56, k57, k58, k59, k60]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) (t53 :: TYPE k53) (t54 :: TYPE k54) (t55 :: TYPE k55) (t56 :: TYPE k56) (t57 :: TYPE k57) (t58 :: TYPE k58) (t59 :: TYPE k59) (t60 :: TYPE k60) (t61 :: TYPE k61) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52, k53, k54, k55, k56, k57, k58, k59, k60, k61]
data (# | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | #) (a :: TYPE k0) (b :: TYPE k1) (c :: TYPE k2) (d :: TYPE k3) (e :: TYPE k4) (f :: TYPE k5) (g :: TYPE k6) (h :: TYPE k7) (i :: TYPE k8) (j :: TYPE k9) (k :: TYPE k10) (l :: TYPE k11) (m :: TYPE k12) (n :: TYPE k13) (o :: TYPE k14) (p :: TYPE k15) (q :: TYPE k16) (r :: TYPE k17) (s :: TYPE k18) (t :: TYPE k19) (u :: TYPE k20) (v :: TYPE k21) (w :: TYPE k22) (x :: TYPE k23) (y :: TYPE k24) (z :: TYPE k25) (t26 :: TYPE k26) (t27 :: TYPE k27) (t28 :: TYPE k28) (t29 :: TYPE k29) (t30 :: TYPE k30) (t31 :: TYPE k31) (t32 :: TYPE k32) (t33 :: TYPE k33) (t34 :: TYPE k34) (t35 :: TYPE k35) (t36 :: TYPE k36) (t37 :: TYPE k37) (t38 :: TYPE k38) (t39 :: TYPE k39) (t40 :: TYPE k40) (t41 :: TYPE k41) (t42 :: TYPE k42) (t43 :: TYPE k43) (t44 :: TYPE k44) (t45 :: TYPE k45) (t46 :: TYPE k46) (t47 :: TYPE k47) (t48 :: TYPE k48) (t49 :: TYPE k49) (t50 :: TYPE k50) (t51 :: TYPE k51) (t52 :: TYPE k52) (t53 :: TYPE k53) (t54 :: TYPE k54) (t55 :: TYPE k55) (t56 :: TYPE k56) (t57 :: TYPE k57) (t58 :: TYPE k58) (t59 :: TYPE k59) (t60 :: TYPE k60) (t61 :: TYPE k61) (t62 :: TYPE k62) :: TYPE 'SumRep '[k0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24, k25, k26, k27, k28, k29, k30, k31, k32, k33, k34, k35, k36, k37, k38, k39, k40, k41, k42, k43, k44, k45, k46, k47, k48, k49, k50, k51, k52, k53, k54, k55, k56, k57, k58, k59, k60, k61, k62]


-- | The tuple data types
--   
--   Users should not import this module. It is GHC internal only.
module GHC.Tuple

-- | A tuple of zero elements, a synonym for <a>()</a>.
type Tuple0 = ()

-- | A tuple of one element, a synonym for <a>Solo</a>.
type Tuple1 = Solo

-- | The unit datatype <tt>Unit</tt> has one non-undefined member, the
--   nullary constructor <tt>()</tt>.
data ()
() :: ()

-- | <tt>Solo</tt> is the canonical lifted 1-tuple, just like <a>(,)</a> is
--   the canonical lifted 2-tuple (pair) and <a>(,,)</a> is the canonical
--   lifted 3-tuple (triple).
--   
--   The most important feature of <tt>Solo</tt> is that it is possible to
--   force its "outside" (usually by pattern matching) without forcing its
--   "inside", because it is defined as a datatype rather than a newtype.
--   One situation where this can be useful is when writing a function to
--   extract a value from a data structure. Suppose you write an
--   implementation of arrays and offer only this function to index into
--   them:
--   
--   <pre>
--   index :: Array a -&gt; Int -&gt; a
--   </pre>
--   
--   Now imagine that someone wants to extract a value from an array and
--   store it in a lazy-valued finite map/dictionary:
--   
--   <pre>
--   insert "hello" (arr <tt>index</tt> 12) m
--   </pre>
--   
--   This can actually lead to a space leak. The value is not actually
--   extracted from the array until that value (now buried in a map) is
--   forced. That means the entire array may be kept live by just that
--   value! Often, the solution is to use a strict map, or to force the
--   value before storing it, but for some purposes that's undesirable.
--   
--   One common solution is to include an indexing function that can
--   produce its result in an arbitrary <tt>Applicative</tt> context:
--   
--   <pre>
--   indexA :: Applicative f =&gt; Array a -&gt; Int -&gt; f a
--   </pre>
--   
--   When using <tt>indexA</tt> in a <i>pure</i> context, <tt>Solo</tt>
--   serves as a handy <tt>Applicative</tt> functor to hold the result. You
--   could write a non-leaky version of the above example thus:
--   
--   <pre>
--   case arr <tt>indexA</tt> 12 of
--     Solo a -&gt; insert "hello" a m
--   </pre>
--   
--   While such simple extraction functions are the most common uses for
--   unary tuples, they can also be useful for fine-grained control of
--   strict-spined data structure traversals, and for unifying the
--   implementations of lazy and strict mapping functions.
data Solo a
MkSolo :: a -> Solo a

-- | <i>Deprecated: The Solo constructor has been renamed to MkSolo to
--   avoid punning.</i>
pattern Solo :: a -> Solo a

-- | Extract the value from a <a>Solo</a>. Very often, values should be
--   extracted directly using pattern matching, to control just what gets
--   evaluated when. <tt>getSolo</tt> is for convenience in situations
--   where that is not the case:
--   
--   When the result is passed to a <i>strict</i> function, it makes no
--   difference whether the pattern matching is done on the "outside" or on
--   the "inside":
--   
--   <pre>
--   Data.Set.insert (getSolo sol) set === case sol of Solo v -&gt; Data.Set.insert v set
--   </pre>
--   
--   A traversal may be performed in <a>Solo</a> in order to control
--   evaluation internally, while using <tt>getSolo</tt> to extract the
--   final result. A strict mapping function, for example, could be defined
--   
--   <pre>
--   map' :: Traversable t =&gt; (a -&gt; b) -&gt; t a -&gt; t b
--   map' f = getSolo . traverse ((Solo $!) . f)
--   </pre>
getSolo :: Solo a -> a

-- | A tuple of two elements.
data (,) a b
(,) :: a -> b -> (,) a b

-- | A tuple of three elements.
data (,,) a b c
(,,) :: a -> b -> c -> (,,) a b c

-- | A tuple of four elements.
data (,,,) a b c d
(,,,) :: a -> b -> c -> d -> (,,,) a b c d

-- | A tuple of five elements.
data (,,,,) a b c d e
(,,,,) :: a -> b -> c -> d -> e -> (,,,,) a b c d e

-- | A tuple of six elements.
data (,,,,,) a b c d e f
(,,,,,) :: a -> b -> c -> d -> e -> f -> (,,,,,) a b c d e f

-- | A tuple of seven elements.
data (,,,,,,) a b c d e f g
(,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> (,,,,,,) a b c d e f g

-- | A tuple of eight elements.
data (,,,,,,,) a b c d e f g h
(,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> (,,,,,,,) a b c d e f g h

-- | A tuple of nine elements.
data (,,,,,,,,) a b c d e f g h i
(,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> (,,,,,,,,) a b c d e f g h i

-- | A tuple of ten elements.
data (,,,,,,,,,) a b c d e f g h i j
(,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> (,,,,,,,,,) a b c d e f g h i j

-- | A tuple of eleven elements.
data (,,,,,,,,,,) a b c d e f g h i j k
(,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> (,,,,,,,,,,) a b c d e f g h i j k

-- | A tuple of twelve elements.
data (,,,,,,,,,,,) a b c d e f g h i j k l
(,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> (,,,,,,,,,,,) a b c d e f g h i j k l

-- | A tuple of 13 elements.
data (,,,,,,,,,,,,) a b c d e f g h i j k l m
(,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> (,,,,,,,,,,,,) a b c d e f g h i j k l m

-- | A tuple of 14 elements.
data (,,,,,,,,,,,,,) a b c d e f g h i j k l m n
(,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> (,,,,,,,,,,,,,) a b c d e f g h i j k l m n

-- | A tuple of 15 elements.
data (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o
(,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o

-- | A tuple of 16 elements.
data (,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p
(,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> (,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p

-- | A tuple of 17 elements.
data (,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q
(,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> (,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q

-- | A tuple of 18 elements.
data (,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r
(,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> (,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r

-- | A tuple of 19 elements.
data (,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s
(,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> (,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s

-- | A tuple of 20 elements.
data (,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t
(,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> (,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t

-- | A tuple of 21 elements.
data (,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u
(,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> (,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u

-- | A tuple of 22 elements.
data (,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v
(,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> (,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v

-- | A tuple of 23 elements.
data (,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w
(,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> (,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w

-- | A tuple of 24 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x
(,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> (,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x

-- | A tuple of 25 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y
(,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> (,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y

-- | A tuple of 26 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z
(,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> (,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z

-- | A tuple of 27 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26
(,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26

-- | A tuple of 28 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27
(,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27

-- | A tuple of 29 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28

-- | A tuple of 30 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29

-- | A tuple of 31 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30

-- | A tuple of 32 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31

-- | A tuple of 33 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32

-- | A tuple of 34 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33

-- | A tuple of 35 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34

-- | A tuple of 36 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35

-- | A tuple of 37 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36

-- | A tuple of 38 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37

-- | A tuple of 39 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38

-- | A tuple of 40 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39

-- | A tuple of 41 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40

-- | A tuple of 42 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41

-- | A tuple of 43 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42

-- | A tuple of 44 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43

-- | A tuple of 45 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44

-- | A tuple of 46 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45

-- | A tuple of 47 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46

-- | A tuple of 48 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47

-- | A tuple of 49 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48

-- | A tuple of 50 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49

-- | A tuple of 51 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50

-- | A tuple of 52 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51

-- | A tuple of 53 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52

-- | A tuple of 54 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53

-- | A tuple of 55 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54

-- | A tuple of 56 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55

-- | A tuple of 57 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56

-- | A tuple of 58 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57

-- | A tuple of 59 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58

-- | A tuple of 60 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59

-- | A tuple of 61 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60

-- | A tuple of 62 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61

-- | A tuple of 63 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62

-- | A tuple of 64 elements.
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62 t63
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t26 -> t27 -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62 t63


-- | Users should not import this module. It is GHC internal only. Use
--   <a>GHC.Exts</a> instead.
module GHC.PrimopWrappers
gtChar# :: Char# -> Char# -> Int#
geChar# :: Char# -> Char# -> Int#
eqChar# :: Char# -> Char# -> Int#
neChar# :: Char# -> Char# -> Int#
ltChar# :: Char# -> Char# -> Int#
leChar# :: Char# -> Char# -> Int#
ord# :: Char# -> Int#
int8ToInt# :: Int8# -> Int#
intToInt8# :: Int# -> Int8#
negateInt8# :: Int8# -> Int8#
plusInt8# :: Int8# -> Int8# -> Int8#
subInt8# :: Int8# -> Int8# -> Int8#
timesInt8# :: Int8# -> Int8# -> Int8#
quotInt8# :: Int8# -> Int8# -> Int8#
remInt8# :: Int8# -> Int8# -> Int8#
quotRemInt8# :: Int8# -> Int8# -> (# Int8#, Int8# #)
uncheckedShiftLInt8# :: Int8# -> Int# -> Int8#
uncheckedShiftRAInt8# :: Int8# -> Int# -> Int8#
uncheckedShiftRLInt8# :: Int8# -> Int# -> Int8#
int8ToWord8# :: Int8# -> Word8#
eqInt8# :: Int8# -> Int8# -> Int#
geInt8# :: Int8# -> Int8# -> Int#
gtInt8# :: Int8# -> Int8# -> Int#
leInt8# :: Int8# -> Int8# -> Int#
ltInt8# :: Int8# -> Int8# -> Int#
neInt8# :: Int8# -> Int8# -> Int#
word8ToWord# :: Word8# -> Word#
wordToWord8# :: Word# -> Word8#
plusWord8# :: Word8# -> Word8# -> Word8#
subWord8# :: Word8# -> Word8# -> Word8#
timesWord8# :: Word8# -> Word8# -> Word8#
quotWord8# :: Word8# -> Word8# -> Word8#
remWord8# :: Word8# -> Word8# -> Word8#
quotRemWord8# :: Word8# -> Word8# -> (# Word8#, Word8# #)
andWord8# :: Word8# -> Word8# -> Word8#
orWord8# :: Word8# -> Word8# -> Word8#
xorWord8# :: Word8# -> Word8# -> Word8#
notWord8# :: Word8# -> Word8#
uncheckedShiftLWord8# :: Word8# -> Int# -> Word8#
uncheckedShiftRLWord8# :: Word8# -> Int# -> Word8#
word8ToInt8# :: Word8# -> Int8#
eqWord8# :: Word8# -> Word8# -> Int#
geWord8# :: Word8# -> Word8# -> Int#
gtWord8# :: Word8# -> Word8# -> Int#
leWord8# :: Word8# -> Word8# -> Int#
ltWord8# :: Word8# -> Word8# -> Int#
neWord8# :: Word8# -> Word8# -> Int#
int16ToInt# :: Int16# -> Int#
intToInt16# :: Int# -> Int16#
negateInt16# :: Int16# -> Int16#
plusInt16# :: Int16# -> Int16# -> Int16#
subInt16# :: Int16# -> Int16# -> Int16#
timesInt16# :: Int16# -> Int16# -> Int16#
quotInt16# :: Int16# -> Int16# -> Int16#
remInt16# :: Int16# -> Int16# -> Int16#
quotRemInt16# :: Int16# -> Int16# -> (# Int16#, Int16# #)
uncheckedShiftLInt16# :: Int16# -> Int# -> Int16#
uncheckedShiftRAInt16# :: Int16# -> Int# -> Int16#
uncheckedShiftRLInt16# :: Int16# -> Int# -> Int16#
int16ToWord16# :: Int16# -> Word16#
eqInt16# :: Int16# -> Int16# -> Int#
geInt16# :: Int16# -> Int16# -> Int#
gtInt16# :: Int16# -> Int16# -> Int#
leInt16# :: Int16# -> Int16# -> Int#
ltInt16# :: Int16# -> Int16# -> Int#
neInt16# :: Int16# -> Int16# -> Int#
word16ToWord# :: Word16# -> Word#
wordToWord16# :: Word# -> Word16#
plusWord16# :: Word16# -> Word16# -> Word16#
subWord16# :: Word16# -> Word16# -> Word16#
timesWord16# :: Word16# -> Word16# -> Word16#
quotWord16# :: Word16# -> Word16# -> Word16#
remWord16# :: Word16# -> Word16# -> Word16#
quotRemWord16# :: Word16# -> Word16# -> (# Word16#, Word16# #)
andWord16# :: Word16# -> Word16# -> Word16#
orWord16# :: Word16# -> Word16# -> Word16#
xorWord16# :: Word16# -> Word16# -> Word16#
notWord16# :: Word16# -> Word16#
uncheckedShiftLWord16# :: Word16# -> Int# -> Word16#
uncheckedShiftRLWord16# :: Word16# -> Int# -> Word16#
word16ToInt16# :: Word16# -> Int16#
eqWord16# :: Word16# -> Word16# -> Int#
geWord16# :: Word16# -> Word16# -> Int#
gtWord16# :: Word16# -> Word16# -> Int#
leWord16# :: Word16# -> Word16# -> Int#
ltWord16# :: Word16# -> Word16# -> Int#
neWord16# :: Word16# -> Word16# -> Int#
int32ToInt# :: Int32# -> Int#
intToInt32# :: Int# -> Int32#
negateInt32# :: Int32# -> Int32#
plusInt32# :: Int32# -> Int32# -> Int32#
subInt32# :: Int32# -> Int32# -> Int32#
timesInt32# :: Int32# -> Int32# -> Int32#
quotInt32# :: Int32# -> Int32# -> Int32#
remInt32# :: Int32# -> Int32# -> Int32#
quotRemInt32# :: Int32# -> Int32# -> (# Int32#, Int32# #)
uncheckedShiftLInt32# :: Int32# -> Int# -> Int32#
uncheckedShiftRAInt32# :: Int32# -> Int# -> Int32#
uncheckedShiftRLInt32# :: Int32# -> Int# -> Int32#
int32ToWord32# :: Int32# -> Word32#
eqInt32# :: Int32# -> Int32# -> Int#
geInt32# :: Int32# -> Int32# -> Int#
gtInt32# :: Int32# -> Int32# -> Int#
leInt32# :: Int32# -> Int32# -> Int#
ltInt32# :: Int32# -> Int32# -> Int#
neInt32# :: Int32# -> Int32# -> Int#
word32ToWord# :: Word32# -> Word#
wordToWord32# :: Word# -> Word32#
plusWord32# :: Word32# -> Word32# -> Word32#
subWord32# :: Word32# -> Word32# -> Word32#
timesWord32# :: Word32# -> Word32# -> Word32#
quotWord32# :: Word32# -> Word32# -> Word32#
remWord32# :: Word32# -> Word32# -> Word32#
quotRemWord32# :: Word32# -> Word32# -> (# Word32#, Word32# #)
andWord32# :: Word32# -> Word32# -> Word32#
orWord32# :: Word32# -> Word32# -> Word32#
xorWord32# :: Word32# -> Word32# -> Word32#
notWord32# :: Word32# -> Word32#
uncheckedShiftLWord32# :: Word32# -> Int# -> Word32#
uncheckedShiftRLWord32# :: Word32# -> Int# -> Word32#
word32ToInt32# :: Word32# -> Int32#
eqWord32# :: Word32# -> Word32# -> Int#
geWord32# :: Word32# -> Word32# -> Int#
gtWord32# :: Word32# -> Word32# -> Int#
leWord32# :: Word32# -> Word32# -> Int#
ltWord32# :: Word32# -> Word32# -> Int#
neWord32# :: Word32# -> Word32# -> Int#
int64ToInt# :: Int64# -> Int#
intToInt64# :: Int# -> Int64#
negateInt64# :: Int64# -> Int64#
plusInt64# :: Int64# -> Int64# -> Int64#
subInt64# :: Int64# -> Int64# -> Int64#
timesInt64# :: Int64# -> Int64# -> Int64#
quotInt64# :: Int64# -> Int64# -> Int64#
remInt64# :: Int64# -> Int64# -> Int64#
uncheckedIShiftL64# :: Int64# -> Int# -> Int64#
uncheckedIShiftRA64# :: Int64# -> Int# -> Int64#
uncheckedIShiftRL64# :: Int64# -> Int# -> Int64#
int64ToWord64# :: Int64# -> Word64#
eqInt64# :: Int64# -> Int64# -> Int#
geInt64# :: Int64# -> Int64# -> Int#
gtInt64# :: Int64# -> Int64# -> Int#
leInt64# :: Int64# -> Int64# -> Int#
ltInt64# :: Int64# -> Int64# -> Int#
neInt64# :: Int64# -> Int64# -> Int#
word64ToWord# :: Word64# -> Word#
wordToWord64# :: Word# -> Word64#
plusWord64# :: Word64# -> Word64# -> Word64#
subWord64# :: Word64# -> Word64# -> Word64#
timesWord64# :: Word64# -> Word64# -> Word64#
quotWord64# :: Word64# -> Word64# -> Word64#
remWord64# :: Word64# -> Word64# -> Word64#
and64# :: Word64# -> Word64# -> Word64#
or64# :: Word64# -> Word64# -> Word64#
xor64# :: Word64# -> Word64# -> Word64#
not64# :: Word64# -> Word64#
uncheckedShiftL64# :: Word64# -> Int# -> Word64#
uncheckedShiftRL64# :: Word64# -> Int# -> Word64#
word64ToInt64# :: Word64# -> Int64#
eqWord64# :: Word64# -> Word64# -> Int#
geWord64# :: Word64# -> Word64# -> Int#
gtWord64# :: Word64# -> Word64# -> Int#
leWord64# :: Word64# -> Word64# -> Int#
ltWord64# :: Word64# -> Word64# -> Int#
neWord64# :: Word64# -> Word64# -> Int#
(+#) :: Int# -> Int# -> Int#
(-#) :: Int# -> Int# -> Int#
(*#) :: Int# -> Int# -> Int#
timesInt2# :: Int# -> Int# -> (# Int#, Int#, Int# #)
mulIntMayOflo# :: Int# -> Int# -> Int#
quotInt# :: Int# -> Int# -> Int#
remInt# :: Int# -> Int# -> Int#
quotRemInt# :: Int# -> Int# -> (# Int#, Int# #)
andI# :: Int# -> Int# -> Int#
orI# :: Int# -> Int# -> Int#
xorI# :: Int# -> Int# -> Int#
notI# :: Int# -> Int#
negateInt# :: Int# -> Int#
addIntC# :: Int# -> Int# -> (# Int#, Int# #)
subIntC# :: Int# -> Int# -> (# Int#, Int# #)
(>#) :: Int# -> Int# -> Int#
(>=#) :: Int# -> Int# -> Int#
(==#) :: Int# -> Int# -> Int#
(/=#) :: Int# -> Int# -> Int#
(<#) :: Int# -> Int# -> Int#
(<=#) :: Int# -> Int# -> Int#
chr# :: Int# -> Char#
int2Word# :: Int# -> Word#
int2Float# :: Int# -> Float#
int2Double# :: Int# -> Double#
word2Float# :: Word# -> Float#
word2Double# :: Word# -> Double#
uncheckedIShiftL# :: Int# -> Int# -> Int#
uncheckedIShiftRA# :: Int# -> Int# -> Int#
uncheckedIShiftRL# :: Int# -> Int# -> Int#
plusWord# :: Word# -> Word# -> Word#
addWordC# :: Word# -> Word# -> (# Word#, Int# #)
subWordC# :: Word# -> Word# -> (# Word#, Int# #)
plusWord2# :: Word# -> Word# -> (# Word#, Word# #)
minusWord# :: Word# -> Word# -> Word#
timesWord# :: Word# -> Word# -> Word#
timesWord2# :: Word# -> Word# -> (# Word#, Word# #)
quotWord# :: Word# -> Word# -> Word#
remWord# :: Word# -> Word# -> Word#
quotRemWord# :: Word# -> Word# -> (# Word#, Word# #)
quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#, Word# #)
and# :: Word# -> Word# -> Word#
or# :: Word# -> Word# -> Word#
xor# :: Word# -> Word# -> Word#
not# :: Word# -> Word#
uncheckedShiftL# :: Word# -> Int# -> Word#
uncheckedShiftRL# :: Word# -> Int# -> Word#
word2Int# :: Word# -> Int#
gtWord# :: Word# -> Word# -> Int#
geWord# :: Word# -> Word# -> Int#
eqWord# :: Word# -> Word# -> Int#
neWord# :: Word# -> Word# -> Int#
ltWord# :: Word# -> Word# -> Int#
leWord# :: Word# -> Word# -> Int#
popCnt8# :: Word# -> Word#
popCnt16# :: Word# -> Word#
popCnt32# :: Word# -> Word#
popCnt64# :: Word64# -> Word#
popCnt# :: Word# -> Word#
pdep8# :: Word# -> Word# -> Word#
pdep16# :: Word# -> Word# -> Word#
pdep32# :: Word# -> Word# -> Word#
pdep64# :: Word64# -> Word64# -> Word64#
pdep# :: Word# -> Word# -> Word#
pext8# :: Word# -> Word# -> Word#
pext16# :: Word# -> Word# -> Word#
pext32# :: Word# -> Word# -> Word#
pext64# :: Word64# -> Word64# -> Word64#
pext# :: Word# -> Word# -> Word#
clz8# :: Word# -> Word#
clz16# :: Word# -> Word#
clz32# :: Word# -> Word#
clz64# :: Word64# -> Word#
clz# :: Word# -> Word#
ctz8# :: Word# -> Word#
ctz16# :: Word# -> Word#
ctz32# :: Word# -> Word#
ctz64# :: Word64# -> Word#
ctz# :: Word# -> Word#
byteSwap16# :: Word# -> Word#
byteSwap32# :: Word# -> Word#
byteSwap64# :: Word64# -> Word64#
byteSwap# :: Word# -> Word#
bitReverse8# :: Word# -> Word#
bitReverse16# :: Word# -> Word#
bitReverse32# :: Word# -> Word#
bitReverse64# :: Word64# -> Word64#
bitReverse# :: Word# -> Word#
narrow8Int# :: Int# -> Int#
narrow16Int# :: Int# -> Int#
narrow32Int# :: Int# -> Int#
narrow8Word# :: Word# -> Word#
narrow16Word# :: Word# -> Word#
narrow32Word# :: Word# -> Word#
(>##) :: Double# -> Double# -> Int#
(>=##) :: Double# -> Double# -> Int#
(==##) :: Double# -> Double# -> Int#
(/=##) :: Double# -> Double# -> Int#
(<##) :: Double# -> Double# -> Int#
(<=##) :: Double# -> Double# -> Int#
minDouble# :: Double# -> Double# -> Double#
maxDouble# :: Double# -> Double# -> Double#
(+##) :: Double# -> Double# -> Double#
(-##) :: Double# -> Double# -> Double#
(*##) :: Double# -> Double# -> Double#
(/##) :: Double# -> Double# -> Double#
negateDouble# :: Double# -> Double#
fabsDouble# :: Double# -> Double#
double2Int# :: Double# -> Int#
double2Float# :: Double# -> Float#
expDouble# :: Double# -> Double#
expm1Double# :: Double# -> Double#
logDouble# :: Double# -> Double#
log1pDouble# :: Double# -> Double#
sqrtDouble# :: Double# -> Double#
sinDouble# :: Double# -> Double#
cosDouble# :: Double# -> Double#
tanDouble# :: Double# -> Double#
asinDouble# :: Double# -> Double#
acosDouble# :: Double# -> Double#
atanDouble# :: Double# -> Double#
sinhDouble# :: Double# -> Double#
coshDouble# :: Double# -> Double#
tanhDouble# :: Double# -> Double#
asinhDouble# :: Double# -> Double#
acoshDouble# :: Double# -> Double#
atanhDouble# :: Double# -> Double#
(**##) :: Double# -> Double# -> Double#
decodeDouble_2Int# :: Double# -> (# Int#, Word#, Word#, Int# #)
decodeDouble_Int64# :: Double# -> (# Int64#, Int# #)
castDoubleToWord64# :: Double# -> Word64#
castWord64ToDouble# :: Word64# -> Double#
gtFloat# :: Float# -> Float# -> Int#
geFloat# :: Float# -> Float# -> Int#
eqFloat# :: Float# -> Float# -> Int#
neFloat# :: Float# -> Float# -> Int#
ltFloat# :: Float# -> Float# -> Int#
leFloat# :: Float# -> Float# -> Int#
minFloat# :: Float# -> Float# -> Float#
maxFloat# :: Float# -> Float# -> Float#
plusFloat# :: Float# -> Float# -> Float#
minusFloat# :: Float# -> Float# -> Float#
timesFloat# :: Float# -> Float# -> Float#
divideFloat# :: Float# -> Float# -> Float#
negateFloat# :: Float# -> Float#
fabsFloat# :: Float# -> Float#
float2Int# :: Float# -> Int#
expFloat# :: Float# -> Float#
expm1Float# :: Float# -> Float#
logFloat# :: Float# -> Float#
log1pFloat# :: Float# -> Float#
sqrtFloat# :: Float# -> Float#
sinFloat# :: Float# -> Float#
cosFloat# :: Float# -> Float#
tanFloat# :: Float# -> Float#
asinFloat# :: Float# -> Float#
acosFloat# :: Float# -> Float#
atanFloat# :: Float# -> Float#
sinhFloat# :: Float# -> Float#
coshFloat# :: Float# -> Float#
tanhFloat# :: Float# -> Float#
asinhFloat# :: Float# -> Float#
acoshFloat# :: Float# -> Float#
atanhFloat# :: Float# -> Float#
powerFloat# :: Float# -> Float# -> Float#
float2Double# :: Float# -> Double#
decodeFloat_Int# :: Float# -> (# Int#, Int# #)
castFloatToWord32# :: Float# -> Word32#
castWord32ToFloat# :: Word32# -> Float#
fmaddFloat# :: Float# -> Float# -> Float# -> Float#
fmsubFloat# :: Float# -> Float# -> Float# -> Float#
fnmaddFloat# :: Float# -> Float# -> Float# -> Float#
fnmsubFloat# :: Float# -> Float# -> Float# -> Float#
fmaddDouble# :: Double# -> Double# -> Double# -> Double#
fmsubDouble# :: Double# -> Double# -> Double# -> Double#
fnmaddDouble# :: Double# -> Double# -> Double# -> Double#
fnmsubDouble# :: Double# -> Double# -> Double# -> Double#
newArray# :: Int# -> a_levpoly -> State# s -> (# State# s, MutableArray# s a_levpoly #)
readArray# :: MutableArray# s a_levpoly -> Int# -> State# s -> (# State# s, a_levpoly #)
writeArray# :: MutableArray# s a_levpoly -> Int# -> a_levpoly -> State# s -> State# s
sizeofArray# :: Array# a_levpoly -> Int#
sizeofMutableArray# :: MutableArray# s a_levpoly -> Int#
indexArray# :: Array# a_levpoly -> Int# -> (# a_levpoly #)
unsafeFreezeArray# :: MutableArray# s a_levpoly -> State# s -> (# State# s, Array# a_levpoly #)
unsafeThawArray# :: Array# a_levpoly -> State# s -> (# State# s, MutableArray# s a_levpoly #)
copyArray# :: Array# a_levpoly -> Int# -> MutableArray# s a_levpoly -> Int# -> Int# -> State# s -> State# s
copyMutableArray# :: MutableArray# s a_levpoly -> Int# -> MutableArray# s a_levpoly -> Int# -> Int# -> State# s -> State# s
cloneArray# :: Array# a_levpoly -> Int# -> Int# -> Array# a_levpoly
cloneMutableArray# :: MutableArray# s a_levpoly -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s a_levpoly #)
freezeArray# :: MutableArray# s a_levpoly -> Int# -> Int# -> State# s -> (# State# s, Array# a_levpoly #)
thawArray# :: Array# a_levpoly -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s a_levpoly #)
casArray# :: MutableArray# s a_levpoly -> Int# -> a_levpoly -> a_levpoly -> State# s -> (# State# s, Int#, a_levpoly #)
newSmallArray# :: Int# -> a_levpoly -> State# s -> (# State# s, SmallMutableArray# s a_levpoly #)
shrinkSmallMutableArray# :: SmallMutableArray# s a_levpoly -> Int# -> State# s -> State# s
readSmallArray# :: SmallMutableArray# s a_levpoly -> Int# -> State# s -> (# State# s, a_levpoly #)
writeSmallArray# :: SmallMutableArray# s a_levpoly -> Int# -> a_levpoly -> State# s -> State# s
sizeofSmallArray# :: SmallArray# a_levpoly -> Int#
sizeofSmallMutableArray# :: SmallMutableArray# s a_levpoly -> Int#
getSizeofSmallMutableArray# :: SmallMutableArray# s a_levpoly -> State# s -> (# State# s, Int# #)
indexSmallArray# :: SmallArray# a_levpoly -> Int# -> (# a_levpoly #)
unsafeFreezeSmallArray# :: SmallMutableArray# s a_levpoly -> State# s -> (# State# s, SmallArray# a_levpoly #)
unsafeThawSmallArray# :: SmallArray# a_levpoly -> State# s -> (# State# s, SmallMutableArray# s a_levpoly #)
copySmallArray# :: SmallArray# a_levpoly -> Int# -> SmallMutableArray# s a_levpoly -> Int# -> Int# -> State# s -> State# s
copySmallMutableArray# :: SmallMutableArray# s a_levpoly -> Int# -> SmallMutableArray# s a_levpoly -> Int# -> Int# -> State# s -> State# s
cloneSmallArray# :: SmallArray# a_levpoly -> Int# -> Int# -> SmallArray# a_levpoly
cloneSmallMutableArray# :: SmallMutableArray# s a_levpoly -> Int# -> Int# -> State# s -> (# State# s, SmallMutableArray# s a_levpoly #)
freezeSmallArray# :: SmallMutableArray# s a_levpoly -> Int# -> Int# -> State# s -> (# State# s, SmallArray# a_levpoly #)
thawSmallArray# :: SmallArray# a_levpoly -> Int# -> Int# -> State# s -> (# State# s, SmallMutableArray# s a_levpoly #)
casSmallArray# :: SmallMutableArray# s a_levpoly -> Int# -> a_levpoly -> a_levpoly -> State# s -> (# State# s, Int#, a_levpoly #)
newByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)
newPinnedByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)
newAlignedPinnedByteArray# :: Int# -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
isMutableByteArrayPinned# :: MutableByteArray# s -> Int#
isByteArrayPinned# :: ByteArray# -> Int#
isByteArrayWeaklyPinned# :: ByteArray# -> Int#
isMutableByteArrayWeaklyPinned# :: MutableByteArray# s -> Int#
byteArrayContents# :: ByteArray# -> Addr#
mutableByteArrayContents# :: MutableByteArray# s -> Addr#
shrinkMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> State# s
resizeMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
unsafeFreezeByteArray# :: MutableByteArray# s -> State# s -> (# State# s, ByteArray# #)
unsafeThawByteArray# :: ByteArray# -> State# s -> (# State# s, MutableByteArray# s #)
sizeofByteArray# :: ByteArray# -> Int#
sizeofMutableByteArray# :: MutableByteArray# s -> Int#
getSizeofMutableByteArray# :: MutableByteArray# s -> State# s -> (# State# s, Int# #)
indexCharArray# :: ByteArray# -> Int# -> Char#
indexWideCharArray# :: ByteArray# -> Int# -> Char#
indexIntArray# :: ByteArray# -> Int# -> Int#
indexWordArray# :: ByteArray# -> Int# -> Word#
indexAddrArray# :: ByteArray# -> Int# -> Addr#
indexFloatArray# :: ByteArray# -> Int# -> Float#
indexDoubleArray# :: ByteArray# -> Int# -> Double#
indexStablePtrArray# :: ByteArray# -> Int# -> StablePtr# a
indexInt8Array# :: ByteArray# -> Int# -> Int8#
indexWord8Array# :: ByteArray# -> Int# -> Word8#
indexInt16Array# :: ByteArray# -> Int# -> Int16#
indexWord16Array# :: ByteArray# -> Int# -> Word16#
indexInt32Array# :: ByteArray# -> Int# -> Int32#
indexWord32Array# :: ByteArray# -> Int# -> Word32#
indexInt64Array# :: ByteArray# -> Int# -> Int64#
indexWord64Array# :: ByteArray# -> Int# -> Word64#
indexWord8ArrayAsChar# :: ByteArray# -> Int# -> Char#
indexWord8ArrayAsWideChar# :: ByteArray# -> Int# -> Char#
indexWord8ArrayAsInt# :: ByteArray# -> Int# -> Int#
indexWord8ArrayAsWord# :: ByteArray# -> Int# -> Word#
indexWord8ArrayAsAddr# :: ByteArray# -> Int# -> Addr#
indexWord8ArrayAsFloat# :: ByteArray# -> Int# -> Float#
indexWord8ArrayAsDouble# :: ByteArray# -> Int# -> Double#
indexWord8ArrayAsStablePtr# :: ByteArray# -> Int# -> StablePtr# a
indexWord8ArrayAsInt16# :: ByteArray# -> Int# -> Int16#
indexWord8ArrayAsWord16# :: ByteArray# -> Int# -> Word16#
indexWord8ArrayAsInt32# :: ByteArray# -> Int# -> Int32#
indexWord8ArrayAsWord32# :: ByteArray# -> Int# -> Word32#
indexWord8ArrayAsInt64# :: ByteArray# -> Int# -> Int64#
indexWord8ArrayAsWord64# :: ByteArray# -> Int# -> Word64#
readCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readWideCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWordArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readAddrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Addr# #)
readFloatArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Float# #)
readDoubleArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Double# #)
readStablePtrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, StablePtr# a #)
readInt8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8# #)
readWord8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8# #)
readInt16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16# #)
readWord16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16# #)
readInt32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32# #)
readWord32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32# #)
readInt64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64# #)
readWord64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64# #)
readWord8ArrayAsChar# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readWord8ArrayAsWideChar# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readWord8ArrayAsInt# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWord8ArrayAsWord# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord8ArrayAsAddr# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Addr# #)
readWord8ArrayAsFloat# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Float# #)
readWord8ArrayAsDouble# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Double# #)
readWord8ArrayAsStablePtr# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, StablePtr# a #)
readWord8ArrayAsInt16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16# #)
readWord8ArrayAsWord16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16# #)
readWord8ArrayAsInt32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32# #)
readWord8ArrayAsWord32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32# #)
readWord8ArrayAsInt64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64# #)
readWord8ArrayAsWord64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64# #)
writeCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeWideCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWordArray# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeAddrArray# :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s
writeFloatArray# :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s
writeDoubleArray# :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s
writeStablePtrArray# :: MutableByteArray# s -> Int# -> StablePtr# a -> State# s -> State# s
writeInt8Array# :: MutableByteArray# s -> Int# -> Int8# -> State# s -> State# s
writeWord8Array# :: MutableByteArray# s -> Int# -> Word8# -> State# s -> State# s
writeInt16Array# :: MutableByteArray# s -> Int# -> Int16# -> State# s -> State# s
writeWord16Array# :: MutableByteArray# s -> Int# -> Word16# -> State# s -> State# s
writeInt32Array# :: MutableByteArray# s -> Int# -> Int32# -> State# s -> State# s
writeWord32Array# :: MutableByteArray# s -> Int# -> Word32# -> State# s -> State# s
writeInt64Array# :: MutableByteArray# s -> Int# -> Int64# -> State# s -> State# s
writeWord64Array# :: MutableByteArray# s -> Int# -> Word64# -> State# s -> State# s
writeWord8ArrayAsChar# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeWord8ArrayAsWideChar# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeWord8ArrayAsInt# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWord8ArrayAsWord# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord8ArrayAsAddr# :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s
writeWord8ArrayAsFloat# :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s
writeWord8ArrayAsDouble# :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s
writeWord8ArrayAsStablePtr# :: MutableByteArray# s -> Int# -> StablePtr# a -> State# s -> State# s
writeWord8ArrayAsInt16# :: MutableByteArray# s -> Int# -> Int16# -> State# s -> State# s
writeWord8ArrayAsWord16# :: MutableByteArray# s -> Int# -> Word16# -> State# s -> State# s
writeWord8ArrayAsInt32# :: MutableByteArray# s -> Int# -> Int32# -> State# s -> State# s
writeWord8ArrayAsWord32# :: MutableByteArray# s -> Int# -> Word32# -> State# s -> State# s
writeWord8ArrayAsInt64# :: MutableByteArray# s -> Int# -> Int64# -> State# s -> State# s
writeWord8ArrayAsWord64# :: MutableByteArray# s -> Int# -> Word64# -> State# s -> State# s
compareByteArrays# :: ByteArray# -> Int# -> ByteArray# -> Int# -> Int# -> Int#
copyByteArray# :: ByteArray# -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
copyMutableByteArray# :: MutableByteArray# s -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
copyMutableByteArrayNonOverlapping# :: MutableByteArray# s -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
copyByteArrayToAddr# :: ByteArray# -> Int# -> Addr# -> Int# -> State# s -> State# s
copyMutableByteArrayToAddr# :: MutableByteArray# s -> Int# -> Addr# -> Int# -> State# s -> State# s
copyAddrToByteArray# :: Addr# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
copyAddrToAddr# :: Addr# -> Addr# -> Int# -> State# RealWorld -> State# RealWorld
copyAddrToAddrNonOverlapping# :: Addr# -> Addr# -> Int# -> State# RealWorld -> State# RealWorld
setByteArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> State# s
setAddrRange# :: Addr# -> Int# -> Int# -> State# RealWorld -> State# RealWorld
atomicReadIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
atomicWriteIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
casIntArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> (# State# s, Int# #)
casInt8Array# :: MutableByteArray# s -> Int# -> Int8# -> Int8# -> State# s -> (# State# s, Int8# #)
casInt16Array# :: MutableByteArray# s -> Int# -> Int16# -> Int16# -> State# s -> (# State# s, Int16# #)
casInt32Array# :: MutableByteArray# s -> Int# -> Int32# -> Int32# -> State# s -> (# State# s, Int32# #)
casInt64Array# :: MutableByteArray# s -> Int# -> Int64# -> Int64# -> State# s -> (# State# s, Int64# #)
fetchAddIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchSubIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchAndIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchNandIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchOrIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchXorIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
plusAddr# :: Addr# -> Int# -> Addr#
minusAddr# :: Addr# -> Addr# -> Int#
remAddr# :: Addr# -> Int# -> Int#
addr2Int# :: Addr# -> Int#
int2Addr# :: Int# -> Addr#
gtAddr# :: Addr# -> Addr# -> Int#
geAddr# :: Addr# -> Addr# -> Int#
eqAddr# :: Addr# -> Addr# -> Int#
neAddr# :: Addr# -> Addr# -> Int#
ltAddr# :: Addr# -> Addr# -> Int#
leAddr# :: Addr# -> Addr# -> Int#
indexCharOffAddr# :: Addr# -> Int# -> Char#
indexWideCharOffAddr# :: Addr# -> Int# -> Char#
indexIntOffAddr# :: Addr# -> Int# -> Int#
indexWordOffAddr# :: Addr# -> Int# -> Word#
indexAddrOffAddr# :: Addr# -> Int# -> Addr#
indexFloatOffAddr# :: Addr# -> Int# -> Float#
indexDoubleOffAddr# :: Addr# -> Int# -> Double#
indexStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a
indexInt8OffAddr# :: Addr# -> Int# -> Int8#
indexWord8OffAddr# :: Addr# -> Int# -> Word8#
indexInt16OffAddr# :: Addr# -> Int# -> Int16#
indexWord16OffAddr# :: Addr# -> Int# -> Word16#
indexInt32OffAddr# :: Addr# -> Int# -> Int32#
indexWord32OffAddr# :: Addr# -> Int# -> Word32#
indexInt64OffAddr# :: Addr# -> Int# -> Int64#
indexWord64OffAddr# :: Addr# -> Int# -> Word64#
indexWord8OffAddrAsChar# :: Addr# -> Int# -> Char#
indexWord8OffAddrAsWideChar# :: Addr# -> Int# -> Char#
indexWord8OffAddrAsInt# :: Addr# -> Int# -> Int#
indexWord8OffAddrAsWord# :: Addr# -> Int# -> Word#
indexWord8OffAddrAsAddr# :: Addr# -> Int# -> Addr#
indexWord8OffAddrAsFloat# :: Addr# -> Int# -> Float#
indexWord8OffAddrAsDouble# :: Addr# -> Int# -> Double#
indexWord8OffAddrAsStablePtr# :: Addr# -> Int# -> StablePtr# a
indexWord8OffAddrAsInt16# :: Addr# -> Int# -> Int16#
indexWord8OffAddrAsWord16# :: Addr# -> Int# -> Word16#
indexWord8OffAddrAsInt32# :: Addr# -> Int# -> Int32#
indexWord8OffAddrAsWord32# :: Addr# -> Int# -> Word32#
indexWord8OffAddrAsInt64# :: Addr# -> Int# -> Int64#
indexWord8OffAddrAsWord64# :: Addr# -> Int# -> Word64#
readCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)
readWideCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)
readIntOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readWordOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readAddrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Addr# #)
readFloatOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Float# #)
readDoubleOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Double# #)
readStablePtrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, StablePtr# a #)
readInt8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int8# #)
readWord8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word8# #)
readInt16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int16# #)
readWord16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word16# #)
readInt32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int32# #)
readWord32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word32# #)
readInt64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int64# #)
readWord64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word64# #)
readWord8OffAddrAsChar# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)
readWord8OffAddrAsWideChar# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)
readWord8OffAddrAsInt# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readWord8OffAddrAsWord# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord8OffAddrAsAddr# :: Addr# -> Int# -> State# s -> (# State# s, Addr# #)
readWord8OffAddrAsFloat# :: Addr# -> Int# -> State# s -> (# State# s, Float# #)
readWord8OffAddrAsDouble# :: Addr# -> Int# -> State# s -> (# State# s, Double# #)
readWord8OffAddrAsStablePtr# :: Addr# -> Int# -> State# s -> (# State# s, StablePtr# a #)
readWord8OffAddrAsInt16# :: Addr# -> Int# -> State# s -> (# State# s, Int16# #)
readWord8OffAddrAsWord16# :: Addr# -> Int# -> State# s -> (# State# s, Word16# #)
readWord8OffAddrAsInt32# :: Addr# -> Int# -> State# s -> (# State# s, Int32# #)
readWord8OffAddrAsWord32# :: Addr# -> Int# -> State# s -> (# State# s, Word32# #)
readWord8OffAddrAsInt64# :: Addr# -> Int# -> State# s -> (# State# s, Int64# #)
readWord8OffAddrAsWord64# :: Addr# -> Int# -> State# s -> (# State# s, Word64# #)
writeCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeWideCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeIntOffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeWordOffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeAddrOffAddr# :: Addr# -> Int# -> Addr# -> State# s -> State# s
writeFloatOffAddr# :: Addr# -> Int# -> Float# -> State# s -> State# s
writeDoubleOffAddr# :: Addr# -> Int# -> Double# -> State# s -> State# s
writeStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a -> State# s -> State# s
writeInt8OffAddr# :: Addr# -> Int# -> Int8# -> State# s -> State# s
writeWord8OffAddr# :: Addr# -> Int# -> Word8# -> State# s -> State# s
writeInt16OffAddr# :: Addr# -> Int# -> Int16# -> State# s -> State# s
writeWord16OffAddr# :: Addr# -> Int# -> Word16# -> State# s -> State# s
writeInt32OffAddr# :: Addr# -> Int# -> Int32# -> State# s -> State# s
writeWord32OffAddr# :: Addr# -> Int# -> Word32# -> State# s -> State# s
writeInt64OffAddr# :: Addr# -> Int# -> Int64# -> State# s -> State# s
writeWord64OffAddr# :: Addr# -> Int# -> Word64# -> State# s -> State# s
writeWord8OffAddrAsChar# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeWord8OffAddrAsWideChar# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeWord8OffAddrAsInt# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeWord8OffAddrAsWord# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord8OffAddrAsAddr# :: Addr# -> Int# -> Addr# -> State# s -> State# s
writeWord8OffAddrAsFloat# :: Addr# -> Int# -> Float# -> State# s -> State# s
writeWord8OffAddrAsDouble# :: Addr# -> Int# -> Double# -> State# s -> State# s
writeWord8OffAddrAsStablePtr# :: Addr# -> Int# -> StablePtr# a -> State# s -> State# s
writeWord8OffAddrAsInt16# :: Addr# -> Int# -> Int16# -> State# s -> State# s
writeWord8OffAddrAsWord16# :: Addr# -> Int# -> Word16# -> State# s -> State# s
writeWord8OffAddrAsInt32# :: Addr# -> Int# -> Int32# -> State# s -> State# s
writeWord8OffAddrAsWord32# :: Addr# -> Int# -> Word32# -> State# s -> State# s
writeWord8OffAddrAsInt64# :: Addr# -> Int# -> Int64# -> State# s -> State# s
writeWord8OffAddrAsWord64# :: Addr# -> Int# -> Word64# -> State# s -> State# s
atomicExchangeAddrAddr# :: Addr# -> Addr# -> State# s -> (# State# s, Addr# #)
atomicExchangeWordAddr# :: Addr# -> Word# -> State# s -> (# State# s, Word# #)
atomicCasAddrAddr# :: Addr# -> Addr# -> Addr# -> State# s -> (# State# s, Addr# #)
atomicCasWordAddr# :: Addr# -> Word# -> Word# -> State# s -> (# State# s, Word# #)
atomicCasWord8Addr# :: Addr# -> Word8# -> Word8# -> State# s -> (# State# s, Word8# #)
atomicCasWord16Addr# :: Addr# -> Word16# -> Word16# -> State# s -> (# State# s, Word16# #)
atomicCasWord32Addr# :: Addr# -> Word32# -> Word32# -> State# s -> (# State# s, Word32# #)
atomicCasWord64Addr# :: Addr# -> Word64# -> Word64# -> State# s -> (# State# s, Word64# #)
fetchAddWordAddr# :: Addr# -> Word# -> State# s -> (# State# s, Word# #)
fetchSubWordAddr# :: Addr# -> Word# -> State# s -> (# State# s, Word# #)
fetchAndWordAddr# :: Addr# -> Word# -> State# s -> (# State# s, Word# #)
fetchNandWordAddr# :: Addr# -> Word# -> State# s -> (# State# s, Word# #)
fetchOrWordAddr# :: Addr# -> Word# -> State# s -> (# State# s, Word# #)
fetchXorWordAddr# :: Addr# -> Word# -> State# s -> (# State# s, Word# #)
atomicReadWordAddr# :: Addr# -> State# s -> (# State# s, Word# #)
atomicWriteWordAddr# :: Addr# -> Word# -> State# s -> State# s
newMutVar# :: a_levpoly -> State# s -> (# State# s, MutVar# s a_levpoly #)
readMutVar# :: MutVar# s a_levpoly -> State# s -> (# State# s, a_levpoly #)
writeMutVar# :: MutVar# s a_levpoly -> a_levpoly -> State# s -> State# s
atomicSwapMutVar# :: MutVar# s a_levpoly -> a_levpoly -> State# s -> (# State# s, a_levpoly #)
atomicModifyMutVar2# :: MutVar# s a -> (a -> c) -> State# s -> (# State# s, a, c #)
atomicModifyMutVar_# :: MutVar# s a -> (a -> a) -> State# s -> (# State# s, a, a #)
casMutVar# :: MutVar# s a_levpoly -> a_levpoly -> a_levpoly -> State# s -> (# State# s, Int#, a_levpoly #)
catch# :: (State# RealWorld -> (# State# RealWorld, a_reppoly #)) -> (b_levpoly -> State# RealWorld -> (# State# RealWorld, a_reppoly #)) -> State# RealWorld -> (# State# RealWorld, a_reppoly #)
raise# :: a_levpoly -> b_reppoly
raiseUnderflow# :: (# #) -> b_reppoly
raiseOverflow# :: (# #) -> b_reppoly
raiseDivZero# :: (# #) -> b_reppoly
raiseIO# :: a_levpoly -> State# RealWorld -> (# State# RealWorld, b_reppoly #)
maskAsyncExceptions# :: (State# RealWorld -> (# State# RealWorld, a_reppoly #)) -> State# RealWorld -> (# State# RealWorld, a_reppoly #)
maskUninterruptible# :: (State# RealWorld -> (# State# RealWorld, a_reppoly #)) -> State# RealWorld -> (# State# RealWorld, a_reppoly #)
unmaskAsyncExceptions# :: (State# RealWorld -> (# State# RealWorld, a_reppoly #)) -> State# RealWorld -> (# State# RealWorld, a_reppoly #)
getMaskingState# :: State# RealWorld -> (# State# RealWorld, Int# #)
newPromptTag# :: State# RealWorld -> (# State# RealWorld, PromptTag# a #)
prompt# :: PromptTag# a -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
control0# :: PromptTag# a -> (((State# RealWorld -> (# State# RealWorld, b_reppoly #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, b_reppoly #)
atomically# :: (State# RealWorld -> (# State# RealWorld, a_levpoly #)) -> State# RealWorld -> (# State# RealWorld, a_levpoly #)
retry# :: State# RealWorld -> (# State# RealWorld, a_levpoly #)
catchRetry# :: (State# RealWorld -> (# State# RealWorld, a_levpoly #)) -> (State# RealWorld -> (# State# RealWorld, a_levpoly #)) -> State# RealWorld -> (# State# RealWorld, a_levpoly #)
catchSTM# :: (State# RealWorld -> (# State# RealWorld, a_levpoly #)) -> (b -> State# RealWorld -> (# State# RealWorld, a_levpoly #)) -> State# RealWorld -> (# State# RealWorld, a_levpoly #)
newTVar# :: a_levpoly -> State# s -> (# State# s, TVar# s a_levpoly #)
readTVar# :: TVar# s a_levpoly -> State# s -> (# State# s, a_levpoly #)
readTVarIO# :: TVar# s a_levpoly -> State# s -> (# State# s, a_levpoly #)
writeTVar# :: TVar# s a_levpoly -> a_levpoly -> State# s -> State# s
newMVar# :: State# s -> (# State# s, MVar# s a_levpoly #)
takeMVar# :: MVar# s a_levpoly -> State# s -> (# State# s, a_levpoly #)
tryTakeMVar# :: MVar# s a_levpoly -> State# s -> (# State# s, Int#, a_levpoly #)
putMVar# :: MVar# s a_levpoly -> a_levpoly -> State# s -> State# s
tryPutMVar# :: MVar# s a_levpoly -> a_levpoly -> State# s -> (# State# s, Int# #)
readMVar# :: MVar# s a_levpoly -> State# s -> (# State# s, a_levpoly #)
tryReadMVar# :: MVar# s a_levpoly -> State# s -> (# State# s, Int#, a_levpoly #)
isEmptyMVar# :: MVar# s a_levpoly -> State# s -> (# State# s, Int# #)
newIOPort# :: State# s -> (# State# s, IOPort# s a_levpoly #)
readIOPort# :: IOPort# s a_levpoly -> State# s -> (# State# s, a_levpoly #)
writeIOPort# :: IOPort# s a_levpoly -> a_levpoly -> State# s -> (# State# s, Int# #)
delay# :: Int# -> State# s -> State# s
waitRead# :: Int# -> State# s -> State# s
waitWrite# :: Int# -> State# s -> State# s
fork# :: (State# RealWorld -> (# State# RealWorld, a_reppoly #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
forkOn# :: Int# -> (State# RealWorld -> (# State# RealWorld, a_reppoly #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
killThread# :: ThreadId# -> a -> State# RealWorld -> State# RealWorld
yield# :: State# RealWorld -> State# RealWorld
myThreadId# :: State# RealWorld -> (# State# RealWorld, ThreadId# #)
labelThread# :: ThreadId# -> ByteArray# -> State# RealWorld -> State# RealWorld
isCurrentThreadBound# :: State# RealWorld -> (# State# RealWorld, Int# #)
noDuplicate# :: State# s -> State# s
threadLabel# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, ByteArray# #)
threadStatus# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, Int#, Int# #)
listThreads# :: State# RealWorld -> (# State# RealWorld, Array# ThreadId# #)
mkWeak# :: a_levpoly -> b_levpoly -> (State# RealWorld -> (# State# RealWorld, c #)) -> State# RealWorld -> (# State# RealWorld, Weak# b_levpoly #)
mkWeakNoFinalizer# :: a_levpoly -> b_levpoly -> State# RealWorld -> (# State# RealWorld, Weak# b_levpoly #)
addCFinalizerToWeak# :: Addr# -> Addr# -> Int# -> Addr# -> Weak# b_levpoly -> State# RealWorld -> (# State# RealWorld, Int# #)
deRefWeak# :: Weak# a_levpoly -> State# RealWorld -> (# State# RealWorld, Int#, a_levpoly #)
finalizeWeak# :: Weak# a_levpoly -> State# RealWorld -> (# State# RealWorld, Int#, State# RealWorld -> (# State# RealWorld, b #) #)
touch# :: a_levpoly -> State# s -> State# s
makeStablePtr# :: a_levpoly -> State# RealWorld -> (# State# RealWorld, StablePtr# a_levpoly #)
deRefStablePtr# :: StablePtr# a_levpoly -> State# RealWorld -> (# State# RealWorld, a_levpoly #)
eqStablePtr# :: StablePtr# a_levpoly -> StablePtr# a_levpoly -> Int#
makeStableName# :: a_levpoly -> State# RealWorld -> (# State# RealWorld, StableName# a_levpoly #)
stableNameToInt# :: StableName# a_levpoly -> Int#
compactNew# :: Word# -> State# RealWorld -> (# State# RealWorld, Compact# #)
compactResize# :: Compact# -> Word# -> State# RealWorld -> State# RealWorld
compactContains# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, Int# #)
compactContainsAny# :: a -> State# RealWorld -> (# State# RealWorld, Int# #)
compactGetFirstBlock# :: Compact# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)
compactGetNextBlock# :: Compact# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)
compactAllocateBlock# :: Word# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr# #)
compactFixupPointers# :: Addr# -> Addr# -> State# RealWorld -> (# State# RealWorld, Compact#, Addr# #)
compactAdd# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)
compactAddWithSharing# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)
compactSize# :: Compact# -> State# RealWorld -> (# State# RealWorld, Word# #)
reallyUnsafePtrEquality# :: a_levpoly -> b_levpoly -> Int#
par# :: a -> Int#
spark# :: a -> State# s -> (# State# s, a #)
getSpark# :: State# s -> (# State# s, Int#, a #)
numSparks# :: State# s -> (# State# s, Int# #)
keepAlive# :: a_levpoly -> State# s -> (State# s -> b_reppoly) -> b_reppoly
dataToTagSmall# :: a_levpoly -> Int#
dataToTagLarge# :: a_levpoly -> Int#
addrToAny# :: Addr# -> (# a_levpoly #)
anyToAddr# :: a -> State# RealWorld -> (# State# RealWorld, Addr# #)
mkApUpd0# :: BCO -> (# a #)
newBCO# :: ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# s -> (# State# s, BCO #)
unpackClosure# :: a -> (# Addr#, ByteArray#, Array# b #)
closureSize# :: a -> Int#
getApStackVal# :: a -> Int# -> (# Int#, b #)
getCCSOf# :: a -> State# s -> (# State# s, Addr# #)
getCurrentCCS# :: a -> State# s -> (# State# s, Addr# #)
clearCCS# :: (State# s -> (# State# s, a #)) -> State# s -> (# State# s, a #)
whereFrom# :: a -> Addr# -> State# s -> (# State# s, Int# #)
traceEvent# :: Addr# -> State# s -> State# s
traceBinaryEvent# :: Addr# -> Int# -> State# s -> State# s
traceMarker# :: Addr# -> State# s -> State# s
setThreadAllocationCounter# :: Int64# -> State# RealWorld -> State# RealWorld
prefetchByteArray3# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray3# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr3# :: Addr# -> Int# -> State# s -> State# s
prefetchValue3# :: a -> State# s -> State# s
prefetchByteArray2# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray2# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr2# :: Addr# -> Int# -> State# s -> State# s
prefetchValue2# :: a -> State# s -> State# s
prefetchByteArray1# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray1# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr1# :: Addr# -> Int# -> State# s -> State# s
prefetchValue1# :: a -> State# s -> State# s
prefetchByteArray0# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray0# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr0# :: Addr# -> Int# -> State# s -> State# s
prefetchValue0# :: a -> State# s -> State# s


-- | Comparing underlying pointers for equality.
--   
--   Use GHC.Exts from the base package instead of importing this module
--   directly.
module GHC.Prim.PtrEq

-- | Compare the underlying pointers of two values for equality.
--   
--   Returns <tt>1</tt> if the pointers are equal and <tt>0</tt> otherwise.
--   
--   The two values must be of the same type, of kind <tt>Type</tt>. See
--   also <a>reallyUnsafePtrEquality#</a>, which doesn't have such
--   restrictions.
reallyUnsafePtrEquality :: a -> a -> Int#

-- | Compare the underlying pointers of two unlifted values for equality.
--   
--   This is less dangerous than <a>reallyUnsafePtrEquality</a>, since the
--   arguments are guaranteed to be evaluated. This means there is no risk
--   of accidentally comparing a thunk. It's however still more dangerous
--   than e.g. <a>sameArray#</a>.
unsafePtrEquality# :: forall (a :: UnliftedType) (b :: UnliftedType). a -> b -> Int#

-- | Compare the underlying pointers of two arrays.
sameArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Array# a -> Array# a -> Int#

-- | Compare the underlying pointers of two mutable arrays.
sameMutableArray# :: forall {l :: Levity} s (a :: TYPE ('BoxedRep l)). MutableArray# s a -> MutableArray# s a -> Int#

-- | Compare the underlying pointers of two small arrays.
sameSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). SmallArray# a -> SmallArray# a -> Int#

-- | Compare the underlying pointers of two small mutable arrays.
sameSmallMutableArray# :: forall {l :: Levity} s (a :: TYPE ('BoxedRep l)). SmallMutableArray# s a -> SmallMutableArray# s a -> Int#

-- | Compare the pointers of two byte arrays.
sameByteArray# :: ByteArray# -> ByteArray# -> Int#

-- | Compare the underlying pointers of two mutable byte arrays.
sameMutableByteArray# :: MutableByteArray# s -> MutableByteArray# s -> Int#

-- | Compare the underlying pointers of two <a>MutVar#</a>s.
sameMutVar# :: forall {l :: Levity} s (a :: TYPE ('BoxedRep l)). MutVar# s a -> MutVar# s a -> Int#

-- | Compare the underlying pointers of two <a>TVar#</a>s.
sameTVar# :: forall {l :: Levity} s (a :: TYPE ('BoxedRep l)). TVar# s a -> TVar# s a -> Int#

-- | Compare the underlying pointers of two <a>MVar#</a>s.
sameMVar# :: forall {l :: Levity} s (a :: TYPE ('BoxedRep l)). MVar# s a -> MVar# s a -> Int#

-- | Compare the underlying pointers of two <a>IOPort#</a>s.
sameIOPort# :: forall {l :: Levity} s (a :: TYPE ('BoxedRep l)). IOPort# s a -> IOPort# s a -> Int#

-- | Compare the underlying pointers of two <a>PromptTag#</a>s.
samePromptTag# :: PromptTag# a -> PromptTag# a -> Int#

-- | Compare two stable names for equality.
eqStableName# :: forall {k :: Levity} {l :: Levity} (a :: TYPE ('BoxedRep k)) (b :: TYPE ('BoxedRep l)). StableName# a -> StableName# b -> Int#


-- | Extra C-- routines exposed from the RTS
--   
--   Users should not import this module. It is GHC internal only. Use
--   <a>GHC.Conc</a> instead.
--   
--   Actual primops are emitted by the compiler itself. They are special
--   bits of code with backend support. The foreign functions in this
--   module aren't actual primops because the compiler doesn't care about
--   them at all: they just are extra foreign C-- calls libraries can make
--   into the RTS.
--   
--   Note that <a>Prim</a> has the same haddock section names as this
--   module, but with descriptions. Consult that module's documentation for
--   what each section means. are described over there.
module GHC.Prim.Ext

-- | Retrieves the allocation counter for the current thread.
getThreadAllocationCounter# :: State# RealWorld -> (# State# RealWorld, Int64# #)


-- | Primitive exceptions.
--   
--   Users should not import this module. It is GHC internal only.
module GHC.Prim.Exception

-- | Raise <a>overflowException</a>
raiseOverflow :: a

-- | Raise <a>underflowException</a>
raiseUnderflow :: a

-- | Raise <a>divZeroException</a>
raiseDivZero :: a


-- | GHC's primitive types and operations. Use GHC.Exts from the base
--   package instead of importing this module directly.
module GHC.Prim

-- | The builtin function type, written in infix form as <tt>a % m -&gt;
--   b</tt>. Values of this type are functions taking inputs of type
--   <tt>a</tt> and producing outputs of type <tt>b</tt>. The multiplicity
--   of the input is <tt>m</tt>.
--   
--   Note that <tt><a>FUN</a> m a b</tt> permits representation
--   polymorphism in both <tt>a</tt> and <tt>b</tt>, so that types like
--   <tt><a>Int#</a> -&gt; <a>Int#</a></tt> can still be well-kinded.
data FUN
data Char# :: TYPE 'WordRep
gtChar# :: Char# -> Char# -> Int#
geChar# :: Char# -> Char# -> Int#
eqChar# :: Char# -> Char# -> Int#
neChar# :: Char# -> Char# -> Int#
ltChar# :: Char# -> Char# -> Int#
leChar# :: Char# -> Char# -> Int#
ord# :: Char# -> Int#
data Int8# :: TYPE 'Int8Rep
int8ToInt# :: Int8# -> Int#
intToInt8# :: Int# -> Int8#
negateInt8# :: Int8# -> Int8#
plusInt8# :: Int8# -> Int8# -> Int8#
subInt8# :: Int8# -> Int8# -> Int8#
timesInt8# :: Int8# -> Int8# -> Int8#
quotInt8# :: Int8# -> Int8# -> Int8#
remInt8# :: Int8# -> Int8# -> Int8#
quotRemInt8# :: Int8# -> Int8# -> (# Int8#, Int8# #)
uncheckedShiftLInt8# :: Int8# -> Int# -> Int8#
uncheckedShiftRAInt8# :: Int8# -> Int# -> Int8#
uncheckedShiftRLInt8# :: Int8# -> Int# -> Int8#
int8ToWord8# :: Int8# -> Word8#
eqInt8# :: Int8# -> Int8# -> Int#
geInt8# :: Int8# -> Int8# -> Int#
gtInt8# :: Int8# -> Int8# -> Int#
leInt8# :: Int8# -> Int8# -> Int#
ltInt8# :: Int8# -> Int8# -> Int#
neInt8# :: Int8# -> Int8# -> Int#
data Word8# :: TYPE 'Word8Rep
word8ToWord# :: Word8# -> Word#
wordToWord8# :: Word# -> Word8#
plusWord8# :: Word8# -> Word8# -> Word8#
subWord8# :: Word8# -> Word8# -> Word8#
timesWord8# :: Word8# -> Word8# -> Word8#
quotWord8# :: Word8# -> Word8# -> Word8#
remWord8# :: Word8# -> Word8# -> Word8#
quotRemWord8# :: Word8# -> Word8# -> (# Word8#, Word8# #)
andWord8# :: Word8# -> Word8# -> Word8#
orWord8# :: Word8# -> Word8# -> Word8#
xorWord8# :: Word8# -> Word8# -> Word8#
notWord8# :: Word8# -> Word8#
uncheckedShiftLWord8# :: Word8# -> Int# -> Word8#
uncheckedShiftRLWord8# :: Word8# -> Int# -> Word8#
word8ToInt8# :: Word8# -> Int8#
eqWord8# :: Word8# -> Word8# -> Int#
geWord8# :: Word8# -> Word8# -> Int#
gtWord8# :: Word8# -> Word8# -> Int#
leWord8# :: Word8# -> Word8# -> Int#
ltWord8# :: Word8# -> Word8# -> Int#
neWord8# :: Word8# -> Word8# -> Int#
data Int16# :: TYPE 'Int16Rep
int16ToInt# :: Int16# -> Int#
intToInt16# :: Int# -> Int16#
negateInt16# :: Int16# -> Int16#
plusInt16# :: Int16# -> Int16# -> Int16#
subInt16# :: Int16# -> Int16# -> Int16#
timesInt16# :: Int16# -> Int16# -> Int16#
quotInt16# :: Int16# -> Int16# -> Int16#
remInt16# :: Int16# -> Int16# -> Int16#
quotRemInt16# :: Int16# -> Int16# -> (# Int16#, Int16# #)
uncheckedShiftLInt16# :: Int16# -> Int# -> Int16#
uncheckedShiftRAInt16# :: Int16# -> Int# -> Int16#
uncheckedShiftRLInt16# :: Int16# -> Int# -> Int16#
int16ToWord16# :: Int16# -> Word16#
eqInt16# :: Int16# -> Int16# -> Int#
geInt16# :: Int16# -> Int16# -> Int#
gtInt16# :: Int16# -> Int16# -> Int#
leInt16# :: Int16# -> Int16# -> Int#
ltInt16# :: Int16# -> Int16# -> Int#
neInt16# :: Int16# -> Int16# -> Int#
data Word16# :: TYPE 'Word16Rep
word16ToWord# :: Word16# -> Word#
wordToWord16# :: Word# -> Word16#
plusWord16# :: Word16# -> Word16# -> Word16#
subWord16# :: Word16# -> Word16# -> Word16#
timesWord16# :: Word16# -> Word16# -> Word16#
quotWord16# :: Word16# -> Word16# -> Word16#
remWord16# :: Word16# -> Word16# -> Word16#
quotRemWord16# :: Word16# -> Word16# -> (# Word16#, Word16# #)
andWord16# :: Word16# -> Word16# -> Word16#
orWord16# :: Word16# -> Word16# -> Word16#
xorWord16# :: Word16# -> Word16# -> Word16#
notWord16# :: Word16# -> Word16#
uncheckedShiftLWord16# :: Word16# -> Int# -> Word16#
uncheckedShiftRLWord16# :: Word16# -> Int# -> Word16#
word16ToInt16# :: Word16# -> Int16#
eqWord16# :: Word16# -> Word16# -> Int#
geWord16# :: Word16# -> Word16# -> Int#
gtWord16# :: Word16# -> Word16# -> Int#
leWord16# :: Word16# -> Word16# -> Int#
ltWord16# :: Word16# -> Word16# -> Int#
neWord16# :: Word16# -> Word16# -> Int#
data Int32# :: TYPE 'Int32Rep
int32ToInt# :: Int32# -> Int#
intToInt32# :: Int# -> Int32#
negateInt32# :: Int32# -> Int32#
plusInt32# :: Int32# -> Int32# -> Int32#
subInt32# :: Int32# -> Int32# -> Int32#
timesInt32# :: Int32# -> Int32# -> Int32#
quotInt32# :: Int32# -> Int32# -> Int32#
remInt32# :: Int32# -> Int32# -> Int32#
quotRemInt32# :: Int32# -> Int32# -> (# Int32#, Int32# #)
uncheckedShiftLInt32# :: Int32# -> Int# -> Int32#
uncheckedShiftRAInt32# :: Int32# -> Int# -> Int32#
uncheckedShiftRLInt32# :: Int32# -> Int# -> Int32#
int32ToWord32# :: Int32# -> Word32#
eqInt32# :: Int32# -> Int32# -> Int#
geInt32# :: Int32# -> Int32# -> Int#
gtInt32# :: Int32# -> Int32# -> Int#
leInt32# :: Int32# -> Int32# -> Int#
ltInt32# :: Int32# -> Int32# -> Int#
neInt32# :: Int32# -> Int32# -> Int#
data Word32# :: TYPE 'Word32Rep
word32ToWord# :: Word32# -> Word#
wordToWord32# :: Word# -> Word32#
plusWord32# :: Word32# -> Word32# -> Word32#
subWord32# :: Word32# -> Word32# -> Word32#
timesWord32# :: Word32# -> Word32# -> Word32#
quotWord32# :: Word32# -> Word32# -> Word32#
remWord32# :: Word32# -> Word32# -> Word32#
quotRemWord32# :: Word32# -> Word32# -> (# Word32#, Word32# #)
andWord32# :: Word32# -> Word32# -> Word32#
orWord32# :: Word32# -> Word32# -> Word32#
xorWord32# :: Word32# -> Word32# -> Word32#
notWord32# :: Word32# -> Word32#
uncheckedShiftLWord32# :: Word32# -> Int# -> Word32#
uncheckedShiftRLWord32# :: Word32# -> Int# -> Word32#
word32ToInt32# :: Word32# -> Int32#
eqWord32# :: Word32# -> Word32# -> Int#
geWord32# :: Word32# -> Word32# -> Int#
gtWord32# :: Word32# -> Word32# -> Int#
leWord32# :: Word32# -> Word32# -> Int#
ltWord32# :: Word32# -> Word32# -> Int#
neWord32# :: Word32# -> Word32# -> Int#
data Int64# :: TYPE 'Int64Rep
int64ToInt# :: Int64# -> Int#
intToInt64# :: Int# -> Int64#
negateInt64# :: Int64# -> Int64#
plusInt64# :: Int64# -> Int64# -> Int64#
subInt64# :: Int64# -> Int64# -> Int64#
timesInt64# :: Int64# -> Int64# -> Int64#
quotInt64# :: Int64# -> Int64# -> Int64#
remInt64# :: Int64# -> Int64# -> Int64#
uncheckedIShiftL64# :: Int64# -> Int# -> Int64#
uncheckedIShiftRA64# :: Int64# -> Int# -> Int64#
uncheckedIShiftRL64# :: Int64# -> Int# -> Int64#
int64ToWord64# :: Int64# -> Word64#
eqInt64# :: Int64# -> Int64# -> Int#
geInt64# :: Int64# -> Int64# -> Int#
gtInt64# :: Int64# -> Int64# -> Int#
leInt64# :: Int64# -> Int64# -> Int#
ltInt64# :: Int64# -> Int64# -> Int#
neInt64# :: Int64# -> Int64# -> Int#
data Word64# :: TYPE 'Word64Rep
word64ToWord# :: Word64# -> Word#
wordToWord64# :: Word# -> Word64#
plusWord64# :: Word64# -> Word64# -> Word64#
subWord64# :: Word64# -> Word64# -> Word64#
timesWord64# :: Word64# -> Word64# -> Word64#
quotWord64# :: Word64# -> Word64# -> Word64#
remWord64# :: Word64# -> Word64# -> Word64#
and64# :: Word64# -> Word64# -> Word64#
or64# :: Word64# -> Word64# -> Word64#
xor64# :: Word64# -> Word64# -> Word64#
not64# :: Word64# -> Word64#
uncheckedShiftL64# :: Word64# -> Int# -> Word64#
uncheckedShiftRL64# :: Word64# -> Int# -> Word64#
word64ToInt64# :: Word64# -> Int64#
eqWord64# :: Word64# -> Word64# -> Int#
geWord64# :: Word64# -> Word64# -> Int#
gtWord64# :: Word64# -> Word64# -> Int#
leWord64# :: Word64# -> Word64# -> Int#
ltWord64# :: Word64# -> Word64# -> Int#
neWord64# :: Word64# -> Word64# -> Int#
data Int# :: TYPE 'IntRep
(+#) :: Int# -> Int# -> Int#
infixl 6 +#
(-#) :: Int# -> Int# -> Int#
infixl 6 -#

-- | Low word of signed integer multiply.
(*#) :: Int# -> Int# -> Int#
infixl 7 *#

-- | Return a triple (isHighNeeded,high,low) where high and low are
--   respectively the high and low bits of the double-word result.
--   isHighNeeded is a cheap way to test if the high word is a
--   sign-extension of the low word (isHighNeeded = 0#) or not
--   (isHighNeeded = 1#).
timesInt2# :: Int# -> Int# -> (# Int#, Int#, Int# #)

-- | Return non-zero if there is any possibility that the upper word of a
--   signed integer multiply might contain useful information. Return zero
--   only if you are completely sure that no overflow can occur. On a
--   32-bit platform, the recommended implementation is to do a 32 x 32
--   -&gt; 64 signed multiply, and subtract result[63:32] from (result[31]
--   &gt;&gt;signed 31). If this is zero, meaning that the upper word is
--   merely a sign extension of the lower one, no overflow can occur.
--   
--   On a 64-bit platform it is not always possible to acquire the top 64
--   bits of the result. Therefore, a recommended implementation is to take
--   the absolute value of both operands, and return 0 iff bits[63:31] of
--   them are zero, since that means that their magnitudes fit within 31
--   bits, so the magnitude of the product must fit into 62 bits.
--   
--   If in doubt, return non-zero, but do make an effort to create the
--   correct answer for small args, since otherwise the performance of
--   <tt>(*) :: Integer -&gt; Integer -&gt; Integer</tt> will be poor.
mulIntMayOflo# :: Int# -> Int# -> Int#

-- | Rounds towards zero. The behavior is undefined if the second argument
--   is zero.
quotInt# :: Int# -> Int# -> Int#

-- | Satisfies <tt>(<a>quotInt#</a> x y) <a>*#</a> y <a>+#</a>
--   (<a>remInt#</a> x y) == x</tt>. The behavior is undefined if the
--   second argument is zero.
remInt# :: Int# -> Int# -> Int#

-- | Rounds towards zero.
quotRemInt# :: Int# -> Int# -> (# Int#, Int# #)

-- | Bitwise "and".
andI# :: Int# -> Int# -> Int#

-- | Bitwise "or".
orI# :: Int# -> Int# -> Int#

-- | Bitwise "xor".
xorI# :: Int# -> Int# -> Int#

-- | Bitwise "not", also known as the binary complement.
notI# :: Int# -> Int#

-- | Unary negation. Since the negative <a>Int#</a> range extends one
--   further than the positive range, <a>negateInt#</a> of the most
--   negative number is an identity operation. This way, <a>negateInt#</a>
--   is always its own inverse.
negateInt# :: Int# -> Int#

-- | Add signed integers reporting overflow. First member of result is the
--   sum truncated to an <a>Int#</a>; second member is zero if the true sum
--   fits in an <a>Int#</a>, nonzero if overflow occurred (the sum is
--   either too large or too small to fit in an <a>Int#</a>).
addIntC# :: Int# -> Int# -> (# Int#, Int# #)

-- | Subtract signed integers reporting overflow. First member of result is
--   the difference truncated to an <a>Int#</a>; second member is zero if
--   the true difference fits in an <a>Int#</a>, nonzero if overflow
--   occurred (the difference is either too large or too small to fit in an
--   <a>Int#</a>).
subIntC# :: Int# -> Int# -> (# Int#, Int# #)
(>#) :: Int# -> Int# -> Int#
infix 4 >#
(>=#) :: Int# -> Int# -> Int#
infix 4 >=#
(==#) :: Int# -> Int# -> Int#
infix 4 ==#
(/=#) :: Int# -> Int# -> Int#
infix 4 /=#
(<#) :: Int# -> Int# -> Int#
infix 4 <#
(<=#) :: Int# -> Int# -> Int#
infix 4 <=#
chr# :: Int# -> Char#
int2Word# :: Int# -> Word#

-- | Convert an <a>Int#</a> to the corresponding <a>Float#</a> with the
--   same integral value (up to truncation due to floating-point
--   precision). e.g. <tt><a>int2Float#</a> 1# == 1.0#</tt>
int2Float# :: Int# -> Float#

-- | Convert an <a>Int#</a> to the corresponding <a>Double#</a> with the
--   same integral value (up to truncation due to floating-point
--   precision). e.g. <tt><a>int2Double#</a> 1# == 1.0##</tt>
int2Double# :: Int# -> Double#

-- | Convert an <a>Word#</a> to the corresponding <a>Float#</a> with the
--   same integral value (up to truncation due to floating-point
--   precision). e.g. <tt><a>word2Float#</a> 1## == 1.0#</tt>
word2Float# :: Word# -> Float#

-- | Convert an <a>Word#</a> to the corresponding <a>Double#</a> with the
--   same integral value (up to truncation due to floating-point
--   precision). e.g. <tt><a>word2Double#</a> 1## == 1.0##</tt>
word2Double# :: Word# -> Double#

-- | Shift left. Result undefined if shift amount is not in the range 0 to
--   word size - 1 inclusive.
uncheckedIShiftL# :: Int# -> Int# -> Int#

-- | Shift right arithmetic. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedIShiftRA# :: Int# -> Int# -> Int#

-- | Shift right logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedIShiftRL# :: Int# -> Int# -> Int#
data Word# :: TYPE 'WordRep
plusWord# :: Word# -> Word# -> Word#

-- | Add unsigned integers reporting overflow. The first element of the
--   pair is the result. The second element is the carry flag, which is
--   nonzero on overflow. See also <a>plusWord2#</a>.
addWordC# :: Word# -> Word# -> (# Word#, Int# #)

-- | Subtract unsigned integers reporting overflow. The first element of
--   the pair is the result. The second element is the carry flag, which is
--   nonzero on overflow.
subWordC# :: Word# -> Word# -> (# Word#, Int# #)

-- | Add unsigned integers, with the high part (carry) in the first
--   component of the returned pair and the low part in the second
--   component of the pair. See also <a>addWordC#</a>.
plusWord2# :: Word# -> Word# -> (# Word#, Word# #)
minusWord# :: Word# -> Word# -> Word#
timesWord# :: Word# -> Word# -> Word#
timesWord2# :: Word# -> Word# -> (# Word#, Word# #)
quotWord# :: Word# -> Word# -> Word#
remWord# :: Word# -> Word# -> Word#
quotRemWord# :: Word# -> Word# -> (# Word#, Word# #)

-- | Takes high word of dividend, then low word of dividend, then divisor.
--   Requires that high word &lt; divisor.
quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#, Word# #)
and# :: Word# -> Word# -> Word#
or# :: Word# -> Word# -> Word#
xor# :: Word# -> Word# -> Word#
not# :: Word# -> Word#

-- | Shift left logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedShiftL# :: Word# -> Int# -> Word#

-- | Shift right logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedShiftRL# :: Word# -> Int# -> Word#
word2Int# :: Word# -> Int#
gtWord# :: Word# -> Word# -> Int#
geWord# :: Word# -> Word# -> Int#
eqWord# :: Word# -> Word# -> Int#
neWord# :: Word# -> Word# -> Int#
ltWord# :: Word# -> Word# -> Int#
leWord# :: Word# -> Word# -> Int#

-- | Count the number of set bits in the lower 8 bits of a word.
popCnt8# :: Word# -> Word#

-- | Count the number of set bits in the lower 16 bits of a word.
popCnt16# :: Word# -> Word#

-- | Count the number of set bits in the lower 32 bits of a word.
popCnt32# :: Word# -> Word#

-- | Count the number of set bits in a 64-bit word.
popCnt64# :: Word64# -> Word#

-- | Count the number of set bits in a word.
popCnt# :: Word# -> Word#

-- | Deposit bits to lower 8 bits of a word at locations specified by a
--   mask.
pdep8# :: Word# -> Word# -> Word#

-- | Deposit bits to lower 16 bits of a word at locations specified by a
--   mask.
pdep16# :: Word# -> Word# -> Word#

-- | Deposit bits to lower 32 bits of a word at locations specified by a
--   mask.
pdep32# :: Word# -> Word# -> Word#

-- | Deposit bits to a word at locations specified by a mask.
pdep64# :: Word64# -> Word64# -> Word64#

-- | Deposit bits to a word at locations specified by a mask, aka
--   <a>parallel bit deposit</a>.
--   
--   Software emulation:
--   
--   <pre>
--   pdep :: Word -&gt; Word -&gt; Word
--   pdep src mask = go 0 src mask
--     where
--       go :: Word -&gt; Word -&gt; Word -&gt; Word
--       go result _ 0 = result
--       go result src mask = go newResult newSrc newMask
--         where
--           maskCtz   = countTrailingZeros mask
--           newResult = if testBit src 0 then setBit result maskCtz else result
--           newSrc    = src `shiftR` 1
--           newMask   = clearBit mask maskCtz
--   </pre>
pdep# :: Word# -> Word# -> Word#

-- | Extract bits from lower 8 bits of a word at locations specified by a
--   mask.
pext8# :: Word# -> Word# -> Word#

-- | Extract bits from lower 16 bits of a word at locations specified by a
--   mask.
pext16# :: Word# -> Word# -> Word#

-- | Extract bits from lower 32 bits of a word at locations specified by a
--   mask.
pext32# :: Word# -> Word# -> Word#

-- | Extract bits from a word at locations specified by a mask.
pext64# :: Word64# -> Word64# -> Word64#

-- | Extract bits from a word at locations specified by a mask, aka
--   <a>parallel bit extract</a>.
--   
--   Software emulation:
--   
--   <pre>
--   pext :: Word -&gt; Word -&gt; Word
--   pext src mask = loop 0 0 0
--     where
--       loop i count result
--         | i &gt;= finiteBitSize (0 :: Word)
--         = result
--         | testBit mask i
--         = loop (i + 1) (count + 1) (if testBit src i then setBit result count else result)
--         | otherwise
--         = loop (i + 1) count result
--   </pre>
pext# :: Word# -> Word# -> Word#

-- | Count leading zeros in the lower 8 bits of a word.
clz8# :: Word# -> Word#

-- | Count leading zeros in the lower 16 bits of a word.
clz16# :: Word# -> Word#

-- | Count leading zeros in the lower 32 bits of a word.
clz32# :: Word# -> Word#

-- | Count leading zeros in a 64-bit word.
clz64# :: Word64# -> Word#

-- | Count leading zeros in a word.
clz# :: Word# -> Word#

-- | Count trailing zeros in the lower 8 bits of a word.
ctz8# :: Word# -> Word#

-- | Count trailing zeros in the lower 16 bits of a word.
ctz16# :: Word# -> Word#

-- | Count trailing zeros in the lower 32 bits of a word.
ctz32# :: Word# -> Word#

-- | Count trailing zeros in a 64-bit word.
ctz64# :: Word64# -> Word#

-- | Count trailing zeros in a word.
ctz# :: Word# -> Word#

-- | Swap bytes in the lower 16 bits of a word. The higher bytes are
--   undefined.
byteSwap16# :: Word# -> Word#

-- | Swap bytes in the lower 32 bits of a word. The higher bytes are
--   undefined.
byteSwap32# :: Word# -> Word#

-- | Swap bytes in a 64 bits of a word.
byteSwap64# :: Word64# -> Word64#

-- | Swap bytes in a word.
byteSwap# :: Word# -> Word#

-- | Reverse the order of the bits in a 8-bit word.
bitReverse8# :: Word# -> Word#

-- | Reverse the order of the bits in a 16-bit word.
bitReverse16# :: Word# -> Word#

-- | Reverse the order of the bits in a 32-bit word.
bitReverse32# :: Word# -> Word#

-- | Reverse the order of the bits in a 64-bit word.
bitReverse64# :: Word64# -> Word64#

-- | Reverse the order of the bits in a word.
bitReverse# :: Word# -> Word#
narrow8Int# :: Int# -> Int#
narrow16Int# :: Int# -> Int#
narrow32Int# :: Int# -> Int#
narrow8Word# :: Word# -> Word#
narrow16Word# :: Word# -> Word#
narrow32Word# :: Word# -> Word#
data Double# :: TYPE 'DoubleRep
(>##) :: Double# -> Double# -> Int#
infix 4 >##
(>=##) :: Double# -> Double# -> Int#
infix 4 >=##
(==##) :: Double# -> Double# -> Int#
infix 4 ==##
(/=##) :: Double# -> Double# -> Int#
infix 4 /=##
(<##) :: Double# -> Double# -> Int#
infix 4 <##
(<=##) :: Double# -> Double# -> Int#
infix 4 <=##
minDouble# :: Double# -> Double# -> Double#
maxDouble# :: Double# -> Double# -> Double#
(+##) :: Double# -> Double# -> Double#
infixl 6 +##
(-##) :: Double# -> Double# -> Double#
infixl 6 -##
(*##) :: Double# -> Double# -> Double#
infixl 7 *##
(/##) :: Double# -> Double# -> Double#
infixl 7 /##
negateDouble# :: Double# -> Double#
fabsDouble# :: Double# -> Double#

-- | Truncates a <a>Double#</a> value to the nearest <a>Int#</a>. Results
--   are undefined if the truncation if truncation yields a value outside
--   the range of <a>Int#</a>.
double2Int# :: Double# -> Int#
double2Float# :: Double# -> Float#
expDouble# :: Double# -> Double#
expm1Double# :: Double# -> Double#
logDouble# :: Double# -> Double#
log1pDouble# :: Double# -> Double#
sqrtDouble# :: Double# -> Double#
sinDouble# :: Double# -> Double#
cosDouble# :: Double# -> Double#
tanDouble# :: Double# -> Double#
asinDouble# :: Double# -> Double#
acosDouble# :: Double# -> Double#
atanDouble# :: Double# -> Double#
sinhDouble# :: Double# -> Double#
coshDouble# :: Double# -> Double#
tanhDouble# :: Double# -> Double#
asinhDouble# :: Double# -> Double#
acoshDouble# :: Double# -> Double#
atanhDouble# :: Double# -> Double#

-- | Exponentiation.
(**##) :: Double# -> Double# -> Double#

-- | Convert to integer. First component of the result is -1 or 1,
--   indicating the sign of the mantissa. The next two are the high and low
--   32 bits of the mantissa respectively, and the last is the exponent.
decodeDouble_2Int# :: Double# -> (# Int#, Word#, Word#, Int# #)

-- | Decode <a>Double#</a> into mantissa and base-2 exponent.
decodeDouble_Int64# :: Double# -> (# Int64#, Int# #)

-- | Bitcast a <a>Double#</a> into a <a>Word64#</a>
castDoubleToWord64# :: Double# -> Word64#

-- | Bitcast a <a>Word64#</a> into a <a>Double#</a>
castWord64ToDouble# :: Word64# -> Double#
data Float# :: TYPE 'FloatRep
gtFloat# :: Float# -> Float# -> Int#
geFloat# :: Float# -> Float# -> Int#
eqFloat# :: Float# -> Float# -> Int#
neFloat# :: Float# -> Float# -> Int#
ltFloat# :: Float# -> Float# -> Int#
leFloat# :: Float# -> Float# -> Int#
minFloat# :: Float# -> Float# -> Float#
maxFloat# :: Float# -> Float# -> Float#
plusFloat# :: Float# -> Float# -> Float#
minusFloat# :: Float# -> Float# -> Float#
timesFloat# :: Float# -> Float# -> Float#
divideFloat# :: Float# -> Float# -> Float#
negateFloat# :: Float# -> Float#
fabsFloat# :: Float# -> Float#

-- | Truncates a <a>Float#</a> value to the nearest <a>Int#</a>. Results
--   are undefined if the truncation if truncation yields a value outside
--   the range of <a>Int#</a>.
float2Int# :: Float# -> Int#
expFloat# :: Float# -> Float#
expm1Float# :: Float# -> Float#
logFloat# :: Float# -> Float#
log1pFloat# :: Float# -> Float#
sqrtFloat# :: Float# -> Float#
sinFloat# :: Float# -> Float#
cosFloat# :: Float# -> Float#
tanFloat# :: Float# -> Float#
asinFloat# :: Float# -> Float#
acosFloat# :: Float# -> Float#
atanFloat# :: Float# -> Float#
sinhFloat# :: Float# -> Float#
coshFloat# :: Float# -> Float#
tanhFloat# :: Float# -> Float#
asinhFloat# :: Float# -> Float#
acoshFloat# :: Float# -> Float#
atanhFloat# :: Float# -> Float#
powerFloat# :: Float# -> Float# -> Float#
float2Double# :: Float# -> Double#

-- | Convert to integers. First <a>Int#</a> in result is the mantissa;
--   second is the exponent.
decodeFloat_Int# :: Float# -> (# Int#, Int# #)

-- | Bitcast a <a>Float#</a> into a <a>Word32#</a>
castFloatToWord32# :: Float# -> Word32#

-- | Bitcast a <a>Word32#</a> into a <a>Float#</a>
castWord32ToFloat# :: Word32# -> Float#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddFloat# :: Float# -> Float# -> Float# -> Float#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubFloat# :: Float# -> Float# -> Float# -> Float#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddFloat# :: Float# -> Float# -> Float# -> Float#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubFloat# :: Float# -> Float# -> Float# -> Float#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddDouble# :: Double# -> Double# -> Double# -> Double#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubDouble# :: Double# -> Double# -> Double# -> Double#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddDouble# :: Double# -> Double# -> Double# -> Double#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubDouble# :: Double# -> Double# -> Double# -> Double#
data Array# (a :: TYPE 'BoxedRep l) :: UnliftedType
data MutableArray# a (b :: TYPE 'BoxedRep l) :: UnliftedType

-- | Create a new mutable array with the specified number of elements, in
--   the specified state thread, with each element containing the specified
--   initial value.
newArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. Int# -> a -> State# d -> (# State# d, MutableArray# d a #)

-- | Read from specified index of mutable array. Result is not yet
--   evaluated.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> State# d -> (# State# d, a #)

-- | Write to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> a -> State# d -> State# d

-- | Return the number of elements in the array.
sizeofArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Array# a -> Int#

-- | Return the number of elements in the array.
sizeofMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int#

-- | Read from the specified index of an immutable array. The result is
--   packaged into an unboxed unary tuple; the result itself is not yet
--   evaluated. Pattern matching on the tuple forces the indexing of the
--   array to happen but does not evaluate the element itself. Evaluating
--   the thunk prevents additional thunks from building up on the heap.
--   Avoiding these thunks, in turn, reduces references to the argument
--   array, allowing it to be garbage collected more promptly.
indexArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Array# a -> Int# -> (# a #)

-- | Make a mutable array immutable, without copying.
unsafeFreezeArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> State# d -> (# State# d, Array# a #)

-- | Make an immutable array mutable, without copying.
unsafeThawArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. Array# a -> State# d -> (# State# d, MutableArray# d a #)

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. The two arrays must not be the same array in different
--   states, but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. Array# a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. In the case where the source and destination are the
--   same array the source and destination regions may overlap.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Array# a -> Int# -> Int# -> Array# a

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
freezeArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, Array# a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
thawArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. Array# a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)

-- | Given an array, an offset, the expected old value, and the new value,
--   perform an atomic compare and swap (i.e. write the new value if the
--   current value and the old value are the same pointer). Returns 0 if
--   the swap succeeds and 1 if it fails. Additionally, returns the element
--   at the offset after the operation completes. This means that on a
--   success the new value is returned, and on a failure the actual old
--   value (not the expected one) is returned. Implies a full memory
--   barrier. The use of a pointer equality on a boxed value makes this
--   function harder to use correctly than <a>casIntArray#</a>. All of the
--   difficulties of using <a>reallyUnsafePtrEquality#</a> correctly apply
--   to <a>casArray#</a> as well.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)
data SmallArray# (a :: TYPE 'BoxedRep l) :: UnliftedType
data SmallMutableArray# a (b :: TYPE 'BoxedRep l) :: UnliftedType

-- | Create a new mutable array with the specified number of elements, in
--   the specified state thread, with each element containing the specified
--   initial value.
newSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. Int# -> a -> State# d -> (# State# d, SmallMutableArray# d a #)

-- | Shrink mutable array to new specified size, in the specified state
--   thread. The new size argument must be less than or equal to the
--   current size as reported by <a>getSizeofSmallMutableArray#</a>.
--   
--   Assuming the non-profiling RTS, for the copying garbage collector
--   (default) this primitive compiles to an O(1) operation in C--,
--   modifying the array in-place. For the non-moving garbage collector,
--   however, the time is proportional to the number of elements shrinked
--   out. Backends bypassing C-- representation (such as JavaScript) might
--   behave differently.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
shrinkSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> State# d -> State# d

-- | Read from specified index of mutable array. Result is not yet
--   evaluated.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readSmallArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> State# d -> (# State# d, a #)

-- | Write to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeSmallArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> a -> State# d -> State# d

-- | Return the number of elements in the array.
sizeofSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). SmallArray# a -> Int#

-- | Return the number of elements in the array. <b>Deprecated</b>, it is
--   unsafe in the presence of <a>shrinkSmallMutableArray#</a> and
--   <tt>resizeSmallMutableArray#</tt> operations on the same small mutable
--   array.

-- | <i>Deprecated: Use <a>getSizeofSmallMutableArray#</a> instead </i>
sizeofSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int#

-- | Return the number of elements in the array, correctly accounting for
--   the effect of <a>shrinkSmallMutableArray#</a> and
--   <tt>resizeSmallMutableArray#</tt>.
getSizeofSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> State# d -> (# State# d, Int# #)

-- | Read from specified index of immutable array. Result is packaged into
--   an unboxed singleton; the result itself is not yet evaluated.
indexSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). SmallArray# a -> Int# -> (# a #)

-- | Make a mutable array immutable, without copying.
unsafeFreezeSmallArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> State# d -> (# State# d, SmallArray# a #)

-- | Make an immutable array mutable, without copying.
unsafeThawSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. SmallArray# a -> State# d -> (# State# d, SmallMutableArray# d a #)

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. The two arrays must not be the same array in different
--   states, but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copySmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. SmallArray# a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. The source and destination arrays can refer to the same array.
--   Both arrays must fully contain the specified ranges, but this is not
--   checked. The regions are allowed to overlap, although this is only
--   possible when the same array is provided as both the source and the
--   destination.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copySmallMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). SmallArray# a -> Int# -> Int# -> SmallArray# a

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
freezeSmallArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallArray# a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
thawSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. SmallArray# a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)

-- | Unsafe, machine-level atomic compare and swap on an element within an
--   array. See the documentation of <a>casArray#</a>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casSmallArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)

-- | A boxed, unlifted datatype representing a region of raw memory in the
--   garbage-collected heap, which is not scanned for pointers during
--   garbage collection.
--   
--   It is created by freezing a <a>MutableByteArray#</a> with
--   <a>unsafeFreezeByteArray#</a>. Freezing is essentially a no-op, as
--   <a>MutableByteArray#</a> and <a>ByteArray#</a> share the same heap
--   structure under the hood.
--   
--   The immutable and mutable variants are commonly used for scenarios
--   requiring high-performance data structures, like <tt>Text</tt>,
--   <tt>Primitive Vector</tt>, <tt>Unboxed Array</tt>, and
--   <tt>ShortByteString</tt>.
--   
--   Another application of fundamental importance is <tt>Integer</tt>,
--   which is backed by <a>ByteArray#</a>.
--   
--   The representation on the heap of a Byte Array is:
--   
--   <pre>
--   +------------+-----------------+-----------------------+
--   |            |                 |                       |
--   |   HEADER   | SIZE (in bytes) |       PAYLOAD         |
--   |            |                 |                       |
--   +------------+-----------------+-----------------------+
--   </pre>
--   
--   To obtain a pointer to actual payload (e.g., for FFI purposes) use
--   <a>byteArrayContents#</a> or <a>mutableByteArrayContents#</a>.
--   
--   Alternatively, enabling the <tt>UnliftedFFITypes</tt> extension allows
--   to mention <a>ByteArray#</a> and <a>MutableByteArray#</a> in FFI type
--   signatures directly.
data ByteArray# :: UnliftedType

-- | A mutable <tt>ByteAray#</tt>. It can be created in three ways:
--   
--   <ul>
--   <li><a>newByteArray#</a>: Create an unpinned array.</li>
--   <li><a>newPinnedByteArray#</a>: This will create a pinned array,</li>
--   <li><a>newAlignedPinnedByteArray#</a>: This will create a pinned
--   array, with a custom alignment.</li>
--   </ul>
--   
--   Unpinned arrays can be moved around during garbage collection, so you
--   must not store or pass pointers to these values if there is a chance
--   for the garbage collector to kick in. That said, even unpinned arrays
--   can be passed to unsafe FFI calls, because no garbage collection
--   happens during these unsafe calls (see <a>Guaranteed Call Safety</a>
--   in the GHC Manual). For safe FFI calls, byte arrays must be not only
--   pinned, but also kept alive by means of the keepAlive# function for
--   the duration of a call (that's because garbage collection cannot move
--   a pinned array, but is free to scrap it altogether).
data MutableByteArray# a :: UnliftedType

-- | Create a new mutable byte array of specified size (in bytes), in the
--   specified state thread. The size of the memory underlying the array
--   will be rounded up to the platform's word size.
newByteArray# :: Int# -> State# d -> (# State# d, MutableByteArray# d #)

-- | Like <a>newByteArray#</a> but GC guarantees not to move it.
newPinnedByteArray# :: Int# -> State# d -> (# State# d, MutableByteArray# d #)

-- | Like <a>newPinnedByteArray#</a> but allow specifying an arbitrary
--   alignment, which must be a power of two.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
newAlignedPinnedByteArray# :: Int# -> Int# -> State# d -> (# State# d, MutableByteArray# d #)

-- | Determine whether a <a>MutableByteArray#</a> is guaranteed not to move
--   during GC.
isMutableByteArrayPinned# :: MutableByteArray# d -> Int#

-- | Determine whether a <a>ByteArray#</a> is guaranteed not to move.
isByteArrayPinned# :: ByteArray# -> Int#

-- | Similar to <a>isByteArrayPinned#</a>. Weakly pinned byte arrays are
--   allowed to be copied into compact regions by the user, potentially
--   invalidating the results of earlier calls to
--   <a>byteArrayContents#</a>.
--   
--   See the section `Pinned Byte Arrays` in the user guide for more
--   information.
--   
--   This function also returns true for regular pinned bytearrays.
isByteArrayWeaklyPinned# :: ByteArray# -> Int#

-- | <a>isByteArrayWeaklyPinned#</a> but for mutable arrays.
isMutableByteArrayWeaklyPinned# :: MutableByteArray# d -> Int#

-- | Intended for use with pinned arrays; otherwise very unsafe!
byteArrayContents# :: ByteArray# -> Addr#

-- | Intended for use with pinned arrays; otherwise very unsafe!
mutableByteArrayContents# :: MutableByteArray# d -> Addr#

-- | Shrink mutable byte array to new specified size (in bytes), in the
--   specified state thread. The new size argument must be less than or
--   equal to the current size as reported by
--   <a>getSizeofMutableByteArray#</a>.
--   
--   Assuming the non-profiling RTS, this primitive compiles to an O(1)
--   operation in C--, modifying the array in-place. Backends bypassing C--
--   representation (such as JavaScript) might behave differently.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
shrinkMutableByteArray# :: MutableByteArray# d -> Int# -> State# d -> State# d

-- | Resize mutable byte array to new specified size (in bytes), shrinking
--   or growing it. The returned <a>MutableByteArray#</a> is either the
--   original <a>MutableByteArray#</a> resized in-place or, if not
--   possible, a newly allocated (unpinned) <a>MutableByteArray#</a> (with
--   the original content copied over).
--   
--   To avoid undefined behaviour, the original <a>MutableByteArray#</a>
--   shall not be accessed anymore after a <a>resizeMutableByteArray#</a>
--   has been performed. Moreover, no reference to the old one should be
--   kept in order to allow garbage collection of the original
--   <a>MutableByteArray#</a> in case a new <a>MutableByteArray#</a> had to
--   be allocated.
resizeMutableByteArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, MutableByteArray# d #)

-- | Make a mutable byte array immutable, without copying.
unsafeFreezeByteArray# :: MutableByteArray# d -> State# d -> (# State# d, ByteArray# #)

-- | Make an immutable byte array mutable, without copying.
unsafeThawByteArray# :: ByteArray# -> State# d -> (# State# d, MutableByteArray# d #)

-- | Return the size of the array in bytes.
sizeofByteArray# :: ByteArray# -> Int#

-- | Return the size of the array in bytes. <b>Deprecated</b>, it is unsafe
--   in the presence of <a>shrinkMutableByteArray#</a> and
--   <a>resizeMutableByteArray#</a> operations on the same mutable byte
--   array.

-- | <i>Deprecated: Use <a>getSizeofMutableByteArray#</a> instead </i>
sizeofMutableByteArray# :: MutableByteArray# d -> Int#

-- | Return the number of elements in the array, correctly accounting for
--   the effect of <a>shrinkMutableByteArray#</a> and
--   <a>resizeMutableByteArray#</a>.
getSizeofMutableByteArray# :: MutableByteArray# d -> State# d -> (# State# d, Int# #)

-- | Read an 8-bit character from immutable array; offset in bytes.
indexCharArray# :: ByteArray# -> Int# -> Char#

-- | Read a 32-bit character from immutable array; offset in 4-byte words.
indexWideCharArray# :: ByteArray# -> Int# -> Char#

-- | Read a word-sized integer from immutable array; offset in machine
--   words.
indexIntArray# :: ByteArray# -> Int# -> Int#

-- | Read a word-sized unsigned integer from immutable array; offset in
--   machine words.
indexWordArray# :: ByteArray# -> Int# -> Word#

-- | Read a machine address from immutable array; offset in machine words.
indexAddrArray# :: ByteArray# -> Int# -> Addr#

-- | Read a single-precision floating-point value from immutable array;
--   offset in 4-byte words.
indexFloatArray# :: ByteArray# -> Int# -> Float#

-- | Read a double-precision floating-point value from immutable array;
--   offset in 8-byte words.
indexDoubleArray# :: ByteArray# -> Int# -> Double#

-- | Read a <a>StablePtr#</a> value from immutable array; offset in machine
--   words.
indexStablePtrArray# :: ByteArray# -> Int# -> StablePtr# a

-- | Read an 8-bit signed integer from immutable array; offset in bytes.
indexInt8Array# :: ByteArray# -> Int# -> Int8#

-- | Read an 8-bit unsigned integer from immutable array; offset in bytes.
indexWord8Array# :: ByteArray# -> Int# -> Word8#

-- | Read a 16-bit signed integer from immutable array; offset in 2-byte
--   words.
indexInt16Array# :: ByteArray# -> Int# -> Int16#

-- | Read a 16-bit unsigned integer from immutable array; offset in 2-byte
--   words.
indexWord16Array# :: ByteArray# -> Int# -> Word16#

-- | Read a 32-bit signed integer from immutable array; offset in 4-byte
--   words.
indexInt32Array# :: ByteArray# -> Int# -> Int32#

-- | Read a 32-bit unsigned integer from immutable array; offset in 4-byte
--   words.
indexWord32Array# :: ByteArray# -> Int# -> Word32#

-- | Read a 64-bit signed integer from immutable array; offset in 8-byte
--   words.
indexInt64Array# :: ByteArray# -> Int# -> Int64#

-- | Read a 64-bit unsigned integer from immutable array; offset in 8-byte
--   words.
indexWord64Array# :: ByteArray# -> Int# -> Word64#

-- | Read an 8-bit character from immutable array; offset in bytes.
indexWord8ArrayAsChar# :: ByteArray# -> Int# -> Char#

-- | Read a 32-bit character from immutable array; offset in bytes.
indexWord8ArrayAsWideChar# :: ByteArray# -> Int# -> Char#

-- | Read a word-sized integer from immutable array; offset in bytes.
indexWord8ArrayAsInt# :: ByteArray# -> Int# -> Int#

-- | Read a word-sized unsigned integer from immutable array; offset in
--   bytes.
indexWord8ArrayAsWord# :: ByteArray# -> Int# -> Word#

-- | Read a machine address from immutable array; offset in bytes.
indexWord8ArrayAsAddr# :: ByteArray# -> Int# -> Addr#

-- | Read a single-precision floating-point value from immutable array;
--   offset in bytes.
indexWord8ArrayAsFloat# :: ByteArray# -> Int# -> Float#

-- | Read a double-precision floating-point value from immutable array;
--   offset in bytes.
indexWord8ArrayAsDouble# :: ByteArray# -> Int# -> Double#

-- | Read a <a>StablePtr#</a> value from immutable array; offset in bytes.
indexWord8ArrayAsStablePtr# :: ByteArray# -> Int# -> StablePtr# a

-- | Read a 16-bit signed integer from immutable array; offset in bytes.
indexWord8ArrayAsInt16# :: ByteArray# -> Int# -> Int16#

-- | Read a 16-bit unsigned integer from immutable array; offset in bytes.
indexWord8ArrayAsWord16# :: ByteArray# -> Int# -> Word16#

-- | Read a 32-bit signed integer from immutable array; offset in bytes.
indexWord8ArrayAsInt32# :: ByteArray# -> Int# -> Int32#

-- | Read a 32-bit unsigned integer from immutable array; offset in bytes.
indexWord8ArrayAsWord32# :: ByteArray# -> Int# -> Word32#

-- | Read a 64-bit signed integer from immutable array; offset in bytes.
indexWord8ArrayAsInt64# :: ByteArray# -> Int# -> Int64#

-- | Read a 64-bit unsigned integer from immutable array; offset in bytes.
indexWord8ArrayAsWord64# :: ByteArray# -> Int# -> Word64#

-- | Read an 8-bit character from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readCharArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a 32-bit character from mutable array; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWideCharArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a word-sized integer from mutable array; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readIntArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)

-- | Read a word-sized unsigned integer from mutable array; offset in
--   machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWordArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)

-- | Read a machine address from mutable array; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readAddrArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)

-- | Read a single-precision floating-point value from mutable array;
--   offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)

-- | Read a double-precision floating-point value from mutable array;
--   offset in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)

-- | Read a <a>StablePtr#</a> value from mutable array; offset in machine
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readStablePtrArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)

-- | Read an 8-bit signed integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8# #)

-- | Read an 8-bit unsigned integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8# #)

-- | Read a 16-bit signed integer from mutable array; offset in 2-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16# #)

-- | Read a 16-bit unsigned integer from mutable array; offset in 2-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16# #)

-- | Read a 32-bit signed integer from mutable array; offset in 4-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32# #)

-- | Read a 32-bit unsigned integer from mutable array; offset in 4-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32# #)

-- | Read a 64-bit signed integer from mutable array; offset in 8-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64# #)

-- | Read a 64-bit unsigned integer from mutable array; offset in 8-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64# #)

-- | Read an 8-bit character from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsChar# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a 32-bit character from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWideChar# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a word-sized integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)

-- | Read a word-sized unsigned integer from mutable array; offset in
--   bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)

-- | Read a machine address from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsAddr# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)

-- | Read a single-precision floating-point value from mutable array;
--   offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsFloat# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)

-- | Read a double-precision floating-point value from mutable array;
--   offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsDouble# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)

-- | Read a <a>StablePtr#</a> value from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsStablePtr# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)

-- | Read a 16-bit signed integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16# #)

-- | Read a 16-bit unsigned integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16# #)

-- | Read a 32-bit signed integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32# #)

-- | Read a 32-bit unsigned integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32# #)

-- | Read a 64-bit signed integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64# #)

-- | Read a 64-bit unsigned integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64# #)

-- | Write an 8-bit character to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeCharArray# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d

-- | Write a 32-bit character to mutable array; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWideCharArray# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d

-- | Write a word-sized integer to mutable array; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Write a word-sized unsigned integer to mutable array; offset in
--   machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWordArray# :: MutableByteArray# d -> Int# -> Word# -> State# d -> State# d

-- | Write a machine address to mutable array; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeAddrArray# :: MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d

-- | Write a single-precision floating-point value to mutable array; offset
--   in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatArray# :: MutableByteArray# d -> Int# -> Float# -> State# d -> State# d

-- | Write a double-precision floating-point value to mutable array; offset
--   in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleArray# :: MutableByteArray# d -> Int# -> Double# -> State# d -> State# d

-- | Write a <a>StablePtr#</a> value to mutable array; offset in machine
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeStablePtrArray# :: MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d

-- | Write an 8-bit signed integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8Array# :: MutableByteArray# d -> Int# -> Int8# -> State# d -> State# d

-- | Write an 8-bit unsigned integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8Array# :: MutableByteArray# d -> Int# -> Word8# -> State# d -> State# d

-- | Write a 16-bit signed integer to mutable array; offset in 2-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16Array# :: MutableByteArray# d -> Int# -> Int16# -> State# d -> State# d

-- | Write a 16-bit unsigned integer to mutable array; offset in 2-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16Array# :: MutableByteArray# d -> Int# -> Word16# -> State# d -> State# d

-- | Write a 32-bit signed integer to mutable array; offset in 4-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32Array# :: MutableByteArray# d -> Int# -> Int32# -> State# d -> State# d

-- | Write a 32-bit unsigned integer to mutable array; offset in 4-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32Array# :: MutableByteArray# d -> Int# -> Word32# -> State# d -> State# d

-- | Write a 64-bit signed integer to mutable array; offset in 8-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64Array# :: MutableByteArray# d -> Int# -> Int64# -> State# d -> State# d

-- | Write a 64-bit unsigned integer to mutable array; offset in 8-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64Array# :: MutableByteArray# d -> Int# -> Word64# -> State# d -> State# d

-- | Write an 8-bit character to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsChar# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d

-- | Write a 32-bit character to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWideChar# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d

-- | Write a word-sized integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt# :: MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Write a word-sized unsigned integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord# :: MutableByteArray# d -> Int# -> Word# -> State# d -> State# d

-- | Write a machine address to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsAddr# :: MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d

-- | Write a single-precision floating-point value to mutable array; offset
--   in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsFloat# :: MutableByteArray# d -> Int# -> Float# -> State# d -> State# d

-- | Write a double-precision floating-point value to mutable array; offset
--   in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsDouble# :: MutableByteArray# d -> Int# -> Double# -> State# d -> State# d

-- | Write a <a>StablePtr#</a> value to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsStablePtr# :: MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d

-- | Write a 16-bit signed integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt16# :: MutableByteArray# d -> Int# -> Int16# -> State# d -> State# d

-- | Write a 16-bit unsigned integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord16# :: MutableByteArray# d -> Int# -> Word16# -> State# d -> State# d

-- | Write a 32-bit signed integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt32# :: MutableByteArray# d -> Int# -> Int32# -> State# d -> State# d

-- | Write a 32-bit unsigned integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord32# :: MutableByteArray# d -> Int# -> Word32# -> State# d -> State# d

-- | Write a 64-bit signed integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt64# :: MutableByteArray# d -> Int# -> Int64# -> State# d -> State# d

-- | Write a 64-bit unsigned integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord64# :: MutableByteArray# d -> Int# -> Word64# -> State# d -> State# d

-- | <tt><a>compareByteArrays#</a> src1 src1_ofs src2 src2_ofs n</tt>
--   compares <tt>n</tt> bytes starting at offset <tt>src1_ofs</tt> in the
--   first <a>ByteArray#</a> <tt>src1</tt> to the range of <tt>n</tt> bytes
--   (i.e. same length) starting at offset <tt>src2_ofs</tt> of the second
--   <a>ByteArray#</a> <tt>src2</tt>. Both arrays must fully contain the
--   specified ranges, but this is not checked. Returns an <a>Int#</a> less
--   than, equal to, or greater than zero if the range is found,
--   respectively, to be byte-wise lexicographically less than, to match,
--   or be greater than the second range.
compareByteArrays# :: ByteArray# -> Int# -> ByteArray# -> Int# -> Int# -> Int#

-- | <tt><a>copyByteArray#</a> src src_ofs dst dst_ofs len</tt> copies the
--   range starting at offset <tt>src_ofs</tt> of length <tt>len</tt> from
--   the <a>ByteArray#</a> <tt>src</tt> to the <a>MutableByteArray#</a>
--   <tt>dst</tt> starting at offset <tt>dst_ofs</tt>. Both arrays must
--   fully contain the specified ranges, but this is not checked. The two
--   arrays must not be the same array in different states, but this is not
--   checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyByteArray# :: ByteArray# -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | <tt><a>copyMutableByteArray#</a> src src_ofs dst dst_ofs len</tt>
--   copies the range starting at offset <tt>src_ofs</tt> of length
--   <tt>len</tt> from the <a>MutableByteArray#</a> <tt>src</tt> to the
--   <a>MutableByteArray#</a> <tt>dst</tt> starting at offset
--   <tt>dst_ofs</tt>. Both arrays must fully contain the specified ranges,
--   but this is not checked. The regions are allowed to overlap, although
--   this is only possible when the same array is provided as both the
--   source and the destination.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableByteArray# :: MutableByteArray# d -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | <tt><a>copyMutableByteArrayNonOverlapping#</a> src src_ofs dst dst_ofs
--   len</tt> copies the range starting at offset <tt>src_ofs</tt> of
--   length <tt>len</tt> from the <a>MutableByteArray#</a> <tt>src</tt> to
--   the <a>MutableByteArray#</a> <tt>dst</tt> starting at offset
--   <tt>dst_ofs</tt>. Both arrays must fully contain the specified ranges,
--   but this is not checked. The regions are <i>not</i> allowed to
--   overlap, but this is also not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableByteArrayNonOverlapping# :: MutableByteArray# d -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Copy a range of the ByteArray# to the memory range starting at the
--   Addr#. The ByteArray# and the memory region at Addr# must fully
--   contain the specified ranges, but this is not checked. The Addr# must
--   not point into the ByteArray# (e.g. if the ByteArray# were pinned),
--   but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyByteArrayToAddr# :: ByteArray# -> Int# -> Addr# -> Int# -> State# d -> State# d

-- | Copy a range of the MutableByteArray# to the memory range starting at
--   the Addr#. The MutableByteArray# and the memory region at Addr# must
--   fully contain the specified ranges, but this is not checked. The Addr#
--   must not point into the MutableByteArray# (e.g. if the
--   MutableByteArray# were pinned), but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableByteArrayToAddr# :: MutableByteArray# d -> Int# -> Addr# -> Int# -> State# d -> State# d

-- | Copy a memory range starting at the Addr# to the specified range in
--   the MutableByteArray#. The memory region at Addr# and the ByteArray#
--   must fully contain the specified ranges, but this is not checked. The
--   Addr# must not point into the MutableByteArray# (e.g. if the
--   MutableByteArray# were pinned), but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyAddrToByteArray# :: Addr# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | <tt><a>copyAddrToAddr#</a> src dest len</tt> copies <tt>len</tt> bytes
--   from <tt>src</tt> to <tt>dest</tt>. These two memory ranges are
--   allowed to overlap.
--   
--   Analogous to the standard C function <tt>memmove</tt>, but with a
--   different argument order.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyAddrToAddr# :: Addr# -> Addr# -> Int# -> State# RealWorld -> State# RealWorld

-- | <tt><a>copyAddrToAddrNonOverlapping#</a> src dest len</tt> copies
--   <tt>len</tt> bytes from <tt>src</tt> to <tt>dest</tt>. As the name
--   suggests, these two memory ranges <i>must not overlap</i>, although
--   this pre-condition is not checked.
--   
--   Analogous to the standard C function <tt>memcpy</tt>, but with a
--   different argument order.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyAddrToAddrNonOverlapping# :: Addr# -> Addr# -> Int# -> State# RealWorld -> State# RealWorld

-- | <tt><a>setByteArray#</a> ba off len c</tt> sets the byte range
--   <tt>[off, off+len)</tt> of the <a>MutableByteArray#</a> to the byte
--   <tt>c</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
setByteArray# :: MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> State# d

-- | <tt><a>setAddrRange#</a> dest len c</tt> sets all of the bytes in
--   <tt>[dest, dest+len)</tt> to the value <tt>c</tt>.
--   
--   Analogous to the standard C function <tt>memset</tt>, but with a
--   different argument order.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
setAddrRange# :: Addr# -> Int# -> Int# -> State# RealWorld -> State# RealWorld

-- | Given an array and an offset in machine words, read an element. The
--   index is assumed to be in bounds. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicReadIntArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an array and an offset in machine words, write an element. The
--   index is assumed to be in bounds. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicWriteIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Given an array, an offset in machine words, the expected old value,
--   and the new value, perform an atomic compare and swap i.e. write the
--   new value if the current value matches the provided old value. Returns
--   the value of the element before the operation. Implies a full memory
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casIntArray# :: MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an array, an offset in bytes, the expected old value, and the
--   new value, perform an atomic compare and swap i.e. write the new value
--   if the current value matches the provided old value. Returns the value
--   of the element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casInt8Array# :: MutableByteArray# d -> Int# -> Int8# -> Int8# -> State# d -> (# State# d, Int8# #)

-- | Given an array, an offset in 16 bit units, the expected old value, and
--   the new value, perform an atomic compare and swap i.e. write the new
--   value if the current value matches the provided old value. Returns the
--   value of the element before the operation. Implies a full memory
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casInt16Array# :: MutableByteArray# d -> Int# -> Int16# -> Int16# -> State# d -> (# State# d, Int16# #)

-- | Given an array, an offset in 32 bit units, the expected old value, and
--   the new value, perform an atomic compare and swap i.e. write the new
--   value if the current value matches the provided old value. Returns the
--   value of the element before the operation. Implies a full memory
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casInt32Array# :: MutableByteArray# d -> Int# -> Int32# -> Int32# -> State# d -> (# State# d, Int32# #)

-- | Given an array, an offset in 64 bit units, the expected old value, and
--   the new value, perform an atomic compare and swap i.e. write the new
--   value if the current value matches the provided old value. Returns the
--   value of the element before the operation. Implies a full memory
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casInt64Array# :: MutableByteArray# d -> Int# -> Int64# -> Int64# -> State# d -> (# State# d, Int64# #)

-- | Given an array, and offset in machine words, and a value to add,
--   atomically add the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAddIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an array, and offset in machine words, and a value to subtract,
--   atomically subtract the value from the element. Returns the value of
--   the element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchSubIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an array, and offset in machine words, and a value to AND,
--   atomically AND the value into the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAndIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an array, and offset in machine words, and a value to NAND,
--   atomically NAND the value into the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchNandIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an array, and offset in machine words, and a value to OR,
--   atomically OR the value into the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchOrIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an array, and offset in machine words, and a value to XOR,
--   atomically XOR the value into the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchXorIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | An arbitrary machine address assumed to point outside the
--   garbage-collected heap.
data Addr# :: TYPE 'AddrRep

-- | The null address.
nullAddr# :: Addr#
plusAddr# :: Addr# -> Int# -> Addr#

-- | Result is meaningless if two <a>Addr#</a>s are so far apart that their
--   difference doesn't fit in an <a>Int#</a>.
minusAddr# :: Addr# -> Addr# -> Int#

-- | Return the remainder when the <a>Addr#</a> arg, treated like an
--   <a>Int#</a>, is divided by the <a>Int#</a> arg.
remAddr# :: Addr# -> Int# -> Int#

-- | Coerce directly from address to int. Users are discouraged from using
--   this operation as it makes little sense on platforms with tagged
--   pointers.
addr2Int# :: Addr# -> Int#

-- | Coerce directly from int to address. Users are discouraged from using
--   this operation as it makes little sense on platforms with tagged
--   pointers.
int2Addr# :: Int# -> Addr#
gtAddr# :: Addr# -> Addr# -> Int#
geAddr# :: Addr# -> Addr# -> Int#
eqAddr# :: Addr# -> Addr# -> Int#
neAddr# :: Addr# -> Addr# -> Int#
ltAddr# :: Addr# -> Addr# -> Int#
leAddr# :: Addr# -> Addr# -> Int#

-- | Read an 8-bit character from immutable address; offset in bytes.
indexCharOffAddr# :: Addr# -> Int# -> Char#

-- | Read a 32-bit character from immutable address; offset in 4-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexWideCharOffAddr# :: Addr# -> Int# -> Char#

-- | Read a word-sized integer from immutable address; offset in machine
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexIntOffAddr# :: Addr# -> Int# -> Int#

-- | Read a word-sized unsigned integer from immutable address; offset in
--   machine words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexWordOffAddr# :: Addr# -> Int# -> Word#

-- | Read a machine address from immutable address; offset in machine
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexAddrOffAddr# :: Addr# -> Int# -> Addr#

-- | Read a single-precision floating-point value from immutable address;
--   offset in 4-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexFloatOffAddr# :: Addr# -> Int# -> Float#

-- | Read a double-precision floating-point value from immutable address;
--   offset in 8-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexDoubleOffAddr# :: Addr# -> Int# -> Double#

-- | Read a <a>StablePtr#</a> value from immutable address; offset in
--   machine words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a

-- | Read an 8-bit signed integer from immutable address; offset in bytes.
indexInt8OffAddr# :: Addr# -> Int# -> Int8#

-- | Read an 8-bit unsigned integer from immutable address; offset in
--   bytes.
indexWord8OffAddr# :: Addr# -> Int# -> Word8#

-- | Read a 16-bit signed integer from immutable address; offset in 2-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexInt16OffAddr# :: Addr# -> Int# -> Int16#

-- | Read a 16-bit unsigned integer from immutable address; offset in
--   2-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexWord16OffAddr# :: Addr# -> Int# -> Word16#

-- | Read a 32-bit signed integer from immutable address; offset in 4-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexInt32OffAddr# :: Addr# -> Int# -> Int32#

-- | Read a 32-bit unsigned integer from immutable address; offset in
--   4-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexWord32OffAddr# :: Addr# -> Int# -> Word32#

-- | Read a 64-bit signed integer from immutable address; offset in 8-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexInt64OffAddr# :: Addr# -> Int# -> Int64#

-- | Read a 64-bit unsigned integer from immutable address; offset in
--   8-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexWord64OffAddr# :: Addr# -> Int# -> Word64#

-- | Read an 8-bit character from immutable address; offset in bytes.
indexWord8OffAddrAsChar# :: Addr# -> Int# -> Char#

-- | Read a 32-bit character from immutable address; offset in bytes.
indexWord8OffAddrAsWideChar# :: Addr# -> Int# -> Char#

-- | Read a word-sized integer from immutable address; offset in bytes.
indexWord8OffAddrAsInt# :: Addr# -> Int# -> Int#

-- | Read a word-sized unsigned integer from immutable address; offset in
--   bytes.
indexWord8OffAddrAsWord# :: Addr# -> Int# -> Word#

-- | Read a machine address from immutable address; offset in bytes.
indexWord8OffAddrAsAddr# :: Addr# -> Int# -> Addr#

-- | Read a single-precision floating-point value from immutable address;
--   offset in bytes.
indexWord8OffAddrAsFloat# :: Addr# -> Int# -> Float#

-- | Read a double-precision floating-point value from immutable address;
--   offset in bytes.
indexWord8OffAddrAsDouble# :: Addr# -> Int# -> Double#

-- | Read a <a>StablePtr#</a> value from immutable address; offset in
--   bytes.
indexWord8OffAddrAsStablePtr# :: Addr# -> Int# -> StablePtr# a

-- | Read a 16-bit signed integer from immutable address; offset in bytes.
indexWord8OffAddrAsInt16# :: Addr# -> Int# -> Int16#

-- | Read a 16-bit unsigned integer from immutable address; offset in
--   bytes.
indexWord8OffAddrAsWord16# :: Addr# -> Int# -> Word16#

-- | Read a 32-bit signed integer from immutable address; offset in bytes.
indexWord8OffAddrAsInt32# :: Addr# -> Int# -> Int32#

-- | Read a 32-bit unsigned integer from immutable address; offset in
--   bytes.
indexWord8OffAddrAsWord32# :: Addr# -> Int# -> Word32#

-- | Read a 64-bit signed integer from immutable address; offset in bytes.
indexWord8OffAddrAsInt64# :: Addr# -> Int# -> Int64#

-- | Read a 64-bit unsigned integer from immutable address; offset in
--   bytes.
indexWord8OffAddrAsWord64# :: Addr# -> Int# -> Word64#

-- | Read an 8-bit character from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readCharOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a 32-bit character from mutable address; offset in 4-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWideCharOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a word-sized integer from mutable address; offset in machine
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readIntOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int# #)

-- | Read a word-sized unsigned integer from mutable address; offset in
--   machine words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWordOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word# #)

-- | Read a machine address from mutable address; offset in machine words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readAddrOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Addr# #)

-- | Read a single-precision floating-point value from mutable address;
--   offset in 4-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Float# #)

-- | Read a double-precision floating-point value from mutable address;
--   offset in 8-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Double# #)

-- | Read a <a>StablePtr#</a> value from mutable address; offset in machine
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readStablePtrOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, StablePtr# a #)

-- | Read an 8-bit signed integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8# #)

-- | Read an 8-bit unsigned integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8# #)

-- | Read a 16-bit signed integer from mutable address; offset in 2-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16# #)

-- | Read a 16-bit unsigned integer from mutable address; offset in 2-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16# #)

-- | Read a 32-bit signed integer from mutable address; offset in 4-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32# #)

-- | Read a 32-bit unsigned integer from mutable address; offset in 4-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32# #)

-- | Read a 64-bit signed integer from mutable address; offset in 8-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64# #)

-- | Read a 64-bit unsigned integer from mutable address; offset in 8-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64# #)

-- | Read an 8-bit character from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsChar# :: Addr# -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a 32-bit character from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWideChar# :: Addr# -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a word-sized integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsInt# :: Addr# -> Int# -> State# d -> (# State# d, Int# #)

-- | Read a word-sized unsigned integer from mutable address; offset in
--   bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWord# :: Addr# -> Int# -> State# d -> (# State# d, Word# #)

-- | Read a machine address from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsAddr# :: Addr# -> Int# -> State# d -> (# State# d, Addr# #)

-- | Read a single-precision floating-point value from mutable address;
--   offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsFloat# :: Addr# -> Int# -> State# d -> (# State# d, Float# #)

-- | Read a double-precision floating-point value from mutable address;
--   offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsDouble# :: Addr# -> Int# -> State# d -> (# State# d, Double# #)

-- | Read a <a>StablePtr#</a> value from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsStablePtr# :: Addr# -> Int# -> State# d -> (# State# d, StablePtr# a #)

-- | Read a 16-bit signed integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsInt16# :: Addr# -> Int# -> State# d -> (# State# d, Int16# #)

-- | Read a 16-bit unsigned integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWord16# :: Addr# -> Int# -> State# d -> (# State# d, Word16# #)

-- | Read a 32-bit signed integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsInt32# :: Addr# -> Int# -> State# d -> (# State# d, Int32# #)

-- | Read a 32-bit unsigned integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWord32# :: Addr# -> Int# -> State# d -> (# State# d, Word32# #)

-- | Read a 64-bit signed integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsInt64# :: Addr# -> Int# -> State# d -> (# State# d, Int64# #)

-- | Read a 64-bit unsigned integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWord64# :: Addr# -> Int# -> State# d -> (# State# d, Word64# #)

-- | Write an 8-bit character to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeCharOffAddr# :: Addr# -> Int# -> Char# -> State# d -> State# d

-- | Write a 32-bit character to mutable address; offset in 4-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWideCharOffAddr# :: Addr# -> Int# -> Char# -> State# d -> State# d

-- | Write a word-sized integer to mutable address; offset in machine
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeIntOffAddr# :: Addr# -> Int# -> Int# -> State# d -> State# d

-- | Write a word-sized unsigned integer to mutable address; offset in
--   machine words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWordOffAddr# :: Addr# -> Int# -> Word# -> State# d -> State# d

-- | Write a machine address to mutable address; offset in machine words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeAddrOffAddr# :: Addr# -> Int# -> Addr# -> State# d -> State# d

-- | Write a single-precision floating-point value to mutable address;
--   offset in 4-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatOffAddr# :: Addr# -> Int# -> Float# -> State# d -> State# d

-- | Write a double-precision floating-point value to mutable address;
--   offset in 8-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleOffAddr# :: Addr# -> Int# -> Double# -> State# d -> State# d

-- | Write a <a>StablePtr#</a> value to mutable address; offset in machine
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a -> State# d -> State# d

-- | Write an 8-bit signed integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8OffAddr# :: Addr# -> Int# -> Int8# -> State# d -> State# d

-- | Write an 8-bit unsigned integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddr# :: Addr# -> Int# -> Word8# -> State# d -> State# d

-- | Write a 16-bit signed integer to mutable address; offset in 2-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16OffAddr# :: Addr# -> Int# -> Int16# -> State# d -> State# d

-- | Write a 16-bit unsigned integer to mutable address; offset in 2-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16OffAddr# :: Addr# -> Int# -> Word16# -> State# d -> State# d

-- | Write a 32-bit signed integer to mutable address; offset in 4-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32OffAddr# :: Addr# -> Int# -> Int32# -> State# d -> State# d

-- | Write a 32-bit unsigned integer to mutable address; offset in 4-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32OffAddr# :: Addr# -> Int# -> Word32# -> State# d -> State# d

-- | Write a 64-bit signed integer to mutable address; offset in 8-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64OffAddr# :: Addr# -> Int# -> Int64# -> State# d -> State# d

-- | Write a 64-bit unsigned integer to mutable address; offset in 8-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64OffAddr# :: Addr# -> Int# -> Word64# -> State# d -> State# d

-- | Write an 8-bit character to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsChar# :: Addr# -> Int# -> Char# -> State# d -> State# d

-- | Write a 32-bit character to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWideChar# :: Addr# -> Int# -> Char# -> State# d -> State# d

-- | Write a word-sized integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsInt# :: Addr# -> Int# -> Int# -> State# d -> State# d

-- | Write a word-sized unsigned integer to mutable address; offset in
--   bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWord# :: Addr# -> Int# -> Word# -> State# d -> State# d

-- | Write a machine address to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsAddr# :: Addr# -> Int# -> Addr# -> State# d -> State# d

-- | Write a single-precision floating-point value to mutable address;
--   offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsFloat# :: Addr# -> Int# -> Float# -> State# d -> State# d

-- | Write a double-precision floating-point value to mutable address;
--   offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsDouble# :: Addr# -> Int# -> Double# -> State# d -> State# d

-- | Write a <a>StablePtr#</a> value to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsStablePtr# :: Addr# -> Int# -> StablePtr# a -> State# d -> State# d

-- | Write a 16-bit signed integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsInt16# :: Addr# -> Int# -> Int16# -> State# d -> State# d

-- | Write a 16-bit unsigned integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWord16# :: Addr# -> Int# -> Word16# -> State# d -> State# d

-- | Write a 32-bit signed integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsInt32# :: Addr# -> Int# -> Int32# -> State# d -> State# d

-- | Write a 32-bit unsigned integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWord32# :: Addr# -> Int# -> Word32# -> State# d -> State# d

-- | Write a 64-bit signed integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsInt64# :: Addr# -> Int# -> Int64# -> State# d -> State# d

-- | Write a 64-bit unsigned integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWord64# :: Addr# -> Int# -> Word64# -> State# d -> State# d

-- | The atomic exchange operation. Atomically exchanges the value at the
--   first address with the Addr# given as second argument. Implies a read
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicExchangeAddrAddr# :: Addr# -> Addr# -> State# d -> (# State# d, Addr# #)

-- | The atomic exchange operation. Atomically exchanges the value at the
--   address with the given value. Returns the old value. Implies a read
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicExchangeWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Compare and swap on a word-sized memory location.
--   
--   Use as: s -&gt; atomicCasAddrAddr# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasAddrAddr# :: Addr# -> Addr# -> Addr# -> State# d -> (# State# d, Addr# #)

-- | Compare and swap on a word-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWordAddr# :: Addr# -> Word# -> Word# -> State# d -> (# State# d, Word# #)

-- | Compare and swap on a 8 bit-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr8# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWord8Addr# :: Addr# -> Word8# -> Word8# -> State# d -> (# State# d, Word8# #)

-- | Compare and swap on a 16 bit-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr16# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWord16Addr# :: Addr# -> Word16# -> Word16# -> State# d -> (# State# d, Word16# #)

-- | Compare and swap on a 32 bit-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr32# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWord32Addr# :: Addr# -> Word32# -> Word32# -> State# d -> (# State# d, Word32# #)

-- | Compare and swap on a 64 bit-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr64# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWord64Addr# :: Addr# -> Word64# -> Word64# -> State# d -> (# State# d, Word64# #)

-- | Given an address, and a value to add, atomically add the value to the
--   element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAddWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Given an address, and a value to subtract, atomically subtract the
--   value from the element. Returns the value of the element before the
--   operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchSubWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Given an address, and a value to AND, atomically AND the value into
--   the element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAndWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Given an address, and a value to NAND, atomically NAND the value into
--   the element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchNandWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Given an address, and a value to OR, atomically OR the value into the
--   element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchOrWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Given an address, and a value to XOR, atomically XOR the value into
--   the element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchXorWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Given an address, read a machine word. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicReadWordAddr# :: Addr# -> State# d -> (# State# d, Word# #)

-- | Given an address, write a machine word. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicWriteWordAddr# :: Addr# -> Word# -> State# d -> State# d

-- | A <a>MutVar#</a> behaves like a single-element mutable array.
data MutVar# a (b :: TYPE 'BoxedRep l) :: UnliftedType

-- | Create <a>MutVar#</a> with specified initial value in specified state
--   thread.
newMutVar# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. a -> State# d -> (# State# d, MutVar# d a #)

-- | Read contents of <a>MutVar#</a>. Result is not yet evaluated.
readMutVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutVar# d a -> State# d -> (# State# d, a #)

-- | Write contents of <a>MutVar#</a>.
writeMutVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutVar# d a -> a -> State# d -> State# d

-- | Atomically exchange the value of a <a>MutVar#</a>.
atomicSwapMutVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutVar# d a -> a -> State# d -> (# State# d, a #)

-- | Modify the contents of a <a>MutVar#</a>, returning the previous
--   contents <tt>x :: a</tt> and the result of applying the given function
--   to the previous contents <tt>f x :: c</tt>.
--   
--   The <tt>data</tt> type <tt>c</tt> (not a <tt>newtype</tt>!) must be a
--   record whose first field is of lifted type <tt>a :: Type</tt> and is
--   not unpacked. For example, product types <tt>c ~ Solo a</tt> or <tt>c
--   ~ (a, b)</tt> work well. If the record type is both monomorphic and
--   strict in its first field, it's recommended to mark the latter <tt>{-#
--   NOUNPACK #-}</tt> explicitly.
--   
--   Under the hood <a>atomicModifyMutVar2#</a> atomically replaces a
--   pointer to an old <tt>x :: a</tt> with a pointer to a selector thunk
--   <tt>fst r</tt>, where <tt>fst</tt> is a selector for the first field
--   of the record and <tt>r</tt> is a function application thunk <tt>r = f
--   x</tt>.
--   
--   <tt>atomicModifyIORef2Native</tt> from <tt>atomic-modify-general</tt>
--   package makes an effort to reflect restrictions on <tt>c</tt>
--   faithfully, providing a well-typed high-level wrapper.
atomicModifyMutVar2# :: MutVar# d a -> (a -> c) -> State# d -> (# State# d, a, c #)

-- | Modify the contents of a <a>MutVar#</a>, returning the previous
--   contents and the result of applying the given function to the previous
--   contents.
atomicModifyMutVar_# :: MutVar# d a -> (a -> a) -> State# d -> (# State# d, a, a #)

-- | Compare-and-swap: perform a pointer equality test between the first
--   value passed to this function and the value stored inside the
--   <a>MutVar#</a>. If the pointers are equal, replace the stored value
--   with the second value passed to this function, otherwise do nothing.
--   Returns the final value stored inside the <a>MutVar#</a>. The
--   <a>Int#</a> indicates whether a swap took place, with <tt>1#</tt>
--   meaning that we didn't swap, and <tt>0#</tt> that we did. Implies a
--   full memory barrier. Because the comparison is done on the level of
--   pointers, all of the difficulties of using
--   <a>reallyUnsafePtrEquality#</a> correctly apply to <a>casMutVar#</a>
--   as well.
casMutVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutVar# d a -> a -> a -> State# d -> (# State# d, Int#, a #)

-- | <tt><a>catch#</a> k handler s</tt> evaluates <tt>k s</tt>, invoking
--   <tt>handler</tt> on any exceptions thrown.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
catch# :: forall {q :: RuntimeRep} {k :: Levity} (a :: TYPE q) (b :: TYPE ('BoxedRep k)). (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
raise# :: forall {l :: Levity} {r :: RuntimeRep} (a :: TYPE ('BoxedRep l)) (b :: TYPE r). a -> b
raiseUnderflow# :: forall {r :: RuntimeRep} (b :: TYPE r). (# #) -> b
raiseOverflow# :: forall {r :: RuntimeRep} (b :: TYPE r). (# #) -> b
raiseDivZero# :: forall {r :: RuntimeRep} (b :: TYPE r). (# #) -> b
raiseIO# :: forall {l :: Levity} {r :: RuntimeRep} (a :: TYPE ('BoxedRep l)) (b :: TYPE r). a -> State# RealWorld -> (# State# RealWorld, b #)

-- | <tt><a>maskAsyncExceptions#</a> k s</tt> evaluates <tt>k s</tt> such
--   that asynchronous exceptions are deferred until after evaluation has
--   finished.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
maskAsyncExceptions# :: forall {q :: RuntimeRep} (a :: TYPE q). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)

-- | <tt><a>maskUninterruptible#</a> k s</tt> evaluates <tt>k s</tt> such
--   that asynchronous exceptions are deferred until after evaluation has
--   finished.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
maskUninterruptible# :: forall {q :: RuntimeRep} (a :: TYPE q). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)

-- | <tt><tt>unmaskAsyncUninterruptible#</tt> k s</tt> evaluates <tt>k
--   s</tt> such that asynchronous exceptions are unmasked.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
unmaskAsyncExceptions# :: forall {q :: RuntimeRep} (a :: TYPE q). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
getMaskingState# :: State# RealWorld -> (# State# RealWorld, Int# #)

-- | See <a>GHC.Prim#continuations</a>.
data PromptTag# a :: UnliftedType

-- | See <a>GHC.Prim#continuations</a>.
newPromptTag# :: State# RealWorld -> (# State# RealWorld, PromptTag# a #)

-- | See <a>GHC.Prim#continuations</a>.
prompt# :: PromptTag# a -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)

-- | See <a>GHC.Prim#continuations</a>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
control0# :: forall {r :: RuntimeRep} a (b :: TYPE r). PromptTag# a -> (((State# RealWorld -> (# State# RealWorld, b #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, b #)
data TVar# a (b :: TYPE 'BoxedRep l) :: UnliftedType
atomically# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
retry# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). State# RealWorld -> (# State# RealWorld, a #)
catchRetry# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). (State# RealWorld -> (# State# RealWorld, a #)) -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
catchSTM# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) b. (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)

-- | Create a new <a>TVar#</a> holding a specified initial value.
newTVar# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. a -> State# d -> (# State# d, TVar# d a #)

-- | Read contents of <a>TVar#</a> inside an STM transaction, i.e. within a
--   call to <a>atomically#</a>. Does not force evaluation of the result.
readTVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). TVar# d a -> State# d -> (# State# d, a #)

-- | Read contents of <a>TVar#</a> outside an STM transaction. Does not
--   force evaluation of the result.
readTVarIO# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). TVar# d a -> State# d -> (# State# d, a #)

-- | Write contents of <a>TVar#</a>.
writeTVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). TVar# d a -> a -> State# d -> State# d

-- | A shared mutable variable (<i>not</i> the same as a <a>MutVar#</a>!).
--   (Note: in a non-concurrent implementation, <tt>(<a>MVar#</a> a)</tt>
--   can be represented by <tt>(<a>MutVar#</a> (Maybe a))</tt>.)
data MVar# a (b :: TYPE 'BoxedRep l) :: UnliftedType

-- | Create new <a>MVar#</a>; initially empty.
newMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). State# d -> (# State# d, MVar# d a #)

-- | If <a>MVar#</a> is empty, block until it becomes full. Then remove and
--   return its contents, and set it empty.
takeMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> State# d -> (# State# d, a #)

-- | If <a>MVar#</a> is empty, immediately return with integer 0 and value
--   undefined. Otherwise, return with integer 1 and contents of
--   <a>MVar#</a>, and set <a>MVar#</a> empty.
tryTakeMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> State# d -> (# State# d, Int#, a #)

-- | If <a>MVar#</a> is full, block until it becomes empty. Then store
--   value arg as its new contents.
putMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> a -> State# d -> State# d

-- | If <a>MVar#</a> is full, immediately return with integer 0. Otherwise,
--   store value arg as 'MVar#''s new contents, and return with integer 1.
tryPutMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> a -> State# d -> (# State# d, Int# #)

-- | If <a>MVar#</a> is empty, block until it becomes full. Then read its
--   contents without modifying the MVar, without possibility of
--   intervention from other threads.
readMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> State# d -> (# State# d, a #)

-- | If <a>MVar#</a> is empty, immediately return with integer 0 and value
--   undefined. Otherwise, return with integer 1 and contents of
--   <a>MVar#</a>.
tryReadMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> State# d -> (# State# d, Int#, a #)

-- | Return 1 if <a>MVar#</a> is empty; 0 otherwise.
isEmptyMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> State# d -> (# State# d, Int# #)

-- | A shared I/O port is almost the same as an <a>MVar#</a>. The main
--   difference is that IOPort has no deadlock detection or deadlock
--   breaking code that forcibly releases the lock.
data IOPort# a (b :: TYPE 'BoxedRep l) :: UnliftedType

-- | Create new <a>IOPort#</a>; initially empty.
newIOPort# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). State# d -> (# State# d, IOPort# d a #)

-- | If <a>IOPort#</a> is empty, block until it becomes full. Then remove
--   and return its contents, and set it empty. Throws an
--   <tt>IOPortException</tt> if another thread is already waiting to read
--   this <a>IOPort#</a>.
readIOPort# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). IOPort# d a -> State# d -> (# State# d, a #)

-- | If <a>IOPort#</a> is full, immediately return with integer 0, throwing
--   an <tt>IOPortException</tt>. Otherwise, store value arg as 'IOPort#''s
--   new contents, and return with integer 1.
writeIOPort# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). IOPort# d a -> a -> State# d -> (# State# d, Int# #)

-- | Sleep specified number of microseconds.
delay# :: Int# -> State# d -> State# d

-- | Block until input is available on specified file descriptor.
waitRead# :: Int# -> State# d -> State# d

-- | Block until output is possible on specified file descriptor.
waitWrite# :: Int# -> State# d -> State# d

-- | <a>State#</a> is the primitive, unlifted type of states. It has one
--   type parameter, thus <tt><a>State#</a> <a>RealWorld</a></tt>, or
--   <tt><a>State#</a> s</tt>, where s is a type variable. The only purpose
--   of the type parameter is to keep different state threads separate. It
--   is represented by nothing at all.
data State# a :: ZeroBitType

-- | <a>RealWorld</a> is deeply magical. It is <i>primitive</i>, but it is
--   not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <a>RealWorld</a>; it's only used in the type system, to
--   parameterise <a>State#</a>.
data RealWorld

-- | (In a non-concurrent implementation, this can be a singleton type,
--   whose (unique) value is returned by <a>myThreadId#</a>. The other
--   operations can be omitted.)
data ThreadId# :: UnliftedType
fork# :: forall {q :: RuntimeRep} (a :: TYPE q). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
forkOn# :: forall {q :: RuntimeRep} (a :: TYPE q). Int# -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
killThread# :: ThreadId# -> a -> State# RealWorld -> State# RealWorld
yield# :: State# RealWorld -> State# RealWorld
myThreadId# :: State# RealWorld -> (# State# RealWorld, ThreadId# #)

-- | Set the label of the given thread. The <tt>ByteArray#</tt> should
--   contain a UTF-8-encoded string.
labelThread# :: ThreadId# -> ByteArray# -> State# RealWorld -> State# RealWorld
isCurrentThreadBound# :: State# RealWorld -> (# State# RealWorld, Int# #)
noDuplicate# :: State# d -> State# d

-- | Get the label of the given thread. Morally of type <tt>ThreadId# -&gt;
--   IO (Maybe ByteArray#)</tt>, with a <tt>1#</tt> tag denoting
--   <tt>Just</tt>.
threadLabel# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, ByteArray# #)

-- | Get the status of the given thread. Result is <tt>(ThreadStatus,
--   Capability, Locked)</tt> where <tt>ThreadStatus</tt> is one of the
--   status constants defined in <tt>rts/Constants.h</tt>,
--   <tt>Capability</tt> is the number of the capability which currently
--   owns the thread, and <tt>Locked</tt> is a boolean indicating whether
--   the thread is bound to that capability.
threadStatus# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, Int#, Int# #)

-- | Returns an array of the threads started by the program. Note that this
--   threads which have finished execution may or may not be present in
--   this list, depending upon whether they have been collected by the
--   garbage collector.
listThreads# :: State# RealWorld -> (# State# RealWorld, Array# ThreadId# #)
data Weak# (a :: TYPE 'BoxedRep l) :: UnliftedType

-- | <tt><a>mkWeak#</a> k v finalizer s</tt> creates a weak reference to
--   value <tt>k</tt>, with an associated reference to some value
--   <tt>v</tt>. If <tt>k</tt> is still alive then <tt>v</tt> can be
--   retrieved using <a>deRefWeak#</a>. Note that the type of <tt>k</tt>
--   must be represented by a pointer (i.e. of kind <tt><tt>TYPE</tt>
--   '<tt>LiftedRep</tt> or </tt><tt>TYPE</tt> '<tt>UnliftedRep</tt>@).
mkWeak# :: forall {l :: Levity} {k :: Levity} (a :: TYPE ('BoxedRep l)) (b :: TYPE ('BoxedRep k)) c. a -> b -> (State# RealWorld -> (# State# RealWorld, c #)) -> State# RealWorld -> (# State# RealWorld, Weak# b #)
mkWeakNoFinalizer# :: forall {l :: Levity} {k :: Levity} (a :: TYPE ('BoxedRep l)) (b :: TYPE ('BoxedRep k)). a -> b -> State# RealWorld -> (# State# RealWorld, Weak# b #)

-- | <tt><a>addCFinalizerToWeak#</a> fptr ptr flag eptr w</tt> attaches a C
--   function pointer <tt>fptr</tt> to a weak pointer <tt>w</tt> as a
--   finalizer. If <tt>flag</tt> is zero, <tt>fptr</tt> will be called with
--   one argument, <tt>ptr</tt>. Otherwise, it will be called with two
--   arguments, <tt>eptr</tt> and <tt>ptr</tt>. <a>addCFinalizerToWeak#</a>
--   returns 1 on success, or 0 if <tt>w</tt> is already dead.
addCFinalizerToWeak# :: forall {k :: Levity} (b :: TYPE ('BoxedRep k)). Addr# -> Addr# -> Int# -> Addr# -> Weak# b -> State# RealWorld -> (# State# RealWorld, Int# #)
deRefWeak# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, a #)

-- | Finalize a weak pointer. The return value is an unboxed tuple
--   containing the new state of the world and an "unboxed Maybe",
--   represented by an <a>Int#</a> and a (possibly invalid) finalization
--   action. An <a>Int#</a> of <tt>1</tt> indicates that the finalizer is
--   valid. The return value <tt>b</tt> from the finalizer should be
--   ignored.
finalizeWeak# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) b. Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, State# RealWorld -> (# State# RealWorld, b #) #)
touch# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. a -> State# d -> State# d
data StablePtr# (a :: TYPE 'BoxedRep l) :: TYPE 'AddrRep
data StableName# (a :: TYPE 'BoxedRep l) :: UnliftedType
makeStablePtr# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). a -> State# RealWorld -> (# State# RealWorld, StablePtr# a #)
deRefStablePtr# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). StablePtr# a -> State# RealWorld -> (# State# RealWorld, a #)
eqStablePtr# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). StablePtr# a -> StablePtr# a -> Int#
makeStableName# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). a -> State# RealWorld -> (# State# RealWorld, StableName# a #)
stableNameToInt# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). StableName# a -> Int#
data Compact# :: UnliftedType

-- | Create a new CNF with a single compact block. The argument is the
--   capacity of the compact block (in bytes, not words). The capacity is
--   rounded up to a multiple of the allocator block size and is capped to
--   one mega block.
compactNew# :: Word# -> State# RealWorld -> (# State# RealWorld, Compact# #)

-- | Set the new allocation size of the CNF. This value (in bytes)
--   determines the capacity of each compact block in the CNF. It does not
--   retroactively affect existing compact blocks in the CNF.
compactResize# :: Compact# -> Word# -> State# RealWorld -> State# RealWorld

-- | Returns 1# if the object is contained in the CNF, 0# otherwise.
compactContains# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, Int# #)

-- | Returns 1# if the object is in any CNF at all, 0# otherwise.
compactContainsAny# :: a -> State# RealWorld -> (# State# RealWorld, Int# #)

-- | Returns the address and the utilized size (in bytes) of the first
--   compact block of a CNF.
compactGetFirstBlock# :: Compact# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)

-- | Given a CNF and the address of one its compact blocks, returns the
--   next compact block and its utilized size, or <a>nullAddr#</a> if the
--   argument was the last compact block in the CNF.
compactGetNextBlock# :: Compact# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)

-- | Attempt to allocate a compact block with the capacity (in bytes) given
--   by the first argument. The <a>Addr#</a> is a pointer to previous
--   compact block of the CNF or <a>nullAddr#</a> to create a new CNF with
--   a single compact block.
--   
--   The resulting block is not known to the GC until
--   <a>compactFixupPointers#</a> is called on it, and care must be taken
--   so that the address does not escape or memory will be leaked.
compactAllocateBlock# :: Word# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr# #)

-- | Given the pointer to the first block of a CNF and the address of the
--   root object in the old address space, fix up the internal pointers
--   inside the CNF to account for a different position in memory than when
--   it was serialized. This method must be called exactly once after
--   importing a serialized CNF. It returns the new CNF and the new
--   adjusted root address.
compactFixupPointers# :: Addr# -> Addr# -> State# RealWorld -> (# State# RealWorld, Compact#, Addr# #)

-- | Recursively add a closure and its transitive closure to a
--   <a>Compact#</a> (a CNF), evaluating any unevaluated components at the
--   same time. Note: <a>compactAdd#</a> is not thread-safe, so only one
--   thread may call <a>compactAdd#</a> with a particular <a>Compact#</a>
--   at any given time. The primop does not enforce any mutual exclusion;
--   the caller is expected to arrange this.
compactAdd# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)

-- | Like <a>compactAdd#</a>, but retains sharing and cycles during
--   compaction.
compactAddWithSharing# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)

-- | Return the total capacity (in bytes) of all the compact blocks in the
--   CNF.
compactSize# :: Compact# -> State# RealWorld -> (# State# RealWorld, Word# #)

-- | Returns <tt>1#</tt> if the given pointers are equal and <tt>0#</tt>
--   otherwise.
reallyUnsafePtrEquality# :: forall {l :: Levity} {k :: Levity} (a :: TYPE ('BoxedRep l)) (b :: TYPE ('BoxedRep k)). a -> b -> Int#

-- | Create a new spark evaluating the given argument. The return value
--   should always be 1. Users are encouraged to use spark# instead.
par# :: a -> Int#
spark# :: a -> State# d -> (# State# d, a #)
getSpark# :: State# d -> (# State# d, Int#, a #)

-- | Returns the number of sparks in the local spark pool.
numSparks# :: State# d -> (# State# d, Int# #)

-- | <tt><a>keepAlive#</a> x s k</tt> keeps the value <tt>x</tt> alive
--   during the execution of the computation <tt>k</tt>.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
keepAlive# :: forall {l :: Levity} {r :: RuntimeRep} (a :: TYPE ('BoxedRep l)) d (b :: TYPE r). a -> State# d -> (State# d -> b) -> b

-- | Used internally to implement <tt>dataToTag#</tt>: Use that function
--   instead! This one normally offers <i>no advantage</i> and comes with
--   no stability guarantees: it may change its type, its name, or its
--   behavior with <i>no warning</i> between compiler releases.
--   
--   It is expected that this function will be un-exposed in a future
--   release of ghc.
--   
--   For more details, look at <tt>Note [DataToTag overview]</tt> in
--   GHC.Tc.Instance.Class in the source code for <i>the specific compiler
--   version you are using.</i>

-- | <i>Deprecated: Use dataToTag# from <a>GHC.Magic</a> instead. </i>
dataToTagSmall# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). a -> Int#

-- | Used internally to implement <tt>dataToTag#</tt>: Use that function
--   instead! This one offers <i>no advantage</i> and comes with no
--   stability guarantees: it may change its type, its name, or its
--   behavior with <i>no warning</i> between compiler releases.
--   
--   It is expected that this function will be un-exposed in a future
--   release of ghc.
--   
--   For more details, look at <tt>Note [DataToTag overview]</tt> in
--   GHC.Tc.Instance.Class in the source code for <i>the specific compiler
--   version you are using.</i>

-- | <i>Deprecated: Use dataToTag# from <a>GHC.Magic</a> instead. </i>
dataToTagLarge# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). a -> Int#
tagToEnum# :: Int# -> a

-- | Primitive bytecode type.
data BCO

-- | Convert an <a>Addr#</a> to a followable Any type.
addrToAny# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Addr# -> (# a #)

-- | Retrieve the address of any Haskell value. This is essentially an
--   <tt>unsafeCoerce#</tt>, but if implemented as such the core lint pass
--   complains and fails to compile. As a primop, it is opaque to core/stg,
--   and only appears in cmm (where the copy propagation pass will get rid
--   of it). Note that "a" must be a value, not a thunk! It's too late for
--   strictness analysis to enforce this, so you're on your own to
--   guarantee this. Also note that <a>Addr#</a> is not a GC pointer - up
--   to you to guarantee that it does not become a dangling pointer
--   immediately after you get it.
anyToAddr# :: a -> State# RealWorld -> (# State# RealWorld, Addr# #)

-- | Wrap a BCO in a <tt>AP_UPD</tt> thunk which will be updated with the
--   value of the BCO when evaluated.
mkApUpd0# :: BCO -> (# a #)

-- | <tt><a>newBCO#</a> instrs lits ptrs arity bitmap</tt> creates a new
--   bytecode object. The resulting object encodes a function of the given
--   arity with the instructions encoded in <tt>instrs</tt>, and a static
--   reference table usage bitmap given by <tt>bitmap</tt>.
newBCO# :: ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# d -> (# State# d, BCO #)

-- | <tt><a>unpackClosure#</a> closure</tt> copies the closure and pointers
--   in the payload of the given closure into two new arrays, and returns a
--   pointer to the first word of the closure's info table, a non-pointer
--   array for the raw bytes of the closure, and a pointer array for the
--   pointers in the payload.
unpackClosure# :: a -> (# Addr#, ByteArray#, Array# b #)

-- | <tt><a>closureSize#</a> closure</tt> returns the size of the given
--   closure in machine words.
closureSize# :: a -> Int#
getApStackVal# :: a -> Int# -> (# Int#, b #)
getCCSOf# :: a -> State# d -> (# State# d, Addr# #)

-- | Returns the current <tt>CostCentreStack</tt> (value is <tt>NULL</tt>
--   if not profiling). Takes a dummy argument which can be used to avoid
--   the call to <a>getCurrentCCS#</a> being floated out by the simplifier,
--   which would result in an uninformative stack (<a>CAF</a>).
getCurrentCCS# :: a -> State# d -> (# State# d, Addr# #)

-- | Run the supplied IO action with an empty CCS. For example, this is
--   used by the interpreter to run an interpreted computation without the
--   call stack showing that it was invoked from GHC.
clearCCS# :: (State# d -> (# State# d, a #)) -> State# d -> (# State# d, a #)

-- | Fills the given buffer with the <tt>InfoProvEnt</tt> for the info
--   table of the given object. Returns <tt>1#</tt> on success and
--   <tt>0#</tt> otherwise.
whereFrom# :: a -> Addr# -> State# d -> (# State# d, Int# #)

-- | The builtin function type, written in infix form as <tt>a % m -&gt;
--   b</tt>. Values of this type are functions taking inputs of type
--   <tt>a</tt> and producing outputs of type <tt>b</tt>. The multiplicity
--   of the input is <tt>m</tt>.
--   
--   Note that <tt><a>FUN</a> m a b</tt> permits representation
--   polymorphism in both <tt>a</tt> and <tt>b</tt>, so that types like
--   <tt><a>Int#</a> -&gt; <a>Int#</a></tt> can still be well-kinded.
data FUN

-- | The token used in the implementation of the IO monad as a state monad.
--   It does not pass any information at runtime. See also <a>runRW#</a>.
realWorld# :: State# RealWorld

-- | This is an alias for the unboxed unit tuple constructor. In earlier
--   versions of GHC, <a>void#</a> was a value of the primitive type
--   <tt>Void#</tt>, which is now defined to be <tt>(# #)</tt>.

-- | <i>Deprecated: Use an unboxed unit tuple instead </i>
void# :: (# #)

-- | The type constructor <a>Proxy#</a> is used to bear witness to some
--   type variable. It's used when you want to pass around proxy values for
--   doing things like modelling type applications. A <a>Proxy#</a> is not
--   only unboxed, it also has a polymorphic kind, and has no runtime
--   representation, being totally free.
data Proxy# (a :: k) :: ZeroBitType

-- | Witness for an unboxed <a>Proxy#</a> value, which has no runtime
--   representation.
proxy# :: forall {k} (a :: k). Proxy# a

-- | The value of <tt><a>seq</a> a b</tt> is bottom if <tt>a</tt> is
--   bottom, and otherwise equal to <tt>b</tt>. In other words, it
--   evaluates the first argument <tt>a</tt> to weak head normal form
--   (WHNF). <a>seq</a> is usually introduced to improve performance by
--   avoiding unneeded laziness.
--   
--   A note on evaluation order: the expression <tt><a>seq</a> a b</tt>
--   does <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <a>seq</a> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <a>seq</a> returns
--   a value. In particular, this means that <tt>b</tt> may be evaluated
--   before <tt>a</tt>. If you need to guarantee a specific order of
--   evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: forall {r :: RuntimeRep} a (b :: TYPE r). a -> b -> b
infixr 0 `seq`

-- | Emits an event via the RTS tracing framework. The contents of the
--   event is the zero-terminated byte string passed as the first argument.
--   The event will be emitted either to the <tt>.eventlog</tt> file, or to
--   stderr, depending on the runtime RTS flags.
traceEvent# :: Addr# -> State# d -> State# d

-- | Emits an event via the RTS tracing framework. The contents of the
--   event is the binary object passed as the first argument with the given
--   length passed as the second argument. The event will be emitted to the
--   <tt>.eventlog</tt> file.
traceBinaryEvent# :: Addr# -> Int# -> State# d -> State# d

-- | Emits a marker event via the RTS tracing framework. The contents of
--   the event is the zero-terminated byte string passed as the first
--   argument. The event will be emitted either to the <tt>.eventlog</tt>
--   file, or to stderr, depending on the runtime RTS flags.
traceMarker# :: Addr# -> State# d -> State# d

-- | Sets the allocation counter for the current thread to the given value.
setThreadAllocationCounter# :: Int64# -> State# RealWorld -> State# RealWorld

-- | Haskell representation of a <tt>StgStack*</tt> that was created
--   (cloned) with a function in <a>GHC.Stack.CloneStack</a>. Please check
--   the documentation in that module for more detailed explanations.
data StackSnapshot# :: UnliftedType

-- | The function <a>coerce</a> allows you to safely convert between values
--   of types that have the same representation with no run-time overhead.
--   In the simplest case you can use it instead of a newtype constructor,
--   to go from the newtype's concrete type to the abstract type. But it
--   also works in more complicated settings, e.g. converting a list of
--   newtypes to a list of concrete types.
--   
--   When used in conversions involving a newtype wrapper, make sure the
--   newtype constructor is in scope.
--   
--   This function is representation-polymorphic, but the
--   <tt>RuntimeRep</tt> type argument is marked as <tt>Inferred</tt>,
--   meaning that it is not available for visible type application. This
--   means the typechecker will accept <tt><a>coerce</a> @<tt>Int</tt> @Age
--   42</tt>.
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; newtype TTL = TTL Int deriving (Eq, Ord, Show)
--   
--   &gt;&gt;&gt; newtype Age = Age Int deriving (Eq, Ord, Show)
--   
--   &gt;&gt;&gt; coerce (Age 42) :: TTL
--   TTL 42
--   
--   &gt;&gt;&gt; coerce (+ (1 :: Int)) (Age 42) :: TTL
--   TTL 43
--   
--   &gt;&gt;&gt; coerce (map (+ (1 :: Int))) [Age 42, Age 24] :: [TTL]
--   [TTL 43,TTL 25]
--   </pre>
coerce :: forall {k :: RuntimeRep} (a :: TYPE k) (b :: TYPE k). Coercible a b => a -> b
data Int8X16# :: TYPE 'VecRep 'Vec16 'Int8ElemRep
data Int16X8# :: TYPE 'VecRep 'Vec8 'Int16ElemRep
data Int32X4# :: TYPE 'VecRep 'Vec4 'Int32ElemRep
data Int64X2# :: TYPE 'VecRep 'Vec2 'Int64ElemRep
data Int8X32# :: TYPE 'VecRep 'Vec32 'Int8ElemRep
data Int16X16# :: TYPE 'VecRep 'Vec16 'Int16ElemRep
data Int32X8# :: TYPE 'VecRep 'Vec8 'Int32ElemRep
data Int64X4# :: TYPE 'VecRep 'Vec4 'Int64ElemRep
data Int8X64# :: TYPE 'VecRep 'Vec64 'Int8ElemRep
data Int16X32# :: TYPE 'VecRep 'Vec32 'Int16ElemRep
data Int32X16# :: TYPE 'VecRep 'Vec16 'Int32ElemRep
data Int64X8# :: TYPE 'VecRep 'Vec8 'Int64ElemRep
data Word8X16# :: TYPE 'VecRep 'Vec16 'Word8ElemRep
data Word16X8# :: TYPE 'VecRep 'Vec8 'Word16ElemRep
data Word32X4# :: TYPE 'VecRep 'Vec4 'Word32ElemRep
data Word64X2# :: TYPE 'VecRep 'Vec2 'Word64ElemRep
data Word8X32# :: TYPE 'VecRep 'Vec32 'Word8ElemRep
data Word16X16# :: TYPE 'VecRep 'Vec16 'Word16ElemRep
data Word32X8# :: TYPE 'VecRep 'Vec8 'Word32ElemRep
data Word64X4# :: TYPE 'VecRep 'Vec4 'Word64ElemRep
data Word8X64# :: TYPE 'VecRep 'Vec64 'Word8ElemRep
data Word16X32# :: TYPE 'VecRep 'Vec32 'Word16ElemRep
data Word32X16# :: TYPE 'VecRep 'Vec16 'Word32ElemRep
data Word64X8# :: TYPE 'VecRep 'Vec8 'Word64ElemRep
data FloatX4# :: TYPE 'VecRep 'Vec4 'FloatElemRep
data DoubleX2# :: TYPE 'VecRep 'Vec2 'DoubleElemRep
data FloatX8# :: TYPE 'VecRep 'Vec8 'FloatElemRep
data DoubleX4# :: TYPE 'VecRep 'Vec4 'DoubleElemRep
data FloatX16# :: TYPE 'VecRep 'Vec16 'FloatElemRep
data DoubleX8# :: TYPE 'VecRep 'Vec8 'DoubleElemRep

-- | Broadcast a scalar to all elements of a vector.
broadcastInt8X16# :: Int8# -> Int8X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt16X8# :: Int16# -> Int16X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt32X4# :: Int32# -> Int32X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt64X2# :: Int64# -> Int64X2#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt8X32# :: Int8# -> Int8X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt16X16# :: Int16# -> Int16X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt32X8# :: Int32# -> Int32X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt64X4# :: Int64# -> Int64X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt8X64# :: Int8# -> Int8X64#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt16X32# :: Int16# -> Int16X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt32X16# :: Int32# -> Int32X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt64X8# :: Int64# -> Int64X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord8X16# :: Word8# -> Word8X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord16X8# :: Word16# -> Word16X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord32X4# :: Word32# -> Word32X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord64X2# :: Word64# -> Word64X2#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord8X32# :: Word8# -> Word8X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord16X16# :: Word16# -> Word16X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord32X8# :: Word32# -> Word32X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord64X4# :: Word64# -> Word64X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord8X64# :: Word8# -> Word8X64#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord16X32# :: Word16# -> Word16X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord32X16# :: Word32# -> Word32X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord64X8# :: Word64# -> Word64X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastFloatX4# :: Float# -> FloatX4#

-- | Broadcast a scalar to all elements of a vector.
broadcastDoubleX2# :: Double# -> DoubleX2#

-- | Broadcast a scalar to all elements of a vector.
broadcastFloatX8# :: Float# -> FloatX8#

-- | Broadcast a scalar to all elements of a vector.
broadcastDoubleX4# :: Double# -> DoubleX4#

-- | Broadcast a scalar to all elements of a vector.
broadcastFloatX16# :: Float# -> FloatX16#

-- | Broadcast a scalar to all elements of a vector.
broadcastDoubleX8# :: Double# -> DoubleX8#

-- | Pack the elements of an unboxed tuple into a vector.
packInt8X16# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X16#

-- | Pack the elements of an unboxed tuple into a vector.
packInt16X8# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X8#

-- | Pack the elements of an unboxed tuple into a vector.
packInt32X4# :: (# Int32#, Int32#, Int32#, Int32# #) -> Int32X4#

-- | Pack the elements of an unboxed tuple into a vector.
packInt64X2# :: (# Int64#, Int64# #) -> Int64X2#

-- | Pack the elements of an unboxed tuple into a vector.
packInt8X32# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X32#

-- | Pack the elements of an unboxed tuple into a vector.
packInt16X16# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X16#

-- | Pack the elements of an unboxed tuple into a vector.
packInt32X8# :: (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #) -> Int32X8#

-- | Pack the elements of an unboxed tuple into a vector.
packInt64X4# :: (# Int64#, Int64#, Int64#, Int64# #) -> Int64X4#

-- | Pack the elements of an unboxed tuple into a vector.
packInt8X64# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X64#

-- | Pack the elements of an unboxed tuple into a vector.
packInt16X32# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X32#

-- | Pack the elements of an unboxed tuple into a vector.
packInt32X16# :: (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #) -> Int32X16#

-- | Pack the elements of an unboxed tuple into a vector.
packInt64X8# :: (# Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64# #) -> Int64X8#

-- | Pack the elements of an unboxed tuple into a vector.
packWord8X16# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X16#

-- | Pack the elements of an unboxed tuple into a vector.
packWord16X8# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X8#

-- | Pack the elements of an unboxed tuple into a vector.
packWord32X4# :: (# Word32#, Word32#, Word32#, Word32# #) -> Word32X4#

-- | Pack the elements of an unboxed tuple into a vector.
packWord64X2# :: (# Word64#, Word64# #) -> Word64X2#

-- | Pack the elements of an unboxed tuple into a vector.
packWord8X32# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X32#

-- | Pack the elements of an unboxed tuple into a vector.
packWord16X16# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X16#

-- | Pack the elements of an unboxed tuple into a vector.
packWord32X8# :: (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #) -> Word32X8#

-- | Pack the elements of an unboxed tuple into a vector.
packWord64X4# :: (# Word64#, Word64#, Word64#, Word64# #) -> Word64X4#

-- | Pack the elements of an unboxed tuple into a vector.
packWord8X64# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X64#

-- | Pack the elements of an unboxed tuple into a vector.
packWord16X32# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X32#

-- | Pack the elements of an unboxed tuple into a vector.
packWord32X16# :: (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #) -> Word32X16#

-- | Pack the elements of an unboxed tuple into a vector.
packWord64X8# :: (# Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64# #) -> Word64X8#

-- | Pack the elements of an unboxed tuple into a vector.
packFloatX4# :: (# Float#, Float#, Float#, Float# #) -> FloatX4#

-- | Pack the elements of an unboxed tuple into a vector.
packDoubleX2# :: (# Double#, Double# #) -> DoubleX2#

-- | Pack the elements of an unboxed tuple into a vector.
packFloatX8# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX8#

-- | Pack the elements of an unboxed tuple into a vector.
packDoubleX4# :: (# Double#, Double#, Double#, Double# #) -> DoubleX4#

-- | Pack the elements of an unboxed tuple into a vector.
packFloatX16# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX16#

-- | Pack the elements of an unboxed tuple into a vector.
packDoubleX8# :: (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #) -> DoubleX8#

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt8X16# :: Int8X16# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt16X8# :: Int16X8# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt32X4# :: Int32X4# -> (# Int32#, Int32#, Int32#, Int32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt64X2# :: Int64X2# -> (# Int64#, Int64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt8X32# :: Int8X32# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt16X16# :: Int16X16# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt32X8# :: Int32X8# -> (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt64X4# :: Int64X4# -> (# Int64#, Int64#, Int64#, Int64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt8X64# :: Int8X64# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt16X32# :: Int16X32# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt32X16# :: Int32X16# -> (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt64X8# :: Int64X8# -> (# Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord8X16# :: Word8X16# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord16X8# :: Word16X8# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord32X4# :: Word32X4# -> (# Word32#, Word32#, Word32#, Word32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord64X2# :: Word64X2# -> (# Word64#, Word64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord8X32# :: Word8X32# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord16X16# :: Word16X16# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord32X8# :: Word32X8# -> (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord64X4# :: Word64X4# -> (# Word64#, Word64#, Word64#, Word64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord8X64# :: Word8X64# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord16X32# :: Word16X32# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord32X16# :: Word32X16# -> (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord64X8# :: Word64X8# -> (# Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackFloatX4# :: FloatX4# -> (# Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackDoubleX2# :: DoubleX2# -> (# Double#, Double# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackFloatX8# :: FloatX8# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackDoubleX4# :: DoubleX4# -> (# Double#, Double#, Double#, Double# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackFloatX16# :: FloatX16# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackDoubleX8# :: DoubleX8# -> (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #)

-- | Insert a scalar at the given position in a vector.
insertInt8X16# :: Int8X16# -> Int8# -> Int# -> Int8X16#

-- | Insert a scalar at the given position in a vector.
insertInt16X8# :: Int16X8# -> Int16# -> Int# -> Int16X8#

-- | Insert a scalar at the given position in a vector.
insertInt32X4# :: Int32X4# -> Int32# -> Int# -> Int32X4#

-- | Insert a scalar at the given position in a vector.
insertInt64X2# :: Int64X2# -> Int64# -> Int# -> Int64X2#

-- | Insert a scalar at the given position in a vector.
insertInt8X32# :: Int8X32# -> Int8# -> Int# -> Int8X32#

-- | Insert a scalar at the given position in a vector.
insertInt16X16# :: Int16X16# -> Int16# -> Int# -> Int16X16#

-- | Insert a scalar at the given position in a vector.
insertInt32X8# :: Int32X8# -> Int32# -> Int# -> Int32X8#

-- | Insert a scalar at the given position in a vector.
insertInt64X4# :: Int64X4# -> Int64# -> Int# -> Int64X4#

-- | Insert a scalar at the given position in a vector.
insertInt8X64# :: Int8X64# -> Int8# -> Int# -> Int8X64#

-- | Insert a scalar at the given position in a vector.
insertInt16X32# :: Int16X32# -> Int16# -> Int# -> Int16X32#

-- | Insert a scalar at the given position in a vector.
insertInt32X16# :: Int32X16# -> Int32# -> Int# -> Int32X16#

-- | Insert a scalar at the given position in a vector.
insertInt64X8# :: Int64X8# -> Int64# -> Int# -> Int64X8#

-- | Insert a scalar at the given position in a vector.
insertWord8X16# :: Word8X16# -> Word8# -> Int# -> Word8X16#

-- | Insert a scalar at the given position in a vector.
insertWord16X8# :: Word16X8# -> Word16# -> Int# -> Word16X8#

-- | Insert a scalar at the given position in a vector.
insertWord32X4# :: Word32X4# -> Word32# -> Int# -> Word32X4#

-- | Insert a scalar at the given position in a vector.
insertWord64X2# :: Word64X2# -> Word64# -> Int# -> Word64X2#

-- | Insert a scalar at the given position in a vector.
insertWord8X32# :: Word8X32# -> Word8# -> Int# -> Word8X32#

-- | Insert a scalar at the given position in a vector.
insertWord16X16# :: Word16X16# -> Word16# -> Int# -> Word16X16#

-- | Insert a scalar at the given position in a vector.
insertWord32X8# :: Word32X8# -> Word32# -> Int# -> Word32X8#

-- | Insert a scalar at the given position in a vector.
insertWord64X4# :: Word64X4# -> Word64# -> Int# -> Word64X4#

-- | Insert a scalar at the given position in a vector.
insertWord8X64# :: Word8X64# -> Word8# -> Int# -> Word8X64#

-- | Insert a scalar at the given position in a vector.
insertWord16X32# :: Word16X32# -> Word16# -> Int# -> Word16X32#

-- | Insert a scalar at the given position in a vector.
insertWord32X16# :: Word32X16# -> Word32# -> Int# -> Word32X16#

-- | Insert a scalar at the given position in a vector.
insertWord64X8# :: Word64X8# -> Word64# -> Int# -> Word64X8#

-- | Insert a scalar at the given position in a vector.
insertFloatX4# :: FloatX4# -> Float# -> Int# -> FloatX4#

-- | Insert a scalar at the given position in a vector.
insertDoubleX2# :: DoubleX2# -> Double# -> Int# -> DoubleX2#

-- | Insert a scalar at the given position in a vector.
insertFloatX8# :: FloatX8# -> Float# -> Int# -> FloatX8#

-- | Insert a scalar at the given position in a vector.
insertDoubleX4# :: DoubleX4# -> Double# -> Int# -> DoubleX4#

-- | Insert a scalar at the given position in a vector.
insertFloatX16# :: FloatX16# -> Float# -> Int# -> FloatX16#

-- | Insert a scalar at the given position in a vector.
insertDoubleX8# :: DoubleX8# -> Double# -> Int# -> DoubleX8#

-- | Add two vectors element-wise.
plusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Add two vectors element-wise.
plusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Add two vectors element-wise.
plusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Add two vectors element-wise.
plusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Add two vectors element-wise.
plusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Add two vectors element-wise.
plusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Add two vectors element-wise.
plusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Add two vectors element-wise.
plusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Add two vectors element-wise.
plusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Add two vectors element-wise.
plusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Add two vectors element-wise.
plusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Add two vectors element-wise.
plusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Add two vectors element-wise.
plusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Add two vectors element-wise.
plusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Add two vectors element-wise.
plusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Add two vectors element-wise.
plusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Add two vectors element-wise.
plusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Add two vectors element-wise.
plusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Add two vectors element-wise.
plusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Add two vectors element-wise.
plusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Add two vectors element-wise.
plusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Add two vectors element-wise.
plusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Add two vectors element-wise.
plusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Add two vectors element-wise.
plusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Add two vectors element-wise.
plusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Add two vectors element-wise.
plusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Add two vectors element-wise.
plusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Add two vectors element-wise.
plusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Add two vectors element-wise.
plusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Add two vectors element-wise.
plusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Subtract two vectors element-wise.
minusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Subtract two vectors element-wise.
minusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Subtract two vectors element-wise.
minusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Subtract two vectors element-wise.
minusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Subtract two vectors element-wise.
minusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Subtract two vectors element-wise.
minusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Subtract two vectors element-wise.
minusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Subtract two vectors element-wise.
minusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Subtract two vectors element-wise.
minusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Subtract two vectors element-wise.
minusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Subtract two vectors element-wise.
minusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Subtract two vectors element-wise.
minusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Subtract two vectors element-wise.
minusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Subtract two vectors element-wise.
minusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Subtract two vectors element-wise.
minusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Subtract two vectors element-wise.
minusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Subtract two vectors element-wise.
minusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Subtract two vectors element-wise.
minusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Subtract two vectors element-wise.
minusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Subtract two vectors element-wise.
minusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Subtract two vectors element-wise.
minusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Subtract two vectors element-wise.
minusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Subtract two vectors element-wise.
minusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Subtract two vectors element-wise.
minusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Subtract two vectors element-wise.
minusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Subtract two vectors element-wise.
minusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Subtract two vectors element-wise.
minusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Subtract two vectors element-wise.
minusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Subtract two vectors element-wise.
minusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Subtract two vectors element-wise.
minusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Multiply two vectors element-wise.
timesInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Multiply two vectors element-wise.
timesInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Multiply two vectors element-wise.
timesInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Multiply two vectors element-wise.
timesInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Multiply two vectors element-wise.
timesInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Multiply two vectors element-wise.
timesInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Multiply two vectors element-wise.
timesInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Multiply two vectors element-wise.
timesInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Multiply two vectors element-wise.
timesInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Multiply two vectors element-wise.
timesInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Multiply two vectors element-wise.
timesInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Multiply two vectors element-wise.
timesInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Multiply two vectors element-wise.
timesWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Multiply two vectors element-wise.
timesWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Multiply two vectors element-wise.
timesWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Multiply two vectors element-wise.
timesWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Multiply two vectors element-wise.
timesWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Multiply two vectors element-wise.
timesWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Multiply two vectors element-wise.
timesWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Multiply two vectors element-wise.
timesWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Multiply two vectors element-wise.
timesWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Multiply two vectors element-wise.
timesWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Multiply two vectors element-wise.
timesWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Multiply two vectors element-wise.
timesWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Multiply two vectors element-wise.
timesFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Multiply two vectors element-wise.
timesDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Multiply two vectors element-wise.
timesFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Multiply two vectors element-wise.
timesDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Multiply two vectors element-wise.
timesFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Multiply two vectors element-wise.
timesDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Divide two vectors element-wise.
divideFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Divide two vectors element-wise.
divideDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Divide two vectors element-wise.
divideFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Divide two vectors element-wise.
divideDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Divide two vectors element-wise.
divideFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Divide two vectors element-wise.
divideDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Rounds towards zero element-wise.
quotInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Rounds towards zero element-wise.
quotInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Rounds towards zero element-wise.
quotInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Rounds towards zero element-wise.
quotInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Rounds towards zero element-wise.
quotInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Rounds towards zero element-wise.
quotInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Rounds towards zero element-wise.
quotInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Rounds towards zero element-wise.
quotInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Rounds towards zero element-wise.
quotInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Rounds towards zero element-wise.
quotInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Rounds towards zero element-wise.
quotInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Rounds towards zero element-wise.
quotInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Rounds towards zero element-wise.
quotWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Rounds towards zero element-wise.
quotWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Rounds towards zero element-wise.
quotWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Rounds towards zero element-wise.
quotWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Rounds towards zero element-wise.
quotWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Rounds towards zero element-wise.
quotWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Rounds towards zero element-wise.
quotWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Rounds towards zero element-wise.
quotWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Rounds towards zero element-wise.
quotWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Rounds towards zero element-wise.
quotWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Rounds towards zero element-wise.
quotWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Rounds towards zero element-wise.
quotWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Negate element-wise.
negateInt8X16# :: Int8X16# -> Int8X16#

-- | Negate element-wise.
negateInt16X8# :: Int16X8# -> Int16X8#

-- | Negate element-wise.
negateInt32X4# :: Int32X4# -> Int32X4#

-- | Negate element-wise.
negateInt64X2# :: Int64X2# -> Int64X2#

-- | Negate element-wise.
negateInt8X32# :: Int8X32# -> Int8X32#

-- | Negate element-wise.
negateInt16X16# :: Int16X16# -> Int16X16#

-- | Negate element-wise.
negateInt32X8# :: Int32X8# -> Int32X8#

-- | Negate element-wise.
negateInt64X4# :: Int64X4# -> Int64X4#

-- | Negate element-wise.
negateInt8X64# :: Int8X64# -> Int8X64#

-- | Negate element-wise.
negateInt16X32# :: Int16X32# -> Int16X32#

-- | Negate element-wise.
negateInt32X16# :: Int32X16# -> Int32X16#

-- | Negate element-wise.
negateInt64X8# :: Int64X8# -> Int64X8#

-- | Negate element-wise.
negateFloatX4# :: FloatX4# -> FloatX4#

-- | Negate element-wise.
negateDoubleX2# :: DoubleX2# -> DoubleX2#

-- | Negate element-wise.
negateFloatX8# :: FloatX8# -> FloatX8#

-- | Negate element-wise.
negateDoubleX4# :: DoubleX4# -> DoubleX4#

-- | Negate element-wise.
negateFloatX16# :: FloatX16# -> FloatX16#

-- | Negate element-wise.
negateDoubleX8# :: DoubleX8# -> DoubleX8#

-- | Read a vector from specified index of immutable array.
indexInt8X16Array# :: ByteArray# -> Int# -> Int8X16#

-- | Read a vector from specified index of immutable array.
indexInt16X8Array# :: ByteArray# -> Int# -> Int16X8#

-- | Read a vector from specified index of immutable array.
indexInt32X4Array# :: ByteArray# -> Int# -> Int32X4#

-- | Read a vector from specified index of immutable array.
indexInt64X2Array# :: ByteArray# -> Int# -> Int64X2#

-- | Read a vector from specified index of immutable array.
indexInt8X32Array# :: ByteArray# -> Int# -> Int8X32#

-- | Read a vector from specified index of immutable array.
indexInt16X16Array# :: ByteArray# -> Int# -> Int16X16#

-- | Read a vector from specified index of immutable array.
indexInt32X8Array# :: ByteArray# -> Int# -> Int32X8#

-- | Read a vector from specified index of immutable array.
indexInt64X4Array# :: ByteArray# -> Int# -> Int64X4#

-- | Read a vector from specified index of immutable array.
indexInt8X64Array# :: ByteArray# -> Int# -> Int8X64#

-- | Read a vector from specified index of immutable array.
indexInt16X32Array# :: ByteArray# -> Int# -> Int16X32#

-- | Read a vector from specified index of immutable array.
indexInt32X16Array# :: ByteArray# -> Int# -> Int32X16#

-- | Read a vector from specified index of immutable array.
indexInt64X8Array# :: ByteArray# -> Int# -> Int64X8#

-- | Read a vector from specified index of immutable array.
indexWord8X16Array# :: ByteArray# -> Int# -> Word8X16#

-- | Read a vector from specified index of immutable array.
indexWord16X8Array# :: ByteArray# -> Int# -> Word16X8#

-- | Read a vector from specified index of immutable array.
indexWord32X4Array# :: ByteArray# -> Int# -> Word32X4#

-- | Read a vector from specified index of immutable array.
indexWord64X2Array# :: ByteArray# -> Int# -> Word64X2#

-- | Read a vector from specified index of immutable array.
indexWord8X32Array# :: ByteArray# -> Int# -> Word8X32#

-- | Read a vector from specified index of immutable array.
indexWord16X16Array# :: ByteArray# -> Int# -> Word16X16#

-- | Read a vector from specified index of immutable array.
indexWord32X8Array# :: ByteArray# -> Int# -> Word32X8#

-- | Read a vector from specified index of immutable array.
indexWord64X4Array# :: ByteArray# -> Int# -> Word64X4#

-- | Read a vector from specified index of immutable array.
indexWord8X64Array# :: ByteArray# -> Int# -> Word8X64#

-- | Read a vector from specified index of immutable array.
indexWord16X32Array# :: ByteArray# -> Int# -> Word16X32#

-- | Read a vector from specified index of immutable array.
indexWord32X16Array# :: ByteArray# -> Int# -> Word32X16#

-- | Read a vector from specified index of immutable array.
indexWord64X8Array# :: ByteArray# -> Int# -> Word64X8#

-- | Read a vector from specified index of immutable array.
indexFloatX4Array# :: ByteArray# -> Int# -> FloatX4#

-- | Read a vector from specified index of immutable array.
indexDoubleX2Array# :: ByteArray# -> Int# -> DoubleX2#

-- | Read a vector from specified index of immutable array.
indexFloatX8Array# :: ByteArray# -> Int# -> FloatX8#

-- | Read a vector from specified index of immutable array.
indexDoubleX4Array# :: ByteArray# -> Int# -> DoubleX4#

-- | Read a vector from specified index of immutable array.
indexFloatX16Array# :: ByteArray# -> Int# -> FloatX16#

-- | Read a vector from specified index of immutable array.
indexDoubleX8Array# :: ByteArray# -> Int# -> DoubleX8#

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64X2Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8X64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64X2Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8X64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatX4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleX2Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatX8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleX4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatX16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleX8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8X16Array# :: MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16X8Array# :: MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32X4Array# :: MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64X2Array# :: MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8X32Array# :: MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16X16Array# :: MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32X8Array# :: MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64X4Array# :: MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8X64Array# :: MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16X32Array# :: MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32X16Array# :: MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64X8Array# :: MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8X16Array# :: MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16X8Array# :: MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32X4Array# :: MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64X2Array# :: MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8X32Array# :: MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16X16Array# :: MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32X8Array# :: MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64X4Array# :: MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8X64Array# :: MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16X32Array# :: MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32X16Array# :: MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64X8Array# :: MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatX4Array# :: MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleX2Array# :: MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatX8Array# :: MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleX4Array# :: MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatX16Array# :: MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleX8Array# :: MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d

-- | Reads vector; offset in bytes.
indexInt8X16OffAddr# :: Addr# -> Int# -> Int8X16#

-- | Reads vector; offset in bytes.
indexInt16X8OffAddr# :: Addr# -> Int# -> Int16X8#

-- | Reads vector; offset in bytes.
indexInt32X4OffAddr# :: Addr# -> Int# -> Int32X4#

-- | Reads vector; offset in bytes.
indexInt64X2OffAddr# :: Addr# -> Int# -> Int64X2#

-- | Reads vector; offset in bytes.
indexInt8X32OffAddr# :: Addr# -> Int# -> Int8X32#

-- | Reads vector; offset in bytes.
indexInt16X16OffAddr# :: Addr# -> Int# -> Int16X16#

-- | Reads vector; offset in bytes.
indexInt32X8OffAddr# :: Addr# -> Int# -> Int32X8#

-- | Reads vector; offset in bytes.
indexInt64X4OffAddr# :: Addr# -> Int# -> Int64X4#

-- | Reads vector; offset in bytes.
indexInt8X64OffAddr# :: Addr# -> Int# -> Int8X64#

-- | Reads vector; offset in bytes.
indexInt16X32OffAddr# :: Addr# -> Int# -> Int16X32#

-- | Reads vector; offset in bytes.
indexInt32X16OffAddr# :: Addr# -> Int# -> Int32X16#

-- | Reads vector; offset in bytes.
indexInt64X8OffAddr# :: Addr# -> Int# -> Int64X8#

-- | Reads vector; offset in bytes.
indexWord8X16OffAddr# :: Addr# -> Int# -> Word8X16#

-- | Reads vector; offset in bytes.
indexWord16X8OffAddr# :: Addr# -> Int# -> Word16X8#

-- | Reads vector; offset in bytes.
indexWord32X4OffAddr# :: Addr# -> Int# -> Word32X4#

-- | Reads vector; offset in bytes.
indexWord64X2OffAddr# :: Addr# -> Int# -> Word64X2#

-- | Reads vector; offset in bytes.
indexWord8X32OffAddr# :: Addr# -> Int# -> Word8X32#

-- | Reads vector; offset in bytes.
indexWord16X16OffAddr# :: Addr# -> Int# -> Word16X16#

-- | Reads vector; offset in bytes.
indexWord32X8OffAddr# :: Addr# -> Int# -> Word32X8#

-- | Reads vector; offset in bytes.
indexWord64X4OffAddr# :: Addr# -> Int# -> Word64X4#

-- | Reads vector; offset in bytes.
indexWord8X64OffAddr# :: Addr# -> Int# -> Word8X64#

-- | Reads vector; offset in bytes.
indexWord16X32OffAddr# :: Addr# -> Int# -> Word16X32#

-- | Reads vector; offset in bytes.
indexWord32X16OffAddr# :: Addr# -> Int# -> Word32X16#

-- | Reads vector; offset in bytes.
indexWord64X8OffAddr# :: Addr# -> Int# -> Word64X8#

-- | Reads vector; offset in bytes.
indexFloatX4OffAddr# :: Addr# -> Int# -> FloatX4#

-- | Reads vector; offset in bytes.
indexDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2#

-- | Reads vector; offset in bytes.
indexFloatX8OffAddr# :: Addr# -> Int# -> FloatX8#

-- | Reads vector; offset in bytes.
indexDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4#

-- | Reads vector; offset in bytes.
indexFloatX16OffAddr# :: Addr# -> Int# -> FloatX16#

-- | Reads vector; offset in bytes.
indexDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64X2OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8X64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64X2OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8X64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatX4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleX2OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatX8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleX4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatX16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleX8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8X16OffAddr# :: Addr# -> Int# -> Int8X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16X8OffAddr# :: Addr# -> Int# -> Int16X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32X4OffAddr# :: Addr# -> Int# -> Int32X4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64X2OffAddr# :: Addr# -> Int# -> Int64X2# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8X32OffAddr# :: Addr# -> Int# -> Int8X32# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16X16OffAddr# :: Addr# -> Int# -> Int16X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32X8OffAddr# :: Addr# -> Int# -> Int32X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64X4OffAddr# :: Addr# -> Int# -> Int64X4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8X64OffAddr# :: Addr# -> Int# -> Int8X64# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16X32OffAddr# :: Addr# -> Int# -> Int16X32# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32X16OffAddr# :: Addr# -> Int# -> Int32X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64X8OffAddr# :: Addr# -> Int# -> Int64X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8X16OffAddr# :: Addr# -> Int# -> Word8X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16X8OffAddr# :: Addr# -> Int# -> Word16X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32X4OffAddr# :: Addr# -> Int# -> Word32X4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64X2OffAddr# :: Addr# -> Int# -> Word64X2# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8X32OffAddr# :: Addr# -> Int# -> Word8X32# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16X16OffAddr# :: Addr# -> Int# -> Word16X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32X8OffAddr# :: Addr# -> Int# -> Word32X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64X4OffAddr# :: Addr# -> Int# -> Word64X4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8X64OffAddr# :: Addr# -> Int# -> Word8X64# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16X32OffAddr# :: Addr# -> Int# -> Word16X32# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32X16OffAddr# :: Addr# -> Int# -> Word32X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64X8OffAddr# :: Addr# -> Int# -> Word64X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatX4OffAddr# :: Addr# -> Int# -> FloatX4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatX8OffAddr# :: Addr# -> Int# -> FloatX8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatX16OffAddr# :: Addr# -> Int# -> FloatX16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8# -> State# d -> State# d

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt8ArrayAsInt8X16# :: ByteArray# -> Int# -> Int8X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt16ArrayAsInt16X8# :: ByteArray# -> Int# -> Int16X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt32ArrayAsInt32X4# :: ByteArray# -> Int# -> Int32X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt64ArrayAsInt64X2# :: ByteArray# -> Int# -> Int64X2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt8ArrayAsInt8X32# :: ByteArray# -> Int# -> Int8X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt16ArrayAsInt16X16# :: ByteArray# -> Int# -> Int16X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt32ArrayAsInt32X8# :: ByteArray# -> Int# -> Int32X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt64ArrayAsInt64X4# :: ByteArray# -> Int# -> Int64X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt8ArrayAsInt8X64# :: ByteArray# -> Int# -> Int8X64#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt16ArrayAsInt16X32# :: ByteArray# -> Int# -> Int16X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt32ArrayAsInt32X16# :: ByteArray# -> Int# -> Int32X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt64ArrayAsInt64X8# :: ByteArray# -> Int# -> Int64X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord8ArrayAsWord8X16# :: ByteArray# -> Int# -> Word8X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord16ArrayAsWord16X8# :: ByteArray# -> Int# -> Word16X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord32ArrayAsWord32X4# :: ByteArray# -> Int# -> Word32X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord64ArrayAsWord64X2# :: ByteArray# -> Int# -> Word64X2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord8ArrayAsWord8X32# :: ByteArray# -> Int# -> Word8X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord16ArrayAsWord16X16# :: ByteArray# -> Int# -> Word16X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord32ArrayAsWord32X8# :: ByteArray# -> Int# -> Word32X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord64ArrayAsWord64X4# :: ByteArray# -> Int# -> Word64X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord8ArrayAsWord8X64# :: ByteArray# -> Int# -> Word8X64#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord16ArrayAsWord16X32# :: ByteArray# -> Int# -> Word16X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord32ArrayAsWord32X16# :: ByteArray# -> Int# -> Word32X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord64ArrayAsWord64X8# :: ByteArray# -> Int# -> Word64X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexFloatArrayAsFloatX4# :: ByteArray# -> Int# -> FloatX4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexDoubleArrayAsDoubleX2# :: ByteArray# -> Int# -> DoubleX2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexFloatArrayAsFloatX8# :: ByteArray# -> Int# -> FloatX8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexDoubleArrayAsDoubleX4# :: ByteArray# -> Int# -> DoubleX4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexFloatArrayAsFloatX16# :: ByteArray# -> Int# -> FloatX16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexDoubleArrayAsDoubleX8# :: ByteArray# -> Int# -> DoubleX8#

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8ArrayAsInt8X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16ArrayAsInt16X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32ArrayAsInt32X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64ArrayAsInt64X2# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8ArrayAsInt8X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16ArrayAsInt16X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32ArrayAsInt32X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64ArrayAsInt64X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8ArrayAsInt8X64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16ArrayAsInt16X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32ArrayAsInt32X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64ArrayAsInt64X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord8X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16ArrayAsWord16X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32ArrayAsWord32X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64ArrayAsWord64X2# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord8X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16ArrayAsWord16X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32ArrayAsWord32X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64ArrayAsWord64X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord8X64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16ArrayAsWord16X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32ArrayAsWord32X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64ArrayAsWord64X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatArrayAsFloatX4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleArrayAsDoubleX2# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatArrayAsFloatX8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleArrayAsDoubleX4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatArrayAsFloatX16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleArrayAsDoubleX8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8ArrayAsInt8X16# :: MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16ArrayAsInt16X8# :: MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32ArrayAsInt32X4# :: MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64ArrayAsInt64X2# :: MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8ArrayAsInt8X32# :: MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16ArrayAsInt16X16# :: MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32ArrayAsInt32X8# :: MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64ArrayAsInt64X4# :: MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8ArrayAsInt8X64# :: MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16ArrayAsInt16X32# :: MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32ArrayAsInt32X16# :: MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64ArrayAsInt64X8# :: MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord8X16# :: MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16ArrayAsWord16X8# :: MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32ArrayAsWord32X4# :: MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64ArrayAsWord64X2# :: MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord8X32# :: MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16ArrayAsWord16X16# :: MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32ArrayAsWord32X8# :: MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64ArrayAsWord64X4# :: MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord8X64# :: MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16ArrayAsWord16X32# :: MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32ArrayAsWord32X16# :: MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64ArrayAsWord64X8# :: MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatArrayAsFloatX4# :: MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleArrayAsDoubleX2# :: MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatArrayAsFloatX8# :: MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleArrayAsDoubleX4# :: MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatArrayAsFloatX16# :: MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleArrayAsDoubleX8# :: MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d

-- | Reads vector; offset in scalar elements.
indexInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16#

-- | Reads vector; offset in scalar elements.
indexInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8#

-- | Reads vector; offset in scalar elements.
indexInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4#

-- | Reads vector; offset in scalar elements.
indexInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2#

-- | Reads vector; offset in scalar elements.
indexInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32#

-- | Reads vector; offset in scalar elements.
indexInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16#

-- | Reads vector; offset in scalar elements.
indexInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8#

-- | Reads vector; offset in scalar elements.
indexInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4#

-- | Reads vector; offset in scalar elements.
indexInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64#

-- | Reads vector; offset in scalar elements.
indexInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32#

-- | Reads vector; offset in scalar elements.
indexInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16#

-- | Reads vector; offset in scalar elements.
indexInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8#

-- | Reads vector; offset in scalar elements.
indexWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16#

-- | Reads vector; offset in scalar elements.
indexWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8#

-- | Reads vector; offset in scalar elements.
indexWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4#

-- | Reads vector; offset in scalar elements.
indexWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2#

-- | Reads vector; offset in scalar elements.
indexWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32#

-- | Reads vector; offset in scalar elements.
indexWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16#

-- | Reads vector; offset in scalar elements.
indexWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8#

-- | Reads vector; offset in scalar elements.
indexWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4#

-- | Reads vector; offset in scalar elements.
indexWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64#

-- | Reads vector; offset in scalar elements.
indexWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32#

-- | Reads vector; offset in scalar elements.
indexWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16#

-- | Reads vector; offset in scalar elements.
indexWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8#

-- | Reads vector; offset in scalar elements.
indexFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4#

-- | Reads vector; offset in scalar elements.
indexDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2#

-- | Reads vector; offset in scalar elements.
indexFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8#

-- | Reads vector; offset in scalar elements.
indexDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4#

-- | Reads vector; offset in scalar elements.
indexFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16#

-- | Reads vector; offset in scalar elements.
indexDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8OffAddrAsInt8X16# :: Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16OffAddrAsInt16X8# :: Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32OffAddrAsInt32X4# :: Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64OffAddrAsInt64X2# :: Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8OffAddrAsInt8X32# :: Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16OffAddrAsInt16X16# :: Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32OffAddrAsInt32X8# :: Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64OffAddrAsInt64X4# :: Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8OffAddrAsInt8X64# :: Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16OffAddrAsInt16X32# :: Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32OffAddrAsInt32X16# :: Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64OffAddrAsInt64X8# :: Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWord8X16# :: Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16OffAddrAsWord16X8# :: Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32OffAddrAsWord32X4# :: Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64OffAddrAsWord64X2# :: Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWord8X32# :: Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16OffAddrAsWord16X16# :: Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32OffAddrAsWord32X8# :: Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64OffAddrAsWord64X4# :: Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWord8X64# :: Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16OffAddrAsWord16X32# :: Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32OffAddrAsWord32X16# :: Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64OffAddrAsWord64X8# :: Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatOffAddrAsFloatX4# :: Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatOffAddrAsFloatX8# :: Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatOffAddrAsFloatX16# :: Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8# -> State# d -> State# d

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddFloatX4# :: FloatX4# -> FloatX4# -> FloatX4# -> FloatX4#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddFloatX8# :: FloatX8# -> FloatX8# -> FloatX8# -> FloatX8#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddFloatX16# :: FloatX16# -> FloatX16# -> FloatX16# -> FloatX16#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubFloatX4# :: FloatX4# -> FloatX4# -> FloatX4# -> FloatX4#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubFloatX8# :: FloatX8# -> FloatX8# -> FloatX8# -> FloatX8#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubFloatX16# :: FloatX16# -> FloatX16# -> FloatX16# -> FloatX16#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddFloatX4# :: FloatX4# -> FloatX4# -> FloatX4# -> FloatX4#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddFloatX8# :: FloatX8# -> FloatX8# -> FloatX8# -> FloatX8#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddFloatX16# :: FloatX16# -> FloatX16# -> FloatX16# -> FloatX16#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubFloatX4# :: FloatX4# -> FloatX4# -> FloatX4# -> FloatX4#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubFloatX8# :: FloatX8# -> FloatX8# -> FloatX8# -> FloatX8#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubFloatX16# :: FloatX16# -> FloatX16# -> FloatX16# -> FloatX16#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt8X16# :: Int8X16# -> Int8X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X16#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt16X8# :: Int16X8# -> Int16X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt32X4# :: Int32X4# -> Int32X4# -> (# Int#, Int#, Int#, Int# #) -> Int32X4#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt64X2# :: Int64X2# -> Int64X2# -> (# Int#, Int# #) -> Int64X2#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt8X32# :: Int8X32# -> Int8X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X32#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt16X16# :: Int16X16# -> Int16X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X16#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt32X8# :: Int32X8# -> Int32X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int32X8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt64X4# :: Int64X4# -> Int64X4# -> (# Int#, Int#, Int#, Int# #) -> Int64X4#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt8X64# :: Int8X64# -> Int8X64# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X64#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt16X32# :: Int16X32# -> Int16X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X32#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt32X16# :: Int32X16# -> Int32X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int32X16#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt64X8# :: Int64X8# -> Int64X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int64X8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord8X16# :: Word8X16# -> Word8X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word8X16#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord16X8# :: Word16X8# -> Word16X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word16X8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord32X4# :: Word32X4# -> Word32X4# -> (# Int#, Int#, Int#, Int# #) -> Word32X4#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord64X2# :: Word64X2# -> Word64X2# -> (# Int#, Int# #) -> Word64X2#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord8X32# :: Word8X32# -> Word8X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word8X32#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord16X16# :: Word16X16# -> Word16X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word16X16#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord32X8# :: Word32X8# -> Word32X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word32X8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord64X4# :: Word64X4# -> Word64X4# -> (# Int#, Int#, Int#, Int# #) -> Word64X4#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord8X64# :: Word8X64# -> Word8X64# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word8X64#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord16X32# :: Word16X32# -> Word16X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word16X32#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord32X16# :: Word32X16# -> Word32X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word32X16#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord64X8# :: Word64X8# -> Word64X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word64X8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleFloatX4# :: FloatX4# -> FloatX4# -> (# Int#, Int#, Int#, Int# #) -> FloatX4#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleDoubleX2# :: DoubleX2# -> DoubleX2# -> (# Int#, Int# #) -> DoubleX2#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleFloatX8# :: FloatX8# -> FloatX8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> FloatX8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleDoubleX4# :: DoubleX4# -> DoubleX4# -> (# Int#, Int#, Int#, Int# #) -> DoubleX4#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleFloatX16# :: FloatX16# -> FloatX16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> FloatX16#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleDoubleX8# :: DoubleX8# -> DoubleX8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> DoubleX8#

-- | Component-wise minimum of two vectors.
minInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Component-wise minimum of two vectors.
minInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Component-wise minimum of two vectors.
minInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Component-wise minimum of two vectors.
minInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Component-wise minimum of two vectors.
minInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Component-wise minimum of two vectors.
minInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Component-wise minimum of two vectors.
minInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Component-wise minimum of two vectors.
minInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Component-wise minimum of two vectors.
minInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Component-wise minimum of two vectors.
minInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Component-wise minimum of two vectors.
minInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Component-wise minimum of two vectors.
minInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Component-wise minimum of two vectors.
minWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Component-wise minimum of two vectors.
minWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Component-wise minimum of two vectors.
minWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Component-wise minimum of two vectors.
minWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Component-wise minimum of two vectors.
minWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Component-wise minimum of two vectors.
minWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Component-wise minimum of two vectors.
minWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Component-wise minimum of two vectors.
minWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Component-wise minimum of two vectors.
minWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Component-wise minimum of two vectors.
minWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Component-wise minimum of two vectors.
minWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Component-wise minimum of two vectors.
minWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Component-wise minimum of two vectors.
minFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Component-wise minimum of two vectors.
minDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Component-wise minimum of two vectors.
minFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Component-wise minimum of two vectors.
minDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Component-wise minimum of two vectors.
minFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Component-wise minimum of two vectors.
minDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Component-wise maximum of two vectors.
maxInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Component-wise maximum of two vectors.
maxInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Component-wise maximum of two vectors.
maxInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Component-wise maximum of two vectors.
maxInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Component-wise maximum of two vectors.
maxInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Component-wise maximum of two vectors.
maxInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Component-wise maximum of two vectors.
maxInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Component-wise maximum of two vectors.
maxInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Component-wise maximum of two vectors.
maxInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Component-wise maximum of two vectors.
maxInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Component-wise maximum of two vectors.
maxInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Component-wise maximum of two vectors.
maxInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Component-wise maximum of two vectors.
maxWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Component-wise maximum of two vectors.
maxWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Component-wise maximum of two vectors.
maxWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Component-wise maximum of two vectors.
maxWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Component-wise maximum of two vectors.
maxWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Component-wise maximum of two vectors.
maxWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Component-wise maximum of two vectors.
maxWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Component-wise maximum of two vectors.
maxWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Component-wise maximum of two vectors.
maxWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Component-wise maximum of two vectors.
maxWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Component-wise maximum of two vectors.
maxWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Component-wise maximum of two vectors.
maxWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Component-wise maximum of two vectors.
maxFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Component-wise maximum of two vectors.
maxDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Component-wise maximum of two vectors.
maxFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Component-wise maximum of two vectors.
maxDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Component-wise maximum of two vectors.
maxFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Component-wise maximum of two vectors.
maxDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
prefetchByteArray3# :: ByteArray# -> Int# -> State# d -> State# d
prefetchMutableByteArray3# :: MutableByteArray# d -> Int# -> State# d -> State# d
prefetchAddr3# :: Addr# -> Int# -> State# d -> State# d
prefetchValue3# :: a -> State# d -> State# d
prefetchByteArray2# :: ByteArray# -> Int# -> State# d -> State# d
prefetchMutableByteArray2# :: MutableByteArray# d -> Int# -> State# d -> State# d
prefetchAddr2# :: Addr# -> Int# -> State# d -> State# d
prefetchValue2# :: a -> State# d -> State# d
prefetchByteArray1# :: ByteArray# -> Int# -> State# d -> State# d
prefetchMutableByteArray1# :: MutableByteArray# d -> Int# -> State# d -> State# d
prefetchAddr1# :: Addr# -> Int# -> State# d -> State# d
prefetchValue1# :: a -> State# d -> State# d
prefetchByteArray0# :: ByteArray# -> Int# -> State# d -> State# d
prefetchMutableByteArray0# :: MutableByteArray# d -> Int# -> State# d -> State# d
prefetchAddr0# :: Addr# -> Int# -> State# d -> State# d
prefetchValue0# :: a -> State# d -> State# d


-- | Defines the <a>withDict</a> function. For more information, see
--   <tt>Note [withDict]</tt> in <a>GHC.Tc.Instance.Class</a> in GHC. The
--   definition of <a>withDict</a> is located in a separate module from
--   <a>GHC.Magic</a> because <a>withDict</a> is <tt>Unsafe</tt> (it
--   threatens type class coherence) while <a>GHC.Magic</a> is
--   <tt>Trustworthy</tt>.
--   
--   Use <a>GHC.Exts</a> from the <tt>base</tt> package instead of
--   importing this module directly.
module GHC.Magic.Dict

-- | The constraint <tt><a>WithDict</a> cls meth</tt> can be solved when
--   evidence for the constraint <tt>cls</tt> can be provided in the form
--   of a dictionary of type <tt>meth</tt>. This requires <tt>cls</tt> to
--   be a class constraint whose single method has type <tt>meth</tt>.
--   
--   For more (important) details on how this works, see <tt>Note
--   [withDict]</tt> in <a>GHC.Tc.Instance.Class</a> in GHC.
class WithDict cls meth
withDict :: forall {rr :: RuntimeRep} (r :: TYPE rr). WithDict cls meth => meth -> (cls => r) -> r


-- | GHC magic.
--   
--   Use GHC.Exts from the base package instead of importing this module
--   directly.
module GHC.Magic

-- | The call <tt>inline f</tt> arranges that <tt>f</tt> is inlined,
--   regardless of its size. More precisely, the call <tt>inline f</tt>
--   rewrites to the right-hand side of <tt>f</tt>'s definition. This
--   allows the programmer to control inlining from a particular call site
--   rather than the definition site of the function (c.f. <tt>INLINE</tt>
--   pragmas).
--   
--   This inlining occurs regardless of the argument to the call or the
--   size of <tt>f</tt>'s definition; it is unconditional. The main caveat
--   is that <tt>f</tt>'s definition must be visible to the compiler; it is
--   therefore recommended to mark the function with an <tt>INLINABLE</tt>
--   pragma at its definition so that GHC guarantees to record its
--   unfolding regardless of size.
--   
--   If no inlining takes place, the <a>inline</a> function expands to the
--   identity function in Phase zero, so its use imposes no overhead.
inline :: a -> a

-- | The call <tt>noinline f</tt> arranges that <tt>f</tt> will not be
--   inlined. It is removed during CorePrep so that its use imposes no
--   overhead (besides the fact that it blocks inlining.)
noinline :: a -> a

-- | The <a>lazy</a> function restrains strictness analysis a little. The
--   call <tt>lazy e</tt> means the same as <tt>e</tt>, but <a>lazy</a> has
--   a magical property so far as strictness analysis is concerned: it is
--   lazy in its first argument, even though its semantics is strict. After
--   strictness analysis has run, calls to <a>lazy</a> are inlined to be
--   the identity function.
--   
--   This behaviour is occasionally useful when controlling evaluation
--   order. Notably, <a>lazy</a> is used in the library definition of
--   <a>par</a>:
--   
--   <pre>
--   par :: a -&gt; b -&gt; b
--   par x y = case (par# x) of _ -&gt; lazy y
--   </pre>
--   
--   If <a>lazy</a> were not lazy, <a>par</a> would look strict in
--   <tt>y</tt> which would defeat the whole purpose of <a>par</a>.
lazy :: a -> a

-- | The <a>oneShot</a> function can be used to give a hint to the compiler
--   that its argument will be called at most once, which may (or may not)
--   enable certain optimizations. It can be useful to improve the
--   performance of code in continuation passing style.
--   
--   If <a>oneShot</a> is used wrongly, then it may be that computations
--   whose result that would otherwise be shared are re-evaluated every
--   time they are used. Otherwise, the use of <a>oneShot</a> is safe.
--   
--   <a>oneShot</a> is representation-polymorphic: the type variables may
--   refer to lifted or unlifted types.
oneShot :: forall {q :: RuntimeRep} {r :: RuntimeRep} (a :: TYPE q) (b :: TYPE r). (a -> b) -> a -> b

-- | Apply a function to a <tt><a>State#</a> <a>RealWorld</a></tt> token.
--   When manually applying a function to <a>realWorld#</a>, it is
--   necessary to use <tt>NOINLINE</tt> to prevent semantically undesirable
--   floating. <a>runRW#</a> is inlined, but only very late in compilation
--   after all floating is complete.
runRW# :: forall (r :: RuntimeRep) (o :: TYPE r). (State# RealWorld -> o) -> o

-- | <tt><a>dataToTag#</a></tt> evaluates its argument and returns the
--   index (starting at zero) of the constructor used to produce that
--   argument. Any algebraic data type with all of its constructors in
--   scope may be used with <tt>dataToTag#</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dataToTag# (Left ())
--   0#
--   
--   &gt;&gt;&gt; dataToTag# (Right undefined)
--   1#
--   </pre>
class DataToTag (a :: TYPE 'BoxedRep lev)
dataToTag# :: DataToTag a => a -> Int#


-- | Primitive panics.
--   
--   Users should not import this module. It is GHC internal only.
module GHC.Prim.Panic

-- | Closure introduced by GHC.Stg.Unarise for unused unboxed sum fields.
--   
--   See Note [aBSENT_SUM_FIELD_ERROR_ID] in GHC.Core.Make
absentSumFieldError :: a

-- | Display the CString whose address is given as an argument and exit.
panicError :: Addr# -> a

-- | Displays "Oops! Entered absent arg" ++ errormsg and exits the program.
absentError :: Addr# -> a
absentConstraintError :: Addr# -> a


-- | Users should not import this module. It is GHC internal only.
module GHC.Debug
debugLn :: [Char] -> IO ()
debugErrLn :: [Char] -> IO ()


-- | GHC C strings definitions (previously in GHC.Base). Use GHC.Exts from
--   the base package instead of importing this module directly.
module GHC.CString
unpackCString# :: Addr# -> [Char]
unpackAppendCString# :: Addr# -> [Char] -> [Char]
unpackFoldrCString# :: Addr# -> (Char -> a -> a) -> a -> a

-- | Compute the length of a NUL-terminated string. This address must refer
--   to immutable memory. GHC includes a built-in rule for constant folding
--   when the argument is a statically-known literal. That is, a
--   core-to-core pass reduces the expression <tt>cstringLength#
--   "hello"#</tt> to the constant <tt>5#</tt>.
cstringLength# :: Addr# -> Int#
unpackCStringUtf8# :: Addr# -> [Char]
unpackAppendCStringUtf8# :: Addr# -> [Char] -> [Char]
unpackFoldrCStringUtf8# :: Addr# -> (Char -> a -> a) -> a -> a
unpackNBytes# :: Addr# -> Int# -> [Char]


-- | Basic classes. Do not import this module directly. It is an GHC
--   internal only module. Some of its contents are instead available from
--   <tt>Prelude</tt> and <tt>GHC.Int</tt>.
module GHC.Classes

-- | The syntax <tt>?x :: a</tt> is desugared into <tt>IP "x" a</tt> IP is
--   declared very early, so that libraries can take advantage of the
--   implicit-call-stack feature
class IP (x :: Symbol) a | x -> a
ip :: IP x a => a

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, instances
--   are encouraged to follow these properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Extensionality</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   <a>Ord</a>, as defined by the Haskell report, implements a total order
--   and has the following properties:
--   
--   <ul>
--   <li><i><b>Comparability</b></i> <tt>x &lt;= y || y &lt;= x</tt> =
--   <a>True</a></li>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   The following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Note that (7.) and (8.) do <i>not</i> require <a>min</a> and
--   <a>max</a> to return either of their arguments. The result is merely
--   required to <i>equal</i> one of the arguments in terms of <a>(==)</a>.
--   Users who expect a stronger guarantee are advised to write their own
--   min and/or max functions.
--   
--   The nuance of the above distinction is not always fully internalized
--   by developers, and in the past (tracing back to the Haskell 1.4
--   Report) the specification for <a>Ord</a> asserted the stronger
--   property that <tt>(min x y, max x y) = (x, y)</tt> or <tt>(y, x)</tt>,
--   or in other words, that <a>min</a> and <a>max</a> <i>will</i> return
--   one of their arguments, using argument order as the tie-breaker if the
--   arguments are equal by comparison. A few list and <a>Foldable</a>
--   functions have behavior that is best understood with this assumption
--   in mind: all variations of <tt>minimumBy</tt> and <tt>maximumBy</tt>
--   (which can't use <a>min</a> and <a>max</a> in their implementations)
--   are written such that <tt>minimumBy <a>compare</a></tt> and
--   <tt>maximumBy <a>compare</a></tt> are respectively equivalent to
--   <tt>minimum</tt> and <tt>maximum</tt> (which do use <a>min</a> and
--   <a>max</a>) only if <a>min</a> and <a>max</a> adhere to this
--   tie-breaking convention. Otherwise, if there are multiple least or
--   largest elements in a container, <tt>minimum</tt> and <tt>maximum</tt>
--   may not return the <i>same</i> one that <tt>minimumBy
--   <a>compare</a></tt> and <tt>maximumBy <a>compare</a></tt> do (though
--   they should return something that is <i>equal</i>). (This is relevant
--   for types with non-extensional equality, like <a>Arg</a>, but also in
--   cases where the precise reference held matters for memory-management
--   reasons.) Unless there is a reason to deviate, it is less confusing
--   for implementors of <a>Ord</a> to respect this same convention (as the
--   default definitions of <a>min</a> and <a>max</a> do).
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 <
infix 4 <=
infix 4 >
eqInt :: Int -> Int -> Bool
neInt :: Int -> Int -> Bool
eqWord :: Word -> Word -> Bool
neWord :: Word -> Word -> Bool
eqChar :: Char -> Char -> Bool
neChar :: Char -> Char -> Bool
eqFloat :: Float -> Float -> Bool
eqDouble :: Double -> Double -> Bool
gtInt :: Int -> Int -> Bool
geInt :: Int -> Int -> Bool
leInt :: Int -> Int -> Bool
ltInt :: Int -> Int -> Bool
compareInt :: Int -> Int -> Ordering
compareInt# :: Int# -> Int# -> Ordering
gtWord :: Word -> Word -> Bool
geWord :: Word -> Word -> Bool
leWord :: Word -> Word -> Bool
ltWord :: Word -> Word -> Bool
compareWord :: Word -> Word -> Ordering
compareWord# :: Word# -> Word# -> Ordering

-- | Boolean "and", lazy in the second argument
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or", lazy in the second argument
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "not"
not :: Bool -> Bool
divInt# :: Int# -> Int# -> Int#
divInt8# :: Int8# -> Int8# -> Int8#
divInt16# :: Int16# -> Int16# -> Int16#
divInt32# :: Int32# -> Int32# -> Int32#
modInt# :: Int# -> Int# -> Int#
modInt8# :: Int8# -> Int8# -> Int8#
modInt16# :: Int16# -> Int16# -> Int16#
modInt32# :: Int32# -> Int32# -> Int32#
divModInt# :: Int# -> Int# -> (# Int#, Int# #)
divModInt8# :: Int8# -> Int8# -> (# Int8#, Int8# #)
divModInt16# :: Int16# -> Int16# -> (# Int16#, Int16# #)
divModInt32# :: Int32# -> Int32# -> (# Int32#, Int32# #)
class CUnit
class a => CSolo a
type CTuple0 = ()
type CTuple1 = CSolo
class (a, b) => CTuple2 a b
class (a, b, c) => CTuple3 a b c
class (a, b, c, d) => CTuple4 a b c d
class (a, b, c, d, e) => CTuple5 a b c d e
class (a, b, c, d, e, f) => CTuple6 a b c d e f
class (a, b, c, d, e, f, g) => CTuple7 a b c d e f g
class (a, b, c, d, e, f, g, h) => CTuple8 a b c d e f g h
class (a, b, c, d, e, f, g, h, i) => CTuple9 a b c d e f g h i
class (a, b, c, d, e, f, g, h, i, j) => CTuple10 a b c d e f g h i j
class (a, b, c, d, e, f, g, h, i, j, k) => CTuple11 a b c d e f g h i j k
class (a, b, c, d, e, f, g, h, i, j, k, l) => CTuple12 a b c d e f g h i j k l
class (a, b, c, d, e, f, g, h, i, j, k, l, m) => CTuple13 a b c d e f g h i j k l m
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n) => CTuple14 a b c d e f g h i j k l m n
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) => CTuple15 a b c d e f g h i j k l m n o
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) => CTuple16 a b c d e f g h i j k l m n o p
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) => CTuple17 a b c d e f g h i j k l m n o p q
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) => CTuple18 a b c d e f g h i j k l m n o p q r
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) => CTuple19 a b c d e f g h i j k l m n o p q r s
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) => CTuple20 a b c d e f g h i j k l m n o p q r s t
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) => CTuple21 a b c d e f g h i j k l m n o p q r s t u
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) => CTuple22 a b c d e f g h i j k l m n o p q r s t u v
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) => CTuple23 a b c d e f g h i j k l m n o p q r s t u v w
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) => CTuple24 a b c d e f g h i j k l m n o p q r s t u v w x
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) => CTuple25 a b c d e f g h i j k l m n o p q r s t u v w x y
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z) => CTuple26 a b c d e f g h i j k l m n o p q r s t u v w x y z
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26) => CTuple27 a b c d e f g h i j k l m n o p q r s t u v w x y z t26
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27) => CTuple28 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28) => CTuple29 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29) => CTuple30 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30) => CTuple31 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31) => CTuple32 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32) => CTuple33 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33) => CTuple34 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34) => CTuple35 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35) => CTuple36 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36) => CTuple37 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37) => CTuple38 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38) => CTuple39 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39) => CTuple40 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40) => CTuple41 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41) => CTuple42 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42) => CTuple43 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43) => CTuple44 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44) => CTuple45 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45) => CTuple46 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46) => CTuple47 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47) => CTuple48 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48) => CTuple49 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49) => CTuple50 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50) => CTuple51 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51) => CTuple52 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52) => CTuple53 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53) => CTuple54 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54) => CTuple55 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55) => CTuple56 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56) => CTuple57 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57) => CTuple58 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58) => CTuple59 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59) => CTuple60 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60) => CTuple61 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61) => CTuple62 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62) => CTuple63 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
class (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63) => CTuple64 a b c d e f g h i j k l m n o p q r s t u v w x y z t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62 t63
instance a => (a)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29)
instance (c1, c2) => (c1, c2)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39)
instance (c1, c2, c3) => (c1, c2, c3)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49)
instance (c1, c2, c3, c4) => (c1, c2, c3, c4)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54, c55) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54, c55)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54, c55, c56) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54, c55, c56)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54, c55, c56, c57) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54, c55, c56, c57)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54, c55, c56, c57, c58) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54, c55, c56, c57, c58)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54, c55, c56, c57, c58, c59) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54, c55, c56, c57, c58, c59)
instance (c1, c2, c3, c4, c5) => (c1, c2, c3, c4, c5)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54, c55, c56, c57, c58, c59, c60) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54, c55, c56, c57, c58, c59, c60)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54, c55, c56, c57, c58, c59, c60, c61) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54, c55, c56, c57, c58, c59, c60, c61)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54, c55, c56, c57, c58, c59, c60, c61, c62) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54, c55, c56, c57, c58, c59, c60, c61, c62)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54, c55, c56, c57, c58, c59, c60, c61, c62, c63) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54, c55, c56, c57, c58, c59, c60, c61, c62, c63)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54, c55, c56, c57, c58, c59, c60, c61, c62, c63, c64) => (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54, c55, c56, c57, c58, c59, c60, c61, c62, c63, c64)
instance (c1, c2, c3, c4, c5, c6) => (c1, c2, c3, c4, c5, c6)
instance (c1, c2, c3, c4, c5, c6, c7) => (c1, c2, c3, c4, c5, c6, c7)
instance (c1, c2, c3, c4, c5, c6, c7, c8) => (c1, c2, c3, c4, c5, c6, c7, c8)
instance (c1, c2, c3, c4, c5, c6, c7, c8, c9) => (c1, c2, c3, c4, c5, c6, c7, c8, c9)
instance () :: Constraint
instance GHC.Classes.Eq GHC.Types.Bool
instance GHC.Classes.Eq GHC.Types.Char
instance GHC.Classes.Eq GHC.Types.Double
instance GHC.Classes.Eq GHC.Types.Float
instance GHC.Classes.Eq GHC.Types.Int
instance GHC.Classes.Eq a => GHC.Classes.Eq [a]
instance GHC.Classes.Eq GHC.Types.Module
instance GHC.Classes.Eq GHC.Types.Ordering
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Tuple.Solo a)
instance GHC.Classes.Eq GHC.Types.TrName
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k, l)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l, GHC.Classes.Eq m) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l, GHC.Classes.Eq m, GHC.Classes.Eq n) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l, GHC.Classes.Eq m, GHC.Classes.Eq n, GHC.Classes.Eq o) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (a, b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) => GHC.Classes.Eq (a, b, c)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d) => GHC.Classes.Eq (a, b, c, d)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e) => GHC.Classes.Eq (a, b, c, d, e)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f) => GHC.Classes.Eq (a, b, c, d, e, f)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g) => GHC.Classes.Eq (a, b, c, d, e, f, g)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h) => GHC.Classes.Eq (a, b, c, d, e, f, g, h)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i)
instance GHC.Classes.Eq GHC.Types.TyCon
instance GHC.Classes.Eq ()
instance GHC.Classes.Eq GHC.Types.Word
instance GHC.Classes.Ord GHC.Types.Bool
instance GHC.Classes.Ord GHC.Types.Char
instance GHC.Classes.Ord GHC.Types.Double
instance GHC.Classes.Ord GHC.Types.Float
instance GHC.Classes.Ord GHC.Types.Int
instance GHC.Classes.Ord a => GHC.Classes.Ord [a]
instance GHC.Classes.Ord GHC.Types.Ordering
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Tuple.Solo a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k, GHC.Classes.Ord l) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k, l)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k, GHC.Classes.Ord l, GHC.Classes.Ord m) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k, GHC.Classes.Ord l, GHC.Classes.Ord m, GHC.Classes.Ord n) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k, GHC.Classes.Ord l, GHC.Classes.Ord m, GHC.Classes.Ord n, GHC.Classes.Ord o) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (a, b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c) => GHC.Classes.Ord (a, b, c)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d) => GHC.Classes.Ord (a, b, c, d)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e) => GHC.Classes.Ord (a, b, c, d, e)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f) => GHC.Classes.Ord (a, b, c, d, e, f)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g) => GHC.Classes.Ord (a, b, c, d, e, f, g)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h) => GHC.Classes.Ord (a, b, c, d, e, f, g, h)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i)
instance GHC.Classes.Ord GHC.Types.TyCon
instance GHC.Classes.Ord ()
instance GHC.Classes.Ord GHC.Types.Word
