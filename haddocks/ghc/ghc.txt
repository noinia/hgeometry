-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The GHC API
--   
--   GHC's functionality can be useful for more things than just compiling
--   Haskell programs. Important use cases are programs that analyse (and
--   perhaps transform) Haskell code. Others include loading Haskell code
--   dynamically in a GHCi-like manner. For this reason, a lot of GHC's
--   functionality is made available through this package.
--   
--   See
--   <a>https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/compiler</a>
--   for more information.
--   
--   <b>This package is not PVP-compliant.</b>
--   
--   This package directly exposes GHC internals, which can and do change
--   with every release.
@package ghc
@version 9.12.2

module GHC.Data.List.Infinite
data Infinite a
Inf :: a -> Infinite a -> Infinite a
head :: Infinite a -> a
tail :: Infinite a -> Infinite a
filter :: (a -> Bool) -> Infinite a -> Infinite a
(++) :: Foldable f => f a -> Infinite a -> Infinite a
infixr 5 ++
unfoldr :: (b -> (a, b)) -> b -> Infinite a
(!!) :: Infinite a -> Int -> a
groupBy :: (a -> a -> Bool) -> Infinite a -> Infinite (NonEmpty a)
dropList :: [a] -> Infinite b -> Infinite b
iterate :: (a -> a) -> a -> Infinite a
concatMap :: Foldable f => (a -> f b) -> Infinite a -> Infinite b

-- | Compute all lists of the given alphabet. For example:
--   <tt><a>allListsOf</a> "ab" = ["a", "b", "aa", "ba", "ab", "bb", "aaa",
--   "baa", "aba", ...]</tt>
allListsOf :: [a] -> Infinite [a]
toList :: Infinite a -> [a]
repeat :: a -> Infinite a
instance GHC.Internal.Base.Applicative GHC.Data.List.Infinite.Infinite
instance GHC.Internal.Data.Foldable.Foldable GHC.Data.List.Infinite.Infinite
instance GHC.Internal.Base.Functor GHC.Data.List.Infinite.Infinite
instance GHC.Internal.Data.Traversable.Traversable GHC.Data.List.Infinite.Infinite

module GHC.Platform.Constants
data PlatformConstants
PlatformConstants :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> !Integer -> !Integer -> !Integer -> !Bool -> PlatformConstants
[pc_CONTROL_GROUP_CONST_291] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_STD_HDR_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_PROF_HDR_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_BLOCK_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_BLOCKS_PER_MBLOCK] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_TICKY_BIN_COUNT] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR7] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR8] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR9] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR10] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rL1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rSp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rSpLim] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rHp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rHpLim] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rCCCS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rCurrentTSO] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rCurrentNursery] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rHpAlloc] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_stgEagerBlackholeInfo] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_stgGCEnter1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_stgGCFun] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_Capability_r] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_start] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_free] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_blocks] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_flags] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_CostCentreStack] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_CostCentreStack_mem_alloc] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_CostCentreStack_mem_alloc] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_CostCentreStack_scc_count] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_CostCentreStack_scc_count] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgHeader_ccs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgHeader_ldvw] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgSMPThunkHeader] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_allocs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgEntCounter_allocs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_allocd] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgEntCounter_allocd] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_registeredp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_link] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_entry_count] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgUpdateFrame_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgOrigThunkInfoFrame_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgMutArrPtrs_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgMutArrPtrs_ptrs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgMutArrPtrs_size] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgSmallMutArrPtrs_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgSmallMutArrPtrs_ptrs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgArrBytes_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgArrBytes_bytes] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgTSO_alloc_limit] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgTSO_cccs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgTSO_stackobj] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgStack_sp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgStack_stack] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgUpdateFrame_updatee] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgOrigThunkInfoFrame_info_ptr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgFunInfoExtraFwd_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgFunInfoExtraFwd_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgFunInfoExtraRev] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgFunInfoExtraRev_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgFunInfoExtraRev_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_SPEC_SELECTEE_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_SPEC_AP_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MIN_PAYLOAD_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MIN_INTLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_INTLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MIN_CHARLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_CHARLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MUT_ARR_PTRS_CARD_BITS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Vanilla_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Float_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Double_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Long_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_XMM_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Vanilla_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Float_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Double_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_XMM_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Long_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_RESERVED_C_STACK_BYTES] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_RESERVED_STACK_WORDS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_AP_STACK_SPLIM] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_WORD_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_CINT_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_CLONG_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_CLONG_LONG_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_BITMAP_BITS_SHIFT] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_TAG_BITS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_LDV_SHIFT] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_ILDV_CREATE_MASK] :: PlatformConstants -> !Integer
[pc_ILDV_STATE_CREATE] :: PlatformConstants -> !Integer
[pc_ILDV_STATE_USE] :: PlatformConstants -> !Integer
[pc_USE_INLINE_SRT_FIELD] :: PlatformConstants -> !Bool
parseConstantsHeader :: FilePath -> IO PlatformConstants
instance GHC.Classes.Eq GHC.Platform.Constants.PlatformConstants
instance GHC.Classes.Ord GHC.Platform.Constants.PlatformConstants
instance GHC.Internal.Read.Read GHC.Platform.Constants.PlatformConstants
instance GHC.Internal.Show.Show GHC.Platform.Constants.PlatformConstants


-- | Custom minimal GHC <a>Prelude</a>
--   
--   This module serves as a replacement for the <a>Prelude</a> module and
--   abstracts over differences between the bootstrapping GHC version, and
--   may also provide a common default vocabulary.
module GHC.Prelude.Basic
($) :: (a -> b) -> a -> b
($!) :: (a -> b) -> a -> b
(++) :: [a] -> [a] -> [a]
(.) :: (b -> c) -> (a -> b) -> a -> c
(=<<) :: Monad m => (a -> m b) -> m a -> m b
asTypeOf :: a -> a -> a
const :: a -> b -> a
flip :: (a -> b -> c) -> b -> a -> c
id :: a -> a
map :: (a -> b) -> [a] -> [b]
otherwise :: Bool
until :: (a -> Bool) -> (a -> a) -> a -> a
either :: (a -> c) -> (b -> c) -> Either a b -> c
all :: Foldable t => (a -> Bool) -> t a -> Bool
and :: Foldable t => t Bool -> Bool
any :: Foldable t => (a -> Bool) -> t a -> Bool
concat :: Foldable t => t [a] -> [a]
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
or :: Foldable t => t Bool -> Bool
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
(<$>) :: Functor f => (a -> b) -> f a -> f b
maybe :: b -> (a -> b) -> Maybe a -> b
lines :: String -> [String]
unlines :: [String] -> String
unwords :: [String] -> String
words :: String -> [String]
curry :: ((a, b) -> c) -> a -> b -> c
fst :: (a, b) -> a
snd :: (a, b) -> b
uncurry :: (a -> b -> c) -> (a, b) -> c
error :: HasCallStack => [Char] -> a
errorWithoutStackTrace :: [Char] -> a
undefined :: HasCallStack => a
ioError :: HasCallStack => IOError -> IO a
userError :: String -> IOError
(!!) :: HasCallStack => [a] -> Int -> a
break :: (a -> Bool) -> [a] -> ([a], [a])
cycle :: HasCallStack => [a] -> [a]
drop :: Int -> [a] -> [a]
dropWhile :: (a -> Bool) -> [a] -> [a]
filter :: (a -> Bool) -> [a] -> [a]
init :: HasCallStack => [a] -> [a]
iterate :: (a -> a) -> a -> [a]
last :: HasCallStack => [a] -> a
lookup :: Eq a => a -> [(a, b)] -> Maybe b
repeat :: a -> [a]
replicate :: Int -> a -> [a]
reverse :: [a] -> [a]
scanl :: (b -> a -> b) -> b -> [a] -> [b]
scanl1 :: (a -> a -> a) -> [a] -> [a]
scanr :: (a -> b -> b) -> b -> [a] -> [b]
scanr1 :: (a -> a -> a) -> [a] -> [a]
span :: (a -> Bool) -> [a] -> ([a], [a])
splitAt :: Int -> [a] -> ([a], [a])
take :: Int -> [a] -> [a]
takeWhile :: (a -> Bool) -> [a] -> [a]
unzip :: [(a, b)] -> ([a], [b])
unzip3 :: [(a, b, c)] -> ([a], [b], [c])
zip :: [a] -> [b] -> [(a, b)]
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
subtract :: Num a => a -> a -> a
lex :: ReadS String
readParen :: Bool -> ReadS a -> ReadS a
(^) :: (Num a, Integral b) => a -> b -> a
(^^) :: (Fractional a, Integral b) => a -> b -> a
even :: Integral a => a -> Bool
fromIntegral :: (Integral a, Num b) => a -> b
gcd :: Integral a => a -> a -> a
lcm :: Integral a => a -> a -> a
odd :: Integral a => a -> Bool
realToFrac :: (Real a, Fractional b) => a -> b
showChar :: Char -> ShowS
showParen :: Bool -> ShowS -> ShowS
showString :: String -> ShowS
shows :: Show a => a -> ShowS
appendFile :: FilePath -> String -> IO ()
getChar :: IO Char
getContents :: IO String
getLine :: IO String
interact :: (String -> String) -> IO ()
print :: Show a => a -> IO ()
putChar :: Char -> IO ()
putStr :: String -> IO ()
putStrLn :: String -> IO ()
readFile :: FilePath -> IO String
readIO :: Read a => String -> IO a
readLn :: Read a => IO a
writeFile :: FilePath -> String -> IO ()
read :: Read a => String -> a
reads :: Read a => ReadS a
(&&) :: Bool -> Bool -> Bool
not :: Bool -> Bool
(||) :: Bool -> Bool -> Bool
seq :: a -> b -> b
class Functor (f :: Type -> Type)
fmap :: Functor f => (a -> b) -> f a -> f b
(<$) :: Functor f => a -> f b -> f a
class Applicative m => Monad (m :: Type -> Type)
(>>=) :: Monad m => m a -> (a -> m b) -> m b
(>>) :: Monad m => m a -> m b -> m b
return :: Monad m => a -> m a
class Semigroup a => Monoid a
mempty :: Monoid a => a
mappend :: Monoid a => a -> a -> a
mconcat :: Monoid a => [a] -> a
class Semigroup a
class Monad m => MonadFail (m :: Type -> Type)
fail :: MonadFail m => String -> m a
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b
class Foldable (t :: Type -> Type)
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
null :: Foldable t => t a -> Bool
length :: Foldable t => t a -> Int
elem :: (Foldable t, Eq a) => a -> t a -> Bool
maximum :: (Foldable t, Ord a) => t a -> a
minimum :: (Foldable t, Ord a) => t a -> a
sum :: (Foldable t, Num a) => t a -> a
product :: (Foldable t, Num a) => t a -> a
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a
class Enum a
succ :: Enum a => a -> a
pred :: Enum a => a -> a
toEnum :: Enum a => Int -> a
fromEnum :: Enum a => a -> Int
enumFrom :: Enum a => a -> [a]
enumFromThen :: Enum a => a -> a -> [a]
enumFromTo :: Enum a => a -> a -> [a]
enumFromThenTo :: Enum a => a -> a -> a -> [a]
class Fractional a => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a
class (RealFrac a, Floating a) => RealFloat a
floatRadix :: RealFloat a => a -> Integer
floatDigits :: RealFloat a => a -> Int
floatRange :: RealFloat a => a -> (Int, Int)
decodeFloat :: RealFloat a => a -> (Integer, Int)
encodeFloat :: RealFloat a => Integer -> Int -> a
exponent :: RealFloat a => a -> Int
significand :: RealFloat a => a -> a
scaleFloat :: RealFloat a => Int -> a -> a
isNaN :: RealFloat a => a -> Bool
isInfinite :: RealFloat a => a -> Bool
isDenormalized :: RealFloat a => a -> Bool
isNegativeZero :: RealFloat a => a -> Bool
isIEEE :: RealFloat a => a -> Bool
atan2 :: RealFloat a => a -> a -> a
type FilePath = String
type IOError = IOException
class Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a
negate :: Num a => a -> a
abs :: Num a => a -> a
signum :: Num a => a -> a
fromInteger :: Num a => Integer -> a
class Read a
readsPrec :: Read a => Int -> ReadS a
readList :: Read a => ReadS [a]
class Num a => Fractional a
(/) :: Fractional a => a -> a -> a
recip :: Fractional a => a -> a
fromRational :: Fractional a => Rational -> a
class (Real a, Enum a) => Integral a
quot :: Integral a => a -> a -> a
rem :: Integral a => a -> a -> a
div :: Integral a => a -> a -> a
mod :: Integral a => a -> a -> a
quotRem :: Integral a => a -> a -> (a, a)
divMod :: Integral a => a -> a -> (a, a)
toInteger :: Integral a => a -> Integer
type Rational = Ratio Integer
class (Num a, Ord a) => Real a
toRational :: Real a => a -> Rational
class (Real a, Fractional a) => RealFrac a
properFraction :: (RealFrac a, Integral b) => a -> (b, a)
truncate :: (RealFrac a, Integral b) => a -> b
round :: (RealFrac a, Integral b) => a -> b
ceiling :: (RealFrac a, Integral b) => a -> b
floor :: (RealFrac a, Integral b) => a -> b
class Show a
showsPrec :: Show a => Int -> a -> ShowS
show :: Show a => a -> String
showList :: Show a => [a] -> ShowS
type ShowS = String -> String
type ReadS a = String -> [(a, String)]
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
data IO a
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering
data Integer
type String = [Char]
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
data Bool
False :: Bool
True :: Bool
data Char
data Double
data Float
data Int
data Word
class a ~# b => (a :: k) ~ (b :: k)
class Functor f => Applicative (f :: Type -> Type)
pure :: Applicative f => a -> f a
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
(*>) :: Applicative f => f a -> f b -> f b
(<*) :: Applicative f => f a -> f b -> f a
bitDefault :: (Bits a, Num a) => Int -> a
popCountDefault :: (Bits a, Num a) => a -> Int
testBitDefault :: (Bits a, Num a) => a -> Int -> Bool
toIntegralSized :: (Integral a, Integral b, Bits a, Bits b) => a -> Maybe b
class Eq a => Bits a
(.&.) :: Bits a => a -> a -> a
(.|.) :: Bits a => a -> a -> a
xor :: Bits a => a -> a -> a
complement :: Bits a => a -> a
shift :: Bits a => a -> Int -> a
rotate :: Bits a => a -> Int -> a
zeroBits :: Bits a => a
complementBit :: Bits a => a -> Int -> a
testBit :: Bits a => a -> Int -> Bool
bitSizeMaybe :: Bits a => a -> Maybe Int
bitSize :: Bits a => a -> Int
isSigned :: Bits a => a -> Bool
unsafeShiftL :: Bits a => a -> Int -> a
unsafeShiftR :: Bits a => a -> Int -> a
rotateL :: Bits a => a -> Int -> a
rotateR :: Bits a => a -> Int -> a
popCount :: Bits a => a -> Int
class Bits b => FiniteBits b
finiteBitSize :: FiniteBits b => b -> Int
countLeadingZeros :: FiniteBits b => b -> Int
countTrailingZeros :: FiniteBits b => b -> Int
bit :: (Num a, Bits a) => Int -> a
shiftL :: Bits a => a -> Int -> a
shiftR :: Bits a => a -> Int -> a
setBit :: (Num a, Bits a) => a -> Int -> a
clearBit :: (Num a, Bits a) => a -> Int -> a
head :: HasCallStack => [a] -> a
tail :: HasCallStack => [a] -> [a]

module GHC.Data.FastMutInt
data FastMutInt
newFastMutInt :: Int -> IO FastMutInt
readFastMutInt :: FastMutInt -> IO Int
writeFastMutInt :: FastMutInt -> Int -> IO ()
atomicFetchAddFastMut :: FastMutInt -> Int -> IO Int

module GHC.Data.Bool
data OverridingBool
Auto :: OverridingBool
Never :: OverridingBool
Always :: OverridingBool
overrideWith :: Bool -> OverridingBool -> Bool
instance GHC.Internal.Enum.Bounded GHC.Data.Bool.OverridingBool
instance GHC.Internal.Enum.Enum GHC.Data.Bool.OverridingBool
instance GHC.Classes.Eq GHC.Data.Bool.OverridingBool
instance GHC.Classes.Ord GHC.Data.Bool.OverridingBool
instance GHC.Internal.Read.Read GHC.Data.Bool.OverridingBool
instance GHC.Internal.Show.Show GHC.Data.Bool.OverridingBool

module GHC.Settings.Config
cBuildPlatformString :: String
cHostPlatformString :: String
cProjectName :: String
cBooterVersion :: String
cStage :: String
cProjectUnitId :: String

module GHC.Utils.Constants
debugIsOn :: Bool
ghciSupported :: Bool
isWindowsHost :: Bool
isDarwinHost :: Bool


module GHC.Utils.Containers.Internal.BitUtil
bitcount :: Int -> Word64 -> Int

-- | Return a word where only the highest bit is set.
highestBitMask :: Word64 -> Word64
shiftLL :: Word64 -> Int -> Word64
shiftRL :: Word64 -> Int -> Word64


-- | A strict pair
module GHC.Utils.Containers.Internal.StrictPair

-- | The same as a regular Haskell pair, but
--   
--   <pre>
--   (x :*: _|_) = (_|_ :*: y) = _|_
--   </pre>
data StrictPair a b
(:*:) :: !a -> !b -> StrictPair a b
infixr 1 :*:

-- | Convert a strict pair to a standard pair.
toPair :: StrictPair a b -> (a, b)


-- | <h1>WARNING</h1>
--   
--   This module is considered <b>internal</b>.
--   
--   The Package Versioning Policy <b>does not apply</b>.
--   
--   The contents of this module may change <b>in any way whatsoever</b>
--   and <b>without any warning</b> between minor versions of this package.
--   
--   Authors importing this module are expected to track development
--   closely.
--   
--   <h1>Description</h1>
--   
--   An efficient implementation of integer sets.
--   
--   These modules are intended to be imported qualified, to avoid name
--   clashes with Prelude functions, e.g.
--   
--   <pre>
--   import Data.Word64Set (Word64Set)
--   import qualified Data.Word64Set as Word64Set
--   </pre>
--   
--   The implementation is based on <i>big-endian patricia trees</i>. This
--   data structure performs especially well on binary operations like
--   <a>union</a> and <a>intersection</a>. However, my benchmarks show that
--   it is also (much) faster on insertions and deletions when compared to
--   a generic size-balanced set implementation (see <a>Data.Set</a>).
--   
--   <ul>
--   <li>Chris Okasaki and Andy Gill, "<i>Fast Mergeable Integer Maps</i>",
--   Workshop on ML, September 1998, pages 77-86,
--   <a>http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.5452</a></li>
--   <li>D.R. Morrison, "<i>PATRICIA -- Practical Algorithm To Retrieve
--   Information Coded In Alphanumeric</i>", Journal of the ACM, 15(4),
--   October 1968, pages 514-534.</li>
--   </ul>
--   
--   Additionally, this implementation places bitmaps in the leaves of the
--   tree. Their size is the natural size of a machine word (32 or 64 bits)
--   and greatly reduce memory footprint and execution times for dense
--   sets, e.g. sets where it is likely that many values lie close to each
--   other. The asymptotics are not affected by this optimization.
--   
--   Many operations have a worst-case complexity of &lt;math&gt;. This
--   means that the operation can become linear in the number of elements
--   with a maximum of &lt;math&gt; -- the number of bits in an <a>Int</a>
--   (32 or 64).
module GHC.Data.Word64Set.Internal

-- | A set of integers.
data Word64Set
Bin :: {-# UNPACK #-} !Prefix -> {-# UNPACK #-} !Mask -> !Word64Set -> !Word64Set -> Word64Set
Tip :: {-# UNPACK #-} !Prefix -> {-# UNPACK #-} !BitMap -> Word64Set
Nil :: Word64Set
type Key = Word64
type Prefix = Word64
type Mask = Word64
type BitMap = Word64

-- | &lt;math&gt;. See <a>difference</a>.
(\\) :: Word64Set -> Word64Set -> Word64Set
infixl 9 \\

-- | &lt;math&gt;. Is the set empty?
null :: Word64Set -> Bool

-- | &lt;math&gt;. Cardinality of the set.
size :: Word64Set -> Int

-- | &lt;math&gt;. Is the value a member of the set?
member :: Key -> Word64Set -> Bool

-- | &lt;math&gt;. Is the element not in the set?
notMember :: Key -> Word64Set -> Bool

-- | &lt;math&gt;. Find largest element smaller than the given one.
--   
--   <pre>
--   lookupLT 3 (fromList [3, 5]) == Nothing
--   lookupLT 5 (fromList [3, 5]) == Just 3
--   </pre>
lookupLT :: Key -> Word64Set -> Maybe Key

-- | &lt;math&gt;. Find smallest element greater than the given one.
--   
--   <pre>
--   lookupGT 4 (fromList [3, 5]) == Just 5
--   lookupGT 5 (fromList [3, 5]) == Nothing
--   </pre>
lookupGT :: Key -> Word64Set -> Maybe Key

-- | &lt;math&gt;. Find largest element smaller or equal to the given one.
--   
--   <pre>
--   lookupLE 2 (fromList [3, 5]) == Nothing
--   lookupLE 4 (fromList [3, 5]) == Just 3
--   lookupLE 5 (fromList [3, 5]) == Just 5
--   </pre>
lookupLE :: Key -> Word64Set -> Maybe Key

-- | &lt;math&gt;. Find smallest element greater or equal to the given one.
--   
--   <pre>
--   lookupGE 3 (fromList [3, 5]) == Just 3
--   lookupGE 4 (fromList [3, 5]) == Just 5
--   lookupGE 6 (fromList [3, 5]) == Nothing
--   </pre>
lookupGE :: Key -> Word64Set -> Maybe Key

-- | &lt;math&gt;. Is this a subset? <tt>(s1 `isSubsetOf` s2)</tt> tells
--   whether <tt>s1</tt> is a subset of <tt>s2</tt>.
isSubsetOf :: Word64Set -> Word64Set -> Bool

-- | &lt;math&gt;. Is this a proper subset? (ie. a subset but not equal).
isProperSubsetOf :: Word64Set -> Word64Set -> Bool

-- | &lt;math&gt;. Check whether two sets are disjoint (i.e. their
--   intersection is empty).
--   
--   <pre>
--   disjoint (fromList [2,4,6])   (fromList [1,3])     == True
--   disjoint (fromList [2,4,6,8]) (fromList [2,3,5,7]) == False
--   disjoint (fromList [1,2])     (fromList [1,2,3,4]) == False
--   disjoint (fromList [])        (fromList [])        == True
--   </pre>
disjoint :: Word64Set -> Word64Set -> Bool

-- | &lt;math&gt;. The empty set.
empty :: Word64Set

-- | &lt;math&gt;. A set of one element.
singleton :: Key -> Word64Set

-- | &lt;math&gt;. Add a value to the set. There is no left- or right bias
--   for Word64Sets.
insert :: Key -> Word64Set -> Word64Set

-- | &lt;math&gt;. Delete a value in the set. Returns the original set when
--   the value was not present.
delete :: Key -> Word64Set -> Word64Set

-- | &lt;math&gt;. <tt>(<a>alterF</a> f x s)</tt> can delete or insert
--   <tt>x</tt> in <tt>s</tt> depending on whether it is already present in
--   <tt>s</tt>.
--   
--   In short:
--   
--   <pre>
--   <a>member</a> x &lt;$&gt; <a>alterF</a> f x s = f (<a>member</a> x s)
--   </pre>
--   
--   Note: <a>alterF</a> is a variant of the <tt>at</tt> combinator from
--   <a>Control.Lens.At</a>.
alterF :: Functor f => (Bool -> f Bool) -> Key -> Word64Set -> f Word64Set

-- | &lt;math&gt;. The union of two sets.
union :: Word64Set -> Word64Set -> Word64Set

-- | The union of a list of sets.
unions :: [Word64Set] -> Word64Set

-- | &lt;math&gt;. Difference between two sets.
difference :: Word64Set -> Word64Set -> Word64Set

-- | &lt;math&gt;. The intersection of two sets.
intersection :: Word64Set -> Word64Set -> Word64Set

-- | &lt;math&gt;. Filter all elements that satisfy some predicate.
filter :: (Key -> Bool) -> Word64Set -> Word64Set

-- | &lt;math&gt;. partition the set according to some predicate.
partition :: (Key -> Bool) -> Word64Set -> (Word64Set, Word64Set)

-- | &lt;math&gt;. Take while a predicate on the elements holds. The user
--   is responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   takeWhileAntitone p = <a>fromDistinctAscList</a> . <a>takeWhile</a> p . <a>toList</a>
--   takeWhileAntitone p = <a>filter</a> p
--   </pre>
takeWhileAntitone :: (Key -> Bool) -> Word64Set -> Word64Set

-- | &lt;math&gt;. Drop while a predicate on the elements holds. The user
--   is responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   dropWhileAntitone p = <a>fromDistinctAscList</a> . <a>dropWhile</a> p . <a>toList</a>
--   dropWhileAntitone p = <a>filter</a> (not . p)
--   </pre>
dropWhileAntitone :: (Key -> Bool) -> Word64Set -> Word64Set

-- | &lt;math&gt;. Divide a set at the point where a predicate on the
--   elements stops holding. The user is responsible for ensuring that for
--   all <tt>Int</tt>s, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>.
--   
--   <pre>
--   spanAntitone p xs = (<a>takeWhileAntitone</a> p xs, <a>dropWhileAntitone</a> p xs)
--   spanAntitone p xs = <a>partition</a> p xs
--   </pre>
--   
--   Note: if <tt>p</tt> is not actually antitone, then
--   <tt>spanAntitone</tt> will split the set at some <i>unspecified</i>
--   point.
spanAntitone :: (Key -> Bool) -> Word64Set -> (Word64Set, Word64Set)

-- | &lt;math&gt;. The expression (<tt><a>split</a> x set</tt>) is a pair
--   <tt>(set1,set2)</tt> where <tt>set1</tt> comprises the elements of
--   <tt>set</tt> less than <tt>x</tt> and <tt>set2</tt> comprises the
--   elements of <tt>set</tt> greater than <tt>x</tt>.
--   
--   <pre>
--   split 3 (fromList [1..5]) == (fromList [1,2], fromList [4,5])
--   </pre>
split :: Key -> Word64Set -> (Word64Set, Word64Set)

-- | &lt;math&gt;. Performs a <a>split</a> but also returns whether the
--   pivot element was found in the original set.
splitMember :: Key -> Word64Set -> (Word64Set, Bool, Word64Set)

-- | &lt;math&gt;. Decompose a set into pieces based on the structure of
--   the underlying tree. This function is useful for consuming a set in
--   parallel.
--   
--   No guarantee is made as to the sizes of the pieces; an internal, but
--   deterministic process determines this. However, it is guaranteed that
--   the pieces returned will be in ascending order (all elements in the
--   first submap less than all elements in the second, and so on).
--   
--   Examples:
--   
--   <pre>
--   splitRoot (fromList [1..120]) == [fromList [1..63],fromList [64..120]]
--   splitRoot empty == []
--   </pre>
--   
--   Note that the current implementation does not return more than two
--   subsets, but you should not depend on this behaviour because it can
--   change in the future without notice. Also, the current version does
--   not continue splitting all the way to individual singleton sets -- it
--   stops at some point.
splitRoot :: Word64Set -> [Word64Set]

-- | &lt;math&gt;. <tt><a>map</a> f s</tt> is the set obtained by applying
--   <tt>f</tt> to each element of <tt>s</tt>.
--   
--   It's worth noting that the size of the result may be smaller if, for
--   some <tt>(x,y)</tt>, <tt>x /= y &amp;&amp; f x == f y</tt>
map :: (Key -> Key) -> Word64Set -> Word64Set

-- | &lt;math&gt;. The
--   
--   <tt><a>mapMonotonic</a> f s == <a>map</a> f s</tt>, but works only
--   when <tt>f</tt> is strictly increasing. <i>The precondition is not
--   checked.</i> Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
--                       ==&gt; mapMonotonic f s == map f s
--       where ls = toList s
--   </pre>
mapMonotonic :: (Key -> Key) -> Word64Set -> Word64Set

-- | &lt;math&gt;. Fold the elements in the set using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   toAscList set = foldr (:) [] set
--   </pre>
foldr :: (Key -> b -> b) -> b -> Word64Set -> b

-- | &lt;math&gt;. Fold the elements in the set using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   toDescList set = foldl (flip (:)) [] set
--   </pre>
foldl :: (a -> Key -> a) -> a -> Word64Set -> a

-- | &lt;math&gt;. A strict version of <a>foldr</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldr' :: (Key -> b -> b) -> b -> Word64Set -> b

-- | &lt;math&gt;. A strict version of <a>foldl</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldl' :: (a -> Key -> a) -> a -> Word64Set -> a

-- | &lt;math&gt;. Fold the elements in the set using the given
--   right-associative binary operator. This function is an equivalent of
--   <a>foldr</a> and is present for compatibility only.
--   
--   <i>Please note that fold will be deprecated in the future and
--   removed.</i>
fold :: (Key -> b -> b) -> b -> Word64Set -> b

-- | &lt;math&gt;. The minimal element of the set.
findMin :: Word64Set -> Key

-- | &lt;math&gt;. The maximal element of a set.
findMax :: Word64Set -> Key

-- | &lt;math&gt;. Delete the minimal element. Returns an empty set if the
--   set is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Set</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Set</a> was already empty.
deleteMin :: Word64Set -> Word64Set

-- | &lt;math&gt;. Delete the maximal element. Returns an empty set if the
--   set is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Set</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Set</a> was already empty.
deleteMax :: Word64Set -> Word64Set

-- | &lt;math&gt;. Delete and find the minimal element.
--   
--   <pre>
--   deleteFindMin set = (findMin set, deleteMin set)
--   </pre>
deleteFindMin :: Word64Set -> (Key, Word64Set)

-- | &lt;math&gt;. Delete and find the maximal element.
--   
--   <pre>
--   deleteFindMax set = (findMax set, deleteMax set)
--   </pre>
deleteFindMax :: Word64Set -> (Key, Word64Set)

-- | &lt;math&gt;. Retrieves the maximal key of the set, and the set
--   stripped of that element, or <a>Nothing</a> if passed an empty set.
maxView :: Word64Set -> Maybe (Key, Word64Set)

-- | &lt;math&gt;. Retrieves the minimal key of the set, and the set
--   stripped of that element, or <a>Nothing</a> if passed an empty set.
minView :: Word64Set -> Maybe (Key, Word64Set)

-- | &lt;math&gt;. An alias of <a>toAscList</a>. The elements of a set in
--   ascending order. Subject to list fusion.
elems :: Word64Set -> [Key]

-- | &lt;math&gt;. Convert the set to a list of elements. Subject to list
--   fusion.
toList :: Word64Set -> [Key]

-- | &lt;math&gt;. Create a set from a list of integers.
fromList :: [Key] -> Word64Set

-- | &lt;math&gt;. Convert the set to an ascending list of elements.
--   Subject to list fusion.
toAscList :: Word64Set -> [Key]

-- | &lt;math&gt;. Convert the set to a descending list of elements.
--   Subject to list fusion.
toDescList :: Word64Set -> [Key]

-- | &lt;math&gt;. Build a set from an ascending list of elements. <i>The
--   precondition (input list is ascending) is not checked.</i>
fromAscList :: [Key] -> Word64Set

-- | &lt;math&gt;. Build a set from an ascending list of distinct elements.
--   <i>The precondition (input list is strictly ascending) is not
--   checked.</i>
fromDistinctAscList :: [Key] -> Word64Set

-- | &lt;math&gt;. Show the tree that implements the set. The tree is shown
--   in a compressed, hanging format.
showTree :: Word64Set -> String

-- | &lt;math&gt;. The expression (<tt><a>showTreeWith</a> hang wide
--   map</tt>) shows the tree that implements the set. If <tt>hang</tt> is
--   <a>True</a>, a <i>hanging</i> tree is shown otherwise a rotated tree
--   is shown. If <tt>wide</tt> is <a>True</a>, an extra wide version is
--   shown.
showTreeWith :: Bool -> Bool -> Word64Set -> String
match :: Word64 -> Prefix -> Mask -> Bool
suffixBitMask :: Word64
prefixBitMask :: Word64
bitmapOf :: Word64 -> BitMap
zero :: Word64 -> Mask -> Bool
instance GHC.Internal.Data.Data.Data GHC.Data.Word64Set.Internal.Word64Set
instance GHC.Classes.Eq GHC.Data.Word64Set.Internal.Word64Set
instance GHC.Internal.IsList.IsList GHC.Data.Word64Set.Internal.Word64Set
instance GHC.Internal.Base.Monoid GHC.Data.Word64Set.Internal.Word64Set
instance Control.DeepSeq.NFData GHC.Data.Word64Set.Internal.Word64Set
instance GHC.Classes.Ord GHC.Data.Word64Set.Internal.Word64Set
instance GHC.Internal.Read.Read GHC.Data.Word64Set.Internal.Word64Set
instance GHC.Internal.Base.Semigroup GHC.Data.Word64Set.Internal.Word64Set
instance GHC.Internal.Show.Show GHC.Data.Word64Set.Internal.Word64Set


-- | <h1>Finite Int Sets</h1>
--   
--   The <tt><a>Word64Set</a></tt> type represents a set of elements of
--   type <tt>Int</tt>.
--   
--   For a walkthrough of the most commonly used functions see their
--   <a>sets introduction</a>.
--   
--   These modules are intended to be imported qualified, to avoid name
--   clashes with Prelude functions, e.g.
--   
--   <pre>
--   import Data.Word64Set (Word64Set)
--   import qualified Data.Word64Set as Word64Set
--   </pre>
--   
--   <h2>Performance information</h2>
--   
--   Many operations have a worst-case complexity of &lt;math&gt;. This
--   means that the operation can become linear in the number of elements
--   with a maximum of &lt;math&gt; -- the number of bits in an
--   <tt>Int</tt> (32 or 64).
--   
--   <h2>Implementation</h2>
--   
--   The implementation is based on <i>big-endian patricia trees</i>. This
--   data structure performs especially well on binary operations like
--   <a>union</a> and <a>intersection</a>. However, my benchmarks show that
--   it is also (much) faster on insertions and deletions when compared to
--   a generic size-balanced set implementation (see <a>Data.Set</a>).
--   
--   <ul>
--   <li>Chris Okasaki and Andy Gill, "<i>Fast Mergeable Integer Maps</i>",
--   Workshop on ML, September 1998, pages 77-86,
--   <a>http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.5452</a></li>
--   <li>D.R. Morrison, "<i>PATRICIA -- Practical Algorithm To Retrieve
--   Information Coded In Alphanumeric</i>", Journal of the ACM, 15(4),
--   October 1968, pages 514-534.</li>
--   </ul>
--   
--   Additionally, this implementation places bitmaps in the leaves of the
--   tree. Their size is the natural size of a machine word (32 or 64 bits)
--   and greatly reduces the memory footprint and execution times for dense
--   sets, e.g. sets where it is likely that many values lie close to each
--   other. The asymptotics are not affected by this optimization.
module GHC.Data.Word64Set

-- | A set of integers.
data Word64Set
type Key = Word64

-- | &lt;math&gt;. The empty set.
empty :: Word64Set

-- | &lt;math&gt;. A set of one element.
singleton :: Key -> Word64Set

-- | &lt;math&gt;. Create a set from a list of integers.
fromList :: [Key] -> Word64Set

-- | &lt;math&gt;. Build a set from an ascending list of elements. <i>The
--   precondition (input list is ascending) is not checked.</i>
fromAscList :: [Key] -> Word64Set

-- | &lt;math&gt;. Build a set from an ascending list of distinct elements.
--   <i>The precondition (input list is strictly ascending) is not
--   checked.</i>
fromDistinctAscList :: [Key] -> Word64Set

-- | &lt;math&gt;. Add a value to the set. There is no left- or right bias
--   for Word64Sets.
insert :: Key -> Word64Set -> Word64Set

-- | &lt;math&gt;. Delete a value in the set. Returns the original set when
--   the value was not present.
delete :: Key -> Word64Set -> Word64Set

-- | &lt;math&gt;. <tt>(<a>alterF</a> f x s)</tt> can delete or insert
--   <tt>x</tt> in <tt>s</tt> depending on whether it is already present in
--   <tt>s</tt>.
--   
--   In short:
--   
--   <pre>
--   <a>member</a> x &lt;$&gt; <a>alterF</a> f x s = f (<a>member</a> x s)
--   </pre>
--   
--   Note: <a>alterF</a> is a variant of the <tt>at</tt> combinator from
--   <a>Control.Lens.At</a>.
alterF :: Functor f => (Bool -> f Bool) -> Key -> Word64Set -> f Word64Set

-- | &lt;math&gt;. Is the value a member of the set?
member :: Key -> Word64Set -> Bool

-- | &lt;math&gt;. Is the element not in the set?
notMember :: Key -> Word64Set -> Bool

-- | &lt;math&gt;. Find largest element smaller than the given one.
--   
--   <pre>
--   lookupLT 3 (fromList [3, 5]) == Nothing
--   lookupLT 5 (fromList [3, 5]) == Just 3
--   </pre>
lookupLT :: Key -> Word64Set -> Maybe Key

-- | &lt;math&gt;. Find smallest element greater than the given one.
--   
--   <pre>
--   lookupGT 4 (fromList [3, 5]) == Just 5
--   lookupGT 5 (fromList [3, 5]) == Nothing
--   </pre>
lookupGT :: Key -> Word64Set -> Maybe Key

-- | &lt;math&gt;. Find largest element smaller or equal to the given one.
--   
--   <pre>
--   lookupLE 2 (fromList [3, 5]) == Nothing
--   lookupLE 4 (fromList [3, 5]) == Just 3
--   lookupLE 5 (fromList [3, 5]) == Just 5
--   </pre>
lookupLE :: Key -> Word64Set -> Maybe Key

-- | &lt;math&gt;. Find smallest element greater or equal to the given one.
--   
--   <pre>
--   lookupGE 3 (fromList [3, 5]) == Just 3
--   lookupGE 4 (fromList [3, 5]) == Just 5
--   lookupGE 6 (fromList [3, 5]) == Nothing
--   </pre>
lookupGE :: Key -> Word64Set -> Maybe Key

-- | &lt;math&gt;. Is the set empty?
null :: Word64Set -> Bool

-- | &lt;math&gt;. Cardinality of the set.
size :: Word64Set -> Int

-- | &lt;math&gt;. Is this a subset? <tt>(s1 `isSubsetOf` s2)</tt> tells
--   whether <tt>s1</tt> is a subset of <tt>s2</tt>.
isSubsetOf :: Word64Set -> Word64Set -> Bool

-- | &lt;math&gt;. Is this a proper subset? (ie. a subset but not equal).
isProperSubsetOf :: Word64Set -> Word64Set -> Bool

-- | &lt;math&gt;. Check whether two sets are disjoint (i.e. their
--   intersection is empty).
--   
--   <pre>
--   disjoint (fromList [2,4,6])   (fromList [1,3])     == True
--   disjoint (fromList [2,4,6,8]) (fromList [2,3,5,7]) == False
--   disjoint (fromList [1,2])     (fromList [1,2,3,4]) == False
--   disjoint (fromList [])        (fromList [])        == True
--   </pre>
disjoint :: Word64Set -> Word64Set -> Bool

-- | &lt;math&gt;. The union of two sets.
union :: Word64Set -> Word64Set -> Word64Set

-- | The union of a list of sets.
unions :: [Word64Set] -> Word64Set

-- | &lt;math&gt;. Difference between two sets.
difference :: Word64Set -> Word64Set -> Word64Set

-- | &lt;math&gt;. See <a>difference</a>.
(\\) :: Word64Set -> Word64Set -> Word64Set
infixl 9 \\

-- | &lt;math&gt;. The intersection of two sets.
intersection :: Word64Set -> Word64Set -> Word64Set

-- | &lt;math&gt;. Filter all elements that satisfy some predicate.
filter :: (Key -> Bool) -> Word64Set -> Word64Set

-- | &lt;math&gt;. partition the set according to some predicate.
partition :: (Key -> Bool) -> Word64Set -> (Word64Set, Word64Set)

-- | &lt;math&gt;. Take while a predicate on the elements holds. The user
--   is responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   takeWhileAntitone p = <a>fromDistinctAscList</a> . <a>takeWhile</a> p . <a>toList</a>
--   takeWhileAntitone p = <a>filter</a> p
--   </pre>
takeWhileAntitone :: (Key -> Bool) -> Word64Set -> Word64Set

-- | &lt;math&gt;. Drop while a predicate on the elements holds. The user
--   is responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   dropWhileAntitone p = <a>fromDistinctAscList</a> . <a>dropWhile</a> p . <a>toList</a>
--   dropWhileAntitone p = <a>filter</a> (not . p)
--   </pre>
dropWhileAntitone :: (Key -> Bool) -> Word64Set -> Word64Set

-- | &lt;math&gt;. Divide a set at the point where a predicate on the
--   elements stops holding. The user is responsible for ensuring that for
--   all <tt>Int</tt>s, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>.
--   
--   <pre>
--   spanAntitone p xs = (<a>takeWhileAntitone</a> p xs, <a>dropWhileAntitone</a> p xs)
--   spanAntitone p xs = <a>partition</a> p xs
--   </pre>
--   
--   Note: if <tt>p</tt> is not actually antitone, then
--   <tt>spanAntitone</tt> will split the set at some <i>unspecified</i>
--   point.
spanAntitone :: (Key -> Bool) -> Word64Set -> (Word64Set, Word64Set)

-- | &lt;math&gt;. The expression (<tt><a>split</a> x set</tt>) is a pair
--   <tt>(set1,set2)</tt> where <tt>set1</tt> comprises the elements of
--   <tt>set</tt> less than <tt>x</tt> and <tt>set2</tt> comprises the
--   elements of <tt>set</tt> greater than <tt>x</tt>.
--   
--   <pre>
--   split 3 (fromList [1..5]) == (fromList [1,2], fromList [4,5])
--   </pre>
split :: Key -> Word64Set -> (Word64Set, Word64Set)

-- | &lt;math&gt;. Performs a <a>split</a> but also returns whether the
--   pivot element was found in the original set.
splitMember :: Key -> Word64Set -> (Word64Set, Bool, Word64Set)

-- | &lt;math&gt;. Decompose a set into pieces based on the structure of
--   the underlying tree. This function is useful for consuming a set in
--   parallel.
--   
--   No guarantee is made as to the sizes of the pieces; an internal, but
--   deterministic process determines this. However, it is guaranteed that
--   the pieces returned will be in ascending order (all elements in the
--   first submap less than all elements in the second, and so on).
--   
--   Examples:
--   
--   <pre>
--   splitRoot (fromList [1..120]) == [fromList [1..63],fromList [64..120]]
--   splitRoot empty == []
--   </pre>
--   
--   Note that the current implementation does not return more than two
--   subsets, but you should not depend on this behaviour because it can
--   change in the future without notice. Also, the current version does
--   not continue splitting all the way to individual singleton sets -- it
--   stops at some point.
splitRoot :: Word64Set -> [Word64Set]

-- | &lt;math&gt;. <tt><a>map</a> f s</tt> is the set obtained by applying
--   <tt>f</tt> to each element of <tt>s</tt>.
--   
--   It's worth noting that the size of the result may be smaller if, for
--   some <tt>(x,y)</tt>, <tt>x /= y &amp;&amp; f x == f y</tt>
map :: (Key -> Key) -> Word64Set -> Word64Set

-- | &lt;math&gt;. The
--   
--   <tt><a>mapMonotonic</a> f s == <a>map</a> f s</tt>, but works only
--   when <tt>f</tt> is strictly increasing. <i>The precondition is not
--   checked.</i> Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
--                       ==&gt; mapMonotonic f s == map f s
--       where ls = toList s
--   </pre>
mapMonotonic :: (Key -> Key) -> Word64Set -> Word64Set

-- | &lt;math&gt;. Fold the elements in the set using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   toAscList set = foldr (:) [] set
--   </pre>
foldr :: (Key -> b -> b) -> b -> Word64Set -> b

-- | &lt;math&gt;. Fold the elements in the set using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   toDescList set = foldl (flip (:)) [] set
--   </pre>
foldl :: (a -> Key -> a) -> a -> Word64Set -> a

-- | &lt;math&gt;. A strict version of <a>foldr</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldr' :: (Key -> b -> b) -> b -> Word64Set -> b

-- | &lt;math&gt;. A strict version of <a>foldl</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldl' :: (a -> Key -> a) -> a -> Word64Set -> a

-- | &lt;math&gt;. Fold the elements in the set using the given
--   right-associative binary operator. This function is an equivalent of
--   <a>foldr</a> and is present for compatibility only.
--   
--   <i>Please note that fold will be deprecated in the future and
--   removed.</i>
fold :: (Key -> b -> b) -> b -> Word64Set -> b

-- | &lt;math&gt;. The minimal element of the set.
findMin :: Word64Set -> Key

-- | &lt;math&gt;. The maximal element of a set.
findMax :: Word64Set -> Key

-- | &lt;math&gt;. Delete the minimal element. Returns an empty set if the
--   set is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Set</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Set</a> was already empty.
deleteMin :: Word64Set -> Word64Set

-- | &lt;math&gt;. Delete the maximal element. Returns an empty set if the
--   set is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Set</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Set</a> was already empty.
deleteMax :: Word64Set -> Word64Set

-- | &lt;math&gt;. Delete and find the minimal element.
--   
--   <pre>
--   deleteFindMin set = (findMin set, deleteMin set)
--   </pre>
deleteFindMin :: Word64Set -> (Key, Word64Set)

-- | &lt;math&gt;. Delete and find the maximal element.
--   
--   <pre>
--   deleteFindMax set = (findMax set, deleteMax set)
--   </pre>
deleteFindMax :: Word64Set -> (Key, Word64Set)

-- | &lt;math&gt;. Retrieves the maximal key of the set, and the set
--   stripped of that element, or <a>Nothing</a> if passed an empty set.
maxView :: Word64Set -> Maybe (Key, Word64Set)

-- | &lt;math&gt;. Retrieves the minimal key of the set, and the set
--   stripped of that element, or <a>Nothing</a> if passed an empty set.
minView :: Word64Set -> Maybe (Key, Word64Set)

-- | &lt;math&gt;. An alias of <a>toAscList</a>. The elements of a set in
--   ascending order. Subject to list fusion.
elems :: Word64Set -> [Key]

-- | &lt;math&gt;. Convert the set to a list of elements. Subject to list
--   fusion.
toList :: Word64Set -> [Key]

-- | &lt;math&gt;. Convert the set to an ascending list of elements.
--   Subject to list fusion.
toAscList :: Word64Set -> [Key]

-- | &lt;math&gt;. Convert the set to a descending list of elements.
--   Subject to list fusion.
toDescList :: Word64Set -> [Key]

-- | &lt;math&gt;. Show the tree that implements the set. The tree is shown
--   in a compressed, hanging format.
showTree :: Word64Set -> String

-- | &lt;math&gt;. The expression (<tt><a>showTreeWith</a> hang wide
--   map</tt>) shows the tree that implements the set. If <tt>hang</tt> is
--   <a>True</a>, a <i>hanging</i> tree is shown otherwise a rotated tree
--   is shown. If <tt>wide</tt> is <a>True</a>, an extra wide version is
--   shown.
showTreeWith :: Bool -> Bool -> Word64Set -> String


-- | <h1>WARNING</h1>
--   
--   This module is considered <b>internal</b>.
--   
--   The Package Versioning Policy <b>does not apply</b>.
--   
--   The contents of this module may change <b>in any way whatsoever</b>
--   and <b>without any warning</b> between minor versions of this package.
--   
--   Authors importing this module are expected to track development
--   closely.
--   
--   <h1>Description</h1>
--   
--   This defines the data structures and core (hidden) manipulations on
--   representations.
module GHC.Data.Word64Map.Internal

-- | A map of integers to values <tt>a</tt>.
data Word64Map a
Bin :: {-# UNPACK #-} !Prefix -> {-# UNPACK #-} !Mask -> !Word64Map a -> !Word64Map a -> Word64Map a
Tip :: {-# UNPACK #-} !Key -> a -> Word64Map a
Nil :: Word64Map a
type Key = Word64

-- | &lt;math&gt;. Find the value at a key. Calls <a>error</a> when the
--   element can not be found.
--   
--   <pre>
--   fromList [(5,'a'), (3,'b')] ! 1    Error: element not in the map
--   fromList [(5,'a'), (3,'b')] ! 5 == 'a'
--   </pre>
(!) :: Word64Map a -> Key -> a

-- | &lt;math&gt;. Find the value at a key. Returns <a>Nothing</a> when the
--   element can not be found.
--   
--   <pre>
--   fromList [(5,'a'), (3,'b')] !? 1 == Nothing
--   fromList [(5,'a'), (3,'b')] !? 5 == Just 'a'
--   </pre>
(!?) :: Word64Map a -> Key -> Maybe a
infixl 9 !?

-- | Same as <a>difference</a>.
(\\) :: Word64Map a -> Word64Map b -> Word64Map a
infixl 9 \\

-- | &lt;math&gt;. Is the map empty?
--   
--   <pre>
--   Data.Word64Map.null (empty)           == True
--   Data.Word64Map.null (singleton 1 'a') == False
--   </pre>
null :: Word64Map a -> Bool

-- | &lt;math&gt;. Number of elements in the map.
--   
--   <pre>
--   size empty                                   == 0
--   size (singleton 1 'a')                       == 1
--   size (fromList([(1,'a'), (2,'c'), (3,'b')])) == 3
--   </pre>
size :: Word64Map a -> Int

-- | &lt;math&gt;. Is the key a member of the map?
--   
--   <pre>
--   member 5 (fromList [(5,'a'), (3,'b')]) == True
--   member 1 (fromList [(5,'a'), (3,'b')]) == False
--   </pre>
member :: Key -> Word64Map a -> Bool

-- | &lt;math&gt;. Is the key not a member of the map?
--   
--   <pre>
--   notMember 5 (fromList [(5,'a'), (3,'b')]) == False
--   notMember 1 (fromList [(5,'a'), (3,'b')]) == True
--   </pre>
notMember :: Key -> Word64Map a -> Bool

-- | &lt;math&gt;. Lookup the value at a key in the map. See also
--   <a>lookup</a>.
lookup :: Key -> Word64Map a -> Maybe a

-- | &lt;math&gt;. The expression <tt>(<a>findWithDefault</a> def k
--   map)</tt> returns the value at key <tt>k</tt> or returns <tt>def</tt>
--   when the key is not an element of the map.
--   
--   <pre>
--   findWithDefault 'x' 1 (fromList [(5,'a'), (3,'b')]) == 'x'
--   findWithDefault 'x' 5 (fromList [(5,'a'), (3,'b')]) == 'a'
--   </pre>
findWithDefault :: a -> Key -> Word64Map a -> a

-- | &lt;math&gt;. Find largest key smaller than the given one and return
--   the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLT 3 (fromList [(3,'a'), (5,'b')]) == Nothing
--   lookupLT 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   </pre>
lookupLT :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find smallest key greater than the given one and return
--   the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGT 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   lookupGT 5 (fromList [(3,'a'), (5,'b')]) == Nothing
--   </pre>
lookupGT :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find largest key smaller or equal to the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLE 2 (fromList [(3,'a'), (5,'b')]) == Nothing
--   lookupLE 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   lookupLE 5 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   </pre>
lookupLE :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find smallest key greater or equal to the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGE 3 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   lookupGE 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   lookupGE 6 (fromList [(3,'a'), (5,'b')]) == Nothing
--   </pre>
lookupGE :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Check whether the key sets of two maps are disjoint
--   (i.e. their <a>intersection</a> is empty).
--   
--   <pre>
--   disjoint (fromList [(2,'a')]) (fromList [(1,()), (3,())])   == True
--   disjoint (fromList [(2,'a')]) (fromList [(1,'a'), (2,'b')]) == False
--   disjoint (fromList [])        (fromList [])                 == True
--   </pre>
--   
--   <pre>
--   disjoint a b == null (intersection a b)
--   </pre>
disjoint :: Word64Map a -> Word64Map b -> Bool

-- | &lt;math&gt;. The empty map.
--   
--   <pre>
--   empty      == fromList []
--   size empty == 0
--   </pre>
empty :: Word64Map a

-- | &lt;math&gt;. A map of one element.
--   
--   <pre>
--   singleton 1 'a'        == fromList [(1, 'a')]
--   size (singleton 1 'a') == 1
--   </pre>
singleton :: Key -> a -> Word64Map a

-- | &lt;math&gt;. Insert a new key/value pair in the map. If the key is
--   already present in the map, the associated value is replaced with the
--   supplied value, i.e. <a>insert</a> is equivalent to
--   <tt><a>insertWith</a> <a>const</a></tt>.
--   
--   <pre>
--   insert 5 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'x')]
--   insert 7 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'a'), (7, 'x')]
--   insert 5 'x' empty                         == singleton 5 'x'
--   </pre>
insert :: Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Insert with a combining function. <tt><a>insertWith</a>
--   f key value mp</tt> will insert the pair (key, value) into <tt>mp</tt>
--   if key does not exist in the map. If the key does exist, the function
--   will insert <tt>f new_value old_value</tt>.
--   
--   <pre>
--   insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "xxxa")]
--   insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWith (++) 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
insertWith :: (a -> a -> a) -> Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Insert with a combining function.
--   <tt><a>insertWithKey</a> f key value mp</tt> will insert the pair
--   (key, value) into <tt>mp</tt> if key does not exist in the map. If the
--   key does exist, the function will insert <tt>f key new_value
--   old_value</tt>.
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:xxx|a")]
--   insertWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWithKey f 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>insertLookupWithKey</a> f k x
--   map</tt>) is a pair where the first element is equal to
--   (<tt><a>lookup</a> k map</tt>) and the second element equal to
--   (<tt><a>insertWithKey</a> f k x map</tt>).
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertLookupWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:xxx|a")])
--   insertLookupWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "xxx")])
--   insertLookupWithKey f 5 "xxx" empty                         == (Nothing,  singleton 5 "xxx")
--   </pre>
--   
--   This is how to define <tt>insertLookup</tt> using
--   <tt>insertLookupWithKey</tt>:
--   
--   <pre>
--   let insertLookup kx x t = insertLookupWithKey (\_ a _ -&gt; a) kx x t
--   insertLookup 5 "x" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "x")])
--   insertLookup 7 "x" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "x")])
--   </pre>
insertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> Word64Map a -> (Maybe a, Word64Map a)

-- | &lt;math&gt;. Delete a key and its value from the map. When the key is
--   not a member of the map, the original map is returned.
--   
--   <pre>
--   delete 5 (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   delete 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   delete 5 empty                         == empty
--   </pre>
delete :: Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Adjust a value at a specific key. When the key is not a
--   member of the map, the original map is returned.
--   
--   <pre>
--   adjust ("new " ++) 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
--   adjust ("new " ++) 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   adjust ("new " ++) 7 empty                         == empty
--   </pre>
adjust :: (a -> a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Adjust a value at a specific key. When the key is not a
--   member of the map, the original map is returned.
--   
--   <pre>
--   let f key x = (show key) ++ ":new " ++ x
--   adjustWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
--   adjustWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   adjustWithKey f 7 empty                         == empty
--   </pre>
adjustWithKey :: (Key -> a -> a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>update</a> f k map</tt>) updates
--   the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If (<tt>f
--   x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   update f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
--   update f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   update f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
update :: (a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>update</a> f k map</tt>) updates
--   the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If (<tt>f k
--   x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
--   updateWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   updateWithKey f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateWithKey :: (Key -> a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Lookup and update. The function returns original value,
--   if it is updated. This is different behavior than
--   <a>updateLookupWithKey</a>. Returns the original key value if the map
--   entry is deleted.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateLookupWithKey f 5 (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:new a")])
--   updateLookupWithKey f 7 (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a")])
--   updateLookupWithKey f 3 (fromList [(5,"a"), (3,"b")]) == (Just "b", singleton 5 "a")
--   </pre>
updateLookupWithKey :: (Key -> a -> Maybe a) -> Key -> Word64Map a -> (Maybe a, Word64Map a)

-- | &lt;math&gt;. The expression (<tt><a>alter</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alter</a>
--   can be used to insert, delete, or update a value in an
--   <a>Word64Map</a>. In short : <tt><a>lookup</a> k (<a>alter</a> f k m)
--   = f (<a>lookup</a> k m)</tt>.
alter :: (Maybe a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>alterF</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alterF</a>
--   can be used to inspect, insert, delete, or update a value in an
--   <a>Word64Map</a>. In short : <tt><a>lookup</a> k <a>$</a>
--   <a>alterF</a> f k m = f (<a>lookup</a> k m)</tt>.
--   
--   Example:
--   
--   <pre>
--   interactiveAlter :: Int -&gt; Word64Map String -&gt; IO (Word64Map String)
--   interactiveAlter k m = alterF f k m where
--     f Nothing = do
--        putStrLn $ show k ++
--            " was not found in the map. Would you like to add it?"
--        getUserResponse1 :: IO (Maybe String)
--     f (Just old) = do
--        putStrLn $ "The key is currently bound to " ++ show old ++
--            ". Would you like to change or delete it?"
--        getUserResponse2 :: IO (Maybe String)
--   </pre>
--   
--   <a>alterF</a> is the most general operation for working with an
--   individual key that may or may not be in a given map.
--   
--   Note: <a>alterF</a> is a flipped version of the <tt>at</tt> combinator
--   from <tt>Control.Lens.At</tt>.
alterF :: Functor f => (Maybe a -> f (Maybe a)) -> Key -> Word64Map a -> f (Word64Map a)

-- | &lt;math&gt;. The (left-biased) union of two maps. It prefers the
--   first map when duplicate keys are encountered, i.e. (<tt><a>union</a>
--   == <a>unionWith</a> <a>const</a></tt>).
--   
--   <pre>
--   union (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "a"), (7, "C")]
--   </pre>
union :: Word64Map a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The union with a combining function.
--   
--   <pre>
--   unionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "aA"), (7, "C")]
--   </pre>
unionWith :: (a -> a -> a) -> Word64Map a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The union with a combining function.
--   
--   <pre>
--   let f key left_value right_value = (show key) ++ ":" ++ left_value ++ "|" ++ right_value
--   unionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "5:a|A"), (7, "C")]
--   </pre>
unionWithKey :: (Key -> a -> a -> a) -> Word64Map a -> Word64Map a -> Word64Map a

-- | The union of a list of maps.
--   
--   <pre>
--   unions [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
--       == fromList [(3, "b"), (5, "a"), (7, "C")]
--   unions [(fromList [(5, "A3"), (3, "B3")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "a"), (3, "b")])]
--       == fromList [(3, "B3"), (5, "A3"), (7, "C")]
--   </pre>
unions :: Foldable f => f (Word64Map a) -> Word64Map a

-- | The union of a list of maps, with a combining operation.
--   
--   <pre>
--   unionsWith (++) [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
--       == fromList [(3, "bB3"), (5, "aAA3"), (7, "C")]
--   </pre>
unionsWith :: Foldable f => (a -> a -> a) -> f (Word64Map a) -> Word64Map a

-- | &lt;math&gt;. Difference between two maps (based on keys).
--   
--   <pre>
--   difference (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 3 "b"
--   </pre>
difference :: Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. Difference with a combining function.
--   
--   <pre>
--   let f al ar = if al == "b" then Just (al ++ ":" ++ ar) else Nothing
--   differenceWith f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (7, "C")])
--       == singleton 3 "b:B"
--   </pre>
differenceWith :: (a -> b -> Maybe a) -> Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. Difference with a combining function. When two equal
--   keys are encountered, the combining function is applied to the key and
--   both values. If it returns <a>Nothing</a>, the element is discarded
--   (proper set difference). If it returns (<tt><a>Just</a> y</tt>), the
--   element is updated with a new value <tt>y</tt>.
--   
--   <pre>
--   let f k al ar = if al == "b" then Just ((show k) ++ ":" ++ al ++ "|" ++ ar) else Nothing
--   differenceWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (10, "C")])
--       == singleton 3 "3:b|B"
--   </pre>
differenceWithKey :: (Key -> a -> b -> Maybe a) -> Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. The (left-biased) intersection of two maps (based on
--   keys).
--   
--   <pre>
--   intersection (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "a"
--   </pre>
intersection :: Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. The intersection with a combining function.
--   
--   <pre>
--   intersectionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "aA"
--   </pre>
intersectionWith :: (a -> b -> c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. The intersection with a combining function.
--   
--   <pre>
--   let f k al ar = (show k) ++ ":" ++ al ++ "|" ++ ar
--   intersectionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "5:a|A"
--   </pre>
intersectionWithKey :: (Key -> a -> b -> c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | Relate the keys of one map to the values of the other, by using the
--   values of the former as keys for lookups in the latter.
--   
--   Complexity: &lt;math&gt;, where &lt;math&gt; is the size of the first
--   argument
--   
--   <pre>
--   compose (fromList [('a', "A"), ('b', "B")]) (fromList [(1,'a'),(2,'b'),(3,'z')]) = fromList [(1,"A"),(2,"B")]
--   </pre>
--   
--   <pre>
--   (<a>compose</a> bc ab <a>!?</a>) = (bc <a>!?</a>) &lt;=&lt; (ab <a>!?</a>)
--   </pre>
--   
--   <b>Note:</b> Prior to v0.6.4, <a>Data.Word64Map.Strict</a> exposed a
--   version of <a>compose</a> that forced the values of the output
--   <a>Word64Map</a>. This version does not force these values.
compose :: Word64Map c -> Word64Map Word64 -> Word64Map c

-- | A tactic for dealing with keys present in one map but not the other in
--   <a>merge</a>.
--   
--   A tactic of type <tt>SimpleWhenMissing x z</tt> is an abstract
--   representation of a function of type <tt>Key -&gt; x -&gt; Maybe
--   z</tt>.
type SimpleWhenMissing = WhenMissing Identity

-- | A tactic for dealing with keys present in both maps in <a>merge</a>.
--   
--   A tactic of type <tt>SimpleWhenMatched x y z</tt> is an abstract
--   representation of a function of type <tt>Key -&gt; x -&gt; y -&gt;
--   Maybe z</tt>.
type SimpleWhenMatched = WhenMatched Identity

-- | Along with zipWithMaybeAMatched, witnesses the isomorphism between
--   <tt>WhenMatched f x y z</tt> and <tt>Key -&gt; x -&gt; y -&gt; f
--   (Maybe z)</tt>.
runWhenMatched :: WhenMatched f x y z -> Key -> x -> y -> f (Maybe z)

-- | Along with traverseMaybeMissing, witnesses the isomorphism between
--   <tt>WhenMissing f x y</tt> and <tt>Key -&gt; x -&gt; f (Maybe y)</tt>.
runWhenMissing :: WhenMissing f x y -> Key -> x -> f (Maybe y)

-- | Merge two maps.
--   
--   <a>merge</a> takes two <a>WhenMissing</a> tactics, a
--   <a>WhenMatched</a> tactic and two maps. It uses the tactics to merge
--   the maps. Its behavior is best understood via its fundamental tactics,
--   <a>mapMaybeMissing</a> and <a>zipWithMaybeMatched</a>.
--   
--   Consider
--   
--   <pre>
--   merge (mapMaybeMissing g1)
--                (mapMaybeMissing g2)
--                (zipWithMaybeMatched f)
--                m1 m2
--   </pre>
--   
--   Take, for example,
--   
--   <pre>
--   m1 = [(0, 'a'), (1, 'b'), (3, 'c'), (4, 'd')]
--   m2 = [(1, "one"), (2, "two"), (4, "three")]
--   </pre>
--   
--   <a>merge</a> will first "align" these maps by key:
--   
--   <pre>
--   m1 = [(0, 'a'), (1, 'b'),               (3, 'c'), (4, 'd')]
--   m2 =           [(1, "one"), (2, "two"),           (4, "three")]
--   </pre>
--   
--   It will then pass the individual entries and pairs of entries to
--   <tt>g1</tt>, <tt>g2</tt>, or <tt>f</tt> as appropriate:
--   
--   <pre>
--   maybes = [g1 0 'a', f 1 'b' "one", g2 2 "two", g1 3 'c', f 4 'd' "three"]
--   </pre>
--   
--   This produces a <a>Maybe</a> for each key:
--   
--   <pre>
--   keys =     0        1          2           3        4
--   results = [Nothing, Just True, Just False, Nothing, Just True]
--   </pre>
--   
--   Finally, the <tt>Just</tt> results are collected into a map:
--   
--   <pre>
--   return value = [(1, True), (2, False), (4, True)]
--   </pre>
--   
--   The other tactics below are optimizations or simplifications of
--   <a>mapMaybeMissing</a> for special cases. Most importantly,
--   
--   <ul>
--   <li><a>dropMissing</a> drops all the keys.</li>
--   <li><a>preserveMissing</a> leaves all the entries alone.</li>
--   </ul>
--   
--   When <a>merge</a> is given three arguments, it is inlined at the call
--   site. To prevent excessive inlining, you should typically use
--   <a>merge</a> to define your custom combining functions.
--   
--   Examples:
--   
--   <pre>
--   unionWithKey f = merge preserveMissing preserveMissing (zipWithMatched f)
--   </pre>
--   
--   <pre>
--   intersectionWithKey f = merge dropMissing dropMissing (zipWithMatched f)
--   </pre>
--   
--   <pre>
--   differenceWith f = merge diffPreserve diffDrop f
--   </pre>
--   
--   <pre>
--   symmetricDifference = merge diffPreserve diffPreserve (\ _ _ _ -&gt; Nothing)
--   </pre>
--   
--   <pre>
--   mapEachPiece f g h = merge (diffMapWithKey f) (diffMapWithKey g)
--   </pre>
merge :: SimpleWhenMissing a c -> SimpleWhenMissing b c -> SimpleWhenMatched a b c -> Word64Map a -> Word64Map b -> Word64Map c

-- | When a key is found in both maps, apply a function to the key and
--   values and maybe use the result in the merged map.
--   
--   <pre>
--   zipWithMaybeMatched
--     :: (Key -&gt; x -&gt; y -&gt; Maybe z)
--     -&gt; SimpleWhenMatched x y z
--   </pre>
zipWithMaybeMatched :: forall (f :: Type -> Type) x y z. Applicative f => (Key -> x -> y -> Maybe z) -> WhenMatched f x y z

-- | When a key is found in both maps, apply a function to the key and
--   values and use the result in the merged map.
--   
--   <pre>
--   zipWithMatched
--     :: (Key -&gt; x -&gt; y -&gt; z)
--     -&gt; SimpleWhenMatched x y z
--   </pre>
zipWithMatched :: forall (f :: Type -> Type) x y z. Applicative f => (Key -> x -> y -> z) -> WhenMatched f x y z

-- | Map over the entries whose keys are missing from the other map,
--   optionally removing some. This is the most powerful
--   <a>SimpleWhenMissing</a> tactic, but others are usually more
--   efficient.
--   
--   <pre>
--   mapMaybeMissing :: (Key -&gt; x -&gt; Maybe y) -&gt; SimpleWhenMissing x y
--   </pre>
--   
--   <pre>
--   mapMaybeMissing f = traverseMaybeMissing (\k x -&gt; pure (f k x))
--   </pre>
--   
--   but <tt>mapMaybeMissing</tt> uses fewer unnecessary <a>Applicative</a>
--   operations.
mapMaybeMissing :: forall (f :: Type -> Type) x y. Applicative f => (Key -> x -> Maybe y) -> WhenMissing f x y

-- | Drop all the entries whose keys are missing from the other map.
--   
--   <pre>
--   dropMissing :: SimpleWhenMissing x y
--   </pre>
--   
--   <pre>
--   dropMissing = mapMaybeMissing (\_ _ -&gt; Nothing)
--   </pre>
--   
--   but <tt>dropMissing</tt> is much faster.
dropMissing :: forall (f :: Type -> Type) x y. Applicative f => WhenMissing f x y

-- | Preserve, unchanged, the entries whose keys are missing from the other
--   map.
--   
--   <pre>
--   preserveMissing :: SimpleWhenMissing x x
--   </pre>
--   
--   <pre>
--   preserveMissing = Merge.Lazy.mapMaybeMissing (\_ x -&gt; Just x)
--   </pre>
--   
--   but <tt>preserveMissing</tt> is much faster.
preserveMissing :: forall (f :: Type -> Type) x. Applicative f => WhenMissing f x x

-- | Map over the entries whose keys are missing from the other map.
--   
--   <pre>
--   mapMissing :: (k -&gt; x -&gt; y) -&gt; SimpleWhenMissing x y
--   </pre>
--   
--   <pre>
--   mapMissing f = mapMaybeMissing (\k x -&gt; Just $ f k x)
--   </pre>
--   
--   but <tt>mapMissing</tt> is somewhat faster.
mapMissing :: forall (f :: Type -> Type) x y. Applicative f => (Key -> x -> y) -> WhenMissing f x y

-- | Filter the entries whose keys are missing from the other map.
--   
--   <pre>
--   filterMissing :: (k -&gt; x -&gt; Bool) -&gt; SimpleWhenMissing x x
--   </pre>
--   
--   <pre>
--   filterMissing f = Merge.Lazy.mapMaybeMissing $ \k x -&gt; guard (f k x) *&gt; Just x
--   </pre>
--   
--   but this should be a little faster.
filterMissing :: forall (f :: Type -> Type) x. Applicative f => (Key -> x -> Bool) -> WhenMissing f x x

-- | A tactic for dealing with keys present in one map but not the other in
--   <a>merge</a> or <a>mergeA</a>.
--   
--   A tactic of type <tt>WhenMissing f k x z</tt> is an abstract
--   representation of a function of type <tt>Key -&gt; x -&gt; f (Maybe
--   z)</tt>.
data WhenMissing (f :: Type -> Type) x y
WhenMissing :: (Word64Map x -> f (Word64Map y)) -> (Key -> x -> f (Maybe y)) -> WhenMissing (f :: Type -> Type) x y
[missingSubtree] :: WhenMissing (f :: Type -> Type) x y -> Word64Map x -> f (Word64Map y)
[missingKey] :: WhenMissing (f :: Type -> Type) x y -> Key -> x -> f (Maybe y)

-- | A tactic for dealing with keys present in both maps in <a>merge</a> or
--   <a>mergeA</a>.
--   
--   A tactic of type <tt>WhenMatched f x y z</tt> is an abstract
--   representation of a function of type <tt>Key -&gt; x -&gt; y -&gt; f
--   (Maybe z)</tt>.
newtype WhenMatched (f :: Type -> Type) x y z
WhenMatched :: (Key -> x -> y -> f (Maybe z)) -> WhenMatched (f :: Type -> Type) x y z
[matchedKey] :: WhenMatched (f :: Type -> Type) x y z -> Key -> x -> y -> f (Maybe z)

-- | An applicative version of <a>merge</a>.
--   
--   <a>mergeA</a> takes two <a>WhenMissing</a> tactics, a
--   <a>WhenMatched</a> tactic and two maps. It uses the tactics to merge
--   the maps. Its behavior is best understood via its fundamental tactics,
--   <a>traverseMaybeMissing</a> and <a>zipWithMaybeAMatched</a>.
--   
--   Consider
--   
--   <pre>
--   mergeA (traverseMaybeMissing g1)
--                 (traverseMaybeMissing g2)
--                 (zipWithMaybeAMatched f)
--                 m1 m2
--   </pre>
--   
--   Take, for example,
--   
--   <pre>
--   m1 = [(0, 'a'), (1, 'b'), (3,'c'), (4, 'd')]
--   m2 = [(1, "one"), (2, "two"), (4, "three")]
--   </pre>
--   
--   <a>mergeA</a> will first "align" these maps by key:
--   
--   <pre>
--   m1 = [(0, 'a'), (1, 'b'),               (3, 'c'), (4, 'd')]
--   m2 =           [(1, "one"), (2, "two"),           (4, "three")]
--   </pre>
--   
--   It will then pass the individual entries and pairs of entries to
--   <tt>g1</tt>, <tt>g2</tt>, or <tt>f</tt> as appropriate:
--   
--   <pre>
--   actions = [g1 0 'a', f 1 'b' "one", g2 2 "two", g1 3 'c', f 4 'd' "three"]
--   </pre>
--   
--   Next, it will perform the actions in the <tt>actions</tt> list in
--   order from left to right.
--   
--   <pre>
--   keys =     0        1          2           3        4
--   results = [Nothing, Just True, Just False, Nothing, Just True]
--   </pre>
--   
--   Finally, the <tt>Just</tt> results are collected into a map:
--   
--   <pre>
--   return value = [(1, True), (2, False), (4, True)]
--   </pre>
--   
--   The other tactics below are optimizations or simplifications of
--   <a>traverseMaybeMissing</a> for special cases. Most importantly,
--   
--   <ul>
--   <li><a>dropMissing</a> drops all the keys.</li>
--   <li><a>preserveMissing</a> leaves all the entries alone.</li>
--   <li><a>mapMaybeMissing</a> does not use the <a>Applicative</a>
--   context.</li>
--   </ul>
--   
--   When <a>mergeA</a> is given three arguments, it is inlined at the call
--   site. To prevent excessive inlining, you should generally only use
--   <a>mergeA</a> to define custom combining functions.
mergeA :: Applicative f => WhenMissing f a c -> WhenMissing f b c -> WhenMatched f a b c -> Word64Map a -> Word64Map b -> f (Word64Map c)

-- | When a key is found in both maps, apply a function to the key and
--   values, perform the resulting action, and maybe use the result in the
--   merged map.
--   
--   This is the fundamental <a>WhenMatched</a> tactic.
zipWithMaybeAMatched :: (Key -> x -> y -> f (Maybe z)) -> WhenMatched f x y z

-- | When a key is found in both maps, apply a function to the key and
--   values to produce an action and use its result in the merged map.
zipWithAMatched :: Applicative f => (Key -> x -> y -> f z) -> WhenMatched f x y z

-- | Traverse over the entries whose keys are missing from the other map,
--   optionally producing values to put in the result. This is the most
--   powerful <a>WhenMissing</a> tactic, but others are usually more
--   efficient.
traverseMaybeMissing :: Applicative f => (Key -> x -> f (Maybe y)) -> WhenMissing f x y

-- | Traverse over the entries whose keys are missing from the other map.
traverseMissing :: Applicative f => (Key -> x -> f y) -> WhenMissing f x y

-- | Filter the entries whose keys are missing from the other map using
--   some <a>Applicative</a> action.
--   
--   <pre>
--   filterAMissing f = Merge.Lazy.traverseMaybeMissing $
--     \k x -&gt; (\b -&gt; guard b *&gt; Just x) &lt;$&gt; f k x
--   </pre>
--   
--   but this should be a little faster.
filterAMissing :: Applicative f => (Key -> x -> f Bool) -> WhenMissing f x x

-- | &lt;math&gt;. A high-performance universal combining function. Using
--   <a>mergeWithKey</a>, all combining functions can be defined without
--   any loss of efficiency (with exception of <a>union</a>,
--   <a>difference</a> and <a>intersection</a>, where sharing of some nodes
--   is lost with <a>mergeWithKey</a>).
--   
--   Please make sure you know what is going on when using
--   <a>mergeWithKey</a>, otherwise you can be surprised by unexpected code
--   growth or even corruption of the data structure.
--   
--   When <a>mergeWithKey</a> is given three arguments, it is inlined to
--   the call site. You should therefore use <a>mergeWithKey</a> only to
--   define your custom combining functions. For example, you could define
--   <a>unionWithKey</a>, <a>differenceWithKey</a> and
--   <a>intersectionWithKey</a> as
--   
--   <pre>
--   myUnionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) id id m1 m2
--   myDifferenceWithKey f m1 m2 = mergeWithKey f id (const empty) m1 m2
--   myIntersectionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) (const empty) (const empty) m1 m2
--   </pre>
--   
--   When calling <tt><a>mergeWithKey</a> combine only1 only2</tt>, a
--   function combining two <a>Word64Map</a>s is created, such that
--   
--   <ul>
--   <li>if a key is present in both maps, it is passed with both
--   corresponding values to the <tt>combine</tt> function. Depending on
--   the result, the key is either present in the result with specified
--   value, or is left out;</li>
--   <li>a nonempty subtree present only in the first map is passed to
--   <tt>only1</tt> and the output is added to the result;</li>
--   <li>a nonempty subtree present only in the second map is passed to
--   <tt>only2</tt> and the output is added to the result.</li>
--   </ul>
--   
--   The <tt>only1</tt> and <tt>only2</tt> methods <i>must return a map
--   with a subset (possibly empty) of the keys of the given map</i>. The
--   values can be modified arbitrarily. Most common variants of
--   <tt>only1</tt> and <tt>only2</tt> are <a>id</a> and <tt><a>const</a>
--   <a>empty</a></tt>, but for example <tt><a>map</a> f</tt> or
--   <tt><a>filterWithKey</a> f</tt> could be used for any <tt>f</tt>.
mergeWithKey :: (Key -> a -> b -> Maybe c) -> (Word64Map a -> Word64Map c) -> (Word64Map b -> Word64Map c) -> Word64Map a -> Word64Map b -> Word64Map c
mergeWithKey' :: (Prefix -> Mask -> Word64Map c -> Word64Map c -> Word64Map c) -> (Word64Map a -> Word64Map b -> Word64Map c) -> (Word64Map a -> Word64Map c) -> (Word64Map b -> Word64Map c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. Map a function over all values in the map.
--   
--   <pre>
--   map (++ "x") (fromList [(5,"a"), (3,"b")]) == fromList [(3, "bx"), (5, "ax")]
--   </pre>
map :: (a -> b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map a function over all values in the map.
--   
--   <pre>
--   let f key x = (show key) ++ ":" ++ x
--   mapWithKey f (fromList [(5,"a"), (3,"b")]) == fromList [(3, "3:b"), (5, "5:a")]
--   </pre>
mapWithKey :: (Key -> a -> b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. <tt><a>traverseWithKey</a> f s == <a>fromList</a>
--   <a>$</a> <a>traverse</a> ((k, v) -&gt; (,) k <a>$</a> f k v)
--   (<a>toList</a> m)</tt> That is, behaves exactly like a regular
--   <a>traverse</a> except that the traversing function also has access to
--   the key associated with a value.
--   
--   <pre>
--   traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(1, 'a'), (5, 'e')]) == Just (fromList [(1, 'b'), (5, 'f')])
--   traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(2, 'c')])           == Nothing
--   </pre>
traverseWithKey :: Applicative t => (Key -> a -> t b) -> Word64Map a -> t (Word64Map b)

-- | &lt;math&gt;. Traverse keys/values and collect the <a>Just</a>
--   results.
traverseMaybeWithKey :: Applicative f => (Key -> a -> f (Maybe b)) -> Word64Map a -> f (Word64Map b)

-- | &lt;math&gt;. The function <tt><a>mapAccum</a></tt> threads an
--   accumulating argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a b = (a ++ b, b ++ "X")
--   mapAccum f "Everything: " (fromList [(5,"a"), (3,"b")]) == ("Everything: ba", fromList [(3, "bX"), (5, "aX")])
--   </pre>
mapAccum :: (a -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. The function <tt><a>mapAccumWithKey</a></tt> threads an
--   accumulating argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a k b = (a ++ " " ++ (show k) ++ "-" ++ b, b ++ "X")
--   mapAccumWithKey f "Everything:" (fromList [(5,"a"), (3,"b")]) == ("Everything: 3-b 5-a", fromList [(3, "bX"), (5, "aX")])
--   </pre>
mapAccumWithKey :: (a -> Key -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. The function <tt><a>mapAccumRWithKey</a></tt> threads an
--   accumulating argument through the map in descending order of keys.
mapAccumRWithKey :: (a -> Key -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. <tt><a>mapKeys</a> f s</tt> is the map obtained by
--   applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the value at the
--   greatest of the original keys is retained.
--   
--   <pre>
--   mapKeys (+ 1) (fromList [(5,"a"), (3,"b")])                        == fromList [(4, "b"), (6, "a")]
--   mapKeys (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "c"
--   mapKeys (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "c"
--   </pre>
mapKeys :: (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. <tt><a>mapKeysWith</a> c f s</tt> is the map obtained by
--   applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the associated values
--   will be combined using <tt>c</tt>.
--   
--   <pre>
--   mapKeysWith (++) (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "cdab"
--   mapKeysWith (++) (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "cdab"
--   </pre>
mapKeysWith :: (a -> a -> a) -> (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. <tt><a>mapKeysMonotonic</a> f s == <a>mapKeys</a> f
--   s</tt>, but works only when <tt>f</tt> is strictly monotonic. That is,
--   for any values <tt>x</tt> and <tt>y</tt>, if <tt>x</tt> &lt;
--   <tt>y</tt> then <tt>f x</tt> &lt; <tt>f y</tt>. <i>The precondition is
--   not checked.</i> Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
--                       ==&gt; mapKeysMonotonic f s == mapKeys f s
--       where ls = keys s
--   </pre>
--   
--   This means that <tt>f</tt> maps distinct original keys to distinct
--   resulting keys. This function has slightly better performance than
--   <a>mapKeys</a>.
--   
--   <pre>
--   mapKeysMonotonic (\ k -&gt; k * 2) (fromList [(5,"a"), (3,"b")]) == fromList [(6, "b"), (10, "a")]
--   </pre>
mapKeysMonotonic :: (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Fold the values in the map using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>elems</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elems map = foldr (:) [] map
--   </pre>
--   
--   <pre>
--   let f a len = len + (length a)
--   foldr f 0 (fromList [(5,"a"), (3,"bbb")]) == 4
--   </pre>
foldr :: (a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. Fold the values in the map using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>elems</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elems = reverse . foldl (flip (:)) []
--   </pre>
--   
--   <pre>
--   let f len a = len + (length a)
--   foldl f 0 (fromList [(5,"a"), (3,"bbb")]) == 4
--   </pre>
foldl :: (a -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   right-associative binary operator, such that <tt><a>foldrWithKey</a> f
--   z == <a>foldr</a> (<a>uncurry</a> f) z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keys map = foldrWithKey (\k x ks -&gt; k:ks) [] map
--   </pre>
--   
--   <pre>
--   let f k a result = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
--   foldrWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (5:a)(3:b)"
--   </pre>
foldrWithKey :: (Key -> a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   left-associative binary operator, such that <tt><a>foldlWithKey</a> f
--   z == <a>foldl</a> (\z' (kx, x) -&gt; f z' kx x) z .
--   <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keys = reverse . foldlWithKey (\ks k x -&gt; k:ks) []
--   </pre>
--   
--   <pre>
--   let f result k a = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
--   foldlWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (3:b)(5:a)"
--   </pre>
foldlWithKey :: (a -> Key -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   monoid, such that
--   
--   <pre>
--   <a>foldMapWithKey</a> f = <a>fold</a> . <a>mapWithKey</a> f
--   </pre>
--   
--   This can be an asymptotically faster than <a>foldrWithKey</a> or
--   <a>foldlWithKey</a> for some monoids.
foldMapWithKey :: Monoid m => (Key -> a -> m) -> Word64Map a -> m

-- | &lt;math&gt;. A strict version of <a>foldr</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldr' :: (a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. A strict version of <a>foldl</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldl' :: (a -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. A strict version of <a>foldrWithKey</a>. Each
--   application of the operator is evaluated before using the result in
--   the next application. This function is strict in the starting value.
foldrWithKey' :: (Key -> a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. A strict version of <a>foldlWithKey</a>. Each
--   application of the operator is evaluated before using the result in
--   the next application. This function is strict in the starting value.
foldlWithKey' :: (a -> Key -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Return all elements of the map in the ascending order of
--   their keys. Subject to list fusion.
--   
--   <pre>
--   elems (fromList [(5,"a"), (3,"b")]) == ["b","a"]
--   elems empty == []
--   </pre>
elems :: Word64Map a -> [a]

-- | &lt;math&gt;. Return all keys of the map in ascending order. Subject
--   to list fusion.
--   
--   <pre>
--   keys (fromList [(5,"a"), (3,"b")]) == [3,5]
--   keys empty == []
--   </pre>
keys :: Word64Map a -> [Key]

-- | &lt;math&gt;. An alias for <a>toAscList</a>. Returns all key/value
--   pairs in the map in ascending key order. Subject to list fusion.
--   
--   <pre>
--   assocs (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   assocs empty == []
--   </pre>
assocs :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. The set of all keys of the map.
--   
--   <pre>
--   keysSet (fromList [(5,"a"), (3,"b")]) == Data.Word64Set.fromList [3,5]
--   keysSet empty == Data.Word64Set.empty
--   </pre>
keysSet :: Word64Map a -> Word64Set

-- | &lt;math&gt;. Build a map from a set of keys and a function which for
--   each key computes its value.
--   
--   <pre>
--   fromSet (\k -&gt; replicate k 'a') (Data.Word64Set.fromList [3, 5]) == fromList [(5,"aaaaa"), (3,"aaa")]
--   fromSet undefined Data.Word64Set.empty == empty
--   </pre>
fromSet :: (Key -> a) -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Convert the map to a list of key/value pairs. Subject to
--   list fusion.
--   
--   <pre>
--   toList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   toList empty == []
--   </pre>
toList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Create a map from a list of key/value pairs.
--   
--   <pre>
--   fromList [] == empty
--   fromList [(5,"a"), (3,"b"), (5, "c")] == fromList [(5,"c"), (3,"b")]
--   fromList [(5,"c"), (3,"b"), (5, "a")] == fromList [(5,"a"), (3,"b")]
--   </pre>
fromList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Create a map from a list of key/value pairs with a
--   combining function. See also <a>fromAscListWith</a>.
--   
--   <pre>
--   fromListWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")] == fromList [(3, "ab"), (5, "cba")]
--   fromListWith (++) [] == empty
--   </pre>
fromListWith :: (a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs with a
--   combining function. See also fromAscListWithKey'.
--   
--   <pre>
--   let f key new_value old_value = show key ++ ":" ++ new_value ++ "|" ++ old_value
--   fromListWithKey f [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")] == fromList [(3, "3:a|b"), (5, "5:c|5:b|a")]
--   fromListWithKey f [] == empty
--   </pre>
fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Convert the map to a list of key/value pairs where the
--   keys are in ascending order. Subject to list fusion.
--   
--   <pre>
--   toAscList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   </pre>
toAscList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Convert the map to a list of key/value pairs where the
--   keys are in descending order. Subject to list fusion.
--   
--   <pre>
--   toDescList (fromList [(5,"a"), (3,"b")]) == [(5,"a"), (3,"b")]
--   </pre>
toDescList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order.
--   
--   <pre>
--   fromAscList [(3,"b"), (5,"a")]          == fromList [(3, "b"), (5, "a")]
--   fromAscList [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "b")]
--   </pre>
fromAscList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order, with a combining function on equal keys.
--   <i>The precondition (input list is ascending) is not checked.</i>
--   
--   <pre>
--   fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]
--   </pre>
fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order, with a combining function on equal keys.
--   <i>The precondition (input list is ascending) is not checked.</i>
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   fromAscListWithKey f [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "5:b|a")]
--   </pre>
fromAscListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order and all distinct. <i>The precondition
--   (input list is strictly ascending) is not checked.</i>
--   
--   <pre>
--   fromDistinctAscList [(3,"b"), (5,"a")] == fromList [(3, "b"), (5, "a")]
--   </pre>
fromDistinctAscList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Filter all values that satisfy some predicate.
--   
--   <pre>
--   filter (&gt; "a") (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   filter (&gt; "x") (fromList [(5,"a"), (3,"b")]) == empty
--   filter (&lt; "a") (fromList [(5,"a"), (3,"b")]) == empty
--   </pre>
filter :: (a -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Filter all keys/values that satisfy some predicate.
--   
--   <pre>
--   filterWithKey (\k _ -&gt; k &gt; 4) (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
filterWithKey :: (Key -> a -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The restriction of a map to the keys in a set.
--   
--   <pre>
--   m `restrictKeys` s = <a>filterWithKey</a> (\k _ -&gt; k <a>`member`</a> s) m
--   </pre>
restrictKeys :: Word64Map a -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Remove all the keys in a given set from a map.
--   
--   <pre>
--   m `withoutKeys` s = <a>filterWithKey</a> (\k _ -&gt; k <a>`notMember`</a> s) m
--   </pre>
withoutKeys :: Word64Map a -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Partition the map according to some predicate. The first
--   map contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate. See also <a>split</a>.
--   
--   <pre>
--   partition (&gt; "a") (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
--   partition (&lt; "x") (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
--   partition (&gt; "x") (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])
--   </pre>
partition :: (a -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Partition the map according to some predicate. The first
--   map contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate. See also <a>split</a>.
--   
--   <pre>
--   partitionWithKey (\ k _ -&gt; k &gt; 3) (fromList [(5,"a"), (3,"b")]) == (singleton 5 "a", singleton 3 "b")
--   partitionWithKey (\ k _ -&gt; k &lt; 7) (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
--   partitionWithKey (\ k _ -&gt; k &gt; 7) (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])
--   </pre>
partitionWithKey :: (Key -> a -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Take while a predicate on the keys holds. The user is
--   responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   takeWhileAntitone p = <a>fromDistinctAscList</a> . <a>takeWhile</a> (p . fst) . <a>toList</a>
--   takeWhileAntitone p = <a>filterWithKey</a> (\k _ -&gt; p k)
--   </pre>
takeWhileAntitone :: (Key -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Drop while a predicate on the keys holds. The user is
--   responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   dropWhileAntitone p = <a>fromDistinctAscList</a> . <a>dropWhile</a> (p . fst) . <a>toList</a>
--   dropWhileAntitone p = <a>filterWithKey</a> (\k _ -&gt; not (p k))
--   </pre>
dropWhileAntitone :: (Key -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Divide a map at the point where a predicate on the keys
--   stops holding. The user is responsible for ensuring that for all
--   <tt>Int</tt>s, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>.
--   
--   <pre>
--   spanAntitone p xs = (<a>takeWhileAntitone</a> p xs, <a>dropWhileAntitone</a> p xs)
--   spanAntitone p xs = <a>partitionWithKey</a> (\k _ -&gt; p k) xs
--   </pre>
--   
--   Note: if <tt>p</tt> is not actually antitone, then
--   <tt>spanAntitone</tt> will split the map at some <i>unspecified</i>
--   point.
spanAntitone :: (Key -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Map values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   mapMaybe f (fromList [(5,"a"), (3,"b")]) == singleton 5 "new a"
--   </pre>
mapMaybe :: (a -> Maybe b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map keys/values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f k _ = if k &lt; 5 then Just ("key : " ++ (show k)) else Nothing
--   mapMaybeWithKey f (fromList [(5,"a"), (3,"b")]) == singleton 3 "key : 3"
--   </pre>
mapMaybeWithKey :: (Key -> a -> Maybe b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map values and separate the <a>Left</a> and <a>Right</a>
--   results.
--   
--   <pre>
--   let f a = if a &lt; "c" then Left a else Right a
--   mapEither f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (fromList [(3,"b"), (5,"a")], fromList [(1,"x"), (7,"z")])
--   
--   mapEither (\ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (empty, fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--   </pre>
mapEither :: (a -> Either b c) -> Word64Map a -> (Word64Map b, Word64Map c)

-- | &lt;math&gt;. Map keys/values and separate the <a>Left</a> and
--   <a>Right</a> results.
--   
--   <pre>
--   let f k a = if k &lt; 5 then Left (k * 2) else Right (a ++ a)
--   mapEitherWithKey f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (fromList [(1,2), (3,6)], fromList [(5,"aa"), (7,"zz")])
--   
--   mapEitherWithKey (\_ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (empty, fromList [(1,"x"), (3,"b"), (5,"a"), (7,"z")])
--   </pre>
mapEitherWithKey :: (Key -> a -> Either b c) -> Word64Map a -> (Word64Map b, Word64Map c)

-- | &lt;math&gt;. The expression (<tt><a>split</a> k map</tt>) is a pair
--   <tt>(map1,map2)</tt> where all keys in <tt>map1</tt> are lower than
--   <tt>k</tt> and all keys in <tt>map2</tt> larger than <tt>k</tt>. Any
--   key equal to <tt>k</tt> is found in neither <tt>map1</tt> nor
--   <tt>map2</tt>.
--   
--   <pre>
--   split 2 (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3,"b"), (5,"a")])
--   split 3 (fromList [(5,"a"), (3,"b")]) == (empty, singleton 5 "a")
--   split 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
--   split 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", empty)
--   split 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], empty)
--   </pre>
split :: Key -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Performs a <a>split</a> but also returns whether the
--   pivot key was found in the original map.
--   
--   <pre>
--   splitLookup 2 (fromList [(5,"a"), (3,"b")]) == (empty, Nothing, fromList [(3,"b"), (5,"a")])
--   splitLookup 3 (fromList [(5,"a"), (3,"b")]) == (empty, Just "b", singleton 5 "a")
--   splitLookup 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Nothing, singleton 5 "a")
--   splitLookup 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Just "a", empty)
--   splitLookup 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], Nothing, empty)
--   </pre>
splitLookup :: Key -> Word64Map a -> (Word64Map a, Maybe a, Word64Map a)

-- | &lt;math&gt;. Decompose a map into pieces based on the structure of
--   the underlying tree. This function is useful for consuming a map in
--   parallel.
--   
--   No guarantee is made as to the sizes of the pieces; an internal, but
--   deterministic process determines this. However, it is guaranteed that
--   the pieces returned will be in ascending order (all elements in the
--   first submap less than all elements in the second, and so on).
--   
--   Examples:
--   
--   <pre>
--   splitRoot (fromList (zip [1..6::Int] ['a'..])) ==
--     [fromList [(1,'a'),(2,'b'),(3,'c')],fromList [(4,'d'),(5,'e'),(6,'f')]]
--   </pre>
--   
--   <pre>
--   splitRoot empty == []
--   </pre>
--   
--   Note that the current implementation does not return more than two
--   submaps, but you should not depend on this behaviour because it can
--   change in the future without notice.
splitRoot :: Word64Map a -> [Word64Map a]

-- | &lt;math&gt;. Is this a submap? Defined as (<tt><a>isSubmapOf</a> =
--   <a>isSubmapOfBy</a> (==)</tt>).
isSubmapOf :: Eq a => Word64Map a -> Word64Map a -> Bool

-- | &lt;math&gt;. The expression (<tt><a>isSubmapOfBy</a> f m1 m2</tt>)
--   returns <a>True</a> if all keys in <tt>m1</tt> are in <tt>m2</tt>, and
--   when <tt>f</tt> returns <a>True</a> when applied to their respective
--   values. For example, the following expressions are all <a>True</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (&lt;=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [(1,2)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (&lt;) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
--   </pre>
isSubmapOfBy :: (a -> b -> Bool) -> Word64Map a -> Word64Map b -> Bool

-- | &lt;math&gt;. Is this a proper submap? (ie. a submap but not equal).
--   Defined as (<tt><a>isProperSubmapOf</a> = <a>isProperSubmapOfBy</a>
--   (==)</tt>).
isProperSubmapOf :: Eq a => Word64Map a -> Word64Map a -> Bool

-- | &lt;math&gt;. Is this a proper submap? (ie. a submap but not equal).
--   The expression (<tt><a>isProperSubmapOfBy</a> f m1 m2</tt>) returns
--   <a>True</a> when <tt>keys m1</tt> and <tt>keys m2</tt> are not equal,
--   all keys in <tt>m1</tt> are in <tt>m2</tt>, and when <tt>f</tt>
--   returns <a>True</a> when applied to their respective values. For
--   example, the following expressions are all <a>True</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isProperSubmapOfBy (&lt;=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
--   isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
--   isProperSubmapOfBy (&lt;)  (fromList [(1,1)])       (fromList [(1,1),(2,2)])
--   </pre>
isProperSubmapOfBy :: (a -> b -> Bool) -> Word64Map a -> Word64Map b -> Bool

-- | &lt;math&gt;. The minimal key of the map. Returns <a>Nothing</a> if
--   the map is empty.
lookupMin :: Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. The maximal key of the map. Returns <a>Nothing</a> if
--   the map is empty.
lookupMax :: Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. The minimal key of the map. Calls <a>error</a> if the
--   map is empty. Use <a>minViewWithKey</a> if the map may be empty.
findMin :: Word64Map a -> (Key, a)

-- | &lt;math&gt;. The maximal key of the map. Calls <a>error</a> if the
--   map is empty. Use <a>maxViewWithKey</a> if the map may be empty.
findMax :: Word64Map a -> (Key, a)

-- | &lt;math&gt;. Delete the minimal key. Returns an empty map if the map
--   is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Map</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Map</a> was already empty.
deleteMin :: Word64Map a -> Word64Map a

-- | &lt;math&gt;. Delete the maximal key. Returns an empty map if the map
--   is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Map</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Map</a> was already empty.
deleteMax :: Word64Map a -> Word64Map a

-- | &lt;math&gt;. Delete and find the minimal element. This function
--   throws an error if the map is empty. Use <a>minViewWithKey</a> if the
--   map may be empty.
deleteFindMin :: Word64Map a -> ((Key, a), Word64Map a)

-- | &lt;math&gt;. Delete and find the maximal element. This function
--   throws an error if the map is empty. Use <a>maxViewWithKey</a> if the
--   map may be empty.
deleteFindMax :: Word64Map a -> ((Key, a), Word64Map a)

-- | &lt;math&gt;. Update the value at the minimal key.
--   
--   <pre>
--   updateMin (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "Xb"), (5, "a")]
--   updateMin (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateMin :: (a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the maximal key.
--   
--   <pre>
--   updateMax (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "Xa")]
--   updateMax (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   </pre>
updateMax :: (a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the minimal key.
--   
--   <pre>
--   updateMinWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"3:b"), (5,"a")]
--   updateMinWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateMinWithKey :: (Key -> a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the maximal key.
--   
--   <pre>
--   updateMaxWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"b"), (5,"5:a")]
--   updateMaxWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   </pre>
updateMaxWithKey :: (Key -> a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Retrieves the minimal key of the map, and the map
--   stripped of that element, or <a>Nothing</a> if passed an empty map.
minView :: Word64Map a -> Maybe (a, Word64Map a)

-- | &lt;math&gt;. Retrieves the maximal key of the map, and the map
--   stripped of that element, or <a>Nothing</a> if passed an empty map.
maxView :: Word64Map a -> Maybe (a, Word64Map a)

-- | &lt;math&gt;. Retrieves the minimal (key,value) pair of the map, and
--   the map stripped of that element, or <a>Nothing</a> if passed an empty
--   map.
--   
--   <pre>
--   minViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((3,"b"), singleton 5 "a")
--   minViewWithKey empty == Nothing
--   </pre>
minViewWithKey :: Word64Map a -> Maybe ((Key, a), Word64Map a)

-- | &lt;math&gt;. Retrieves the maximal (key,value) pair of the map, and
--   the map stripped of that element, or <a>Nothing</a> if passed an empty
--   map.
--   
--   <pre>
--   maxViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((5,"a"), singleton 3 "b")
--   maxViewWithKey empty == Nothing
--   </pre>
maxViewWithKey :: Word64Map a -> Maybe ((Key, a), Word64Map a)

-- | &lt;math&gt;. Show the tree that implements the map. The tree is shown
--   in a compressed, hanging format.
showTree :: Show a => Word64Map a -> String

-- | &lt;math&gt;. The expression (<tt><a>showTreeWith</a> hang wide
--   map</tt>) shows the tree that implements the map. If <tt>hang</tt> is
--   <a>True</a>, a <i>hanging</i> tree is shown otherwise a rotated tree
--   is shown. If <tt>wide</tt> is <a>True</a>, an extra wide version is
--   shown.
showTreeWith :: Show a => Bool -> Bool -> Word64Map a -> String
type Mask = Word64
type Prefix = Word64
type Nat = Word64
natFromInt :: Key -> Nat
intFromNat :: Nat -> Key
link :: Prefix -> Word64Map a -> Prefix -> Word64Map a -> Word64Map a
linkWithMask :: Mask -> Prefix -> Word64Map a -> Word64Map a -> Word64Map a
bin :: Prefix -> Mask -> Word64Map a -> Word64Map a -> Word64Map a
binCheckLeft :: Prefix -> Mask -> Word64Map a -> Word64Map a -> Word64Map a
binCheckRight :: Prefix -> Mask -> Word64Map a -> Word64Map a -> Word64Map a

-- | Should this key follow the left subtree of a <a>Bin</a> with switching
--   bit <tt>m</tt>? N.B., the answer is only valid when <tt>match i p
--   m</tt> is true.
zero :: Key -> Mask -> Bool

-- | Does the key <tt>i</tt> differ from the prefix <tt>p</tt> before
--   getting to the switching bit <tt>m</tt>?
nomatch :: Key -> Prefix -> Mask -> Bool

-- | Does the key <tt>i</tt> match the prefix <tt>p</tt> (up to but not
--   including bit <tt>m</tt>)?
match :: Key -> Prefix -> Mask -> Bool

-- | The prefix of key <tt>i</tt> up to (but not including) the switching
--   bit <tt>m</tt>.
mask :: Key -> Mask -> Prefix

-- | The prefix of key <tt>i</tt> up to (but not including) the switching
--   bit <tt>m</tt>.
maskW :: Nat -> Nat -> Prefix

-- | Does the left switching bit specify a shorter prefix?
shorter :: Mask -> Mask -> Bool

-- | The first switching bit where the two prefixes disagree.
branchMask :: Prefix -> Prefix -> Mask

-- | Return a word where only the highest bit is set.
highestBitMask :: Word64 -> Word64

-- | Map covariantly over a <tt><a>WhenMissing</a> f x</tt>.
mapWhenMissing :: forall (f :: Type -> Type) a b x. (Applicative f, Monad f) => (a -> b) -> WhenMissing f x a -> WhenMissing f x b

-- | Map covariantly over a <tt><a>WhenMatched</a> f x y</tt>.
mapWhenMatched :: forall (f :: Type -> Type) a b x y. Functor f => (a -> b) -> WhenMatched f x y a -> WhenMatched f x y b

-- | Map contravariantly over a <tt><a>WhenMissing</a> f _ x</tt>.
lmapWhenMissing :: forall b a (f :: Type -> Type) x. (b -> a) -> WhenMissing f a x -> WhenMissing f b x

-- | Map contravariantly over a <tt><a>WhenMatched</a> f _ y z</tt>.
contramapFirstWhenMatched :: forall b a (f :: Type -> Type) y z. (b -> a) -> WhenMatched f a y z -> WhenMatched f b y z

-- | Map contravariantly over a <tt><a>WhenMatched</a> f x _ z</tt>.
contramapSecondWhenMatched :: forall b a (f :: Type -> Type) x z. (b -> a) -> WhenMatched f x a z -> WhenMatched f x b z

-- | Map covariantly over a <tt><a>WhenMissing</a> f x</tt>, using only a
--   'Functor f' constraint.
mapGentlyWhenMissing :: forall (f :: Type -> Type) a b x. Functor f => (a -> b) -> WhenMissing f x a -> WhenMissing f x b

-- | Map covariantly over a <tt><a>WhenMatched</a> f k x</tt>, using only a
--   'Functor f' constraint.
mapGentlyWhenMatched :: forall (f :: Type -> Type) a b x y. Functor f => (a -> b) -> WhenMatched f x y a -> WhenMatched f x y b
instance (GHC.Internal.Base.Monad f, GHC.Internal.Base.Applicative f) => GHC.Internal.Base.Applicative (GHC.Data.Word64Map.Internal.WhenMatched f x y)
instance (GHC.Internal.Base.Applicative f, GHC.Internal.Base.Monad f) => GHC.Internal.Base.Applicative (GHC.Data.Word64Map.Internal.WhenMissing f x)
instance (GHC.Internal.Base.Monad f, GHC.Internal.Base.Applicative f) => GHC.Internal.Control.Category.Category (GHC.Data.Word64Map.Internal.WhenMatched f x)
instance (GHC.Internal.Base.Applicative f, GHC.Internal.Base.Monad f) => GHC.Internal.Control.Category.Category (GHC.Data.Word64Map.Internal.WhenMissing f)
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Data.Word64Map.Internal.Word64Map a)
instance Data.Functor.Classes.Eq1 GHC.Data.Word64Map.Internal.Word64Map
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Data.Word64Map.Internal.Word64Map a)
instance GHC.Internal.Data.Foldable.Foldable GHC.Data.Word64Map.Internal.Word64Map
instance GHC.Internal.Base.Functor f => GHC.Internal.Base.Functor (GHC.Data.Word64Map.Internal.WhenMatched f x y)
instance (GHC.Internal.Base.Applicative f, GHC.Internal.Base.Monad f) => GHC.Internal.Base.Functor (GHC.Data.Word64Map.Internal.WhenMissing f x)
instance GHC.Internal.Base.Functor GHC.Data.Word64Map.Internal.Word64Map
instance GHC.Internal.IsList.IsList (GHC.Data.Word64Map.Internal.Word64Map a)
instance (GHC.Internal.Base.Monad f, GHC.Internal.Base.Applicative f) => GHC.Internal.Base.Monad (GHC.Data.Word64Map.Internal.WhenMatched f x y)
instance (GHC.Internal.Base.Applicative f, GHC.Internal.Base.Monad f) => GHC.Internal.Base.Monad (GHC.Data.Word64Map.Internal.WhenMissing f x)
instance GHC.Internal.Base.Monoid (GHC.Data.Word64Map.Internal.Word64Map a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Data.Word64Map.Internal.Word64Map a)
instance Data.Functor.Classes.Ord1 GHC.Data.Word64Map.Internal.Word64Map
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Data.Word64Map.Internal.Word64Map a)
instance Data.Functor.Classes.Read1 GHC.Data.Word64Map.Internal.Word64Map
instance GHC.Internal.Read.Read e => GHC.Internal.Read.Read (GHC.Data.Word64Map.Internal.Word64Map e)
instance GHC.Internal.Base.Semigroup (GHC.Data.Word64Map.Internal.Word64Map a)
instance Data.Functor.Classes.Show1 GHC.Data.Word64Map.Internal.Word64Map
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Data.Word64Map.Internal.Word64Map a)
instance GHC.Internal.Data.Traversable.Traversable GHC.Data.Word64Map.Internal.Word64Map


-- | <h1>Finite Int Maps (strict interface)</h1>
--   
--   The <tt><a>Word64Map</a> v</tt> type represents a finite map
--   (sometimes called a dictionary) from key of type <tt>Int</tt> to
--   values of type <tt>v</tt>.
--   
--   Each function in this module is careful to force values before
--   installing them in an <a>Word64Map</a>. This is usually more efficient
--   when laziness is not necessary. When laziness <i>is</i> required, use
--   the functions in <a>Data.Word64Map.Lazy</a>.
--   
--   In particular, the functions in this module obey the following law:
--   
--   <ul>
--   <li>If all values stored in all maps in the arguments are in WHNF,
--   then all values stored in all maps in the results will be in WHNF once
--   those maps are evaluated.</li>
--   </ul>
--   
--   For a walkthrough of the most commonly used functions see the <a>maps
--   introduction</a>.
--   
--   This module is intended to be imported qualified, to avoid name
--   clashes with Prelude functions:
--   
--   <pre>
--   import Data.Word64Map.Strict (Word64Map)
--   import qualified Data.Word64Map.Strict as Word64Map
--   </pre>
--   
--   Note that the implementation is generally <i>left-biased</i>.
--   Functions that take two maps as arguments and combine them, such as
--   <a>union</a> and <a>intersection</a>, prefer the values in the first
--   argument to those in the second.
--   
--   <h2>Detailed performance information</h2>
--   
--   The amortized running time is given for each operation, with
--   &lt;math&gt; referring to the number of entries in the map and
--   &lt;math&gt; referring to the number of bits in an <a>Int</a> (32 or
--   64).
--   
--   Benchmarks comparing <a>Data.Word64Map.Strict</a> with other
--   dictionary implementations can be found at
--   <a>https://github.com/haskell-perf/dictionaries</a>.
--   
--   <h2>Warning</h2>
--   
--   The <a>Word64Map</a> type is shared between the lazy and strict
--   modules, meaning that the same <a>Word64Map</a> value can be passed to
--   functions in both modules. This means that the <a>Functor</a>,
--   <a>Traversable</a> and <a>Data</a> instances are the same as for the
--   <a>Data.Word64Map.Lazy</a> module, so if they are used the resulting
--   map may contain suspended values (thunks).
--   
--   <h2>Implementation</h2>
--   
--   The implementation is based on <i>big-endian patricia trees</i>. This
--   data structure performs especially well on binary operations like
--   <a>union</a> and <a>intersection</a>. Additionally, benchmarks show
--   that it is also (much) faster on insertions and deletions when
--   compared to a generic size-balanced map implementation (see
--   <a>Data.Map</a>).
--   
--   <ul>
--   <li>Chris Okasaki and Andy Gill, "<i>Fast Mergeable Integer Maps</i>",
--   Workshop on ML, September 1998, pages 77-86,
--   <a>http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.5452</a></li>
--   <li>D.R. Morrison, "<i>PATRICIA -- Practical Algorithm To Retrieve
--   Information Coded In Alphanumeric</i>", Journal of the ACM, 15(4),
--   October 1968, pages 514-534.</li>
--   </ul>
module GHC.Data.Word64Map.Strict.Internal

-- | A map of integers to values <tt>a</tt>.
data Word64Map a
type Key = Word64

-- | &lt;math&gt;. The empty map.
--   
--   <pre>
--   empty      == fromList []
--   size empty == 0
--   </pre>
empty :: Word64Map a

-- | &lt;math&gt;. A map of one element.
--   
--   <pre>
--   singleton 1 'a'        == fromList [(1, 'a')]
--   size (singleton 1 'a') == 1
--   </pre>
singleton :: Key -> a -> Word64Map a

-- | &lt;math&gt;. Build a map from a set of keys and a function which for
--   each key computes its value.
--   
--   <pre>
--   fromSet (\k -&gt; replicate k 'a') (Data.Word64Set.fromList [3, 5]) == fromList [(5,"aaaaa"), (3,"aaa")]
--   fromSet undefined Data.Word64Set.empty == empty
--   </pre>
fromSet :: (Key -> a) -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Create a map from a list of key/value pairs.
--   
--   <pre>
--   fromList [] == empty
--   fromList [(5,"a"), (3,"b"), (5, "c")] == fromList [(5,"c"), (3,"b")]
--   fromList [(5,"c"), (3,"b"), (5, "a")] == fromList [(5,"a"), (3,"b")]
--   </pre>
fromList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Create a map from a list of key/value pairs with a
--   combining function. See also <a>fromAscListWith</a>.
--   
--   <pre>
--   fromListWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"a")] == fromList [(3, "ab"), (5, "aba")]
--   fromListWith (++) [] == empty
--   </pre>
fromListWith :: (a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs with a
--   combining function. See also fromAscListWithKey'.
--   
--   <pre>
--   let f key new_value old_value = show key ++ ":" ++ new_value ++ "|" ++ old_value
--   fromListWithKey f [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")] == fromList [(3, "3:a|b"), (5, "5:c|5:b|a")]
--   fromListWithKey f [] == empty
--   </pre>
fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order.
--   
--   <pre>
--   fromAscList [(3,"b"), (5,"a")]          == fromList [(3, "b"), (5, "a")]
--   fromAscList [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "b")]
--   </pre>
fromAscList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order, with a combining function on equal keys.
--   <i>The precondition (input list is ascending) is not checked.</i>
--   
--   <pre>
--   fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]
--   </pre>
fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order, with a combining function on equal keys.
--   <i>The precondition (input list is ascending) is not checked.</i>
--   
--   <pre>
--   fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]
--   </pre>
fromAscListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order and all distinct. <i>The precondition
--   (input list is strictly ascending) is not checked.</i>
--   
--   <pre>
--   fromDistinctAscList [(3,"b"), (5,"a")] == fromList [(3, "b"), (5, "a")]
--   </pre>
fromDistinctAscList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Insert a new key/value pair in the map. If the key is
--   already present in the map, the associated value is replaced with the
--   supplied value, i.e. <a>insert</a> is equivalent to
--   <tt><a>insertWith</a> <a>const</a></tt>.
--   
--   <pre>
--   insert 5 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'x')]
--   insert 7 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'a'), (7, 'x')]
--   insert 5 'x' empty                         == singleton 5 'x'
--   </pre>
insert :: Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Insert with a combining function. <tt><a>insertWith</a>
--   f key value mp</tt> will insert the pair (key, value) into <tt>mp</tt>
--   if key does not exist in the map. If the key does exist, the function
--   will insert <tt>f new_value old_value</tt>.
--   
--   <pre>
--   insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "xxxa")]
--   insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWith (++) 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
insertWith :: (a -> a -> a) -> Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Insert with a combining function.
--   <tt><a>insertWithKey</a> f key value mp</tt> will insert the pair
--   (key, value) into <tt>mp</tt> if key does not exist in the map. If the
--   key does exist, the function will insert <tt>f key new_value
--   old_value</tt>.
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:xxx|a")]
--   insertWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWithKey f 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
--   
--   If the key exists in the map, this function is lazy in <tt>value</tt>
--   but strict in the result of <tt>f</tt>.
insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>insertLookupWithKey</a> f k x
--   map</tt>) is a pair where the first element is equal to
--   (<tt><a>lookup</a> k map</tt>) and the second element equal to
--   (<tt><a>insertWithKey</a> f k x map</tt>).
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertLookupWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:xxx|a")])
--   insertLookupWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "xxx")])
--   insertLookupWithKey f 5 "xxx" empty                         == (Nothing,  singleton 5 "xxx")
--   </pre>
--   
--   This is how to define <tt>insertLookup</tt> using
--   <tt>insertLookupWithKey</tt>:
--   
--   <pre>
--   let insertLookup kx x t = insertLookupWithKey (\_ a _ -&gt; a) kx x t
--   insertLookup 5 "x" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "x")])
--   insertLookup 7 "x" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "x")])
--   </pre>
insertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> Word64Map a -> (Maybe a, Word64Map a)

-- | &lt;math&gt;. Delete a key and its value from the map. When the key is
--   not a member of the map, the original map is returned.
--   
--   <pre>
--   delete 5 (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   delete 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   delete 5 empty                         == empty
--   </pre>
delete :: Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Adjust a value at a specific key. When the key is not a
--   member of the map, the original map is returned.
--   
--   <pre>
--   adjust ("new " ++) 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
--   adjust ("new " ++) 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   adjust ("new " ++) 7 empty                         == empty
--   </pre>
adjust :: (a -> a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Adjust a value at a specific key. When the key is not a
--   member of the map, the original map is returned.
--   
--   <pre>
--   let f key x = (show key) ++ ":new " ++ x
--   adjustWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
--   adjustWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   adjustWithKey f 7 empty                         == empty
--   </pre>
adjustWithKey :: (Key -> a -> a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>update</a> f k map</tt>) updates
--   the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If (<tt>f
--   x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   update f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
--   update f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   update f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
update :: (a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>update</a> f k map</tt>) updates
--   the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If (<tt>f k
--   x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
--   updateWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   updateWithKey f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateWithKey :: (Key -> a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Lookup and update. The function returns original value,
--   if it is updated. This is different behavior than
--   <a>updateLookupWithKey</a>. Returns the original key value if the map
--   entry is deleted.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateLookupWithKey f 5 (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:new a")])
--   updateLookupWithKey f 7 (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a")])
--   updateLookupWithKey f 3 (fromList [(5,"a"), (3,"b")]) == (Just "b", singleton 5 "a")
--   </pre>
updateLookupWithKey :: (Key -> a -> Maybe a) -> Key -> Word64Map a -> (Maybe a, Word64Map a)

-- | &lt;math&gt;. The expression (<tt><a>alter</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alter</a>
--   can be used to insert, delete, or update a value in an
--   <a>Word64Map</a>. In short : <tt><a>lookup</a> k (<a>alter</a> f k m)
--   = f (<a>lookup</a> k m)</tt>.
alter :: (Maybe a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>alterF</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alterF</a>
--   can be used to inspect, insert, delete, or update a value in an
--   <a>Word64Map</a>. In short : <tt><a>lookup</a> k <a>$</a>
--   <a>alterF</a> f k m = f (<a>lookup</a> k m)</tt>.
--   
--   Example:
--   
--   <pre>
--   interactiveAlter :: Int -&gt; Word64Map String -&gt; IO (Word64Map String)
--   interactiveAlter k m = alterF f k m where
--     f Nothing = do
--        putStrLn $ show k ++
--            " was not found in the map. Would you like to add it?"
--        getUserResponse1 :: IO (Maybe String)
--     f (Just old) = do
--        putStrLn $ "The key is currently bound to " ++ show old ++
--            ". Would you like to change or delete it?"
--        getUserResponse2 :: IO (Maybe String)
--   </pre>
--   
--   <a>alterF</a> is the most general operation for working with an
--   individual key that may or may not be in a given map.
alterF :: Functor f => (Maybe a -> f (Maybe a)) -> Key -> Word64Map a -> f (Word64Map a)

-- | &lt;math&gt;. Lookup the value at a key in the map. See also
--   <a>lookup</a>.
lookup :: Key -> Word64Map a -> Maybe a

-- | &lt;math&gt;. Find the value at a key. Returns <a>Nothing</a> when the
--   element can not be found.
--   
--   <pre>
--   fromList [(5,'a'), (3,'b')] !? 1 == Nothing
--   fromList [(5,'a'), (3,'b')] !? 5 == Just 'a'
--   </pre>
(!?) :: Word64Map a -> Key -> Maybe a
infixl 9 !?

-- | &lt;math&gt;. Find the value at a key. Calls <a>error</a> when the
--   element can not be found.
--   
--   <pre>
--   fromList [(5,'a'), (3,'b')] ! 1    Error: element not in the map
--   fromList [(5,'a'), (3,'b')] ! 5 == 'a'
--   </pre>
(!) :: Word64Map a -> Key -> a

-- | &lt;math&gt;. The expression <tt>(<a>findWithDefault</a> def k
--   map)</tt> returns the value at key <tt>k</tt> or returns <tt>def</tt>
--   when the key is not an element of the map.
--   
--   <pre>
--   findWithDefault 'x' 1 (fromList [(5,'a'), (3,'b')]) == 'x'
--   findWithDefault 'x' 5 (fromList [(5,'a'), (3,'b')]) == 'a'
--   </pre>
findWithDefault :: a -> Key -> Word64Map a -> a

-- | &lt;math&gt;. Is the key a member of the map?
--   
--   <pre>
--   member 5 (fromList [(5,'a'), (3,'b')]) == True
--   member 1 (fromList [(5,'a'), (3,'b')]) == False
--   </pre>
member :: Key -> Word64Map a -> Bool

-- | &lt;math&gt;. Is the key not a member of the map?
--   
--   <pre>
--   notMember 5 (fromList [(5,'a'), (3,'b')]) == False
--   notMember 1 (fromList [(5,'a'), (3,'b')]) == True
--   </pre>
notMember :: Key -> Word64Map a -> Bool

-- | &lt;math&gt;. Find largest key smaller than the given one and return
--   the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLT 3 (fromList [(3,'a'), (5,'b')]) == Nothing
--   lookupLT 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   </pre>
lookupLT :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find smallest key greater than the given one and return
--   the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGT 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   lookupGT 5 (fromList [(3,'a'), (5,'b')]) == Nothing
--   </pre>
lookupGT :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find largest key smaller or equal to the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLE 2 (fromList [(3,'a'), (5,'b')]) == Nothing
--   lookupLE 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   lookupLE 5 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   </pre>
lookupLE :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find smallest key greater or equal to the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGE 3 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   lookupGE 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   lookupGE 6 (fromList [(3,'a'), (5,'b')]) == Nothing
--   </pre>
lookupGE :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Is the map empty?
--   
--   <pre>
--   Data.Word64Map.null (empty)           == True
--   Data.Word64Map.null (singleton 1 'a') == False
--   </pre>
null :: Word64Map a -> Bool

-- | &lt;math&gt;. Number of elements in the map.
--   
--   <pre>
--   size empty                                   == 0
--   size (singleton 1 'a')                       == 1
--   size (fromList([(1,'a'), (2,'c'), (3,'b')])) == 3
--   </pre>
size :: Word64Map a -> Int

-- | &lt;math&gt;. The (left-biased) union of two maps. It prefers the
--   first map when duplicate keys are encountered, i.e. (<tt><a>union</a>
--   == <a>unionWith</a> <a>const</a></tt>).
--   
--   <pre>
--   union (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "a"), (7, "C")]
--   </pre>
union :: Word64Map a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The union with a combining function.
--   
--   <pre>
--   unionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "aA"), (7, "C")]
--   </pre>
unionWith :: (a -> a -> a) -> Word64Map a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The union with a combining function.
--   
--   <pre>
--   let f key left_value right_value = (show key) ++ ":" ++ left_value ++ "|" ++ right_value
--   unionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "5:a|A"), (7, "C")]
--   </pre>
unionWithKey :: (Key -> a -> a -> a) -> Word64Map a -> Word64Map a -> Word64Map a

-- | The union of a list of maps.
--   
--   <pre>
--   unions [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
--       == fromList [(3, "b"), (5, "a"), (7, "C")]
--   unions [(fromList [(5, "A3"), (3, "B3")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "a"), (3, "b")])]
--       == fromList [(3, "B3"), (5, "A3"), (7, "C")]
--   </pre>
unions :: Foldable f => f (Word64Map a) -> Word64Map a

-- | The union of a list of maps, with a combining operation.
--   
--   <pre>
--   unionsWith (++) [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
--       == fromList [(3, "bB3"), (5, "aAA3"), (7, "C")]
--   </pre>
unionsWith :: Foldable f => (a -> a -> a) -> f (Word64Map a) -> Word64Map a

-- | &lt;math&gt;. Difference between two maps (based on keys).
--   
--   <pre>
--   difference (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 3 "b"
--   </pre>
difference :: Word64Map a -> Word64Map b -> Word64Map a

-- | Same as <a>difference</a>.
(\\) :: Word64Map a -> Word64Map b -> Word64Map a
infixl 9 \\

-- | &lt;math&gt;. Difference with a combining function.
--   
--   <pre>
--   let f al ar = if al == "b" then Just (al ++ ":" ++ ar) else Nothing
--   differenceWith f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (7, "C")])
--       == singleton 3 "b:B"
--   </pre>
differenceWith :: (a -> b -> Maybe a) -> Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. Difference with a combining function. When two equal
--   keys are encountered, the combining function is applied to the key and
--   both values. If it returns <a>Nothing</a>, the element is discarded
--   (proper set difference). If it returns (<tt><a>Just</a> y</tt>), the
--   element is updated with a new value <tt>y</tt>.
--   
--   <pre>
--   let f k al ar = if al == "b" then Just ((show k) ++ ":" ++ al ++ "|" ++ ar) else Nothing
--   differenceWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (10, "C")])
--       == singleton 3 "3:b|B"
--   </pre>
differenceWithKey :: (Key -> a -> b -> Maybe a) -> Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. The (left-biased) intersection of two maps (based on
--   keys).
--   
--   <pre>
--   intersection (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "a"
--   </pre>
intersection :: Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. The intersection with a combining function.
--   
--   <pre>
--   intersectionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "aA"
--   </pre>
intersectionWith :: (a -> b -> c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. The intersection with a combining function.
--   
--   <pre>
--   let f k al ar = (show k) ++ ":" ++ al ++ "|" ++ ar
--   intersectionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "5:a|A"
--   </pre>
intersectionWithKey :: (Key -> a -> b -> c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. Check whether the key sets of two maps are disjoint
--   (i.e. their <a>intersection</a> is empty).
--   
--   <pre>
--   disjoint (fromList [(2,'a')]) (fromList [(1,()), (3,())])   == True
--   disjoint (fromList [(2,'a')]) (fromList [(1,'a'), (2,'b')]) == False
--   disjoint (fromList [])        (fromList [])                 == True
--   </pre>
--   
--   <pre>
--   disjoint a b == null (intersection a b)
--   </pre>
disjoint :: Word64Map a -> Word64Map b -> Bool

-- | Relate the keys of one map to the values of the other, by using the
--   values of the former as keys for lookups in the latter.
--   
--   Complexity: &lt;math&gt;, where &lt;math&gt; is the size of the first
--   argument
--   
--   <pre>
--   compose (fromList [('a', "A"), ('b', "B")]) (fromList [(1,'a'),(2,'b'),(3,'z')]) = fromList [(1,"A"),(2,"B")]
--   </pre>
--   
--   <pre>
--   (<a>compose</a> bc ab <a>!?</a>) = (bc <a>!?</a>) &lt;=&lt; (ab <a>!?</a>)
--   </pre>
--   
--   <b>Note:</b> Prior to v0.6.4, <a>Data.Word64Map.Strict</a> exposed a
--   version of <a>compose</a> that forced the values of the output
--   <a>Word64Map</a>. This version does not force these values.
compose :: Word64Map c -> Word64Map Word64 -> Word64Map c

-- | &lt;math&gt;. A high-performance universal combining function. Using
--   <a>mergeWithKey</a>, all combining functions can be defined without
--   any loss of efficiency (with exception of <a>union</a>,
--   <a>difference</a> and <a>intersection</a>, where sharing of some nodes
--   is lost with <a>mergeWithKey</a>).
--   
--   Please make sure you know what is going on when using
--   <a>mergeWithKey</a>, otherwise you can be surprised by unexpected code
--   growth or even corruption of the data structure.
--   
--   When <a>mergeWithKey</a> is given three arguments, it is inlined to
--   the call site. You should therefore use <a>mergeWithKey</a> only to
--   define your custom combining functions. For example, you could define
--   <a>unionWithKey</a>, <a>differenceWithKey</a> and
--   <a>intersectionWithKey</a> as
--   
--   <pre>
--   myUnionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) id id m1 m2
--   myDifferenceWithKey f m1 m2 = mergeWithKey f id (const empty) m1 m2
--   myIntersectionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) (const empty) (const empty) m1 m2
--   </pre>
--   
--   When calling <tt><a>mergeWithKey</a> combine only1 only2</tt>, a
--   function combining two <a>Word64Map</a>s is created, such that
--   
--   <ul>
--   <li>if a key is present in both maps, it is passed with both
--   corresponding values to the <tt>combine</tt> function. Depending on
--   the result, the key is either present in the result with specified
--   value, or is left out;</li>
--   <li>a nonempty subtree present only in the first map is passed to
--   <tt>only1</tt> and the output is added to the result;</li>
--   <li>a nonempty subtree present only in the second map is passed to
--   <tt>only2</tt> and the output is added to the result.</li>
--   </ul>
--   
--   The <tt>only1</tt> and <tt>only2</tt> methods <i>must return a map
--   with a subset (possibly empty) of the keys of the given map</i>. The
--   values can be modified arbitrarily. Most common variants of
--   <tt>only1</tt> and <tt>only2</tt> are <a>id</a> and <tt><a>const</a>
--   <a>empty</a></tt>, but for example <tt><a>map</a> f</tt> or
--   <tt><a>filterWithKey</a> f</tt> could be used for any <tt>f</tt>.
mergeWithKey :: (Key -> a -> b -> Maybe c) -> (Word64Map a -> Word64Map c) -> (Word64Map b -> Word64Map c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. Map a function over all values in the map.
--   
--   <pre>
--   map (++ "x") (fromList [(5,"a"), (3,"b")]) == fromList [(3, "bx"), (5, "ax")]
--   </pre>
map :: (a -> b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map a function over all values in the map.
--   
--   <pre>
--   let f key x = (show key) ++ ":" ++ x
--   mapWithKey f (fromList [(5,"a"), (3,"b")]) == fromList [(3, "3:b"), (5, "5:a")]
--   </pre>
mapWithKey :: (Key -> a -> b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. <tt><a>traverseWithKey</a> f s == <a>fromList</a>
--   <a>$</a> <a>traverse</a> ((k, v) -&gt; (,) k <a>$</a> f k v)
--   (<a>toList</a> m)</tt> That is, behaves exactly like a regular
--   <a>traverse</a> except that the traversing function also has access to
--   the key associated with a value.
--   
--   <pre>
--   traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(1, 'a'), (5, 'e')]) == Just (fromList [(1, 'b'), (5, 'f')])
--   traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(2, 'c')])           == Nothing
--   </pre>
traverseWithKey :: Applicative t => (Key -> a -> t b) -> Word64Map a -> t (Word64Map b)

-- | &lt;math&gt;. Traverse keys/values and collect the <a>Just</a>
--   results.
traverseMaybeWithKey :: Applicative f => (Key -> a -> f (Maybe b)) -> Word64Map a -> f (Word64Map b)

-- | &lt;math&gt;. The function <tt><a>mapAccum</a></tt> threads an
--   accumulating argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a b = (a ++ b, b ++ "X")
--   mapAccum f "Everything: " (fromList [(5,"a"), (3,"b")]) == ("Everything: ba", fromList [(3, "bX"), (5, "aX")])
--   </pre>
mapAccum :: (a -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. The function <tt><a>mapAccumWithKey</a></tt> threads an
--   accumulating argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a k b = (a ++ " " ++ (show k) ++ "-" ++ b, b ++ "X")
--   mapAccumWithKey f "Everything:" (fromList [(5,"a"), (3,"b")]) == ("Everything: 3-b 5-a", fromList [(3, "bX"), (5, "aX")])
--   </pre>
mapAccumWithKey :: (a -> Key -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. The function <tt><a>mapAccumRWithKey</a></tt> threads an
--   accumulating argument through the map in descending order of keys.
mapAccumRWithKey :: (a -> Key -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. <tt><a>mapKeys</a> f s</tt> is the map obtained by
--   applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the value at the
--   greatest of the original keys is retained.
--   
--   <pre>
--   mapKeys (+ 1) (fromList [(5,"a"), (3,"b")])                        == fromList [(4, "b"), (6, "a")]
--   mapKeys (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "c"
--   mapKeys (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "c"
--   </pre>
mapKeys :: (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. <tt><a>mapKeysWith</a> c f s</tt> is the map obtained by
--   applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the associated values
--   will be combined using <tt>c</tt>.
--   
--   <pre>
--   mapKeysWith (++) (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "cdab"
--   mapKeysWith (++) (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "cdab"
--   </pre>
mapKeysWith :: (a -> a -> a) -> (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. <tt><a>mapKeysMonotonic</a> f s == <a>mapKeys</a> f
--   s</tt>, but works only when <tt>f</tt> is strictly monotonic. That is,
--   for any values <tt>x</tt> and <tt>y</tt>, if <tt>x</tt> &lt;
--   <tt>y</tt> then <tt>f x</tt> &lt; <tt>f y</tt>. <i>The precondition is
--   not checked.</i> Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
--                       ==&gt; mapKeysMonotonic f s == mapKeys f s
--       where ls = keys s
--   </pre>
--   
--   This means that <tt>f</tt> maps distinct original keys to distinct
--   resulting keys. This function has slightly better performance than
--   <a>mapKeys</a>.
--   
--   <pre>
--   mapKeysMonotonic (\ k -&gt; k * 2) (fromList [(5,"a"), (3,"b")]) == fromList [(6, "b"), (10, "a")]
--   </pre>
mapKeysMonotonic :: (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Fold the values in the map using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>elems</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elems map = foldr (:) [] map
--   </pre>
--   
--   <pre>
--   let f a len = len + (length a)
--   foldr f 0 (fromList [(5,"a"), (3,"bbb")]) == 4
--   </pre>
foldr :: (a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. Fold the values in the map using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>elems</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elems = reverse . foldl (flip (:)) []
--   </pre>
--   
--   <pre>
--   let f len a = len + (length a)
--   foldl f 0 (fromList [(5,"a"), (3,"bbb")]) == 4
--   </pre>
foldl :: (a -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   right-associative binary operator, such that <tt><a>foldrWithKey</a> f
--   z == <a>foldr</a> (<a>uncurry</a> f) z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keys map = foldrWithKey (\k x ks -&gt; k:ks) [] map
--   </pre>
--   
--   <pre>
--   let f k a result = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
--   foldrWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (5:a)(3:b)"
--   </pre>
foldrWithKey :: (Key -> a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   left-associative binary operator, such that <tt><a>foldlWithKey</a> f
--   z == <a>foldl</a> (\z' (kx, x) -&gt; f z' kx x) z .
--   <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keys = reverse . foldlWithKey (\ks k x -&gt; k:ks) []
--   </pre>
--   
--   <pre>
--   let f result k a = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
--   foldlWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (3:b)(5:a)"
--   </pre>
foldlWithKey :: (a -> Key -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   monoid, such that
--   
--   <pre>
--   <a>foldMapWithKey</a> f = <a>fold</a> . <a>mapWithKey</a> f
--   </pre>
--   
--   This can be an asymptotically faster than <a>foldrWithKey</a> or
--   <a>foldlWithKey</a> for some monoids.
foldMapWithKey :: Monoid m => (Key -> a -> m) -> Word64Map a -> m

-- | &lt;math&gt;. A strict version of <a>foldr</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldr' :: (a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. A strict version of <a>foldl</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldl' :: (a -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. A strict version of <a>foldrWithKey</a>. Each
--   application of the operator is evaluated before using the result in
--   the next application. This function is strict in the starting value.
foldrWithKey' :: (Key -> a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. A strict version of <a>foldlWithKey</a>. Each
--   application of the operator is evaluated before using the result in
--   the next application. This function is strict in the starting value.
foldlWithKey' :: (a -> Key -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Return all elements of the map in the ascending order of
--   their keys. Subject to list fusion.
--   
--   <pre>
--   elems (fromList [(5,"a"), (3,"b")]) == ["b","a"]
--   elems empty == []
--   </pre>
elems :: Word64Map a -> [a]

-- | &lt;math&gt;. Return all keys of the map in ascending order. Subject
--   to list fusion.
--   
--   <pre>
--   keys (fromList [(5,"a"), (3,"b")]) == [3,5]
--   keys empty == []
--   </pre>
keys :: Word64Map a -> [Key]

-- | &lt;math&gt;. An alias for <a>toAscList</a>. Returns all key/value
--   pairs in the map in ascending key order. Subject to list fusion.
--   
--   <pre>
--   assocs (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   assocs empty == []
--   </pre>
assocs :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. The set of all keys of the map.
--   
--   <pre>
--   keysSet (fromList [(5,"a"), (3,"b")]) == Data.Word64Set.fromList [3,5]
--   keysSet empty == Data.Word64Set.empty
--   </pre>
keysSet :: Word64Map a -> Word64Set

-- | &lt;math&gt;. Convert the map to a list of key/value pairs. Subject to
--   list fusion.
--   
--   <pre>
--   toList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   toList empty == []
--   </pre>
toList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Convert the map to a list of key/value pairs where the
--   keys are in ascending order. Subject to list fusion.
--   
--   <pre>
--   toAscList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   </pre>
toAscList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Convert the map to a list of key/value pairs where the
--   keys are in descending order. Subject to list fusion.
--   
--   <pre>
--   toDescList (fromList [(5,"a"), (3,"b")]) == [(5,"a"), (3,"b")]
--   </pre>
toDescList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Filter all values that satisfy some predicate.
--   
--   <pre>
--   filter (&gt; "a") (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   filter (&gt; "x") (fromList [(5,"a"), (3,"b")]) == empty
--   filter (&lt; "a") (fromList [(5,"a"), (3,"b")]) == empty
--   </pre>
filter :: (a -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Filter all keys/values that satisfy some predicate.
--   
--   <pre>
--   filterWithKey (\k _ -&gt; k &gt; 4) (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
filterWithKey :: (Key -> a -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The restriction of a map to the keys in a set.
--   
--   <pre>
--   m `restrictKeys` s = <a>filterWithKey</a> (\k _ -&gt; k <a>`member`</a> s) m
--   </pre>
restrictKeys :: Word64Map a -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Remove all the keys in a given set from a map.
--   
--   <pre>
--   m `withoutKeys` s = <a>filterWithKey</a> (\k _ -&gt; k <a>`notMember`</a> s) m
--   </pre>
withoutKeys :: Word64Map a -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Partition the map according to some predicate. The first
--   map contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate. See also <a>split</a>.
--   
--   <pre>
--   partition (&gt; "a") (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
--   partition (&lt; "x") (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
--   partition (&gt; "x") (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])
--   </pre>
partition :: (a -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Partition the map according to some predicate. The first
--   map contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate. See also <a>split</a>.
--   
--   <pre>
--   partitionWithKey (\ k _ -&gt; k &gt; 3) (fromList [(5,"a"), (3,"b")]) == (singleton 5 "a", singleton 3 "b")
--   partitionWithKey (\ k _ -&gt; k &lt; 7) (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
--   partitionWithKey (\ k _ -&gt; k &gt; 7) (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])
--   </pre>
partitionWithKey :: (Key -> a -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Take while a predicate on the keys holds. The user is
--   responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   takeWhileAntitone p = <a>fromDistinctAscList</a> . <a>takeWhile</a> (p . fst) . <a>toList</a>
--   takeWhileAntitone p = <a>filterWithKey</a> (\k _ -&gt; p k)
--   </pre>
takeWhileAntitone :: (Key -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Drop while a predicate on the keys holds. The user is
--   responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   dropWhileAntitone p = <a>fromDistinctAscList</a> . <a>dropWhile</a> (p . fst) . <a>toList</a>
--   dropWhileAntitone p = <a>filterWithKey</a> (\k _ -&gt; not (p k))
--   </pre>
dropWhileAntitone :: (Key -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Divide a map at the point where a predicate on the keys
--   stops holding. The user is responsible for ensuring that for all
--   <tt>Int</tt>s, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>.
--   
--   <pre>
--   spanAntitone p xs = (<a>takeWhileAntitone</a> p xs, <a>dropWhileAntitone</a> p xs)
--   spanAntitone p xs = <a>partitionWithKey</a> (\k _ -&gt; p k) xs
--   </pre>
--   
--   Note: if <tt>p</tt> is not actually antitone, then
--   <tt>spanAntitone</tt> will split the map at some <i>unspecified</i>
--   point.
spanAntitone :: (Key -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Map values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   mapMaybe f (fromList [(5,"a"), (3,"b")]) == singleton 5 "new a"
--   </pre>
mapMaybe :: (a -> Maybe b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map keys/values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f k _ = if k &lt; 5 then Just ("key : " ++ (show k)) else Nothing
--   mapMaybeWithKey f (fromList [(5,"a"), (3,"b")]) == singleton 3 "key : 3"
--   </pre>
mapMaybeWithKey :: (Key -> a -> Maybe b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map values and separate the <a>Left</a> and <a>Right</a>
--   results.
--   
--   <pre>
--   let f a = if a &lt; "c" then Left a else Right a
--   mapEither f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (fromList [(3,"b"), (5,"a")], fromList [(1,"x"), (7,"z")])
--   
--   mapEither (\ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (empty, fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--   </pre>
mapEither :: (a -> Either b c) -> Word64Map a -> (Word64Map b, Word64Map c)

-- | &lt;math&gt;. Map keys/values and separate the <a>Left</a> and
--   <a>Right</a> results.
--   
--   <pre>
--   let f k a = if k &lt; 5 then Left (k * 2) else Right (a ++ a)
--   mapEitherWithKey f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (fromList [(1,2), (3,6)], fromList [(5,"aa"), (7,"zz")])
--   
--   mapEitherWithKey (\_ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (empty, fromList [(1,"x"), (3,"b"), (5,"a"), (7,"z")])
--   </pre>
mapEitherWithKey :: (Key -> a -> Either b c) -> Word64Map a -> (Word64Map b, Word64Map c)

-- | &lt;math&gt;. The expression (<tt><a>split</a> k map</tt>) is a pair
--   <tt>(map1,map2)</tt> where all keys in <tt>map1</tt> are lower than
--   <tt>k</tt> and all keys in <tt>map2</tt> larger than <tt>k</tt>. Any
--   key equal to <tt>k</tt> is found in neither <tt>map1</tt> nor
--   <tt>map2</tt>.
--   
--   <pre>
--   split 2 (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3,"b"), (5,"a")])
--   split 3 (fromList [(5,"a"), (3,"b")]) == (empty, singleton 5 "a")
--   split 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
--   split 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", empty)
--   split 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], empty)
--   </pre>
split :: Key -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Performs a <a>split</a> but also returns whether the
--   pivot key was found in the original map.
--   
--   <pre>
--   splitLookup 2 (fromList [(5,"a"), (3,"b")]) == (empty, Nothing, fromList [(3,"b"), (5,"a")])
--   splitLookup 3 (fromList [(5,"a"), (3,"b")]) == (empty, Just "b", singleton 5 "a")
--   splitLookup 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Nothing, singleton 5 "a")
--   splitLookup 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Just "a", empty)
--   splitLookup 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], Nothing, empty)
--   </pre>
splitLookup :: Key -> Word64Map a -> (Word64Map a, Maybe a, Word64Map a)

-- | &lt;math&gt;. Decompose a map into pieces based on the structure of
--   the underlying tree. This function is useful for consuming a map in
--   parallel.
--   
--   No guarantee is made as to the sizes of the pieces; an internal, but
--   deterministic process determines this. However, it is guaranteed that
--   the pieces returned will be in ascending order (all elements in the
--   first submap less than all elements in the second, and so on).
--   
--   Examples:
--   
--   <pre>
--   splitRoot (fromList (zip [1..6::Int] ['a'..])) ==
--     [fromList [(1,'a'),(2,'b'),(3,'c')],fromList [(4,'d'),(5,'e'),(6,'f')]]
--   </pre>
--   
--   <pre>
--   splitRoot empty == []
--   </pre>
--   
--   Note that the current implementation does not return more than two
--   submaps, but you should not depend on this behaviour because it can
--   change in the future without notice.
splitRoot :: Word64Map a -> [Word64Map a]

-- | &lt;math&gt;. Is this a submap? Defined as (<tt><a>isSubmapOf</a> =
--   <a>isSubmapOfBy</a> (==)</tt>).
isSubmapOf :: Eq a => Word64Map a -> Word64Map a -> Bool

-- | &lt;math&gt;. The expression (<tt><a>isSubmapOfBy</a> f m1 m2</tt>)
--   returns <a>True</a> if all keys in <tt>m1</tt> are in <tt>m2</tt>, and
--   when <tt>f</tt> returns <a>True</a> when applied to their respective
--   values. For example, the following expressions are all <a>True</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (&lt;=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [(1,2)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (&lt;) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
--   </pre>
isSubmapOfBy :: (a -> b -> Bool) -> Word64Map a -> Word64Map b -> Bool

-- | &lt;math&gt;. Is this a proper submap? (ie. a submap but not equal).
--   Defined as (<tt><a>isProperSubmapOf</a> = <a>isProperSubmapOfBy</a>
--   (==)</tt>).
isProperSubmapOf :: Eq a => Word64Map a -> Word64Map a -> Bool

-- | &lt;math&gt;. Is this a proper submap? (ie. a submap but not equal).
--   The expression (<tt><a>isProperSubmapOfBy</a> f m1 m2</tt>) returns
--   <a>True</a> when <tt>keys m1</tt> and <tt>keys m2</tt> are not equal,
--   all keys in <tt>m1</tt> are in <tt>m2</tt>, and when <tt>f</tt>
--   returns <a>True</a> when applied to their respective values. For
--   example, the following expressions are all <a>True</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isProperSubmapOfBy (&lt;=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
--   isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
--   isProperSubmapOfBy (&lt;)  (fromList [(1,1)])       (fromList [(1,1),(2,2)])
--   </pre>
isProperSubmapOfBy :: (a -> b -> Bool) -> Word64Map a -> Word64Map b -> Bool

-- | &lt;math&gt;. The minimal key of the map. Returns <a>Nothing</a> if
--   the map is empty.
lookupMin :: Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. The maximal key of the map. Returns <a>Nothing</a> if
--   the map is empty.
lookupMax :: Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. The minimal key of the map. Calls <a>error</a> if the
--   map is empty. Use <a>minViewWithKey</a> if the map may be empty.
findMin :: Word64Map a -> (Key, a)

-- | &lt;math&gt;. The maximal key of the map. Calls <a>error</a> if the
--   map is empty. Use <a>maxViewWithKey</a> if the map may be empty.
findMax :: Word64Map a -> (Key, a)

-- | &lt;math&gt;. Delete the minimal key. Returns an empty map if the map
--   is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Map</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Map</a> was already empty.
deleteMin :: Word64Map a -> Word64Map a

-- | &lt;math&gt;. Delete the maximal key. Returns an empty map if the map
--   is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Map</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Map</a> was already empty.
deleteMax :: Word64Map a -> Word64Map a

-- | &lt;math&gt;. Delete and find the minimal element. This function
--   throws an error if the map is empty. Use <a>minViewWithKey</a> if the
--   map may be empty.
deleteFindMin :: Word64Map a -> ((Key, a), Word64Map a)

-- | &lt;math&gt;. Delete and find the maximal element. This function
--   throws an error if the map is empty. Use <a>maxViewWithKey</a> if the
--   map may be empty.
deleteFindMax :: Word64Map a -> ((Key, a), Word64Map a)

-- | &lt;math&gt;. Update the value at the minimal key.
--   
--   <pre>
--   updateMin (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "Xb"), (5, "a")]
--   updateMin (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateMin :: (a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the maximal key.
--   
--   <pre>
--   updateMax (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "Xa")]
--   updateMax (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   </pre>
updateMax :: (a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the minimal key.
--   
--   <pre>
--   updateMinWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"3:b"), (5,"a")]
--   updateMinWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateMinWithKey :: (Key -> a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the maximal key.
--   
--   <pre>
--   updateMaxWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"b"), (5,"5:a")]
--   updateMaxWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   </pre>
updateMaxWithKey :: (Key -> a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Retrieves the minimal key of the map, and the map
--   stripped of that element, or <a>Nothing</a> if passed an empty map.
minView :: Word64Map a -> Maybe (a, Word64Map a)

-- | &lt;math&gt;. Retrieves the maximal key of the map, and the map
--   stripped of that element, or <a>Nothing</a> if passed an empty map.
maxView :: Word64Map a -> Maybe (a, Word64Map a)

-- | &lt;math&gt;. Retrieves the minimal (key,value) pair of the map, and
--   the map stripped of that element, or <a>Nothing</a> if passed an empty
--   map.
--   
--   <pre>
--   minViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((3,"b"), singleton 5 "a")
--   minViewWithKey empty == Nothing
--   </pre>
minViewWithKey :: Word64Map a -> Maybe ((Key, a), Word64Map a)

-- | &lt;math&gt;. Retrieves the maximal (key,value) pair of the map, and
--   the map stripped of that element, or <a>Nothing</a> if passed an empty
--   map.
--   
--   <pre>
--   maxViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((5,"a"), singleton 3 "b")
--   maxViewWithKey empty == Nothing
--   </pre>
maxViewWithKey :: Word64Map a -> Maybe ((Key, a), Word64Map a)


-- | <h1>Finite Word64 Maps (strict interface)</h1>
--   
--   The <tt><a>Word64Map</a> v</tt> type represents a finite map
--   (sometimes called a dictionary) from key of type <tt>Word64</tt> to
--   values of type <tt>v</tt>.
--   
--   Each function in this module is careful to force values before
--   installing them in an <a>Word64Map</a>. This is usually more efficient
--   when laziness is not necessary. When laziness <i>is</i> required, use
--   the functions in <a>Data.Word64Map.Lazy</a>.
--   
--   In particular, the functions in this module obey the following law:
--   
--   <ul>
--   <li>If all values stored in all maps in the arguments are in WHNF,
--   then all values stored in all maps in the results will be in WHNF once
--   those maps are evaluated.</li>
--   </ul>
--   
--   For a walkthrough of the most commonly used functions see the <a>maps
--   introduction</a>.
--   
--   This module is intended to be imported qualified, to avoid name
--   clashes with Prelude functions:
--   
--   <pre>
--   import Data.Word64Map.Strict (Word64Map)
--   import qualified Data.Word64Map.Strict as Word64Map
--   </pre>
--   
--   Note that the implementation is generally <i>left-biased</i>.
--   Functions that take two maps as arguments and combine them, such as
--   <a>union</a> and <a>intersection</a>, prefer the values in the first
--   argument to those in the second.
--   
--   <h2>Detailed performance information</h2>
--   
--   The amortized running time is given for each operation, with
--   &lt;math&gt; referring to the number of entries in the map and
--   &lt;math&gt; referring to the number of bits in an <tt>Word64</tt>
--   (64).
--   
--   Benchmarks comparing <a>Data.Word64Map.Strict</a> with other
--   dictionary implementations can be found at
--   <a>https://github.com/haskell-perf/dictionaries</a>.
--   
--   <h2>Warning</h2>
--   
--   The <a>Word64Map</a> type is shared between the lazy and strict
--   modules, meaning that the same <a>Word64Map</a> value can be passed to
--   functions in both modules. This means that the <tt>Functor</tt>,
--   <tt>Traversable</tt> and <a>Data</a> instances are the same as for the
--   <a>Data.Word64Map.Lazy</a> module, so if they are used the resulting
--   map may contain suspended values (thunks).
--   
--   <h2>Implementation</h2>
--   
--   The implementation is based on <i>big-endian patricia trees</i>. This
--   data structure performs especially well on binary operations like
--   <a>union</a> and <a>intersection</a>. Additionally, benchmarks show
--   that it is also (much) faster on insertions and deletions when
--   compared to a generic size-balanced map implementation (see
--   <a>Data.Map</a>).
--   
--   <ul>
--   <li>Chris Okasaki and Andy Gill, "<i>Fast Mergeable Integer Maps</i>",
--   Workshop on ML, September 1998, pages 77-86,
--   <a>http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.5452</a></li>
--   <li>D.R. Morrison, "<i>PATRICIA -- Practical Algorithm To Retrieve
--   Information Coded In Alphanumeric</i>", Journal of the ACM, 15(4),
--   October 1968, pages 514-534.</li>
--   </ul>
module GHC.Data.Word64Map.Strict

-- | A map of integers to values <tt>a</tt>.
data Word64Map a
type Key = Word64

-- | &lt;math&gt;. The empty map.
--   
--   <pre>
--   empty      == fromList []
--   size empty == 0
--   </pre>
empty :: Word64Map a

-- | &lt;math&gt;. A map of one element.
--   
--   <pre>
--   singleton 1 'a'        == fromList [(1, 'a')]
--   size (singleton 1 'a') == 1
--   </pre>
singleton :: Key -> a -> Word64Map a

-- | &lt;math&gt;. Build a map from a set of keys and a function which for
--   each key computes its value.
--   
--   <pre>
--   fromSet (\k -&gt; replicate k 'a') (Data.Word64Set.fromList [3, 5]) == fromList [(5,"aaaaa"), (3,"aaa")]
--   fromSet undefined Data.Word64Set.empty == empty
--   </pre>
fromSet :: (Key -> a) -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Create a map from a list of key/value pairs.
--   
--   <pre>
--   fromList [] == empty
--   fromList [(5,"a"), (3,"b"), (5, "c")] == fromList [(5,"c"), (3,"b")]
--   fromList [(5,"c"), (3,"b"), (5, "a")] == fromList [(5,"a"), (3,"b")]
--   </pre>
fromList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Create a map from a list of key/value pairs with a
--   combining function. See also <a>fromAscListWith</a>.
--   
--   <pre>
--   fromListWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"a")] == fromList [(3, "ab"), (5, "aba")]
--   fromListWith (++) [] == empty
--   </pre>
fromListWith :: (a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs with a
--   combining function. See also fromAscListWithKey'.
--   
--   <pre>
--   let f key new_value old_value = show key ++ ":" ++ new_value ++ "|" ++ old_value
--   fromListWithKey f [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")] == fromList [(3, "3:a|b"), (5, "5:c|5:b|a")]
--   fromListWithKey f [] == empty
--   </pre>
fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order.
--   
--   <pre>
--   fromAscList [(3,"b"), (5,"a")]          == fromList [(3, "b"), (5, "a")]
--   fromAscList [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "b")]
--   </pre>
fromAscList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order, with a combining function on equal keys.
--   <i>The precondition (input list is ascending) is not checked.</i>
--   
--   <pre>
--   fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]
--   </pre>
fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order, with a combining function on equal keys.
--   <i>The precondition (input list is ascending) is not checked.</i>
--   
--   <pre>
--   fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]
--   </pre>
fromAscListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order and all distinct. <i>The precondition
--   (input list is strictly ascending) is not checked.</i>
--   
--   <pre>
--   fromDistinctAscList [(3,"b"), (5,"a")] == fromList [(3, "b"), (5, "a")]
--   </pre>
fromDistinctAscList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Insert a new key/value pair in the map. If the key is
--   already present in the map, the associated value is replaced with the
--   supplied value, i.e. <a>insert</a> is equivalent to
--   <tt><a>insertWith</a> <a>const</a></tt>.
--   
--   <pre>
--   insert 5 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'x')]
--   insert 7 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'a'), (7, 'x')]
--   insert 5 'x' empty                         == singleton 5 'x'
--   </pre>
insert :: Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Insert with a combining function. <tt><a>insertWith</a>
--   f key value mp</tt> will insert the pair (key, value) into <tt>mp</tt>
--   if key does not exist in the map. If the key does exist, the function
--   will insert <tt>f new_value old_value</tt>.
--   
--   <pre>
--   insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "xxxa")]
--   insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWith (++) 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
insertWith :: (a -> a -> a) -> Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Insert with a combining function.
--   <tt><a>insertWithKey</a> f key value mp</tt> will insert the pair
--   (key, value) into <tt>mp</tt> if key does not exist in the map. If the
--   key does exist, the function will insert <tt>f key new_value
--   old_value</tt>.
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:xxx|a")]
--   insertWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWithKey f 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
--   
--   If the key exists in the map, this function is lazy in <tt>value</tt>
--   but strict in the result of <tt>f</tt>.
insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>insertLookupWithKey</a> f k x
--   map</tt>) is a pair where the first element is equal to
--   (<tt><a>lookup</a> k map</tt>) and the second element equal to
--   (<tt><a>insertWithKey</a> f k x map</tt>).
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertLookupWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:xxx|a")])
--   insertLookupWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "xxx")])
--   insertLookupWithKey f 5 "xxx" empty                         == (Nothing,  singleton 5 "xxx")
--   </pre>
--   
--   This is how to define <tt>insertLookup</tt> using
--   <tt>insertLookupWithKey</tt>:
--   
--   <pre>
--   let insertLookup kx x t = insertLookupWithKey (\_ a _ -&gt; a) kx x t
--   insertLookup 5 "x" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "x")])
--   insertLookup 7 "x" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "x")])
--   </pre>
insertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> Word64Map a -> (Maybe a, Word64Map a)

-- | &lt;math&gt;. Delete a key and its value from the map. When the key is
--   not a member of the map, the original map is returned.
--   
--   <pre>
--   delete 5 (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   delete 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   delete 5 empty                         == empty
--   </pre>
delete :: Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Adjust a value at a specific key. When the key is not a
--   member of the map, the original map is returned.
--   
--   <pre>
--   adjust ("new " ++) 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
--   adjust ("new " ++) 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   adjust ("new " ++) 7 empty                         == empty
--   </pre>
adjust :: (a -> a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Adjust a value at a specific key. When the key is not a
--   member of the map, the original map is returned.
--   
--   <pre>
--   let f key x = (show key) ++ ":new " ++ x
--   adjustWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
--   adjustWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   adjustWithKey f 7 empty                         == empty
--   </pre>
adjustWithKey :: (Key -> a -> a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>update</a> f k map</tt>) updates
--   the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If (<tt>f
--   x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   update f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
--   update f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   update f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
update :: (a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>update</a> f k map</tt>) updates
--   the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If (<tt>f k
--   x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
--   updateWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   updateWithKey f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateWithKey :: (Key -> a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Lookup and update. The function returns original value,
--   if it is updated. This is different behavior than
--   <a>updateLookupWithKey</a>. Returns the original key value if the map
--   entry is deleted.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateLookupWithKey f 5 (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:new a")])
--   updateLookupWithKey f 7 (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a")])
--   updateLookupWithKey f 3 (fromList [(5,"a"), (3,"b")]) == (Just "b", singleton 5 "a")
--   </pre>
updateLookupWithKey :: (Key -> a -> Maybe a) -> Key -> Word64Map a -> (Maybe a, Word64Map a)

-- | &lt;math&gt;. The expression (<tt><a>alter</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alter</a>
--   can be used to insert, delete, or update a value in an
--   <a>Word64Map</a>. In short : <tt><a>lookup</a> k (<a>alter</a> f k m)
--   = f (<a>lookup</a> k m)</tt>.
alter :: (Maybe a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>alterF</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alterF</a>
--   can be used to inspect, insert, delete, or update a value in an
--   <a>Word64Map</a>. In short : <tt><a>lookup</a> k <a>$</a>
--   <a>alterF</a> f k m = f (<a>lookup</a> k m)</tt>.
--   
--   Example:
--   
--   <pre>
--   interactiveAlter :: Int -&gt; Word64Map String -&gt; IO (Word64Map String)
--   interactiveAlter k m = alterF f k m where
--     f Nothing = do
--        putStrLn $ show k ++
--            " was not found in the map. Would you like to add it?"
--        getUserResponse1 :: IO (Maybe String)
--     f (Just old) = do
--        putStrLn $ "The key is currently bound to " ++ show old ++
--            ". Would you like to change or delete it?"
--        getUserResponse2 :: IO (Maybe String)
--   </pre>
--   
--   <a>alterF</a> is the most general operation for working with an
--   individual key that may or may not be in a given map.
alterF :: Functor f => (Maybe a -> f (Maybe a)) -> Key -> Word64Map a -> f (Word64Map a)

-- | &lt;math&gt;. Lookup the value at a key in the map. See also
--   <a>lookup</a>.
lookup :: Key -> Word64Map a -> Maybe a

-- | &lt;math&gt;. Find the value at a key. Returns <a>Nothing</a> when the
--   element can not be found.
--   
--   <pre>
--   fromList [(5,'a'), (3,'b')] !? 1 == Nothing
--   fromList [(5,'a'), (3,'b')] !? 5 == Just 'a'
--   </pre>
(!?) :: Word64Map a -> Key -> Maybe a
infixl 9 !?

-- | &lt;math&gt;. Find the value at a key. Calls <a>error</a> when the
--   element can not be found.
--   
--   <pre>
--   fromList [(5,'a'), (3,'b')] ! 1    Error: element not in the map
--   fromList [(5,'a'), (3,'b')] ! 5 == 'a'
--   </pre>
(!) :: Word64Map a -> Key -> a

-- | &lt;math&gt;. The expression <tt>(<a>findWithDefault</a> def k
--   map)</tt> returns the value at key <tt>k</tt> or returns <tt>def</tt>
--   when the key is not an element of the map.
--   
--   <pre>
--   findWithDefault 'x' 1 (fromList [(5,'a'), (3,'b')]) == 'x'
--   findWithDefault 'x' 5 (fromList [(5,'a'), (3,'b')]) == 'a'
--   </pre>
findWithDefault :: a -> Key -> Word64Map a -> a

-- | &lt;math&gt;. Is the key a member of the map?
--   
--   <pre>
--   member 5 (fromList [(5,'a'), (3,'b')]) == True
--   member 1 (fromList [(5,'a'), (3,'b')]) == False
--   </pre>
member :: Key -> Word64Map a -> Bool

-- | &lt;math&gt;. Is the key not a member of the map?
--   
--   <pre>
--   notMember 5 (fromList [(5,'a'), (3,'b')]) == False
--   notMember 1 (fromList [(5,'a'), (3,'b')]) == True
--   </pre>
notMember :: Key -> Word64Map a -> Bool

-- | &lt;math&gt;. Find largest key smaller than the given one and return
--   the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLT 3 (fromList [(3,'a'), (5,'b')]) == Nothing
--   lookupLT 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   </pre>
lookupLT :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find smallest key greater than the given one and return
--   the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGT 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   lookupGT 5 (fromList [(3,'a'), (5,'b')]) == Nothing
--   </pre>
lookupGT :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find largest key smaller or equal to the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLE 2 (fromList [(3,'a'), (5,'b')]) == Nothing
--   lookupLE 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   lookupLE 5 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   </pre>
lookupLE :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find smallest key greater or equal to the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGE 3 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   lookupGE 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   lookupGE 6 (fromList [(3,'a'), (5,'b')]) == Nothing
--   </pre>
lookupGE :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Is the map empty?
--   
--   <pre>
--   Data.Word64Map.null (empty)           == True
--   Data.Word64Map.null (singleton 1 'a') == False
--   </pre>
null :: Word64Map a -> Bool

-- | &lt;math&gt;. Number of elements in the map.
--   
--   <pre>
--   size empty                                   == 0
--   size (singleton 1 'a')                       == 1
--   size (fromList([(1,'a'), (2,'c'), (3,'b')])) == 3
--   </pre>
size :: Word64Map a -> Int

-- | &lt;math&gt;. The (left-biased) union of two maps. It prefers the
--   first map when duplicate keys are encountered, i.e. (<tt><a>union</a>
--   == <a>unionWith</a> <a>const</a></tt>).
--   
--   <pre>
--   union (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "a"), (7, "C")]
--   </pre>
union :: Word64Map a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The union with a combining function.
--   
--   <pre>
--   unionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "aA"), (7, "C")]
--   </pre>
unionWith :: (a -> a -> a) -> Word64Map a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The union with a combining function.
--   
--   <pre>
--   let f key left_value right_value = (show key) ++ ":" ++ left_value ++ "|" ++ right_value
--   unionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "5:a|A"), (7, "C")]
--   </pre>
unionWithKey :: (Key -> a -> a -> a) -> Word64Map a -> Word64Map a -> Word64Map a

-- | The union of a list of maps.
--   
--   <pre>
--   unions [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
--       == fromList [(3, "b"), (5, "a"), (7, "C")]
--   unions [(fromList [(5, "A3"), (3, "B3")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "a"), (3, "b")])]
--       == fromList [(3, "B3"), (5, "A3"), (7, "C")]
--   </pre>
unions :: Foldable f => f (Word64Map a) -> Word64Map a

-- | The union of a list of maps, with a combining operation.
--   
--   <pre>
--   unionsWith (++) [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
--       == fromList [(3, "bB3"), (5, "aAA3"), (7, "C")]
--   </pre>
unionsWith :: Foldable f => (a -> a -> a) -> f (Word64Map a) -> Word64Map a

-- | &lt;math&gt;. Difference between two maps (based on keys).
--   
--   <pre>
--   difference (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 3 "b"
--   </pre>
difference :: Word64Map a -> Word64Map b -> Word64Map a

-- | Same as <a>difference</a>.
(\\) :: Word64Map a -> Word64Map b -> Word64Map a
infixl 9 \\

-- | &lt;math&gt;. Difference with a combining function.
--   
--   <pre>
--   let f al ar = if al == "b" then Just (al ++ ":" ++ ar) else Nothing
--   differenceWith f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (7, "C")])
--       == singleton 3 "b:B"
--   </pre>
differenceWith :: (a -> b -> Maybe a) -> Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. Difference with a combining function. When two equal
--   keys are encountered, the combining function is applied to the key and
--   both values. If it returns <a>Nothing</a>, the element is discarded
--   (proper set difference). If it returns (<tt><a>Just</a> y</tt>), the
--   element is updated with a new value <tt>y</tt>.
--   
--   <pre>
--   let f k al ar = if al == "b" then Just ((show k) ++ ":" ++ al ++ "|" ++ ar) else Nothing
--   differenceWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (10, "C")])
--       == singleton 3 "3:b|B"
--   </pre>
differenceWithKey :: (Key -> a -> b -> Maybe a) -> Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. The (left-biased) intersection of two maps (based on
--   keys).
--   
--   <pre>
--   intersection (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "a"
--   </pre>
intersection :: Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. The intersection with a combining function.
--   
--   <pre>
--   intersectionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "aA"
--   </pre>
intersectionWith :: (a -> b -> c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. The intersection with a combining function.
--   
--   <pre>
--   let f k al ar = (show k) ++ ":" ++ al ++ "|" ++ ar
--   intersectionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "5:a|A"
--   </pre>
intersectionWithKey :: (Key -> a -> b -> c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. Check whether the key sets of two maps are disjoint
--   (i.e. their <a>intersection</a> is empty).
--   
--   <pre>
--   disjoint (fromList [(2,'a')]) (fromList [(1,()), (3,())])   == True
--   disjoint (fromList [(2,'a')]) (fromList [(1,'a'), (2,'b')]) == False
--   disjoint (fromList [])        (fromList [])                 == True
--   </pre>
--   
--   <pre>
--   disjoint a b == null (intersection a b)
--   </pre>
disjoint :: Word64Map a -> Word64Map b -> Bool

-- | Relate the keys of one map to the values of the other, by using the
--   values of the former as keys for lookups in the latter.
--   
--   Complexity: &lt;math&gt;, where &lt;math&gt; is the size of the first
--   argument
--   
--   <pre>
--   compose (fromList [('a', "A"), ('b', "B")]) (fromList [(1,'a'),(2,'b'),(3,'z')]) = fromList [(1,"A"),(2,"B")]
--   </pre>
--   
--   <pre>
--   (<a>compose</a> bc ab <a>!?</a>) = (bc <a>!?</a>) &lt;=&lt; (ab <a>!?</a>)
--   </pre>
--   
--   <b>Note:</b> Prior to v0.6.4, <a>Data.Word64Map.Strict</a> exposed a
--   version of <a>compose</a> that forced the values of the output
--   <a>Word64Map</a>. This version does not force these values.
compose :: Word64Map c -> Word64Map Word64 -> Word64Map c

-- | &lt;math&gt;. A high-performance universal combining function. Using
--   <a>mergeWithKey</a>, all combining functions can be defined without
--   any loss of efficiency (with exception of <a>union</a>,
--   <a>difference</a> and <a>intersection</a>, where sharing of some nodes
--   is lost with <a>mergeWithKey</a>).
--   
--   Please make sure you know what is going on when using
--   <a>mergeWithKey</a>, otherwise you can be surprised by unexpected code
--   growth or even corruption of the data structure.
--   
--   When <a>mergeWithKey</a> is given three arguments, it is inlined to
--   the call site. You should therefore use <a>mergeWithKey</a> only to
--   define your custom combining functions. For example, you could define
--   <a>unionWithKey</a>, <a>differenceWithKey</a> and
--   <a>intersectionWithKey</a> as
--   
--   <pre>
--   myUnionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) id id m1 m2
--   myDifferenceWithKey f m1 m2 = mergeWithKey f id (const empty) m1 m2
--   myIntersectionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) (const empty) (const empty) m1 m2
--   </pre>
--   
--   When calling <tt><a>mergeWithKey</a> combine only1 only2</tt>, a
--   function combining two <a>Word64Map</a>s is created, such that
--   
--   <ul>
--   <li>if a key is present in both maps, it is passed with both
--   corresponding values to the <tt>combine</tt> function. Depending on
--   the result, the key is either present in the result with specified
--   value, or is left out;</li>
--   <li>a nonempty subtree present only in the first map is passed to
--   <tt>only1</tt> and the output is added to the result;</li>
--   <li>a nonempty subtree present only in the second map is passed to
--   <tt>only2</tt> and the output is added to the result.</li>
--   </ul>
--   
--   The <tt>only1</tt> and <tt>only2</tt> methods <i>must return a map
--   with a subset (possibly empty) of the keys of the given map</i>. The
--   values can be modified arbitrarily. Most common variants of
--   <tt>only1</tt> and <tt>only2</tt> are <a>id</a> and <tt><a>const</a>
--   <a>empty</a></tt>, but for example <tt><a>map</a> f</tt> or
--   <tt><a>filterWithKey</a> f</tt> could be used for any <tt>f</tt>.
mergeWithKey :: (Key -> a -> b -> Maybe c) -> (Word64Map a -> Word64Map c) -> (Word64Map b -> Word64Map c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. Map a function over all values in the map.
--   
--   <pre>
--   map (++ "x") (fromList [(5,"a"), (3,"b")]) == fromList [(3, "bx"), (5, "ax")]
--   </pre>
map :: (a -> b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map a function over all values in the map.
--   
--   <pre>
--   let f key x = (show key) ++ ":" ++ x
--   mapWithKey f (fromList [(5,"a"), (3,"b")]) == fromList [(3, "3:b"), (5, "5:a")]
--   </pre>
mapWithKey :: (Key -> a -> b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. <tt><a>traverseWithKey</a> f s == <a>fromList</a>
--   <a>$</a> <a>traverse</a> ((k, v) -&gt; (,) k <a>$</a> f k v)
--   (<a>toList</a> m)</tt> That is, behaves exactly like a regular
--   <a>traverse</a> except that the traversing function also has access to
--   the key associated with a value.
--   
--   <pre>
--   traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(1, 'a'), (5, 'e')]) == Just (fromList [(1, 'b'), (5, 'f')])
--   traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(2, 'c')])           == Nothing
--   </pre>
traverseWithKey :: Applicative t => (Key -> a -> t b) -> Word64Map a -> t (Word64Map b)

-- | &lt;math&gt;. Traverse keys/values and collect the <a>Just</a>
--   results.
traverseMaybeWithKey :: Applicative f => (Key -> a -> f (Maybe b)) -> Word64Map a -> f (Word64Map b)

-- | &lt;math&gt;. The function <tt><a>mapAccum</a></tt> threads an
--   accumulating argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a b = (a ++ b, b ++ "X")
--   mapAccum f "Everything: " (fromList [(5,"a"), (3,"b")]) == ("Everything: ba", fromList [(3, "bX"), (5, "aX")])
--   </pre>
mapAccum :: (a -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. The function <tt><a>mapAccumWithKey</a></tt> threads an
--   accumulating argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a k b = (a ++ " " ++ (show k) ++ "-" ++ b, b ++ "X")
--   mapAccumWithKey f "Everything:" (fromList [(5,"a"), (3,"b")]) == ("Everything: 3-b 5-a", fromList [(3, "bX"), (5, "aX")])
--   </pre>
mapAccumWithKey :: (a -> Key -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. The function <tt><a>mapAccumRWithKey</a></tt> threads an
--   accumulating argument through the map in descending order of keys.
mapAccumRWithKey :: (a -> Key -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. <tt><a>mapKeys</a> f s</tt> is the map obtained by
--   applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the value at the
--   greatest of the original keys is retained.
--   
--   <pre>
--   mapKeys (+ 1) (fromList [(5,"a"), (3,"b")])                        == fromList [(4, "b"), (6, "a")]
--   mapKeys (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "c"
--   mapKeys (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "c"
--   </pre>
mapKeys :: (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. <tt><a>mapKeysWith</a> c f s</tt> is the map obtained by
--   applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the associated values
--   will be combined using <tt>c</tt>.
--   
--   <pre>
--   mapKeysWith (++) (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "cdab"
--   mapKeysWith (++) (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "cdab"
--   </pre>
mapKeysWith :: (a -> a -> a) -> (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. <tt><a>mapKeysMonotonic</a> f s == <a>mapKeys</a> f
--   s</tt>, but works only when <tt>f</tt> is strictly monotonic. That is,
--   for any values <tt>x</tt> and <tt>y</tt>, if <tt>x</tt> &lt;
--   <tt>y</tt> then <tt>f x</tt> &lt; <tt>f y</tt>. <i>The precondition is
--   not checked.</i> Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
--                       ==&gt; mapKeysMonotonic f s == mapKeys f s
--       where ls = keys s
--   </pre>
--   
--   This means that <tt>f</tt> maps distinct original keys to distinct
--   resulting keys. This function has slightly better performance than
--   <a>mapKeys</a>.
--   
--   <pre>
--   mapKeysMonotonic (\ k -&gt; k * 2) (fromList [(5,"a"), (3,"b")]) == fromList [(6, "b"), (10, "a")]
--   </pre>
mapKeysMonotonic :: (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Fold the values in the map using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>elems</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elems map = foldr (:) [] map
--   </pre>
--   
--   <pre>
--   let f a len = len + (length a)
--   foldr f 0 (fromList [(5,"a"), (3,"bbb")]) == 4
--   </pre>
foldr :: (a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. Fold the values in the map using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>elems</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elems = reverse . foldl (flip (:)) []
--   </pre>
--   
--   <pre>
--   let f len a = len + (length a)
--   foldl f 0 (fromList [(5,"a"), (3,"bbb")]) == 4
--   </pre>
foldl :: (a -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   right-associative binary operator, such that <tt><a>foldrWithKey</a> f
--   z == <a>foldr</a> (<a>uncurry</a> f) z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keys map = foldrWithKey (\k x ks -&gt; k:ks) [] map
--   </pre>
--   
--   <pre>
--   let f k a result = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
--   foldrWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (5:a)(3:b)"
--   </pre>
foldrWithKey :: (Key -> a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   left-associative binary operator, such that <tt><a>foldlWithKey</a> f
--   z == <a>foldl</a> (\z' (kx, x) -&gt; f z' kx x) z .
--   <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keys = reverse . foldlWithKey (\ks k x -&gt; k:ks) []
--   </pre>
--   
--   <pre>
--   let f result k a = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
--   foldlWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (3:b)(5:a)"
--   </pre>
foldlWithKey :: (a -> Key -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   monoid, such that
--   
--   <pre>
--   <a>foldMapWithKey</a> f = <a>fold</a> . <a>mapWithKey</a> f
--   </pre>
--   
--   This can be an asymptotically faster than <a>foldrWithKey</a> or
--   <a>foldlWithKey</a> for some monoids.
foldMapWithKey :: Monoid m => (Key -> a -> m) -> Word64Map a -> m

-- | &lt;math&gt;. A strict version of <a>foldr</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldr' :: (a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. A strict version of <a>foldl</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldl' :: (a -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. A strict version of <a>foldrWithKey</a>. Each
--   application of the operator is evaluated before using the result in
--   the next application. This function is strict in the starting value.
foldrWithKey' :: (Key -> a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. A strict version of <a>foldlWithKey</a>. Each
--   application of the operator is evaluated before using the result in
--   the next application. This function is strict in the starting value.
foldlWithKey' :: (a -> Key -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Return all elements of the map in the ascending order of
--   their keys. Subject to list fusion.
--   
--   <pre>
--   elems (fromList [(5,"a"), (3,"b")]) == ["b","a"]
--   elems empty == []
--   </pre>
elems :: Word64Map a -> [a]

-- | &lt;math&gt;. Return all keys of the map in ascending order. Subject
--   to list fusion.
--   
--   <pre>
--   keys (fromList [(5,"a"), (3,"b")]) == [3,5]
--   keys empty == []
--   </pre>
keys :: Word64Map a -> [Key]

-- | &lt;math&gt;. An alias for <a>toAscList</a>. Returns all key/value
--   pairs in the map in ascending key order. Subject to list fusion.
--   
--   <pre>
--   assocs (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   assocs empty == []
--   </pre>
assocs :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. The set of all keys of the map.
--   
--   <pre>
--   keysSet (fromList [(5,"a"), (3,"b")]) == Data.Word64Set.fromList [3,5]
--   keysSet empty == Data.Word64Set.empty
--   </pre>
keysSet :: Word64Map a -> Word64Set

-- | &lt;math&gt;. Convert the map to a list of key/value pairs. Subject to
--   list fusion.
--   
--   <pre>
--   toList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   toList empty == []
--   </pre>
toList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Convert the map to a list of key/value pairs where the
--   keys are in ascending order. Subject to list fusion.
--   
--   <pre>
--   toAscList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   </pre>
toAscList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Convert the map to a list of key/value pairs where the
--   keys are in descending order. Subject to list fusion.
--   
--   <pre>
--   toDescList (fromList [(5,"a"), (3,"b")]) == [(5,"a"), (3,"b")]
--   </pre>
toDescList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Filter all values that satisfy some predicate.
--   
--   <pre>
--   filter (&gt; "a") (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   filter (&gt; "x") (fromList [(5,"a"), (3,"b")]) == empty
--   filter (&lt; "a") (fromList [(5,"a"), (3,"b")]) == empty
--   </pre>
filter :: (a -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Filter all keys/values that satisfy some predicate.
--   
--   <pre>
--   filterWithKey (\k _ -&gt; k &gt; 4) (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
filterWithKey :: (Key -> a -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The restriction of a map to the keys in a set.
--   
--   <pre>
--   m `restrictKeys` s = <a>filterWithKey</a> (\k _ -&gt; k <a>`member`</a> s) m
--   </pre>
restrictKeys :: Word64Map a -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Remove all the keys in a given set from a map.
--   
--   <pre>
--   m `withoutKeys` s = <a>filterWithKey</a> (\k _ -&gt; k <a>`notMember`</a> s) m
--   </pre>
withoutKeys :: Word64Map a -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Partition the map according to some predicate. The first
--   map contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate. See also <a>split</a>.
--   
--   <pre>
--   partition (&gt; "a") (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
--   partition (&lt; "x") (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
--   partition (&gt; "x") (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])
--   </pre>
partition :: (a -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Partition the map according to some predicate. The first
--   map contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate. See also <a>split</a>.
--   
--   <pre>
--   partitionWithKey (\ k _ -&gt; k &gt; 3) (fromList [(5,"a"), (3,"b")]) == (singleton 5 "a", singleton 3 "b")
--   partitionWithKey (\ k _ -&gt; k &lt; 7) (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
--   partitionWithKey (\ k _ -&gt; k &gt; 7) (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])
--   </pre>
partitionWithKey :: (Key -> a -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Take while a predicate on the keys holds. The user is
--   responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   takeWhileAntitone p = <a>fromDistinctAscList</a> . <a>takeWhile</a> (p . fst) . <a>toList</a>
--   takeWhileAntitone p = <a>filterWithKey</a> (\k _ -&gt; p k)
--   </pre>
takeWhileAntitone :: (Key -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Drop while a predicate on the keys holds. The user is
--   responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   dropWhileAntitone p = <a>fromDistinctAscList</a> . <a>dropWhile</a> (p . fst) . <a>toList</a>
--   dropWhileAntitone p = <a>filterWithKey</a> (\k _ -&gt; not (p k))
--   </pre>
dropWhileAntitone :: (Key -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Divide a map at the point where a predicate on the keys
--   stops holding. The user is responsible for ensuring that for all
--   <tt>Int</tt>s, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>.
--   
--   <pre>
--   spanAntitone p xs = (<a>takeWhileAntitone</a> p xs, <a>dropWhileAntitone</a> p xs)
--   spanAntitone p xs = <a>partitionWithKey</a> (\k _ -&gt; p k) xs
--   </pre>
--   
--   Note: if <tt>p</tt> is not actually antitone, then
--   <tt>spanAntitone</tt> will split the map at some <i>unspecified</i>
--   point.
spanAntitone :: (Key -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Map values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   mapMaybe f (fromList [(5,"a"), (3,"b")]) == singleton 5 "new a"
--   </pre>
mapMaybe :: (a -> Maybe b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map keys/values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f k _ = if k &lt; 5 then Just ("key : " ++ (show k)) else Nothing
--   mapMaybeWithKey f (fromList [(5,"a"), (3,"b")]) == singleton 3 "key : 3"
--   </pre>
mapMaybeWithKey :: (Key -> a -> Maybe b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map values and separate the <a>Left</a> and <a>Right</a>
--   results.
--   
--   <pre>
--   let f a = if a &lt; "c" then Left a else Right a
--   mapEither f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (fromList [(3,"b"), (5,"a")], fromList [(1,"x"), (7,"z")])
--   
--   mapEither (\ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (empty, fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--   </pre>
mapEither :: (a -> Either b c) -> Word64Map a -> (Word64Map b, Word64Map c)

-- | &lt;math&gt;. Map keys/values and separate the <a>Left</a> and
--   <a>Right</a> results.
--   
--   <pre>
--   let f k a = if k &lt; 5 then Left (k * 2) else Right (a ++ a)
--   mapEitherWithKey f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (fromList [(1,2), (3,6)], fromList [(5,"aa"), (7,"zz")])
--   
--   mapEitherWithKey (\_ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (empty, fromList [(1,"x"), (3,"b"), (5,"a"), (7,"z")])
--   </pre>
mapEitherWithKey :: (Key -> a -> Either b c) -> Word64Map a -> (Word64Map b, Word64Map c)

-- | &lt;math&gt;. The expression (<tt><a>split</a> k map</tt>) is a pair
--   <tt>(map1,map2)</tt> where all keys in <tt>map1</tt> are lower than
--   <tt>k</tt> and all keys in <tt>map2</tt> larger than <tt>k</tt>. Any
--   key equal to <tt>k</tt> is found in neither <tt>map1</tt> nor
--   <tt>map2</tt>.
--   
--   <pre>
--   split 2 (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3,"b"), (5,"a")])
--   split 3 (fromList [(5,"a"), (3,"b")]) == (empty, singleton 5 "a")
--   split 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
--   split 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", empty)
--   split 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], empty)
--   </pre>
split :: Key -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Performs a <a>split</a> but also returns whether the
--   pivot key was found in the original map.
--   
--   <pre>
--   splitLookup 2 (fromList [(5,"a"), (3,"b")]) == (empty, Nothing, fromList [(3,"b"), (5,"a")])
--   splitLookup 3 (fromList [(5,"a"), (3,"b")]) == (empty, Just "b", singleton 5 "a")
--   splitLookup 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Nothing, singleton 5 "a")
--   splitLookup 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Just "a", empty)
--   splitLookup 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], Nothing, empty)
--   </pre>
splitLookup :: Key -> Word64Map a -> (Word64Map a, Maybe a, Word64Map a)

-- | &lt;math&gt;. Decompose a map into pieces based on the structure of
--   the underlying tree. This function is useful for consuming a map in
--   parallel.
--   
--   No guarantee is made as to the sizes of the pieces; an internal, but
--   deterministic process determines this. However, it is guaranteed that
--   the pieces returned will be in ascending order (all elements in the
--   first submap less than all elements in the second, and so on).
--   
--   Examples:
--   
--   <pre>
--   splitRoot (fromList (zip [1..6::Int] ['a'..])) ==
--     [fromList [(1,'a'),(2,'b'),(3,'c')],fromList [(4,'d'),(5,'e'),(6,'f')]]
--   </pre>
--   
--   <pre>
--   splitRoot empty == []
--   </pre>
--   
--   Note that the current implementation does not return more than two
--   submaps, but you should not depend on this behaviour because it can
--   change in the future without notice.
splitRoot :: Word64Map a -> [Word64Map a]

-- | &lt;math&gt;. Is this a submap? Defined as (<tt><a>isSubmapOf</a> =
--   <a>isSubmapOfBy</a> (==)</tt>).
isSubmapOf :: Eq a => Word64Map a -> Word64Map a -> Bool

-- | &lt;math&gt;. The expression (<tt><a>isSubmapOfBy</a> f m1 m2</tt>)
--   returns <a>True</a> if all keys in <tt>m1</tt> are in <tt>m2</tt>, and
--   when <tt>f</tt> returns <a>True</a> when applied to their respective
--   values. For example, the following expressions are all <a>True</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (&lt;=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [(1,2)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (&lt;) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
--   </pre>
isSubmapOfBy :: (a -> b -> Bool) -> Word64Map a -> Word64Map b -> Bool

-- | &lt;math&gt;. Is this a proper submap? (ie. a submap but not equal).
--   Defined as (<tt><a>isProperSubmapOf</a> = <a>isProperSubmapOfBy</a>
--   (==)</tt>).
isProperSubmapOf :: Eq a => Word64Map a -> Word64Map a -> Bool

-- | &lt;math&gt;. Is this a proper submap? (ie. a submap but not equal).
--   The expression (<tt><a>isProperSubmapOfBy</a> f m1 m2</tt>) returns
--   <a>True</a> when <tt>keys m1</tt> and <tt>keys m2</tt> are not equal,
--   all keys in <tt>m1</tt> are in <tt>m2</tt>, and when <tt>f</tt>
--   returns <a>True</a> when applied to their respective values. For
--   example, the following expressions are all <a>True</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isProperSubmapOfBy (&lt;=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
--   isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
--   isProperSubmapOfBy (&lt;)  (fromList [(1,1)])       (fromList [(1,1),(2,2)])
--   </pre>
isProperSubmapOfBy :: (a -> b -> Bool) -> Word64Map a -> Word64Map b -> Bool

-- | &lt;math&gt;. The minimal key of the map. Returns <a>Nothing</a> if
--   the map is empty.
lookupMin :: Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. The maximal key of the map. Returns <a>Nothing</a> if
--   the map is empty.
lookupMax :: Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. The minimal key of the map. Calls <a>error</a> if the
--   map is empty. Use <a>minViewWithKey</a> if the map may be empty.
findMin :: Word64Map a -> (Key, a)

-- | &lt;math&gt;. The maximal key of the map. Calls <a>error</a> if the
--   map is empty. Use <a>maxViewWithKey</a> if the map may be empty.
findMax :: Word64Map a -> (Key, a)

-- | &lt;math&gt;. Delete the minimal key. Returns an empty map if the map
--   is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Map</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Map</a> was already empty.
deleteMin :: Word64Map a -> Word64Map a

-- | &lt;math&gt;. Delete the maximal key. Returns an empty map if the map
--   is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Map</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Map</a> was already empty.
deleteMax :: Word64Map a -> Word64Map a

-- | &lt;math&gt;. Delete and find the minimal element. This function
--   throws an error if the map is empty. Use <a>minViewWithKey</a> if the
--   map may be empty.
deleteFindMin :: Word64Map a -> ((Key, a), Word64Map a)

-- | &lt;math&gt;. Delete and find the maximal element. This function
--   throws an error if the map is empty. Use <a>maxViewWithKey</a> if the
--   map may be empty.
deleteFindMax :: Word64Map a -> ((Key, a), Word64Map a)

-- | &lt;math&gt;. Update the value at the minimal key.
--   
--   <pre>
--   updateMin (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "Xb"), (5, "a")]
--   updateMin (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateMin :: (a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the maximal key.
--   
--   <pre>
--   updateMax (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "Xa")]
--   updateMax (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   </pre>
updateMax :: (a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the minimal key.
--   
--   <pre>
--   updateMinWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"3:b"), (5,"a")]
--   updateMinWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateMinWithKey :: (Key -> a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the maximal key.
--   
--   <pre>
--   updateMaxWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"b"), (5,"5:a")]
--   updateMaxWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   </pre>
updateMaxWithKey :: (Key -> a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Retrieves the minimal key of the map, and the map
--   stripped of that element, or <a>Nothing</a> if passed an empty map.
minView :: Word64Map a -> Maybe (a, Word64Map a)

-- | &lt;math&gt;. Retrieves the maximal key of the map, and the map
--   stripped of that element, or <a>Nothing</a> if passed an empty map.
maxView :: Word64Map a -> Maybe (a, Word64Map a)

-- | &lt;math&gt;. Retrieves the minimal (key,value) pair of the map, and
--   the map stripped of that element, or <a>Nothing</a> if passed an empty
--   map.
--   
--   <pre>
--   minViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((3,"b"), singleton 5 "a")
--   minViewWithKey empty == Nothing
--   </pre>
minViewWithKey :: Word64Map a -> Maybe ((Key, a), Word64Map a)

-- | &lt;math&gt;. Retrieves the maximal (key,value) pair of the map, and
--   the map stripped of that element, or <a>Nothing</a> if passed an empty
--   map.
--   
--   <pre>
--   maxViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((5,"a"), singleton 3 "b")
--   maxViewWithKey empty == Nothing
--   </pre>
maxViewWithKey :: Word64Map a -> Maybe ((Key, a), Word64Map a)


-- | <h1>Finite Word64 Maps (lazy interface)</h1>
--   
--   The <tt><a>Word64Map</a> v</tt> type represents a finite map
--   (sometimes called a dictionary) from keys of type <tt>Word64</tt> to
--   values of type <tt>v</tt>.
--   
--   The functions in <a>Data.Word64Map.Strict</a> are careful to force
--   values before installing them in an <a>Word64Map</a>. This is usually
--   more efficient in cases where laziness is not essential. The functions
--   in this module do not do so.
--   
--   For a walkthrough of the most commonly used functions see the <a>maps
--   introduction</a>.
--   
--   This module is intended to be imported qualified, to avoid name
--   clashes with Prelude functions:
--   
--   <pre>
--   import Data.Word64Map.Lazy (Word64Map)
--   import qualified Data.Word64Map.Lazy as Word64Map
--   </pre>
--   
--   Note that the implementation is generally <i>left-biased</i>.
--   Functions that take two maps as arguments and combine them, such as
--   <a>union</a> and <a>intersection</a>, prefer the values in the first
--   argument to those in the second.
--   
--   <h2>Detailed performance information</h2>
--   
--   The amortized running time is given for each operation, with
--   &lt;math&gt; referring to the number of entries in the map and
--   &lt;math&gt; referring to the number of bits in an <tt>Word64</tt>
--   (64).
--   
--   Benchmarks comparing <a>Data.Word64Map.Lazy</a> with other dictionary
--   implementations can be found at
--   <a>https://github.com/haskell-perf/dictionaries</a>.
--   
--   <h2>Implementation</h2>
--   
--   The implementation is based on <i>big-endian patricia trees</i>. This
--   data structure performs especially well on binary operations like
--   <a>union</a> and <a>intersection</a>. Additionally, benchmarks show
--   that it is also (much) faster on insertions and deletions when
--   compared to a generic size-balanced map implementation (see
--   <a>Data.Map</a>).
--   
--   <ul>
--   <li>Chris Okasaki and Andy Gill, "<i>Fast Mergeable Integer Maps</i>",
--   Workshop on ML, September 1998, pages 77-86,
--   <a>http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.5452</a></li>
--   <li>D.R. Morrison, "<i>PATRICIA -- Practical Algorithm To Retrieve
--   Information Coded In Alphanumeric</i>", Journal of the ACM, 15(4),
--   October 1968, pages 514-534.</li>
--   </ul>
module GHC.Data.Word64Map.Lazy

-- | A map of integers to values <tt>a</tt>.
data Word64Map a
type Key = Word64

-- | &lt;math&gt;. The empty map.
--   
--   <pre>
--   empty      == fromList []
--   size empty == 0
--   </pre>
empty :: Word64Map a

-- | &lt;math&gt;. A map of one element.
--   
--   <pre>
--   singleton 1 'a'        == fromList [(1, 'a')]
--   size (singleton 1 'a') == 1
--   </pre>
singleton :: Key -> a -> Word64Map a

-- | &lt;math&gt;. Build a map from a set of keys and a function which for
--   each key computes its value.
--   
--   <pre>
--   fromSet (\k -&gt; replicate k 'a') (Data.Word64Set.fromList [3, 5]) == fromList [(5,"aaaaa"), (3,"aaa")]
--   fromSet undefined Data.Word64Set.empty == empty
--   </pre>
fromSet :: (Key -> a) -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Create a map from a list of key/value pairs.
--   
--   <pre>
--   fromList [] == empty
--   fromList [(5,"a"), (3,"b"), (5, "c")] == fromList [(5,"c"), (3,"b")]
--   fromList [(5,"c"), (3,"b"), (5, "a")] == fromList [(5,"a"), (3,"b")]
--   </pre>
fromList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Create a map from a list of key/value pairs with a
--   combining function. See also <a>fromAscListWith</a>.
--   
--   <pre>
--   fromListWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")] == fromList [(3, "ab"), (5, "cba")]
--   fromListWith (++) [] == empty
--   </pre>
fromListWith :: (a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs with a
--   combining function. See also fromAscListWithKey'.
--   
--   <pre>
--   let f key new_value old_value = show key ++ ":" ++ new_value ++ "|" ++ old_value
--   fromListWithKey f [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")] == fromList [(3, "3:a|b"), (5, "5:c|5:b|a")]
--   fromListWithKey f [] == empty
--   </pre>
fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order.
--   
--   <pre>
--   fromAscList [(3,"b"), (5,"a")]          == fromList [(3, "b"), (5, "a")]
--   fromAscList [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "b")]
--   </pre>
fromAscList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order, with a combining function on equal keys.
--   <i>The precondition (input list is ascending) is not checked.</i>
--   
--   <pre>
--   fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]
--   </pre>
fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order, with a combining function on equal keys.
--   <i>The precondition (input list is ascending) is not checked.</i>
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   fromAscListWithKey f [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "5:b|a")]
--   </pre>
fromAscListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order and all distinct. <i>The precondition
--   (input list is strictly ascending) is not checked.</i>
--   
--   <pre>
--   fromDistinctAscList [(3,"b"), (5,"a")] == fromList [(3, "b"), (5, "a")]
--   </pre>
fromDistinctAscList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Insert a new key/value pair in the map. If the key is
--   already present in the map, the associated value is replaced with the
--   supplied value, i.e. <a>insert</a> is equivalent to
--   <tt><a>insertWith</a> <a>const</a></tt>.
--   
--   <pre>
--   insert 5 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'x')]
--   insert 7 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'a'), (7, 'x')]
--   insert 5 'x' empty                         == singleton 5 'x'
--   </pre>
insert :: Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Insert with a combining function. <tt><a>insertWith</a>
--   f key value mp</tt> will insert the pair (key, value) into <tt>mp</tt>
--   if key does not exist in the map. If the key does exist, the function
--   will insert <tt>f new_value old_value</tt>.
--   
--   <pre>
--   insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "xxxa")]
--   insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWith (++) 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
insertWith :: (a -> a -> a) -> Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Insert with a combining function.
--   <tt><a>insertWithKey</a> f key value mp</tt> will insert the pair
--   (key, value) into <tt>mp</tt> if key does not exist in the map. If the
--   key does exist, the function will insert <tt>f key new_value
--   old_value</tt>.
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:xxx|a")]
--   insertWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWithKey f 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>insertLookupWithKey</a> f k x
--   map</tt>) is a pair where the first element is equal to
--   (<tt><a>lookup</a> k map</tt>) and the second element equal to
--   (<tt><a>insertWithKey</a> f k x map</tt>).
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertLookupWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:xxx|a")])
--   insertLookupWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "xxx")])
--   insertLookupWithKey f 5 "xxx" empty                         == (Nothing,  singleton 5 "xxx")
--   </pre>
--   
--   This is how to define <tt>insertLookup</tt> using
--   <tt>insertLookupWithKey</tt>:
--   
--   <pre>
--   let insertLookup kx x t = insertLookupWithKey (\_ a _ -&gt; a) kx x t
--   insertLookup 5 "x" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "x")])
--   insertLookup 7 "x" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "x")])
--   </pre>
insertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> Word64Map a -> (Maybe a, Word64Map a)

-- | &lt;math&gt;. Delete a key and its value from the map. When the key is
--   not a member of the map, the original map is returned.
--   
--   <pre>
--   delete 5 (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   delete 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   delete 5 empty                         == empty
--   </pre>
delete :: Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Adjust a value at a specific key. When the key is not a
--   member of the map, the original map is returned.
--   
--   <pre>
--   adjust ("new " ++) 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
--   adjust ("new " ++) 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   adjust ("new " ++) 7 empty                         == empty
--   </pre>
adjust :: (a -> a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Adjust a value at a specific key. When the key is not a
--   member of the map, the original map is returned.
--   
--   <pre>
--   let f key x = (show key) ++ ":new " ++ x
--   adjustWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
--   adjustWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   adjustWithKey f 7 empty                         == empty
--   </pre>
adjustWithKey :: (Key -> a -> a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>update</a> f k map</tt>) updates
--   the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If (<tt>f
--   x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   update f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
--   update f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   update f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
update :: (a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>update</a> f k map</tt>) updates
--   the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If (<tt>f k
--   x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
--   updateWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   updateWithKey f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateWithKey :: (Key -> a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Lookup and update. The function returns original value,
--   if it is updated. This is different behavior than
--   <a>updateLookupWithKey</a>. Returns the original key value if the map
--   entry is deleted.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateLookupWithKey f 5 (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:new a")])
--   updateLookupWithKey f 7 (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a")])
--   updateLookupWithKey f 3 (fromList [(5,"a"), (3,"b")]) == (Just "b", singleton 5 "a")
--   </pre>
updateLookupWithKey :: (Key -> a -> Maybe a) -> Key -> Word64Map a -> (Maybe a, Word64Map a)

-- | &lt;math&gt;. The expression (<tt><a>alter</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alter</a>
--   can be used to insert, delete, or update a value in an
--   <a>Word64Map</a>. In short : <tt><a>lookup</a> k (<a>alter</a> f k m)
--   = f (<a>lookup</a> k m)</tt>.
alter :: (Maybe a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>alterF</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alterF</a>
--   can be used to inspect, insert, delete, or update a value in an
--   <a>Word64Map</a>. In short : <tt><a>lookup</a> k <a>$</a>
--   <a>alterF</a> f k m = f (<a>lookup</a> k m)</tt>.
--   
--   Example:
--   
--   <pre>
--   interactiveAlter :: Int -&gt; Word64Map String -&gt; IO (Word64Map String)
--   interactiveAlter k m = alterF f k m where
--     f Nothing = do
--        putStrLn $ show k ++
--            " was not found in the map. Would you like to add it?"
--        getUserResponse1 :: IO (Maybe String)
--     f (Just old) = do
--        putStrLn $ "The key is currently bound to " ++ show old ++
--            ". Would you like to change or delete it?"
--        getUserResponse2 :: IO (Maybe String)
--   </pre>
--   
--   <a>alterF</a> is the most general operation for working with an
--   individual key that may or may not be in a given map.
--   
--   Note: <a>alterF</a> is a flipped version of the <tt>at</tt> combinator
--   from <tt>Control.Lens.At</tt>.
alterF :: Functor f => (Maybe a -> f (Maybe a)) -> Key -> Word64Map a -> f (Word64Map a)

-- | &lt;math&gt;. Lookup the value at a key in the map. See also
--   <a>lookup</a>.
lookup :: Key -> Word64Map a -> Maybe a

-- | &lt;math&gt;. Find the value at a key. Returns <a>Nothing</a> when the
--   element can not be found.
--   
--   <pre>
--   fromList [(5,'a'), (3,'b')] !? 1 == Nothing
--   fromList [(5,'a'), (3,'b')] !? 5 == Just 'a'
--   </pre>
(!?) :: Word64Map a -> Key -> Maybe a
infixl 9 !?

-- | &lt;math&gt;. Find the value at a key. Calls <a>error</a> when the
--   element can not be found.
--   
--   <pre>
--   fromList [(5,'a'), (3,'b')] ! 1    Error: element not in the map
--   fromList [(5,'a'), (3,'b')] ! 5 == 'a'
--   </pre>
(!) :: Word64Map a -> Key -> a

-- | &lt;math&gt;. The expression <tt>(<a>findWithDefault</a> def k
--   map)</tt> returns the value at key <tt>k</tt> or returns <tt>def</tt>
--   when the key is not an element of the map.
--   
--   <pre>
--   findWithDefault 'x' 1 (fromList [(5,'a'), (3,'b')]) == 'x'
--   findWithDefault 'x' 5 (fromList [(5,'a'), (3,'b')]) == 'a'
--   </pre>
findWithDefault :: a -> Key -> Word64Map a -> a

-- | &lt;math&gt;. Is the key a member of the map?
--   
--   <pre>
--   member 5 (fromList [(5,'a'), (3,'b')]) == True
--   member 1 (fromList [(5,'a'), (3,'b')]) == False
--   </pre>
member :: Key -> Word64Map a -> Bool

-- | &lt;math&gt;. Is the key not a member of the map?
--   
--   <pre>
--   notMember 5 (fromList [(5,'a'), (3,'b')]) == False
--   notMember 1 (fromList [(5,'a'), (3,'b')]) == True
--   </pre>
notMember :: Key -> Word64Map a -> Bool

-- | &lt;math&gt;. Find largest key smaller than the given one and return
--   the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLT 3 (fromList [(3,'a'), (5,'b')]) == Nothing
--   lookupLT 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   </pre>
lookupLT :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find smallest key greater than the given one and return
--   the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGT 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   lookupGT 5 (fromList [(3,'a'), (5,'b')]) == Nothing
--   </pre>
lookupGT :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find largest key smaller or equal to the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLE 2 (fromList [(3,'a'), (5,'b')]) == Nothing
--   lookupLE 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   lookupLE 5 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   </pre>
lookupLE :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find smallest key greater or equal to the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGE 3 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   lookupGE 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   lookupGE 6 (fromList [(3,'a'), (5,'b')]) == Nothing
--   </pre>
lookupGE :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Is the map empty?
--   
--   <pre>
--   Data.Word64Map.null (empty)           == True
--   Data.Word64Map.null (singleton 1 'a') == False
--   </pre>
null :: Word64Map a -> Bool

-- | &lt;math&gt;. Number of elements in the map.
--   
--   <pre>
--   size empty                                   == 0
--   size (singleton 1 'a')                       == 1
--   size (fromList([(1,'a'), (2,'c'), (3,'b')])) == 3
--   </pre>
size :: Word64Map a -> Int

-- | &lt;math&gt;. The (left-biased) union of two maps. It prefers the
--   first map when duplicate keys are encountered, i.e. (<tt><a>union</a>
--   == <a>unionWith</a> <a>const</a></tt>).
--   
--   <pre>
--   union (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "a"), (7, "C")]
--   </pre>
union :: Word64Map a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The union with a combining function.
--   
--   <pre>
--   unionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "aA"), (7, "C")]
--   </pre>
unionWith :: (a -> a -> a) -> Word64Map a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The union with a combining function.
--   
--   <pre>
--   let f key left_value right_value = (show key) ++ ":" ++ left_value ++ "|" ++ right_value
--   unionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "5:a|A"), (7, "C")]
--   </pre>
unionWithKey :: (Key -> a -> a -> a) -> Word64Map a -> Word64Map a -> Word64Map a

-- | The union of a list of maps.
--   
--   <pre>
--   unions [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
--       == fromList [(3, "b"), (5, "a"), (7, "C")]
--   unions [(fromList [(5, "A3"), (3, "B3")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "a"), (3, "b")])]
--       == fromList [(3, "B3"), (5, "A3"), (7, "C")]
--   </pre>
unions :: Foldable f => f (Word64Map a) -> Word64Map a

-- | The union of a list of maps, with a combining operation.
--   
--   <pre>
--   unionsWith (++) [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
--       == fromList [(3, "bB3"), (5, "aAA3"), (7, "C")]
--   </pre>
unionsWith :: Foldable f => (a -> a -> a) -> f (Word64Map a) -> Word64Map a

-- | &lt;math&gt;. Difference between two maps (based on keys).
--   
--   <pre>
--   difference (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 3 "b"
--   </pre>
difference :: Word64Map a -> Word64Map b -> Word64Map a

-- | Same as <a>difference</a>.
(\\) :: Word64Map a -> Word64Map b -> Word64Map a
infixl 9 \\

-- | &lt;math&gt;. Difference with a combining function.
--   
--   <pre>
--   let f al ar = if al == "b" then Just (al ++ ":" ++ ar) else Nothing
--   differenceWith f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (7, "C")])
--       == singleton 3 "b:B"
--   </pre>
differenceWith :: (a -> b -> Maybe a) -> Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. Difference with a combining function. When two equal
--   keys are encountered, the combining function is applied to the key and
--   both values. If it returns <a>Nothing</a>, the element is discarded
--   (proper set difference). If it returns (<tt><a>Just</a> y</tt>), the
--   element is updated with a new value <tt>y</tt>.
--   
--   <pre>
--   let f k al ar = if al == "b" then Just ((show k) ++ ":" ++ al ++ "|" ++ ar) else Nothing
--   differenceWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (10, "C")])
--       == singleton 3 "3:b|B"
--   </pre>
differenceWithKey :: (Key -> a -> b -> Maybe a) -> Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. The (left-biased) intersection of two maps (based on
--   keys).
--   
--   <pre>
--   intersection (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "a"
--   </pre>
intersection :: Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. The intersection with a combining function.
--   
--   <pre>
--   intersectionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "aA"
--   </pre>
intersectionWith :: (a -> b -> c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. The intersection with a combining function.
--   
--   <pre>
--   let f k al ar = (show k) ++ ":" ++ al ++ "|" ++ ar
--   intersectionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "5:a|A"
--   </pre>
intersectionWithKey :: (Key -> a -> b -> c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. Check whether the key sets of two maps are disjoint
--   (i.e. their <a>intersection</a> is empty).
--   
--   <pre>
--   disjoint (fromList [(2,'a')]) (fromList [(1,()), (3,())])   == True
--   disjoint (fromList [(2,'a')]) (fromList [(1,'a'), (2,'b')]) == False
--   disjoint (fromList [])        (fromList [])                 == True
--   </pre>
--   
--   <pre>
--   disjoint a b == null (intersection a b)
--   </pre>
disjoint :: Word64Map a -> Word64Map b -> Bool

-- | Relate the keys of one map to the values of the other, by using the
--   values of the former as keys for lookups in the latter.
--   
--   Complexity: &lt;math&gt;, where &lt;math&gt; is the size of the first
--   argument
--   
--   <pre>
--   compose (fromList [('a', "A"), ('b', "B")]) (fromList [(1,'a'),(2,'b'),(3,'z')]) = fromList [(1,"A"),(2,"B")]
--   </pre>
--   
--   <pre>
--   (<a>compose</a> bc ab <a>!?</a>) = (bc <a>!?</a>) &lt;=&lt; (ab <a>!?</a>)
--   </pre>
--   
--   <b>Note:</b> Prior to v0.6.4, <a>Data.Word64Map.Strict</a> exposed a
--   version of <a>compose</a> that forced the values of the output
--   <a>Word64Map</a>. This version does not force these values.
compose :: Word64Map c -> Word64Map Word64 -> Word64Map c

-- | &lt;math&gt;. A high-performance universal combining function. Using
--   <a>mergeWithKey</a>, all combining functions can be defined without
--   any loss of efficiency (with exception of <a>union</a>,
--   <a>difference</a> and <a>intersection</a>, where sharing of some nodes
--   is lost with <a>mergeWithKey</a>).
--   
--   Please make sure you know what is going on when using
--   <a>mergeWithKey</a>, otherwise you can be surprised by unexpected code
--   growth or even corruption of the data structure.
--   
--   When <a>mergeWithKey</a> is given three arguments, it is inlined to
--   the call site. You should therefore use <a>mergeWithKey</a> only to
--   define your custom combining functions. For example, you could define
--   <a>unionWithKey</a>, <a>differenceWithKey</a> and
--   <a>intersectionWithKey</a> as
--   
--   <pre>
--   myUnionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) id id m1 m2
--   myDifferenceWithKey f m1 m2 = mergeWithKey f id (const empty) m1 m2
--   myIntersectionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) (const empty) (const empty) m1 m2
--   </pre>
--   
--   When calling <tt><a>mergeWithKey</a> combine only1 only2</tt>, a
--   function combining two <a>Word64Map</a>s is created, such that
--   
--   <ul>
--   <li>if a key is present in both maps, it is passed with both
--   corresponding values to the <tt>combine</tt> function. Depending on
--   the result, the key is either present in the result with specified
--   value, or is left out;</li>
--   <li>a nonempty subtree present only in the first map is passed to
--   <tt>only1</tt> and the output is added to the result;</li>
--   <li>a nonempty subtree present only in the second map is passed to
--   <tt>only2</tt> and the output is added to the result.</li>
--   </ul>
--   
--   The <tt>only1</tt> and <tt>only2</tt> methods <i>must return a map
--   with a subset (possibly empty) of the keys of the given map</i>. The
--   values can be modified arbitrarily. Most common variants of
--   <tt>only1</tt> and <tt>only2</tt> are <a>id</a> and <tt><a>const</a>
--   <a>empty</a></tt>, but for example <tt><a>map</a> f</tt> or
--   <tt><a>filterWithKey</a> f</tt> could be used for any <tt>f</tt>.
mergeWithKey :: (Key -> a -> b -> Maybe c) -> (Word64Map a -> Word64Map c) -> (Word64Map b -> Word64Map c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. Map a function over all values in the map.
--   
--   <pre>
--   map (++ "x") (fromList [(5,"a"), (3,"b")]) == fromList [(3, "bx"), (5, "ax")]
--   </pre>
map :: (a -> b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map a function over all values in the map.
--   
--   <pre>
--   let f key x = (show key) ++ ":" ++ x
--   mapWithKey f (fromList [(5,"a"), (3,"b")]) == fromList [(3, "3:b"), (5, "5:a")]
--   </pre>
mapWithKey :: (Key -> a -> b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. <tt><a>traverseWithKey</a> f s == <a>fromList</a>
--   <a>$</a> <a>traverse</a> ((k, v) -&gt; (,) k <a>$</a> f k v)
--   (<a>toList</a> m)</tt> That is, behaves exactly like a regular
--   <a>traverse</a> except that the traversing function also has access to
--   the key associated with a value.
--   
--   <pre>
--   traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(1, 'a'), (5, 'e')]) == Just (fromList [(1, 'b'), (5, 'f')])
--   traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(2, 'c')])           == Nothing
--   </pre>
traverseWithKey :: Applicative t => (Key -> a -> t b) -> Word64Map a -> t (Word64Map b)

-- | &lt;math&gt;. Traverse keys/values and collect the <a>Just</a>
--   results.
traverseMaybeWithKey :: Applicative f => (Key -> a -> f (Maybe b)) -> Word64Map a -> f (Word64Map b)

-- | &lt;math&gt;. The function <tt><a>mapAccum</a></tt> threads an
--   accumulating argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a b = (a ++ b, b ++ "X")
--   mapAccum f "Everything: " (fromList [(5,"a"), (3,"b")]) == ("Everything: ba", fromList [(3, "bX"), (5, "aX")])
--   </pre>
mapAccum :: (a -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. The function <tt><a>mapAccumWithKey</a></tt> threads an
--   accumulating argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a k b = (a ++ " " ++ (show k) ++ "-" ++ b, b ++ "X")
--   mapAccumWithKey f "Everything:" (fromList [(5,"a"), (3,"b")]) == ("Everything: 3-b 5-a", fromList [(3, "bX"), (5, "aX")])
--   </pre>
mapAccumWithKey :: (a -> Key -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. The function <tt><a>mapAccumRWithKey</a></tt> threads an
--   accumulating argument through the map in descending order of keys.
mapAccumRWithKey :: (a -> Key -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. <tt><a>mapKeys</a> f s</tt> is the map obtained by
--   applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the value at the
--   greatest of the original keys is retained.
--   
--   <pre>
--   mapKeys (+ 1) (fromList [(5,"a"), (3,"b")])                        == fromList [(4, "b"), (6, "a")]
--   mapKeys (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "c"
--   mapKeys (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "c"
--   </pre>
mapKeys :: (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. <tt><a>mapKeysWith</a> c f s</tt> is the map obtained by
--   applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the associated values
--   will be combined using <tt>c</tt>.
--   
--   <pre>
--   mapKeysWith (++) (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "cdab"
--   mapKeysWith (++) (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "cdab"
--   </pre>
mapKeysWith :: (a -> a -> a) -> (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. <tt><a>mapKeysMonotonic</a> f s == <a>mapKeys</a> f
--   s</tt>, but works only when <tt>f</tt> is strictly monotonic. That is,
--   for any values <tt>x</tt> and <tt>y</tt>, if <tt>x</tt> &lt;
--   <tt>y</tt> then <tt>f x</tt> &lt; <tt>f y</tt>. <i>The precondition is
--   not checked.</i> Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
--                       ==&gt; mapKeysMonotonic f s == mapKeys f s
--       where ls = keys s
--   </pre>
--   
--   This means that <tt>f</tt> maps distinct original keys to distinct
--   resulting keys. This function has slightly better performance than
--   <a>mapKeys</a>.
--   
--   <pre>
--   mapKeysMonotonic (\ k -&gt; k * 2) (fromList [(5,"a"), (3,"b")]) == fromList [(6, "b"), (10, "a")]
--   </pre>
mapKeysMonotonic :: (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Fold the values in the map using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>elems</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elems map = foldr (:) [] map
--   </pre>
--   
--   <pre>
--   let f a len = len + (length a)
--   foldr f 0 (fromList [(5,"a"), (3,"bbb")]) == 4
--   </pre>
foldr :: (a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. Fold the values in the map using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>elems</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elems = reverse . foldl (flip (:)) []
--   </pre>
--   
--   <pre>
--   let f len a = len + (length a)
--   foldl f 0 (fromList [(5,"a"), (3,"bbb")]) == 4
--   </pre>
foldl :: (a -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   right-associative binary operator, such that <tt><a>foldrWithKey</a> f
--   z == <a>foldr</a> (<a>uncurry</a> f) z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keys map = foldrWithKey (\k x ks -&gt; k:ks) [] map
--   </pre>
--   
--   <pre>
--   let f k a result = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
--   foldrWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (5:a)(3:b)"
--   </pre>
foldrWithKey :: (Key -> a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   left-associative binary operator, such that <tt><a>foldlWithKey</a> f
--   z == <a>foldl</a> (\z' (kx, x) -&gt; f z' kx x) z .
--   <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keys = reverse . foldlWithKey (\ks k x -&gt; k:ks) []
--   </pre>
--   
--   <pre>
--   let f result k a = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
--   foldlWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (3:b)(5:a)"
--   </pre>
foldlWithKey :: (a -> Key -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   monoid, such that
--   
--   <pre>
--   <a>foldMapWithKey</a> f = <a>fold</a> . <a>mapWithKey</a> f
--   </pre>
--   
--   This can be an asymptotically faster than <a>foldrWithKey</a> or
--   <a>foldlWithKey</a> for some monoids.
foldMapWithKey :: Monoid m => (Key -> a -> m) -> Word64Map a -> m

-- | &lt;math&gt;. A strict version of <a>foldr</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldr' :: (a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. A strict version of <a>foldl</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldl' :: (a -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. A strict version of <a>foldrWithKey</a>. Each
--   application of the operator is evaluated before using the result in
--   the next application. This function is strict in the starting value.
foldrWithKey' :: (Key -> a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. A strict version of <a>foldlWithKey</a>. Each
--   application of the operator is evaluated before using the result in
--   the next application. This function is strict in the starting value.
foldlWithKey' :: (a -> Key -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Return all elements of the map in the ascending order of
--   their keys. Subject to list fusion.
--   
--   <pre>
--   elems (fromList [(5,"a"), (3,"b")]) == ["b","a"]
--   elems empty == []
--   </pre>
elems :: Word64Map a -> [a]

-- | &lt;math&gt;. Return all keys of the map in ascending order. Subject
--   to list fusion.
--   
--   <pre>
--   keys (fromList [(5,"a"), (3,"b")]) == [3,5]
--   keys empty == []
--   </pre>
keys :: Word64Map a -> [Key]

-- | &lt;math&gt;. An alias for <a>toAscList</a>. Returns all key/value
--   pairs in the map in ascending key order. Subject to list fusion.
--   
--   <pre>
--   assocs (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   assocs empty == []
--   </pre>
assocs :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. The set of all keys of the map.
--   
--   <pre>
--   keysSet (fromList [(5,"a"), (3,"b")]) == Data.Word64Set.fromList [3,5]
--   keysSet empty == Data.Word64Set.empty
--   </pre>
keysSet :: Word64Map a -> Word64Set

-- | &lt;math&gt;. Convert the map to a list of key/value pairs. Subject to
--   list fusion.
--   
--   <pre>
--   toList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   toList empty == []
--   </pre>
toList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Convert the map to a list of key/value pairs where the
--   keys are in ascending order. Subject to list fusion.
--   
--   <pre>
--   toAscList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   </pre>
toAscList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Convert the map to a list of key/value pairs where the
--   keys are in descending order. Subject to list fusion.
--   
--   <pre>
--   toDescList (fromList [(5,"a"), (3,"b")]) == [(5,"a"), (3,"b")]
--   </pre>
toDescList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Filter all values that satisfy some predicate.
--   
--   <pre>
--   filter (&gt; "a") (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   filter (&gt; "x") (fromList [(5,"a"), (3,"b")]) == empty
--   filter (&lt; "a") (fromList [(5,"a"), (3,"b")]) == empty
--   </pre>
filter :: (a -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Filter all keys/values that satisfy some predicate.
--   
--   <pre>
--   filterWithKey (\k _ -&gt; k &gt; 4) (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
filterWithKey :: (Key -> a -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The restriction of a map to the keys in a set.
--   
--   <pre>
--   m `restrictKeys` s = <a>filterWithKey</a> (\k _ -&gt; k <a>`member`</a> s) m
--   </pre>
restrictKeys :: Word64Map a -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Remove all the keys in a given set from a map.
--   
--   <pre>
--   m `withoutKeys` s = <a>filterWithKey</a> (\k _ -&gt; k <a>`notMember`</a> s) m
--   </pre>
withoutKeys :: Word64Map a -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Partition the map according to some predicate. The first
--   map contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate. See also <a>split</a>.
--   
--   <pre>
--   partition (&gt; "a") (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
--   partition (&lt; "x") (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
--   partition (&gt; "x") (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])
--   </pre>
partition :: (a -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Partition the map according to some predicate. The first
--   map contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate. See also <a>split</a>.
--   
--   <pre>
--   partitionWithKey (\ k _ -&gt; k &gt; 3) (fromList [(5,"a"), (3,"b")]) == (singleton 5 "a", singleton 3 "b")
--   partitionWithKey (\ k _ -&gt; k &lt; 7) (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
--   partitionWithKey (\ k _ -&gt; k &gt; 7) (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])
--   </pre>
partitionWithKey :: (Key -> a -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Take while a predicate on the keys holds. The user is
--   responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   takeWhileAntitone p = <a>fromDistinctAscList</a> . <a>takeWhile</a> (p . fst) . <a>toList</a>
--   takeWhileAntitone p = <a>filterWithKey</a> (\k _ -&gt; p k)
--   </pre>
takeWhileAntitone :: (Key -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Drop while a predicate on the keys holds. The user is
--   responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   dropWhileAntitone p = <a>fromDistinctAscList</a> . <a>dropWhile</a> (p . fst) . <a>toList</a>
--   dropWhileAntitone p = <a>filterWithKey</a> (\k _ -&gt; not (p k))
--   </pre>
dropWhileAntitone :: (Key -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Divide a map at the point where a predicate on the keys
--   stops holding. The user is responsible for ensuring that for all
--   <tt>Int</tt>s, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>.
--   
--   <pre>
--   spanAntitone p xs = (<a>takeWhileAntitone</a> p xs, <a>dropWhileAntitone</a> p xs)
--   spanAntitone p xs = <a>partitionWithKey</a> (\k _ -&gt; p k) xs
--   </pre>
--   
--   Note: if <tt>p</tt> is not actually antitone, then
--   <tt>spanAntitone</tt> will split the map at some <i>unspecified</i>
--   point.
spanAntitone :: (Key -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Map values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   mapMaybe f (fromList [(5,"a"), (3,"b")]) == singleton 5 "new a"
--   </pre>
mapMaybe :: (a -> Maybe b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map keys/values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f k _ = if k &lt; 5 then Just ("key : " ++ (show k)) else Nothing
--   mapMaybeWithKey f (fromList [(5,"a"), (3,"b")]) == singleton 3 "key : 3"
--   </pre>
mapMaybeWithKey :: (Key -> a -> Maybe b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map values and separate the <a>Left</a> and <a>Right</a>
--   results.
--   
--   <pre>
--   let f a = if a &lt; "c" then Left a else Right a
--   mapEither f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (fromList [(3,"b"), (5,"a")], fromList [(1,"x"), (7,"z")])
--   
--   mapEither (\ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (empty, fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--   </pre>
mapEither :: (a -> Either b c) -> Word64Map a -> (Word64Map b, Word64Map c)

-- | &lt;math&gt;. Map keys/values and separate the <a>Left</a> and
--   <a>Right</a> results.
--   
--   <pre>
--   let f k a = if k &lt; 5 then Left (k * 2) else Right (a ++ a)
--   mapEitherWithKey f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (fromList [(1,2), (3,6)], fromList [(5,"aa"), (7,"zz")])
--   
--   mapEitherWithKey (\_ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (empty, fromList [(1,"x"), (3,"b"), (5,"a"), (7,"z")])
--   </pre>
mapEitherWithKey :: (Key -> a -> Either b c) -> Word64Map a -> (Word64Map b, Word64Map c)

-- | &lt;math&gt;. The expression (<tt><a>split</a> k map</tt>) is a pair
--   <tt>(map1,map2)</tt> where all keys in <tt>map1</tt> are lower than
--   <tt>k</tt> and all keys in <tt>map2</tt> larger than <tt>k</tt>. Any
--   key equal to <tt>k</tt> is found in neither <tt>map1</tt> nor
--   <tt>map2</tt>.
--   
--   <pre>
--   split 2 (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3,"b"), (5,"a")])
--   split 3 (fromList [(5,"a"), (3,"b")]) == (empty, singleton 5 "a")
--   split 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
--   split 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", empty)
--   split 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], empty)
--   </pre>
split :: Key -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Performs a <a>split</a> but also returns whether the
--   pivot key was found in the original map.
--   
--   <pre>
--   splitLookup 2 (fromList [(5,"a"), (3,"b")]) == (empty, Nothing, fromList [(3,"b"), (5,"a")])
--   splitLookup 3 (fromList [(5,"a"), (3,"b")]) == (empty, Just "b", singleton 5 "a")
--   splitLookup 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Nothing, singleton 5 "a")
--   splitLookup 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Just "a", empty)
--   splitLookup 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], Nothing, empty)
--   </pre>
splitLookup :: Key -> Word64Map a -> (Word64Map a, Maybe a, Word64Map a)

-- | &lt;math&gt;. Decompose a map into pieces based on the structure of
--   the underlying tree. This function is useful for consuming a map in
--   parallel.
--   
--   No guarantee is made as to the sizes of the pieces; an internal, but
--   deterministic process determines this. However, it is guaranteed that
--   the pieces returned will be in ascending order (all elements in the
--   first submap less than all elements in the second, and so on).
--   
--   Examples:
--   
--   <pre>
--   splitRoot (fromList (zip [1..6::Int] ['a'..])) ==
--     [fromList [(1,'a'),(2,'b'),(3,'c')],fromList [(4,'d'),(5,'e'),(6,'f')]]
--   </pre>
--   
--   <pre>
--   splitRoot empty == []
--   </pre>
--   
--   Note that the current implementation does not return more than two
--   submaps, but you should not depend on this behaviour because it can
--   change in the future without notice.
splitRoot :: Word64Map a -> [Word64Map a]

-- | &lt;math&gt;. Is this a submap? Defined as (<tt><a>isSubmapOf</a> =
--   <a>isSubmapOfBy</a> (==)</tt>).
isSubmapOf :: Eq a => Word64Map a -> Word64Map a -> Bool

-- | &lt;math&gt;. The expression (<tt><a>isSubmapOfBy</a> f m1 m2</tt>)
--   returns <a>True</a> if all keys in <tt>m1</tt> are in <tt>m2</tt>, and
--   when <tt>f</tt> returns <a>True</a> when applied to their respective
--   values. For example, the following expressions are all <a>True</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (&lt;=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [(1,2)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (&lt;) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
--   </pre>
isSubmapOfBy :: (a -> b -> Bool) -> Word64Map a -> Word64Map b -> Bool

-- | &lt;math&gt;. Is this a proper submap? (ie. a submap but not equal).
--   Defined as (<tt><a>isProperSubmapOf</a> = <a>isProperSubmapOfBy</a>
--   (==)</tt>).
isProperSubmapOf :: Eq a => Word64Map a -> Word64Map a -> Bool

-- | &lt;math&gt;. Is this a proper submap? (ie. a submap but not equal).
--   The expression (<tt><a>isProperSubmapOfBy</a> f m1 m2</tt>) returns
--   <a>True</a> when <tt>keys m1</tt> and <tt>keys m2</tt> are not equal,
--   all keys in <tt>m1</tt> are in <tt>m2</tt>, and when <tt>f</tt>
--   returns <a>True</a> when applied to their respective values. For
--   example, the following expressions are all <a>True</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isProperSubmapOfBy (&lt;=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
--   isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
--   isProperSubmapOfBy (&lt;)  (fromList [(1,1)])       (fromList [(1,1),(2,2)])
--   </pre>
isProperSubmapOfBy :: (a -> b -> Bool) -> Word64Map a -> Word64Map b -> Bool

-- | &lt;math&gt;. The minimal key of the map. Returns <a>Nothing</a> if
--   the map is empty.
lookupMin :: Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. The maximal key of the map. Returns <a>Nothing</a> if
--   the map is empty.
lookupMax :: Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. The minimal key of the map. Calls <a>error</a> if the
--   map is empty. Use <a>minViewWithKey</a> if the map may be empty.
findMin :: Word64Map a -> (Key, a)

-- | &lt;math&gt;. The maximal key of the map. Calls <a>error</a> if the
--   map is empty. Use <a>maxViewWithKey</a> if the map may be empty.
findMax :: Word64Map a -> (Key, a)

-- | &lt;math&gt;. Delete the minimal key. Returns an empty map if the map
--   is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Map</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Map</a> was already empty.
deleteMin :: Word64Map a -> Word64Map a

-- | &lt;math&gt;. Delete the maximal key. Returns an empty map if the map
--   is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Map</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Map</a> was already empty.
deleteMax :: Word64Map a -> Word64Map a

-- | &lt;math&gt;. Delete and find the minimal element. This function
--   throws an error if the map is empty. Use <a>minViewWithKey</a> if the
--   map may be empty.
deleteFindMin :: Word64Map a -> ((Key, a), Word64Map a)

-- | &lt;math&gt;. Delete and find the maximal element. This function
--   throws an error if the map is empty. Use <a>maxViewWithKey</a> if the
--   map may be empty.
deleteFindMax :: Word64Map a -> ((Key, a), Word64Map a)

-- | &lt;math&gt;. Update the value at the minimal key.
--   
--   <pre>
--   updateMin (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "Xb"), (5, "a")]
--   updateMin (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateMin :: (a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the maximal key.
--   
--   <pre>
--   updateMax (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "Xa")]
--   updateMax (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   </pre>
updateMax :: (a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the minimal key.
--   
--   <pre>
--   updateMinWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"3:b"), (5,"a")]
--   updateMinWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateMinWithKey :: (Key -> a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the maximal key.
--   
--   <pre>
--   updateMaxWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"b"), (5,"5:a")]
--   updateMaxWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   </pre>
updateMaxWithKey :: (Key -> a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Retrieves the minimal key of the map, and the map
--   stripped of that element, or <a>Nothing</a> if passed an empty map.
minView :: Word64Map a -> Maybe (a, Word64Map a)

-- | &lt;math&gt;. Retrieves the maximal key of the map, and the map
--   stripped of that element, or <a>Nothing</a> if passed an empty map.
maxView :: Word64Map a -> Maybe (a, Word64Map a)

-- | &lt;math&gt;. Retrieves the minimal (key,value) pair of the map, and
--   the map stripped of that element, or <a>Nothing</a> if passed an empty
--   map.
--   
--   <pre>
--   minViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((3,"b"), singleton 5 "a")
--   minViewWithKey empty == Nothing
--   </pre>
minViewWithKey :: Word64Map a -> Maybe ((Key, a), Word64Map a)

-- | &lt;math&gt;. Retrieves the maximal (key,value) pair of the map, and
--   the map stripped of that element, or <a>Nothing</a> if passed an empty
--   map.
--   
--   <pre>
--   maxViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((5,"a"), singleton 3 "b")
--   maxViewWithKey empty == Nothing
--   </pre>
maxViewWithKey :: Word64Map a -> Maybe ((Key, a), Word64Map a)


-- | An efficient implementation of maps from integer keys to values
--   (dictionaries).
--   
--   This module re-exports the value lazy <a>Data.Word64Map.Lazy</a> API,
--   plus several deprecated value strict functions. Please note that these
--   functions have different strictness properties than those in
--   <a>Data.Word64Map.Strict</a>: they only evaluate the result of the
--   combining function. For example, the default value to
--   <tt>insertWith'</tt> is only evaluated if the combining function is
--   called and uses it.
--   
--   These modules are intended to be imported qualified, to avoid name
--   clashes with Prelude functions, e.g.
--   
--   <pre>
--   import Data.Word64Map (Word64Map)
--   import qualified Data.Word64Map as Word64Map
--   </pre>
--   
--   The implementation is based on <i>big-endian patricia trees</i>. This
--   data structure performs especially well on binary operations like
--   <a>union</a> and <a>intersection</a>. However, my benchmarks show that
--   it is also (much) faster on insertions and deletions when compared to
--   a generic size-balanced map implementation (see <a>Data.Map</a>).
--   
--   <ul>
--   <li>Chris Okasaki and Andy Gill, "<i>Fast Mergeable Integer Maps</i>",
--   Workshop on ML, September 1998, pages 77-86,
--   <a>http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.5452</a></li>
--   <li>D.R. Morrison, "<i>PATRICIA -- Practical Algorithm To Retrieve
--   Information Coded In Alphanumeric</i>", Journal of the ACM, 15(4),
--   October 1968, pages 514-534.</li>
--   </ul>
--   
--   Operation comments contain the operation time complexity in the Big-O
--   notation <a>http://en.wikipedia.org/wiki/Big_O_notation</a>. Many
--   operations have a worst-case complexity of &lt;math&gt;. This means
--   that the operation can become linear in the number of elements with a
--   maximum of &lt;math&gt;
module GHC.Data.Word64Map

module GHC.Utils.Exception
throwTo :: Exception e => ThreadId -> e -> IO ()
allowInterrupt :: IO ()
catches :: IO a -> [Handler a] -> IO a
bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
bracket_ :: IO a -> IO b -> IO c -> IO c
catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a
finally :: IO a -> IO b -> IO a
handle :: Exception e => (e -> IO a) -> IO a -> IO a
handleJust :: Exception e => (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a
mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
onException :: IO a -> IO b -> IO a
try :: Exception e => IO a -> IO (Either e a)
tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
tryWithContext :: Exception e => IO a -> IO (Either (ExceptionWithContext e) a)
throw :: forall a e. (HasCallStack, Exception e) => e -> a
addExceptionContext :: ExceptionAnnotation a => a -> SomeException -> SomeException
someExceptionContext :: SomeException -> ExceptionContext
annotateIO :: ExceptionAnnotation e => e -> IO a -> IO a
catch :: Exception e => IO a -> (e -> IO a) -> IO a
catchNoPropagate :: Exception e => IO a -> (ExceptionWithContext e -> IO a) -> IO a
evaluate :: a -> IO a
getMaskingState :: IO MaskingState
interruptible :: IO a -> IO a
mask :: ((forall a. () => IO a -> IO a) -> IO b) -> IO b
mask_ :: IO a -> IO a
rethrowIO :: Exception e => ExceptionWithContext e -> IO a
throwIO :: (HasCallStack, Exception e) => e -> IO a
uninterruptibleMask :: ((forall a. () => IO a -> IO a) -> IO b) -> IO b
uninterruptibleMask_ :: IO a -> IO a
asyncExceptionFromException :: Exception e => SomeException -> Maybe e
asyncExceptionToException :: Exception e => e -> SomeException
ioError :: HasCallStack => IOError -> IO a
data Handler a
Handler :: (e -> IO a) -> Handler a
data NestedAtomically
NestedAtomically :: NestedAtomically
newtype NoMethodError
NoMethodError :: String -> NoMethodError
data NonTermination
NonTermination :: NonTermination
newtype PatternMatchFail
PatternMatchFail :: String -> PatternMatchFail
newtype RecConError
RecConError :: String -> RecConError
newtype RecSelError
RecSelError :: String -> RecSelError
newtype RecUpdError
RecUpdError :: String -> RecUpdError
newtype TypeError
TypeError :: String -> TypeError
data ErrorCall
ErrorCall :: String -> ErrorCall
pattern ErrorCallWithLocation :: String -> String -> ErrorCall
data ArithException
Overflow :: ArithException
Underflow :: ArithException
LossOfPrecision :: ArithException
DivideByZero :: ArithException
Denormal :: ArithException
RatioZeroDenominator :: ArithException
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e
displayException :: Exception e => e -> String
backtraceDesired :: Exception e => e -> Bool
data ExceptionWithContext a
ExceptionWithContext :: ExceptionContext -> a -> ExceptionWithContext a
newtype NoBacktrace e
NoBacktrace :: e -> NoBacktrace e
data SomeException
SomeException :: e -> SomeException
data WhileHandling
WhileHandling :: SomeException -> WhileHandling
data MaskingState
Unmasked :: MaskingState
MaskedInterruptible :: MaskingState
MaskedUninterruptible :: MaskingState
data AllocationLimitExceeded
AllocationLimitExceeded :: AllocationLimitExceeded
data ArrayException
IndexOutOfBounds :: String -> ArrayException
UndefinedElement :: String -> ArrayException
newtype AssertionFailed
AssertionFailed :: String -> AssertionFailed
data AsyncException
StackOverflow :: AsyncException
HeapOverflow :: AsyncException
ThreadKilled :: AsyncException
UserInterrupt :: AsyncException
data BlockedIndefinitelyOnMVar
BlockedIndefinitelyOnMVar :: BlockedIndefinitelyOnMVar
data BlockedIndefinitelyOnSTM
BlockedIndefinitelyOnSTM :: BlockedIndefinitelyOnSTM
newtype CompactionFailed
CompactionFailed :: String -> CompactionFailed
data Deadlock
Deadlock :: Deadlock
data IOException
data SomeAsyncException
SomeAsyncException :: e -> SomeAsyncException
catchIO :: IO a -> (IOException -> IO a) -> IO a
handleIO :: (IOException -> IO a) -> IO a -> IO a
tryIO :: IO a -> IO (Either IOException a)
type ExceptionMonad (m :: Type -> Type) = (MonadCatch m, MonadThrow m, MonadMask m, MonadIO m)

module GHC.Utils.Fingerprint
readHexFingerprint :: String -> Fingerprint
fingerprintByteString :: ByteString -> Fingerprint
data Fingerprint
Fingerprint :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> Fingerprint
fingerprint0 :: Fingerprint
fingerprintFingerprints :: [Fingerprint] -> Fingerprint
fingerprintData :: Ptr Word8 -> Int -> IO Fingerprint
fingerprintString :: String -> Fingerprint
fingerprintStrings :: [String] -> Fingerprint
getFileHash :: FilePath -> IO Fingerprint


-- | Do not use global variables!
--   
--   Global variables are a hack. Do not use them if you can help it.
module GHC.Utils.GlobalVars
v_unsafeHasPprDebug :: IORef Bool
v_unsafeHasNoDebugOutput :: IORef Bool
v_unsafeHasNoStateHack :: IORef Bool
unsafeHasPprDebug :: Bool
unsafeHasNoDebugOutput :: Bool
unsafeHasNoStateHack :: Bool
global :: a -> IORef a
consIORef :: IORef [a] -> a -> IO ()
globalM :: IO a -> IORef a
sharedGlobal :: a -> (Ptr (IORef a) -> IO (Ptr (IORef a))) -> IORef a
sharedGlobalM :: IO a -> (Ptr (IORef a) -> IO (Ptr (IORef a))) -> IORef a

module GHC.Utils.IO.Unsafe
inlinePerformIO :: IO a -> a


-- | Defines a simple exception type and utilities to throw it. The
--   <a>PlainGhcException</a> type is a subset of the <a>GhcException</a>
--   type. It omits the exception constructors that involve pretty-printing
--   via <a>SDoc</a>.
--   
--   The reason for this is to avoid import cycles / use of boot files.
--   <a>GHC.Utils.Outputable</a> has many transitive dependencies. To throw
--   exceptions from these modules, the functions here can be used without
--   introducing import cycles.
module GHC.Utils.Panic.Plain

-- | This type is very similar to <a>GhcException</a>, but it omits the
--   constructors that involve pretty-printing via <a>SDoc</a>. Due to the
--   implementation of <a>fromException</a> for <a>GhcException</a>, this
--   type can be caught as a <a>GhcException</a>.
--   
--   Note that this should only be used for throwing exceptions, not for
--   catching, as <a>GhcException</a> will not be converted to this type
--   when catching.
data PlainGhcException

-- | Some other fatal signal (SIGHUP,SIGTERM)
PlainSignal :: Int -> PlainGhcException

-- | Prints the short usage msg after the error
PlainUsageError :: String -> PlainGhcException

-- | A problem with the command line arguments, but don't print usage.
PlainCmdLineError :: String -> PlainGhcException

-- | The <tt>impossible</tt> happened.
PlainPanic :: String -> PlainGhcException

-- | The user tickled something that's known not to work yet, but we're not
--   counting it as a bug.
PlainSorry :: String -> PlainGhcException

-- | An installation problem.
PlainInstallationError :: String -> PlainGhcException

-- | An error in the user's code, probably.
PlainProgramError :: String -> PlainGhcException

-- | Append a description of the given exception to this string.
showPlainGhcException :: PlainGhcException -> ShowS

-- | Panics and asserts.
panic :: HasCallStack => String -> a

-- | Panics and asserts.
sorry :: HasCallStack => String -> a

-- | Panics and asserts.
pgmError :: HasCallStack => String -> a
cmdLineError :: String -> a
cmdLineErrorIO :: String -> IO a

-- | Throw a failed assertion exception for a given filename and line
--   number.
assertPanic :: String -> Int -> a
assert :: HasCallStack => Bool -> a -> a
assertM :: (HasCallStack, Monad m) => m Bool -> m ()
massert :: (HasCallStack, Applicative m) => Bool -> m ()
instance GHC.Internal.Exception.Type.Exception GHC.Utils.Panic.Plain.PlainGhcException
instance GHC.Internal.Show.Show GHC.Utils.Panic.Plain.PlainGhcException


-- | Highly random utility functions
module GHC.Utils.Misc

-- | Apply a function iff some condition is met.
applyWhen :: Bool -> (a -> a) -> a -> a

-- | Apply a function <tt>n</tt> times to a given value.
nTimes :: Int -> (a -> a) -> a -> a
const2 :: a -> b -> c -> a
zipEqual :: HasDebugCallStack => String -> [a] -> [b] -> [(a, b)]
zipWithEqual :: HasDebugCallStack => String -> (a -> b -> c) -> [a] -> [b] -> [c]
zipWith3Equal :: HasDebugCallStack => String -> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
zipWith4Equal :: HasDebugCallStack => String -> (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]

-- | <tt>stretchZipWith p z f xs ys</tt> stretches <tt>ys</tt> by inserting
--   <tt>z</tt> in the places where <tt>p</tt> returns <tt>True</tt>
stretchZipWith :: (a -> Bool) -> b -> (a -> b -> c) -> [a] -> [b] -> [c]
zipWithAndUnzip :: (a -> b -> (c, d)) -> [a] -> [b] -> ([c], [d])

-- | This has the effect of making the two lists have equal length by
--   dropping the tail of the longer one.
zipAndUnzip :: [a] -> [b] -> ([a], [b])

-- | <a>filterByList</a> takes a list of Bools and a list of some elements
--   and filters out these elements for which the corresponding value in
--   the list of Bools is False. This function does not check whether the
--   lists have equal length.
filterByList :: [Bool] -> [a] -> [a]

-- | <a>filterByLists</a> takes a list of Bools and two lists as input, and
--   outputs a new list consisting of elements from the last two input
--   lists. For each Bool in the list, if it is <a>True</a>, then it takes
--   an element from the former list. If it is <a>False</a>, it takes an
--   element from the latter list. The elements taken correspond to the
--   index of the Bool in its list. For example:
--   
--   <pre>
--   filterByLists [True, False, True, False] "abcd" "wxyz" = "axcz"
--   </pre>
--   
--   This function does not check whether the lists have equal length.
filterByLists :: [Bool] -> [a] -> [a] -> [a]

-- | <a>partitionByList</a> takes a list of Bools and a list of some
--   elements and partitions the list according to the list of Bools.
--   Elements corresponding to <a>True</a> go to the left; elements
--   corresponding to <a>False</a> go to the right. For example,
--   <tt>partitionByList [True, False, True] [1,2,3] == ([1,3], [2])</tt>
--   This function does not check whether the lists have equal length; when
--   one list runs out, the function stops.
partitionByList :: [Bool] -> [a] -> ([a], [a])
unzipWith :: (a -> b -> c) -> [(a, b)] -> [c]
mapFst :: Functor f => (a -> c) -> f (a, b) -> f (c, b)
mapSnd :: Functor f => (b -> c) -> f (a, b) -> f (a, c)
chkAppend :: [a] -> [a] -> [a]
mapAndUnzip :: (a -> (b, c)) -> [a] -> ([b], [c])
mapAndUnzip3 :: (a -> (b, c, d)) -> [a] -> ([b], [c], [d])
mapAndUnzip4 :: (a -> (b, c, d, e)) -> [a] -> ([b], [c], [d], [e])

-- | Like filter, only it reverses the sense of the test
filterOut :: (a -> Bool) -> [a] -> [a]

-- | Uses a function to determine which of two output lists an input
--   element should join
partitionWith :: (a -> Either b c) -> [a] -> ([b], [c])

-- | Monadic version of <a>partitionWith</a>
partitionWithM :: Monad m => (a -> m (Either b c)) -> [a] -> m ([b], [c])
dropWhileEndLE :: (a -> Bool) -> [a] -> [a]

-- | <tt>spanEnd p l == reverse (span p (reverse l))</tt>. The first list
--   returns actually comes after the second list (when you look at the
--   input list).
spanEnd :: (a -> Bool) -> [a] -> ([a], [a])

-- | Get the last two elements in a list.
last2 :: [a] -> Maybe (a, a)
lastMaybe :: [a] -> Maybe a

-- | <tt>onJust x m f</tt> applies f to the value inside the Just or
--   returns the default.
onJust :: b -> Maybe a -> (a -> b) -> b
foldl1' :: HasCallStack => (a -> a -> a) -> [a] -> a
foldl2 :: (acc -> a -> b -> acc) -> acc -> [a] -> [b] -> acc
count :: (a -> Bool) -> [a] -> Int
countWhile :: (a -> Bool) -> [a] -> Int
all2 :: (a -> b -> Bool) -> [a] -> [b] -> Bool
any2 :: (a -> b -> Bool) -> [a] -> [b] -> Bool

-- | <pre>
--   (lengthExceeds xs n) = (length xs &gt; n)
--   </pre>
lengthExceeds :: [a] -> Int -> Bool

-- | <pre>
--   (lengthIs xs n) = (length xs == n)
--   </pre>
lengthIs :: [a] -> Int -> Bool

-- | <pre>
--   (lengthIsNot xs n) = (length xs /= n)
--   </pre>
lengthIsNot :: [a] -> Int -> Bool

-- | <pre>
--   (lengthAtLeast xs n) = (length xs &gt;= n)
--   </pre>
lengthAtLeast :: [a] -> Int -> Bool

-- | <pre>
--   (lengthAtMost xs n) = (length xs &lt;= n)
--   </pre>
lengthAtMost :: [a] -> Int -> Bool

-- | <pre>
--   (lengthLessThan xs n) == (length xs &lt; n)
--   </pre>
lengthLessThan :: [a] -> Int -> Bool
listLengthCmp :: [a] -> Int -> Ordering

-- | <tt>atLength atLen atEnd ls n</tt> unravels list <tt>ls</tt> to
--   position <tt>n</tt>. Precisely:
--   
--   <pre>
--   atLength atLenPred atEndPred ls n
--    | n &lt; 0         = atLenPred ls
--    | length ls &lt; n = atEndPred (n - length ls)
--    | otherwise     = atLenPred (drop n ls)
--   </pre>
atLength :: ([a] -> b) -> b -> [a] -> Int -> b

-- | True if length xs == length ys
equalLength :: [a] -> [b] -> Bool
compareLength :: [a] -> [b] -> Ordering

-- | True if length xs &lt;= length ys
leLength :: [a] -> [b] -> Bool

-- | True if length xs &lt; length ys
ltLength :: [a] -> [b] -> Bool
isSingleton :: [a] -> Bool

-- | Utility function to go from a singleton list to it's element.
--   
--   Wether or not the argument is a singleton list is only checked in
--   debug builds.
only :: [a] -> a

-- | Extract the single element of a list and panic with the given message
--   if there are more elements or the list was empty. Like
--   <tt>expectJust</tt>, but for lists.
expectOnly :: HasDebugCallStack => String -> [a] -> a
singleton :: a -> [a]
notNull :: Foldable f => f a -> Bool

-- | Like <tt>expectJust msg . nonEmpty</tt>; a better alternative to
--   <a>fromList</a>.
expectNonEmpty :: HasDebugCallStack => String -> [a] -> NonEmpty a

-- | Split a list into its last element and the initial part of the list.
--   <tt>snocView xs = Just (init xs, last xs)</tt> for non-empty lists.
--   <tt>snocView xs = Nothing</tt> otherwise. Unless both parts of the
--   result are guaranteed to be used prefer separate calls to
--   <tt>last</tt> + <tt>init</tt>. If you are guaranteed to use both, this
--   will be more efficient.
snocView :: [a] -> Maybe ([a], a)

-- | Compute all the ways of removing a single element from a list.
--   
--   <pre>
--   holes [1,2,3] = [(1, [2,3]), (2, [1,3]), (3, [1,2])]
--   </pre>
holes :: [a] -> [(a, [a])]

-- | Replace the last element of a list with another element.
changeLast :: [a] -> a -> [a]
whenNonEmpty :: Applicative m => [a] -> (NonEmpty a -> m ()) -> m ()

-- | Merge an unsorted list of sorted lists, for example:
--   
--   <pre>
--   mergeListsBy compare [ [2,5,15], [1,10,100] ] = [1,2,5,10,15,100]
--   </pre>
--   
--   &lt;math&gt;
mergeListsBy :: (a -> a -> Ordering) -> [[a]] -> [a]
isSortedBy :: (a -> a -> Ordering) -> [a] -> Bool
mapMaybe' :: Foldable f => (a -> Maybe b) -> f a -> [b]
fstOf3 :: (a, b, c) -> a
sndOf3 :: (a, b, c) -> b
thdOf3 :: (a, b, c) -> c
fstOf4 :: (a, b, c, d) -> a
sndOf4 :: (a, b, c, d) -> b
fst3 :: (a -> d) -> (a, b, c) -> (d, b, c)
snd3 :: (b -> d) -> (a, b, c) -> (a, d, c)
third3 :: (c -> d) -> (a, b, c) -> (a, b, d)
uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d
takeList :: [b] -> [a] -> [a]
dropList :: [b] -> [a] -> [a]

-- | Given two lists xs and ys, return `splitAt (length xs) ys`.
splitAtList :: [b] -> [a] -> ([a], [a])
split :: Char -> String -> [String]

-- | drop from the end of a list
dropTail :: Int -> [a] -> [a]

-- | Convert a word to title case by capitalising the first letter
capitalise :: String -> String
sortWith :: Ord b => (a -> b) -> [a] -> [a]
minWith :: Ord b => (a -> b) -> [a] -> a
nubSort :: Ord a => [a] -> [a]

-- | Remove duplicates but keep elements in order. O(n * log n)
ordNub :: Ord a => [a] -> [a]

-- | Remove duplicates but keep elements in order. O(n * log n)
ordNubOn :: Ord b => (a -> b) -> [a] -> [a]
isEqual :: Ordering -> Bool
removeSpaces :: String -> String
(<&&>) :: Applicative f => f Bool -> f Bool -> f Bool
infixr 3 <&&>
(<||>) :: Applicative f => f Bool -> f Bool -> f Bool
infixr 2 <||>
fuzzyMatch :: String -> [String] -> [String]

-- | Search for possible matches to the users input in the given list,
--   returning a small number of ranked results
fuzzyLookup :: String -> [(String, a)] -> [a]
transitiveClosure :: (a -> [a]) -> (a -> a -> Bool) -> [a] -> [a]
seqList :: [a] -> b -> b
strictMap :: (a -> b) -> [a] -> [b]
strictZipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
strictZipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
looksLikeModuleName :: String -> Bool
looksLikePackageName :: String -> Bool

-- | Determine the $log_2$ of exact powers of 2
exactLog2 :: Integer -> Maybe Integer
readRational :: String -> Rational

-- | Parse a string into a significand and exponent. A trivial example
--   might be: ghci&gt; readSignificandExponentPair "1E2" (1,2) In a more
--   complex case we might return a exponent different than that which the
--   user wrote. This is needed in order to use a Integer significand.
--   ghci&gt; readSignificandExponentPair "-1.11E5" (-111,3)
readSignificandExponentPair :: String -> (Integer, Integer)
readHexRational :: String -> Rational

-- | Parse a string into a significand and exponent according to the
--   "Hexadecimal Floats in Haskell" proposal. A trivial example might be:
--   ghci&gt; readHexSignificandExponentPair "0x1p+1" (1,1) Behaves similar
--   to readSignificandExponentPair but the base is 16 and numbers are
--   given in hexadecimal: ghci&gt; readHexSignificandExponentPair "0xAp-4"
--   (10,-4) ghci&gt; readHexSignificandExponentPair "0x1.2p3" (18,-1)
readHexSignificandExponentPair :: String -> (Integer, Integer)
doesDirNameExist :: FilePath -> IO Bool
getModificationUTCTime :: FilePath -> IO UTCTime
modificationTimeIfExists :: FilePath -> IO (Maybe UTCTime)
fileHashIfExists :: FilePath -> IO (Maybe Fingerprint)
withAtomicRename :: MonadIO m => FilePath -> (FilePath -> m a) -> m a
type Suffix = String
splitLongestPrefix :: String -> (Char -> Bool) -> (String, String)
escapeSpaces :: String -> String
data Direction
Forwards :: Direction
Backwards :: Direction
reslash :: Direction -> FilePath -> FilePath
makeRelativeTo :: FilePath -> FilePath -> FilePath
abstractConstr :: String -> Constr
abstractDataType :: String -> DataType
mkNoRepType :: String -> DataType
charToC :: Word8 -> String

-- | A sample hash function for Strings. We keep multiplying by the golden
--   ratio and adding. The implementation is:
--   
--   <pre>
--   hashString = foldl' f golden
--     where f m c = fromIntegral (ord c) * magic + hashInt32 m
--           magic = 0xdeadbeef
--   </pre>
--   
--   Where hashInt32 works just as hashInt shown above.
--   
--   Knuth argues that repeated multiplication by the golden ratio will
--   minimize gaps in the hash space, and thus it's a good choice for
--   combining together multiple keys to form one.
--   
--   Here we know that individual characters c are often small, and this
--   produces frequent collisions if we use ord c alone. A particular
--   problem are the shorter low ASCII and ISO-8859-1 character strings. We
--   pre-multiply by a magic twiddle factor to obtain a good distribution.
--   In fact, given the following test:
--   
--   <pre>
--   testp :: Int32 -&gt; Int
--   testp k = (n - ) . length . group . sort . map hs . take n $ ls
--     where ls = [] : [c : l | l &lt;- ls, c &lt;- ['\0'..'\xff']]
--           hs = foldl' f golden
--           f m c = fromIntegral (ord c) * k + hashInt32 m
--           n = 100000
--   </pre>
--   
--   We discover that testp magic = 0.
hashString :: String -> Int32
type HasCallStack = ?callStack :: CallStack

-- | A call stack constraint, but only when <tt>isDebugOn</tt>.
type HasDebugCallStack = ()


-- | There are two principal string types used internally by GHC:
--   
--   <ul>
--   <li><i><a>FastString</a></i></li>
--   </ul>
--   
--   <ul>
--   <li>A compact, hash-consed, representation of character strings.</li>
--   <li>Generated by <a>fsLit</a>.</li>
--   <li>You can get a <a>Unique</a> from them.</li>
--   <li>Equality test is O(1) (it uses the Unique).</li>
--   <li>Comparison is O(1) or O(n):</li>
--   <li>O(n) but deterministic with lexical comparison
--   (<a>lexicalCompareFS</a>)</li>
--   <li>O(1) but non-deterministic with Unique comparison
--   (<a>uniqCompareFS</a>)</li>
--   <li>Turn into <a>SDoc</a> with <a>ftext</a>.</li>
--   </ul>
--   
--   <ul>
--   <li><i><a>PtrString</a></i></li>
--   </ul>
--   
--   <ul>
--   <li>Pointer and size of a Latin-1 encoded string.</li>
--   <li>Practically no operations.</li>
--   <li>Outputting them is fast.</li>
--   <li>Generated by <a>mkPtrString#</a>.</li>
--   <li>Length of string literals (mkPtrString# "abc"#) is computed
--   statically</li>
--   <li>Turn into <a>SDoc</a> with <a>ptext</a></li>
--   <li>Requires manual memory management. Improper use may lead to memory
--   leaks or dangling pointers.</li>
--   <li>It assumes Latin-1 as the encoding, therefore it cannot represent
--   arbitrary Unicode strings.</li>
--   </ul>
--   
--   Use <a>PtrString</a> unless you want the facilities of
--   <a>FastString</a>.
module GHC.Data.FastString

-- | Gives the Modified UTF-8 encoded bytes corresponding to a
--   <a>FastString</a>
bytesFS :: FastString -> ByteString

-- | Gives the Modified UTF-8 encoded bytes corresponding to a
--   <a>FastString</a>

-- | <i>Deprecated: Use <a>bytesFS</a> instead</i>
fastStringToByteString :: FastString -> ByteString

-- | Create a <a>FastString</a> by copying an existing <a>ByteString</a>
mkFastStringByteString :: ByteString -> FastString
fastZStringToByteString :: FastZString -> ByteString
unsafeMkByteString :: String -> ByteString
fastStringToShortByteString :: FastString -> ShortByteString

-- | Create a <a>FastString</a> from an existing <a>ShortByteString</a>
--   without copying.
mkFastStringShortByteString :: ShortByteString -> FastString
fastStringToShortText :: FastString -> ShortText
data FastZString
hPutFZS :: Handle -> FastZString -> IO ()
zString :: FastZString -> String

-- | <tt>zStringTakeN n = <a>take</a> n . <a>zString</a></tt> but is
--   performed in &lt;math&gt; rather than &lt;math&gt;, where &lt;math&gt;
--   is the length of the <a>FastZString</a>.
zStringTakeN :: Int -> FastZString -> String
lengthFZS :: FastZString -> Int

-- | A <a>FastString</a> is a Modified UTF-8 encoded string together with a
--   unique ID. All <a>FastString</a>s are stored in a global hashtable to
--   support fast O(1) comparison.
--   
--   It is also associated with a lazy reference to the Z-encoding of this
--   string which is used by the compiler internally.
data FastString
FastString :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !ShortByteString -> FastZString -> FastString
[uniq] :: FastString -> {-# UNPACK #-} !Int
[n_chars] :: FastString -> {-# UNPACK #-} !Int
[fs_sbs] :: FastString -> {-# UNPACK #-} !ShortByteString

-- | Lazily computed Z-encoding of this string. See Note [Z-Encoding] in
--   GHC.Utils.Encoding.
--   
--   Since <a>FastString</a>s are globally memoized this is computed at
--   most once for any given string.
[fs_zenc] :: FastString -> FastZString

-- | Non-deterministic FastString
--   
--   This is a simple FastString wrapper with an Ord instance using
--   <a>uniqCompareFS</a> (i.e. which compares FastStrings on their
--   Uniques). Hence it is not deterministic from one run to the other.
newtype NonDetFastString
NonDetFastString :: FastString -> NonDetFastString

-- | Lexical FastString
--   
--   This is a simple FastString wrapper with an Ord instance using
--   <a>lexicalCompareFS</a> (i.e. which compares FastStrings on their
--   String representation). Hence it is deterministic from one run to the
--   other.
newtype LexicalFastString
LexicalFastString :: FastString -> LexicalFastString
[getLexicalFastString] :: LexicalFastString -> FastString
fsLit :: String -> FastString

-- | Creates a UTF-8 encoded <a>FastString</a> from a <a>String</a>
mkFastString :: String -> FastString
mkFastStringBytes :: Ptr Word8 -> Int -> FastString

-- | Creates a <a>FastString</a> from a UTF-8 encoded <tt>[Word8]</tt>
mkFastStringByteList :: [Word8] -> FastString
mkFastString# :: Addr# -> FastString

-- | Lazily unpacks and decodes the FastString
unpackFS :: FastString -> String
unconsFS :: FastString -> Maybe (Char, FastString)

-- | Returns a Z-encoded version of a <a>FastString</a>. This might be the
--   original, if it was already Z-encoded. The first time this function is
--   applied to a particular <a>FastString</a>, the results are memoized.
zEncodeFS :: FastString -> FastZString
uniqueOfFS :: FastString -> Int

-- | Returns the length of the <a>FastString</a> in characters
lengthFS :: FastString -> Int

-- | Returns <tt>True</tt> if the <a>FastString</a> is empty
nullFS :: FastString -> Bool
appendFS :: FastString -> FastString -> FastString
concatFS :: [FastString] -> FastString
consFS :: Char -> FastString -> FastString
nilFS :: FastString

-- | Compare FastString lexically
--   
--   If you don't care about the lexical ordering, use <a>uniqCompareFS</a>
--   instead.
lexicalCompareFS :: FastString -> FastString -> Ordering

-- | Compare FastString by their Unique (not lexically).
--   
--   Much cheaper than <a>lexicalCompareFS</a> but non-deterministic!
uniqCompareFS :: FastString -> FastString -> Ordering

-- | Outputs a <a>FastString</a> with <i>no decoding at all</i>, that is,
--   you get the actual bytes in the <a>FastString</a> written to the
--   <a>Handle</a>.
hPutFS :: Handle -> FastString -> IO ()
getFastStringTable :: IO [[[FastString]]]
getFastStringZEncCounter :: IO Int

-- | A <a>PtrString</a> is a pointer to some array of Latin-1 encoded
--   chars.
data PtrString
PtrString :: !Ptr Word8 -> !Int -> PtrString

-- | Wrap an unboxed address into a <a>PtrString</a>.
mkPtrString# :: Addr# -> PtrString

-- | Decode a <a>PtrString</a> back into a <a>String</a> using Latin-1
--   encoding. This does not free the memory associated with
--   <a>PtrString</a>.
unpackPtrString :: PtrString -> String

-- | <tt>unpackPtrStringTakeN n = <a>take</a> n .
--   <a>unpackPtrString</a></tt> but is performed in &lt;math&gt; rather
--   than &lt;math&gt;, where &lt;math&gt; is the length of the
--   <a>PtrString</a>.
unpackPtrStringTakeN :: Int -> PtrString -> String

-- | Return the length of a <a>PtrString</a>
lengthPS :: PtrString -> Int
instance GHC.Internal.Data.Data.Data GHC.Data.FastString.FastString
instance GHC.Internal.Data.Data.Data GHC.Data.FastString.LexicalFastString
instance GHC.Internal.Data.Data.Data GHC.Data.FastString.NonDetFastString
instance GHC.Classes.Eq GHC.Data.FastString.FastString
instance GHC.Classes.Eq GHC.Data.FastString.LexicalFastString
instance GHC.Classes.Eq GHC.Data.FastString.NonDetFastString
instance GHC.Internal.Data.String.IsString GHC.Data.FastString.FastString
instance GHC.Internal.Base.Monoid GHC.Data.FastString.FastString
instance Control.DeepSeq.NFData GHC.Data.FastString.FastString
instance Control.DeepSeq.NFData GHC.Data.FastString.FastZString
instance Control.DeepSeq.NFData GHC.Data.FastString.LexicalFastString
instance GHC.Classes.Ord GHC.Data.FastString.LexicalFastString
instance GHC.Classes.Ord GHC.Data.FastString.NonDetFastString
instance GHC.Internal.Base.Semigroup GHC.Data.FastString.FastString
instance GHC.Internal.Show.Show GHC.Data.FastString.FastString
instance GHC.Internal.Show.Show GHC.Data.FastString.LexicalFastString
instance GHC.Internal.Show.Show GHC.Data.FastString.NonDetFastString

module GHC.Utils.BufHandle
data BufHandle
BufHandle :: {-# UNPACK #-} !Ptr Word8 -> {-# UNPACK #-} !FastMutInt -> Handle -> BufHandle
newBufHandle :: Handle -> IO BufHandle
bPutChar :: BufHandle -> Char -> IO ()
bPutStr :: BufHandle -> String -> IO ()
bPutFS :: BufHandle -> FastString -> IO ()
bPutFZS :: BufHandle -> FastZString -> IO ()
bPutPtrString :: BufHandle -> PtrString -> IO ()

-- | Replicate an 8-bit character
bPutReplicate :: BufHandle -> Int -> Char -> IO ()
bFlush :: BufHandle -> IO ()


-- | John Hughes's and Simon Peyton Jones's Pretty Printer Combinators
--   
--   Based on <i>The Design of a Pretty-printing Library</i> in Advanced
--   Functional Programming, Johan Jeuring and Erik Meijer (eds), LNCS 925
--   <a>http://www.cse.chalmers.se/~rjmh/Papers/pretty.ps</a>
module GHC.Utils.Ppr

-- | The abstract type of documents. A Doc represents a *set* of layouts. A
--   Doc with no occurrences of Union or NoDoc represents just one layout.
data Doc

-- | The TextDetails data type
--   
--   A TextDetails represents a fragment of text that will be output at
--   some point.
data TextDetails

-- | A single Char fragment
Chr :: {-# UNPACK #-} !Char -> TextDetails

-- | A whole String fragment
Str :: String -> TextDetails
PStr :: FastString -> TextDetails
ZStr :: FastZString -> TextDetails
LStr :: {-# UNPACK #-} !PtrString -> TextDetails
RStr :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Char -> TextDetails

-- | A document of height and width 1, containing a literal character.
char :: Char -> Doc

-- | A document of height 1 containing a literal string. <a>text</a>
--   satisfies the following laws:
--   
--   <ul>
--   <li><pre><a>text</a> s <a>&lt;&gt;</a> <a>text</a> t = <a>text</a>
--   (s<a>++</a>t)</pre></li>
--   <li><tt><a>text</a> "" <a>&lt;&gt;</a> x = x</tt>, if <tt>x</tt>
--   non-empty</li>
--   </ul>
--   
--   The side condition on the last law is necessary because
--   <tt><a>text</a> ""</tt> has height 1, while <a>empty</a> has no
--   height.
text :: String -> Doc
ftext :: FastString -> Doc
ptext :: PtrString -> Doc
ztext :: FastZString -> Doc

-- | Some text with any width. (<tt>text s = sizedText (length s) s</tt>)
sizedText :: Int -> String -> Doc

-- | Some text, but without any width. Use for non-printing text such as a
--   HTML or Latex tags
zeroWidthText :: String -> Doc

-- | Empty text (one line high but no width). (<tt>emptyText = text
--   ""</tt>)
emptyText :: Doc
int :: Int -> Doc
integer :: Integer -> Doc
float :: Float -> Doc
double :: Double -> Doc
rational :: Rational -> Doc
hex :: Integer -> Doc
semi :: Doc
comma :: Doc
colon :: Doc
space :: Doc
equals :: Doc
lparen :: Doc
rparen :: Doc
lbrack :: Doc
rbrack :: Doc
lbrace :: Doc
rbrace :: Doc
parens :: Doc -> Doc
brackets :: Doc -> Doc
braces :: Doc -> Doc
quotes :: Doc -> Doc
squotes :: Doc -> Doc
quote :: Doc -> Doc
doubleQuotes :: Doc -> Doc

-- | Apply <a>parens</a> to <a>Doc</a> if boolean is true.
maybeParens :: Bool -> Doc -> Doc

-- | The empty document, with no height and no width. <a>empty</a> is the
--   identity for <a>&lt;&gt;</a>, <a>&lt;+&gt;</a>, <a>$$</a> and
--   <a>$+$</a>, and anywhere in the argument list for <a>sep</a>,
--   <a>hcat</a>, <a>hsep</a>, <a>vcat</a>, <a>fcat</a> etc.
empty :: Doc

-- | Beside. <a>&lt;&gt;</a> is associative, with identity <a>empty</a>.
(<>) :: Doc -> Doc -> Doc
infixl 6 <>

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc -> Doc -> Doc
infixl 6 <+>

-- | List version of <a>&lt;&gt;</a>.
hcat :: [Doc] -> Doc

-- | List version of <a>&lt;+&gt;</a>.
hsep :: [Doc] -> Doc

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc -> Doc -> Doc
infixl 5 $$

-- | Above, with no overlapping. <a>$+$</a> is associative, with identity
--   <a>empty</a>.
($+$) :: Doc -> Doc -> Doc
infixl 5 $+$

-- | List version of <a>$$</a>.
vcat :: [Doc] -> Doc

-- | Either <a>hsep</a> or <a>vcat</a>.
sep :: [Doc] -> Doc

-- | Either <a>hcat</a> or <a>vcat</a>.
cat :: [Doc] -> Doc

-- | "Paragraph fill" version of <a>sep</a>.
fsep :: [Doc] -> Doc

-- | "Paragraph fill" version of <a>cat</a>.
fcat :: [Doc] -> Doc

-- | Nest (or indent) a document by a given number of positions (which may
--   also be negative). <a>nest</a> satisfies the laws:
--   
--   <ul>
--   <li><pre><a>nest</a> 0 x = x</pre></li>
--   <li><pre><a>nest</a> k (<a>nest</a> k' x) = <a>nest</a> (k+k')
--   x</pre></li>
--   <li><pre><a>nest</a> k (x <a>&lt;&gt;</a> y) = <a>nest</a> k z
--   <a>&lt;&gt;</a> <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k (x <a>$$</a> y) = <a>nest</a> k x <a>$$</a>
--   <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k <a>empty</a> = <a>empty</a></pre></li>
--   <li><tt>x <a>&lt;&gt;</a> <a>nest</a> k y = x <a>&lt;&gt;</a> y</tt>,
--   if <tt>x</tt> non-empty</li>
--   </ul>
--   
--   The side condition on the last law is needed because <a>empty</a> is a
--   left identity for <a>&lt;&gt;</a>.
nest :: Int -> Doc -> Doc

-- | <pre>
--   hang d1 n d2 = sep [d1, nest n d2]
--   </pre>
hang :: Doc -> Int -> Doc -> Doc

-- | Apply <a>hang</a> to the arguments if the first <a>Doc</a> is not
--   empty.
hangNotEmpty :: Doc -> Int -> Doc -> Doc

-- | <pre>
--   punctuate p [d1, ... dn] = [d1 &lt;&gt; p, d2 &lt;&gt; p, ... dn-1 &lt;&gt; p, dn]
--   </pre>
punctuate :: Doc -> [Doc] -> [Doc]

-- | Returns <a>True</a> if the document is empty
isEmpty :: Doc -> Bool

-- | Get the first character of a document. We also return a new document,
--   equivalent to the original one but faster to render. Use it to avoid
--   work duplication.
docHead :: Doc -> (Maybe Char, Doc)

-- | A rendering style.
data Style
Style :: Mode -> Int -> Float -> Style

-- | The rendering mode
[mode] :: Style -> Mode

-- | Length of line, in chars
[lineLength] :: Style -> Int

-- | Ratio of line length to ribbon length
[ribbonsPerLine] :: Style -> Float

-- | The default style (<tt>mode=PageMode False, lineLength=100,
--   ribbonsPerLine=1.5</tt>).
style :: Style

-- | Render the <tt>Doc</tt> to a String using the given <tt>Style</tt>.
renderStyle :: Style -> Doc -> String

-- | Rendering mode.
data Mode

-- | Normal
PageMode :: Bool -> Mode
[asciiSpace] :: Mode -> Bool

-- | With zig-zag cuts
ZigZagMode :: Mode

-- | No indentation, infinitely long lines
LeftMode :: Mode

-- | All on one line
OneLineMode :: Mode

-- | The general rendering interface.
fullRender :: Mode -> Int -> Float -> (TextDetails -> a -> a) -> a -> Doc -> a

-- | Default TextDetails printer
txtPrinter :: TextDetails -> String -> String
printDoc :: Mode -> Int -> Handle -> Doc -> IO ()
printDoc_ :: Mode -> Int -> Handle -> Doc -> IO ()
bufLeftRender :: BufHandle -> Doc -> IO ()
printLeftRender :: Handle -> Doc -> IO ()
instance GHC.Internal.Show.Show GHC.Utils.Ppr.Doc

module GHC.Utils.Ppr.Colour

-- | A colour/style for use with <tt>coloured</tt>.
newtype PprColour
PprColour :: String -> PprColour
[renderColour] :: PprColour -> String
renderColourAfresh :: PprColour -> String
colCustom :: String -> PprColour
colReset :: PprColour
colBold :: PprColour
colBlackFg :: PprColour
colRedFg :: PprColour
colGreenFg :: PprColour
colYellowFg :: PprColour
colBlueFg :: PprColour
colMagentaFg :: PprColour
colCyanFg :: PprColour
colWhiteFg :: PprColour
data Scheme
Scheme :: PprColour -> PprColour -> PprColour -> PprColour -> PprColour -> PprColour -> Scheme
[sHeader] :: Scheme -> PprColour
[sMessage] :: Scheme -> PprColour
[sWarning] :: Scheme -> PprColour
[sError] :: Scheme -> PprColour
[sFatal] :: Scheme -> PprColour
[sMargin] :: Scheme -> PprColour
defaultScheme :: Scheme

-- | Parse the colour scheme from a string (presumably from the
--   <tt>GHC_COLORS</tt> environment variable).
parseScheme :: String -> (OverridingBool, Scheme) -> (OverridingBool, Scheme)
instance GHC.Internal.Base.Monoid GHC.Utils.Ppr.Colour.PprColour
instance GHC.Internal.Base.Semigroup GHC.Utils.Ppr.Colour.PprColour

module Language.Haskell.Syntax.Basic
data Boxity
Boxed :: Boxity
Unboxed :: Boxity
isBoxed :: Boxity -> Bool

-- | The width of an unboxed sum
type SumWidth = Int

-- | A *one-index* constructor tag
--   
--   Type of the tags associated with each constructor possibility or
--   superclass selector
type ConTag = Int

-- | Field labels are just represented as strings; they are not necessarily
--   unique (even within a module)
newtype FieldLabelString
FieldLabelString :: FastString -> FieldLabelString
[field_label] :: FieldLabelString -> FastString

-- | See Note [Roles] in GHC.Core.Coercion
--   
--   Order of constructors matters: the Ord instance coincides with the
--   *super*typing relation on roles.
data Role
Nominal :: Role
Representational :: Role
Phantom :: Role

-- | Haskell Bang
--   
--   Bangs on data constructor arguments written by the user.
--   
--   <tt>(HsBang SrcUnpack SrcLazy)</tt> and <tt>(HsBang SrcUnpack
--   NoSrcStrict)</tt> (without StrictData) makes no sense, we emit a
--   warning (in checkValidDataCon) and treat it like <tt>(HsBang
--   NoSrcUnpack SrcLazy)</tt>
--   
--   <a>HsSrcBang</a> is a wrapper around this, associating it with a
--   <a>SourceText</a> as written by the user. In the AST, the
--   <tt>SourceText</tt> is hidden inside the extension point
--   <a>XBangTy</a>.
data HsBang
HsBang :: SrcUnpackedness -> SrcStrictness -> HsBang

-- | Source Strictness
--   
--   What strictness annotation the user wrote
data SrcStrictness

-- | Lazy, ie <tt>~</tt>
SrcLazy :: SrcStrictness

-- | Strict, ie <tt>!</tt>
SrcStrict :: SrcStrictness

-- | no strictness annotation
NoSrcStrict :: SrcStrictness

-- | Source Unpackedness
--   
--   What unpackedness the user requested
data SrcUnpackedness

-- | {-# UNPACK #-} specified
SrcUnpack :: SrcUnpackedness

-- | {-# NOUNPACK #-} specified
SrcNoUnpack :: SrcUnpackedness

-- | no unpack pragma
NoSrcUnpack :: SrcUnpackedness

-- | Captures the fixity of declarations as they are parsed. This is not
--   necessarily the same as the fixity declaration, as the normal fixity
--   may be overridden using parens or backticks.
data LexicalFixity
Prefix :: LexicalFixity
Infix :: LexicalFixity
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection
data Fixity
Fixity :: Int -> FixityDirection -> Fixity
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Basic.Boxity
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Basic.FieldLabelString
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Basic.Fixity
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Basic.FixityDirection
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Basic.HsBang
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Basic.LexicalFixity
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Basic.Role
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Basic.SrcStrictness
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Basic.SrcUnpackedness
instance GHC.Classes.Eq Language.Haskell.Syntax.Basic.Boxity
instance GHC.Classes.Eq Language.Haskell.Syntax.Basic.FieldLabelString
instance GHC.Classes.Eq Language.Haskell.Syntax.Basic.Fixity
instance GHC.Classes.Eq Language.Haskell.Syntax.Basic.FixityDirection
instance GHC.Classes.Eq Language.Haskell.Syntax.Basic.LexicalFixity
instance GHC.Classes.Eq Language.Haskell.Syntax.Basic.Role
instance GHC.Classes.Eq Language.Haskell.Syntax.Basic.SrcStrictness
instance GHC.Classes.Eq Language.Haskell.Syntax.Basic.SrcUnpackedness
instance Control.DeepSeq.NFData Language.Haskell.Syntax.Basic.FieldLabelString
instance GHC.Classes.Ord Language.Haskell.Syntax.Basic.Role

module Language.Haskell.Syntax.Extension

-- | A placeholder type for TTG extension points that are not currently
--   used to represent any particular value.
--   
--   This should not be confused with <a>DataConCantHappen</a>, which are
--   found in unused extension <i>constructors</i> and therefore should
--   never be inhabited. In contrast, <a>NoExtField</a> is used in
--   extension <i>points</i> (e.g., as the field of some constructor), so
--   it must have an inhabitant to construct AST passes that manipulate
--   fields with that extension point as their type.
data NoExtField
NoExtField :: NoExtField

-- | Used when constructing a term with an unused extension point.
noExtField :: NoExtField
data DataConCantHappen

-- | Eliminate a <a>DataConCantHappen</a>. See Note [Constructor cannot
--   occur].
dataConCantHappen :: DataConCantHappen -> a

-- | GHC's L prefixed variants wrap their vanilla variant in this type
--   family, to add <tt>SrcLoc</tt> info via <tt>Located</tt>. Other passes
--   than <tt>GhcPass</tt> not interested in location information can
--   define this as <tt>type instance XRec NoLocated a = a</tt>. See Note
--   [XRec and SrcSpans in the AST]
type family XRec p a = (r :: Type) | r -> a
type family Anno a = (b :: Type)

-- | We can strip off the XRec to access the underlying data. See Note
--   [XRec and SrcSpans in the AST]
class UnXRec p
unXRec :: UnXRec p => XRec p a -> a

-- | We can map over the underlying type contained in an <tt>XRec</tt>
--   while preserving the annotation as is.
class MapXRec p
mapXRec :: (MapXRec p, Anno a ~ Anno b) => (a -> b) -> XRec p a -> XRec p b

-- | The trivial wrapper that carries no additional information See Note
--   [XRec and SrcSpans in the AST]
class WrapXRec p a
wrapXRec :: WrapXRec p a => a -> XRec p a

-- | Maps the "normal" id type for a given pass
type family IdP p
type LIdP p = XRec p IdP p
type family XHsValBinds x x'
type family XHsIPBinds x x'
type family XEmptyLocalBinds x x'
type family XXHsLocalBindsLR x x'
type family XValBinds x x'
type family XXValBindsLR x x'
type family XFunBind x x'
type family XPatBind x x'
type family XVarBind x x'
type family XPatSynBind x x'
type family XXHsBindsLR x x'
type family XPSB x x'
type family XXPatSynBind x x'
type family XIPBinds x
type family XXHsIPBinds x
type family XCIPBind x
type family XXIPBind x
type family XTypeSig x
type family XPatSynSig x
type family XClassOpSig x
type family XIdSig x
type family XFixSig x
type family XInlineSig x
type family XSpecSig x
type family XSpecInstSig x
type family XMinimalSig x
type family XSCCFunSig x
type family XCompleteMatchSig x
type family XXSig x
type family XFixitySig x
type family XXFixitySig x
type family XStandaloneKindSig x
type family XXStandaloneKindSig x
type family XTyClD x
type family XInstD x
type family XDerivD x
type family XValD x
type family XSigD x
type family XKindSigD x
type family XDefD x
type family XForD x
type family XWarningD x
type family XAnnD x
type family XRuleD x
type family XSpliceD x
type family XDocD x
type family XRoleAnnotD x
type family XXHsDecl x
type family XCHsGroup x
type family XXHsGroup x
type family XSpliceDecl x
type family XXSpliceDecl x
type family XFamDecl x
type family XSynDecl x
type family XDataDecl x
type family XClassDecl x
type family XXTyClDecl x
type family XCFunDep x
type family XXFunDep x
type family XCTyClGroup x
type family XXTyClGroup x
type family XNoSig x
type family XCKindSig x
type family XTyVarSig x
type family XXFamilyResultSig x
type family XCFamilyDecl x
type family XXFamilyDecl x
type family XCHsDataDefn x
type family XXHsDataDefn x
type family XCHsDerivingClause x
type family XXHsDerivingClause x
type family XDctSingle x
type family XDctMulti x
type family XXDerivClauseTys x
type family XConDeclGADT x
type family XConDeclH98 x
type family XXConDecl x
type family XCFamEqn x r
type family XXFamEqn x r
type family XCTyFamInstDecl x
type family XXTyFamInstDecl x
type family XCClsInstDecl x
type family XXClsInstDecl x
type family XClsInstD x
type family XDataFamInstD x
type family XTyFamInstD x
type family XXInstDecl x
type family XCDerivDecl x
type family XXDerivDecl x
type family XStockStrategy x
type family XAnyClassStrategy x
type family XNewtypeStrategy x
type family XViaStrategy x
type family XCDefaultDecl x
type family XXDefaultDecl x
type family XForeignImport x
type family XForeignExport x
type family XXForeignDecl x
type family XCImport x
type family XXForeignImport x
type family XCExport x
type family XXForeignExport x
type family XCRuleDecls x
type family XXRuleDecls x
type family XHsRule x
type family XXRuleDecl x
type family XCRuleBndr x
type family XRuleBndrSig x
type family XXRuleBndr x
type family XWarnings x
type family XXWarnDecls x
type family XWarning x
type family XXWarnDecl x
type family XHsAnnotation x
type family XXAnnDecl x
type family XCRoleAnnotDecl x
type family XXRoleAnnotDecl x
type family XCInjectivityAnn x
type family XXInjectivityAnn x
type family XCModule x
type family XXModule x
type family XVar x
type family XUnboundVar x
type family XRecSel x
type family XOverLabel x
type family XIPVar x
type family XOverLitE x
type family XLitE x
type family XLam x
type family XLamCase x
type family XApp x
type family XAppTypeE x
type family XOpApp x
type family XNegApp x
type family XPar x
type family XSectionL x
type family XSectionR x
type family XExplicitTuple x
type family XExplicitSum x
type family XCase x
type family XIf x
type family XMultiIf x
type family XLet x
type family XDo x
type family XExplicitList x
type family XRecordCon x
type family XRecordUpd x
type family XLHsRecUpdLabels x
type family XLHsOLRecUpdLabels x
type family XGetField x
type family XProjection x
type family XExprWithTySig x
type family XArithSeq x
type family XTypedBracket x
type family XUntypedBracket x
type family XTypedSplice x
type family XUntypedSplice x
type family XProc x
type family XStatic x
type family XTick x
type family XBinTick x
type family XPragE x
type family XEmbTy x
type family XForAll x
type family XQual x
type family XFunArr x
type family XXExpr x
type family XFunRhs
type family XCDotFieldOcc x
type family XXDotFieldOcc x
type family XSCC x
type family XXPragE x
type family XPresent x
type family XMissing x
type family XXTupArg x
type family XUntypedSpliceExpr x
type family XQuasiQuote x
type family XXUntypedSplice x
type family XExpBr x
type family XPatBr x
type family XDecBrL x
type family XDecBrG x
type family XTypBr x
type family XVarBr x
type family XXQuote x
type family XCmdTop x
type family XXCmdTop x
type family XMG x b
type family XXMatchGroup x b
type family XCMatch x b
type family XXMatch x b
type family XCGRHSs x b
type family XXGRHSs x b
type family XCGRHS x b
type family XXGRHS x b
type family XLastStmt x x' b
type family XBindStmt x x' b
type family XBodyStmt x x' b
type family XLetStmt x x' b
type family XParStmt x x' b
type family XTransStmt x x' b
type family XRecStmt x x' b
type family XXStmtLR x x' b
type family XCmdArrApp x
type family XCmdArrForm x
type family XCmdApp x
type family XCmdLam x
type family XCmdPar x
type family XCmdCase x
type family XCmdLamCase x
type family XCmdIf x
type family XCmdLet x
type family XCmdDo x
type family XCmdWrap x
type family XXCmd x
type family XParStmtBlock x x'
type family XXParStmtBlock x x'
type family XHsChar x
type family XHsCharPrim x
type family XHsString x
type family XHsMultilineString x
type family XHsStringPrim x
type family XHsInt x
type family XHsIntPrim x
type family XHsWordPrim x
type family XHsInt8Prim x
type family XHsInt16Prim x
type family XHsInt32Prim x
type family XHsInt64Prim x
type family XHsWord8Prim x
type family XHsWord16Prim x
type family XHsWord32Prim x
type family XHsWord64Prim x
type family XHsInteger x
type family XHsRat x
type family XHsFloatPrim x
type family XHsDoublePrim x
type family XXLit x
type family XOverLit x
type family XXOverLit x
type family XWildPat x
type family XVarPat x
type family XLazyPat x
type family XAsPat x
type family XParPat x
type family XBangPat x
type family XListPat x
type family XTuplePat x
type family XSumPat x
type family XOrPat x
type family XConPat x
type family XViewPat x
type family XSplicePat x
type family XLitPat x
type family XNPat x
type family XNPlusKPat x
type family XSigPat x
type family XEmbTyPat x
type family XInvisPat x
type family XCoPat x
type family XXPat x
type family XHsFieldBind x
type family XHsQTvs x
type family XXLHsQTyVars x
type family XHsOuterImplicit x
type family XHsOuterExplicit x flag
type family XXHsOuterTyVarBndrs x
type family XHsSig x
type family XXHsSigType x
type family XHsWC x b
type family XXHsWildCardBndrs x b
type family XHsPS x
type family XXHsPatSigType x
type family XHsTP x
type family XXHsTyPat x
type family XForAllTy x
type family XQualTy x
type family XTyVar x
type family XAppTy x
type family XAppKindTy x
type family XFunTy x
type family XListTy x
type family XTupleTy x
type family XSumTy x
type family XOpTy x
type family XParTy x
type family XIParamTy x
type family XStarTy x
type family XKindSig x
type family XSpliceTy x
type family XDocTy x
type family XBangTy x
type family XRecTy x
type family XExplicitListTy x
type family XExplicitTupleTy x
type family XTyLit x
type family XWildCardTy x
type family XXType x
type family XNumTy x
type family XStrTy x
type family XCharTy x
type family XXTyLit x
type family XHsForAllVis x
type family XHsForAllInvis x
type family XXHsForAllTelescope x
type family XTyVarBndr x
type family XXTyVarBndr x
type family XConDeclField x
type family XXConDeclField x
type family XCFieldOcc x
type family XXFieldOcc x
type family XCImportDecl x
type family XXImportDecl x
type family ImportDeclPkgQual x
type family XIEVar x
type family XIEThingAbs x
type family XIEThingAll x
type family XIEThingWith x
type family XIEModuleContents x
type family XIEGroup x
type family XIEDoc x
type family XIEDocNamed x
type family XXIE x
type family XIEName p
type family XIEDefault p
type family XIEPattern p
type family XIEType p
type family XXIEWrappedName p

-- | See Note [NoGhcTc] in GHC.Hs.Extension. It has to be in this module
--   because it is used like an extension point (in the data definitions of
--   types that should be parameter-agnostic.
type family NoGhcTc p
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Extension.DataConCantHappen
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Extension.NoExtField
instance GHC.Classes.Eq Language.Haskell.Syntax.Extension.DataConCantHappen
instance GHC.Classes.Eq Language.Haskell.Syntax.Extension.NoExtField
instance GHC.Classes.Ord Language.Haskell.Syntax.Extension.DataConCantHappen
instance GHC.Classes.Ord Language.Haskell.Syntax.Extension.NoExtField

module Language.Haskell.Syntax.Module.Name

-- | A ModuleName is essentially a simple string, e.g. <tt>Data.List</tt>.
newtype ModuleName
ModuleName :: FastString -> ModuleName

-- | Compares module names lexically, rather than by their <tt>Unique</tt>s
stableModuleNameCmp :: ModuleName -> ModuleName -> Ordering
moduleNameFS :: ModuleName -> FastString
moduleNameString :: ModuleName -> String
mkModuleName :: String -> ModuleName
mkModuleNameFS :: FastString -> ModuleName

-- | Returns the string version of the module name, with dots replaced by
--   slashes.
moduleNameSlashes :: ModuleName -> String

-- | Returns the string version of the module name, with dots replaced by
--   colons.
moduleNameColons :: ModuleName -> String
parseModuleName :: ReadP ModuleName
instance GHC.Classes.Eq Language.Haskell.Syntax.Module.Name.ModuleName
instance Control.DeepSeq.NFData Language.Haskell.Syntax.Module.Name.ModuleName
instance GHC.Classes.Ord Language.Haskell.Syntax.Module.Name.ModuleName
instance GHC.Internal.Show.Show Language.Haskell.Syntax.Module.Name.ModuleName


-- | This module defines classes and functions for pretty-printing. It also
--   exports a number of helpful debugging and other utilities such as
--   <tt>trace</tt> and <tt>panic</tt>.
--   
--   The interface to this module is very similar to the standard Hughes-PJ
--   pretty printing module, except that it exports a number of additional
--   functions that are rarely used, and works over the <a>SDoc</a> type.
module GHC.Utils.Outputable

-- | Class designating that some type has an <a>SDoc</a> representation
class Outputable a
ppr :: Outputable a => a -> SDoc

-- | When we print a binder, we often want to print its type too. The
--   <tt>OutputableBndr</tt> class encapsulates this idea.
class Outputable a => OutputableBndr a
pprBndr :: OutputableBndr a => BindingSite -> a -> SDoc
pprPrefixOcc :: OutputableBndr a => a -> SDoc
pprInfixOcc :: OutputableBndr a => a -> SDoc
bndrIsJoin_maybe :: OutputableBndr a => a -> JoinPointHood

-- | Outputable class with an additional environment value
--   
--   See Note [The OutputableP class]
class OutputableP env a
pdoc :: OutputableP env a => env -> a -> SDoc

-- | <a>BindingSite</a> is used to tell the thing that prints binder what
--   language construct is binding the identifier. This can be used to
--   decide how much info to print. Also see Note [Binding-site specific
--   printing] in <a>GHC.Core.Ppr</a>
data BindingSite

-- | The x in (x. e)
LambdaBind :: BindingSite

-- | The x in case scrut of x { (y,z) -&gt; ... }
CaseBind :: BindingSite

-- | The y,z in case scrut of x { (y,z) -&gt; ... }
CasePatBind :: BindingSite

-- | The x in (let x = rhs in e)
LetBind :: BindingSite
data JoinPointHood
JoinPoint :: {-# UNPACK #-} !Int -> JoinPointHood
NotJoinPoint :: JoinPointHood
isJoinPoint :: JoinPointHood -> Bool

-- | A superclass for <a>IsLine</a> and <a>IsDoc</a> that provides an
--   identity, <a>empty</a>, as well as access to the shared
--   <a>SDocContext</a>.
--   
--   See Note [The outputable class hierarchy] for more details.
class IsOutput doc
empty :: IsOutput doc => doc
docWithContext :: IsOutput doc => (SDocContext -> doc) -> doc
docWithStyle :: IsOutput doc => doc -> (PprStyle -> SDoc) -> doc

-- | A class of types that represent a single logical line of text, with
--   support for horizontal composition.
--   
--   See Note [HLine versus HDoc] and Note [The outputable class hierarchy]
--   for more details.
class IsOutput doc => IsLine doc
char :: IsLine doc => Char -> doc
text :: IsLine doc => String -> doc
ftext :: IsLine doc => FastString -> doc
ztext :: IsLine doc => FastZString -> doc

-- | Join two <tt>doc</tt>s together horizontally without a gap.
(<>) :: IsLine doc => doc -> doc -> doc

-- | Join two <tt>doc</tt>s together horizontally with a gap between them.
(<+>) :: IsLine doc => doc -> doc -> doc

-- | Separate: is either like <a>hsep</a> or like <a>vcat</a>, depending on
--   what fits.
sep :: IsLine doc => [doc] -> doc

-- | A paragraph-fill combinator. It's much like <a>sep</a>, only it keeps
--   fitting things on one line until it can't fit any more.
fsep :: IsLine doc => [doc] -> doc

-- | Concatenate <tt>doc</tt>s horizontally without gaps.
hcat :: IsLine doc => [doc] -> doc

-- | Concatenate <tt>doc</tt>s horizontally with a space between each one.
hsep :: IsLine doc => [doc] -> doc

-- | Prints as either the given <a>SDoc</a> or the given <a>HLine</a>,
--   depending on which type the result is instantiated to. This should
--   generally be avoided; see Note [dualLine and dualDoc] for details.
dualLine :: IsLine doc => SDoc -> HLine -> doc

-- | A class of types that represent a multiline document, with support for
--   vertical composition.
--   
--   See Note [HLine versus HDoc] and Note [The outputable class hierarchy]
--   for more details.
class (IsOutput doc, IsLine Line doc) => IsDoc doc where {
    type Line doc = (r :: Type) | r -> doc;
}
line :: IsDoc doc => Line doc -> doc

-- | Join two <tt>doc</tt>s together vertically. If there is no vertical
--   overlap it "dovetails" the two onto one line.
($$) :: IsDoc doc => doc -> doc -> doc
lines_ :: IsDoc doc => [Line doc] -> doc

-- | Concatenate <tt>doc</tt>s vertically with dovetailing.
vcat :: IsDoc doc => [doc] -> doc

-- | Prints as either the given <a>SDoc</a> or the given <a>HDoc</a>,
--   depending on which type the result is instantiated to. This should
--   generally be avoided; see Note [dualLine and dualDoc] for details.
dualDoc :: IsDoc doc => SDoc -> HDoc -> doc

-- | Represents a single line of output that can be efficiently printed
--   directly to a <a>Handle</a> (actually a <a>BufHandle</a>). See Note
--   [SDoc versus HDoc] and Note [HLine versus HDoc] for more details.
data HLine

-- | Represents a (possibly empty) sequence of lines that can be
--   efficiently printed directly to a <a>Handle</a> (actually a
--   <a>BufHandle</a>). See Note [SDoc versus HDoc] and Note [HLine versus
--   HDoc] for more details.
data HDoc

-- | Represents a pretty-printable document.
--   
--   To display an <a>SDoc</a>, use <a>printSDoc</a>, <a>printSDocLn</a>,
--   <a>bufLeftRenderSDoc</a>, or <a>renderWithContext</a>. Avoid calling
--   <a>runSDoc</a> directly as it breaks the abstraction layer.
data SDoc
runSDoc :: SDoc -> SDocContext -> Doc

-- | Wrapper for types having a Outputable instance when an OutputableP
--   instance is required.
newtype PDoc a
PDoc :: a -> PDoc a
docToSDoc :: Doc -> SDoc

-- | Returns the separated concatenation of the pretty printed things.
interppSP :: Outputable a => [a] -> SDoc

-- | Returns the comma-separated concatenation of the pretty printed
--   things.
interpp'SP :: Outputable a => [a] -> SDoc
interpp'SP' :: (a -> SDoc) -> [a] -> SDoc

-- | Returns the comma-separated concatenation of the quoted pretty printed
--   things.
--   
--   <pre>
--   [x,y,z]  ==&gt;  `x', `y', `z'
--   </pre>
pprQuotedList :: Outputable a => [a] -> SDoc
pprWithCommas :: (a -> SDoc) -> [a] -> SDoc
pprWithSemis :: (a -> SDoc) -> [a] -> SDoc
unquotedListWith :: SDoc -> [SDoc] -> SDoc
quotedListWithOr :: [SDoc] -> SDoc
quotedListWithNor :: [SDoc] -> SDoc
quotedListWithAnd :: [SDoc] -> SDoc
pprWithBars :: (a -> SDoc) -> [a] -> SDoc
spaceIfSingleQuote :: SDoc -> SDoc
isEmpty :: SDocContext -> SDoc -> Bool

-- | Indent <a>SDoc</a> some specified amount
nest :: Int -> SDoc -> SDoc
ptext :: PtrString -> SDoc
int :: IsLine doc => Int -> doc
intWithCommas :: Integral a => a -> SDoc
integer :: IsLine doc => Integer -> doc
word64 :: IsLine doc => Word64 -> doc
word :: Integer -> SDoc
float :: IsLine doc => Float -> doc
double :: IsLine doc => Double -> doc
rational :: Rational -> SDoc

-- | <tt>doublePrec p n</tt> shows a floating point number <tt>n</tt> with
--   <tt>p</tt> digits of precision after the decimal point.
doublePrec :: Int -> Double -> SDoc
parens :: IsLine doc => doc -> doc
cparen :: Bool -> SDoc -> SDoc
brackets :: IsLine doc => doc -> doc
braces :: IsLine doc => doc -> doc
quotes :: SDoc -> SDoc
quote :: SDoc -> SDoc
quoteIfPunsEnabled :: SDoc -> SDoc
doubleQuotes :: IsLine doc => doc -> doc
angleBrackets :: IsLine doc => doc -> doc
semi :: IsLine doc => doc
comma :: IsLine doc => doc
colon :: IsLine doc => doc
dcolon :: SDoc
space :: IsLine doc => doc
equals :: IsLine doc => doc
dot :: IsLine doc => doc
vbar :: IsLine doc => doc
arrow :: SDoc
lollipop :: SDoc
larrow :: SDoc
darrow :: SDoc
arrowt :: SDoc
larrowt :: SDoc
arrowtt :: SDoc
larrowtt :: SDoc
lambda :: SDoc
lparen :: IsLine doc => doc
rparen :: IsLine doc => doc
lbrack :: IsLine doc => doc
rbrack :: IsLine doc => doc
lbrace :: IsLine doc => doc
rbrace :: IsLine doc => doc
underscore :: IsLine doc => doc
blankLine :: SDoc
forAllLit :: SDoc
bullet :: SDoc

-- | Join two <a>SDoc</a> together vertically
($+$) :: SDoc -> SDoc -> SDoc

-- | A paragraph-fill combinator. It's much like sep, only it keeps fitting
--   things on one line until it can't fit any more.
cat :: [SDoc] -> SDoc

-- | This behaves like <a>fsep</a>, but it uses <a>&lt;&gt;</a> for
--   horizontal composition rather than <a>&lt;+&gt;</a>
fcat :: [SDoc] -> SDoc
hang :: SDoc -> Int -> SDoc -> SDoc

-- | This behaves like <a>hang</a>, but does not indent the second document
--   when the header is empty.
hangNotEmpty :: SDoc -> Int -> SDoc -> SDoc
punctuate :: IsLine doc => doc -> [doc] -> [doc]

-- | Punctuate a list, e.g. with commas and dots.
--   
--   <pre>
--   sep $ punctuateFinal comma dot [text "ab", text "cd", text "ef"]
--   ab, cd, ef.
--   </pre>
punctuateFinal :: IsLine doc => doc -> doc -> [doc] -> [doc]
ppWhen :: IsOutput doc => Bool -> doc -> doc
ppUnless :: IsOutput doc => Bool -> doc -> doc
ppWhenOption :: (SDocContext -> Bool) -> SDoc -> SDoc
ppUnlessOption :: (SDocContext -> Bool) -> SDoc -> SDoc

-- | Converts an integer to a verbal index:
--   
--   <pre>
--   speakNth 1 = text "first"
--   speakNth 5 = text "fifth"
--   speakNth 21 = text "21st"
--   </pre>
speakNth :: Int -> SDoc

-- | Converts an integer to a verbal multiplicity:
--   
--   <pre>
--   speakN 0 = text "none"
--   speakN 5 = text "five"
--   speakN 10 = text "10"
--   </pre>
speakN :: Int -> SDoc

-- | Converts an integer and object description to a statement about the
--   multiplicity of those objects:
--   
--   <pre>
--   speakNOf 0 (text "melon") = text "no melons"
--   speakNOf 1 (text "melon") = text "one melon"
--   speakNOf 3 (text "melon") = text "three melons"
--   </pre>
speakNOf :: Int -> SDoc -> SDoc

-- | Determines the pluralisation suffix appropriate for the length of a
--   list:
--   
--   <pre>
--   plural [] = char 's'
--   plural ["Hello"] = empty
--   plural ["Hello", "World"] = char 's'
--   </pre>
plural :: [a] -> SDoc

-- | Determines the singular verb suffix appropriate for the length of a
--   list:
--   
--   <pre>
--   singular [] = empty
--   singular["Hello"] = char 's'
--   singular ["Hello", "World"] = empty
--   </pre>
singular :: [a] -> SDoc

-- | Determines the form of to be appropriate for the length of a list:
--   
--   <pre>
--   isOrAre [] = text "are"
--   isOrAre ["Hello"] = text "is"
--   isOrAre ["Hello", "World"] = text "are"
--   </pre>
isOrAre :: [a] -> SDoc

-- | Determines the form of to do appropriate for the length of a list:
--   
--   <pre>
--   doOrDoes [] = text "do"
--   doOrDoes ["Hello"] = text "does"
--   doOrDoes ["Hello", "World"] = text "do"
--   </pre>
doOrDoes :: [a] -> SDoc

-- | Determines the form of possessive appropriate for the length of a
--   list:
--   
--   <pre>
--   itsOrTheir [x]   = text "its"
--   itsOrTheir [x,y] = text "their"
--   itsOrTheir []    = text "their"  -- probably avoid this
--   </pre>
itsOrTheir :: [a] -> SDoc

-- | Determines the form of subject appropriate for the length of a list:
--   
--   <pre>
--   thisOrThese [x]   = text "This"
--   thisOrThese [x,y] = text "These"
--   thisOrThese []    = text "These"  -- probably avoid this
--   </pre>
thisOrThese :: [a] -> SDoc

-- | <tt>"has"</tt> or <tt>"have"</tt> depending on the length of a list.
hasOrHave :: [a] -> SDoc

-- | <tt>it</tt> or <tt>they</tt>, depeneding on the length of the list.
--   
--   <pre>
--   itOrThey [x]   = text "it"
--   itOrThey [x,y] = text "they"
--   itOrThey []    = text "they"  -- probably avoid this
--   </pre>
itOrThey :: [a] -> SDoc
unicodeSyntax :: SDoc -> SDoc -> SDoc

-- | Apply the given colour/style for the argument.
--   
--   Only takes effect if colours are enabled.
coloured :: PprColour -> SDoc -> SDoc
keyword :: SDoc -> SDoc

-- | The analog of <a>printDoc_</a> for <a>SDoc</a>, which tries to make
--   sure the terminal doesn't get screwed up by the ANSI color codes if an
--   exception is thrown during pretty-printing.
printSDoc :: SDocContext -> Mode -> Handle -> SDoc -> IO ()

-- | Like <a>printSDoc</a> but appends an extra newline.
printSDocLn :: SDocContext -> Mode -> Handle -> SDoc -> IO ()

-- | An efficient variant of <a>printSDoc</a> specialized for
--   <a>LeftMode</a> that outputs to a <a>BufHandle</a>.
bufLeftRenderSDoc :: SDocContext -> BufHandle -> SDoc -> IO ()
pprCode :: SDoc -> SDoc
showSDocOneLine :: SDocContext -> SDoc -> String
showSDocUnsafe :: SDoc -> String
showPprUnsafe :: Outputable a => a -> String
renderWithContext :: SDocContext -> SDoc -> String
pprDebugAndThen :: SDocContext -> (String -> a) -> SDoc -> SDoc -> a
pprInfixVar :: Bool -> SDoc -> SDoc
pprPrefixVar :: Bool -> SDoc -> SDoc

-- | Special combinator for showing character literals.
pprHsChar :: Char -> SDoc

-- | Special combinator for showing string literals.
pprHsString :: FastString -> SDoc

-- | Special combinator for showing bytestring literals.
pprHsBytes :: ByteString -> SDoc
primFloatSuffix :: SDoc
primCharSuffix :: SDoc
primDoubleSuffix :: SDoc
primInt8Suffix :: SDoc
primWord8Suffix :: SDoc
primInt16Suffix :: SDoc
primWord16Suffix :: SDoc
primInt32Suffix :: SDoc
primWord32Suffix :: SDoc
primInt64Suffix :: SDoc
primWord64Suffix :: SDoc
primIntSuffix :: SDoc
primWordSuffix :: SDoc

-- | Special combinator for showing unboxed literals.
pprPrimChar :: Char -> SDoc
pprPrimInt :: Integer -> SDoc
pprPrimWord :: Integer -> SDoc
pprPrimInt8 :: Integer -> SDoc
pprPrimWord8 :: Integer -> SDoc
pprPrimInt16 :: Integer -> SDoc
pprPrimWord16 :: Integer -> SDoc
pprPrimInt32 :: Integer -> SDoc
pprPrimWord32 :: Integer -> SDoc
pprPrimInt64 :: Integer -> SDoc
pprPrimWord64 :: Integer -> SDoc
pprFastFilePath :: FastString -> SDoc

-- | Normalise, escape and render a string representing a path
--   
--   e.g. "c:\whatever"
pprFilePathString :: IsLine doc => FilePath -> doc
pprModuleName :: IsLine doc => ModuleName -> doc
data PprStyle
PprUser :: NamePprCtx -> Depth -> Coloured -> PprStyle
PprDump :: NamePprCtx -> PprStyle

-- | Print code; either C or assembler
PprCode :: PprStyle

-- | When printing code that contains original names, we need to map the
--   original names back to something the user understands. This is the
--   purpose of the triple of functions that gets passed around when
--   rendering <a>SDoc</a>.
data NamePprCtx
QueryQualify :: QueryQualifyName -> QueryQualifyModule -> QueryQualifyPackage -> QueryPromotionTick -> NamePprCtx
[queryQualifyName] :: NamePprCtx -> QueryQualifyName
[queryQualifyModule] :: NamePprCtx -> QueryQualifyModule
[queryQualifyPackage] :: NamePprCtx -> QueryQualifyPackage
[queryPromotionTick] :: NamePprCtx -> QueryPromotionTick

-- | Given a <tt>Name</tt>'s <a>Module</a> and <a>OccName</a>, decide
--   whether and how to qualify it.
type QueryQualifyName = Module -> OccName -> QualifyName

-- | For a given module, we need to know whether to print it with a package
--   name to disambiguate it.
type QueryQualifyModule = Module -> Bool

-- | For a given package, we need to know whether to print it with the
--   component id to disambiguate it.
type QueryQualifyPackage = Unit -> Bool

-- | Given a promoted data constructor, decide whether to print a tick to
--   disambiguate the namespace.
type QueryPromotionTick = PromotedItem -> Bool
data PromotedItem
PromotedItemListSyntax :: IsEmptyOrSingleton -> PromotedItem
PromotedItemTupleSyntax :: PromotedItem
PromotedItemDataCon :: OccName -> PromotedItem
newtype IsEmptyOrSingleton
IsEmptyOrSingleton :: Bool -> IsEmptyOrSingleton
isListEmptyOrSingleton :: [a] -> IsEmptyOrSingleton

-- | Flags that affect whether a promotion tick is printed.
data PromotionTickContext
PromTickCtx :: !Bool -> !Bool -> PromotionTickContext
[ptcListTuplePuns] :: PromotionTickContext -> !Bool
[ptcPrintRedundantPromTicks] :: PromotionTickContext -> !Bool
reallyAlwaysQualify :: NamePprCtx
reallyAlwaysQualifyNames :: QueryQualifyName
alwaysQualify :: NamePprCtx

-- | NB: This won't ever show package IDs
alwaysQualifyNames :: QueryQualifyName
alwaysQualifyModules :: QueryQualifyModule
neverQualify :: NamePprCtx
neverQualifyNames :: QueryQualifyName
neverQualifyModules :: QueryQualifyModule
alwaysQualifyPackages :: QueryQualifyPackage
neverQualifyPackages :: QueryQualifyPackage
alwaysPrintPromTick :: QueryPromotionTick
data QualifyName
NameUnqual :: QualifyName
NameQual :: ModuleName -> QualifyName
NameNotInScope1 :: QualifyName
NameNotInScope2 :: QualifyName
queryQual :: PprStyle -> NamePprCtx
sdocOption :: (SDocContext -> a) -> (a -> SDoc) -> SDoc
updSDocContext :: (SDocContext -> SDocContext) -> SDoc -> SDoc
data SDocContext
SDC :: !PprStyle -> !Scheme -> !PprColour -> !Bool -> !Int -> !Int -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !FastString -> SDoc -> SDocContext
[sdocStyle] :: SDocContext -> !PprStyle
[sdocColScheme] :: SDocContext -> !Scheme

-- | The most recently used colour. This allows nesting colours.
[sdocLastColour] :: SDocContext -> !PprColour
[sdocShouldUseColor] :: SDocContext -> !Bool
[sdocDefaultDepth] :: SDocContext -> !Int
[sdocLineLength] :: SDocContext -> !Int

-- | True if Unicode encoding is supported and not disabled by
--   GHC_NO_UNICODE environment variable
[sdocCanUseUnicode] :: SDocContext -> !Bool
[sdocPrintErrIndexLinks] :: SDocContext -> !Bool
[sdocHexWordLiterals] :: SDocContext -> !Bool
[sdocPprDebug] :: SDocContext -> !Bool
[sdocPrintUnicodeSyntax] :: SDocContext -> !Bool
[sdocPrintCaseAsLet] :: SDocContext -> !Bool
[sdocPrintTypecheckerElaboration] :: SDocContext -> !Bool
[sdocPrintAxiomIncomps] :: SDocContext -> !Bool
[sdocPrintExplicitKinds] :: SDocContext -> !Bool
[sdocPrintExplicitCoercions] :: SDocContext -> !Bool
[sdocPrintExplicitRuntimeReps] :: SDocContext -> !Bool
[sdocPrintExplicitForalls] :: SDocContext -> !Bool
[sdocPrintPotentialInstances] :: SDocContext -> !Bool
[sdocPrintEqualityRelations] :: SDocContext -> !Bool
[sdocSuppressTicks] :: SDocContext -> !Bool
[sdocSuppressTypeSignatures] :: SDocContext -> !Bool
[sdocSuppressTypeApplications] :: SDocContext -> !Bool
[sdocSuppressIdInfo] :: SDocContext -> !Bool
[sdocSuppressCoercions] :: SDocContext -> !Bool
[sdocSuppressCoercionTypes] :: SDocContext -> !Bool
[sdocSuppressUnfoldings] :: SDocContext -> !Bool
[sdocSuppressVarKinds] :: SDocContext -> !Bool
[sdocSuppressUniques] :: SDocContext -> !Bool
[sdocSuppressModulePrefixes] :: SDocContext -> !Bool
[sdocSuppressStgExts] :: SDocContext -> !Bool
[sdocSuppressStgReps] :: SDocContext -> !Bool
[sdocErrorSpans] :: SDocContext -> !Bool
[sdocStarIsType] :: SDocContext -> !Bool
[sdocLinearTypes] :: SDocContext -> !Bool
[sdocListTuplePuns] :: SDocContext -> !Bool
[sdocPrintTypeAbbreviations] :: SDocContext -> !Bool

-- | Used to map UnitIds to more friendly "package-version:component"
--   strings while pretty-printing.
--   
--   Use <a>pprWithUnitState</a> to set it. Users should never have to set
--   it to pretty-print SDocs emitted by GHC, otherwise it's a bug. It's an
--   internal field used to thread the UnitState so that the Outputable
--   instance of UnitId can use it.
--   
--   See Note [Pretty-printing UnitId] in <a>GHC.Unit</a> for more details.
--   
--   Note that we use <a>FastString</a> instead of <tt>UnitId</tt> to avoid
--   boring module inter-dependency issues.
[sdocUnitIdForUser] :: SDocContext -> !FastString -> SDoc
sdocWithContext :: (SDocContext -> SDoc) -> SDoc

-- | Default pretty-printing options
defaultSDocContext :: SDocContext
traceSDocContext :: SDocContext
getPprStyle :: (PprStyle -> SDoc) -> SDoc
withPprStyle :: PprStyle -> SDoc -> SDoc
setStyleColoured :: Bool -> PprStyle -> PprStyle
pprDeeper :: SDoc -> SDoc

-- | Truncate a list that is longer than the current depth.
pprDeeperList :: ([SDoc] -> SDoc) -> [SDoc] -> SDoc
pprSetDepth :: Depth -> SDoc -> SDoc
codeStyle :: PprStyle -> Bool
userStyle :: PprStyle -> Bool
dumpStyle :: PprStyle -> Bool
qualName :: PprStyle -> QueryQualifyName
qualModule :: PprStyle -> QueryQualifyModule
qualPackage :: PprStyle -> QueryQualifyPackage
promTick :: PprStyle -> QueryPromotionTick

-- | Style for printing error messages
mkErrStyle :: NamePprCtx -> PprStyle

-- | Default style for error messages, when we don't know NamePprCtx It's a
--   bit of a hack because it doesn't take into account what's in scope
--   Only used for desugarer warnings, and typechecker errors in interface
--   sigs
defaultErrStyle :: PprStyle
defaultDumpStyle :: PprStyle
mkDumpStyle :: NamePprCtx -> PprStyle
defaultUserStyle :: PprStyle
mkUserStyle :: NamePprCtx -> Depth -> PprStyle
cmdlineParserStyle :: PprStyle
data Depth
AllTheWay :: Depth

-- | 0 =&gt; stop
PartWay :: Int -> Depth

-- | Use <a>sdocDefaultDepth</a> field as depth
DefaultDepth :: Depth
withUserStyle :: NamePprCtx -> Depth -> SDoc -> SDoc
withErrStyle :: NamePprCtx -> SDoc -> SDoc

-- | Says what to do with and without -dppr-debug
ifPprDebug :: IsOutput doc => doc -> doc -> doc

-- | Says what to do with -dppr-debug; without, return empty
whenPprDebug :: IsOutput doc => doc -> doc

-- | Indicate if -dppr-debug mode is enabled
getPprDebug :: IsOutput doc => (Bool -> doc) -> doc
bPutHDoc :: BufHandle -> SDocContext -> HDoc -> IO ()
instance GHC.Classes.Eq GHC.Utils.Outputable.BindingSite
instance GHC.Classes.Eq GHC.Utils.Outputable.JoinPointHood
instance GHC.Utils.Outputable.IsDoc GHC.Utils.Outputable.HDoc
instance GHC.Utils.Outputable.IsDoc GHC.Utils.Outputable.SDoc
instance GHC.Utils.Outputable.IsLine GHC.Utils.Outputable.HLine
instance GHC.Utils.Outputable.IsLine GHC.Utils.Outputable.SDoc
instance GHC.Utils.Outputable.IsOutput GHC.Utils.Outputable.HDoc
instance GHC.Utils.Outputable.IsOutput GHC.Utils.Outputable.HLine
instance GHC.Utils.Outputable.IsOutput GHC.Utils.Outputable.SDoc
instance GHC.Internal.Data.String.IsString GHC.Utils.Outputable.SDoc
instance Control.DeepSeq.NFData GHC.Utils.Outputable.JoinPointHood
instance GHC.Utils.Outputable.OutputableP env a => GHC.Utils.Outputable.OutputableP env [a]
instance (GHC.Utils.Outputable.OutputableP env key, GHC.Utils.Outputable.OutputableP env elt) => GHC.Utils.Outputable.OutputableP env (Data.Map.Internal.Map key elt)
instance GHC.Utils.Outputable.OutputableP env a => GHC.Utils.Outputable.OutputableP env (GHC.Internal.Maybe.Maybe a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.OutputableP env (GHC.Utils.Outputable.PDoc a)
instance GHC.Utils.Outputable.OutputableP env a => GHC.Utils.Outputable.OutputableP env (Data.Graph.SCC a)
instance GHC.Utils.Outputable.OutputableP env GHC.Utils.Outputable.SDoc
instance GHC.Utils.Outputable.OutputableP env a => GHC.Utils.Outputable.OutputableP env (Data.Set.Internal.Set a)
instance (GHC.Utils.Outputable.OutputableP env a, GHC.Utils.Outputable.OutputableP env b) => GHC.Utils.Outputable.OutputableP env (a, b)
instance (GHC.Utils.Outputable.OutputableP env a, GHC.Utils.Outputable.OutputableP env b, GHC.Utils.Outputable.OutputableP env c) => GHC.Utils.Outputable.OutputableP env (a, b, c)
instance GHC.Utils.Outputable.OutputableP env ()
instance GHC.Utils.Outputable.OutputableP env GHC.Internal.Base.Void
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b) => GHC.Utils.Outputable.Outputable (Data.Semigroup.Arg a b)
instance GHC.Utils.Outputable.Outputable GHC.Types.Bool
instance GHC.Utils.Outputable.Outputable GHC.Types.Double
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b) => GHC.Utils.Outputable.Outputable (GHC.Internal.Data.Either.Either a b)
instance GHC.Utils.Outputable.Outputable GHC.Internal.LanguageExtensions.Extension
instance GHC.Utils.Outputable.Outputable GHC.Data.FastString.FastString
instance GHC.Utils.Outputable.Outputable GHC.Internal.Fingerprint.Type.Fingerprint
instance GHC.Utils.Outputable.Outputable GHC.Types.Float
instance GHC.Utils.Outputable.Outputable GHC.Types.Int
instance GHC.Utils.Outputable.Outputable GHC.Internal.Int.Int16
instance GHC.Utils.Outputable.Outputable GHC.Internal.Int.Int32
instance GHC.Utils.Outputable.Outputable GHC.Internal.Int.Int64
instance GHC.Utils.Outputable.Outputable GHC.Internal.Int.Int8
instance GHC.Utils.Outputable.Outputable elt => GHC.Utils.Outputable.Outputable (Data.IntMap.Internal.IntMap elt)
instance GHC.Utils.Outputable.Outputable Data.IntSet.Internal.IntSet
instance GHC.Utils.Outputable.Outputable GHC.Num.Integer.Integer
instance GHC.Utils.Outputable.Outputable GHC.Utils.Outputable.JoinPointHood
instance GHC.Utils.Outputable.Outputable GHC.Data.FastString.LexicalFastString
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable [a]
instance (GHC.Utils.Outputable.Outputable key, GHC.Utils.Outputable.Outputable elt) => GHC.Utils.Outputable.Outputable (Data.Map.Internal.Map key elt)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Internal.Maybe.Maybe a)
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Module.Name.ModuleName
instance GHC.Utils.Outputable.Outputable GHC.Data.FastString.NonDetFastString
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Internal.Base.NonEmpty a)
instance GHC.Utils.Outputable.Outputable GHC.Types.Ordering
instance GHC.Utils.Outputable.Outputable GHC.Utils.Outputable.PprStyle
instance GHC.Utils.Outputable.Outputable GHC.Utils.Outputable.QualifyName
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (Data.Graph.SCC a)
instance GHC.Utils.Outputable.Outputable GHC.Utils.Outputable.SDoc
instance GHC.Utils.Outputable.Outputable GHC.Serialized.Serialized
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (Data.Set.Internal.Set a)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b) => GHC.Utils.Outputable.Outputable (a, b)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b, GHC.Utils.Outputable.Outputable c) => GHC.Utils.Outputable.Outputable (a, b, c)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b, GHC.Utils.Outputable.Outputable c, GHC.Utils.Outputable.Outputable d) => GHC.Utils.Outputable.Outputable (a, b, c, d)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b, GHC.Utils.Outputable.Outputable c, GHC.Utils.Outputable.Outputable d, GHC.Utils.Outputable.Outputable e) => GHC.Utils.Outputable.Outputable (a, b, c, d, e)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b, GHC.Utils.Outputable.Outputable c, GHC.Utils.Outputable.Outputable d, GHC.Utils.Outputable.Outputable e, GHC.Utils.Outputable.Outputable f) => GHC.Utils.Outputable.Outputable (a, b, c, d, e, f)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b, GHC.Utils.Outputable.Outputable c, GHC.Utils.Outputable.Outputable d, GHC.Utils.Outputable.Outputable e, GHC.Utils.Outputable.Outputable f, GHC.Utils.Outputable.Outputable g) => GHC.Utils.Outputable.Outputable (a, b, c, d, e, f, g)
instance GHC.Utils.Outputable.Outputable Data.Time.Clock.Internal.UTCTime.UTCTime
instance GHC.Utils.Outputable.Outputable ()
instance GHC.Utils.Outputable.Outputable GHC.Internal.Base.Void
instance GHC.Utils.Outputable.Outputable GHC.Types.Word
instance GHC.Utils.Outputable.Outputable GHC.Internal.Word.Word16
instance GHC.Utils.Outputable.Outputable GHC.Internal.Word.Word32
instance GHC.Utils.Outputable.Outputable GHC.Internal.Word.Word64
instance GHC.Utils.Outputable.Outputable GHC.Data.Word64Set.Internal.Word64Set
instance GHC.Utils.Outputable.Outputable GHC.Internal.Word.Word8


-- | Defines basic functions for printing error messages.
--   
--   It's hard to put these functions anywhere else without causing some
--   unnecessary loops in the module dependency graph.
module GHC.Utils.Panic

-- | GHC's own exception type error messages all take the form:
--   
--   <pre>
--   &lt;location&gt;: &lt;error&gt;
--   
--   </pre>
--   
--   If the location is on the command line, or in GHC itself, then
--   &lt;location&gt;="ghc". All of the error types below correspond to a
--   &lt;location&gt; of "ghc", except for ProgramError (where the string
--   is assumed to contain a location already, so we don't print one).
data GhcException

-- | Some other fatal signal (SIGHUP,SIGTERM)
Signal :: Int -> GhcException

-- | Prints the short usage msg after the error
UsageError :: String -> GhcException

-- | A problem with the command line arguments, but don't print usage.
CmdLineError :: String -> GhcException

-- | The <tt>impossible</tt> happened.
Panic :: String -> GhcException
PprPanic :: String -> SDoc -> GhcException

-- | The user tickled something that's known not to work yet, but we're not
--   counting it as a bug.
Sorry :: String -> GhcException
PprSorry :: String -> SDoc -> GhcException

-- | An installation problem.
InstallationError :: String -> GhcException

-- | An error in the user's code, probably.
ProgramError :: String -> GhcException
PprProgramError :: String -> SDoc -> GhcException

-- | Append a description of the given exception to this string.
showGhcException :: SDocContext -> GhcException -> ShowS

-- | Append a description of the given exception to this string.
--   
--   Note that this uses <a>defaultSDocContext</a>, which doesn't use the
--   options set by the user via DynFlags.
showGhcExceptionUnsafe :: GhcException -> ShowS
throwGhcException :: GhcException -> a
throwGhcExceptionIO :: GhcException -> IO a
handleGhcException :: ExceptionMonad m => (GhcException -> m a) -> m a -> m a

-- | Throw an exception saying "bug in GHC" with a callstack
pprPanic :: HasCallStack => String -> SDoc -> a

-- | Throw an exception saying "bug in GHC"
panicDoc :: String -> SDoc -> a

-- | Throw an exception saying "this isn't finished yet"
sorryDoc :: String -> SDoc -> a

-- | Throw an exception saying "bug in pgm being compiled" (used for
--   unusual program errors)
pgmErrorDoc :: String -> SDoc -> a

-- | Panic with an assertion failure, recording the given file and line
--   number. Should typically be accessed with the ASSERT family of macros
assertPprPanic :: HasCallStack => SDoc -> a
assertPpr :: HasCallStack => Bool -> SDoc -> a -> a
assertPprMaybe :: HasCallStack => Maybe SDoc -> a -> a
assertPprM :: (HasCallStack, Monad m) => m Bool -> SDoc -> m ()
massertPpr :: (HasCallStack, Applicative m) => Bool -> SDoc -> m ()
callStackDoc :: HasCallStack => SDoc
prettyCallStackDoc :: CallStack -> SDoc
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e
displayException :: Exception e => e -> String
backtraceDesired :: Exception e => e -> Bool

-- | Show an exception as a string.
showException :: Exception e => e -> String

-- | Show an exception which can possibly throw other exceptions. Used when
--   displaying exception thrown within TH code.
safeShowException :: Exception e => e -> IO String
try :: Exception e => IO a -> IO (Either e a)

-- | Like try, but pass through UserInterrupt and Panic exceptions. Used
--   when we want soft failures when reading interface files, for example.
--   TODO: I'm not entirely sure if this is catching what we really want to
--   catch
tryMost :: IO a -> IO (Either SomeException a)
throwTo :: Exception e => ThreadId -> e -> IO ()

-- | Temporarily install standard signal handlers for catching ^C, which
--   just throw an exception in the current thread.
withSignalHandlers :: ExceptionMonad m => m a -> m a
instance GHC.Internal.Exception.Type.Exception GHC.Utils.Panic.GhcException
instance GHC.Internal.Show.Show GHC.Utils.Panic.GhcException


-- | Tracing utilities
module GHC.Utils.Trace

-- | If debug output is on, show some <a>SDoc</a> on the screen
pprTrace :: String -> SDoc -> a -> a
pprTraceM :: Applicative f => String -> SDoc -> f ()
pprTraceDebug :: String -> SDoc -> a -> a

-- | <tt>pprTraceIt desc x</tt> is equivalent to <tt>pprTrace desc (ppr x)
--   x</tt>
pprTraceIt :: Outputable a => String -> a -> a

-- | <tt>pprTraceWith desc f x</tt> is equivalent to <tt>pprTrace desc (f
--   x) x</tt>. This allows you to print details from the returned value as
--   well as from ambient variables.
pprTraceWith :: String -> (a -> SDoc) -> a -> a

-- | If debug output is on, show some <a>SDoc</a> on the screen along with
--   a call stack when available.
pprSTrace :: HasCallStack => SDoc -> a -> a

-- | <tt>pprTraceException desc x action</tt> runs action, printing a
--   message if it throws an exception.
pprTraceException :: ExceptionMonad m => String -> SDoc -> m a -> m a

-- | Just warn about an assertion failure, recording the given file and
--   line number.
warnPprTrace :: HasCallStack => Bool -> String -> SDoc -> a -> a
warnPprTraceM :: (Applicative f, HasCallStack) => Bool -> String -> SDoc -> f ()

-- | For when we want to show the user a non-fatal WARNING so that they can
--   report a GHC bug, but don't want to panic.
pprTraceUserWarning :: HasCallStack => SDoc -> a -> a
trace :: String -> a -> a


-- | Custom GHC <a>Prelude</a>
--   
--   This module serves as a replacement for the <a>Prelude</a> module and
--   abstracts over differences between the bootstrapping GHC version, and
--   may also provide a common default vocabulary.
module GHC.Prelude

-- | If debug output is on, show some <a>SDoc</a> on the screen along with
--   a call stack when available.
pprSTrace :: HasCallStack => SDoc -> a -> a

-- | If debug output is on, show some <a>SDoc</a> on the screen
pprTrace :: String -> SDoc -> a -> a
pprTraceDebug :: String -> SDoc -> a -> a

-- | <tt>pprTraceException desc x action</tt> runs action, printing a
--   message if it throws an exception.
pprTraceException :: ExceptionMonad m => String -> SDoc -> m a -> m a

-- | <tt>pprTraceIt desc x</tt> is equivalent to <tt>pprTrace desc (ppr x)
--   x</tt>
pprTraceIt :: Outputable a => String -> a -> a
pprTraceM :: Applicative f => String -> SDoc -> f ()

-- | For when we want to show the user a non-fatal WARNING so that they can
--   report a GHC bug, but don't want to panic.
pprTraceUserWarning :: HasCallStack => SDoc -> a -> a

-- | <tt>pprTraceWith desc f x</tt> is equivalent to <tt>pprTrace desc (f
--   x) x</tt>. This allows you to print details from the returned value as
--   well as from ambient variables.
pprTraceWith :: String -> (a -> SDoc) -> a -> a

-- | Just warn about an assertion failure, recording the given file and
--   line number.
warnPprTrace :: HasCallStack => Bool -> String -> SDoc -> a -> a
warnPprTraceM :: (Applicative f, HasCallStack) => Bool -> String -> SDoc -> f ()

module GHC.Utils.Word64
intToWord64 :: HasDebugCallStack => Int -> Word64
word64ToInt :: HasDebugCallStack => Word64 -> Int
truncateWord64ToWord32 :: Word64 -> Word32

module GHC.Utils.Touch

-- | Set the mtime of the given file to the current time.
touch :: FilePath -> IO ()


-- | A state monad which is strict in its state.
module GHC.Utils.Monad.State.Strict

-- | A state monad which is strict in the state <tt>s</tt>, but lazy in the
--   value <tt>a</tt>.
--   
--   See Note [Strict State monad] for the particular notion of strictness
--   and implementation details.
newtype State s a
State' :: (s -> (# a, s #)) -> State s a
pattern State :: (s -> (# a, s #)) -> State s a
state :: (s -> (a, s)) -> State s a
evalState :: State s a -> s -> a
execState :: State s a -> s -> s
runState :: State s a -> s -> (a, s)
get :: State s s
gets :: (s -> a) -> State s a
put :: s -> State s ()
modify :: (s -> s) -> State s ()
instance GHC.Internal.Base.Applicative (GHC.Utils.Monad.State.Strict.State s)
instance GHC.Internal.Base.Functor (GHC.Utils.Monad.State.Strict.State s)
instance GHC.Internal.Base.Monad (GHC.Utils.Monad.State.Strict.State s)

module GHC.Utils.Monad.Codensity
newtype Codensity (m :: Type -> Type) a
Codensity :: (forall r. () => (a -> m r) -> m r) -> Codensity (m :: Type -> Type) a
[runCodensity] :: Codensity (m :: Type -> Type) a -> forall r. () => (a -> m r) -> m r
toCodensity :: Monad m => m a -> Codensity m a
fromCodensity :: Monad m => Codensity m a -> m a
instance GHC.Internal.Base.Applicative (GHC.Utils.Monad.Codensity.Codensity f)
instance GHC.Internal.Base.Functor (GHC.Utils.Monad.Codensity.Codensity k)
instance GHC.Internal.Base.Monad (GHC.Utils.Monad.Codensity.Codensity f)
instance GHC.Internal.Control.Monad.IO.Class.MonadIO m => GHC.Internal.Control.Monad.Fix.MonadFix (GHC.Utils.Monad.Codensity.Codensity m)
instance GHC.Internal.Control.Monad.IO.Class.MonadIO m => GHC.Internal.Control.Monad.IO.Class.MonadIO (GHC.Utils.Monad.Codensity.Codensity m)
instance Control.Monad.Trans.Class.MonadTrans GHC.Utils.Monad.Codensity.Codensity


-- | Utilities related to Monad and Applicative classes Mostly for
--   backwards compatibility.
module GHC.Utils.Monad
class Functor f => Applicative (f :: Type -> Type)
pure :: Applicative f => a -> f a
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
(*>) :: Applicative f => f a -> f b -> f b
(<*) :: Applicative f => f a -> f b -> f a
(<$>) :: Functor f => (a -> b) -> f a -> f b
class Monad m => MonadFix (m :: Type -> Type)
mfix :: MonadFix m => (a -> m a) -> m a
class Monad m => MonadIO (m :: Type -> Type)
liftIO :: MonadIO m => IO a -> m a
zipWith3M :: Monad m => (a -> b -> c -> m d) -> [a] -> [b] -> [c] -> m [d]
zipWith3M_ :: Monad m => (a -> b -> c -> m d) -> [a] -> [b] -> [c] -> m ()
zipWith4M :: Monad m => (a -> b -> c -> d -> m e) -> [a] -> [b] -> [c] -> [d] -> m [e]
zipWithAndUnzipM :: Monad m => (a -> b -> m (c, d)) -> [a] -> [b] -> m ([c], [d])

-- | <a>zipWith3M</a> for <a>NonEmpty</a> lists.
zipWith3MNE :: Monad m => (a -> b -> c -> m d) -> NonEmpty a -> NonEmpty b -> NonEmpty c -> m (NonEmpty d)
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | mapAndUnzipM for triples
mapAndUnzip3M :: Monad m => (a -> m (b, c, d)) -> [a] -> m ([b], [c], [d])
mapAndUnzip4M :: Monad m => (a -> m (b, c, d, e)) -> [a] -> m ([b], [c], [d], [e])
mapAndUnzip5M :: Monad m => (a -> m (b, c, d, e, f)) -> [a] -> m ([b], [c], [d], [e], [f])

-- | Monadic version of mapAccumL
mapAccumLM :: (Monad m, Traversable t) => (acc -> x -> m (acc, y)) -> acc -> t x -> m (acc, t y)

-- | Monadic version of mapSnd
mapSndM :: (Applicative m, Traversable f) => (b -> m c) -> f (a, b) -> m (f (a, c))

-- | Monadic version of concatMap
concatMapM :: (Monad m, Traversable f) => (a -> m [b]) -> f a -> m [b]

-- | Applicative version of mapMaybe
mapMaybeM :: Applicative m => (a -> m (Maybe b)) -> [a] -> m [b]

-- | Monadic version of <a>any</a>, aborts the computation at the first
--   <tt>True</tt> value
anyM :: (Monad m, Foldable f) => (a -> m Bool) -> f a -> m Bool

-- | Monad version of <a>all</a>, aborts the computation at the first
--   <tt>False</tt> value
allM :: (Monad m, Foldable f) => (a -> m Bool) -> f a -> m Bool

-- | Monadic version of or
orM :: Monad m => m Bool -> m Bool -> m Bool
foldlM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Monadic version of foldl that discards its result
foldlM_ :: (Monad m, Foldable t) => (a -> b -> m a) -> a -> t b -> m ()
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b

-- | Monadic version of <a>foldMap</a>
foldMapM :: (Applicative m, Foldable t, Monoid b) => (a -> m b) -> t a -> m b

-- | Monadic version of <tt>when</tt>, taking the condition in the monad
whenM :: Monad m => m Bool -> m () -> m ()

-- | Monadic version of <tt>unless</tt>, taking the condition in the monad
unlessM :: Monad m => m Bool -> m () -> m ()

-- | Like <a>filterM</a>, only it reverses the sense of the test.
filterOutM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

-- | Monadic version of <tt>partition</tt>
partitionM :: Monad m => (a -> m Bool) -> [a] -> m ([a], [a])

module GHC.Utils.Lexeme
isLexCon :: FastString -> Bool
isLexVar :: FastString -> Bool
isLexId :: FastString -> Bool
isLexSym :: FastString -> Bool
isLexConId :: FastString -> Bool
isLexConSym :: FastString -> Bool
isLexVarId :: FastString -> Bool
isLexVarSym :: FastString -> Bool
startsVarSym :: Char -> Bool
startsVarId :: Char -> Bool
startsConSym :: Char -> Bool
startsConId :: Char -> Bool

-- | Is this an acceptable variable name?
okVarOcc :: String -> Bool

-- | Is this an acceptable constructor name?
okConOcc :: String -> Bool

-- | Is this an acceptable type name?
okTcOcc :: String -> Bool

-- | Is this an acceptable alphanumeric variable name, assuming it starts
--   with an acceptable letter?
okVarIdOcc :: String -> Bool

-- | Is this an acceptable symbolic variable name, assuming it starts with
--   an acceptable character?
okVarSymOcc :: String -> Bool

-- | Is this an acceptable alphanumeric constructor name, assuming it
--   starts with an acceptable letter?
okConIdOcc :: String -> Bool

-- | Is this an acceptable symbolic constructor name, assuming it starts
--   with an acceptable character?
okConSymOcc :: String -> Bool

module GHC.Utils.CliOption

-- | When invoking external tools as part of the compilation pipeline, we
--   pass these a sequence of options on the command-line. Rather than just
--   using a list of Strings, we use a type that allows us to distinguish
--   between filepaths and 'other stuff'. The reason for this is that this
--   type gives us a handle on transforming filenames, and filenames only,
--   to whatever format they're expected to be on a particular platform.
data Option
FileOption :: String -> String -> Option
Option :: String -> Option
showOpt :: Option -> String
instance GHC.Classes.Eq GHC.Utils.CliOption.Option

module GHC.Types.ProfAuto

-- | What kind of {-# SCC #-} to add automatically
data ProfAuto

-- | no SCC annotations added
NoProfAuto :: ProfAuto

-- | top-level and nested functions are annotated
ProfAutoAll :: ProfAuto

-- | top-level functions annotated only
ProfAutoTop :: ProfAuto

-- | exported functions annotated only
ProfAutoExports :: ProfAuto

-- | annotate call-sites
ProfAutoCalls :: ProfAuto
instance GHC.Internal.Enum.Enum GHC.Types.ProfAuto.ProfAuto
instance GHC.Classes.Eq GHC.Types.ProfAuto.ProfAuto


-- | Haskell Program Coverage (HPC) support
module GHC.Types.HpcInfo

-- | Information about a modules use of Haskell Program Coverage
data HpcInfo
HpcInfo :: Int -> Int -> HpcInfo
[hpcInfoTickCount] :: HpcInfo -> Int
[hpcInfoHash] :: HpcInfo -> Int
NoHpcInfo :: AnyHpcUsage -> HpcInfo

-- | Is hpc used anywhere on the module *tree*?
[hpcUsed] :: HpcInfo -> AnyHpcUsage

-- | This is used to signal if one of my imports used HPC instrumentation
--   even if there is no module-local HPC usage
type AnyHpcUsage = Bool
emptyHpcInfo :: AnyHpcUsage -> HpcInfo

-- | Find out if HPC is used by this module or any of the modules it
--   depends upon
isHpcUsed :: HpcInfo -> AnyHpcUsage

module GHC.Tc.Types.TcRef

-- | Type alias for <a>IORef</a>; the convention is we'll use this for
--   mutable bits of data in the typechecker which are updated during
--   typechecking and returned at the end.
type TcRef a = IORef a
newTcRef :: MonadIO m => a -> m (TcRef a)
readTcRef :: MonadIO m => TcRef a -> m a
writeTcRef :: MonadIO m => TcRef a -> a -> m ()
updTcRef :: MonadIO m => TcRef a -> (a -> a) -> m ()
updTcRefM :: MonadIO m => TcRef a -> (a -> m a) -> m ()

module GHC.SysTools.Terminal

-- | Does the controlling terminal support ANSI color sequences? This
--   memoized to avoid thread-safety issues in ncurses (see #17922).
stderrSupportsAnsiColors :: Bool

module GHC.SysTools.Ar
data ArchiveEntry
ArchiveEntry :: String -> Int -> Int -> Int -> Int -> Int -> ByteString -> ArchiveEntry

-- | File name.
[filename] :: ArchiveEntry -> String

-- | File modification time.
[filetime] :: ArchiveEntry -> Int

-- | File owner.
[fileown] :: ArchiveEntry -> Int

-- | File group.
[filegrp] :: ArchiveEntry -> Int

-- | File mode.
[filemode] :: ArchiveEntry -> Int

-- | File size.
[filesize] :: ArchiveEntry -> Int

-- | File bytes.
[filedata] :: ArchiveEntry -> ByteString
newtype Archive
Archive :: [ArchiveEntry] -> Archive
afilter :: (ArchiveEntry -> Bool) -> Archive -> Archive
parseAr :: ByteString -> Archive
loadAr :: FilePath -> IO Archive
loadObj :: FilePath -> IO ArchiveEntry
writeBSDAr :: FilePath -> Archive -> IO ()
writeGNUAr :: FilePath -> Archive -> IO ()
isBSDSymdef :: ArchiveEntry -> Bool
isGNUSymdef :: ArchiveEntry -> Bool
instance GHC.Classes.Eq GHC.SysTools.Ar.Archive
instance GHC.Classes.Eq GHC.SysTools.Ar.ArchiveEntry
instance GHC.Internal.Base.Monoid GHC.SysTools.Ar.Archive
instance GHC.Internal.Base.Semigroup GHC.SysTools.Ar.Archive
instance GHC.Internal.Show.Show GHC.SysTools.Ar.Archive
instance GHC.Internal.Show.Show GHC.SysTools.Ar.ArchiveEntry


-- | Compile-time settings
module GHC.Settings.Constants
hiVersion :: Integer
mAX_TUPLE_SIZE :: Int
mAX_CTUPLE_SIZE :: Int
mAX_SUM_SIZE :: Int

-- | Default maximum depth for both class instance search and type family
--   reduction. See also #5395.
mAX_REDUCTION_DEPTH :: Int

-- | Default maximum constraint-solver iterations Typically there should be
--   very few
mAX_SOLVER_ITERATIONS :: Int

-- | In case of loopy quantified constraints constraints, how many times
--   should we allow superclass expansions Should be less than
--   mAX_SOLVER_ITERATIONS See Note [Expanding Recursive Superclasses and
--   ExpansionFuel]
mAX_QC_FUEL :: Int

-- | In case of loopy wanted constraints, how many times should we allow
--   superclass expansions Should be less than mAX_GIVENS_FUEL See Note
--   [Expanding Recursive Superclasses and ExpansionFuel]
mAX_WANTEDS_FUEL :: Int

-- | In case of loopy given constraints, how many times should we allow
--   superclass expansions Should be less than max_SOLVER_ITERATIONS See
--   Note [Expanding Recursive Superclasses and ExpansionFuel]
mAX_GIVENS_FUEL :: Int
wORD64_SIZE :: Int
fLOAT_SIZE :: Int
dOUBLE_SIZE :: Int
tARGET_MAX_CHAR :: Int

module GHC.Runtime.Utils
runWithPipes :: (CreateProcess -> IO ProcessHandle) -> FilePath -> [String] -> [String] -> IO (ProcessHandle, Handle, Handle)


-- | External plugins
--   
--   GHC supports two kinds of "static" plugins: 1. internal: setup with
--   GHC-API 2. external: setup as explained below and loaded from shared
--   libraries
--   
--   The intended use case for external static plugins is with cross
--   compilers: at the time of writing, GHC is mono-target and a GHC
--   cross-compiler (i.e. when host /= target) can't build nor load plugins
--   for the host using the "non-static" plugin approach. Fixing this is
--   tracked in #14335. If you're not using a cross-compiler, you'd better
--   use non-static plugins which are easier to build and and safer to use
--   (see below).
--   
--   External static plugins can be configured via the command-line with
--   the -fplugin-library flag. Syntax is:
--   
--   <ul>
--   <li>fplugin-library=⟨file-path⟩;⟨unit-id⟩;⟨module⟩;⟨args⟩</li>
--   </ul>
--   
--   Example:
--   -fplugin-library=path<i>to</i>plugin;package-123;Plugin.Module;[<a>Argument</a>,<a>List</a>]
--   
--   Building the plugin library: 1. link with the libraries used to build
--   the compiler you target. If you target a cross-compiler (stage2), you
--   can't directly use it to build the plugin library. Use the stage1
--   compiler instead.
--   
--   <ol>
--   <li>if you use cabal to build the library, its unit-id will be set by
--   cabal and will contain a hash (e.g.
--   "my-plugin-unit-1345656546ABCDEF"). To force the unit id, use GHC's
--   `-this-unit-id` command line flag: e.g. -this-unit-id my-plugin-unit
--   You can set this in the .cabal file of your library with the following
--   stanza: `ghc-options: -this-unit-id my-plugin-unit`</li>
--   <li>To make your plugin easier to distribute, you may want to link it
--   statically with all its dependencies. You would need to use `-shared`
--   without `-dynamic` when building your library.</li>
--   </ol>
--   
--   However, all the static dependencies have to be built with `-fPIC` and
--   it's not done by default. See
--   <a>https://www.hobson.space/posts/haskell-foreign-library/</a> for a
--   way to modify the compiler to do it.
--   
--   In any case, don't link your plugin library statically with the RTS
--   (e.g. use `-fno-link-rts`) as there are some global variables in the
--   RTS that must be shared between the plugin and the compiler.
--   
--   With external static plugins we don't check the type of the
--   <tt>plugin</tt> closure we look up. If it's not a valid
--   <tt>Plugin</tt> value, it will probably crash badly.
module GHC.Driver.Plugins.External

-- | External plugin spec
data ExternalPluginSpec
ExternalPluginSpec :: !FilePath -> !String -> !String -> ![String] -> ExternalPluginSpec
[esp_lib] :: ExternalPluginSpec -> !FilePath
[esp_unit_id] :: ExternalPluginSpec -> !String
[esp_module] :: ExternalPluginSpec -> !String
[esp_args] :: ExternalPluginSpec -> ![String]

-- | Parser external static plugin specification from command-line flag
parseExternalPluginSpec :: String -> Maybe ExternalPluginSpec


-- | In versions of GHC up through 9.2, a <tt>Backend</tt> was represented
--   only by its name. This module is meant to aid clients written against
--   the GHC API, versions 9.2 and older. The module provides an
--   alternative way to name any back end found in GHC 9.2. /Code within
--   the GHC source tree should not import this module./ (#20927).
--   
--   Only back ends found in version 9.2 have names.
module GHC.Driver.Backend.Internal
data BackendName

-- | Names the native code generator backend.
NCG :: BackendName

-- | Names the LLVM backend.
LLVM :: BackendName

-- | Names the Via-C backend.
ViaC :: BackendName

-- | Names the JS backend.
JavaScript :: BackendName

-- | Names the ByteCode interpreter.
Interpreter :: BackendName

-- | Names the `-fno-code` backend.
NoBackend :: BackendName
instance GHC.Classes.Eq GHC.Driver.Backend.Internal.BackendName
instance GHC.Internal.Show.Show GHC.Driver.Backend.Internal.BackendName

module GHC.Data.UnionFind

-- | A variable which can be unified; alternately, this can be thought of
--   as an equivalence class with a distinguished representative.
newtype Point s a
Point :: STRef s (Link s a) -> Point s a

-- | Mutable write to a <a>Point</a>
writePoint :: Point s a -> Link s a -> ST s ()

-- | Read the current value of <a>Point</a>.
readPoint :: Point s a -> ST s (Link s a)

-- | The internal data structure for a <a>Point</a>, which either records
--   the representative element of an equivalence class, or a link to the
--   <a>Point</a> that actually stores the representative type.
data Link s a
Info :: {-# UNPACK #-} !STRef s Int -> {-# UNPACK #-} !STRef s a -> Link s a
Link :: {-# UNPACK #-} !Point s a -> Link s a

-- | Create a fresh equivalence class with one element.
fresh :: a -> ST s (Point s a)

-- | Flatten any chains of links, returning a <a>Point</a> which points
--   directly to the canonical representation.
repr :: Point s a -> ST s (Point s a)

-- | Return the canonical element of an equivalence class <a>Point</a>.
find :: Point s a -> ST s a

-- | Unify two equivalence classes, so that they share a canonical element.
--   Keeps the descriptor of point2.
union :: Point s a -> Point s a -> ST s ()

-- | Test if two points are in the same equivalence class.
equivalent :: Point s a -> Point s a -> ST s Bool
instance GHC.Classes.Eq (GHC.Data.UnionFind.Point s a)

module GHC.Data.Unboxed

-- | Like Maybe, but using unboxed sums.
--   
--   Use with care. Using a unboxed maybe is not always a win in execution
--   *time* even when allocations go down. So make sure to benchmark for
--   execution time as well. If the difference in *runtime* for the
--   compiler is too small to measure it's likely better to use a regular
--   Maybe instead.
--   
--   This is since it causes more function arguments to be passed, and
--   potentially more variables to be captured by closures increasing
--   closure size.
data MaybeUB a :: TYPE 'SumRep '[ZeroBitRep, LiftedRep]
pattern JustUB :: a -> MaybeUB a
pattern NothingUB :: MaybeUB a
fmapMaybeUB :: (a -> b) -> MaybeUB a -> MaybeUB b
fromMaybeUB :: a -> MaybeUB a -> a
apMaybeUB :: MaybeUB (a -> b) -> MaybeUB a -> MaybeUB b
maybeUB :: b -> (a -> b) -> MaybeUB a -> b

module GHC.Data.StringBuffer

-- | A StringBuffer is an internal pointer to a sized chunk of bytes. The
--   bytes are intended to be *immutable*. There are pure operations to
--   read the contents of a StringBuffer.
--   
--   A StringBuffer may have a finalizer, depending on how it was obtained.
data StringBuffer
StringBuffer :: {-# UNPACK #-} !ForeignPtr Word8 -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> StringBuffer
[buf] :: StringBuffer -> {-# UNPACK #-} !ForeignPtr Word8
[len] :: StringBuffer -> {-# UNPACK #-} !Int
[cur] :: StringBuffer -> {-# UNPACK #-} !Int

-- | Read a file into a <a>StringBuffer</a>. The resulting buffer is
--   automatically managed by the garbage collector.
hGetStringBuffer :: FilePath -> IO StringBuffer
hGetStringBufferBlock :: Handle -> Int -> IO StringBuffer
hPutStringBuffer :: Handle -> StringBuffer -> IO ()
appendStringBuffers :: StringBuffer -> StringBuffer -> IO StringBuffer

-- | Encode a <a>String</a> into a <a>StringBuffer</a> as UTF-8. The
--   resulting buffer is automatically managed by the garbage collector.
stringToStringBuffer :: String -> StringBuffer

-- | Convert a UTF-8 encoded <a>ByteString</a> into a 'StringBuffer. This
--   really relies on the internals of both <a>ByteString</a> and
--   <a>StringBuffer</a>.
--   
--   <i>O(n)</i> (but optimized into a <tt>memcpy</tt> by
--   <tt>bytestring</tt> under the hood)
stringBufferFromByteString :: ByteString -> StringBuffer

-- | Return the first UTF-8 character of a nonempty <a>StringBuffer</a> and
--   as well the remaining portion (analogous to <a>uncons</a>).
--   <b>Warning:</b> The behavior is undefined if the <a>StringBuffer</a>
--   is empty. The result shares the same buffer as the original. Similar
--   to <tt>utf8DecodeChar</tt>, if the character cannot be decoded as
--   UTF-8, <tt>'\0'</tt> is returned.
nextChar :: StringBuffer -> (Char, StringBuffer)

-- | Return the first UTF-8 character of a nonempty <a>StringBuffer</a>
--   (analogous to <a>head</a>). <b>Warning:</b> The behavior is undefined
--   if the <a>StringBuffer</a> is empty. Similar to
--   <tt>utf8DecodeChar</tt>, if the character cannot be decoded as UTF-8,
--   <tt>'\0'</tt> is returned.
currentChar :: StringBuffer -> Char
prevChar :: StringBuffer -> Char -> Char

-- | Check whether a <a>StringBuffer</a> is empty (analogous to
--   <a>null</a>).
atEnd :: StringBuffer -> Bool

-- | Computes a hash of the contents of a <a>StringBuffer</a>.
fingerprintStringBuffer :: StringBuffer -> Fingerprint

-- | Return a <a>StringBuffer</a> with the first UTF-8 character removed
--   (analogous to <a>tail</a>). <b>Warning:</b> The behavior is undefined
--   if the <a>StringBuffer</a> is empty. The result shares the same buffer
--   as the original.
stepOn :: StringBuffer -> StringBuffer

-- | Return a <a>StringBuffer</a> with the first <tt>n</tt> bytes removed.
--   <b>Warning:</b> If there aren't enough characters, the returned
--   <a>StringBuffer</a> will be invalid and any use of it may lead to
--   undefined behavior. The result shares the same buffer as the original.
offsetBytes :: Int -> StringBuffer -> StringBuffer

-- | Compute the difference in offset between two <a>StringBuffer</a>s that
--   share the same buffer. <b>Warning:</b> The behavior is undefined if
--   the <a>StringBuffer</a>s use separate buffers.
byteDiff :: StringBuffer -> StringBuffer -> Int

-- | Computes a <a>StringBuffer</a> which points to the first character of
--   the wanted line. Lines begin at 1.
atLine :: Int -> StringBuffer -> Maybe StringBuffer

-- | Decode the first <tt>n</tt> bytes of a <a>StringBuffer</a> as UTF-8
--   into a <a>String</a>. Similar to <tt>utf8DecodeChar</tt>, if the
--   character cannot be decoded as UTF-8, they will be replaced with
--   <tt>'\0'</tt>.
lexemeToString :: StringBuffer -> Int -> String
lexemeToFastString :: StringBuffer -> Int -> FastString

-- | Return the previous <tt>n</tt> characters (or fewer if we are less
--   than <tt>n</tt> characters into the buffer.
decodePrevNChars :: Int -> StringBuffer -> String
parseUnsignedInteger :: StringBuffer -> Int -> Integer -> (Char -> Int) -> Integer

-- | Find the offset of the <tt>#</tt> character in the StringBuffer.
--   
--   Make sure that it contains one before calling this function!
findHashOffset :: StringBuffer -> Int

-- | Returns true if the buffer contains Unicode bi-directional formatting
--   characters.
--   
--   
--   <a>https://www.unicode.org/reports/tr9/#Bidirectional_Character_Types</a>
--   
--   Bidirectional format characters are one of 'x202a' : "U+202A
--   LEFT-TO-RIGHT EMBEDDING (LRE)" 'x202b' : "U+202B RIGHT-TO-LEFT
--   EMBEDDING (RLE)" 'x202c' : "U+202C POP DIRECTIONAL FORMATTING (PDF)"
--   'x202d' : "U+202D LEFT-TO-RIGHT OVERRIDE (LRO)" 'x202e' : "U+202E
--   RIGHT-TO-LEFT OVERRIDE (RLO)" 'x2066' : "U+2066 LEFT-TO-RIGHT ISOLATE
--   (LRI)" 'x2067' : "U+2067 RIGHT-TO-LEFT ISOLATE (RLI)" 'x2068' :
--   "U+2068 FIRST STRONG ISOLATE (FSI)" 'x2069' : "U+2069 POP DIRECTIONAL
--   ISOLATE (PDI)"
--   
--   This list is encoded in <a>bidirectionalFormatChars</a>
containsBidirectionalFormatChar :: StringBuffer -> Bool
bidirectionalFormatChars :: [(Char, String)]
instance GHC.Internal.Show.Show GHC.Data.StringBuffer.StringBuffer

module GHC.Data.Strict
data Maybe a
Nothing :: Maybe a
Just :: !a -> Maybe a
fromMaybe :: a -> Maybe a -> a
maybe :: b -> (a -> b) -> Maybe a -> b
data Pair a b
And :: !a -> !b -> Pair a b
instance GHC.Internal.Base.Alternative GHC.Data.Strict.Maybe
instance GHC.Internal.Base.Applicative GHC.Data.Strict.Maybe
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Data.Strict.Maybe a)
instance (GHC.Internal.Data.Data.Data a, GHC.Internal.Data.Data.Data b) => GHC.Internal.Data.Data.Data (GHC.Data.Strict.Pair a b)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Data.Strict.Maybe a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (GHC.Data.Strict.Pair a b)
instance GHC.Internal.Data.Foldable.Foldable GHC.Data.Strict.Maybe
instance GHC.Internal.Data.Foldable.Foldable (GHC.Data.Strict.Pair a)
instance GHC.Internal.Base.Functor GHC.Data.Strict.Maybe
instance GHC.Internal.Base.Functor (GHC.Data.Strict.Pair a)
instance GHC.Internal.Base.Semigroup a => GHC.Internal.Base.Monoid (GHC.Data.Strict.Maybe a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Data.Strict.Maybe a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (GHC.Data.Strict.Pair a b)
instance GHC.Internal.Base.Semigroup a => GHC.Internal.Base.Semigroup (GHC.Data.Strict.Maybe a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Data.Strict.Maybe a)
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b) => GHC.Internal.Show.Show (GHC.Data.Strict.Pair a b)
instance GHC.Internal.Data.Traversable.Traversable GHC.Data.Strict.Maybe
instance GHC.Internal.Data.Traversable.Traversable (GHC.Data.Strict.Pair a)


-- | Monadic streams
module GHC.Data.Stream

-- | <tt>Stream m a b</tt> is a computation in some Monad <tt>m</tt> that
--   delivers a sequence of elements of type <tt>a</tt> followed by a
--   result of type <tt>b</tt>.
--   
--   More concretely, a value of type <tt>Stream m a b</tt> can be run
--   using <tt>runStreamInternal</tt> in the Monad <tt>m</tt>, and it
--   delivers either
--   
--   <ul>
--   <li>the final result: <tt>Done b</tt>, or</li>
--   <li><tt>Yield a str</tt> where <tt>a</tt> is the next element in the
--   stream, and <tt>str</tt> is the rest of the stream</li>
--   <li><tt>Effect mstr</tt> where <tt>mstr</tt> is some action running in
--   <tt>m</tt> which generates the rest of the stream.</li>
--   </ul>
--   
--   Stream is itself a Monad, and provides an operation <a>yield</a> that
--   produces a new element of the stream. This makes it convenient to turn
--   existing monadic computations into streams.
--   
--   The idea is that Stream is useful for making a monadic computation
--   that produces values from time to time. This can be used for knitting
--   together two complex monadic operations, so that the producer does not
--   have to produce all its values before the consumer starts consuming
--   them. We make the producer into a Stream, and the consumer pulls on
--   the stream each time it wants a new value.
--   
--   <a>Stream</a> is implemented in the "yoneda" style for efficiency. By
--   representing a stream in this manner <a>fmap</a> and <a>&gt;&gt;=</a>
--   operations are accumulated in the function parameters before being
--   applied once when the stream is destroyed. In the old implementation
--   each usage of <a>mapM</a> and <a>&gt;&gt;=</a> would traverse the
--   entire stream in order to apply the substitution at the leaves.
--   
--   The &gt;&gt;= operation for <a>Stream</a> was a hot-spot in the ticky
--   profile for the <a>ManyConstructors</a> test which called the
--   <tt>cg</tt> function many times in <tt>StgToCmm.hs</tt>
newtype Stream (m :: Type -> Type) a b
Stream :: (forall r' r. () => (a -> m r') -> (b -> StreamS m r' r) -> StreamS m r' r) -> Stream (m :: Type -> Type) a b
[runStreamInternal] :: Stream (m :: Type -> Type) a b -> forall r' r. () => (a -> m r') -> (b -> StreamS m r' r) -> StreamS m r' r
data StreamS (m :: Type -> Type) a b
Yield :: a -> StreamS m a b -> StreamS (m :: Type -> Type) a b
Done :: b -> StreamS (m :: Type -> Type) a b
Effect :: m (StreamS m a b) -> StreamS (m :: Type -> Type) a b
runStream :: forall (m :: Type -> Type) r' r. Applicative m => Stream m r' r -> StreamS m r' r
yield :: forall (m :: Type -> Type) a. Monad m => a -> Stream m a ()
liftIO :: MonadIO m => IO a -> m a

-- | Lift an effect into the Stream
liftEff :: Monad m => m b -> Stream m a b

-- | Hoist the underlying Stream effect Note this is not very efficience
--   since, just like <a>mapAccumL_</a>, it also needs to traverse and
--   rebuild the whole stream.
hoistEff :: (Applicative m, Monad n) => (forall x. () => m x -> n x) -> Stream m a b -> Stream n a b

-- | Turn a Stream into an ordinary list, by demanding all the elements.
collect :: Monad m => Stream m a () -> m [a]
consume :: (Monad m, Monad n) => Stream m a b -> (forall a1. () => m a1 -> n a1) -> (a -> n ()) -> n b

-- | Turn a list into a <a>Stream</a>, by yielding each element in turn.
fromList :: forall (m :: Type -> Type) a. Monad m => [a] -> Stream m a ()

-- | Apply a function to each element of a <a>Stream</a>, lazily
map :: forall (m :: Type -> Type) a b x. Monad m => (a -> b) -> Stream m a x -> Stream m b x

-- | Apply a monadic operation to each element of a <a>Stream</a>, lazily
mapM :: Monad m => (a -> m b) -> Stream m a x -> Stream m b x

-- | Note this is not very efficient because it traverses the whole stream
--   before rebuilding it, avoid using it if you can. mapAccumL used to
--   implemented but it wasn't used anywhere in the compiler and has
--   similar efficiency problems.
mapAccumL_ :: forall m a b c r. Monad m => (c -> a -> m (c, b)) -> c -> Stream m a r -> Stream m b (c, r)
instance GHC.Internal.Base.Applicative (GHC.Data.Stream.Stream m a)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Applicative (GHC.Data.Stream.StreamS m a)
instance GHC.Internal.Base.Functor (GHC.Data.Stream.Stream f a)
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (GHC.Data.Stream.StreamS m a)
instance GHC.Internal.Control.Monad.IO.Class.MonadIO m => GHC.Internal.Control.Monad.IO.Class.MonadIO (GHC.Data.Stream.Stream m b)
instance GHC.Internal.Base.Monad (GHC.Data.Stream.Stream m a)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (GHC.Data.Stream.StreamS m a)


-- | Small-array
module GHC.Data.SmallArray
data SmallMutableArray s a
SmallMutableArray :: SmallMutableArray# s a -> SmallMutableArray s a
data SmallArray a
SmallArray :: SmallArray# a -> SmallArray a
newSmallArray :: Int -> a -> State# s -> (# State# s, SmallMutableArray s a #)
writeSmallArray :: SmallMutableArray s a -> Int -> a -> State# s -> State# s

-- | Copy and freeze a slice of a mutable array.
freezeSmallArray :: SmallMutableArray s a -> Int -> Int -> State# s -> (# State# s, SmallArray a #)

-- | Freeze a mutable array (no copy!)
unsafeFreezeSmallArray :: SmallMutableArray s a -> State# s -> (# State# s, SmallArray a #)

-- | Index a small-array (no bounds checking!)
indexSmallArray :: SmallArray a -> Int -> a

-- | Get the size of a <a>SmallArray</a>
sizeofSmallArray :: SmallArray a -> Int

-- | Convert a list into an array.
listToArray :: Int -> (e -> Int) -> (e -> a) -> [e] -> SmallArray a

-- | Map a function over the elements of a <a>SmallArray</a>
mapSmallArray :: (a -> b) -> SmallArray a -> SmallArray b

-- | Fold the values of a <a>SmallArray</a> into a 'Monoid m' of choice
foldMapSmallArray :: Monoid m => (a -> m) -> SmallArray a -> m

-- | Force the elements of the given <a>SmallArray</a>
rnfSmallArray :: NFData a => SmallArray a -> ()

module GHC.Data.Maybe
data MaybeErr err val
Succeeded :: val -> MaybeErr err val
Failed :: err -> MaybeErr err val
failME :: err -> MaybeErr err val
isSuccess :: MaybeErr err val -> Bool

-- | Flipped version of <tt>fromMaybe</tt>, useful for chaining.
orElse :: Maybe a -> a -> a
infixr 4 `orElse`
firstJust :: Maybe a -> Maybe a -> Maybe a

-- | Takes a list of <tt>Maybes</tt> and returns the first <tt>Just</tt> if
--   there is one, or <tt>Nothing</tt> otherwise.
firstJusts :: Foldable f => f (Maybe a) -> Maybe a

-- | Takes computations returnings <tt>Maybes</tt>; tries each one in
--   order. The first one to return a <tt>Just</tt> wins. Returns
--   <tt>Nothing</tt> if all computations return <tt>Nothing</tt>.
firstJustsM :: (Monad m, Foldable f) => f (m (Maybe a)) -> m (Maybe a)
whenIsJust :: Monad m => Maybe a -> (a -> m ()) -> m ()
expectJust :: HasDebugCallStack => String -> Maybe a -> a
rightToMaybe :: Either a b -> Maybe b

-- | The parameterizable maybe monad, obtained by composing an arbitrary
--   monad with the <a>Maybe</a> monad.
--   
--   Computations are actions that may produce a value or exit.
--   
--   The <a>return</a> function yields a computation that produces that
--   value, while <tt>&gt;&gt;=</tt> sequences two subcomputations, exiting
--   if either computation does.
newtype MaybeT (m :: Type -> Type) a
MaybeT :: m (Maybe a) -> MaybeT (m :: Type -> Type) a
[runMaybeT] :: MaybeT (m :: Type -> Type) a -> m (Maybe a)
liftMaybeT :: Monad m => m a -> MaybeT m a

-- | Try performing an <a>IO</a> action, failing on error.
tryMaybeT :: IO a -> MaybeT IO a
instance GHC.Internal.Base.Applicative (GHC.Data.Maybe.MaybeErr err)
instance GHC.Internal.Base.Functor (GHC.Data.Maybe.MaybeErr err)
instance GHC.Internal.Base.Monad (GHC.Data.Maybe.MaybeErr err)

module GHC.Data.FlatBag

-- | Store elements in a flattened representation.
--   
--   A <a>FlatBag</a> is a data structure that stores an ordered list of
--   elements in a flat structure, avoiding the overhead of a linked list.
--   Use this data structure, if the code requires the following
--   properties:
--   
--   <ul>
--   <li>Elements are stored in a long-lived object, and benefit from a
--   flattened representation.</li>
--   <li>The <a>FlatBag</a> will be traversed but not extended or
--   filtered.</li>
--   <li>The number of elements should be known.</li>
--   <li>Sharing of the empty case improves memory behaviour.</li>
--   </ul>
--   
--   A <tt>FlagBag</tt> aims to have as little overhead as possible to
--   store its elements. To achieve that, it distinguishes between the
--   empty case, singleton, tuple and general case. Thus, we only pay for
--   the additional three words of an <tt>Array</tt> if we have at least
--   three elements.
data FlatBag a
EmptyFlatBag :: FlatBag a
UnitFlatBag :: !a -> FlatBag a
TupleFlatBag :: !a -> !a -> FlatBag a

-- | Create an empty <a>FlatBag</a>.
--   
--   The empty <a>FlatBag</a> is shared over all instances.
emptyFlatBag :: FlatBag a

-- | Create a singleton <a>FlatBag</a>.
unitFlatBag :: a -> FlatBag a

-- | Calculate the size of
sizeFlatBag :: FlatBag a -> Word

-- | Get all elements that are stored in the <a>FlatBag</a>.
elemsFlatBag :: FlatBag a -> [a]

-- | Combine two <a>FlatBag</a>s.
--   
--   The new <a>FlatBag</a> contains all elements from both
--   <a>FlatBag</a>s.
--   
--   If one of the <a>FlatBag</a>s is empty, the old <a>FlatBag</a> is
--   reused.
mappendFlatBag :: FlatBag a -> FlatBag a -> FlatBag a

-- | Store the list in a flattened memory representation, avoiding the
--   memory overhead of a linked list.
--   
--   The size <tt>n</tt> needs to be smaller or equal to the length of the
--   list. If it is smaller than the length of the list, overflowing
--   elements are discarded. It is undefined behaviour to set <tt>n</tt> to
--   be bigger than the length of the list.
fromList :: Word -> [a] -> FlatBag a

-- | Convert a <a>SizedSeq</a> into its flattened representation. A
--   'FlatBag a' is more memory efficient than '[a]', if no further
--   modification is necessary.
fromSizedSeq :: SizedSeq a -> FlatBag a
instance GHC.Internal.Data.Foldable.Foldable GHC.Data.FlatBag.FlatBag
instance GHC.Internal.Base.Functor GHC.Data.FlatBag.FlatBag
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Data.FlatBag.FlatBag a)
instance GHC.Internal.Data.Traversable.Traversable GHC.Data.FlatBag.FlatBag

module GHC.Data.FiniteMap
insertList :: Ord key => [(key, elt)] -> Map key elt -> Map key elt
insertListWith :: Ord key => (elt -> elt -> elt) -> [(key, elt)] -> Map key elt -> Map key elt
deleteList :: Ord key => [key] -> Map key elt -> Map key elt
foldRight :: (elt -> a -> a) -> a -> Map key elt -> a
foldRightWithKey :: (key -> elt -> a -> a) -> a -> Map key elt -> a

module GHC.CmmToLlvm.Version.Type
newtype LlvmVersion
LlvmVersion :: NonEmpty Int -> LlvmVersion
[llvmVersionNE] :: LlvmVersion -> NonEmpty Int
instance GHC.Classes.Eq GHC.CmmToLlvm.Version.Type.LlvmVersion
instance GHC.Classes.Ord GHC.CmmToLlvm.Version.Type.LlvmVersion

module GHC.CmmToLlvm.Version.Bounds

-- | The (inclusive) lower bound on the LLVM Version that is currently
--   supported.
supportedLlvmVersionLowerBound :: LlvmVersion

-- | The (not-inclusive) upper bound bound on the LLVM Version that is
--   currently supported.
supportedLlvmVersionUpperBound :: LlvmVersion

module GHC.CmmToLlvm.Version
newtype LlvmVersion
LlvmVersion :: NonEmpty Int -> LlvmVersion
[llvmVersionNE] :: LlvmVersion -> NonEmpty Int

-- | The (inclusive) lower bound on the LLVM Version that is currently
--   supported.
supportedLlvmVersionLowerBound :: LlvmVersion

-- | The (not-inclusive) upper bound bound on the LLVM Version that is
--   currently supported.
supportedLlvmVersionUpperBound :: LlvmVersion
parseLlvmVersion :: String -> Maybe LlvmVersion
llvmVersionSupported :: LlvmVersion -> Bool
llvmVersionStr :: LlvmVersion -> String
llvmVersionList :: LlvmVersion -> [Int]

module GHC.CmmToAsm.X86.Cond
data Cond
ALWAYS :: Cond
EQQ :: Cond
GE :: Cond
GEU :: Cond
GTT :: Cond
GU :: Cond
LE :: Cond
LEU :: Cond
LTT :: Cond
LU :: Cond
NE :: Cond
NEG :: Cond
POS :: Cond
CARRY :: Cond
OFLO :: Cond
PARITY :: Cond
NOTPARITY :: Cond
condToUnsigned :: Cond -> Cond

-- | <tt>maybeFlipCond c</tt> returns <tt>Just c'</tt> if it is possible to
--   flip the arguments to the conditional <tt>c</tt>, and the new
--   condition should be <tt>c'</tt>.
maybeFlipCond :: Cond -> Maybe Cond

-- | If we apply <tt>maybeInvertCond</tt> to the condition of a jump we
--   turn jumps taken into jumps not taken and vice versa.
--   
--   Careful! If the used comparison and the conditional jump don't match
--   the above behaviour will NOT hold. When used for FP comparisons this
--   does not consider unordered numbers. Also inverting twice might return
--   a synonym for the original condition.
maybeInvertCond :: Cond -> Maybe Cond
instance GHC.Classes.Eq GHC.CmmToAsm.X86.Cond.Cond

module GHC.CmmToAsm.RV64.Cond

-- | Condition codes.
--   
--   Used in conditional branches and bit setters. According to the
--   available instruction set, some conditions are encoded as their
--   negated opposites. I.e. these are logical things that don't
--   necessarily map 1:1 to hardware/ISA.
data Cond

-- | int and float
EQ :: Cond

-- | int and float
NE :: Cond

-- | signed less than
SLT :: Cond

-- | signed less than or equal
SLE :: Cond

-- | signed greater than or equal
SGE :: Cond

-- | signed greater than
SGT :: Cond

-- | unsigned less than
ULT :: Cond

-- | unsigned less than or equal
ULE :: Cond

-- | unsigned greater than or equal
UGE :: Cond

-- | unsigned greater than
UGT :: Cond

-- | floating point instruction <tt>flt</tt>
FLT :: Cond

-- | floating point instruction <tt>fle</tt>
FLE :: Cond

-- | floating point instruction <tt>fge</tt>
FGE :: Cond

-- | floating point instruction <tt>fgt</tt>
FGT :: Cond
instance GHC.Classes.Eq GHC.CmmToAsm.RV64.Cond.Cond
instance GHC.Internal.Show.Show GHC.CmmToAsm.RV64.Cond.Cond


-- | The Lengauer-Tarjan graph dominators algorithm.
--   
--   &lt;math&gt; Lengauer, Tarjan, <i>A Fast Algorithm for Finding
--   Dominators in a Flowgraph</i>, 1979.
--   
--   &lt;math&gt; Muchnick, <i>Advanced Compiler Design and
--   Implementation</i>, 1997.
--   
--   &lt;math&gt; Brisk, Sarrafzadeh, <i>Interference CGraphs for
--   Procedures in Static Single</i> <i>Information Form are Interval
--   CGraphs</i>, 2007.
--   
--   <ul>
--   <li>Strictness</li>
--   </ul>
--   
--   Unless stated otherwise all exposed functions might fully evaluate
--   their input but are not guaranteed to do so.
module GHC.CmmToAsm.CFG.Dominators
type Node = Word64
type Path = [Node]
type Edge = (Node, Node)
type Graph = Word64Map Word64Set
type Rooted = (Node, Graph)

-- | <i>Immediate dominators</i>. <i>O(|E|*alpha(|E|,|V|))</i>, where
--   <i>alpha(m,n)</i> is "a functional inverse of Ackermann's function".
--   
--   This Complexity bound assumes <i>O(1)</i> indexing. Since we're using
--   <tt>IntMap</tt>, it has an additional <i>lg |V|</i> factor somewhere
--   in there. I'm not sure where.
idom :: Rooted -> [(Node, Node)]

-- | <i>Immediate post-dominators</i>. Complexity as for <tt>idom</tt>.
ipdom :: Rooted -> [(Node, Node)]

-- | <i>Dominator tree</i>. Complexity as for <tt>idom</tt>.
domTree :: Rooted -> Tree Node

-- | <i>Post-dominator tree</i>. Complexity as for <tt>idom</tt>.
pdomTree :: Rooted -> Tree Node

-- | <i>Dominators</i>. Complexity as for <tt>idom</tt>
dom :: Rooted -> [(Node, Path)]

-- | <i>Post-dominators</i>. Complexity as for <tt>idom</tt>.
pdom :: Rooted -> [(Node, Path)]

-- | <i>Post-dominated depth-first search</i>.
pddfs :: Rooted -> [Node]

-- | <i>Reverse post-dominated depth-first search</i>.
rpddfs :: Rooted -> [Node]
fromAdj :: [(Node, [Node])] -> Graph
fromEdges :: [Edge] -> Graph
toAdj :: Graph -> [(Node, [Node])]
toEdges :: Graph -> [Edge]
asTree :: Rooted -> Tree Node
asCGraph :: Tree Node -> Rooted
parents :: Tree a -> [(a, a)]
ancestors :: Tree a -> [(a, [a])]
instance GHC.Internal.Base.Applicative (GHC.CmmToAsm.CFG.Dominators.S z s)
instance GHC.Internal.Base.Functor (GHC.CmmToAsm.CFG.Dominators.S z s)
instance GHC.Internal.Base.Monad (GHC.CmmToAsm.CFG.Dominators.S z s)

module GHC.CmmToAsm.AArch64.Cond
data Cond
ALWAYS :: Cond
EQ :: Cond
NE :: Cond
SLT :: Cond
SLE :: Cond
SGE :: Cond
SGT :: Cond
ULT :: Cond
ULE :: Cond
UGE :: Cond
UGT :: Cond
OLT :: Cond
OLE :: Cond
OGE :: Cond
OGT :: Cond
UOLT :: Cond
UOLE :: Cond
UOGE :: Cond
UOGT :: Cond
VS :: Cond
VC :: Cond
instance GHC.Classes.Eq GHC.CmmToAsm.AArch64.Cond.Cond

module GHC.Cmm.Dataflow.Block

-- | Used at the type level to indicate "open" vs "closed" structure.
data Extensibility

-- | An "open" structure with a unique, unnamed control-flow edge flowing
--   in or out. "Fallthrough" and concatenation are permitted at an open
--   point.
Open :: Extensibility

-- | A "closed" structure which supports control transfer only through the
--   use of named labels---no "fallthrough" is permitted. The number of
--   control-flow edges is unconstrained.
Closed :: Extensibility
type O = 'Open
type C = 'Closed

-- | Maybe type indexed by open/closed
data MaybeO (ex :: Extensibility) t
[JustO] :: forall t. t -> MaybeO 'Open t
[NothingO] :: forall t. MaybeO 'Closed t

-- | Either type indexed by closed/open using type families
type family IndexedCO (ex :: Extensibility) (a :: k) (b :: k) :: k

-- | A sequence of nodes. May be any of four shapes (O<i>O, O</i>C, C<i>O,
--   C</i>C). Open at the entry means single entry, mutatis mutandis for
--   exit. A closed<i>closed block is a </i>basic/ block and can't be
--   extended further. Clients should avoid manipulating blocks and should
--   stick to either nodes or graphs.
data Block (n :: Extensibility -> Extensibility -> Type) (e :: Extensibility) (x :: Extensibility)
[BlockCO] :: forall (n :: Extensibility -> Extensibility -> Type). n C O -> Block n O O -> Block n 'Closed 'Open
[BlockCC] :: forall (n :: Extensibility -> Extensibility -> Type). n C O -> Block n O O -> n O C -> Block n 'Closed 'Closed
[BlockOC] :: forall (n :: Extensibility -> Extensibility -> Type). Block n O O -> n O C -> Block n 'Open 'Closed
[BNil] :: forall (n :: Extensibility -> Extensibility -> Type). Block n 'Open 'Open
[BMiddle] :: forall (n :: Extensibility -> Extensibility -> Type). n O O -> Block n 'Open 'Open
[BCat] :: forall (n :: Extensibility -> Extensibility -> Type). Block n O O -> Block n O O -> Block n 'Open 'Open
[BSnoc] :: forall (n :: Extensibility -> Extensibility -> Type). Block n O O -> n O O -> Block n 'Open 'Open
[BCons] :: forall (n :: Extensibility -> Extensibility -> Type). n O O -> Block n O O -> Block n 'Open 'Open
blockAppend :: forall (n :: Extensibility -> Extensibility -> Type) (e :: Extensibility) (x :: Extensibility). Block n e O -> Block n O x -> Block n e x
blockConcat :: forall (n :: Extensibility -> Extensibility -> Type). [Block n O O] -> Block n O O
blockCons :: forall n (x :: Extensibility). n O O -> Block n O x -> Block n O x
blockFromList :: [n O O] -> Block n O O
blockJoin :: n C O -> Block n O O -> n O C -> Block n C C
blockJoinHead :: forall n (x :: Extensibility). n C O -> Block n O x -> Block n C x
blockJoinTail :: forall n (e :: Extensibility). Block n e O -> n O C -> Block n e C
blockSnoc :: forall n (e :: Extensibility). Block n e O -> n O O -> Block n e O

-- | Split a closed block into its entry node, open middle block, and exit
--   node.
blockSplit :: Block n C C -> (n C O, Block n O O, n O C)
blockSplitHead :: forall n (x :: Extensibility). Block n C x -> (n C O, Block n O x)
blockSplitTail :: forall n (e :: Extensibility). Block n e C -> (Block n e O, n O C)
blockToList :: Block n O O -> [n O O]
emptyBlock :: forall (n :: Extensibility -> Extensibility -> Type). Block n O O
firstNode :: forall n (x :: Extensibility). Block n C x -> n C O
foldBlockNodesB :: (forall (e :: Extensibility) (x :: Extensibility). () => n e x -> a -> a) -> forall (e :: Extensibility) (x :: Extensibility). () => Block n e x -> IndexedCO x a a -> IndexedCO e a a
foldBlockNodesB3 :: forall n a b c. (n C O -> b -> c, n O O -> b -> b, n O C -> a -> b) -> forall (e :: Extensibility) (x :: Extensibility). () => Block n e x -> IndexedCO x a b -> IndexedCO e c b
foldBlockNodesF :: (forall (e :: Extensibility) (x :: Extensibility). () => n e x -> a -> a) -> forall (e :: Extensibility) (x :: Extensibility). () => Block n e x -> IndexedCO e a a -> IndexedCO x a a
isEmptyBlock :: forall (n :: Extensibility -> Extensibility -> Type) (e :: Extensibility) (x :: Extensibility). Block n e x -> Bool
lastNode :: forall n (x :: Extensibility). Block n x C -> n O C

-- | map a function over the nodes of a <a>Block</a>
mapBlock :: forall n n' (e :: Extensibility) (x :: Extensibility). (forall (e1 :: Extensibility) (x1 :: Extensibility). () => n e1 x1 -> n' e1 x1) -> Block n e x -> Block n' e x

-- | A strict <a>mapBlock</a>
mapBlock' :: forall n n' (e :: Extensibility) (x :: Extensibility). (forall (e1 :: Extensibility) (x1 :: Extensibility). () => n e1 x1 -> n' e1 x1) -> Block n e x -> Block n' e x

-- | map over a block, with different functions to apply to first nodes,
--   middle nodes and last nodes respectively. The map is strict.
mapBlock3' :: forall n n' (e :: Extensibility) (x :: Extensibility). (n C O -> n' C O, n O O -> n' O O, n O C -> n' O C) -> Block n e x -> Block n' e x
replaceFirstNode :: forall n (x :: Extensibility). Block n C x -> n C O -> Block n C x
replaceLastNode :: forall n (x :: Extensibility). Block n x C -> n O C -> Block n x C
instance GHC.Internal.Base.Functor (GHC.Cmm.Dataflow.Block.MaybeO ex)

module GHC.SysTools.BaseDir

-- | Expand occurrences of the <tt>$topdir</tt> interpolation in a string.
expandTopDir :: FilePath -> String -> String

-- | Expand occurrences of the <tt>$tooldir</tt> interpolation in a string
--   on Windows, leave the string untouched otherwise.
expandToolDir :: Bool -> Maybe FilePath -> String -> String

-- | Returns a Unix-format path pointing to TopDir.
findTopDir :: Maybe String -> IO String
findToolDir :: Bool -> FilePath -> IO (Maybe FilePath)
tryFindTopDir :: Maybe String -> IO (Maybe String)

module GHC.Parser.CharClass
is_ident :: Char -> Bool
is_symbol :: Char -> Bool
is_any :: Char -> Bool
is_space :: Char -> Bool
is_lower :: Char -> Bool
is_upper :: Char -> Bool
is_digit :: Char -> Bool
is_alphanum :: Char -> Bool
is_decdigit :: Char -> Bool
is_hexdigit :: Char -> Bool
is_octdigit :: Char -> Bool
is_bindigit :: Char -> Bool
hexDigit :: Char -> Int
octDecDigit :: Char -> Int

module GHC.Data.OsPath

-- | Type representing filenames/pathnames.
--   
--   This type doesn't add any guarantees over <a>OsString</a>.
type OsPath = OsString

-- | Newtype representing short operating system specific strings.
--   
--   Internally this is either <a>WindowsString</a> or <a>PosixString</a>,
--   depending on the platform. Both use unpinned <tt>ShortByteString</tt>
--   for efficiency.
--   
--   The constructor is only exported via
--   <a>System.OsString.Internal.Types</a>, since dealing with the
--   internals isn't generally recommended, but supported in case you need
--   to write platform specific code.
data OsString

-- | Partial unicode friendly encoding.
--   
--   On windows this encodes as UTF16-LE (strictly), which is a pretty good
--   guess. On unix this encodes as UTF8 (strictly), which is a good guess.
--   
--   Throws an <a>EncodingException</a> if encoding fails. If the input
--   does not contain surrogate chars, you can use <a>unsafeEncodeUtf</a>.
encodeUtf :: MonadThrow m => FilePath -> m OsPath

-- | Partial unicode friendly decoding.
--   
--   On windows this decodes as UTF16-LE (strictly), which is a pretty good
--   guess. On unix this decodes as UTF8 (strictly), which is a good guess.
--   
--   Throws a <a>EncodingException</a> if decoding fails.
decodeUtf :: MonadThrow m => OsPath -> m FilePath

-- | Decode an <a>OsPath</a> to <a>FilePath</a>, throwing an <a>error</a>
--   if decoding failed. Prefer <a>decodeUtf</a> and gracious error
--   handling.
unsafeDecodeUtf :: HasCallStack => OsPath -> FilePath

-- | Unsafe unicode friendly encoding.
--   
--   Like <a>encodeUtf</a>, except it crashes when the input contains
--   surrogate chars. For sanitized input, this can be useful.
unsafeEncodeUtf :: HasCallStack => String -> OsString

-- | Fallibly converts String to OsString. Only intended to be used on
--   literals.
os :: String -> OsString

-- | Combine two paths with a path separator. If the second path starts
--   with a path separator or a drive letter, then it returns the second.
--   The intention is that <tt>readFile (dir <a>&lt;/&gt;</a> file)</tt>
--   will access the same file as <tt>setCurrentDirectory dir; readFile
--   file</tt>.
--   
--   <pre>
--   Posix:   "/directory" &lt;/&gt; "file.ext" == "/directory/file.ext"
--   Windows: "/directory" &lt;/&gt; "file.ext" == "/directory\\file.ext"
--            "directory" &lt;/&gt; "/file.ext" == "/file.ext"
--   Valid x =&gt; (takeDirectory x &lt;/&gt; takeFileName x) `equalFilePath` x
--   </pre>
--   
--   Combined:
--   
--   <pre>
--   Posix:   "/" &lt;/&gt; "test" == "/test"
--   Posix:   "home" &lt;/&gt; "bob" == "home/bob"
--   Posix:   "x:" &lt;/&gt; "foo" == "x:/foo"
--   Windows: "C:\\foo" &lt;/&gt; "bar" == "C:\\foo\\bar"
--   Windows: "home" &lt;/&gt; "bob" == "home\\bob"
--   </pre>
--   
--   Not combined:
--   
--   <pre>
--   Posix:   "home" &lt;/&gt; "/bob" == "/bob"
--   Windows: "home" &lt;/&gt; "C:\\bob" == "C:\\bob"
--   </pre>
--   
--   Not combined (tricky):
--   
--   On Windows, if a filepath starts with a single slash, it is relative
--   to the root of the current drive. In [1], this is (confusingly)
--   referred to as an absolute path. The current behavior of
--   <a>&lt;/&gt;</a> is to never combine these forms.
--   
--   <pre>
--   Windows: "home" &lt;/&gt; "/bob" == "/bob"
--   Windows: "home" &lt;/&gt; "\\bob" == "\\bob"
--   Windows: "C:\\home" &lt;/&gt; "\\bob" == "\\bob"
--   </pre>
--   
--   On Windows, from [1]: "If a file name begins with only a disk
--   designator but not the backslash after the colon, it is interpreted as
--   a relative path to the current directory on the drive with the
--   specified letter." The current behavior of <a>&lt;/&gt;</a> is to
--   never combine these forms.
--   
--   <pre>
--   Windows: "D:\\foo" &lt;/&gt; "C:bar" == "C:bar"
--   Windows: "C:\\foo" &lt;/&gt; "C:bar" == "C:bar"
--   </pre>
(</>) :: OsPath -> OsPath -> OsPath

-- | Add an extension, even if there is already one there, equivalent to
--   <a>addExtension</a>.
--   
--   <pre>
--   "/directory/path" &lt;.&gt; "ext" == "/directory/path.ext"
--   "/directory/path" &lt;.&gt; ".ext" == "/directory/path.ext"
--   </pre>
(<.>) :: OsPath -> OsString -> OsPath


-- | Static and Dynamic Inductive Graphs
--   
--   Code is from Hackage <tt>fgl</tt> package version 5.7.0.3
module GHC.Data.Graph.Inductive.Graph

-- | Unlabeled node
type Node = Int

-- | Labeled node
type LNode a = (Node, a)

-- | Quasi-unlabeled node
type UNode = LNode ()

-- | Unlabeled edge
type Edge = (Node, Node)

-- | Labeled edge
type LEdge b = (Node, Node, b)

-- | Quasi-unlabeled edge
type UEdge = LEdge ()

-- | Labeled links to or from a <a>Node</a>.
type Adj b = [(b, Node)]

-- | Links to the <a>Node</a>, the <a>Node</a> itself, a label, links from
--   the <a>Node</a>.
--   
--   In other words, this captures all information regarding the specified
--   <a>Node</a> within a graph.
type Context a b = (Adj b, Node, a, Adj b)
type MContext a b = Maybe Context a b

-- | <a>Graph</a> decomposition - the context removed from a <a>Graph</a>,
--   and the rest of the <a>Graph</a>.
type Decomp (g :: Type -> Type -> Type) a b = (MContext a b, g a b)

-- | The same as <a>Decomp</a>, only more sure of itself.
type GDecomp (g :: Type -> Type -> Type) a b = (Context a b, g a b)

-- | Unlabeled context.
type UContext = ([Node], Node, [Node])

-- | Unlabeled decomposition.
type UDecomp g = (Maybe UContext, g)

-- | Unlabeled path
type Path = [Node]

-- | Labeled path
newtype LPath a
LP :: [LNode a] -> LPath a
[unLPath] :: LPath a -> [LNode a]

-- | Quasi-unlabeled path
type UPath = [UNode]

-- | Minimum implementation: <a>empty</a>, <a>isEmpty</a>, <a>match</a>,
--   <a>mkGraph</a>, <a>labNodes</a>
class Graph (gr :: Type -> Type -> Type)

-- | An empty <a>Graph</a>.
empty :: Graph gr => gr a b

-- | True if the given <a>Graph</a> is empty.
isEmpty :: Graph gr => gr a b -> Bool

-- | Decompose a <a>Graph</a> into the <a>MContext</a> found for the given
--   node and the remaining <a>Graph</a>.
match :: Graph gr => Node -> gr a b -> Decomp gr a b

-- | Create a <a>Graph</a> from the list of <a>LNode</a>s and
--   <a>LEdge</a>s.
--   
--   For graphs that are also instances of <a>DynGraph</a>, <tt>mkGraph ns
--   es</tt> should be equivalent to <tt>(<a>insEdges</a> es .
--   <a>insNodes</a> ns) <a>empty</a></tt>.
mkGraph :: Graph gr => [LNode a] -> [LEdge b] -> gr a b

-- | A list of all <a>LNode</a>s in the <a>Graph</a>.
labNodes :: Graph gr => gr a b -> [LNode a]

-- | Decompose a graph into the <a>Context</a> for an arbitrarily-chosen
--   <a>Node</a> and the remaining <a>Graph</a>.
matchAny :: Graph gr => gr a b -> GDecomp gr a b

-- | The number of <a>Node</a>s in a <a>Graph</a>.
noNodes :: Graph gr => gr a b -> Int

-- | The minimum and maximum <a>Node</a> in a <a>Graph</a>.
nodeRange :: Graph gr => gr a b -> (Node, Node)

-- | A list of all <a>LEdge</a>s in the <a>Graph</a>.
labEdges :: Graph gr => gr a b -> [LEdge b]
class Graph gr => DynGraph (gr :: Type -> Type -> Type)

-- | Merge the <a>Context</a> into the <a>DynGraph</a>.
--   
--   Context adjacencies should only refer to either a Node already in a
--   graph or the node in the Context itself (for loops).
--   
--   Behaviour is undefined if the specified <a>Node</a> already exists in
--   the graph.
(&) :: DynGraph gr => Context a b -> gr a b -> gr a b

-- | The number of nodes in the graph. An alias for <a>noNodes</a>.
order :: Graph gr => gr a b -> Int

-- | The number of edges in the graph.
--   
--   Note that this counts every edge found, so if you are representing an
--   unordered graph by having each edge mirrored this will be incorrect.
--   
--   If you created an unordered graph by either mirroring every edge
--   (including loops!) or using the <tt>undir</tt> function in
--   <a>Data.Graph.Inductive.Basic</a> then you can safely halve the value
--   returned by this.
size :: Graph gr => gr a b -> Int

-- | Fold a function over the graph by recursively calling <a>match</a>.
ufold :: Graph gr => (Context a b -> c -> c) -> c -> gr a b -> c

-- | Map a function over the graph by recursively calling <a>match</a>.
gmap :: DynGraph gr => (Context a b -> Context c d) -> gr a b -> gr c d

-- | Map a function over the <a>Node</a> labels in a graph.
nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b

-- | Map a function over the <a>Edge</a> labels in a graph.
emap :: DynGraph gr => (b -> c) -> gr a b -> gr a c

-- | Map functions over both the <a>Node</a> and <a>Edge</a> labels in a
--   graph.
nemap :: DynGraph gr => (a -> c) -> (b -> d) -> gr a b -> gr c d

-- | List all <a>Node</a>s in the <a>Graph</a>.
nodes :: Graph gr => gr a b -> [Node]

-- | List all <a>Edge</a>s in the <a>Graph</a>.
edges :: Graph gr => gr a b -> [Edge]

-- | Drop the label component of an edge.
toEdge :: LEdge b -> Edge

-- | The label in an edge.
edgeLabel :: LEdge b -> b

-- | Add a label to an edge.
toLEdge :: Edge -> b -> LEdge b

-- | List N available <a>Node</a>s, i.e. <a>Node</a>s that are not used in
--   the <a>Graph</a>.
newNodes :: Graph gr => Int -> gr a b -> [Node]

-- | <a>True</a> if the <a>Node</a> is present in the <a>Graph</a>.
gelem :: Graph gr => Node -> gr a b -> Bool

-- | Insert a <a>LNode</a> into the <a>Graph</a>.
insNode :: DynGraph gr => LNode a -> gr a b -> gr a b

-- | Insert a <a>LEdge</a> into the <a>Graph</a>.
insEdge :: DynGraph gr => LEdge b -> gr a b -> gr a b

-- | Remove a <a>Node</a> from the <a>Graph</a>.
delNode :: Graph gr => Node -> gr a b -> gr a b

-- | Remove an <a>Edge</a> from the <a>Graph</a>.
--   
--   NOTE: in the case of multiple edges, this will delete <i>all</i> such
--   edges from the graph as there is no way to distinguish between them.
--   If you need to delete only a single such edge, please use
--   <a>delLEdge</a>.
delEdge :: DynGraph gr => Edge -> gr a b -> gr a b

-- | Remove an <a>LEdge</a> from the <a>Graph</a>.
--   
--   NOTE: in the case of multiple edges with the same label, this will
--   only delete the <i>first</i> such edge. To delete all such edges,
--   please use <tt>delAllLedge</tt>.
delLEdge :: (DynGraph gr, Eq b) => LEdge b -> gr a b -> gr a b

-- | Remove all edges equal to the one specified.
delAllLEdge :: (DynGraph gr, Eq b) => LEdge b -> gr a b -> gr a b

-- | Insert multiple <a>LNode</a>s into the <a>Graph</a>.
insNodes :: DynGraph gr => [LNode a] -> gr a b -> gr a b

-- | Insert multiple <a>LEdge</a>s into the <a>Graph</a>.
insEdges :: DynGraph gr => [LEdge b] -> gr a b -> gr a b

-- | Remove multiple <a>Node</a>s from the <a>Graph</a>.
delNodes :: Graph gr => [Node] -> gr a b -> gr a b

-- | Remove multiple <a>Edge</a>s from the <a>Graph</a>.
delEdges :: DynGraph gr => [Edge] -> gr a b -> gr a b

-- | Build a <a>Graph</a> from a list of <a>Context</a>s.
--   
--   The list should be in the order such that earlier <a>Context</a>s
--   depend upon later ones (i.e. as produced by <tt><a>ufold</a> (:)
--   []</tt>).
buildGr :: DynGraph gr => [Context a b] -> gr a b

-- | Build a quasi-unlabeled <a>Graph</a>.
mkUGraph :: Graph gr => [Node] -> [Edge] -> gr () ()

-- | Build a graph out of the contexts for which the predicate is satisfied
--   by recursively calling <a>match</a>.
gfiltermap :: DynGraph gr => (Context a b -> MContext c d) -> gr a b -> gr c d

-- | Returns the subgraph only containing the nodes which satisfy the given
--   predicate.
nfilter :: DynGraph gr => (Node -> Bool) -> gr a b -> gr a b

-- | Returns the subgraph only containing the labelled nodes which satisfy
--   the given predicate.
labnfilter :: Graph gr => (LNode a -> Bool) -> gr a b -> gr a b

-- | Returns the subgraph only containing the nodes whose labels satisfy
--   the given predicate.
labfilter :: DynGraph gr => (a -> Bool) -> gr a b -> gr a b

-- | Returns the subgraph induced by the supplied nodes.
subgraph :: DynGraph gr => [Node] -> gr a b -> gr a b

-- | Find the context for the given <a>Node</a>. Causes an error if the
--   <a>Node</a> is not present in the <a>Graph</a>.
context :: Graph gr => gr a b -> Node -> Context a b

-- | Find the label for a <a>Node</a>.
lab :: Graph gr => gr a b -> Node -> Maybe a

-- | Find the neighbors for a <a>Node</a>.
neighbors :: Graph gr => gr a b -> Node -> [Node]

-- | Find the labelled links coming into or going from a <a>Context</a>.
lneighbors :: Graph gr => gr a b -> Node -> Adj b

-- | Find all <a>Node</a>s that have a link from the given <a>Node</a>.
suc :: Graph gr => gr a b -> Node -> [Node]

-- | Find all <a>Node</a>s that link to to the given <a>Node</a>.
pre :: Graph gr => gr a b -> Node -> [Node]

-- | Find all <a>Node</a>s that are linked from the given <a>Node</a> and
--   the label of each link.
lsuc :: Graph gr => gr a b -> Node -> [(Node, b)]

-- | Find all <a>Node</a>s that link to the given <a>Node</a> and the label
--   of each link.
lpre :: Graph gr => gr a b -> Node -> [(Node, b)]

-- | Find all outward-bound <a>LEdge</a>s for the given <a>Node</a>.
out :: Graph gr => gr a b -> Node -> [LEdge b]

-- | Find all inward-bound <a>LEdge</a>s for the given <a>Node</a>.
inn :: Graph gr => gr a b -> Node -> [LEdge b]

-- | The outward-bound degree of the <a>Node</a>.
outdeg :: Graph gr => gr a b -> Node -> Int

-- | The inward-bound degree of the <a>Node</a>.
indeg :: Graph gr => gr a b -> Node -> Int

-- | The degree of the <a>Node</a>.
deg :: Graph gr => gr a b -> Node -> Int

-- | Checks if there is a directed edge between two nodes.
hasEdge :: Graph gr => gr a b -> Edge -> Bool

-- | Checks if there is an undirected edge between two nodes.
hasNeighbor :: Graph gr => gr a b -> Node -> Node -> Bool

-- | Checks if there is a labelled edge between two nodes.
hasLEdge :: (Graph gr, Eq b) => gr a b -> LEdge b -> Bool

-- | Checks if there is an undirected labelled edge between two nodes.
hasNeighborAdj :: (Graph gr, Eq b) => gr a b -> Node -> (b, Node) -> Bool
equal :: (Eq a, Eq b, Graph gr) => gr a b -> gr a b -> Bool

-- | The <a>Node</a> in a <a>Context</a>.
node' :: Context a b -> Node

-- | The label in a <a>Context</a>.
lab' :: Context a b -> a

-- | The <a>LNode</a> from a <a>Context</a>.
labNode' :: Context a b -> LNode a

-- | All <a>Node</a>s linked to or from in a <a>Context</a>.
neighbors' :: Context a b -> [Node]

-- | All labelled links coming into or going from a <a>Context</a>.
lneighbors' :: Context a b -> Adj b

-- | All <a>Node</a>s linked to in a <a>Context</a>.
suc' :: Context a b -> [Node]

-- | All <a>Node</a>s linked from in a <a>Context</a>.
pre' :: Context a b -> [Node]

-- | All <a>Node</a>s linked from in a <a>Context</a>, and the label of the
--   links.
lpre' :: Context a b -> [(Node, b)]

-- | All <a>Node</a>s linked from in a <a>Context</a>, and the label of the
--   links.
lsuc' :: Context a b -> [(Node, b)]

-- | All outward-directed <a>LEdge</a>s in a <a>Context</a>.
out' :: Context a b -> [LEdge b]

-- | All inward-directed <a>LEdge</a>s in a <a>Context</a>.
inn' :: Context a b -> [LEdge b]

-- | The outward degree of a <a>Context</a>.
outdeg' :: Context a b -> Int

-- | The inward degree of a <a>Context</a>.
indeg' :: Context a b -> Int

-- | The degree of a <a>Context</a>.
deg' :: Context a b -> Int

-- | Pretty-print the graph. Note that this loses a lot of information,
--   such as edge inverses, etc.
prettify :: (DynGraph gr, Show a, Show b) => gr a b -> String

-- | Pretty-print the graph to stdout.
prettyPrint :: (DynGraph gr, Show a, Show b) => gr a b -> IO ()

-- | OrdGr comes equipped with an Ord instance, so that graphs can be used
--   as e.g. Map keys.
newtype OrdGr (gr :: k -> k1 -> Type) (a :: k) (b :: k1)
OrdGr :: gr a b -> OrdGr (gr :: k -> k1 -> Type) (a :: k) (b :: k1)
[unOrdGr] :: OrdGr (gr :: k -> k1 -> Type) (a :: k) (b :: k1) -> gr a b
instance GHC.Classes.Eq b => GHC.Classes.Eq (GHC.Data.Graph.Inductive.Graph.GroupEdges b)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Data.Graph.Inductive.Graph.LPath a)
instance (GHC.Data.Graph.Inductive.Graph.Graph gr, GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Eq (GHC.Data.Graph.Inductive.Graph.OrdGr gr a b)
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Data.Graph.Inductive.Graph.LPath a)
instance (GHC.Data.Graph.Inductive.Graph.Graph gr, GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (GHC.Data.Graph.Inductive.Graph.OrdGr gr a b)
instance GHC.Internal.Read.Read b => GHC.Internal.Read.Read (GHC.Data.Graph.Inductive.Graph.GroupEdges b)
instance forall k1 k2 (gr :: k1 -> k2 -> *) (a :: k1) (b :: k2). GHC.Internal.Read.Read (gr a b) => GHC.Internal.Read.Read (GHC.Data.Graph.Inductive.Graph.OrdGr gr a b)
instance GHC.Internal.Show.Show b => GHC.Internal.Show.Show (GHC.Data.Graph.Inductive.Graph.GroupEdges b)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Data.Graph.Inductive.Graph.LPath a)
instance forall k1 k2 (gr :: k1 -> k2 -> *) (a :: k1) (b :: k2). GHC.Internal.Show.Show (gr a b) => GHC.Internal.Show.Show (GHC.Data.Graph.Inductive.Graph.OrdGr gr a b)


-- | An efficient implementation of <a>Graph</a> using big-endian patricia
--   tree (i.e. <a>Data.IntMap</a>).
--   
--   This module provides the following specialised functions to gain more
--   performance, using GHC's RULES pragma:
--   
--   <ul>
--   <li><a>insNode</a></li>
--   <li><a>insEdge</a></li>
--   <li><a>gmap</a></li>
--   <li><a>nmap</a></li>
--   <li><a>emap</a></li>
--   </ul>
--   
--   Code is from Hackage <tt>fgl</tt> package version 5.7.0.3
module GHC.Data.Graph.Inductive.PatriciaTree
data Gr a b
type UGr = Gr () ()
instance Data.Bifunctor.Bifunctor GHC.Data.Graph.Inductive.PatriciaTree.Gr
instance GHC.Data.Graph.Inductive.Graph.DynGraph GHC.Data.Graph.Inductive.PatriciaTree.Gr
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Data.Graph.Inductive.PatriciaTree.FromListCounting a)
instance (GHC.Classes.Eq a, GHC.Classes.Ord b) => GHC.Classes.Eq (GHC.Data.Graph.Inductive.PatriciaTree.Gr a b)
instance GHC.Internal.Base.Functor (GHC.Data.Graph.Inductive.PatriciaTree.Gr a)
instance GHC.Internal.Generics.Generic (GHC.Data.Graph.Inductive.PatriciaTree.Gr a b)
instance GHC.Data.Graph.Inductive.Graph.Graph GHC.Data.Graph.Inductive.PatriciaTree.Gr
instance GHC.Internal.Read.Read a => GHC.Internal.Read.Read (GHC.Data.Graph.Inductive.PatriciaTree.FromListCounting a)
instance (GHC.Internal.Read.Read a, GHC.Internal.Read.Read b) => GHC.Internal.Read.Read (GHC.Data.Graph.Inductive.PatriciaTree.Gr a b)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Data.Graph.Inductive.PatriciaTree.FromListCounting a)
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b) => GHC.Internal.Show.Show (GHC.Data.Graph.Inductive.PatriciaTree.Gr a b)

module GHC.CmmToAsm.PPC.Cond
data Cond
ALWAYS :: Cond
EQQ :: Cond
GE :: Cond
GEU :: Cond
GTT :: Cond
GU :: Cond
LE :: Cond
LEU :: Cond
LTT :: Cond
LU :: Cond
NE :: Cond
condNegate :: Cond -> Cond
condUnsigned :: Cond -> Bool
instance GHC.Classes.Eq GHC.CmmToAsm.PPC.Cond.Cond

module GHC.CmmToAsm.CFG.Weight

-- | Edge weights to use when generating a CFG from CMM
data Weights
Weights :: Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Weights
[uncondWeight] :: Weights -> Int
[condBranchWeight] :: Weights -> Int
[switchWeight] :: Weights -> Int
[callWeight] :: Weights -> Int
[likelyCondWeight] :: Weights -> Int
[unlikelyCondWeight] :: Weights -> Int
[infoTablePenalty] :: Weights -> Int
[backEdgeBonus] :: Weights -> Int

-- | Default edge weights
defaultWeights :: Weights
parseWeights :: String -> Weights -> Weights

module GHC.Utils.Json

-- | Simple data type to represent JSON documents.
data JsonDoc
[JSNull] :: JsonDoc
[JSBool] :: Bool -> JsonDoc
[JSInt] :: Int -> JsonDoc
[JSString] :: String -> JsonDoc
[JSArray] :: [JsonDoc] -> JsonDoc
[JSObject] :: [(String, JsonDoc)] -> JsonDoc
renderJSON :: JsonDoc -> SDoc
escapeJsonString :: String -> String
class ToJson a
json :: ToJson a => a -> JsonDoc
instance GHC.Utils.Json.ToJson GHC.Types.Int
instance GHC.Utils.Json.ToJson GHC.Internal.Base.String


-- | Unit identifier pretty-printing
module GHC.Unit.Ppr

-- | Subset of UnitInfo: just enough to pretty-print a unit-id
--   
--   Instead of printing the unit-id which may contain a hash, we print:
--   package-version:componentname
data UnitPprInfo
UnitPprInfo :: FastString -> String -> Version -> Maybe String -> UnitPprInfo

-- | Identifier
[unitPprId] :: UnitPprInfo -> FastString

-- | Source package name
[unitPprPackageName] :: UnitPprInfo -> String

-- | Source package version
[unitPprPackageVersion] :: UnitPprInfo -> Version

-- | Component name
[unitPprComponentName] :: UnitPprInfo -> Maybe String
instance GHC.Utils.Outputable.Outputable GHC.Unit.Ppr.UnitPprInfo


-- | This module contains types that relate to the positions of things in
--   source files, and allow tagging of those things with locations
module GHC.Types.SrcLoc

-- | Real Source Location
--   
--   Represents a single point within a file
data RealSrcLoc

-- | Source Location
data SrcLoc
RealSrcLoc :: !RealSrcLoc -> !Maybe BufPos -> SrcLoc
UnhelpfulLoc :: !FastString -> SrcLoc
mkSrcLoc :: FastString -> Int -> Int -> SrcLoc
mkRealSrcLoc :: FastString -> Int -> Int -> RealSrcLoc

-- | Creates a "bad" <a>SrcLoc</a> that has no detailed information about
--   its location
mkGeneralSrcLoc :: FastString -> SrcLoc

-- | Indentation level is 1-indexed, so the leftmost column is 1.
leftmostColumn :: Int

-- | Built-in "bad" <a>SrcLoc</a> values for particular locations
noSrcLoc :: SrcLoc

-- | Built-in "bad" <a>SrcLoc</a> values for particular locations
generatedSrcLoc :: SrcLoc

-- | Built-in "bad" <a>SrcLoc</a> values for particular locations
interactiveSrcLoc :: SrcLoc

-- | Move the <a>SrcLoc</a> down by one line if the character is a newline,
--   to the next 8-char tabstop if it is a tab, and across by one character
--   in any other case
advanceSrcLoc :: RealSrcLoc -> Char -> RealSrcLoc
advanceBufPos :: BufPos -> BufPos

-- | Gives the filename of the <a>RealSrcLoc</a>
srcLocFile :: RealSrcLoc -> FastString

-- | Raises an error when used on a "bad" <a>SrcLoc</a>
srcLocLine :: RealSrcLoc -> Int

-- | Raises an error when used on a "bad" <a>SrcLoc</a>
srcLocCol :: RealSrcLoc -> Int

-- | A <a>RealSrcSpan</a> delimits a portion of a text file. It could be
--   represented by a pair of (line,column) coordinates, but in fact we
--   optimise slightly by using more compact representations for
--   single-line and zero-length spans, both of which are quite common.
--   
--   The end position is defined to be the column <i>after</i> the end of
--   the span. That is, a span of (1,1)-(1,2) is one character long, and a
--   span of (1,1)-(1,1) is zero characters long.
--   
--   Real Source Span
data RealSrcSpan

-- | Source Span
--   
--   A <a>SrcSpan</a> identifies either a specific portion of a text file
--   or a human-readable description of a location.
data SrcSpan
RealSrcSpan :: !RealSrcSpan -> !Maybe BufSpan -> SrcSpan
UnhelpfulSpan :: !UnhelpfulSpanReason -> SrcSpan
data UnhelpfulSpanReason
UnhelpfulNoLocationInfo :: UnhelpfulSpanReason
UnhelpfulWiredIn :: UnhelpfulSpanReason
UnhelpfulInteractive :: UnhelpfulSpanReason
UnhelpfulGenerated :: UnhelpfulSpanReason
UnhelpfulOther :: !FastString -> UnhelpfulSpanReason

-- | Create a "bad" <a>SrcSpan</a> that has not location information
mkGeneralSrcSpan :: FastString -> SrcSpan

-- | Create a <a>SrcSpan</a> between two points in a file
mkSrcSpan :: SrcLoc -> SrcLoc -> SrcSpan

-- | Create a <a>SrcSpan</a> between two points in a file
mkRealSrcSpan :: RealSrcLoc -> RealSrcLoc -> RealSrcSpan

-- | Built-in "bad" <a>SrcSpan</a>s for common sources of location
--   uncertainty
noSrcSpan :: SrcSpan

-- | Built-in "bad" <a>SrcSpan</a>s for common sources of location
--   uncertainty
generatedSrcSpan :: SrcSpan
isGeneratedSrcSpan :: SrcSpan -> Bool

-- | Built-in "bad" <a>SrcSpan</a>s for common sources of location
--   uncertainty
wiredInSrcSpan :: SrcSpan

-- | Built-in "bad" <a>SrcSpan</a>s for common sources of location
--   uncertainty
interactiveSrcSpan :: SrcSpan

-- | Create a <a>SrcSpan</a> corresponding to a single point
srcLocSpan :: SrcLoc -> SrcSpan
realSrcLocSpan :: RealSrcLoc -> RealSrcSpan

-- | Combines two <a>SrcSpan</a> into one that spans at least all the
--   characters within both spans. Returns UnhelpfulSpan if the files
--   differ.
combineSrcSpans :: SrcSpan -> SrcSpan -> SrcSpan

-- | Convert a SrcSpan into one that represents only its first character
srcSpanFirstCharacter :: SrcSpan -> SrcSpan

-- | Returns the location at the start of the <a>SrcSpan</a> or a "bad"
--   <a>SrcSpan</a> if that is unavailable
srcSpanStart :: SrcSpan -> SrcLoc

-- | Returns the location at the end of the <a>SrcSpan</a> or a "bad"
--   <a>SrcSpan</a> if that is unavailable
srcSpanEnd :: SrcSpan -> SrcLoc
realSrcSpanStart :: RealSrcSpan -> RealSrcLoc
realSrcSpanEnd :: RealSrcSpan -> RealSrcLoc

-- | Obtains the filename for a <a>SrcSpan</a> if it is "good"
srcSpanFileName_maybe :: SrcSpan -> Maybe FastString
pprUserRealSpan :: Bool -> RealSrcSpan -> SDoc
pprUnhelpfulSpanReason :: UnhelpfulSpanReason -> SDoc
pprUserSpan :: Bool -> SrcSpan -> SDoc
unhelpfulSpanFS :: UnhelpfulSpanReason -> FastString
srcSpanToRealSrcSpan :: SrcSpan -> Maybe RealSrcSpan
srcSpanFile :: RealSrcSpan -> FastString
srcSpanStartLine :: RealSrcSpan -> Int
srcSpanEndLine :: RealSrcSpan -> Int
srcSpanStartCol :: RealSrcSpan -> Int
srcSpanEndCol :: RealSrcSpan -> Int

-- | Test if a <a>SrcSpan</a> is "good", i.e. has precise location
--   information
isGoodSrcSpan :: SrcSpan -> Bool

-- | True if the span is known to straddle only one line. For "bad"
--   <a>SrcSpan</a>, it returns False
isOneLineSpan :: SrcSpan -> Bool

-- | True if the span has a width of zero, as returned for "virtual"
--   semicolons in the lexer. For "bad" <a>SrcSpan</a>, it returns False
isZeroWidthSpan :: SrcSpan -> Bool

-- | Tests whether the first span "contains" the other span, meaning that
--   it covers at least as much source code. True where spans are equal.
containsSpan :: RealSrcSpan -> RealSrcSpan -> Bool
isNoSrcSpan :: SrcSpan -> Bool

-- | <a>True</a> if the span is a single point
isPointRealSpan :: RealSrcSpan -> Bool

-- | 0-based offset identifying the raw location in the
--   <tt>StringBuffer</tt>.
--   
--   The lexer increments the <a>BufPos</a> every time a character (UTF-8
--   code point) is read from the input buffer. As UTF-8 is a
--   variable-length encoding and <tt>StringBuffer</tt> needs a byte offset
--   for indexing, a <a>BufPos</a> cannot be used for indexing.
--   
--   The parser guarantees that <a>BufPos</a> are monotonic. See #17632.
--   This means that syntactic constructs that appear later in the
--   <tt>StringBuffer</tt> are guaranteed to have a higher <a>BufPos</a>.
--   Contrast that with <a>RealSrcLoc</a>, which does *not* make the
--   analogous guarantee about higher line/column numbers.
--   
--   This is due to #line and {-# LINE ... #-} pragmas that can arbitrarily
--   modify <a>RealSrcLoc</a>. Notice how <tt>setSrcLoc</tt> and
--   <tt>resetAlrLastLoc</tt> in <a>GHC.Parser.Lexer</a> update
--   <a>PsLoc</a>, modifying <a>RealSrcLoc</a> but preserving
--   <a>BufPos</a>.
--   
--   Monotonicity makes <a>BufPos</a> useful to determine the order in
--   which syntactic elements appear in the source. Consider this example
--   (haddockA041 in the test suite):
--   
--   haddockA041.hs {-# LANGUAGE CPP #-} -- | Module header documentation
--   module Comments_and_CPP_include where #include "IncludeMe.hs"
--   
--   IncludeMe.hs: -- | Comment on T data T = MkT -- ^ Comment on MkT
--   
--   After the C preprocessor runs, the <tt>StringBuffer</tt> will contain
--   a program that looks like this (unimportant lines at the beginning
--   removed):
--   
--   # 1 "haddockA041.hs" {-# LANGUAGE CPP #-} -- | Module header
--   documentation module Comments_and_CPP_include where # 1 "IncludeMe.hs"
--   1 -- | Comment on T data T = MkT -- ^ Comment on MkT # 7
--   "haddockA041.hs" 2
--   
--   The line pragmas inserted by CPP make the error messages more
--   informative. The downside is that we can't use RealSrcLoc to determine
--   the ordering of syntactic elements.
--   
--   With RealSrcLoc, we have the following location information recorded
--   in the AST: * The module name is located at haddockA041.hs:3:8-31 *
--   The Haddock comment "Comment on T" is located at IncludeMe:1:1-17 *
--   The data declaration is located at IncludeMe.hs:2:1-32
--   
--   Is the Haddock comment located between the module name and the data
--   declaration? This is impossible to tell because the locations are not
--   comparable; they even refer to different files.
--   
--   On the other hand, with <a>BufPos</a>, we have the following location
--   information: * The module name is located at 846-870 * The Haddock
--   comment "Comment on T" is located at 898-915 * The data declaration is
--   located at 916-928
--   
--   Aside: if you're wondering why the numbers are so high, try running
--   <tt>ghc -E haddockA041.hs</tt> and see the extra fluff that CPP
--   inserts at the start of the file.
--   
--   For error messages, <a>BufPos</a> is not useful at all. On the other
--   hand, this is exactly what we need to determine the order of syntactic
--   elements: 870 &lt; 898, therefore the Haddock comment appears *after*
--   the module name. 915 &lt; 916, therefore the Haddock comment appears
--   *before* the data declaration.
--   
--   We use <a>BufPos</a> in in GHC.Parser.PostProcess.Haddock to associate
--   Haddock comments with parts of the AST using location information
--   (#17544).
newtype BufPos
BufPos :: Int -> BufPos
[bufPos] :: BufPos -> Int
getBufPos :: SrcLoc -> Maybe BufPos

-- | StringBuffer Source Span
data BufSpan
BufSpan :: {-# UNPACK #-} !BufPos -> {-# UNPACK #-} !BufPos -> BufSpan
[bufSpanStart] :: BufSpan -> {-# UNPACK #-} !BufPos
[bufSpanEnd] :: BufSpan -> {-# UNPACK #-} !BufPos
getBufSpan :: SrcSpan -> Maybe BufSpan
removeBufSpan :: SrcSpan -> SrcSpan
combineBufSpans :: BufSpan -> BufSpan -> BufSpan
type Located = GenLocated SrcSpan
type RealLocated = GenLocated RealSrcSpan

-- | We attach SrcSpans to lots of things, so let's have a datatype for it.
data GenLocated l e
L :: l -> e -> GenLocated l e
noLoc :: e -> Located e
mkGeneralLocated :: String -> e -> Located e
getLoc :: GenLocated l e -> l
unLoc :: GenLocated l e -> e
unRealSrcSpan :: RealLocated a -> a
getRealSrcSpan :: RealLocated a -> RealSrcSpan
pprLocated :: (Outputable l, Outputable e) => GenLocated l e -> SDoc

-- | Always prints the location, even without -dppr-debug
pprLocatedAlways :: (Outputable l, Outputable e) => GenLocated l e -> SDoc

-- | Tests whether the two located things are equal
eqLocated :: Eq a => GenLocated l a -> GenLocated l a -> Bool

-- | Tests the ordering of the two located things
cmpLocated :: Ord a => GenLocated l a -> GenLocated l a -> Ordering

-- | Compare the <a>BufSpan</a> of two located things.
--   
--   Precondition: both operands have an associated <a>BufSpan</a>.
cmpBufSpan :: HasDebugCallStack => Located a -> Located a -> Ordering
combineLocs :: Located a -> Located b -> SrcSpan

-- | Combine locations from two <a>Located</a> things and add them to a
--   third thing
addCLoc :: Located a -> Located b -> c -> Located c

-- | Strategies for ordering <a>SrcSpan</a>s
leftmost_smallest :: SrcSpan -> SrcSpan -> Ordering

-- | Strategies for ordering <a>SrcSpan</a>s
leftmost_largest :: SrcSpan -> SrcSpan -> Ordering

-- | Strategies for ordering <a>SrcSpan</a>s
rightmost_smallest :: SrcSpan -> SrcSpan -> Ordering

-- | Determines whether a span encloses a given line and column index
spans :: SrcSpan -> (Int, Int) -> Bool

-- | Determines whether a span is enclosed by another one
isSubspanOf :: SrcSpan -> SrcSpan -> Bool

-- | Determines whether a span is enclosed by another one
isRealSubspanOf :: RealSrcSpan -> RealSrcSpan -> Bool
sortLocated :: [Located a] -> [Located a]
sortRealLocated :: [RealLocated a] -> [RealLocated a]
lookupSrcLoc :: SrcLoc -> Map RealSrcLoc a -> Maybe a
lookupSrcSpan :: SrcSpan -> Map RealSrcSpan a -> Maybe a

-- | A location as produced by the parser. Consists of two components:
--   
--   <ul>
--   <li>The location in the file, adjusted for #line and {-# LINE ... #-}
--   pragmas (RealSrcLoc)</li>
--   <li>The location in the string buffer (BufPos) with monotonicity
--   guarantees (see #17632)</li>
--   </ul>
data PsLoc
PsLoc :: !RealSrcLoc -> !BufPos -> PsLoc
[psRealLoc] :: PsLoc -> !RealSrcLoc
[psBufPos] :: PsLoc -> !BufPos
data PsSpan
PsSpan :: !RealSrcSpan -> !BufSpan -> PsSpan
[psRealSpan] :: PsSpan -> !RealSrcSpan
[psBufSpan] :: PsSpan -> !BufSpan
type PsLocated = GenLocated PsSpan
advancePsLoc :: PsLoc -> Char -> PsLoc
mkPsSpan :: PsLoc -> PsLoc -> PsSpan
psSpanStart :: PsSpan -> PsLoc
psSpanEnd :: PsSpan -> PsLoc
mkSrcSpanPs :: PsSpan -> SrcSpan

-- | Combines two <a>SrcSpan</a> into one that spans at least all the
--   characters within both spans. Assumes the "file" part is the same in
--   both inputs
combineRealSrcSpans :: RealSrcSpan -> RealSrcSpan -> RealSrcSpan
psLocatedToLocated :: PsLocated a -> Located a

-- | The anchor for an exact print annotation. The Parser inserts the
--   <tt><a>EpaSpan</a></tt> variant, giving the exact location of the
--   original item in the parsed source. This can be replaced by the
--   <tt><a>EpaDelta</a></tt> version, to provide a position for the item
--   relative to the end of the previous item in the source. This is useful
--   when editing an AST prior to exact printing the changed one. The
--   EpaDelta also contains the original <tt><a>SrcSpan</a></tt> for use by
--   tools wanting to manipulate the AST after converting it using
--   ghc-exactprint' <tt><tt>makeDeltaAst</tt></tt>.
data EpaLocation' a
EpaSpan :: !SrcSpan -> EpaLocation' a
EpaDelta :: !SrcSpan -> !DeltaPos -> !a -> EpaLocation' a
type NoCommentsLocation = EpaLocation' NoComments
data NoComments
NoComments :: NoComments

-- | Spacing between output items when exact printing. It captures the
--   spacing from the current print position on the page to the position
--   required for the thing about to be printed. This is either on the same
--   line in which case is is simply the number of spaces to emit, or it is
--   some number of lines down, with a given column offset. The exact
--   printing algorithm keeps track of the column offset pertaining to the
--   current anchor position, so the <a>deltaColumn</a> is the additional
--   spaces to add in this case. See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/api-annotations</a> for
--   details.
data DeltaPos
SameLine :: !Int -> DeltaPos
[deltaColumn] :: DeltaPos -> !Int
DifferentLine :: !Int -> !Int -> DeltaPos

-- | deltaLine should always be &gt; 0
[deltaLine] :: DeltaPos -> !Int
[deltaColumn] :: DeltaPos -> !Int

-- | Smart constructor for a <a>DeltaPos</a>. It preserves the invariant
--   that for the <a>DifferentLine</a> constructor <a>deltaLine</a> is
--   always &gt; 0.
deltaPos :: Int -> Int -> DeltaPos
getDeltaLine :: DeltaPos -> Int
instance GHC.Internal.Data.Data.Data GHC.Types.SrcLoc.BufPos
instance GHC.Internal.Data.Data.Data GHC.Types.SrcLoc.BufSpan
instance GHC.Internal.Data.Data.Data GHC.Types.SrcLoc.DeltaPos
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Types.SrcLoc.EpaLocation' a)
instance (GHC.Internal.Data.Data.Data l, GHC.Internal.Data.Data.Data e) => GHC.Internal.Data.Data.Data (GHC.Types.SrcLoc.GenLocated l e)
instance GHC.Internal.Data.Data.Data GHC.Types.SrcLoc.NoComments
instance GHC.Internal.Data.Data.Data GHC.Types.SrcLoc.PsSpan
instance GHC.Internal.Data.Data.Data GHC.Types.SrcLoc.RealSrcSpan
instance GHC.Internal.Data.Data.Data GHC.Types.SrcLoc.SrcSpan
instance GHC.Classes.Eq GHC.Types.SrcLoc.BufPos
instance GHC.Classes.Eq GHC.Types.SrcLoc.BufSpan
instance GHC.Classes.Eq GHC.Types.SrcLoc.DeltaPos
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Types.SrcLoc.EpaLocation' a)
instance (GHC.Classes.Eq l, GHC.Classes.Eq e) => GHC.Classes.Eq (GHC.Types.SrcLoc.GenLocated l e)
instance GHC.Classes.Eq GHC.Types.SrcLoc.NoComments
instance GHC.Classes.Eq GHC.Types.SrcLoc.PsLoc
instance GHC.Classes.Eq GHC.Types.SrcLoc.PsSpan
instance GHC.Classes.Eq GHC.Types.SrcLoc.RealSrcLoc
instance GHC.Classes.Eq GHC.Types.SrcLoc.RealSrcSpan
instance GHC.Classes.Eq GHC.Types.SrcLoc.SrcLoc
instance GHC.Classes.Eq GHC.Types.SrcLoc.SrcSpan
instance GHC.Classes.Eq GHC.Types.SrcLoc.UnhelpfulSpanReason
instance GHC.Internal.Data.Foldable.Foldable (GHC.Types.SrcLoc.GenLocated l)
instance GHC.Internal.Base.Functor (GHC.Types.SrcLoc.GenLocated l)
instance (Control.DeepSeq.NFData l, Control.DeepSeq.NFData e) => Control.DeepSeq.NFData (GHC.Types.SrcLoc.GenLocated l e)
instance Control.DeepSeq.NFData GHC.Types.SrcLoc.SrcSpan
instance GHC.Classes.Ord GHC.Types.SrcLoc.BufPos
instance GHC.Classes.Ord GHC.Types.SrcLoc.BufSpan
instance GHC.Classes.Ord GHC.Types.SrcLoc.DeltaPos
instance (GHC.Classes.Ord l, GHC.Classes.Ord e) => GHC.Classes.Ord (GHC.Types.SrcLoc.GenLocated l e)
instance GHC.Classes.Ord GHC.Types.SrcLoc.NoComments
instance GHC.Classes.Ord GHC.Types.SrcLoc.PsLoc
instance GHC.Classes.Ord GHC.Types.SrcLoc.PsSpan
instance GHC.Classes.Ord GHC.Types.SrcLoc.RealSrcLoc
instance GHC.Classes.Ord GHC.Types.SrcLoc.RealSrcSpan
instance GHC.Utils.Outputable.Outputable GHC.Types.SrcLoc.DeltaPos
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Types.SrcLoc.EpaLocation' a)
instance GHC.Utils.Outputable.Outputable e => GHC.Utils.Outputable.Outputable (GHC.Types.SrcLoc.Located e)
instance GHC.Utils.Outputable.Outputable e => GHC.Utils.Outputable.Outputable (GHC.Types.SrcLoc.GenLocated GHC.Types.SrcLoc.RealSrcSpan e)
instance GHC.Utils.Outputable.Outputable GHC.Types.SrcLoc.NoComments
instance GHC.Utils.Outputable.Outputable GHC.Types.SrcLoc.RealSrcLoc
instance GHC.Utils.Outputable.Outputable GHC.Types.SrcLoc.RealSrcSpan
instance GHC.Utils.Outputable.Outputable GHC.Types.SrcLoc.SrcLoc
instance GHC.Utils.Outputable.Outputable GHC.Types.SrcLoc.SrcSpan
instance GHC.Utils.Outputable.Outputable GHC.Types.SrcLoc.UnhelpfulSpanReason
instance GHC.Internal.Base.Semigroup GHC.Types.SrcLoc.BufSpan
instance GHC.Internal.Show.Show GHC.Types.SrcLoc.BufPos
instance GHC.Internal.Show.Show GHC.Types.SrcLoc.BufSpan
instance GHC.Internal.Show.Show GHC.Types.SrcLoc.DeltaPos
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Types.SrcLoc.EpaLocation' a)
instance (GHC.Internal.Show.Show l, GHC.Internal.Show.Show e) => GHC.Internal.Show.Show (GHC.Types.SrcLoc.GenLocated l e)
instance GHC.Internal.Show.Show GHC.Types.SrcLoc.NoComments
instance GHC.Internal.Show.Show GHC.Types.SrcLoc.PsLoc
instance GHC.Internal.Show.Show GHC.Types.SrcLoc.PsSpan
instance GHC.Internal.Show.Show GHC.Types.SrcLoc.RealSrcLoc
instance GHC.Internal.Show.Show GHC.Types.SrcLoc.RealSrcSpan
instance GHC.Internal.Show.Show GHC.Types.SrcLoc.SrcLoc
instance GHC.Internal.Show.Show GHC.Types.SrcLoc.SrcSpan
instance GHC.Internal.Show.Show GHC.Types.SrcLoc.UnhelpfulSpanReason
instance GHC.Utils.Json.ToJson GHC.Types.SrcLoc.RealSrcSpan
instance GHC.Utils.Json.ToJson GHC.Types.SrcLoc.SrcSpan
instance GHC.Internal.Data.Traversable.Traversable (GHC.Types.SrcLoc.GenLocated l)

module GHC.Tc.Types.Rank
data Rank
ArbitraryRank :: Rank
LimitedRank :: Bool -> Rank -> Rank
MonoTypeRankZero :: Rank
MonoTypeTyConArg :: Rank
MonoTypeSynArg :: Rank
MonoTypeConstraint :: Rank
MustBeMonoType :: Rank
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Rank.Rank

module GHC.Parser.Errors.Basic

-- | The operator symbol in the
--   <tt>PsOperatorWhitespaceExtConflictMessage</tt> diagnostic.
data OperatorWhitespaceSymbol
OperatorWhitespaceSymbol_PrefixPercent :: OperatorWhitespaceSymbol
OperatorWhitespaceSymbol_PrefixDollar :: OperatorWhitespaceSymbol
OperatorWhitespaceSymbol_PrefixDollarDollar :: OperatorWhitespaceSymbol
pprOperatorWhitespaceSymbol :: OperatorWhitespaceSymbol -> SDoc

-- | The operator occurrence type in the
--   <tt>PsOperatorWhitespaceMessage</tt> diagnostic.
data OperatorWhitespaceOccurrence
OperatorWhitespaceOccurrence_Prefix :: OperatorWhitespaceOccurrence
OperatorWhitespaceOccurrence_Suffix :: OperatorWhitespaceOccurrence
OperatorWhitespaceOccurrence_TightInfix :: OperatorWhitespaceOccurrence

module GHC.Data.Pair
data Pair a
Pair :: a -> a -> Pair a
[pFst] :: Pair a -> a
[pSnd] :: Pair a -> a
unPair :: Pair a -> (a, a)
toPair :: (a, a) -> Pair a
swap :: Pair a -> Pair a
pLiftFst :: (a -> a) -> Pair a -> Pair a
pLiftSnd :: (a -> a) -> Pair a -> Pair a
unzipPairs :: [Pair a] -> ([a], [a])
instance GHC.Internal.Base.Applicative GHC.Data.Pair.Pair
instance GHC.Internal.Data.Foldable.Foldable GHC.Data.Pair.Pair
instance GHC.Internal.Base.Functor GHC.Data.Pair.Pair
instance (GHC.Internal.Base.Semigroup a, GHC.Internal.Base.Monoid a) => GHC.Internal.Base.Monoid (GHC.Data.Pair.Pair a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Data.Pair.Pair a)
instance GHC.Internal.Base.Semigroup a => GHC.Internal.Base.Semigroup (GHC.Data.Pair.Pair a)
instance GHC.Internal.Data.Traversable.Traversable GHC.Data.Pair.Pair


-- | Provide trees (of instructions), so that lists of instructions can be
--   appended in linear time.
module GHC.Data.OrdList
data OrdList a
pattern NilOL :: OrdList a
pattern ConsOL :: a -> OrdList a -> OrdList a
pattern SnocOL :: OrdList a -> a -> OrdList a
nilOL :: OrdList a
isNilOL :: OrdList a -> Bool
unitOL :: a -> OrdList a
appOL :: OrdList a -> OrdList a -> OrdList a
infixl 5 `appOL`
consOL :: a -> OrdList a -> OrdList a
infixr 5 `consOL`
snocOL :: OrdList a -> a -> OrdList a
infixl 5 `snocOL`
concatOL :: [OrdList a] -> OrdList a
lastOL :: OrdList a -> a
headOL :: OrdList a -> a
mapOL :: (a -> b) -> OrdList a -> OrdList b
mapOL' :: (a -> b) -> OrdList a -> OrdList b
fromOL :: OrdList a -> [a]
toOL :: [a] -> OrdList a
foldrOL :: (a -> b -> b) -> b -> OrdList a -> b

-- | Strict left fold.
foldlOL :: (b -> a -> b) -> b -> OrdList a -> b
partitionOL :: (a -> Bool) -> OrdList a -> (OrdList a, OrdList a)
reverseOL :: OrdList a -> OrdList a
fromOLReverse :: OrdList a -> [a]

-- | Compare not only the values but also the structure of two lists
strictlyEqOL :: Eq a => OrdList a -> OrdList a -> Bool

-- | Compare not only the values but also the structure of two lists
strictlyOrdOL :: Ord a => OrdList a -> OrdList a -> Ordering
instance GHC.Internal.Data.Foldable.Foldable GHC.Data.OrdList.OrdList
instance GHC.Internal.Base.Functor GHC.Data.OrdList.OrdList
instance GHC.Internal.Base.Monoid (GHC.Data.OrdList.OrdList a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Data.OrdList.OrdList a)
instance GHC.Internal.Base.Semigroup (GHC.Data.OrdList.OrdList a)
instance GHC.Internal.Data.Traversable.Traversable GHC.Data.OrdList.OrdList


-- | Implementation of a jobserver using system semaphores.
module GHC.Driver.MakeSem

-- | Implement an abstract semaphore using a semaphore <a>Jobserver</a>
--   which queries the system semaphore of the given name for resources.
runJSemAbstractSem :: SemaphoreName -> (AbstractSem -> IO a) -> IO a

-- | A system semaphore (POSIX or Win32).
data Semaphore
newtype SemaphoreName
SemaphoreName :: String -> SemaphoreName
[getSemaphoreName] :: SemaphoreName -> String

-- | Abstraction over the operations of a semaphore.
data AbstractSem
AbstractSem :: IO () -> IO () -> AbstractSem
[acquireSem] :: AbstractSem -> IO ()
[releaseSem] :: AbstractSem -> IO ()
withAbstractSem :: AbstractSem -> IO b -> IO b
instance GHC.Utils.Outputable.Outputable GHC.Driver.MakeSem.JobResources


-- | Set-like operations on lists
--   
--   Avoid using them as much as possible
module GHC.Data.List.SetOps

-- | Assumes that the arguments contain no duplicates
unionLists :: (HasDebugCallStack, Outputable a, Eq a) => [a] -> [a] -> [a]

-- | Combines the two lists while keeping their order, placing the first
--   argument first in the result.
--   
--   Uses a set internally to record duplicates. This makes it slightly
--   slower for very small lists but avoids quadratic behaviour for large
--   lists.
unionListsOrd :: (HasDebugCallStack, Outputable a, Ord a) => [a] -> [a] -> [a]

-- | Calculate the set difference of two lists. This is <i>O((m + n) log
--   n)</i>, where we subtract a list of <i>n</i> elements from a list of
--   <i>m</i> elements.
--   
--   Extremely short cases are handled specially: When <i>m</i> or <i>n</i>
--   is 0, this takes <i>O(1)</i> time. When <i>m</i> is 1, it takes
--   <i>O(n)</i> time.
minusList :: Ord a => [a] -> [a] -> [a]

-- | A finite mapping based on equality and association lists.
type Assoc a b = [(a, b)]
assoc :: Eq a => String -> Assoc a b -> a -> b

-- | Lookup key, fail gracefully using Nothing if not found.
assocMaybe :: Eq a => Assoc a b -> a -> Maybe b
assocUsing :: (a -> a -> Bool) -> String -> Assoc a b -> a -> b
assocDefault :: Eq a => b -> Assoc a b -> a -> b
assocDefaultUsing :: (a -> a -> Bool) -> b -> Assoc a b -> a -> b
hasNoDups :: Eq a => [a] -> Bool

-- | Remove the duplicates from a list using the provided comparison
--   function. Might change the order of elements.
--   
--   Returns the list without duplicates, and accumulates all the
--   duplicates in the second component of its result.
removeDups :: (a -> a -> Ordering) -> [a] -> ([a], [NonEmpty a])
removeDupsOn :: Ord b => (a -> b) -> [a] -> ([a], [NonEmpty a])

-- | Remove the duplicates from a list using the provided comparison
--   function.
nubOrdBy :: (a -> a -> Ordering) -> [a] -> [a]
findDupsEq :: (a -> a -> Bool) -> [a] -> [NonEmpty a]
equivClasses :: (a -> a -> Ordering) -> [a] -> [NonEmpty a]
getNth :: Outputable a => [a] -> Int -> a
isIn :: Eq a => String -> a -> [a] -> Bool
isn'tIn :: Eq a => String -> a -> [a] -> Bool

module GHC.Data.Bag
data Bag a
emptyBag :: Bag a
unitBag :: a -> Bag a
unionBags :: Bag a -> Bag a -> Bag a
unionManyBags :: [Bag a] -> Bag a
mapBag :: (a -> b) -> Bag a -> Bag b
pprBag :: Outputable a => Bag a -> SDoc
elemBag :: Eq a => a -> Bag a -> Bool
lengthBag :: Bag a -> Int
filterBag :: (a -> Bool) -> Bag a -> Bag a
partitionBag :: (a -> Bool) -> Bag a -> (Bag a, Bag a)
partitionBagWith :: (a -> Either b c) -> Bag a -> (Bag b, Bag c)
concatBag :: Bag (Bag a) -> Bag a
catBagMaybes :: Bag (Maybe a) -> Bag a
foldBag :: (r -> r -> r) -> (a -> r) -> r -> Bag a -> r
isEmptyBag :: Bag a -> Bool
isSingletonBag :: Bag a -> Bool
consBag :: a -> Bag a -> Bag a
infixr 3 `consBag`
snocBag :: Bag a -> a -> Bag a
infixl 3 `snocBag`
anyBag :: (a -> Bool) -> Bag a -> Bool
allBag :: (a -> Bool) -> Bag a -> Bool
listToBag :: [a] -> Bag a
nonEmptyToBag :: NonEmpty a -> Bag a
bagToList :: Bag a -> [a]
headMaybe :: Bag a -> Maybe a
mapAccumBagL :: (acc -> x -> (acc, y)) -> acc -> Bag x -> (acc, Bag y)
concatMapBag :: (a -> Bag b) -> Bag a -> Bag b
concatMapBagPair :: (a -> (Bag b, Bag c)) -> Bag a -> (Bag b, Bag c)
mapMaybeBag :: (a -> Maybe b) -> Bag a -> Bag b
mapMaybeBagM :: Monad m => (a -> m (Maybe b)) -> Bag a -> m (Bag b)
unzipBag :: Bag (a, b) -> (Bag a, Bag b)
mapBagM :: Monad m => (a -> m b) -> Bag a -> m (Bag b)
mapBagM_ :: Monad m => (a -> m b) -> Bag a -> m ()
lookupBag :: Eq a => a -> Bag (a, b) -> Maybe b
flatMapBagM :: Monad m => (a -> m (Bag b)) -> Bag a -> m (Bag b)
flatMapBagPairM :: Monad m => (a -> m (Bag b, Bag c)) -> Bag a -> m (Bag b, Bag c)
mapAndUnzipBagM :: Monad m => (a -> m (b, c)) -> Bag a -> m (Bag b, Bag c)
mapAccumBagLM :: Monad m => (acc -> x -> m (acc, y)) -> acc -> Bag x -> m (acc, Bag y)
anyBagM :: Monad m => (a -> m Bool) -> Bag a -> m Bool
filterBagM :: Monad m => (a -> m Bool) -> Bag a -> m (Bag a)
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Data.Bag.Bag a)
instance GHC.Internal.Data.Foldable.Foldable GHC.Data.Bag.Bag
instance GHC.Internal.Base.Functor GHC.Data.Bag.Bag
instance GHC.Internal.IsList.IsList (GHC.Data.Bag.Bag a)
instance GHC.Internal.Base.Monoid (GHC.Data.Bag.Bag a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Data.Bag.Bag a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Data.Bag.Bag a)
instance GHC.Internal.Base.Semigroup (GHC.Data.Bag.Bag a)
instance GHC.Internal.Data.Traversable.Traversable GHC.Data.Bag.Bag

module GHC.Types.Unique

-- | Unique identifier.
--   
--   The type of unique identifiers that are used in many places in GHC for
--   fast ordering and equality tests. You should generate these with the
--   functions from the <tt>UniqSupply</tt> module
--   
--   These are sometimes also referred to as "keys" in comments in GHC.
data Unique

-- | Class of things that we can obtain a <a>Unique</a> from
class Uniquable a
getUnique :: Uniquable a => a -> Unique
uNIQUE_BITS :: Int
hasKey :: Uniquable a => a -> Unique -> Bool
pprUniqueAlways :: IsLine doc => Unique -> doc

-- | Put the character in the highest bits of the Word64. This may truncate
--   the character to 8. This function is used in
--   <tt><tt>mkSplitUniqSupply</tt></tt> so that it can precompute and
--   share the tag part of the uniques it generates.
mkTag :: Char -> Word64
mkUniqueGrimily :: Word64 -> Unique
mkUniqueIntGrimily :: Int -> Unique
getKey :: Unique -> Word64
mkUnique :: Char -> Word64 -> Unique
unpkUnique :: Unique -> (Char, Word64)
mkUniqueInt :: Char -> Int -> Unique
eqUnique :: Unique -> Unique -> Bool
ltUnique :: Unique -> Unique -> Bool
incrUnique :: Unique -> Unique
stepUnique :: Unique -> Word64 -> Unique
newTagUnique :: Unique -> Char -> Unique
nonDetCmpUnique :: Unique -> Unique -> Ordering

-- | The interface file symbol-table encoding assumes that known-key
--   uniques fit in 30-bits; verify this.
--   
--   See Note [Symbol table representation of names] in
--   <a>GHC.Iface.Binary</a> for details.
isValidKnownKeyUnique :: Unique -> Bool
mkLocalUnique :: Word64 -> Unique
minLocalUnique :: Unique
maxLocalUnique :: Unique
instance GHC.Classes.Eq GHC.Types.Unique.Unique
instance GHC.Utils.Outputable.Outputable GHC.Types.Unique.Unique
instance GHC.Internal.Show.Show GHC.Types.Unique.Unique
instance GHC.Types.Unique.Uniquable GHC.Data.FastString.FastString
instance GHC.Types.Unique.Uniquable GHC.Types.Int
instance GHC.Types.Unique.Uniquable Language.Haskell.Syntax.Module.Name.ModuleName
instance GHC.Types.Unique.Uniquable GHC.Types.Unique.Unique
instance GHC.Types.Unique.Uniquable GHC.Internal.Word.Word64

module GHC.Utils.Unique
sameUnique :: Uniquable a => a -> a -> Bool
anyOfUnique :: Uniquable a => a -> [Unique] -> Bool

module GHC.Types.Unique.Supply

-- | Unique Supply
--   
--   A value of type <a>UniqSupply</a> is unique, and it can supply
--   <i>one</i> distinct <a>Unique</a>. Also, from the supply, one can also
--   manufacture an arbitrary number of further <tt>UniqueSupply</tt>
--   values, which will be distinct from the first and from all others.
data UniqSupply

-- | Obtain the <a>Unique</a> from this particular <a>UniqSupply</a>
uniqFromSupply :: UniqSupply -> Unique

-- | Obtain an infinite list of <a>Unique</a> that can be generated by
--   constant splitting of the supply
uniqsFromSupply :: UniqSupply -> [Unique]

-- | Obtain the <a>Unique</a> from this particular <a>UniqSupply</a>, and a
--   new supply
takeUniqFromSupply :: UniqSupply -> (Unique, UniqSupply)
uniqFromTag :: Char -> IO Unique

-- | Create a unique supply out of thin air. The "tag" (Char) supplied is
--   mostly cosmetic, making it easier to figure out where a Unique was
--   born. See Note [Uniques and tags].
--   
--   The payload part of the Uniques allocated from this UniqSupply are
--   guaranteed distinct wrt all other supplies, regardless of their "tag".
--   This is achieved by allocating the payload part from a single source
--   of Uniques, namely <a>genSym</a>, shared across all UniqSupply's.
mkSplitUniqSupply :: Char -> IO UniqSupply

-- | Build two <a>UniqSupply</a> from a single one, each of which can
--   supply its own <a>Unique</a>.
splitUniqSupply :: UniqSupply -> (UniqSupply, UniqSupply)

-- | Create an infinite list of <a>UniqSupply</a> from a single one
listSplitUniqSupply :: UniqSupply -> [UniqSupply]

-- | A monad which just gives the ability to obtain <a>Unique</a>s
data UniqSM result

-- | A monad for generating unique identifiers
class Monad m => MonadUnique (m :: Type -> Type)

-- | Get a new UniqueSupply
getUniqueSupplyM :: MonadUnique m => m UniqSupply

-- | Get a new unique identifier
getUniqueM :: MonadUnique m => m Unique

-- | Get an infinite list of new unique identifiers
getUniquesM :: MonadUnique m => m [Unique]

-- | Run the <a>UniqSM</a> action, returning the final <a>UniqSupply</a>
initUs :: UniqSupply -> UniqSM a -> (a, UniqSupply)

-- | Run the <a>UniqSM</a> action, discarding the final <a>UniqSupply</a>
initUs_ :: UniqSupply -> UniqSM a -> a
initUniqSupply :: Word64 -> Int -> IO ()
instance GHC.Internal.Base.Applicative GHC.Types.Unique.Supply.UniqSM
instance GHC.Internal.Base.Functor GHC.Types.Unique.Supply.UniqSM
instance GHC.Internal.Control.Monad.Fail.MonadFail GHC.Types.Unique.Supply.UniqSM
instance GHC.Internal.Control.Monad.Fix.MonadFix GHC.Types.Unique.Supply.UniqSM
instance GHC.Internal.Base.Monad GHC.Types.Unique.Supply.UniqSM
instance GHC.Types.Unique.Supply.MonadUnique GHC.Types.Unique.Supply.UniqSM

module GHC.Types.Unique.FM

-- | A finite map from <tt>uniques</tt> of one type to elements in another
--   type.
--   
--   The key is just here to keep us honest. It's always safe to use a
--   single type as key. If two types don't overlap in their uniques it's
--   also safe to index the same map at multiple key types. But this is
--   very much discouraged.
data UniqFM (key :: k) ele

-- | A wrapper around <a>UniqFM</a> with the sole purpose of informing call
--   sites that the provided <a>Foldable</a> and <a>Traversable</a>
--   instances are nondeterministic. If you use this please provide a
--   justification why it doesn't introduce nondeterminism. See Note
--   [Deterministic UniqFM] in <a>GHC.Types.Unique.DFM</a> to learn about
--   determinism.
newtype NonDetUniqFM (key :: k) ele
NonDetUniqFM :: UniqFM key ele -> NonDetUniqFM (key :: k) ele
[getNonDet] :: NonDetUniqFM (key :: k) ele -> UniqFM key ele
emptyUFM :: forall {k} (key :: k) elt. UniqFM key elt
unitUFM :: Uniquable key => key -> elt -> UniqFM key elt
unitDirectlyUFM :: forall {k} elt (key :: k). Unique -> elt -> UniqFM key elt
zipToUFM :: Uniquable key => [key] -> [elt] -> UniqFM key elt
listToUFM :: Uniquable key => [(key, elt)] -> UniqFM key elt
listToUFM_Directly :: forall {k} elt (key :: k). [(Unique, elt)] -> UniqFM key elt
listToUFM_C :: Uniquable key => (elt -> elt -> elt) -> [(key, elt)] -> UniqFM key elt
listToIdentityUFM :: Uniquable key => [key] -> UniqFM key key
addToUFM :: Uniquable key => UniqFM key elt -> key -> elt -> UniqFM key elt
addToUFM_C :: Uniquable key => (elt -> elt -> elt) -> UniqFM key elt -> key -> elt -> UniqFM key elt
addToUFM_Acc :: Uniquable key => (elt -> elts -> elts) -> (elt -> elts) -> UniqFM key elts -> key -> elt -> UniqFM key elts

-- | Add an element, returns previous lookup result and new map. If old
--   element doesn't exist, add the passed element directly, otherwise
--   compute the element to add using the passed function.
addToUFM_L :: Uniquable key => (key -> elt -> elt -> elt) -> key -> elt -> UniqFM key elt -> (Maybe elt, UniqFM key elt)
addListToUFM :: Uniquable key => UniqFM key elt -> [(key, elt)] -> UniqFM key elt

-- | Add elements to the map, combining existing values with inserted ones
--   using the given function.
addListToUFM_C :: Uniquable key => (elt -> elt -> elt) -> UniqFM key elt -> [(key, elt)] -> UniqFM key elt
addToUFM_Directly :: forall {k} (key :: k) elt. UniqFM key elt -> Unique -> elt -> UniqFM key elt
addListToUFM_Directly :: forall {k} (key :: k) elt. UniqFM key elt -> [(Unique, elt)] -> UniqFM key elt
adjustUFM :: Uniquable key => (elt -> elt) -> UniqFM key elt -> key -> UniqFM key elt
alterUFM :: Uniquable key => (Maybe elt -> Maybe elt) -> UniqFM key elt -> key -> UniqFM key elt
alterUFM_Directly :: forall {k} elt (key :: k). (Maybe elt -> Maybe elt) -> UniqFM key elt -> Unique -> UniqFM key elt
adjustUFM_Directly :: forall {k} elt (key :: k). (elt -> elt) -> UniqFM key elt -> Unique -> UniqFM key elt
delFromUFM :: Uniquable key => UniqFM key elt -> key -> UniqFM key elt
delFromUFM_Directly :: forall {k} (key :: k) elt. UniqFM key elt -> Unique -> UniqFM key elt
delListFromUFM :: Uniquable key => UniqFM key elt -> [key] -> UniqFM key elt
delListFromUFM_Directly :: forall {k} (key :: k) elt. UniqFM key elt -> [Unique] -> UniqFM key elt
plusUFM :: forall {k} (key :: k) elt. UniqFM key elt -> UniqFM key elt -> UniqFM key elt
plusUFM_C :: forall {k} elt (key :: k). (elt -> elt -> elt) -> UniqFM key elt -> UniqFM key elt -> UniqFM key elt

-- | `plusUFM_CD f m1 d1 m2 d2` merges the maps using <tt>f</tt> as the
--   combinding function and <tt>d1</tt> resp. <tt>d2</tt> as the default
--   value if there is no entry in <tt>m1</tt> reps. <tt>m2</tt>. The
--   domain is the union of the domains of <tt>m1</tt> and <tt>m2</tt>.
--   
--   IMPORTANT NOTE: This function strictly applies the modification
--   function and forces the result unlike most the other functions in this
--   module.
--   
--   Representative example:
--   
--   <pre>
--   plusUFM_CD f {A: 1, B: 2} 23 {B: 3, C: 4} 42
--      == {A: f 1 42, B: f 2 3, C: f 23 4 }
--   </pre>
plusUFM_CD :: forall {k} elta eltb eltc (key :: k). (elta -> eltb -> eltc) -> UniqFM key elta -> elta -> UniqFM key eltb -> eltb -> UniqFM key eltc

-- | `plusUFM_CD2 f m1 m2` merges the maps using <tt>f</tt> as the
--   combining function. Unlike <a>plusUFM_CD</a>, a missing value is not
--   defaulted: it is instead passed as <a>Nothing</a> to <tt>f</tt>.
--   <tt>f</tt> can never have both its arguments be <a>Nothing</a>.
--   
--   IMPORTANT NOTE: This function strictly applies the modification
--   function and forces the result.
--   
--   `plusUFM_CD2 f m1 m2` is the same as `plusUFM_CD f (mapUFM Just m1)
--   Nothing (mapUFM Just m2) Nothing`.
plusUFM_CD2 :: forall {k} elta eltb eltc (key :: k). (Maybe elta -> Maybe eltb -> eltc) -> UniqFM key elta -> UniqFM key eltb -> UniqFM key eltc
mergeUFM :: forall {k} elta eltb eltc (key :: k). (elta -> eltb -> Maybe eltc) -> (UniqFM key elta -> UniqFM key eltc) -> (UniqFM key eltb -> UniqFM key eltc) -> UniqFM key elta -> UniqFM key eltb -> UniqFM key eltc
plusMaybeUFM_C :: forall {k} elt (key :: k). (elt -> elt -> Maybe elt) -> UniqFM key elt -> UniqFM key elt -> UniqFM key elt
plusUFMList :: forall {k} (key :: k) elt. [UniqFM key elt] -> UniqFM key elt
plusUFMListWith :: forall {k} elt (key :: k). (elt -> elt -> elt) -> [UniqFM key elt] -> UniqFM key elt
sequenceUFMList :: forall {k} (key :: k) elt. [UniqFM key elt] -> UniqFM key [elt]
minusUFM :: forall {k} (key :: k) elt1 elt2. UniqFM key elt1 -> UniqFM key elt2 -> UniqFM key elt1

-- | <tt>minusUFC_C f map1 map2</tt> returns <tt>map1</tt>, except that
--   every mapping <tt>key |-&gt; value1</tt> in <tt>map1</tt> that shares
--   a key with a mapping <tt>key |-&gt; value2</tt> in <tt>map2</tt> is
--   altered by <tt>f</tt>: <tt>value1</tt> is replaced by <tt>f value1
--   value2</tt>, where <a>Just</a> means that the new value is used and
--   <a>Nothing</a> means that the mapping is deleted.
minusUFM_C :: forall {k} elt1 elt2 (key :: k). (elt1 -> elt2 -> Maybe elt1) -> UniqFM key elt1 -> UniqFM key elt2 -> UniqFM key elt1
intersectUFM :: forall {k} (key :: k) elt1 elt2. UniqFM key elt1 -> UniqFM key elt2 -> UniqFM key elt1
intersectUFM_C :: forall {k} elt1 elt2 elt3 (key :: k). (elt1 -> elt2 -> elt3) -> UniqFM key elt1 -> UniqFM key elt2 -> UniqFM key elt3
disjointUFM :: forall {k} (key :: k) elt1 elt2. UniqFM key elt1 -> UniqFM key elt2 -> Bool
equalKeysUFM :: forall {k} (key :: k) a b. UniqFM key a -> UniqFM key b -> Bool

-- | Computes the diff of two <a>UniqFM</a>s in terms of <a>Edit</a>s.
--   Equal points will not be present in the result map at all.
diffUFM :: forall {k} a (key :: k). Eq a => UniqFM key a -> UniqFM key a -> UniqFM key (Edit a)
nonDetStrictFoldUFM :: forall {k} elt a (key :: k). (elt -> a -> a) -> a -> UniqFM key elt -> a

-- | Fold over a <a>UniqFM</a>.
--   
--   Non-deterministic, unless the folding function is commutative (i.e.
--   <tt>a1 <tt>f</tt> ( a2 <tt>f</tt> b ) == a2 <tt>f</tt> ( a1 <tt>f</tt>
--   b )</tt> for all <tt>a1</tt>, <tt>a2</tt>, <tt>b</tt>).
nonDetFoldUFM :: forall {k} elt a (key :: k). (elt -> a -> a) -> a -> UniqFM key elt -> a

-- | In essence foldM See Note [Deterministic UniqFM] to learn about
--   nondeterminism. If you use this please provide a justification why it
--   doesn't introduce nondeterminism.
nonDetStrictFoldUFM_DirectlyM :: forall {k} m b elt (key :: k). Monad m => (Unique -> b -> elt -> m b) -> b -> UniqFM key elt -> m b

-- | Like <a>nonDetFoldUFM</a>, but with the <a>Unique</a> key as well.
nonDetFoldWithKeyUFM :: forall {k} elt a (key :: k). (Unique -> elt -> a -> a) -> a -> UniqFM key elt -> a
nonDetStrictFoldUFM_Directly :: forall {k} elt a (key :: k). (Unique -> elt -> a -> a) -> a -> UniqFM key elt -> a
anyUFM :: forall {k} elt (key :: k). (elt -> Bool) -> UniqFM key elt -> Bool
allUFM :: forall {k} elt (key :: k). (elt -> Bool) -> UniqFM key elt -> Bool
seqEltsUFM :: forall {k} elt (key :: k). (elt -> ()) -> UniqFM key elt -> ()
mapUFM :: forall {k} elt1 elt2 (key :: k). (elt1 -> elt2) -> UniqFM key elt1 -> UniqFM key elt2
mapUFM_Directly :: forall {k} elt1 elt2 (key :: k). (Unique -> elt1 -> elt2) -> UniqFM key elt1 -> UniqFM key elt2
strictMapUFM :: forall {k1} a b (k2 :: k1). (a -> b) -> UniqFM k2 a -> UniqFM k2 b
mapMaybeUFM :: forall {k} elt1 elt2 (key :: k). (elt1 -> Maybe elt2) -> UniqFM key elt1 -> UniqFM key elt2

-- | Like <a>mapMaybe</a>, but you must ensure the passed-in function does
--   not modify the unique.
mapMaybeUFM_sameUnique :: forall {k1} {k2} elt1 elt2 (key1 :: k1) (key2 :: k2). (elt1 -> Maybe elt2) -> UniqFM key1 elt1 -> UniqFM key2 elt2
mapMaybeWithKeyUFM :: forall {k} elt1 elt2 (key :: k). (Unique -> elt1 -> Maybe elt2) -> UniqFM key elt1 -> UniqFM key elt2
elemUFM :: Uniquable key => key -> UniqFM key elt -> Bool
elemUFM_Directly :: forall {k} (key :: k) elt. Unique -> UniqFM key elt -> Bool
filterUFM :: forall {k} elt (key :: k). (elt -> Bool) -> UniqFM key elt -> UniqFM key elt
filterUFM_Directly :: forall {k} elt (key :: k). (Unique -> elt -> Bool) -> UniqFM key elt -> UniqFM key elt
partitionUFM :: forall {k} elt (key :: k). (elt -> Bool) -> UniqFM key elt -> (UniqFM key elt, UniqFM key elt)
sizeUFM :: forall {k} (key :: k) elt. UniqFM key elt -> Int
isNullUFM :: forall {k} (key :: k) elt. UniqFM key elt -> Bool
lookupUFM :: Uniquable key => UniqFM key elt -> key -> Maybe elt
lookupUFM_Directly :: forall {k} (key :: k) elt. UniqFM key elt -> Unique -> Maybe elt
lookupWithDefaultUFM :: Uniquable key => UniqFM key elt -> elt -> key -> elt
lookupWithDefaultUFM_Directly :: forall {k} (key :: k) elt. UniqFM key elt -> elt -> Unique -> elt
nonDetEltsUFM :: forall {k} (key :: k) elt. UniqFM key elt -> [elt]
nonDetKeysUFM :: forall {k} (key :: k) elt. UniqFM key elt -> [Unique]
ufmToSet_Directly :: forall {k} (key :: k) elt. UniqFM key elt -> Word64Set
nonDetUFMToList :: forall {k} (key :: k) elt. UniqFM key elt -> [(Unique, elt)]
ufmToIntMap :: forall {k} (key :: k) elt. UniqFM key elt -> Word64Map elt
unsafeIntMapToUFM :: forall {k} elt (key :: k). Word64Map elt -> UniqFM key elt

-- | Cast the key domain of a UniqFM.
--   
--   As long as the domains don't overlap in their uniques this is safe.
unsafeCastUFMKey :: forall {k1} {k2} (key1 :: k1) elt (key2 :: k2). UniqFM key1 elt -> UniqFM key2 elt
pprUniqFM :: forall {k} a (key :: k). (a -> SDoc) -> UniqFM key a -> SDoc

-- | Pretty-print a non-deterministic set. The order of variables is
--   non-deterministic and for pretty-printing that shouldn't be a problem.
--   Having this function helps contain the non-determinism created with
--   nonDetEltsUFM.
pprUFM :: forall {k} (key :: k) a. UniqFM key a -> ([a] -> SDoc) -> SDoc

-- | Pretty-print a non-deterministic set. The order of variables is
--   non-deterministic and for pretty-printing that shouldn't be a problem.
--   Having this function helps contain the non-determinism created with
--   nonDetUFMToList.
pprUFMWithKeys :: forall {k} (key :: k) a. UniqFM key a -> ([(Unique, a)] -> SDoc) -> SDoc

-- | Determines the pluralisation suffix appropriate for the length of a
--   set in the same way that plural from Outputable does for lists.
pluralUFM :: forall {k} (key :: k) a. UniqFM key a -> SDoc
instance forall k (key :: k) ele. (GHC.Internal.Data.Typeable.Internal.Typeable key, GHC.Internal.Data.Typeable.Internal.Typeable k, GHC.Internal.Data.Data.Data ele) => GHC.Internal.Data.Data.Data (GHC.Types.Unique.FM.UniqFM key ele)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Types.Unique.FM.Edit a)
instance forall k (key :: k) ele. GHC.Classes.Eq ele => GHC.Classes.Eq (GHC.Types.Unique.FM.UniqFM key ele)
instance forall k (key :: k). GHC.Internal.Data.Foldable.Foldable (GHC.Types.Unique.FM.NonDetUniqFM key)
instance forall k (key :: k). GHC.Internal.Base.Functor (GHC.Types.Unique.FM.NonDetUniqFM key)
instance forall k (key :: k). GHC.Internal.Base.Functor (GHC.Types.Unique.FM.UniqFM key)
instance forall k (key :: k) a. GHC.Internal.Base.Monoid (GHC.Types.Unique.FM.UniqFM key a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.FM.Edit a)
instance forall k a (key :: k). GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.FM.UniqFM key a)
instance forall k (key :: k) a. GHC.Internal.Base.Semigroup (GHC.Types.Unique.FM.UniqFM key a)
instance forall k (key :: k). GHC.Internal.Data.Traversable.Traversable (GHC.Types.Unique.FM.NonDetUniqFM key)

module GHC.Types.Unique.MemoFun
memoiseUniqueFun :: Uniquable k => (k -> a) -> k -> a

module GHC.Types.Unique.Map

-- | Maps indexed by <a>Uniquable</a> keys
newtype UniqMap k a
UniqMap :: UniqFM k (k, a) -> UniqMap k a
[getUniqMap] :: UniqMap k a -> UniqFM k (k, a)
emptyUniqMap :: UniqMap k a
isNullUniqMap :: UniqMap k a -> Bool
unitUniqMap :: Uniquable k => k -> a -> UniqMap k a
listToUniqMap :: Uniquable k => [(k, a)] -> UniqMap k a
listToUniqMap_C :: Uniquable k => (a -> a -> a) -> [(k, a)] -> UniqMap k a
addToUniqMap :: Uniquable k => UniqMap k a -> k -> a -> UniqMap k a
addListToUniqMap :: Uniquable k => UniqMap k a -> [(k, a)] -> UniqMap k a
addToUniqMap_C :: Uniquable k => (a -> a -> a) -> UniqMap k a -> k -> a -> UniqMap k a
addToUniqMap_Acc :: Uniquable k => (b -> a -> a) -> (b -> a) -> UniqMap k a -> k -> b -> UniqMap k a

-- | Add an element, returns previous lookup result and new map. If old
--   element doesn't exist, add the passed element directly, otherwise
--   compute the element to add using the passed function.
addToUniqMap_L :: Uniquable k => (k -> a -> a -> a) -> k -> a -> UniqMap k a -> (Maybe a, UniqMap k a)
alterUniqMap :: Uniquable k => (Maybe a -> Maybe a) -> UniqMap k a -> k -> UniqMap k a
addListToUniqMap_C :: Uniquable k => (a -> a -> a) -> UniqMap k a -> [(k, a)] -> UniqMap k a
adjustUniqMap :: Uniquable k => (a -> a) -> UniqMap k a -> k -> UniqMap k a
delFromUniqMap :: Uniquable k => UniqMap k a -> k -> UniqMap k a
delListFromUniqMap :: Uniquable k => UniqMap k a -> [k] -> UniqMap k a
plusUniqMap :: UniqMap k a -> UniqMap k a -> UniqMap k a
plusUniqMap_C :: (a -> a -> a) -> UniqMap k a -> UniqMap k a -> UniqMap k a
plusMaybeUniqMap_C :: (a -> a -> Maybe a) -> UniqMap k a -> UniqMap k a -> UniqMap k a
plusUniqMapList :: [UniqMap k a] -> UniqMap k a
plusUniqMapListWith :: (a -> a -> a) -> [UniqMap k a] -> UniqMap k a
minusUniqMap :: UniqMap k a -> UniqMap k b -> UniqMap k a
intersectUniqMap :: UniqMap k a -> UniqMap k b -> UniqMap k a

-- | Intersection with a combining function.
intersectUniqMap_C :: (a -> b -> c) -> UniqMap k a -> UniqMap k b -> UniqMap k c
disjointUniqMap :: UniqMap k a -> UniqMap k b -> Bool
mapUniqMap :: (a -> b) -> UniqMap k a -> UniqMap k b
filterUniqMap :: (a -> Bool) -> UniqMap k a -> UniqMap k a
filterWithKeyUniqMap :: (k -> a -> Bool) -> UniqMap k a -> UniqMap k a
partitionUniqMap :: (a -> Bool) -> UniqMap k a -> (UniqMap k a, UniqMap k a)
sizeUniqMap :: UniqMap k a -> Int
elemUniqMap :: Uniquable k => k -> UniqMap k a -> Bool
nonDetKeysUniqMap :: UniqMap k a -> [k]
nonDetEltsUniqMap :: UniqMap k a -> [a]
lookupUniqMap :: Uniquable k => UniqMap k a -> k -> Maybe a
lookupWithDefaultUniqMap :: Uniquable k => UniqMap k a -> a -> k -> a
anyUniqMap :: (a -> Bool) -> UniqMap k a -> Bool
allUniqMap :: (a -> Bool) -> UniqMap k a -> Bool
nonDetUniqMapToList :: UniqMap k a -> [(k, a)]
nonDetUniqMapToKeySet :: Ord k => UniqMap k a -> Set k
nonDetFoldUniqMap :: ((k, a) -> b -> b) -> b -> UniqMap k a -> b
instance (GHC.Internal.Data.Data.Data k, GHC.Internal.Data.Data.Data a) => GHC.Internal.Data.Data.Data (GHC.Types.Unique.Map.UniqMap k a)
instance (GHC.Classes.Eq k, GHC.Classes.Eq a) => GHC.Classes.Eq (GHC.Types.Unique.Map.UniqMap k a)
instance GHC.Internal.Base.Functor (GHC.Types.Unique.Map.UniqMap k)
instance GHC.Internal.Base.Monoid (GHC.Types.Unique.Map.UniqMap k a)
instance (Control.DeepSeq.NFData k, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (GHC.Types.Unique.Map.UniqMap k a)
instance (GHC.Utils.Outputable.Outputable k, GHC.Utils.Outputable.Outputable a) => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.Map.UniqMap k a)
instance GHC.Internal.Base.Semigroup (GHC.Types.Unique.Map.UniqMap k a)

module GHC.Types.Unique.DSM
data DUniqSupply

-- | A monad which just gives the ability to obtain <a>Unique</a>s
--   deterministically. There's no splitting.
data UniqDSM result
pattern UDSM :: (DUniqSupply -> DUniqResult a) -> UniqDSM a
type DUniqResult result = (# result, DUniqSupply #)
pattern DUniqResult :: a -> DUniqSupply -> (# a, DUniqSupply #)
getUniqueDSM :: UniqDSM Unique
runUniqueDSM :: DUniqSupply -> UniqDSM a -> (a, DUniqSupply)
takeUniqueFromDSupply :: DUniqSupply -> (Unique, DUniqSupply)

-- | Initialize a deterministic unique supply with the given Tag and
--   initial unique.
initDUniqSupply :: Char -> Word64 -> DUniqSupply

-- | Set the tag of uniques generated from this deterministic unique supply
newTagDUniqSupply :: Char -> DUniqSupply -> DUniqSupply

-- | Get the tag uniques generated from this deterministic unique supply
--   would have
getTagDUniqSupply :: DUniqSupply -> Char

-- | Transformer version of <a>UniqDSM</a> to use when threading a
--   deterministic uniq supply over a Monad. Specifically, it is used in
--   the <tt>Stream</tt> of Cmm decls.
data UniqDSMT (m :: Type -> Type) result
pattern UDSMT :: (DUniqSupply -> m (result, DUniqSupply)) -> UniqDSMT m result

-- | Like <a>runUniqueDSM</a> but for <a>UniqDSMT</a>
runUDSMT :: DUniqSupply -> UniqDSMT m a -> m (a, DUniqSupply)

-- | Lift an IO action that depends on, and threads through, a unique
--   supply into UniqDSMT IO.
withDUS :: (DUniqSupply -> IO (a, DUniqSupply)) -> UniqDSMT IO a

-- | Change the monad underyling an applied <tt>UniqDSMT</tt>, i.e.
--   transform a <tt>UniqDSMT m</tt> into a <tt>UniqDSMT n</tt> given <tt>m
--   ~&gt; n</tt>.
hoistUDSMT :: (forall x. () => m x -> n x) -> UniqDSMT m a -> UniqDSMT n a

-- | Lift a monadic action <tt>m a</tt> into an <tt>UniqDSMT m a</tt>
liftUDSMT :: Functor m => m a -> UniqDSMT m a

-- | Set the tag of the running <tt>UniqDSMT</tt> supply to the given tag
--   and run an action with it. All uniques produced in the given action
--   will use this tag, until the tag is changed again.
setTagUDSMT :: forall (m :: Type -> Type) a. Monad m => Char -> UniqDSMT m a -> UniqDSMT m a

-- | Get a unique from a monad that can access a unique supply.
--   
--   Crucially, because <a>MonadGetUnique</a> doesn't allow you to get the
--   <tt>UniqSupply</tt> (unlike <tt>MonadUnique</tt>), an instance such as
--   <a>UniqDSM</a> can use a deterministic unique supply to return
--   deterministic uniques without allowing for the <tt>UniqSupply</tt> to
--   be shared.
class Monad m => MonadGetUnique (m :: Type -> Type)
getUniqueM :: MonadGetUnique m => m Unique
class Monad m => MonadUniqDSM (m :: Type -> Type)

-- | Lift a pure <a>UniqDSM</a> action into a <a>MonadUniqDSM</a> such as
--   <a>UniqDSMT</a>
liftUniqDSM :: MonadUniqDSM m => UniqDSM a -> m a
instance GHC.Internal.Base.Applicative GHC.Types.Unique.DSM.UniqDSM
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Applicative (GHC.Types.Unique.DSM.UniqDSMT m)
instance GHC.Internal.Base.Functor GHC.Types.Unique.DSM.UniqDSM
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (GHC.Types.Unique.DSM.UniqDSMT m)
instance GHC.Internal.Control.Monad.Fix.MonadFix GHC.Types.Unique.DSM.UniqDSM
instance GHC.Types.Unique.DSM.MonadGetUnique GHC.Types.Unique.DSM.UniqDSM
instance GHC.Internal.Base.Monad m => GHC.Types.Unique.DSM.MonadGetUnique (GHC.Types.Unique.DSM.UniqDSMT m)
instance GHC.Types.Unique.DSM.MonadGetUnique GHC.Types.Unique.Supply.UniqSM
instance GHC.Internal.Control.Monad.IO.Class.MonadIO m => GHC.Internal.Control.Monad.IO.Class.MonadIO (GHC.Types.Unique.DSM.UniqDSMT m)
instance GHC.Internal.Base.Monad GHC.Types.Unique.DSM.UniqDSM
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (GHC.Types.Unique.DSM.UniqDSMT m)
instance GHC.Types.Unique.DSM.MonadUniqDSM GHC.Types.Unique.DSM.UniqDSM
instance GHC.Internal.Base.Monad m => GHC.Types.Unique.DSM.MonadUniqDSM (GHC.Types.Unique.DSM.UniqDSMT m)

module GHC.Types.Unique.DFM

-- | Type of unique deterministic finite maps
--   
--   The key is just here to keep us honest. It's always safe to use a
--   single type as key. If two types don't overlap in their uniques it's
--   also safe to index the same map at multiple key types. But this is
--   very much discouraged.
data UniqDFM (key :: k) ele
emptyUDFM :: forall {k} (key :: k) elt. UniqDFM key elt
unitUDFM :: Uniquable key => key -> elt -> UniqDFM key elt
addToUDFM :: Uniquable key => UniqDFM key elt -> key -> elt -> UniqDFM key elt
addToUDFM_C :: Uniquable key => (elt -> elt -> elt) -> UniqDFM key elt -> key -> elt -> UniqDFM key elt
addToUDFM_C_Directly :: forall {k} elt (key :: k). (elt -> elt -> elt) -> UniqDFM key elt -> Unique -> elt -> UniqDFM key elt
addToUDFM_Directly :: forall {k} (key :: k) elt. UniqDFM key elt -> Unique -> elt -> UniqDFM key elt
addListToUDFM :: Uniquable key => UniqDFM key elt -> [(key, elt)] -> UniqDFM key elt
delFromUDFM :: Uniquable key => UniqDFM key elt -> key -> UniqDFM key elt

-- | Delete a list of elements from a UniqDFM
delListFromUDFM :: Uniquable key => UniqDFM key elt -> [key] -> UniqDFM key elt

-- | Apply a function to a particular element
adjustUDFM :: Uniquable key => (elt -> elt) -> UniqDFM key elt -> key -> UniqDFM key elt

-- | Apply a function to a particular element
adjustUDFM_Directly :: forall {k} elt (key :: k). (elt -> elt) -> UniqDFM key elt -> Unique -> UniqDFM key elt

-- | The expression (alterUDFM f k map) alters value x at k, or absence
--   thereof. alterUDFM can be used to insert, delete, or update a value in
--   UniqDFM. Use addToUDFM, delFromUDFM or adjustUDFM when possible, they
--   are more efficient.
alterUDFM :: Uniquable key => (Maybe elt -> Maybe elt) -> UniqDFM key elt -> key -> UniqDFM key elt

-- | Map a function over every value in a UniqDFM
mapUDFM :: forall {k} elt1 elt2 (key :: k). (elt1 -> elt2) -> UniqDFM key elt1 -> UniqDFM key elt2
mapMaybeUDFM :: forall {k} elt1 elt2 (key :: k). (elt1 -> Maybe elt2) -> UniqDFM key elt1 -> UniqDFM key elt2

-- | <a>mapM</a> for a <a>UniqDFM</a>.
mapMUDFM :: forall {k} m elt1 elt2 (key :: k). Monad m => (elt1 -> m elt2) -> UniqDFM key elt1 -> m (UniqDFM key elt2)
plusUDFM :: forall {k} (key :: k) elt. UniqDFM key elt -> UniqDFM key elt -> UniqDFM key elt
plusUDFM_C :: forall {k} elt (key :: k). (elt -> elt -> elt) -> UniqDFM key elt -> UniqDFM key elt -> UniqDFM key elt

-- | Like <a>plusUDFM_C</a> but the combine function also receives the
--   unique key
plusUDFM_CK :: forall {k} elt (key :: k). (Unique -> elt -> elt -> elt) -> UniqDFM key elt -> UniqDFM key elt -> UniqDFM key elt
lookupUDFM :: Uniquable key => UniqDFM key elt -> key -> Maybe elt
lookupUDFM_Directly :: forall {k} (key :: k) elt. UniqDFM key elt -> Unique -> Maybe elt
elemUDFM :: Uniquable key => key -> UniqDFM key elt -> Bool

-- | Performs a deterministic fold over the UniqDFM. It's O(n log n) while
--   the corresponding function on <a>UniqFM</a> is O(n).
foldUDFM :: forall {k} elt a (key :: k). (elt -> a -> a) -> a -> UniqDFM key elt -> a

-- | Like <a>foldUDFM</a> but the function also receives a key
foldWithKeyUDFM :: forall {k} elt a (key :: k). (Unique -> elt -> a -> a) -> a -> UniqDFM key elt -> a
eltsUDFM :: forall {k} (key :: k) elt. UniqDFM key elt -> [elt]
filterUDFM :: forall {k} elt (key :: k). (elt -> Bool) -> UniqDFM key elt -> UniqDFM key elt
filterUDFM_Directly :: forall {k} elt (key :: k). (Unique -> elt -> Bool) -> UniqDFM key elt -> UniqDFM key elt
isNullUDFM :: forall {k} (key :: k) elt. UniqDFM key elt -> Bool
sizeUDFM :: forall {k} (key :: k) elt. UniqDFM key elt -> Int
intersectUDFM :: forall {k} (key :: k) elt. UniqDFM key elt -> UniqDFM key elt -> UniqDFM key elt
udfmIntersectUFM :: forall {k} (key :: k) elt1 elt2. UniqDFM key elt1 -> UniqFM key elt2 -> UniqDFM key elt1
disjointUDFM :: forall {k} (key :: k) elt. UniqDFM key elt -> UniqDFM key elt -> Bool
disjointUdfmUfm :: forall {k} (key :: k) elt elt2. UniqDFM key elt -> UniqFM key elt2 -> Bool
equalKeysUDFM :: forall {k} (key :: k) a b. UniqDFM key a -> UniqDFM key b -> Bool
minusUDFM :: forall {k} (key :: k) elt1 elt2. UniqDFM key elt1 -> UniqDFM key elt2 -> UniqDFM key elt1
listToUDFM :: Uniquable key => [(key, elt)] -> UniqDFM key elt
listToUDFM_Directly :: forall {k} elt (key :: k). [(Unique, elt)] -> UniqDFM key elt
listToUDFM_C_Directly :: forall {k} elt (key :: k). (elt -> elt -> elt) -> [(Unique, elt)] -> UniqDFM key elt
udfmMinusUFM :: forall {k} (key :: k) elt1 elt2. UniqDFM key elt1 -> UniqFM key elt2 -> UniqDFM key elt1
ufmMinusUDFM :: forall {k} (key :: k) elt1 elt2. UniqFM key elt1 -> UniqDFM key elt2 -> UniqFM key elt1

-- | Partition UniqDFM into two UniqDFMs according to the predicate
partitionUDFM :: forall {k} elt (key :: k). (elt -> Bool) -> UniqDFM key elt -> (UniqDFM key elt, UniqDFM key elt)
udfmRestrictKeys :: forall {k} (key :: k) elt elt2. UniqDFM key elt -> UniqDFM key elt2 -> UniqDFM key elt
udfmRestrictKeysSet :: forall {k} (key :: k) elt. UniqDFM key elt -> Word64Set -> UniqDFM key elt
anyUDFM :: forall {k} elt (key :: k). (elt -> Bool) -> UniqDFM key elt -> Bool
allUDFM :: forall {k} elt (key :: k). (elt -> Bool) -> UniqDFM key elt -> Bool
pprUniqDFM :: forall {k} a (key :: k). (a -> SDoc) -> UniqDFM key a -> SDoc
pprUDFM :: forall {k} (key :: k) a. UniqDFM key a -> ([a] -> SDoc) -> SDoc

-- | Converts <a>UniqDFM</a> to a list, with elements in deterministic
--   order. It's O(n log n) while the corresponding function on
--   <a>UniqFM</a> is O(n).
udfmToList :: forall {k} (key :: k) elt. UniqDFM key elt -> [(Unique, elt)]

-- | This allows for lossy conversion from UniqDFM to UniqFM
udfmToUfm :: forall {k} (key :: k) elt. UniqDFM key elt -> UniqFM key elt

-- | Performs a nondeterministic strict fold over the UniqDFM. It's O(n),
--   same as the corresponding function on <a>UniqFM</a>. If you use this
--   please provide a justification why it doesn't introduce
--   nondeterminism.
nonDetStrictFoldUDFM :: forall {k} elt a (key :: k). (elt -> a -> a) -> a -> UniqDFM key elt -> a

-- | Cast the key domain of a UniqFM.
--   
--   As long as the domains don't overlap in their uniques this is safe.
unsafeCastUDFMKey :: forall {k1} {k2} (key1 :: k1) elt (key2 :: k2). UniqDFM key1 elt -> UniqDFM key2 elt
alwaysUnsafeUfmToUdfm :: forall {k} (key :: k) elt. UniqFM key elt -> UniqDFM key elt
instance GHC.Internal.Data.Data.Data val => GHC.Internal.Data.Data.Data (GHC.Types.Unique.DFM.TaggedVal val)
instance forall k (key :: k) ele. (GHC.Internal.Data.Typeable.Internal.Typeable key, GHC.Internal.Data.Typeable.Internal.Typeable k, GHC.Internal.Data.Data.Data ele) => GHC.Internal.Data.Data.Data (GHC.Types.Unique.DFM.UniqDFM key ele)
instance GHC.Classes.Eq val => GHC.Classes.Eq (GHC.Types.Unique.DFM.TaggedVal val)
instance GHC.Internal.Data.Foldable.Foldable GHC.Types.Unique.DFM.TaggedVal
instance forall k (key :: k). GHC.Internal.Data.Foldable.Foldable (GHC.Types.Unique.DFM.UniqDFM key)
instance GHC.Internal.Base.Functor GHC.Types.Unique.DFM.TaggedVal
instance forall k (key :: k). GHC.Internal.Base.Functor (GHC.Types.Unique.DFM.UniqDFM key)
instance forall k a (key :: k). GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.DFM.UniqDFM key a)
instance GHC.Internal.Data.Traversable.Traversable GHC.Types.Unique.DFM.TaggedVal
instance forall k (key :: k). GHC.Internal.Data.Traversable.Traversable (GHC.Types.Unique.DFM.UniqDFM key)

module GHC.Types.Unique.Set

-- | Set of Uniquable values
data UniqSet a
getUniqSet :: UniqSet a -> UniqFM a a
pprUniqSet :: (a -> SDoc) -> UniqSet a -> SDoc
emptyUniqSet :: UniqSet a
unitUniqSet :: Uniquable a => a -> UniqSet a
mkUniqSet :: Uniquable a => [a] -> UniqSet a
addOneToUniqSet :: Uniquable a => UniqSet a -> a -> UniqSet a
addListToUniqSet :: Uniquable a => UniqSet a -> [a] -> UniqSet a
delOneFromUniqSet :: Uniquable a => UniqSet a -> a -> UniqSet a
delOneFromUniqSet_Directly :: UniqSet a -> Unique -> UniqSet a
delListFromUniqSet :: Uniquable a => UniqSet a -> [a] -> UniqSet a
delListFromUniqSet_Directly :: UniqSet a -> [Unique] -> UniqSet a
unionUniqSets :: UniqSet a -> UniqSet a -> UniqSet a
unionManyUniqSets :: [UniqSet a] -> UniqSet a
minusUniqSet :: UniqSet a -> UniqSet a -> UniqSet a
uniqSetMinusUFM :: UniqSet key -> UniqFM key b -> UniqSet key
uniqSetMinusUDFM :: UniqSet key -> UniqDFM key b -> UniqSet key
intersectUniqSets :: UniqSet a -> UniqSet a -> UniqSet a
disjointUniqSets :: UniqSet a -> UniqSet a -> Bool
restrictUniqSetToUFM :: UniqSet key -> UniqFM key b -> UniqSet key
uniqSetAny :: (a -> Bool) -> UniqSet a -> Bool
uniqSetAll :: (a -> Bool) -> UniqSet a -> Bool
elementOfUniqSet :: Uniquable a => a -> UniqSet a -> Bool
elemUniqSet_Directly :: Unique -> UniqSet a -> Bool
filterUniqSet :: (a -> Bool) -> UniqSet a -> UniqSet a
filterUniqSet_Directly :: (Unique -> elt -> Bool) -> UniqSet elt -> UniqSet elt
sizeUniqSet :: UniqSet a -> Int
isEmptyUniqSet :: UniqSet a -> Bool

-- | What's the point you might ask? We might have changed an object
--   without it's key changing. In which case this lookup makes sense.
lookupUniqSet :: Uniquable key => UniqSet key -> key -> Maybe key
lookupUniqSet_Directly :: UniqSet a -> Unique -> Maybe a
partitionUniqSet :: (a -> Bool) -> UniqSet a -> (UniqSet a, UniqSet a)
mapUniqSet :: Uniquable b => (a -> b) -> UniqSet a -> UniqSet b

-- | <a>unsafeUFMToUniqSet</a> converts a <tt><a>UniqFM</a> a</tt> into a
--   <tt><a>UniqSet</a> a</tt> assuming, without checking, that it maps
--   each <a>Unique</a> to a value that has that <a>Unique</a>. See Note
--   [UniqSet invariant].
unsafeUFMToUniqSet :: UniqFM a a -> UniqSet a
nonDetEltsUniqSet :: UniqSet elt -> [elt]
nonDetKeysUniqSet :: UniqSet elt -> [Unique]
nonDetStrictFoldUniqSet :: (elt -> a -> a) -> a -> UniqSet elt -> a

-- | Like <a>mapMaybe</a>, but you must ensure the passed in function does
--   not change the <a>Unique</a>.
mapMaybeUniqSet_sameUnique :: (a -> Maybe b) -> UniqSet a -> UniqSet b

-- | Set of Unique values
--   
--   Similar to 'UniqSet Unique' but with a more compact representation.
newtype UniqueSet
US :: Word64Set -> UniqueSet
[unUniqueSet] :: UniqueSet -> Word64Set
nullUniqueSet :: UniqueSet -> Bool
sizeUniqueSet :: UniqueSet -> Int
memberUniqueSet :: Unique -> UniqueSet -> Bool
emptyUniqueSet :: UniqueSet
singletonUniqueSet :: Unique -> UniqueSet
insertUniqueSet :: Unique -> UniqueSet -> UniqueSet
deleteUniqueSet :: Unique -> UniqueSet -> UniqueSet
differenceUniqueSet :: UniqueSet -> UniqueSet -> UniqueSet
unionUniqueSet :: UniqueSet -> UniqueSet -> UniqueSet
unionsUniqueSet :: [UniqueSet] -> UniqueSet
intersectionUniqueSet :: UniqueSet -> UniqueSet -> UniqueSet
isSubsetOfUniqueSet :: UniqueSet -> UniqueSet -> Bool
filterUniqueSet :: (Unique -> Bool) -> UniqueSet -> UniqueSet
foldlUniqueSet :: (a -> Unique -> a) -> a -> UniqueSet -> a
foldrUniqueSet :: (Unique -> b -> b) -> b -> UniqueSet -> b
elemsUniqueSet :: UniqueSet -> [Unique]
fromListUniqueSet :: [Unique] -> UniqueSet
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Types.Unique.Set.UniqSet a)
instance GHC.Classes.Eq (GHC.Types.Unique.Set.UniqSet a)
instance GHC.Classes.Eq GHC.Types.Unique.Set.UniqueSet
instance GHC.Internal.Base.Monoid (GHC.Types.Unique.Set.UniqSet a)
instance GHC.Internal.Base.Monoid GHC.Types.Unique.Set.UniqueSet
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Types.Unique.Set.UniqSet a)
instance GHC.Classes.Ord GHC.Types.Unique.Set.UniqueSet
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.Set.UniqSet a)
instance GHC.Internal.Base.Semigroup (GHC.Types.Unique.Set.UniqSet a)
instance GHC.Internal.Base.Semigroup GHC.Types.Unique.Set.UniqueSet
instance GHC.Internal.Show.Show GHC.Types.Unique.Set.UniqueSet


-- | Types for the general graph colorer.
module GHC.Data.Graph.Base

-- | A fn to check if a node is trivially colorable For graphs who's color
--   classes are disjoint then a node is 'trivially colorable' when it has
--   less neighbors and exclusions than available colors for that node.
--   
--   For graph's who's color classes overlap, ie some colors alias other
--   colors, then this can be a bit more tricky. There is a general way to
--   calculate this, but it's likely be too slow for use in the code. The
--   coloring algorithm takes a canned function which can be optimised by
--   the user to be specific to the specific graph being colored.
--   
--   for details, see "A Generalised Algorithm for Graph-Coloring Register
--   Allocation" Smith, Ramsey, Holloway - PLDI 2004.
type Triv k cls color = cls -> UniqSet k -> UniqSet color -> Bool

-- | The Interference graph. There used to be more fields, but they were
--   turfed out in a previous revision. maybe we'll want more later..
newtype Graph k cls color
Graph :: UniqFM k (Node k cls color) -> Graph k cls color

-- | All active nodes in the graph.
[graphMap] :: Graph k cls color -> UniqFM k (Node k cls color)

-- | An empty graph.
initGraph :: Graph k cls color

-- | Modify the finite map holding the nodes in the graph.
graphMapModify :: (UniqFM k (Node k cls color) -> UniqFM k (Node k cls color)) -> Graph k cls color -> Graph k cls color

-- | Graph nodes. Represents a thing that can conflict with another thing.
--   For the register allocater the nodes represent registers.
data Node k cls color
Node :: k -> cls -> Maybe color -> UniqSet k -> UniqSet color -> [color] -> UniqSet k -> Node k cls color

-- | A unique identifier for this node.
[nodeId] :: Node k cls color -> k

-- | The class of this node, determines the set of colors that can be used.
[nodeClass] :: Node k cls color -> cls

-- | The color of this node, if any.
[nodeColor] :: Node k cls color -> Maybe color

-- | Neighbors which must be colored differently to this node.
[nodeConflicts] :: Node k cls color -> UniqSet k

-- | Colors that cannot be used by this node.
[nodeExclusions] :: Node k cls color -> UniqSet color

-- | Colors that this node would prefer to be, in descending order.
[nodePreference] :: Node k cls color -> [color]

-- | Neighbors that this node would like to be colored the same as.
[nodeCoalesce] :: Node k cls color -> UniqSet k

-- | An empty node.
newNode :: k -> cls -> Node k cls color


-- | Like a <a>UniqDFM</a>, but maintains equivalence classes of keys
--   sharing the same entry. See <a>UniqSDFM</a>.
module GHC.Types.Unique.SDFM

-- | A <a>UniqDFM</a> whose domain is <i>sets</i> of <a>Unique</a>s, each
--   of which share a common value of type <tt>ele</tt>. Every such set
--   ("equivalence class") has a distinct representative <a>Unique</a>.
--   Supports merging the entries of multiple such sets in a union-find
--   like fashion.
--   
--   An accurate model is that of <tt>[(Set key, Maybe ele)]</tt>: A finite
--   mapping from sets of <tt>key</tt>s to possibly absent entries
--   <tt>ele</tt>, where the sets don't overlap. Example: <tt> m =
--   [({u1,u3}, Just ele1), ({u2}, Just ele2), ({u4,u7}, Nothing)] </tt> On
--   this model we support the following main operations:
--   
--   <ul>
--   <li><tt><a>lookupUSDFM</a> m u3 == Just ele1</tt>,
--   <tt><a>lookupUSDFM</a> m u4 == Nothing</tt>, <tt><a>lookupUSDFM</a> m
--   u5 == Nothing</tt>.</li>
--   <li><tt><a>equateUSDFM</a> m u1 u3</tt> is a no-op, but
--   <tt><a>equateUSDFM</a> m u1 u2</tt> merges <tt>{u1,u3}</tt> and
--   <tt>{u2}</tt> to point to <tt>Just ele2</tt> and returns the old entry
--   of <tt>{u1,u3}</tt>, <tt>Just ele1</tt>.</li>
--   <li><tt><a>addToUSDFM</a> m u3 ele4</tt> sets the entry of
--   <tt>{u1,u3}</tt> to <tt>Just ele4</tt>.</li>
--   </ul>
--   
--   As well as a few means for traversal/conversion to list.
data UniqSDFM key ele
emptyUSDFM :: UniqSDFM key ele

-- | <tt>lookupSUDFM env x</tt> looks up an entry for <tt>x</tt>, looking
--   through all <a>Indirect</a>s until it finds a shared <a>Entry</a>.
--   
--   Examples in terms of the model (see <a>UniqSDFM</a>): &gt;&gt;&gt;
--   lookupUSDFM [({u1,u3}, Just ele1), ({u2}, Just ele2)] u3 == Just ele1
--   &gt;&gt;&gt; lookupUSDFM [({u1,u3}, Just ele1), ({u2}, Just ele2)] u4
--   == Nothing &gt;&gt;&gt; lookupUSDFM [({u1,u3}, Just ele1), ({u2},
--   Nothing)] u2 == Nothing
lookupUSDFM :: Uniquable key => UniqSDFM key ele -> key -> Maybe ele

-- | <tt>equateUSDFM env x y</tt> makes <tt>x</tt> and <tt>y</tt> point to
--   the same entry, thereby merging <tt>x</tt>'s class with <tt>y</tt>'s.
--   If both <tt>x</tt> and <tt>y</tt> are in the domain of the map, then
--   <tt>y</tt>'s entry will be chosen as the new entry and <tt>x</tt>'s
--   old entry will be returned.
--   
--   Examples in terms of the model (see <a>UniqSDFM</a>): &gt;&gt;&gt;
--   equateUSDFM [] u1 u2 == (Nothing, [({u1,u2}, Nothing)]) &gt;&gt;&gt;
--   equateUSDFM [({u1,u3}, Just ele1)] u3 u4 == (Nothing, [({u1,u3,u4},
--   Just ele1)]) &gt;&gt;&gt; equateUSDFM [({u1,u3}, Just ele1)] u4 u3 ==
--   (Nothing, [({u1,u3,u4}, Just ele1)]) &gt;&gt;&gt; equateUSDFM
--   [({u1,u3}, Just ele1), ({u2}, Just ele2)] u3 u2 == (Just ele1,
--   [({u2,u1,u3}, Just ele2)])
equateUSDFM :: Uniquable key => UniqSDFM key ele -> key -> key -> (Maybe ele, UniqSDFM key ele)

-- | <tt>addToUSDFM env x a</tt> sets the entry <tt>x</tt> is associated
--   with to <tt>a</tt>, thereby modifying its whole equivalence class.
--   
--   Examples in terms of the model (see <a>UniqSDFM</a>): &gt;&gt;&gt;
--   addToUSDFM [] u1 ele1 == [({u1}, Just ele1)] &gt;&gt;&gt; addToUSDFM
--   [({u1,u3}, Just ele1)] u3 ele2 == [({u1,u3}, Just ele2)]
addToUSDFM :: Uniquable key => UniqSDFM key ele -> key -> ele -> UniqSDFM key ele
traverseUSDFM :: forall key a b f. Applicative f => (a -> f b) -> UniqSDFM key a -> f (UniqSDFM key b)
instance (GHC.Utils.Outputable.Outputable key, GHC.Utils.Outputable.Outputable ele) => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.SDFM.Shared key ele)
instance (GHC.Utils.Outputable.Outputable key, GHC.Utils.Outputable.Outputable ele) => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.SDFM.UniqSDFM key ele)


-- | Specialised deterministic sets, for things with <tt>Uniques</tt>
--   
--   Based on <a>UniqDFM</a>s (as you would expect). See Note
--   [Deterministic UniqFM] in <a>GHC.Types.Unique.DFM</a> for explanation
--   why we need it.
--   
--   Basically, the things need to be in class <a>Uniquable</a>.
module GHC.Types.Unique.DSet
data UniqDSet a
getUniqDSet :: UniqDSet a -> UniqDFM a a
pprUniqDSet :: (a -> SDoc) -> UniqDSet a -> SDoc
delOneFromUniqDSet :: Uniquable a => UniqDSet a -> a -> UniqDSet a
delListFromUniqDSet :: Uniquable a => UniqDSet a -> [a] -> UniqDSet a
emptyUniqDSet :: UniqDSet a
unitUniqDSet :: Uniquable a => a -> UniqDSet a
mkUniqDSet :: Uniquable a => [a] -> UniqDSet a
addOneToUniqDSet :: Uniquable a => UniqDSet a -> a -> UniqDSet a
addListToUniqDSet :: Uniquable a => UniqDSet a -> [a] -> UniqDSet a
unionUniqDSets :: UniqDSet a -> UniqDSet a -> UniqDSet a
unionManyUniqDSets :: [UniqDSet a] -> UniqDSet a
minusUniqDSet :: UniqDSet a -> UniqDSet a -> UniqDSet a
uniqDSetMinusUniqSet :: UniqDSet a -> UniqSet a -> UniqDSet a
intersectUniqDSets :: UniqDSet a -> UniqDSet a -> UniqDSet a
uniqDSetIntersectUniqSet :: UniqDSet a -> UniqSet a -> UniqDSet a
nonDetStrictFoldUniqDSet :: (a -> b -> b) -> b -> UniqDSet a -> b
elementOfUniqDSet :: Uniquable a => a -> UniqDSet a -> Bool
filterUniqDSet :: (a -> Bool) -> UniqDSet a -> UniqDSet a
sizeUniqDSet :: UniqDSet a -> Int
isEmptyUniqDSet :: UniqDSet a -> Bool
lookupUniqDSet :: Uniquable a => UniqDSet a -> a -> Maybe a
uniqDSetToList :: UniqDSet a -> [a]
partitionUniqDSet :: (a -> Bool) -> UniqDSet a -> (UniqDSet a, UniqDSet a)
mapUniqDSet :: Uniquable b => (a -> b) -> UniqDSet a -> UniqDSet b
strictFoldUniqDSet :: (a -> r -> r) -> r -> UniqDSet a -> r

-- | Like <a>mapUniqDSet</a> but for <a>mapM</a>. Assumes the function we
--   are mapping over the <a>UniqDSet</a> does not modify uniques, as per
--   Note [UniqSet invariant] in GHC.Types.Unique.Set.
mapMUniqDSet :: (Monad m, Uniquable b) => (a -> m b) -> UniqDSet a -> m (UniqDSet b)
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Types.Unique.DSet.UniqDSet a)
instance GHC.Classes.Eq (GHC.Types.Unique.DSet.UniqDSet a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.DSet.UniqDSet a)


module GHC.Data.FastString.Env

-- | A non-deterministic set of FastStrings. See Note [Deterministic
--   UniqFM] in <a>GHC.Types.Unique.DFM</a> for explanation why it's not
--   deterministic and why it matters. Use DFastStringEnv if the set
--   eventually gets converted into a list or folded over in a way where
--   the order changes the generated code.
type FastStringEnv a = UniqFM FastString a
mkFsEnv :: [(FastString, a)] -> FastStringEnv a
emptyFsEnv :: FastStringEnv a
unitFsEnv :: FastString -> a -> FastStringEnv a
extendFsEnv_C :: (a -> a -> a) -> FastStringEnv a -> FastString -> a -> FastStringEnv a
extendFsEnv_Acc :: (a -> b -> b) -> (a -> b) -> FastStringEnv b -> FastString -> a -> FastStringEnv b
extendFsEnv :: FastStringEnv a -> FastString -> a -> FastStringEnv a
extendFsEnvList :: FastStringEnv a -> [(FastString, a)] -> FastStringEnv a
extendFsEnvList_C :: (a -> a -> a) -> FastStringEnv a -> [(FastString, a)] -> FastStringEnv a
filterFsEnv :: (elt -> Bool) -> FastStringEnv elt -> FastStringEnv elt
plusFsEnv :: FastStringEnv a -> FastStringEnv a -> FastStringEnv a
plusFsEnv_C :: (a -> a -> a) -> FastStringEnv a -> FastStringEnv a -> FastStringEnv a
alterFsEnv :: (Maybe a -> Maybe a) -> FastStringEnv a -> FastString -> FastStringEnv a
lookupFsEnv :: FastStringEnv a -> FastString -> Maybe a
lookupFsEnv_NF :: FastStringEnv a -> FastString -> a
delFromFsEnv :: FastStringEnv a -> FastString -> FastStringEnv a
delListFromFsEnv :: FastStringEnv a -> [FastString] -> FastStringEnv a
elemFsEnv :: FastString -> FastStringEnv a -> Bool
mapFsEnv :: (elt1 -> elt2) -> FastStringEnv elt1 -> FastStringEnv elt2
strictMapFsEnv :: (a -> b) -> FastStringEnv a -> FastStringEnv b
mapMaybeFsEnv :: (elt1 -> Maybe elt2) -> FastStringEnv elt1 -> FastStringEnv elt2

-- | Fold over a <a>FastStringEnv</a>.
--   
--   Non-deterministic, unless the folding function is commutative (i.e.
--   <tt>a1 <tt>f</tt> ( a2 <tt>f</tt> b ) == a2 <tt>f</tt> ( a1 <tt>f</tt>
--   b )</tt> for all <tt>a1</tt>, <tt>a2</tt>, <tt>b</tt>).
nonDetFoldFsEnv :: (a -> b -> b) -> b -> FastStringEnv a -> b
type DFastStringEnv a = UniqDFM FastString a
mkDFsEnv :: [(FastString, a)] -> DFastStringEnv a
emptyDFsEnv :: DFastStringEnv a
dFsEnvElts :: DFastStringEnv a -> [a]
lookupDFsEnv :: DFastStringEnv a -> FastString -> Maybe a


-- | <ul>
--   <li>Domain and PurposeGHC.JS.Ident defines identifiers for the JS
--   backend. We keep this module separate to prevent coupling between GHC
--   and the backend and between unrelated modules is the JS backend.</li>
--   <li>ConsumersThe entire JavaScript Backend consumes this module
--   including modules in GHC.JS.* and modules in GHC.StgToJS.*</li>
--   <li>Additional NotesThis module should be kept as small as possible.
--   Anything added to it will be coupled to the JS backend EDSL and the JS
--   Backend including the linker and rts. You have been warned.</li>
--   </ul>
module GHC.JS.Ident

-- | A newtype wrapper around <a>FastString</a> for JS identifiers.
newtype Ident
TxtI :: FastString -> Ident
[identFS] :: Ident -> FastString

-- | To give a thing a name is to have power over it. This smart
--   constructor serves two purposes: first, it isolates the JS backend
--   from the rest of GHC. The backend should not explicitly use types
--   provided by GHC but instead should wrap them such as we do here.
--   Second it creates a symbol in the JS backend, but it does not yet give
--   that symbols meaning. Giving the symbol meaning only occurs once it is
--   used with a combinator from <tt>GHC.JS.Make</tt>.
name :: FastString -> Ident
instance GHC.Classes.Eq GHC.JS.Ident.Ident
instance GHC.Utils.Outputable.Outputable GHC.JS.Ident.Ident
instance GHC.Internal.Show.Show GHC.JS.Ident.Ident
instance GHC.Types.Unique.Uniquable GHC.JS.Ident.Ident


-- | <ul>
--   <li>Domain and PurposeGHC.JS.JStg.Monad defines the computational
--   environment for the eDSL that we use to write the JS Backend's RTS.
--   Its purpose is to ensure unique identifiers are generated throughout
--   the backend and that we can use the host language to ensure references
--   are not mixed.</li>
--   <li>StrategyThe monad is a straightforward state monad which holds an
--   environment holds a pointer to a prefix to tag identifiers with and an
--   infinite stream of identifiers.</li>
--   <li>UsageOne should almost never need to directly use the functions in
--   this module. Instead one should opt to use the combinators in
--   <a>Make</a>, the sole exception to this is the <tt>withTag</tt>
--   function which is used to change the prefix of identifiers for a given
--   computation. For example, the rts uses this function to tag all
--   identifiers generated by the RTS code as RTS_N, where N is some
--   unique.</li>
--   </ul>
module GHC.JS.JStg.Monad
runJSM :: JEnv -> JSM a -> a
type JSM a = State JEnv a

-- | tag the name generater with a prefix for the monadic action.
withTag :: FastString -> JSM a -> JSM a

-- | generate a fresh Ident
newIdent :: JSM Ident
initJSM :: IO JEnv

module GHC.Data.TrieMap
data MaybeMap (m :: Type -> Type) a
data ListMap (m :: Type -> Type) a
class Functor m => TrieMap (m :: Type -> Type) where {
    type Key (m :: Type -> Type);
}
emptyTM :: TrieMap m => m a
lookupTM :: TrieMap m => Key m -> m b -> Maybe b
alterTM :: TrieMap m => Key m -> XT b -> m b -> m b
filterTM :: TrieMap m => (a -> Bool) -> m a -> m a
foldTM :: TrieMap m => (a -> b -> b) -> m a -> b -> b
insertTM :: TrieMap m => Key m -> a -> m a -> m a
deleteTM :: TrieMap m => Key m -> m a -> m a
foldMapTM :: (TrieMap m, Monoid r) => (a -> r) -> m a -> r
isEmptyTM :: TrieMap m => m a -> Bool
(>.>) :: (a -> b) -> (b -> c) -> a -> c
infixr 1 >.>
(|>) :: a -> (a -> b) -> b
infixr 1 |>
(|>>) :: TrieMap m2 => (XT (m2 a) -> m1 (m2 a) -> m1 (m2 a)) -> (m2 a -> m2 a) -> m1 (m2 a) -> m1 (m2 a)
infixr 1 |>>
type XT a = Maybe a -> Maybe a
foldMaybe :: (a -> b -> b) -> Maybe a -> b -> b
filterMaybe :: (a -> Bool) -> Maybe a -> Maybe a
data GenMap (m :: Type -> Type) a
lkG :: forall (m :: Type -> Type) a. (Eq (Key m), TrieMap m) => Key m -> GenMap m a -> Maybe a
xtG :: forall (m :: Type -> Type) a. (Eq (Key m), TrieMap m) => Key m -> XT a -> GenMap m a -> GenMap m a
mapG :: forall (m :: Type -> Type) a b. Functor m => (a -> b) -> GenMap m a -> GenMap m b
fdG :: forall (m :: Type -> Type) a b. TrieMap m => (a -> b -> b) -> GenMap m a -> b -> b
xtList :: TrieMap m => (forall b. () => k -> XT b -> m b -> m b) -> [k] -> XT a -> ListMap m a -> ListMap m a
lkList :: TrieMap m => (forall b. () => k -> m b -> Maybe b) -> [k] -> ListMap m a -> Maybe a
instance (GHC.Classes.Eq (GHC.Data.TrieMap.Key m), GHC.Data.TrieMap.TrieMap m) => GHC.Internal.Data.Foldable.Foldable (GHC.Data.TrieMap.GenMap m)
instance GHC.Data.TrieMap.TrieMap m => GHC.Internal.Data.Foldable.Foldable (GHC.Data.TrieMap.ListMap m)
instance GHC.Data.TrieMap.TrieMap m => GHC.Internal.Data.Foldable.Foldable (GHC.Data.TrieMap.MaybeMap m)
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (GHC.Data.TrieMap.GenMap m)
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (GHC.Data.TrieMap.ListMap m)
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (GHC.Data.TrieMap.MaybeMap m)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable (m a)) => GHC.Utils.Outputable.Outputable (GHC.Data.TrieMap.GenMap m a)
instance (GHC.Data.TrieMap.TrieMap m, GHC.Utils.Outputable.Outputable a) => GHC.Utils.Outputable.Outputable (GHC.Data.TrieMap.ListMap m a)
instance (GHC.Classes.Eq (GHC.Data.TrieMap.Key m), GHC.Data.TrieMap.TrieMap m) => GHC.Data.TrieMap.TrieMap (GHC.Data.TrieMap.GenMap m)
instance GHC.Data.TrieMap.TrieMap Data.IntMap.Internal.IntMap
instance GHC.Data.TrieMap.TrieMap m => GHC.Data.TrieMap.TrieMap (GHC.Data.TrieMap.ListMap m)
instance GHC.Classes.Ord k => GHC.Data.TrieMap.TrieMap (Data.Map.Internal.Map k)
instance GHC.Data.TrieMap.TrieMap m => GHC.Data.TrieMap.TrieMap (GHC.Data.TrieMap.MaybeMap m)
instance GHC.Types.Unique.Uniquable key => GHC.Data.TrieMap.TrieMap (GHC.Types.Unique.DFM.UniqDFM key)

module GHC.Utils.Binary
data Bin (a :: k)

-- | Like a <a>Bin</a> but is used to store relative offset pointers.
--   Relative offset pointers store a relative location, but also contain
--   an anchor that allow to obtain the absolute offset.
data RelBin (a :: k)
RelBin :: {-# UNPACK #-} !Bin a -> {-# UNPACK #-} !RelBinPtr a -> RelBin (a :: k)

-- | Absolute position from where we read <a>relBin_offset</a>.
[relBin_anchor] :: RelBin (a :: k) -> {-# UNPACK #-} !Bin a

-- | Relative offset to <a>relBin_anchor</a>. The absolute position of the
--   <a>RelBin</a> is <tt>relBin_anchor + relBin_offset</tt>
[relBin_offset] :: RelBin (a :: k) -> {-# UNPACK #-} !RelBinPtr a

-- | Read a relative offset location and wrap it in <a>RelBin</a>.
--   
--   The resulting <a>RelBin</a> can be translated into an absolute offset
--   location using <a>makeAbsoluteBin</a>
getRelBin :: forall {k} (a :: k). ReadBinHandle -> IO (RelBin a)

-- | Do not rely on instance sizes for general types, we use variable
--   length encoding for many of them.
class Binary a
put_ :: Binary a => WriteBinHandle -> a -> IO ()
put :: Binary a => WriteBinHandle -> a -> IO (Bin a)
get :: Binary a => ReadBinHandle -> IO a

-- | A read-only handle that can be used to deserialise binary data from a
--   buffer.
--   
--   The buffer is an unboxed binary array.
data ReadBinHandle

-- | A write-only handle that can be used to serialise binary data into a
--   buffer.
--   
--   The buffer is an unboxed binary array.
data WriteBinHandle

-- | Symbols that are read from disk. The <a>SymbolTable</a> index starts
--   on '0'.
type SymbolTable a = Array Int a

-- | A <a>SymbolTable</a> of <a>FastString</a>s.
type Dictionary = SymbolTable FastString
data BinData
BinData :: Int -> BinArray -> BinData
dataHandle :: BinData -> IO ReadBinHandle
handleData :: WriteBinHandle -> IO BinData
unsafeUnpackBinBuffer :: ByteString -> IO ReadBinHandle
openBinMem :: Int -> IO WriteBinHandle
seekBinWriter :: forall {k} (a :: k). WriteBinHandle -> Bin a -> IO ()

-- | SeekBin but without calling expandBin
seekBinReader :: forall {k} (a :: k). ReadBinHandle -> Bin a -> IO ()
seekBinReaderRel :: forall {k} (a :: k). ReadBinHandle -> RelBin a -> IO ()
tellBinReader :: forall {k} (a :: k). ReadBinHandle -> IO (Bin a)
tellBinWriter :: forall {k} (a :: k). WriteBinHandle -> IO (Bin a)
castBin :: forall {k1} {k2} (a :: k1) (b :: k2). Bin a -> Bin b

-- | Get access to the underlying buffer.
withBinBuffer :: WriteBinHandle -> (ByteString -> IO a) -> IO a

-- | Freeze the given <a>WriteBinHandle</a> and turn it into an equivalent
--   <a>ReadBinHandle</a>.
--   
--   The current offset of the <a>WriteBinHandle</a> is maintained in the
--   new <a>ReadBinHandle</a>.
freezeWriteHandle :: WriteBinHandle -> IO ReadBinHandle

-- | Copy the BinBuffer to a new BinBuffer which is exactly the right size.
--   This performs a copy of the underlying buffer. The buffer may be
--   truncated if the offset is not at the end of the written output.
--   
--   UserData is also discarded during the copy You should just use this
--   when translating a Put handle into a Get handle.
shrinkBinBuffer :: WriteBinHandle -> IO ReadBinHandle
thawReadHandle :: ReadBinHandle -> IO WriteBinHandle
foldGet :: Binary a => Word -> ReadBinHandle -> b -> (Word -> a -> b -> IO b) -> IO b
foldGet' :: Binary a => Word -> ReadBinHandle -> b -> (Word -> a -> b -> IO b) -> IO b
writeBinMem :: WriteBinHandle -> FilePath -> IO ()
readBinMem :: FilePath -> IO ReadBinHandle
readBinMemN :: Int -> FilePath -> IO (Maybe ReadBinHandle)
putAt :: Binary a => WriteBinHandle -> Bin a -> a -> IO ()
getAt :: Binary a => ReadBinHandle -> Bin a -> IO a
putAtRel :: forall {k} (a :: k). WriteBinHandle -> Bin (RelBinPtr a) -> Bin a -> IO ()

-- | <tt><a>forwardPut</a> put_A put_B</tt> outputs A after B but allows A
--   to be read before B by using a forward reference.
forwardPut :: WriteBinHandle -> (b -> IO a) -> IO b -> IO (a, b)
forwardPut_ :: WriteBinHandle -> (b -> IO a) -> IO b -> IO ()

-- | Read a value stored using a forward reference
--   
--   The forward reference is expected to be an absolute offset.
forwardGet :: ReadBinHandle -> IO a -> IO a

-- | <tt><a>forwardPutRel</a> put_A put_B</tt> outputs A after B but allows
--   A to be read before B by using a forward reference.
--   
--   This forward reference is a relative offset that allows us to skip
--   over the result of <tt>put_A</tt>.
forwardPutRel :: WriteBinHandle -> (b -> IO a) -> IO b -> IO (a, b)

-- | Like <a>forwardGetRel</a>, but discard the result.
forwardPutRel_ :: WriteBinHandle -> (b -> IO a) -> IO b -> IO ()

-- | Read a value stored using a forward reference.
--   
--   The forward reference is expected to be a relative offset.
forwardGetRel :: ReadBinHandle -> IO a -> IO a
putByte :: WriteBinHandle -> Word8 -> IO ()
getByte :: ReadBinHandle -> IO Word8

-- | Put a ByteString without its length (can't be read back without
--   knowing the length!)
putByteString :: WriteBinHandle -> ByteString -> IO ()

-- | Get a ByteString whose length is known
getByteString :: ReadBinHandle -> Int -> IO ByteString
putULEB128 :: (Integral a, FiniteBits a) => WriteBinHandle -> a -> IO ()
getULEB128 :: (Integral a, FiniteBits a) => ReadBinHandle -> IO a
putSLEB128 :: (Integral a, Bits a) => WriteBinHandle -> a -> IO ()
getSLEB128 :: (Show a, Integral a, FiniteBits a) => ReadBinHandle -> IO a

-- | Encode the argument in its full length. This is different from many
--   default binary instances which make no guarantee about the actual
--   encoding and might do things using variable length encoding.
newtype FixedLengthEncoding a
FixedLengthEncoding :: a -> FixedLengthEncoding a
[unFixedLength] :: FixedLengthEncoding a -> a
lazyGet :: Binary a => ReadBinHandle -> IO a
lazyPut :: Binary a => WriteBinHandle -> a -> IO ()
lazyGet' :: (ReadBinHandle -> IO a) -> ReadBinHandle -> IO a
lazyPut' :: (WriteBinHandle -> a -> IO ()) -> WriteBinHandle -> a -> IO ()

-- | Deserialize a value serialized by <a>lazyPutMaybe</a>.
lazyGetMaybe :: Binary a => ReadBinHandle -> IO (Maybe a)

-- | Serialize the constructor strictly but lazily serialize a value inside
--   a <a>Just</a>.
--   
--   This way we can check for the presence of a value without
--   deserializing the value itself.
lazyPutMaybe :: Binary a => WriteBinHandle -> Maybe a -> IO ()

-- | UserData required to deserialise symbols for interface files.
--   
--   See Note [Binary UserData]
data ReaderUserData
getReaderUserData :: ReadBinHandle -> ReaderUserData
setReaderUserData :: ReadBinHandle -> ReaderUserData -> ReadBinHandle
noReaderUserData :: ReaderUserData

-- | UserData required to serialise symbols for interface files.
--   
--   See Note [Binary UserData]
data WriterUserData
getWriterUserData :: WriteBinHandle -> WriterUserData
setWriterUserData :: WriteBinHandle -> WriterUserData -> WriteBinHandle
noWriterUserData :: WriterUserData
mkWriterUserData :: [SomeBinaryWriter] -> WriterUserData
mkReaderUserData :: [SomeBinaryReader] -> ReaderUserData
newReadState :: (ReadBinHandle -> IO Name) -> (ReadBinHandle -> IO FastString) -> ReaderUserData
newWriteState :: (WriteBinHandle -> Name -> IO ()) -> (WriteBinHandle -> Name -> IO ()) -> (WriteBinHandle -> FastString -> IO ()) -> WriterUserData

-- | Add <a>SomeBinaryReader</a> as a known binary decoder. If a
--   <a>BinaryReader</a> for the associated type already exists in
--   <a>ReaderUserData</a>, it is overwritten.
addReaderToUserData :: Typeable a => BinaryReader a -> ReadBinHandle -> ReadBinHandle

-- | Add <a>SomeBinaryWriter</a> as a known binary encoder. If a
--   <a>BinaryWriter</a> for the associated type already exists in
--   <a>WriterUserData</a>, it is overwritten.
addWriterToUserData :: Typeable a => BinaryWriter a -> WriteBinHandle -> WriteBinHandle

-- | Find the <a>BinaryReader</a> for the <a>Binary</a> instance for the
--   type identified by 'Proxy a'.
--   
--   If no <a>BinaryReader</a> has been configured before, this function
--   will panic.
findUserDataReader :: Typeable a => Proxy a -> ReadBinHandle -> BinaryReader a

-- | Find the <a>BinaryWriter</a> for the <a>Binary</a> instance for the
--   type identified by 'Proxy a'.
--   
--   If no <a>BinaryWriter</a> has been configured before, this function
--   will panic.
findUserDataWriter :: Typeable a => Proxy a -> WriteBinHandle -> BinaryWriter a
newtype BinaryReader s
BinaryReader :: (ReadBinHandle -> IO s) -> BinaryReader s
[getEntry] :: BinaryReader s -> ReadBinHandle -> IO s
newtype BinaryWriter s
BinaryWriter :: (WriteBinHandle -> s -> IO ()) -> BinaryWriter s
[putEntry] :: BinaryWriter s -> WriteBinHandle -> s -> IO ()
mkWriter :: (WriteBinHandle -> s -> IO ()) -> BinaryWriter s
mkReader :: (ReadBinHandle -> IO s) -> BinaryReader s

-- | Existential for <a>BinaryReader</a> with a type witness.
data SomeBinaryReader

-- | Existential for <a>BinaryWriter</a> with a type witness.
data SomeBinaryWriter
mkSomeBinaryReader :: Typeable a => BinaryReader a -> SomeBinaryReader
mkSomeBinaryWriter :: Typeable a => BinaryWriter a -> SomeBinaryWriter

-- | A <a>ReaderTable</a> describes how to deserialise a table from disk,
--   and how to create a <a>BinaryReader</a> that looks up values in the
--   deduplication table.
data ReaderTable a
ReaderTable :: (ReadBinHandle -> IO (SymbolTable a)) -> (SymbolTable a -> BinaryReader a) -> ReaderTable a

-- | Deserialise a list of elements into a <a>SymbolTable</a>.
[getTable] :: ReaderTable a -> ReadBinHandle -> IO (SymbolTable a)

-- | Given the table from <a>getTable</a>, create a <a>BinaryReader</a>
--   that reads values only from the <a>SymbolTable</a>.
[mkReaderFromTable] :: ReaderTable a -> SymbolTable a -> BinaryReader a

-- | A <a>WriterTable</a> is an interface any deduplication table can
--   implement to describe how the table can be written to disk.
newtype WriterTable
WriterTable :: (WriteBinHandle -> IO Int) -> WriterTable

-- | Serialise a table to disk. Returns the number of written elements.
[putTable] :: WriterTable -> WriteBinHandle -> IO Int
initFastStringReaderTable :: IO (ReaderTable FastString)
initFastStringWriterTable :: IO (WriterTable, BinaryWriter FastString)
putDictionary :: WriteBinHandle -> Int -> UniqFM FastString (Int, FastString) -> IO ()
getDictionary :: ReadBinHandle -> IO Dictionary
putFS :: WriteBinHandle -> FastString -> IO ()
data FSTable
FSTable :: !FastMutInt -> !IORef (UniqFM FastString (Int, FastString)) -> FSTable
[fs_tab_next] :: FSTable -> !FastMutInt
[fs_tab_map] :: FSTable -> !IORef (UniqFM FastString (Int, FastString))
getDictFastString :: Dictionary -> ReadBinHandle -> IO FastString
putDictFastString :: FSTable -> WriteBinHandle -> FastString -> IO ()

-- | The <a>GenericSymbolTable</a> stores a mapping from already seen
--   elements to an index. If an element wasn't seen before, it is added to
--   the mapping together with a fresh index.
--   
--   <a>GenericSymbolTable</a> is a variant of a <tt>BinSymbolTable</tt>
--   that is polymorphic in the table implementation. As such it can be
--   used with any container that implements the <a>TrieMap</a> type class.
--   
--   While <a>GenericSymbolTable</a> is similar to the
--   <tt>BinSymbolTable</tt>, it supports storing tree-like structures such
--   as <tt>Type</tt> and <tt>IfaceType</tt> more efficiently.
data GenericSymbolTable (m :: Type -> Type)
GenericSymbolTable :: !FastMutInt -> !IORef (m Int) -> !IORef [Key m] -> GenericSymbolTable (m :: Type -> Type)

-- | The next index to use.
[gen_symtab_next] :: GenericSymbolTable (m :: Type -> Type) -> !FastMutInt

-- | Given a symbol, find the symbol and return its index.
[gen_symtab_map] :: GenericSymbolTable (m :: Type -> Type) -> !IORef (m Int)

-- | Reversed list of values to write into the buffer. This is an
--   optimisation, as it allows us to write out quickly all newly
--   discovered values that are discovered when serialising 'Key m' to
--   disk.
[gen_symtab_to_write] :: GenericSymbolTable (m :: Type -> Type) -> !IORef [Key m]

-- | Initialise a <a>GenericSymbolTable</a>, initialising the index to '0'.
initGenericSymbolTable :: forall (m :: Type -> Type). TrieMap m => IO (GenericSymbolTable m)

-- | Read a value from a <a>SymbolTable</a>.
getGenericSymtab :: Binary a => SymbolTable a -> ReadBinHandle -> IO a

-- | Write an element 'Key m' to the given <a>WriteBinHandle</a>.
--   
--   If the element was seen before, we simply write the index of that
--   element to the <a>WriteBinHandle</a>. If we haven't seen it before, we
--   add the element to the <a>GenericSymbolTable</a>, increment the index,
--   and return this new index.
putGenericSymTab :: forall (m :: Type -> Type). TrieMap m => GenericSymbolTable m -> WriteBinHandle -> Key m -> IO ()

-- | Read the elements of a <a>GenericSymbolTable</a> from disk into a
--   <a>SymbolTable</a>.
getGenericSymbolTable :: (ReadBinHandle -> IO a) -> ReadBinHandle -> IO (SymbolTable a)

-- | Serialise the <a>GenericSymbolTable</a> to disk.
--   
--   Since <a>GenericSymbolTable</a> stores tree-like structures, such as
--   <tt>IfaceType</tt>, serialising an element can add new elements to the
--   mapping. Thus, <a>putGenericSymbolTable</a> first serialises all
--   values, and then checks whether any new elements have been discovered.
--   If so, repeat the loop.
putGenericSymbolTable :: forall (m :: Type -> Type). TrieMap m => GenericSymbolTable m -> (WriteBinHandle -> Key m -> IO ()) -> WriteBinHandle -> IO Int
newtype BinSpan
BinSpan :: RealSrcSpan -> BinSpan
[unBinSpan] :: BinSpan -> RealSrcSpan
newtype BinSrcSpan
BinSrcSpan :: SrcSpan -> BinSrcSpan
[unBinSrcSpan] :: BinSrcSpan -> SrcSpan
newtype BinLocated a
BinLocated :: Located a -> BinLocated a
[unBinLocated] :: BinLocated a -> Located a

-- | Newtype to serialise binding names differently to non-binding
--   <a>Name</a>. See Note [Binary UserData]
newtype BindingName
BindingName :: Name -> BindingName
[getBindingName] :: BindingName -> Name
simpleBindingNameWriter :: BinaryWriter Name -> BinaryWriter BindingName
simpleBindingNameReader :: BinaryReader Name -> BinaryReader BindingName

-- | <a>FullBinData</a> stores a slice to a <a>BinArray</a>.
--   
--   It requires less memory than <a>ReadBinHandle</a>, and can be
--   constructed from a <a>ReadBinHandle</a> via <a>freezeBinHandle</a> and
--   turned back into a <a>ReadBinHandle</a> using <a>thawBinHandle</a>.
--   Additionally, the byte array slice can be put into a
--   <a>WriteBinHandle</a> without extra conversions via
--   <a>putFullBinData</a>.
data FullBinData
FullBinData :: ReaderUserData -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !BinArray -> FullBinData

-- | <a>ReaderUserData</a> that can be used to resume reading.
[fbd_readerUserData] :: FullBinData -> ReaderUserData

-- | start offset
[fbd_off_s] :: FullBinData -> {-# UNPACK #-} !Int

-- | end offset
[fbd_off_e] :: FullBinData -> {-# UNPACK #-} !Int

-- | total buffer size
[fbd_size] :: FullBinData -> {-# UNPACK #-} !Int
[fbd_buffer] :: FullBinData -> {-# UNPACK #-} !BinArray

-- | Freeze a <a>ReadBinHandle</a> and a start index into a
--   <a>FullBinData</a>.
--   
--   <a>FullBinData</a> stores a slice starting from the 'Bin a' location
--   to the current offset of the <a>ReadBinHandle</a>.
freezeBinHandle :: forall {k} (a :: k). ReadBinHandle -> Bin a -> IO FullBinData

-- | Turn the <a>FullBinData</a> into a <a>ReadBinHandle</a>, setting the
--   <a>ReadBinHandle</a> offset to the start of the <a>FullBinData</a> and
--   restore the <a>ReaderUserData</a> that was obtained from
--   <a>freezeBinHandle</a>.
thawBinHandle :: FullBinData -> IO ReadBinHandle

-- | Write the <a>FullBinData</a> slice into the <a>WriteBinHandle</a>.
putFullBinData :: WriteBinHandle -> FullBinData -> IO ()
type BinArray = ForeignPtr Word8
instance (GHC.Internal.Ix.Ix a, GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b) => GHC.Utils.Binary.Binary (GHC.Internal.Arr.Array a b)
instance forall k (a :: k). GHC.Utils.Binary.Binary (GHC.Utils.Binary.Bin a)
instance GHC.Utils.Binary.Binary GHC.Utils.Binary.BinData
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Utils.Binary.BinLocated a)
instance GHC.Utils.Binary.Binary GHC.Utils.Binary.BinSpan
instance GHC.Utils.Binary.Binary GHC.Utils.Binary.BinSrcSpan
instance GHC.Utils.Binary.Binary GHC.Types.Bool
instance GHC.Utils.Binary.Binary Data.ByteString.Internal.Type.ByteString
instance GHC.Utils.Binary.Binary GHC.Types.Char
instance GHC.Utils.Binary.Binary Data.Time.Calendar.Days.Day
instance GHC.Utils.Binary.Binary Data.Time.Clock.Internal.DiffTime.DiffTime
instance (GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b) => GHC.Utils.Binary.Binary (GHC.Internal.Data.Either.Either a b)
instance GHC.Utils.Binary.Binary GHC.Data.FastString.FastString
instance GHC.Utils.Binary.Binary GHC.Internal.Fingerprint.Type.Fingerprint
instance GHC.Utils.Binary.Binary (GHC.Utils.Binary.FixedLengthEncoding GHC.Internal.Word.Word8)
instance GHC.Utils.Binary.Binary (GHC.Utils.Binary.FixedLengthEncoding GHC.Internal.Word.Word16)
instance GHC.Utils.Binary.Binary (GHC.Utils.Binary.FixedLengthEncoding GHC.Internal.Word.Word32)
instance GHC.Utils.Binary.Binary (GHC.Utils.Binary.FixedLengthEncoding GHC.Internal.Word.Word64)
instance GHC.Utils.Binary.Binary GHC.Types.Int
instance GHC.Utils.Binary.Binary GHC.Internal.Int.Int16
instance GHC.Utils.Binary.Binary GHC.Internal.Int.Int32
instance GHC.Utils.Binary.Binary GHC.Internal.Int.Int64
instance GHC.Utils.Binary.Binary GHC.Internal.Int.Int8
instance GHC.Utils.Binary.Binary v => GHC.Utils.Binary.Binary (Data.IntMap.Internal.IntMap v)
instance GHC.Utils.Binary.Binary GHC.Num.Integer.Integer
instance GHC.Utils.Binary.Binary GHC.Utils.Outputable.JoinPointHood
instance GHC.Utils.Binary.Binary GHC.Data.FastString.LexicalFastString
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary [a]
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Data.Strict.Maybe a)
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Internal.Maybe.Maybe a)
instance GHC.Utils.Binary.Binary Language.Haskell.Syntax.Module.Name.ModuleName
instance GHC.Utils.Binary.Binary GHC.Data.FastString.NonDetFastString
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Internal.Base.NonEmpty a)
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Internal.Real.Ratio a)
instance forall k (a :: k). GHC.Utils.Binary.Binary (GHC.Utils.Binary.RelBinPtr a)
instance (GHC.Utils.Binary.Binary a, GHC.Classes.Ord a) => GHC.Utils.Binary.Binary (Data.Set.Internal.Set a)
instance (GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b) => GHC.Utils.Binary.Binary (a, b)
instance (GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b, GHC.Utils.Binary.Binary c) => GHC.Utils.Binary.Binary (a, b, c)
instance (GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b, GHC.Utils.Binary.Binary c, GHC.Utils.Binary.Binary d) => GHC.Utils.Binary.Binary (a, b, c, d)
instance (GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b, GHC.Utils.Binary.Binary c, GHC.Utils.Binary.Binary d, GHC.Utils.Binary.Binary e) => GHC.Utils.Binary.Binary (a, b, c, d, e)
instance (GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b, GHC.Utils.Binary.Binary c, GHC.Utils.Binary.Binary d, GHC.Utils.Binary.Binary e, GHC.Utils.Binary.Binary f) => GHC.Utils.Binary.Binary (a, b, c, d, e, f)
instance (GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b, GHC.Utils.Binary.Binary c, GHC.Utils.Binary.Binary d, GHC.Utils.Binary.Binary e, GHC.Utils.Binary.Binary f, GHC.Utils.Binary.Binary g) => GHC.Utils.Binary.Binary (a, b, c, d, e, f, g)
instance GHC.Utils.Binary.Binary Data.Time.Clock.Internal.UTCTime.UTCTime
instance GHC.Utils.Binary.Binary GHC.Types.SrcLoc.UnhelpfulSpanReason
instance GHC.Utils.Binary.Binary ()
instance GHC.Utils.Binary.Binary GHC.Internal.Word.Word16
instance GHC.Utils.Binary.Binary GHC.Internal.Word.Word32
instance GHC.Utils.Binary.Binary GHC.Internal.Word.Word64
instance GHC.Utils.Binary.Binary GHC.Internal.Word.Word8
instance forall k (a :: k). GHC.Internal.Enum.Bounded (GHC.Utils.Binary.Bin a)
instance forall k (a :: k). GHC.Internal.Enum.Bounded (GHC.Utils.Binary.RelBin a)
instance forall k (a :: k). GHC.Internal.Enum.Bounded (GHC.Utils.Binary.RelBinPtr a)
instance forall k (a :: k). GHC.Classes.Eq (GHC.Utils.Binary.Bin a)
instance GHC.Classes.Eq GHC.Utils.Binary.BindingName
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Utils.Binary.FixedLengthEncoding a)
instance GHC.Classes.Eq GHC.Utils.Binary.FullBinData
instance forall k (a :: k). GHC.Classes.Eq (GHC.Utils.Binary.RelBin a)
instance forall k (a :: k). GHC.Classes.Eq (GHC.Utils.Binary.RelBinPtr a)
instance GHC.Internal.Base.Functor GHC.Utils.Binary.BinaryReader
instance Control.DeepSeq.NFData GHC.Utils.Binary.BinData
instance forall k (a :: k). GHC.Classes.Ord (GHC.Utils.Binary.Bin a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Utils.Binary.FixedLengthEncoding a)
instance GHC.Classes.Ord GHC.Utils.Binary.FullBinData
instance forall k (a :: k). GHC.Classes.Ord (GHC.Utils.Binary.RelBin a)
instance forall k (a :: k). GHC.Classes.Ord (GHC.Utils.Binary.RelBinPtr a)
instance forall k (a :: k). GHC.Internal.Show.Show (GHC.Utils.Binary.Bin a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Utils.Binary.FixedLengthEncoding a)
instance forall k (a :: k). GHC.Internal.Show.Show (GHC.Utils.Binary.RelBin a)
instance forall k (a :: k). GHC.Internal.Show.Show (GHC.Utils.Binary.RelBinPtr a)


-- | Orphan Binary instances for Data.Typeable stuff
module GHC.Utils.Binary.Typeable
getSomeTypeRep :: ReadBinHandle -> IO SomeTypeRep
instance GHC.Utils.Binary.Binary GHC.Types.KindRep
instance GHC.Utils.Binary.Binary GHC.Types.RuntimeRep
instance GHC.Utils.Binary.Binary GHC.Serialized.Serialized
instance GHC.Utils.Binary.Binary GHC.Internal.Data.Typeable.Internal.SomeTypeRep
instance GHC.Utils.Binary.Binary GHC.Types.TyCon
instance GHC.Utils.Binary.Binary GHC.Types.TypeLitSort
instance forall k (a :: k). GHC.Internal.Data.Typeable.Internal.Typeable a => GHC.Utils.Binary.Binary (GHC.Internal.Data.Typeable.Internal.TypeRep a)
instance GHC.Utils.Binary.Binary GHC.Types.VecCount
instance GHC.Utils.Binary.Binary GHC.Types.VecElem


-- | Unit &amp; Module types
--   
--   This module is used to resolve the loops between Unit and Module types
--   (Module references a Unit and vice-versa).
module GHC.Unit.Types

-- | A generic module is a pair of a unit identifier and a
--   <a>ModuleName</a>.
data GenModule unit
Module :: !unit -> !ModuleName -> GenModule unit

-- | Unit the module belongs to
[moduleUnit] :: GenModule unit -> !unit

-- | Module name (e.g. A.B.C)
[moduleName] :: GenModule unit -> !ModuleName

-- | A Module is a pair of a <a>Unit</a> and a <a>ModuleName</a>.
type Module = GenModule Unit

-- | A <a>InstalledModule</a> is a <a>Module</a> whose unit is identified
--   with an <a>UnitId</a>.
type InstalledModule = GenModule UnitId

-- | A <a>HomeUnitModule</a> is like an <a>InstalledModule</a> but we
--   expect to find it in one of the home units rather than the package
--   database.
type HomeUnitModule = GenModule UnitId

-- | An <a>InstantiatedModule</a> is a <a>Module</a> whose unit is
--   identified with an <a>InstantiatedUnit</a>.
type InstantiatedModule = GenModule InstantiatedUnit
mkModule :: u -> ModuleName -> GenModule u
moduleUnitId :: Module -> UnitId
pprModule :: IsLine doc => Module -> doc
pprInstantiatedModule :: InstantiatedModule -> SDoc

-- | Calculate the free holes of a <a>Module</a>. If this set is non-empty,
--   this module was defined in an indefinite library that had required
--   signatures.
--   
--   If a module has free holes, that means that substitutions can operate
--   on it; if it has no free holes, substituting over a module has no
--   effect.
moduleFreeHoles :: GenModule (GenUnit u) -> UniqDSet ModuleName

-- | Class for types that are used as unit identifiers (UnitKey, UnitId,
--   Unit)
--   
--   We need this class because we create new unit ids for virtual units
--   (see VirtUnit) and they have to to be made from units with different
--   kinds of identifiers.
class IsUnitId u

-- | A unit identifier identifies a (possibly partially) instantiated
--   library. It is primarily used as part of <a>Module</a>, which in turn
--   is used in <tt>Name</tt>, which is used to give names to entities when
--   typechecking.
--   
--   There are two possible forms for a <a>Unit</a>:
--   
--   1) It can be a <a>RealUnit</a>, in which case we just have a
--   <a>DefUnitId</a> that uniquely identifies some fully compiled,
--   installed library we have on disk.
--   
--   2) It can be an <a>VirtUnit</a>. When we are typechecking a library
--   with missing holes, we may need to instantiate a library on the fly
--   (in which case we don't have any on-disk representation.) In that
--   case, you have an <a>InstantiatedUnit</a>, which explicitly records
--   the instantiation, so that we can substitute over it.
data GenUnit uid

-- | Installed definite unit (either a fully instantiated unit or a closed
--   unit)
RealUnit :: !Definite uid -> GenUnit uid

-- | Virtual unit instantiated on-the-fly. It may be definite if all the
--   holes are instantiated but we don't have code objects for it.
VirtUnit :: {-# UNPACK #-} !GenInstantiatedUnit uid -> GenUnit uid

-- | Fake hole unit
HoleUnit :: GenUnit uid
type Unit = GenUnit UnitId

-- | A UnitId identifies a built library in a database and is used to
--   generate unique symbols, etc. It's usually of the form:
--   
--   pkgname-1.2:libname+hash
--   
--   These UnitId are provided to us via the <tt>-this-unit-id</tt> flag.
--   
--   The library in question may be definite or indefinite; if it is
--   indefinite, none of the holes have been filled (we never install
--   partially instantiated libraries as we can cheaply instantiate them
--   on-the-fly, cf VirtUnit). Put another way, an installed unit id is
--   either fully instantiated, or not instantiated at all.
newtype UnitId
UnitId :: FastString -> UnitId

-- | The full hashed unit identifier, including the component id and the
--   hash.
[unitIdFS] :: UnitId -> FastString

-- | A unit key in the database
newtype UnitKey
UnitKey :: FastString -> UnitKey

-- | An instantiated unit.
--   
--   It identifies an indefinite library (with holes) that has been
--   instantiated.
--   
--   This unit may be indefinite or not (i.e. with remaining holes or not).
--   If it is definite, we don't know if it has already been compiled and
--   installed in a database. Nevertheless, we have a mechanism called
--   "improvement" to try to match a fully instantiated unit with existing
--   compiled and installed units: see Note [VirtUnit to RealUnit
--   improvement].
--   
--   An indefinite unit identifier pretty-prints to something like
--   <tt>p[H=<a>H</a>,A=aimpl:A&gt;]</tt> (<tt>p</tt> is the <a>UnitId</a>,
--   and the brackets enclose the module substitution).
data GenInstantiatedUnit unit
InstantiatedUnit :: !FastString -> !Unique -> !unit -> !GenInstantiations unit -> UniqDSet ModuleName -> GenInstantiatedUnit unit

-- | A private, uniquely identifying representation of an InstantiatedUnit.
--   This string is completely private to GHC and is just used to get a
--   unique.
[instUnitFS] :: GenInstantiatedUnit unit -> !FastString

-- | Cached unique of <a>unitFS</a>.
[instUnitKey] :: GenInstantiatedUnit unit -> !Unique

-- | The (indefinite) unit being instantiated.
[instUnitInstanceOf] :: GenInstantiatedUnit unit -> !unit

-- | The sorted (by <a>ModuleName</a>) instantiations of this unit.
[instUnitInsts] :: GenInstantiatedUnit unit -> !GenInstantiations unit

-- | A cache of the free module holes of <a>instUnitInsts</a>. This lets us
--   efficiently tell if a <a>InstantiatedUnit</a> has been fully
--   instantiated (empty set of free module holes) and whether or not a
--   substitution can have any effect.
[instUnitHoles] :: GenInstantiatedUnit unit -> UniqDSet ModuleName
type InstantiatedUnit = GenInstantiatedUnit UnitId

-- | A <a>DefUnitId</a> is an <a>UnitId</a> with the invariant that it only
--   refers to a definite library; i.e., one we have generated code for.
type DefUnitId = Definite UnitId
type Instantiations = GenInstantiations UnitId
type GenInstantiations unit = [(ModuleName, GenModule GenUnit unit)]

-- | Create a new <a>GenInstantiatedUnit</a> given an explicit module
--   substitution.
mkInstantiatedUnit :: IsUnitId u => u -> GenInstantiations u -> GenInstantiatedUnit u

-- | Generate a uniquely identifying hash (internal unit-id) for an
--   instantiated unit.
--   
--   This is a one-way function. If the indefinite unit has not been
--   instantiated at all, we return its unit-id.
--   
--   This hash is completely internal to GHC and is not used for symbol
--   names or file paths. It is different from the hash Cabal would produce
--   for the same instantiated unit.
mkInstantiatedUnitHash :: IsUnitId u => u -> [(ModuleName, GenModule (GenUnit u))] -> FastString

-- | Smart constructor for instantiated GenUnit
mkVirtUnit :: IsUnitId u => u -> [(ModuleName, GenModule (GenUnit u))] -> GenUnit u

-- | Map over the unit type of a <a>GenUnit</a>
mapGenUnit :: IsUnitId v => (u -> v) -> GenUnit u -> GenUnit v

-- | Map over the unit identifier of unit instantiations.
mapInstantiations :: IsUnitId v => (u -> v) -> GenInstantiations u -> GenInstantiations v

-- | Retrieve the set of free module holes of a <a>Unit</a>.
unitFreeModuleHoles :: GenUnit u -> UniqDSet ModuleName

-- | Create a new simple unit identifier from a <a>FastString</a>.
--   Internally, this is primarily used to specify wired-in unit
--   identifiers.
fsToUnit :: FastString -> Unit
unitFS :: IsUnitId u => u -> FastString
unitString :: IsUnitId u => u -> String

-- | Return the UnitId of the Unit. For on-the-fly instantiated units,
--   return the UnitId of the indefinite unit this unit is an instance of.
toUnitId :: Unit -> UnitId

-- | Return the virtual UnitId of an on-the-fly instantiated unit.
virtualUnitId :: InstantiatedUnit -> UnitId
stringToUnit :: String -> Unit

-- | Compares unit ids lexically, rather than by their <a>Unique</a>s
stableUnitCmp :: Unit -> Unit -> Ordering

-- | A <a>Unit</a> is definite if it has no free holes.
unitIsDefinite :: Unit -> Bool
isHoleUnit :: GenUnit u -> Bool
pprUnit :: Unit -> SDoc
unitIdString :: UnitId -> String
stringToUnitId :: String -> UnitId

-- | A definite unit (i.e. without any free module hole)
newtype Definite unit
Definite :: unit -> Definite unit
[unDefinite] :: Definite unit -> unit
primUnitId :: UnitId
bignumUnitId :: UnitId
ghcInternalUnitId :: UnitId
rtsUnitId :: UnitId

-- | This is the package Id for the current program. It is the default
--   package Id if you don't specify a package name. We don't add this
--   prefix to symbol names, since there can be only one main package per
--   program.
mainUnitId :: UnitId
thisGhcUnitId :: UnitId
interactiveUnitId :: UnitId
primUnit :: Unit
bignumUnit :: Unit
ghcInternalUnit :: Unit
rtsUnit :: Unit
mainUnit :: Unit
thisGhcUnit :: Unit
interactiveUnit :: Unit
isInteractiveModule :: Module -> Bool
wiredInUnitIds :: [UnitId]
data IsBootInterface
NotBoot :: IsBootInterface
IsBoot :: IsBootInterface

-- | This data type just pairs a value <a>mod</a> with an IsBootInterface
--   flag. In practice, <a>mod</a> is usually a <tt>Module</tt> or
--   <tt>ModuleName</tt>'.
data GenWithIsBoot mod
GWIB :: mod -> IsBootInterface -> GenWithIsBoot mod
[gwib_mod] :: GenWithIsBoot mod -> mod
[gwib_isBoot] :: GenWithIsBoot mod -> IsBootInterface
type ModuleNameWithIsBoot = GenWithIsBoot ModuleName
type ModuleWithIsBoot = GenWithIsBoot Module
type InstalledModuleWithIsBoot = GenWithIsBoot InstalledModule
notBoot :: mod -> GenWithIsBoot mod
instance GHC.Utils.Binary.Binary unit => GHC.Utils.Binary.Binary (GHC.Unit.Types.Definite unit)
instance GHC.Utils.Binary.Binary GHC.Unit.Types.InstantiatedUnit
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Unit.Types.GenModule a)
instance GHC.Utils.Binary.Binary GHC.Unit.Types.Unit
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Unit.Types.GenWithIsBoot a)
instance GHC.Utils.Binary.Binary Language.Haskell.Syntax.ImpExp.IsBootInterface
instance GHC.Utils.Binary.Binary GHC.Unit.Types.UnitId
instance GHC.Internal.Data.Data.Data unit => GHC.Internal.Data.Data.Data (GHC.Unit.Types.GenModule unit)
instance GHC.Internal.Data.Data.Data GHC.Unit.Types.Unit
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Module.Name.ModuleName
instance GHC.Internal.Data.Data.Data GHC.Unit.Types.UnitId
instance GHC.Classes.Eq unit => GHC.Classes.Eq (GHC.Unit.Types.Definite unit)
instance GHC.Classes.Eq (GHC.Unit.Types.GenInstantiatedUnit unit)
instance GHC.Classes.Eq unit => GHC.Classes.Eq (GHC.Unit.Types.GenModule unit)
instance GHC.Unit.Types.IsUnitId u => GHC.Classes.Eq (GHC.Unit.Types.GenUnit u)
instance GHC.Classes.Eq mod => GHC.Classes.Eq (GHC.Unit.Types.GenWithIsBoot mod)
instance GHC.Classes.Eq GHC.Unit.Types.UnitId
instance GHC.Internal.Data.Foldable.Foldable GHC.Unit.Types.GenWithIsBoot
instance GHC.Internal.Base.Functor GHC.Unit.Types.Definite
instance GHC.Internal.Base.Functor GHC.Unit.Types.GenModule
instance GHC.Internal.Base.Functor GHC.Unit.Types.GenWithIsBoot
instance GHC.Unit.Types.IsUnitId unit => GHC.Unit.Types.IsUnitId (GHC.Unit.Types.Definite unit)
instance GHC.Unit.Types.IsUnitId u => GHC.Unit.Types.IsUnitId (GHC.Unit.Types.GenUnit u)
instance GHC.Unit.Types.IsUnitId GHC.Unit.Types.UnitId
instance GHC.Unit.Types.IsUnitId GHC.Unit.Types.UnitKey
instance Control.DeepSeq.NFData (GHC.Unit.Types.GenModule a)
instance Control.DeepSeq.NFData GHC.Unit.Types.Unit
instance GHC.Classes.Ord unit => GHC.Classes.Ord (GHC.Unit.Types.Definite unit)
instance GHC.Classes.Ord (GHC.Unit.Types.GenInstantiatedUnit unit)
instance GHC.Classes.Ord unit => GHC.Classes.Ord (GHC.Unit.Types.GenModule unit)
instance GHC.Classes.Ord GHC.Unit.Types.Unit
instance GHC.Classes.Ord mod => GHC.Classes.Ord (GHC.Unit.Types.GenWithIsBoot mod)
instance GHC.Classes.Ord GHC.Unit.Types.UnitId
instance GHC.Utils.Outputable.Outputable unit => GHC.Utils.Outputable.Outputable (GHC.Unit.Types.Definite unit)
instance GHC.Utils.Outputable.Outputable GHC.Unit.Types.InstantiatedUnit
instance GHC.Utils.Outputable.Outputable GHC.Unit.Types.Module
instance GHC.Utils.Outputable.Outputable GHC.Unit.Types.InstantiatedModule
instance GHC.Utils.Outputable.Outputable GHC.Unit.Types.InstalledModule
instance GHC.Utils.Outputable.Outputable GHC.Unit.Types.Unit
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Unit.Types.GenWithIsBoot a)
instance GHC.Utils.Outputable.Outputable GHC.Unit.Types.UnitId
instance GHC.Internal.Show.Show GHC.Unit.Types.Unit
instance GHC.Internal.Show.Show mod => GHC.Internal.Show.Show (GHC.Unit.Types.GenWithIsBoot mod)
instance GHC.Internal.Data.Traversable.Traversable GHC.Unit.Types.GenWithIsBoot
instance GHC.Types.Unique.Uniquable unit => GHC.Types.Unique.Uniquable (GHC.Unit.Types.Definite unit)
instance GHC.Types.Unique.Uniquable GHC.Unit.Types.Module
instance GHC.Unit.Types.IsUnitId u => GHC.Types.Unique.Uniquable (GHC.Unit.Types.GenUnit u)
instance GHC.Types.Unique.Uniquable GHC.Unit.Types.UnitId


-- | Parsers for unit/module identifiers
module GHC.Unit.Parser
parseUnit :: ReadP Unit
parseUnitId :: ReadP UnitId
parseHoleyModule :: ReadP Module
parseModSubst :: ReadP [(ModuleName, Module)]


-- | Module location
module GHC.Unit.Module.Location

-- | Module Location
--   
--   Where a module lives on the file system: the actual locations of the
--   .hs, .hi, .dyn_hi, .o, .dyn_o and .hie files, if we have them.
--   
--   For a module in another unit, the ml_hs_file_ospath and
--   ml_obj_file_ospath components of ModLocation are undefined.
--   
--   The locations specified by a ModLocation may or may not correspond to
--   actual files yet: for example, even if the object file doesn't exist,
--   the ModLocation still contains the path to where the object file will
--   reside if/when it is created.
--   
--   The paths of anything which can affect recompilation should be placed
--   inside ModLocation.
--   
--   When a ModLocation is created none of the filepaths will have -boot
--   suffixes. This is because in --make mode the ModLocation is put in the
--   finder cache which is indexed by ModuleName, when a ModLocation is
--   retrieved from the FinderCache the boot suffixes are appended. The
--   other case is in -c mode, there the ModLocation immediately gets given
--   the boot suffixes in mkOneShotModLocation.
data ModLocation
OsPathModLocation :: Maybe OsPath -> OsPath -> OsPath -> OsPath -> OsPath -> OsPath -> ModLocation

-- | The source file, if we have one. Package modules probably don't have
--   source files.
[ml_hs_file_ospath] :: ModLocation -> Maybe OsPath

-- | Where the .hi file is, whether or not it exists yet. Always of form
--   foo.hi, even if there is an hi-boot file (we add the -boot suffix
--   later)
[ml_hi_file_ospath] :: ModLocation -> OsPath

-- | Where the .dyn_hi file is, whether or not it exists yet.
[ml_dyn_hi_file_ospath] :: ModLocation -> OsPath

-- | Where the .o file is, whether or not it exists yet. (might not exist
--   either because the module hasn't been compiled yet, or because it is
--   part of a unit with a .a file)
[ml_obj_file_ospath] :: ModLocation -> OsPath

-- | Where the .dy file is, whether or not it exists yet.
[ml_dyn_obj_file_ospath] :: ModLocation -> OsPath

-- | Where the .hie file is, whether or not it exists yet.
[ml_hie_file_ospath] :: ModLocation -> OsPath
pattern ModLocation :: Maybe FilePath -> FilePath -> FilePath -> FilePath -> FilePath -> FilePath -> ModLocation

-- | Add the <tt>-boot</tt> suffix to .hs, .hi and .o files
addBootSuffix :: OsPath -> OsPath

-- | Add the <tt>-boot</tt> suffix if the <tt>Bool</tt> argument is
--   <tt>True</tt>
addBootSuffix_maybe :: IsBootInterface -> OsPath -> OsPath
addBootSuffixLocn_maybe :: IsBootInterface -> ModLocation -> ModLocation

-- | Add the <tt>-boot</tt> suffix to all file paths associated with the
--   module
addBootSuffixLocn :: ModLocation -> ModLocation

-- | Add the <tt>-boot</tt> suffix to all output file paths associated with
--   the module, not including the input file itself
addBootSuffixLocnOut :: ModLocation -> ModLocation

-- | Remove the <tt>-boot</tt> suffix to .hs, .hi and .o files
removeBootSuffix :: OsPath -> OsPath

-- | Compute a <a>SrcSpan</a> from a <a>ModLocation</a>.
mkFileSrcSpan :: ModLocation -> SrcSpan
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.Location.ModLocation
instance GHC.Internal.Show.Show GHC.Unit.Module.Location.ModLocation


-- | Module environment
module GHC.Unit.Module.Env

-- | A map keyed off of <a>Module</a>s
data ModuleEnv elt
elemModuleEnv :: Module -> ModuleEnv a -> Bool
extendModuleEnv :: ModuleEnv a -> Module -> a -> ModuleEnv a
extendModuleEnvList :: ModuleEnv a -> [(Module, a)] -> ModuleEnv a
extendModuleEnvList_C :: (a -> a -> a) -> ModuleEnv a -> [(Module, a)] -> ModuleEnv a
plusModuleEnv_C :: (a -> a -> a) -> ModuleEnv a -> ModuleEnv a -> ModuleEnv a
delModuleEnvList :: ModuleEnv a -> [Module] -> ModuleEnv a
delModuleEnv :: ModuleEnv a -> Module -> ModuleEnv a
plusModuleEnv :: ModuleEnv a -> ModuleEnv a -> ModuleEnv a
lookupModuleEnv :: ModuleEnv a -> Module -> Maybe a
lookupWithDefaultModuleEnv :: ModuleEnv a -> a -> Module -> a
mapModuleEnv :: (a -> b) -> ModuleEnv a -> ModuleEnv b
mkModuleEnv :: [(Module, a)] -> ModuleEnv a
emptyModuleEnv :: ModuleEnv a
alterModuleEnv :: (Maybe a -> Maybe a) -> Module -> ModuleEnv a -> ModuleEnv a
partitionModuleEnv :: (a -> Bool) -> ModuleEnv a -> (ModuleEnv a, ModuleEnv a)
moduleEnvKeys :: ModuleEnv a -> [Module]
moduleEnvElts :: ModuleEnv a -> [a]
moduleEnvToList :: ModuleEnv a -> [(Module, a)]
unitModuleEnv :: Module -> a -> ModuleEnv a
isEmptyModuleEnv :: ModuleEnv a -> Bool
extendModuleEnvWith :: (a -> a -> a) -> ModuleEnv a -> Module -> a -> ModuleEnv a
filterModuleEnv :: (Module -> a -> Bool) -> ModuleEnv a -> ModuleEnv a
mapMaybeModuleEnv :: (Module -> a -> Maybe b) -> ModuleEnv a -> ModuleEnv b

-- | A map keyed off of <a>ModuleName</a>s (actually, their <a>Unique</a>s)
type ModuleNameEnv elt = UniqFM ModuleName elt

-- | A map keyed off of <a>ModuleName</a>s (actually, their <a>Unique</a>s)
--   Has deterministic folds and can be deterministically converted to a
--   list
type DModuleNameEnv elt = UniqDFM ModuleName elt

-- | A set of <a>Module</a>s
type ModuleSet = Set NDModule
emptyModuleSet :: ModuleSet
mkModuleSet :: [Module] -> ModuleSet
moduleSetElts :: ModuleSet -> [Module]
extendModuleSet :: ModuleSet -> Module -> ModuleSet
extendModuleSetList :: ModuleSet -> [Module] -> ModuleSet
delModuleSet :: ModuleSet -> Module -> ModuleSet
elemModuleSet :: Module -> ModuleSet -> Bool
intersectModuleSet :: ModuleSet -> ModuleSet -> ModuleSet
minusModuleSet :: ModuleSet -> ModuleSet -> ModuleSet
unionModuleSet :: ModuleSet -> ModuleSet -> ModuleSet
unitModuleSet :: Module -> ModuleSet
isEmptyModuleSet :: ModuleSet -> Bool
unionManyModuleSets :: [ModuleSet] -> ModuleSet

-- | A map keyed off of <a>InstalledModule</a>
data InstalledModuleEnv elt
emptyInstalledModuleEnv :: InstalledModuleEnv a
lookupInstalledModuleEnv :: InstalledModuleEnv a -> InstalledModule -> Maybe a
extendInstalledModuleEnv :: InstalledModuleEnv a -> InstalledModule -> a -> InstalledModuleEnv a
filterInstalledModuleEnv :: (InstalledModule -> a -> Bool) -> InstalledModuleEnv a -> InstalledModuleEnv a
delInstalledModuleEnv :: InstalledModuleEnv a -> InstalledModule -> InstalledModuleEnv a
mergeInstalledModuleEnv :: (elta -> eltb -> Maybe eltc) -> (InstalledModuleEnv elta -> InstalledModuleEnv eltc) -> (InstalledModuleEnv eltb -> InstalledModuleEnv eltc) -> InstalledModuleEnv elta -> InstalledModuleEnv eltb -> InstalledModuleEnv eltc
plusInstalledModuleEnv :: (elt -> elt -> elt) -> InstalledModuleEnv elt -> InstalledModuleEnv elt -> InstalledModuleEnv elt
installedModuleEnvElts :: InstalledModuleEnv a -> [(InstalledModule, a)]

-- | A map keyed off of <a>InstalledModuleWithIsBoot</a>
data InstalledModuleWithIsBootEnv elt
emptyInstalledModuleWithIsBootEnv :: InstalledModuleWithIsBootEnv a
lookupInstalledModuleWithIsBootEnv :: InstalledModuleWithIsBootEnv a -> InstalledModuleWithIsBoot -> Maybe a
extendInstalledModuleWithIsBootEnv :: InstalledModuleWithIsBootEnv a -> InstalledModuleWithIsBoot -> a -> InstalledModuleWithIsBootEnv a
filterInstalledModuleWithIsBootEnv :: (InstalledModuleWithIsBoot -> a -> Bool) -> InstalledModuleWithIsBootEnv a -> InstalledModuleWithIsBootEnv a
delInstalledModuleWithIsBootEnv :: InstalledModuleWithIsBootEnv a -> InstalledModuleWithIsBoot -> InstalledModuleWithIsBootEnv a
mergeInstalledModuleWithIsBootEnv :: (elta -> eltb -> Maybe eltc) -> (InstalledModuleWithIsBootEnv elta -> InstalledModuleWithIsBootEnv eltc) -> (InstalledModuleWithIsBootEnv eltb -> InstalledModuleWithIsBootEnv eltc) -> InstalledModuleWithIsBootEnv elta -> InstalledModuleWithIsBootEnv eltb -> InstalledModuleWithIsBootEnv eltc
plusInstalledModuleWithIsBootEnv :: (elt -> elt -> elt) -> InstalledModuleWithIsBootEnv elt -> InstalledModuleWithIsBootEnv elt -> InstalledModuleWithIsBootEnv elt
installedModuleWithIsBootEnvElts :: InstalledModuleWithIsBootEnv a -> [(InstalledModuleWithIsBoot, a)]
instance GHC.Classes.Eq GHC.Unit.Module.Env.NDModule
instance GHC.Classes.Ord GHC.Unit.Module.Env.NDModule
instance GHC.Utils.Outputable.Outputable elt => GHC.Utils.Outputable.Outputable (GHC.Unit.Module.Env.InstalledModuleEnv elt)
instance GHC.Utils.Outputable.Outputable elt => GHC.Utils.Outputable.Outputable (GHC.Unit.Module.Env.InstalledModuleWithIsBootEnv elt)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Unit.Module.Env.ModuleEnv a)
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.Env.NDModule

module GHC.Unit.Module

-- | Given a possibly on-the-fly instantiated module, split it into a
--   <a>Module</a> that we definitely can find on-disk, as well as an
--   instantiation if we need to instantiate it on the fly. If the
--   instantiation is <tt>Nothing</tt> no on-the-fly renaming is needed.
getModuleInstantiation :: Module -> (InstalledModule, Maybe InstantiatedModule)

-- | Return the unit-id this unit is an instance of and the module
--   instantiations (if any).
getUnitInstantiations :: Unit -> (UnitId, Maybe InstantiatedUnit)

-- | Remove instantiations of the given instantiated unit
uninstantiateInstantiatedUnit :: InstantiatedUnit -> InstantiatedUnit

-- | Remove instantiations of the given module instantiated unit
uninstantiateInstantiatedModule :: InstantiatedModule -> InstantiatedModule

-- | Create a hole Module
mkHoleModule :: ModuleName -> GenModule (GenUnit u)

-- | Test if a Module is not instantiated
isHoleModule :: GenModule (GenUnit u) -> Bool

-- | This gives a stable ordering, as opposed to the Ord instance which
--   gives an ordering based on the <tt>Unique</tt>s of the components,
--   which may not be stable from run to run of the compiler.
stableModuleCmp :: Module -> Module -> Ordering

-- | Get a string representation of a <a>Module</a> that's unique and
--   stable across recompilations. eg.
--   "$aeson_70dylHtv1FFGeai1IoxcQr$Data.Aeson.Types.Internal"
moduleStableString :: Module -> String

-- | A <a>Module</a> is definite if it has no free holes.
moduleIsDefinite :: Module -> Bool
class HasModule (m :: Type -> Type)
getModule :: HasModule m => m Module
class ContainsModule t
extractModule :: ContainsModule t => t -> Module

-- | Test if a <a>Module</a> corresponds to a given <a>InstalledModule</a>,
--   modulo instantiation.
installedModuleEq :: InstalledModule -> Module -> Bool


-- | Breakpoint related types
module GHC.Types.Breakpoint

-- | Breakpoint identifier.
--   
--   See Note [Breakpoint identifiers]
data BreakpointId
BreakpointId :: !Module -> !Int -> BreakpointId

-- | Breakpoint tick module
[bi_tick_mod] :: BreakpointId -> !Module

-- | Breakpoint tick index
[bi_tick_index] :: BreakpointId -> !Int

-- | Internal breakpoint identifier
--   
--   See Note [Breakpoint identifiers]
data InternalBreakpointId
InternalBreakpointId :: !Module -> !Int -> !Module -> !Int -> InternalBreakpointId

-- | Breakpoint tick module
[ibi_tick_mod] :: InternalBreakpointId -> !Module

-- | Breakpoint tick index
[ibi_tick_index] :: InternalBreakpointId -> !Int

-- | Breakpoint info module
[ibi_info_mod] :: InternalBreakpointId -> !Module

-- | Breakpoint info index
[ibi_info_index] :: InternalBreakpointId -> !Int
toBreakpointId :: InternalBreakpointId -> BreakpointId


-- | The home unit is the unit (i.e. compiled package) that contains the
--   module we are compiling/typechecking.
module GHC.Unit.Home

-- | Information about the home unit (i.e., the until that will contain the
--   modules we are compiling)
--   
--   The unit identifier of the instantiating units is left open to allow
--   switching from UnitKey (what is provided by the user) to UnitId
--   (internal unit identifier) with <a>homeUnitMap</a>.
--   
--   TODO: this isn't implemented yet. UnitKeys are still converted too
--   early into UnitIds in GHC.Unit.State.readUnitDataBase
data GenHomeUnit u

-- | Definite home unit (i.e. that we can compile).
--   
--   Nothing: not an instantiated unit Just (i,insts): made definite by
--   instantiating "i" with "insts"
DefiniteHomeUnit :: UnitId -> Maybe (u, GenInstantiations u) -> GenHomeUnit u

-- | Indefinite home unit (i.e. that we can only typecheck)
--   
--   All the holes are instantiated with fake modules from the Hole unit.
--   See Note [Representation of module/name variables] in <a>GHC.Unit</a>
IndefiniteHomeUnit :: UnitId -> GenInstantiations u -> GenHomeUnit u
type HomeUnit = GenHomeUnit UnitId

-- | Return home unit id
homeUnitId :: GenHomeUnit u -> UnitId

-- | Return home unit instantiations
homeUnitInstantiations :: GenHomeUnit u -> GenInstantiations u

-- | Return the unit id of the unit that is instantiated by the home unit.
--   
--   E.g. if home unit = q[A=p:B,...] we return q.
--   
--   If the home unit is not an instance of another unit, we return its own
--   unit id (it is an instance of itself if you will).
homeUnitInstanceOf :: HomeUnit -> UnitId

-- | Return the unit id of the unit that is instantiated by the home unit.
--   
--   E.g. if home unit = q[A=p:B,...] we return (Just q).
--   
--   If the home unit is not an instance of another unit, we return
--   Nothing.
homeUnitInstanceOfMaybe :: GenHomeUnit u -> Maybe u

-- | Return the home unit as a normal unit.
--   
--   We infer from the home unit itself the kind of unit we create: 1. If
--   the home unit is definite, we must be compiling so we return a real
--   unit. The definite home unit may be the result of a unit
--   instantiation, say `p = q[A=r:X]`. In this case we could have returned
--   a virtual unit `q[A=r:X]` but it's not what the clients of this
--   function expect, especially because <tt>p</tt> is lost when we do
--   this. The unit id of a virtual unit is made up internally so
--   `unitId(q[A=r:X])` is not equal to <tt>p</tt>.
--   
--   <ol>
--   <li>If the home unit is indefinite we can only create a virtual unit
--   from it. It's ok because we must be only typechecking the home unit so
--   we won't produce any code object that rely on the unit id of this
--   virtual unit.</li>
--   </ol>
homeUnitAsUnit :: HomeUnit -> Unit

-- | Map over the unit identifier for instantiating units
homeUnitMap :: IsUnitId v => (u -> v) -> GenHomeUnit u -> GenHomeUnit v

-- | Test if we are type-checking an indefinite unit
--   
--   (if it is not, we should never use on-the-fly renaming)
isHomeUnitIndefinite :: GenHomeUnit u -> Bool

-- | Test if we are compiling a definite unit
--   
--   (if it is, we should never use on-the-fly renaming)
isHomeUnitDefinite :: GenHomeUnit u -> Bool

-- | Test if we are compiling by instantiating a definite unit
isHomeUnitInstantiating :: GenHomeUnit u -> Bool

-- | Test if the unit is the home unit
isHomeUnit :: HomeUnit -> Unit -> Bool

-- | Test if the unit-id is the home unit-id
isHomeUnitId :: GenHomeUnit u -> UnitId -> Bool

-- | Test if the home unit is an instance of the given unit-id
isHomeUnitInstanceOf :: HomeUnit -> UnitId -> Bool

-- | Test if the module comes from the home unit
isHomeModule :: HomeUnit -> Module -> Bool

-- | Test if the module comes from the home unit
isHomeInstalledModule :: GenHomeUnit u -> InstalledModule -> Bool

-- | Test if the unit-id is not the home unit-id
notHomeUnitId :: Maybe (GenHomeUnit u) -> UnitId -> Bool

-- | Test if a module doesn't come from the given home unit
notHomeModule :: HomeUnit -> Module -> Bool

-- | Test if a module doesn't come from the given home unit
notHomeModuleMaybe :: Maybe HomeUnit -> Module -> Bool

-- | Test if a module doesn't come from the given home unit
notHomeInstalledModule :: GenHomeUnit u -> InstalledModule -> Bool

-- | Test if a module doesn't come from the given home unit
notHomeInstalledModuleMaybe :: Maybe (GenHomeUnit u) -> InstalledModule -> Bool

-- | Make a module in home unit
mkHomeModule :: HomeUnit -> ModuleName -> Module

-- | Make a module in home unit
mkHomeInstalledModule :: GenHomeUnit u -> ModuleName -> InstalledModule

-- | Return the module that is used to instantiate the given home module.
--   
--   If the given module isn't a module hole, return the actual home
--   module.
--   
--   E.g., the instantiating module of <tt>p:A</tt> in <tt>p[A=q[]:B]</tt>
--   is <tt>q[]:B</tt>. the instantiating module of <tt>r:A</tt> in
--   <tt>p[A=q[]:B]</tt> is <tt>r:A</tt>. the instantiating module of
--   <tt>p:A</tt> in <tt>p</tt> is <tt>p:A</tt>. the instantiating module
--   of <tt>r:A</tt> in <tt>p</tt> is <tt>r:A</tt>.
homeModuleInstantiation :: Maybe HomeUnit -> Module -> Module

-- | Return the module that is used to instantiate the given home module
--   name. If the ModuleName doesn't refer to a signature, return the
--   actual home module.
--   
--   E.g., the instantiating module of <tt>A</tt> in <tt>p[A=q[]:B]</tt> is
--   <tt>q[]:B</tt>. the instantiating module of <tt>A</tt> in <tt>p</tt>
--   is <tt>p:A</tt>.
homeModuleNameInstantiation :: HomeUnit -> ModuleName -> Module


-- | This data structure holds an updateable environment which is used when
--   compiling module loops.
module GHC.Driver.Env.KnotVars
data KnotVars a
KnotVars :: [Module] -> (Module -> Maybe a) -> KnotVars a
[kv_domain] :: KnotVars a -> [Module]
[kv_lookup] :: KnotVars a -> Module -> Maybe a
NoKnotVars :: KnotVars a
emptyKnotVars :: KnotVars a
knotVarsFromModuleEnv :: ModuleEnv a -> KnotVars a
knotVarElems :: KnotVars a -> [a]
lookupKnotVars :: KnotVars a -> Module -> Maybe a
knotVarsWithout :: Module -> KnotVars a -> KnotVars a
instance GHC.Internal.Base.Functor GHC.Driver.Env.KnotVars.KnotVars
instance GHC.Utils.Outputable.Outputable (GHC.Driver.Env.KnotVars.KnotVars a)


-- | Source text
--   
--   Keeping Source Text for source to source conversions
module GHC.Types.SourceText
data SourceText
SourceText :: FastString -> SourceText

-- | For when code is generated, e.g. TH, deriving. The pretty printer will
--   then make its own representation of the item.
NoSourceText :: SourceText

-- | Special combinator for showing string literals.
pprWithSourceText :: SourceText -> SDoc -> SDoc

-- | Integral Literal
--   
--   Used (instead of Integer) to represent negative zegative zero which is
--   required for NegativeLiterals extension to correctly parse
--   `-0::Double` as negative zero. See also #13211.
data IntegralLit
IL :: SourceText -> Bool -> Integer -> IntegralLit
[il_text] :: IntegralLit -> SourceText
[il_neg] :: IntegralLit -> Bool
[il_value] :: IntegralLit -> Integer

-- | Fractional Literal
--   
--   Used (instead of Rational) to represent exactly the floating point
--   literal that we encountered in the user's source program. This allows
--   us to pretty-print exactly what the user wrote, which is important
--   e.g. for floating point numbers that can't represented as Doubles (we
--   used to via Double for pretty-printing). See also #2245. Note
--   [FractionalLit representation] in GHC.HsToCore.Match.Literal The
--   actual value then is: sign * fl_signi * (fl_exp_base^fl_exp) where
--   sign = if fl_neg then (-1) else 1
--   
--   For example FL { fl_neg = True, fl_signi = 5.3, fl_exp = 4,
--   fl_exp_base = Base10 } denotes -5300
data FractionalLit
FL :: SourceText -> Bool -> Rational -> Integer -> FractionalExponentBase -> FractionalLit

-- | How the value was written in the source
[fl_text] :: FractionalLit -> SourceText
[fl_neg] :: FractionalLit -> Bool
[fl_signi] :: FractionalLit -> Rational
[fl_exp] :: FractionalLit -> Integer
[fl_exp_base] :: FractionalLit -> FractionalExponentBase

-- | A String Literal in the source, including its original raw format for
--   use by source to source manipulation tools.
data StringLiteral
StringLiteral :: SourceText -> FastString -> Maybe NoCommentsLocation -> StringLiteral
[sl_st] :: StringLiteral -> SourceText
[sl_fs] :: StringLiteral -> FastString
[sl_tc] :: StringLiteral -> Maybe NoCommentsLocation
negateIntegralLit :: IntegralLit -> IntegralLit
negateFractionalLit :: FractionalLit -> FractionalLit
mkIntegralLit :: Integral a => a -> IntegralLit
mkTHFractionalLit :: Rational -> FractionalLit
rationalFromFractionalLit :: FractionalLit -> Rational

-- | The integer should already be negated if it's negative.
integralFractionalLit :: Bool -> Integer -> FractionalLit

-- | The arguments should already be negated if they are negative.
mkSourceFractionalLit :: String -> Bool -> Integer -> Integer -> FractionalExponentBase -> FractionalLit
data FractionalExponentBase
Base2 :: FractionalExponentBase
Base10 :: FractionalExponentBase
fractionalLitFromRational :: Rational -> FractionalLit
mkFractionalLit :: SourceText -> Bool -> Rational -> Integer -> FractionalExponentBase -> FractionalLit
instance GHC.Utils.Binary.Binary GHC.Types.SourceText.SourceText
instance GHC.Internal.Data.Data.Data GHC.Types.SourceText.FractionalExponentBase
instance GHC.Internal.Data.Data.Data GHC.Types.SourceText.FractionalLit
instance GHC.Internal.Data.Data.Data GHC.Types.SourceText.IntegralLit
instance GHC.Internal.Data.Data.Data GHC.Types.SourceText.SourceText
instance GHC.Internal.Data.Data.Data GHC.Types.SourceText.StringLiteral
instance GHC.Classes.Eq GHC.Types.SourceText.FractionalExponentBase
instance GHC.Classes.Eq GHC.Types.SourceText.FractionalLit
instance GHC.Classes.Eq GHC.Types.SourceText.IntegralLit
instance GHC.Classes.Eq GHC.Types.SourceText.SourceText
instance GHC.Classes.Eq GHC.Types.SourceText.StringLiteral
instance Control.DeepSeq.NFData GHC.Types.SourceText.SourceText
instance GHC.Classes.Ord GHC.Types.SourceText.FractionalExponentBase
instance GHC.Classes.Ord GHC.Types.SourceText.FractionalLit
instance GHC.Classes.Ord GHC.Types.SourceText.IntegralLit
instance GHC.Utils.Outputable.Outputable GHC.Types.SourceText.FractionalLit
instance GHC.Utils.Outputable.Outputable GHC.Types.SourceText.IntegralLit
instance GHC.Utils.Outputable.Outputable GHC.Types.SourceText.SourceText
instance GHC.Utils.Outputable.Outputable GHC.Types.SourceText.StringLiteral
instance GHC.Internal.Show.Show GHC.Types.SourceText.FractionalExponentBase
instance GHC.Internal.Show.Show GHC.Types.SourceText.FractionalLit
instance GHC.Internal.Show.Show GHC.Types.SourceText.IntegralLit
instance GHC.Internal.Show.Show GHC.Types.SourceText.SourceText

module GHC.Types.PkgQual

-- | Package-qualifier as it was parsed
data RawPkgQual

-- | No package qualifier
NoRawPkgQual :: RawPkgQual

-- | Raw package qualifier string.
RawPkgQual :: StringLiteral -> RawPkgQual

-- | Package-qualifier after renaming
--   
--   Renaming detects if "this" or the unit-id of the home-unit was used as
--   a package qualifier.
data PkgQual

-- | No package qualifier
NoPkgQual :: PkgQual

-- | Import from home-unit
ThisPkg :: !UnitId -> PkgQual

-- | Import from another unit
OtherPkg :: !UnitId -> PkgQual
instance GHC.Internal.Data.Data.Data GHC.Types.PkgQual.PkgQual
instance GHC.Internal.Data.Data.Data GHC.Types.PkgQual.RawPkgQual
instance GHC.Classes.Eq GHC.Types.PkgQual.PkgQual
instance GHC.Classes.Ord GHC.Types.PkgQual.PkgQual
instance GHC.Utils.Outputable.Outputable GHC.Types.PkgQual.PkgQual
instance GHC.Utils.Outputable.Outputable GHC.Types.PkgQual.RawPkgQual

module GHC.Types.SourceFile
data HscSource

-- | .hs file
HsSrcFile :: HscSource

-- | .hs-boot or .hsig file
HsBootOrSig :: !HsBootOrSig -> HscSource
pattern HsBootFile :: HscSource
pattern HsigFile :: HscSource
data HsBootOrSig

-- | .hs-boot file
HsBoot :: HsBootOrSig

-- | .hsig file
Hsig :: HsBootOrSig

-- | Tests if an <a>HscSource</a> is a boot file, primarily for
--   constructing elements of <tt>BuildModule</tt>. We conflate signatures
--   and modules because they are bound in the same namespace; only boot
--   interfaces can be disambiguated with `import {-# SOURCE #-}`.
hscSourceToIsBoot :: HscSource -> IsBootInterface
isHsBootOrSig :: HscSource -> Bool
isHsBootFile :: HscSource -> Bool
isHsigFile :: HscSource -> Bool
hscSourceString :: HscSource -> String
instance GHC.Utils.Binary.Binary GHC.Types.SourceFile.HscSource
instance GHC.Classes.Eq GHC.Types.SourceFile.HsBootOrSig
instance GHC.Classes.Eq GHC.Types.SourceFile.HscSource
instance GHC.Classes.Ord GHC.Types.SourceFile.HsBootOrSig
instance GHC.Classes.Ord GHC.Types.SourceFile.HscSource
instance GHC.Internal.Show.Show GHC.Types.SourceFile.HsBootOrSig
instance GHC.Internal.Show.Show GHC.Types.SourceFile.HscSource


-- | Double datatype with saner instances
module GHC.Types.SaneDouble

-- | A newtype wrapper around <a>Double</a> to ensure we never generate a
--   <a>Double</a> that becomes a <tt>NaN</tt>, see instances for details
--   on sanity.
newtype SaneDouble
SaneDouble :: Double -> SaneDouble
[unSaneDouble] :: SaneDouble -> Double
instance GHC.Utils.Binary.Binary GHC.Types.SaneDouble.SaneDouble
instance GHC.Classes.Eq GHC.Types.SaneDouble.SaneDouble
instance GHC.Internal.Real.Fractional GHC.Types.SaneDouble.SaneDouble
instance GHC.Internal.Num.Num GHC.Types.SaneDouble.SaneDouble
instance GHC.Classes.Ord GHC.Types.SaneDouble.SaneDouble
instance GHC.Internal.Show.Show GHC.Types.SaneDouble.SaneDouble


-- | <ul>
--   <li>Domain and PurposeGHC.JS.Syntax defines the Syntax for the JS
--   backend in GHC. It comports with the <a>ECMA-262</a> although not
--   every production rule of the standard is represented. Code in this
--   module is a fork of <a>JMacro</a> (BSD 3 Clause) by Gershom Bazerman,
--   heavily modified to accomodate GHC's constraints.</li>
--   <li>StrategyNothing fancy in this module, this is a classic deeply
--   embedded AST for JS. We define numerous ADTs and pattern synonyms to
--   make pattern matching and constructing ASTs easier.</li>
--   <li>ConsumersThe entire JS backend consumes this module, e.g., the
--   modules in GHC.StgToJS.*. Please see <a>Make</a> for a module which
--   provides helper functions that use the deeply embedded DSL defined in
--   this module to provide some of the benefits of a shallow
--   embedding.</li>
--   </ul>
module GHC.JS.Syntax

-- | JavaScript statements, see the <a>ECMA262 Reference</a> for details
data JStat

-- | Variable declarations: var foo [= e]
DeclStat :: !Ident -> !Maybe JExpr -> JStat

-- | Return
ReturnStat :: JExpr -> JStat

-- | If
IfStat :: JExpr -> JStat -> JStat -> JStat

-- | While, bool is "do" when True
WhileStat :: Bool -> JExpr -> JStat -> JStat

-- | For
ForStat :: JStat -> JExpr -> JStat -> JStat -> JStat

-- | For-in, bool is "each' when True
ForInStat :: Bool -> Ident -> JExpr -> JStat -> JStat

-- | Switch
SwitchStat :: JExpr -> [(JExpr, JStat)] -> JStat -> JStat

-- | Try
TryStat :: JStat -> Ident -> JStat -> JStat -> JStat

-- | Blocks
BlockStat :: [JStat] -> JStat

-- | Application
ApplStat :: JExpr -> [JExpr] -> JStat

-- | Unary operators
UOpStat :: UOp -> JExpr -> JStat

-- | Binding form: <tt><a>foo</a> <a>op</a> <a>bar</a></tt>
AssignStat :: JExpr -> AOp -> JExpr -> JStat

-- | Statement Labels, makes me nostalgic for qbasic
LabelStat :: JLabel -> JStat -> JStat

-- | Break
BreakStat :: Maybe JLabel -> JStat

-- | Continue
ContinueStat :: Maybe JLabel -> JStat

-- | an explicit function definition
FuncStat :: !Ident -> [Ident] -> JStat -> JStat

-- | JavaScript Expressions
data JExpr

-- | All values are trivially expressions
ValExpr :: JVal -> JExpr

-- | Selection: Obj.foo, see <a>.^</a>
SelExpr :: JExpr -> Ident -> JExpr

-- | Indexing: Obj[foo], see <a>.!</a>
IdxExpr :: JExpr -> JExpr -> JExpr

-- | Infix Expressions, see <a>JExpr</a> pattern synonyms
InfixExpr :: Op -> JExpr -> JExpr -> JExpr

-- | Unary Expressions
UOpExpr :: UOp -> JExpr -> JExpr

-- | If-expression
IfExpr :: JExpr -> JExpr -> JExpr -> JExpr

-- | Application
ApplExpr :: JExpr -> [JExpr] -> JExpr

-- | JavaScript values
data JVal

-- | A variable reference
JVar :: Ident -> JVal

-- | A JavaScript list, or what JS calls an Array
JList :: [JExpr] -> JVal

-- | A Double
JDouble :: SaneDouble -> JVal

-- | A BigInt
JInt :: Integer -> JVal

-- | A String
JStr :: FastString -> JVal

-- | A Regex
JRegEx :: FastString -> JVal

-- | A Boolean
JBool :: Bool -> JVal

-- | A JS HashMap: <tt>{"foo": 0}</tt>
JHash :: UniqMap FastString JExpr -> JVal

-- | A function
JFunc :: [Ident] -> JStat -> JVal

-- | JS Binary Operators. We do not deeply embed the comma operator and the
--   assignment operators
data Op

-- | Equality: <a>==</a>
EqOp :: Op

-- | Strict Equality: <tt>===</tt>
StrictEqOp :: Op

-- | InEquality: <tt>!=</tt>
NeqOp :: Op

-- | Strict InEquality <tt>!==</tt>
StrictNeqOp :: Op

-- | Greater Than: <a>&gt;</a>
GtOp :: Op

-- | Greater Than or Equal: <a>&gt;=</a>
GeOp :: Op

-- | Less Than: &lt;
LtOp :: Op

-- | Less Than or Equal: &lt;=
LeOp :: Op

-- | Addition: +
AddOp :: Op

-- | Subtraction: -
SubOp :: Op

-- | Multiplication *
MulOp :: Op

-- | Division: /
DivOp :: Op

-- | Remainder: %
ModOp :: Op

-- | Left Shift: &lt;&lt;
LeftShiftOp :: Op

-- | Right Shift: &gt;&gt;
RightShiftOp :: Op

-- | Unsigned RightShift: &gt;&gt;&gt;
ZRightShiftOp :: Op

-- | Bitwise And: &amp;
BAndOp :: Op

-- | Bitwise Or: |
BOrOp :: Op

-- | Bitwise XOr: ^
BXorOp :: Op

-- | Logical And: &amp;&amp;
LAndOp :: Op

-- | Logical Or: ||
LOrOp :: Op

-- | <pre>
--   instanceof
--   </pre>
InstanceofOp :: Op

-- | <pre>
--   in
--   </pre>
InOp :: Op

-- | JS Unary Operators
data UOp

-- | Logical Not: <tt>!</tt>
NotOp :: UOp

-- | Bitwise Not: <tt>~</tt>
BNotOp :: UOp

-- | Negation: <tt>-</tt>
NegOp :: UOp

-- | Unary Plus: <tt>+x</tt>
PlusOp :: UOp

-- | new x
NewOp :: UOp

-- | typeof x
TypeofOp :: UOp

-- | delete x
DeleteOp :: UOp

-- | yield x
YieldOp :: UOp

-- | void x
VoidOp :: UOp

-- | Prefix Increment: <tt>++x</tt>
PreIncOp :: UOp

-- | Postfix Increment: <tt>x++</tt>
PostIncOp :: UOp

-- | Prefix Decrement: <tt>--x</tt>
PreDecOp :: UOp

-- | Postfix Decrement: <tt>x--</tt>
PostDecOp :: UOp

-- | JS Unary Operators
data AOp

-- | Vanilla Assignment: =
AssignOp :: AOp

-- | Addition Assignment: +=
AddAssignOp :: AOp

-- | Subtraction Assignment: -=
SubAssignOp :: AOp

-- | A newtype wrapper around <a>FastString</a> for JS identifiers.
newtype Ident
TxtI :: FastString -> Ident
[identFS] :: Ident -> FastString

-- | A Label used for <a>JStat</a>, specifically <a>BreakStat</a>,
--   <a>ContinueStat</a> and of course <a>LabelStat</a>
type JLabel = LexicalFastString

-- | pattern synonym for a unary operator new
pattern New :: JExpr -> JExpr

-- | pattern synonym for logical not <tt>!</tt>
pattern Not :: JExpr -> JExpr

-- | pattern synonym for unary negation <tt>-</tt>
pattern Negate :: JExpr -> JExpr

-- | pattern synonym for addition <tt>+</tt>
pattern Add :: JExpr -> JExpr -> JExpr

-- | pattern synonym for subtraction <tt>-</tt>
pattern Sub :: JExpr -> JExpr -> JExpr

-- | pattern synonym for multiplication <tt>*</tt>
pattern Mul :: JExpr -> JExpr -> JExpr

-- | pattern synonym for division <tt>*</tt>
pattern Div :: JExpr -> JExpr -> JExpr

-- | pattern synonym for remainder <tt>%</tt>
pattern Mod :: JExpr -> JExpr -> JExpr

-- | pattern synonym for Bitwise Or <tt>|</tt>
pattern BOr :: JExpr -> JExpr -> JExpr

-- | pattern synonym for Bitwise And <tt>&amp;</tt>
pattern BAnd :: JExpr -> JExpr -> JExpr

-- | pattern synonym for Bitwise XOr <tt>^</tt>
pattern BXor :: JExpr -> JExpr -> JExpr

-- | pattern synonym for Bitwise Not <tt>~</tt>
pattern BNot :: JExpr -> JExpr

-- | pattern synonym for logical Or <tt>||</tt>
pattern LOr :: JExpr -> JExpr -> JExpr

-- | pattern synonym for logical And <tt>&amp;&amp;</tt>
pattern LAnd :: JExpr -> JExpr -> JExpr

-- | pattern synonym to create integer values
pattern Int :: Integer -> JExpr

-- | pattern synonym to create string values
pattern String :: FastString -> JExpr

-- | pattern synonym to create a local variable reference
pattern Var :: Ident -> JExpr

-- | pattern synonym for prefix increment <tt>++x</tt>
pattern PreInc :: JExpr -> JExpr

-- | pattern synonym for postfix increment <tt>x++</tt>
pattern PostInc :: JExpr -> JExpr

-- | pattern synonym for prefix decrement <tt>--x</tt>
pattern PreDec :: JExpr -> JExpr

-- | pattern synonym for postfix decrement <tt>--x</tt>
pattern PostDec :: JExpr -> JExpr

-- | A newtype wrapper around <a>Double</a> to ensure we never generate a
--   <a>Double</a> that becomes a <tt>NaN</tt>, see instances for details
--   on sanity.
newtype SaneDouble
SaneDouble :: Double -> SaneDouble
[unSaneDouble] :: SaneDouble -> Double

-- | construct a JS variable reference
var :: FastString -> JExpr

-- | The JS literal <tt>true</tt>
true_ :: JExpr

-- | The JS literal <tt>false</tt>
false_ :: JExpr
instance GHC.Internal.Data.Data.Data GHC.JS.Syntax.AOp
instance GHC.Internal.Data.Data.Data GHC.JS.Syntax.Op
instance GHC.Internal.Data.Data.Data GHC.JS.Syntax.UOp
instance GHC.Internal.Enum.Enum GHC.JS.Syntax.AOp
instance GHC.Internal.Enum.Enum GHC.JS.Syntax.Op
instance GHC.Internal.Enum.Enum GHC.JS.Syntax.UOp
instance GHC.Classes.Eq GHC.JS.Syntax.AOp
instance GHC.Classes.Eq GHC.JS.Syntax.JExpr
instance GHC.Classes.Eq GHC.JS.Syntax.JStat
instance GHC.Classes.Eq GHC.JS.Syntax.JVal
instance GHC.Classes.Eq GHC.JS.Syntax.Op
instance GHC.Classes.Eq GHC.JS.Syntax.UOp
instance GHC.Internal.Generics.Generic GHC.JS.Syntax.AOp
instance GHC.Internal.Generics.Generic GHC.JS.Syntax.JExpr
instance GHC.Internal.Generics.Generic GHC.JS.Syntax.JStat
instance GHC.Internal.Generics.Generic GHC.JS.Syntax.JVal
instance GHC.Internal.Generics.Generic GHC.JS.Syntax.Op
instance GHC.Internal.Generics.Generic GHC.JS.Syntax.UOp
instance GHC.Internal.Base.Monoid GHC.JS.Syntax.JStat
instance Control.DeepSeq.NFData GHC.JS.Syntax.AOp
instance Control.DeepSeq.NFData GHC.JS.Syntax.Op
instance Control.DeepSeq.NFData GHC.JS.Syntax.UOp
instance GHC.Classes.Ord GHC.JS.Syntax.AOp
instance GHC.Classes.Ord GHC.JS.Syntax.Op
instance GHC.Classes.Ord GHC.JS.Syntax.UOp
instance GHC.Internal.Base.Semigroup GHC.JS.Syntax.JStat
instance GHC.Internal.Show.Show GHC.JS.Syntax.AOp
instance GHC.Internal.Show.Show GHC.JS.Syntax.Op
instance GHC.Internal.Show.Show GHC.JS.Syntax.UOp


-- | <ul>
--   <li>Domain and PurposeGHC.JS.Ppr defines the code generation
--   facilities for the JavaScript backend. That is, this module exports a
--   function from the JS backend IR to JavaScript compliant concrete
--   syntax that can readily be executed by nodejs or called in a
--   browser.</li>
--   <li>DesignThis module follows the architecture and style of the other
--   backends in GHC: it instances Outputable for the relevant types,
--   creates a class that describes a morphism from the IR domain to
--   JavaScript concrete Syntax and then generates that syntax on a case by
--   case basis.</li>
--   <li>How to useThe key functions are <tt>renderJS</tt>,
--   <tt>jsToDoc</tt>, and the <tt>RenderJS</tt> record. Use the
--   <tt>RenderJS</tt> record and <tt>jsToDoc</tt> to define a custom
--   renderers for specific parts of the backend, for example in <a>Opt</a>
--   a custom renderer ensures all <tt>Ident</tt> generated by the linker
--   optimization pass are prefixed differently than the default. Use
--   <tt>renderJS</tt> to generate JavaScript concrete syntax in the
--   general case, suitable for human consumption.</li>
--   </ul>
module GHC.JS.Ppr

-- | Render a syntax tree as a pretty-printable document (simply showing
--   the resultant doc produces a nice, well formatted String).
renderJs :: JsToDoc a => a -> SDoc

-- | Render a syntax tree as a pretty-printable document, using a given
--   prefix to all generated names. Use this with distinct prefixes to
--   ensure distinct generated names between independent calls to
--   render(Prefix)Js.
renderPrefixJs :: JsToDoc a => a -> SDoc
renderPrefixJs' :: (JsToDoc a, JsRender doc) => RenderJs doc -> a -> doc
class JsToDoc a
jsToDocR :: (JsToDoc a, JsRender doc) => RenderJs doc -> a -> doc
defaultRenderJs :: RenderJs doc
data RenderJs doc
RenderJs :: !JsRender doc => RenderJs doc -> JStat -> doc -> !JsRender doc => RenderJs doc -> JExpr -> doc -> !JsRender doc => RenderJs doc -> JVal -> doc -> !JsRender doc => RenderJs doc -> Ident -> doc -> RenderJs doc
[renderJsS] :: RenderJs doc -> !JsRender doc => RenderJs doc -> JStat -> doc
[renderJsE] :: RenderJs doc -> !JsRender doc => RenderJs doc -> JExpr -> doc
[renderJsV] :: RenderJs doc -> !JsRender doc => RenderJs doc -> JVal -> doc
[renderJsI] :: RenderJs doc -> !JsRender doc => RenderJs doc -> Ident -> doc

-- | JsRender controls the differences in whitespace between HLine and
--   SDoc. Generally, this involves the indentation and newlines in the
--   human-readable SDoc implementation being replaced in the HLine version
--   by the minimal whitespace required for valid JavaScript syntax.
class IsLine doc => JsRender doc

-- | Concatenate with an optional single space
(<+?>) :: JsRender doc => doc -> doc -> doc

-- | Concatenate with an optional newline
($$$) :: JsRender doc => doc -> doc -> doc

-- | Concatenate these <tt>doc</tt>s, either vertically (SDoc) or
--   horizontally (HLine)
jcat :: JsRender doc => [doc] -> doc

-- | Optionally indent the following
jnest :: JsRender doc => doc -> doc

-- | Append semi-colon (and line-break in HLine mode)
addSemi :: JsRender doc => doc -> doc
jsToDoc :: JsToDoc a => a -> SDoc
pprStringLit :: IsLine doc => FastString -> doc
interSemi :: JsRender doc => [doc] -> doc

-- | The structure `{body}`, optionally indented over multiple lines
braceNest :: JsRender doc => doc -> doc

-- | The structure `hdr {body}`, optionally indented over multiple lines
hangBrace :: JsRender doc => doc -> doc -> doc
instance GHC.JS.Ppr.JsRender GHC.Utils.Outputable.HLine
instance GHC.JS.Ppr.JsRender GHC.Utils.Outputable.SDoc
instance GHC.JS.Ppr.JsToDoc GHC.JS.Ident.Ident
instance GHC.JS.Ppr.JsToDoc GHC.JS.Syntax.JExpr
instance GHC.JS.Ppr.JsToDoc GHC.JS.Syntax.JStat
instance GHC.JS.Ppr.JsToDoc GHC.JS.Syntax.JVal
instance GHC.JS.Ppr.JsToDoc [GHC.JS.Syntax.JExpr]
instance GHC.JS.Ppr.JsToDoc [GHC.JS.Syntax.JStat]
instance GHC.Utils.Outputable.Outputable GHC.JS.Syntax.JExpr
instance GHC.Utils.Outputable.Outputable GHC.JS.Syntax.JVal


-- | Optimization pass at link time
module GHC.StgToJS.Linker.Opt
pretty :: JsRender doc => Bool -> JStat -> doc

-- | Render JS with code size minimization enabled
optRenderJs :: RenderJs doc


module GHC.JS.Opt.Expr
optExprs :: JStat -> JStat


-- | <ul>
--   <li>Simple optimizer for the JavaScript IRThis is a simple optimizer
--   for the JavaScript IR. It is intended to be the first optimization
--   pass after generating the JavaScript IR.</li>
--   <li>DesignThe optimizer is invoked on the top-level JStat. It leaves
--   the top-level scope alone, but traverses into each function body and
--   optimizes it. Nested functions are mostly left alone, since they are
--   uncommon in generated code.The optimizations are:<ul><li>rename local
--   variables to shorter names</li><li>remove unused
--   variables</li><li>remove trivial assignments: x = x</li><li>"float"
--   expressions without side effects:</li><li>var x = 1; var y = x + 1;
--   -&gt; var y = 1 + 1;</li></ul></li>
--   <li>LimitationsThe simple optimization pass is intended to be fast and
--   applicable to almost all generated JavaScript code. Limitations
--   are:<ul><li>optimization is disabled if an <tt>eval</tt> statement is
--   encountered</li><li>variables declared in nested scopes are not
--   renamed</li></ul></li>
--   </ul>
module GHC.JS.Opt.Simple
simpleOpt :: JStat -> JStat
instance GHC.Classes.Eq GHC.JS.Opt.Simple.Multiplicity
instance GHC.Classes.Eq GHC.JS.Opt.Simple.VarDecl
instance GHC.Internal.Base.Monoid GHC.JS.Opt.Simple.Multiplicity
instance GHC.Internal.Base.Monoid GHC.JS.Opt.Simple.VarUsage
instance GHC.Internal.Base.Monoid GHC.JS.Opt.Simple.VarValue
instance GHC.Classes.Ord GHC.JS.Opt.Simple.Multiplicity
instance GHC.Classes.Ord GHC.JS.Opt.Simple.VarDecl
instance GHC.Internal.Base.Semigroup GHC.JS.Opt.Simple.Multiplicity
instance GHC.Internal.Base.Semigroup GHC.JS.Opt.Simple.VarDecl
instance GHC.Internal.Base.Semigroup GHC.JS.Opt.Simple.VarUsage
instance GHC.Internal.Base.Semigroup GHC.JS.Opt.Simple.VarValue
instance GHC.Internal.Show.Show GHC.JS.Opt.Simple.Multiplicity
instance GHC.Internal.Show.Show GHC.JS.Opt.Simple.VarDecl


-- | <ul>
--   <li>Domain and PurposeGHC.JS.Optimizer is a shallow embedding of a
--   peephole optimizer. That is, this module defines transformations over
--   the JavaScript IR in <a>Syntax</a>, transforming the IR forms from
--   inefficient, or non-idiomatic, JavaScript to more efficient and
--   idiomatic JavaScript. The optimizer is written in continuation passing
--   style so optimizations compose.</li>
--   <li>Architecture of the optimizer</li>
--   </ul>
--   
--   The design is that each optimization pattern matches on the head of a
--   block by pattern matching onto the head of the stream of nodes in the
--   JavaScript IR. If an optimization gets a successful match then it
--   performs whatever rewrite is necessary and then calls the <a>loop</a>
--   continuation. This ensures that the result of the optimization is
--   subject to the same optimization, <i>and</i> the rest of the
--   optimizations. If there is no match then the optimization should call
--   the <tt>next</tt> continuation to pass the stream to the next
--   optimization in the optimization chain. We then define the last
--   "optimization" to be <tt>tailLoop</tt> which selects the next block of
--   code to optimize and begin the optimization pipeline again.
module GHC.JS.Optimizer
jsOptimize :: JStat -> JStat
instance GHC.Internal.Base.Monoid GHC.JS.Optimizer.BlockOpt
instance GHC.Internal.Base.Semigroup GHC.JS.Optimizer.BlockOpt


-- | <ul>
--   <li>Domain and PurposeGHC.JS.JStg.Syntax defines the eDSL that the JS
--   backend's runtime system is written in. Nothing fancy, its just a
--   straightforward deeply embedded DSL.In general, one should not use
--   these constructors explicitly in the JS backend. Instead, prefer using
--   the combinators in GHC.JS.Make, if those are suitable then prefer
--   using the patterns exported from this module</li>
--   </ul>
module GHC.JS.JStg.Syntax

-- | JavaScript statements, see the <a>ECMA262 Reference</a> for details
data JStgStat

-- | Variable declarations: var foo [= e]
DeclStat :: !Ident -> !Maybe JStgExpr -> JStgStat

-- | Return
ReturnStat :: JStgExpr -> JStgStat

-- | If
IfStat :: JStgExpr -> JStgStat -> JStgStat -> JStgStat

-- | While, bool is "do" when True
WhileStat :: Bool -> JStgExpr -> JStgStat -> JStgStat

-- | For
ForStat :: JStgStat -> JStgExpr -> JStgStat -> JStgStat -> JStgStat

-- | For-in, bool is "each' when True
ForInStat :: Bool -> Ident -> JStgExpr -> JStgStat -> JStgStat

-- | Switch
SwitchStat :: JStgExpr -> [(JStgExpr, JStgStat)] -> JStgStat -> JStgStat

-- | Try
TryStat :: JStgStat -> Ident -> JStgStat -> JStgStat -> JStgStat

-- | Blocks
BlockStat :: [JStgStat] -> JStgStat

-- | Application
ApplStat :: JStgExpr -> [JStgExpr] -> JStgStat

-- | Unary operators
UOpStat :: UOp -> JStgExpr -> JStgStat

-- | Binding form: <tt>foo = bar</tt>
AssignStat :: JStgExpr -> AOp -> JStgExpr -> JStgStat

-- | Statement Labels, makes me nostalgic for qbasic
LabelStat :: JsLabel -> JStgStat -> JStgStat

-- | Break
BreakStat :: Maybe JsLabel -> JStgStat

-- | Continue
ContinueStat :: Maybe JsLabel -> JStgStat

-- | an explicit function definition
FuncStat :: !Ident -> [Ident] -> JStgStat -> JStgStat

-- | JavaScript Expressions
data JStgExpr

-- | All values are trivially expressions
ValExpr :: JVal -> JStgExpr

-- | Selection: Obj.foo, see <a>.^</a>
SelExpr :: JStgExpr -> Ident -> JStgExpr

-- | Indexing: Obj[foo], see <a>.!</a>
IdxExpr :: JStgExpr -> JStgExpr -> JStgExpr

-- | Infix Expressions, see <a>JStgExpr</a> pattern synonyms
InfixExpr :: Op -> JStgExpr -> JStgExpr -> JStgExpr

-- | Unary Expressions
UOpExpr :: UOp -> JStgExpr -> JStgExpr

-- | If-expression
IfExpr :: JStgExpr -> JStgExpr -> JStgExpr -> JStgExpr

-- | Application
ApplExpr :: JStgExpr -> [JStgExpr] -> JStgExpr

-- | JavaScript values
data JVal

-- | A variable reference
JVar :: Ident -> JVal

-- | A JavaScript list, or what JS calls an Array
JList :: [JStgExpr] -> JVal

-- | A Double
JDouble :: SaneDouble -> JVal

-- | A BigInt
JInt :: Integer -> JVal

-- | A String
JStr :: FastString -> JVal

-- | A Regex
JRegEx :: FastString -> JVal

-- | A Boolean
JBool :: Bool -> JVal

-- | A JS HashMap: <tt>{"foo": 0}</tt>
JHash :: UniqMap FastString JStgExpr -> JVal

-- | A function
JFunc :: [Ident] -> JStgStat -> JVal

-- | JS Binary Operators. We do not deeply embed the comma operator and the
--   assignment operators
data Op

-- | Equality: <a>==</a>
EqOp :: Op

-- | Strict Equality: <tt>===</tt>
StrictEqOp :: Op

-- | InEquality: <tt>!=</tt>
NeqOp :: Op

-- | Strict InEquality <tt>!==</tt>
StrictNeqOp :: Op

-- | Greater Than: <a>&gt;</a>
GtOp :: Op

-- | Greater Than or Equal: <a>&gt;=</a>
GeOp :: Op

-- | Less Than: &lt;
LtOp :: Op

-- | Less Than or Equal: &lt;=
LeOp :: Op

-- | Addition: +
AddOp :: Op

-- | Subtraction: -
SubOp :: Op

-- | Multiplication *
MulOp :: Op

-- | Division: /
DivOp :: Op

-- | Remainder: %
ModOp :: Op

-- | Left Shift: &lt;&lt;
LeftShiftOp :: Op

-- | Right Shift: &gt;&gt;
RightShiftOp :: Op

-- | Unsigned RightShift: &gt;&gt;&gt;
ZRightShiftOp :: Op

-- | Bitwise And: &amp;
BAndOp :: Op

-- | Bitwise Or: |
BOrOp :: Op

-- | Bitwise XOr: ^
BXorOp :: Op

-- | Logical And: &amp;&amp;
LAndOp :: Op

-- | Logical Or: ||
LOrOp :: Op

-- | <pre>
--   instanceof
--   </pre>
InstanceofOp :: Op

-- | <pre>
--   in
--   </pre>
InOp :: Op

-- | JS Unary Operators
data AOp

-- | Vanilla Assignment: =
AssignOp :: AOp

-- | Addition Assignment: +=
AddAssignOp :: AOp

-- | Subtraction Assignment: -=
SubAssignOp :: AOp

-- | JS Unary Operators
data UOp

-- | Logical Not: <tt>!</tt>
NotOp :: UOp

-- | Bitwise Not: <tt>~</tt>
BNotOp :: UOp

-- | Negation: <tt>-</tt>
NegOp :: UOp

-- | Unary Plus: <tt>+x</tt>
PlusOp :: UOp

-- | new x
NewOp :: UOp

-- | typeof x
TypeofOp :: UOp

-- | delete x
DeleteOp :: UOp

-- | yield x
YieldOp :: UOp

-- | void x
VoidOp :: UOp

-- | Prefix Increment: <tt>++x</tt>
PreIncOp :: UOp

-- | Postfix Increment: <tt>x++</tt>
PostIncOp :: UOp

-- | Prefix Decrement: <tt>--x</tt>
PreDecOp :: UOp

-- | Postfix Decrement: <tt>x--</tt>
PostDecOp :: UOp

-- | A Label used for <a>JStgStat</a>, specifically <a>BreakStat</a>,
--   <a>ContinueStat</a> and of course <a>LabelStat</a>
type JsLabel = LexicalFastString

-- | pattern synonym for a unary operator new
pattern New :: JStgExpr -> JStgExpr

-- | pattern synonym for logical not <tt>!</tt>
pattern Not :: JStgExpr -> JStgExpr

-- | pattern synonym for unary negation <tt>-</tt>
pattern Negate :: JStgExpr -> JStgExpr

-- | pattern synonym for addition <tt>+</tt>
pattern Add :: JStgExpr -> JStgExpr -> JStgExpr

-- | pattern synonym for subtraction <tt>-</tt>
pattern Sub :: JStgExpr -> JStgExpr -> JStgExpr

-- | pattern synonym for multiplication <tt>*</tt>
pattern Mul :: JStgExpr -> JStgExpr -> JStgExpr

-- | pattern synonym for division <tt>*</tt>
pattern Div :: JStgExpr -> JStgExpr -> JStgExpr

-- | pattern synonym for remainder <tt>%</tt>
pattern Mod :: JStgExpr -> JStgExpr -> JStgExpr

-- | pattern synonym for Bitwise Or <tt>|</tt>
pattern BOr :: JStgExpr -> JStgExpr -> JStgExpr

-- | pattern synonym for Bitwise And <tt>&amp;</tt>
pattern BAnd :: JStgExpr -> JStgExpr -> JStgExpr

-- | pattern synonym for Bitwise XOr <tt>^</tt>
pattern BXor :: JStgExpr -> JStgExpr -> JStgExpr

-- | pattern synonym for Bitwise Not <tt>~</tt>
pattern BNot :: JStgExpr -> JStgExpr

-- | pattern synonym for logical Or <tt>||</tt>
pattern LOr :: JStgExpr -> JStgExpr -> JStgExpr

-- | pattern synonym for logical And <tt>&amp;&amp;</tt>
pattern LAnd :: JStgExpr -> JStgExpr -> JStgExpr

-- | pattern synonym to create integer values
pattern Int :: Integer -> JStgExpr

-- | pattern synonym to create string values
pattern String :: FastString -> JStgExpr

-- | pattern synonym to create a local variable reference
pattern Var :: Ident -> JStgExpr

-- | pattern synonym for prefix increment <tt>++x</tt>
pattern PreInc :: JStgExpr -> JStgExpr

-- | pattern synonym for postfix increment <tt>x++</tt>
pattern PostInc :: JStgExpr -> JStgExpr

-- | pattern synonym for prefix decrement <tt>--x</tt>
pattern PreDec :: JStgExpr -> JStgExpr

-- | pattern synonym for postfix decrement <tt>--x</tt>
pattern PostDec :: JStgExpr -> JStgExpr

-- | A newtype wrapper around <a>Double</a> to ensure we never generate a
--   <a>Double</a> that becomes a <tt>NaN</tt>, see instances for details
--   on sanity.
newtype SaneDouble
SaneDouble :: Double -> SaneDouble
[unSaneDouble] :: SaneDouble -> Double

-- | pattern synonym to create an anonymous function
pattern Func :: [Ident] -> JStgStat -> JStgExpr

-- | construct a JS reference, intended to refer to a global name
global :: FastString -> JStgExpr

-- | construct a JS reference, intended to refer to a local name
local :: FastString -> JStgExpr
instance GHC.Internal.Data.Data.Data GHC.JS.JStg.Syntax.AOp
instance GHC.Internal.Data.Data.Data GHC.JS.JStg.Syntax.Op
instance GHC.Internal.Data.Data.Data GHC.JS.JStg.Syntax.UOp
instance GHC.Internal.Enum.Enum GHC.JS.JStg.Syntax.AOp
instance GHC.Internal.Enum.Enum GHC.JS.JStg.Syntax.Op
instance GHC.Internal.Enum.Enum GHC.JS.JStg.Syntax.UOp
instance GHC.Classes.Eq GHC.JS.JStg.Syntax.AOp
instance GHC.Classes.Eq GHC.JS.JStg.Syntax.JStgExpr
instance GHC.Classes.Eq GHC.JS.JStg.Syntax.JStgStat
instance GHC.Classes.Eq GHC.JS.JStg.Syntax.JVal
instance GHC.Classes.Eq GHC.JS.JStg.Syntax.Op
instance GHC.Classes.Eq GHC.JS.JStg.Syntax.UOp
instance GHC.Internal.Generics.Generic GHC.JS.JStg.Syntax.AOp
instance GHC.Internal.Generics.Generic GHC.JS.JStg.Syntax.JStgExpr
instance GHC.Internal.Generics.Generic GHC.JS.JStg.Syntax.JStgStat
instance GHC.Internal.Generics.Generic GHC.JS.JStg.Syntax.JVal
instance GHC.Internal.Generics.Generic GHC.JS.JStg.Syntax.Op
instance GHC.Internal.Generics.Generic GHC.JS.JStg.Syntax.UOp
instance GHC.Internal.Base.Monoid GHC.JS.JStg.Syntax.JStgStat
instance Control.DeepSeq.NFData GHC.JS.JStg.Syntax.AOp
instance Control.DeepSeq.NFData GHC.JS.JStg.Syntax.Op
instance Control.DeepSeq.NFData GHC.JS.JStg.Syntax.UOp
instance GHC.Classes.Ord GHC.JS.JStg.Syntax.AOp
instance GHC.Classes.Ord GHC.JS.JStg.Syntax.Op
instance GHC.Classes.Ord GHC.JS.JStg.Syntax.UOp
instance GHC.Utils.Outputable.Outputable GHC.JS.JStg.Syntax.JStgExpr
instance GHC.Internal.Base.Semigroup GHC.JS.JStg.Syntax.JStgStat
instance GHC.Internal.Show.Show GHC.JS.JStg.Syntax.AOp
instance GHC.Internal.Show.Show GHC.JS.JStg.Syntax.Op
instance GHC.Internal.Show.Show GHC.JS.JStg.Syntax.UOp


-- | JS symbol generation
module GHC.StgToJS.Symbols

-- | Hexadecimal representation of an int
--   
--   Used for the sub indices.
intBS :: Int -> ByteString

-- | Hexadecimal representation of a 64-bit word
--   
--   Used for uniques. We could use base-62 as GHC usually does but this is
--   likely faster.
word64BS :: Word64 -> ByteString

-- | Return z-encoded unit:module
unitModuleStringZ :: Module -> ByteString

-- | the global linkable unit of a module exports this symbol, depend on it
--   to include that unit (used for cost centres)
moduleGlobalSymbol :: Module -> FastString
moduleExportsSymbol :: Module -> FastString

-- | Make JS symbol corresponding to the given Haskell symbol in the given
--   module
mkJsSymbolBS :: Bool -> Module -> FastString -> ByteString

-- | Make JS symbol corresponding to the given Haskell symbol in the given
--   module
mkJsSymbol :: Bool -> Module -> FastString -> FastString

-- | Make JS symbol for given module and unique.
mkFreshJsSymbol :: Module -> Int -> FastString

-- | Make symbol "h$XYZ" or "h$$XYZ"
mkRawSymbol :: Bool -> FastString -> FastString

-- | "h$$" constant string
hddB :: ByteString

-- | "h$" constant string
hdB :: ByteString
hd :: JStgExpr
hdStr :: FastString
hdlB :: ByteString
hdApply :: JStgExpr
hdApplyStr :: FastString
hdMoveRegs2 :: FastString
hdPapGen :: JStgExpr
hdPapGenStr :: FastString
hdSetReg :: JStgExpr
hdSetRegStr :: FastString
hdGetReg :: JStgExpr
hdGetRegStr :: FastString
hdResetRegisters :: Ident
hdResetResultVars :: Ident
hdInitClosure :: FastString
hdRegs :: JStgExpr
hdRegsStr :: Ident
hdReturn :: JStgExpr
hdReturnStr :: Ident
hdStack :: JStgExpr
hdStackStr :: Ident
hdStackPtr :: JStgExpr
hdStackPtrStr :: Ident
hdBlackHoleTrap :: JStgExpr
hdBlackHoleTrapStr :: Ident
hdBlockOnBlackHoleStr :: FastString
hdBlackHoleLNE :: JStgExpr
hdBlackHoleLNEStr :: Ident
hdClosureTypeName :: JStgExpr
hdClosureTypeNameStr :: Ident
hdBh :: JStgExpr
hdBhStr :: FastString
hdBlackHole :: JStgExpr
hdBlackHoleStr :: Ident
hdUpdFrame :: JStgExpr
hdUpdFrameStr :: Ident
hdCSel :: JStgExpr
hdCSelStr :: FastString
hdEntry :: Ident
hdEntryStr :: FastString
hdApGen :: JStgExpr
hdApGenStr :: Ident
hdApGenFastStr :: Ident
hdLog :: JStgExpr
hdLogStr :: FastString
hdMkFunctionPtr :: JStgExpr
hdInitStatic :: JStgExpr
hdInitStaticStr :: Ident
hdHsSptInsert :: JStgExpr
hdCurrentThread :: JStgExpr
hdCurrentThreadStr :: Ident
hdWakeupThread :: FastString
hdPaps :: JStgExpr
hdPapsStr :: FastString
hdPapStr_ :: FastString
hdLazyEntryStr :: Ident
hdUnboxEntry :: JStgExpr
hdUnboxEntryStr :: Ident
hdMaskFrame :: JStgExpr
hdMaskFrameStr :: Ident
hdUnMaskFrameStr :: Ident
hdReturnF :: JStgExpr
hdReturnFStr :: Ident
hdResumeEntryStr :: Ident
hdFlushStdout :: JStgExpr
hdFlushStdoutStr :: Ident
hdFlushStdoutEntry :: JStgExpr
hdFlushStdoutEntryStr :: Ident
hdRunIOEntry :: JStgExpr
hdRunIOEntryStr :: Ident
hdReduce :: JStgExpr
hdReduceStr :: Ident
hdThrowStr :: FastString
hdRaiseAsyncFrame :: JStgExpr
hdRaiseAsyncFrameStr :: Ident
hdRaiseAsyncEntry :: JStgExpr
hdRaiseAsyncEntryStr :: Ident
hdRaiseEntry :: JStgExpr
hdRaiseEntryStr :: Ident
hdKeepAliveEntry :: JStgExpr
hdKeepAliveEntryStr :: Ident
hdSelect2Return :: JStgExpr
hdSelect2ReturnStr :: Ident
hdSelect2Entry :: JStgExpr
hdSelect2EntryStr :: Ident
hdSelect1Ret :: JStgExpr
hdSelect1RetStr :: Ident
hdSelect1EntryStr :: Ident
hdStaticThunkStr :: FastString
hdStaticThunksStr :: Ident
hdStaticThunksArrStr :: Ident
hdCAFsStr :: Ident
hdCAFsResetStr :: Ident
hdUpdThunkEntryStr :: Ident
hdAp3EntryStr :: Ident
hdAp2EntryStr :: Ident
hdAp1EntryStr :: Ident
hdDataToTagEntryStr :: Ident
hdTagToEnum :: FastString
hdCatchEntryStr :: Ident
hdNoopStr :: Ident
hdNoopEntry :: JStgExpr
hdNoopEntryStr :: Ident
hdC0 :: JStgExpr
hdC :: JStgExpr
hdC0Str :: Ident
hdCStr :: Ident
hdData2Entry :: Ident
hdData1Entry :: Ident
hdTrueEntry :: Ident
hdFalseEntry :: Ident
hdDoneMainEntry :: JStgExpr
hdDoneMainEntryStr :: Ident
hdDoneMain :: JStgExpr
hdDone :: Ident
hdExitProcess :: FastString
hdTraceAlloc :: FastString
hdDebugAllocNotifyAlloc :: FastString
hdRtsTraceForeign :: Ident
hdRtsProfiling :: Ident
hdCtFun :: Ident
hdCtCon :: Ident
hdCtThunk :: Ident
hdCtPap :: Ident
hdCtBlackhole :: Ident
hdCtStackFrame :: Ident
hdCtVtPtr :: Ident
hdVtVoid :: Ident
hdVtInt :: Ident
hdVtDouble :: Ident
hdVtLong :: Ident
hdVtAddr :: Ident
hdVtObj :: Ident
hdVtArr :: Ident
hdLoads :: Array Int Ident
hdAp00 :: JStgExpr
hdAp00Str :: Ident
hdAp00FastStr :: FastString
hdAp11Fast :: FastString
hdAp10 :: JStgExpr
hdAp33FastStr :: FastString
hdAp22FastStr :: FastString
hdNewByteArrayStr :: FastString
hdCopyMutableByteArrayStr :: FastString
hdCheckOverlapByteArrayStr :: FastString
hdShrinkMutableCharArrayStr :: FastString
hdTraceEventStr :: FastString
hdTraceEventBinaryStr :: FastString
hdTraceMarkerStr :: FastString
hdThrowJSException :: JStgExpr
hdUnboxFFIResult :: JStgExpr
hdUnboxFFIResultStr :: Ident
hdMkForeignCallback :: JStgExpr
hdTraceForeign :: JStgExpr
hdBuildObject :: JStgExpr
hdBuildObjectStr :: FastString
hdCallDynamicStr :: FastString
except :: JStgExpr
exceptStr :: Ident
excepStr :: FastString
mv :: FastString
lngth :: FastString

-- | only for byte arrays. This is a JS byte array method
len :: FastString
slice :: FastString
this :: JStgExpr
arr :: FastString
dv :: FastString
d1 :: JStgExpr
d2 :: JStgExpr
d3 :: JStgExpr
d1Str :: FastString
d2Str :: FastString
d3Str :: FastString
getInt16 :: FastString
getUint16 :: FastString
getInt32 :: FastString
getUint32 :: FastString
getFloat32 :: FastString
getFloat64 :: FastString
setInt16 :: FastString
setUint16 :: FastString
setInt32 :: FastString
setUint32 :: FastString
setFloat32 :: FastString
setFloat64 :: FastString
i3 :: FastString
u8 :: FastString
u1 :: FastString
f6 :: FastString
f3 :: FastString
val :: FastString
label :: FastString
mask :: FastString
unMask :: FastString
resume :: FastString
f :: FastString
n :: FastString
hasOwnProperty :: FastString
hdCollectProps :: FastString
replace :: FastString
substring :: FastString
trace :: FastString
apply :: FastString
hdMVar :: JStgExpr
hdMVarStr :: FastString
hdTakeMVar :: JStgExpr
hdTakeMVarStr :: FastString
hdTryTakeMVarStr :: FastString
hdPutMVarStr :: FastString
hdTryPutMVarStr :: FastString
hdNewTVar :: FastString
hdReadTVar :: FastString
hdReadTVarIO :: FastString
hdWriteTVar :: FastString
hdReadMVarStr :: FastString
hdStmRemoveBlockedThreadStr :: FastString
hdStmStartTransactionStr :: FastString
hdAtomicallyEntry :: JStgExpr
hdAtomicallyEntryStr :: Ident
hdAtomicallyStr :: FastString
hdStgResumeRetryEntry :: JStgExpr
hdStgResumeRetryEntryStr :: Ident
hdStmCommitTransactionStr :: FastString
hdStmValidateTransactionStr :: FastString
hdStmCatchRetryEntry :: JStgExpr
hdStmCatchRetryEntryStr :: Ident
hdStmRetryStr :: FastString
hdStmCatchRetryStr :: FastString
hdStmCatchEntry :: JStgExpr
hdCatchStmStr :: FastString
hdStmCatchEntryStr :: Ident
hdRetryInterrupted :: JStgExpr
hdRetryInterruptedStr :: Ident
hdMaskUnintFrame :: JStgExpr
hdMaskUnintFrameStr :: Ident
hdReschedule :: JStgExpr
hdRescheduleStr :: Ident
hdRestoreThread :: JStgExpr
hdRestoreThreadStr :: Ident
hdFinishedThread :: FastString
hdPrimOpStr :: FastString
wrapperColonStr :: FastString
hdInternalExceptionTypeDivZero :: JStgExpr
hdInternalExceptionTypeOverflow :: JStgExpr
hdInternalExceptionTypeUnderflow :: JStgExpr
hdInternalExceptionControlExceptionBaseNonTermination :: JStgExpr
hdGhcInternalIOHandleFlush :: JStgExpr
hdGhcInternalIOHandleFDStdout :: JStgExpr
hdGhcInternalJSPrimValConEntryStr :: FastString
hdBuildCCSPtrStr :: FastString
hdClearCCSStr :: FastString
hdRestoreCCSStr :: FastString
hdSetCcsEntry :: JStgExpr
hdSetCcsEntryStr :: Ident
ccStr :: FastString
unknown :: FastString
typeof :: FastString
hdRawStr :: FastString
throwStr :: FastString
hdCheckObj :: JStgExpr
console :: JStgExpr
consoleStr :: FastString
arguments :: JStgExpr
argumentsStr :: FastString
hdReportHeapOverflow :: JStgExpr
hdReportHeapOverflowStr :: Ident
hdReportStackOverflow :: JStgExpr
hdReportStackOverflowStr :: Ident
hdDumpRes :: JStgExpr
hdDumpResStr :: Ident
ghcjsArray :: FastString
hdCompactSize :: FastString
hdCompactAddWithSharing :: FastString
hdCompactAdd :: FastString
hdCompactFixupPointers :: FastString
hdCompactAllocateBlock :: FastString
hdCompactGetNextBlock :: FastString
hdCompactGetFirstBlock :: FastString
hdCompactContainsAny :: FastString
hdCompactContains :: FastString
hdCompactResize :: FastString
hdCompactNew :: FastString
hdStableNameInt :: FastString
hdMakeStableName :: FastString
hdDeRefStablePtr :: FastString
hdStablePtrBuf :: JStgExpr
hdMakeStablePtrStr :: FastString
hdKeepAlive :: FastString
hdFinalizeWeak :: FastString
hdMakeWeakNoFinalizer :: FastString
hdMakeWeak :: FastString
hdGetThreadLabel :: FastString
hdListThreads :: FastString
hdThreadStatus :: FastString
hdYield :: FastString
hdKillThread :: FastString
hdFork :: FastString
hdWaitWrite :: FastString
hdWaitRead :: FastString
hdDelayThread :: FastString
hdCatchStr :: FastString
hdMaskAsyncStr :: FastString
hdMaskUnintAsyncStr :: FastString
hdUnmaskAsyncStr :: FastString
hdMutVarStr :: FastString
hdAtomicModifyMutVar2Str :: FastString
hdAtomicModifyMutVarStr :: FastString
hdComparePointerStr :: FastString
hdCompareByteArraysStr :: FastString
hdResizeMutableByteArrayStr :: FastString
hdShrinkMutableByteArrayStr :: FastString
hdCopyMutableArrayStr :: FastString
hdNewArrayStr :: FastString
hdSliceArrayStr :: FastString
hdDecodeFloatIntStr :: FastString
hdCastFloatToWord32Str :: FastString
hdCastWord32ToFloatStr :: FastString
hdDecodeDouble2IntStr :: FastString
hdDecodeDoubleInt64Str :: FastString
hdCastDoubleToWord64Str :: FastString
hdCastWord64ToDoubleStr :: FastString
hdReverseWordStr :: FastString
hdClz8Str :: FastString
hdClz16Str :: FastString
hdClz32Str :: FastString
hdClz64Str :: FastString
hdCtz8Str :: FastString
hdCtz16Str :: FastString
hdCtz32Str :: FastString
hdCtz64Str :: FastString
hdBSwap64Str :: FastString
hdPExit8Str :: FastString
hdPExit16Str :: FastString
hdPExit32Str :: FastString
hdPExit64Str :: FastString
hdPDep8Str :: FastString
hdPDep16Str :: FastString
hdPDep32Str :: FastString
hdPDep64Str :: FastString
hdPopCntTab :: JStgExpr
hdPopCnt32Str :: FastString
hdPopCnt64Str :: FastString
hdQuotRem2Word32Str :: FastString
hdQuotRemWord32Str :: FastString
hdRemWord32Str :: FastString
hdQuotWord32Str :: FastString
hdMul2Word32Str :: FastString
hdMulImulStr :: FastString
hdWordAdd2 :: FastString
hdHsPlusWord64Str :: FastString
hdHsMinusWord64Str :: FastString
hdHsTimesWord64Str :: FastString
hdHsQuotWord64Str :: FastString
hdHsRemWord64Str :: FastString
hdHsUncheckedShiftRWord64Str :: FastString
hdHsUncheckedShiftLWord64Str :: FastString
hdHsPlusInt64Str :: FastString
hdHsMinusInt64Str :: FastString
hdHsTimesInt64Str :: FastString
hdHsQuotInt64Str :: FastString
hdHsRemInt64Str :: FastString
hdHsUncheckedShiftLLInt64Str :: FastString
hdHsUncheckedShiftRAInt64Str :: FastString
hdHsUncheckedShiftRLInt64Str :: FastString
hdHsTimesInt2Str :: FastString
hdEncodeModifiedUtf8Str :: FastString
hdRawStringDataStr :: FastString
hdPStr :: FastString
hdDStr :: FastString
hdDiStr :: FastString
hdStcStr :: FastString
hdStlStr :: FastString
hdStiStr :: FastString
hdStrStr :: FastString

module GHC.JS.Transform
identsS :: JStgStat -> [Ident]
identsV :: JVal -> [Ident]
identsE :: JStgExpr -> [Ident]
jStgExprToJS :: JStgExpr -> JExpr
jStgStatToJS :: JStgStat -> JStat


-- | <ul>
--   <li>Domain and PurposeGHC.JS.Make defines helper functions to ease the
--   creation of JavaScript ASTs as defined in <a>Syntax</a>. Its purpose
--   is twofold: make the EDSL more ergonomic to program in, and make
--   errors in the EDSL <i>look</i> obvious because the EDSL is untyped. It
--   is primarily concerned with injecting terms into the domain of the
--   EDSL to construct JS programs in Haskell.</li>
--   <li>StrategyThe strategy for this module comes straight from gentzen;
--   where we have two types of helper functions. Functions which inject
--   terms into the EDSL, and combinator functions which operate on terms
--   in the EDSL to construct new terms in the EDSL. Crucially, missing
--   from this module are corresponding <i>elimination</i> or
--   <i>destructing</i> functions which would project information from the
--   EDSL back to Haskell. See <a>Utils</a> for such
--   functions.<ul><li><i>Introduction</i> functionsWe define various
--   primitive helpers which <i>introduce</i> terms in the EDSL, for
--   example <a>jVar</a>, <a>jLam</a>, and <tt>var</tt> and <a>jString</a>.
--   Similarly this module exports four typeclasses <tt>ToExpr</tt>,
--   <a>ToStat</a>, <a>JVarMagic</a>, <a>JSArgument</a>. <tt>ToExpr</tt>
--   injects values as a JS expression into the EDSL. <a>ToStat</a> injects
--   values as JS statements into the EDSL. <tt>JVarMagic</tt> provides a
--   polymorphic way to introduce a new name into the EDSL and
--   <tt>JSArgument</tt> provides a polymorphic way to bind variable names
--   for use in JS functions with different
--   arities.</li><li><i>Combinator</i> functionsThe rest of the module
--   defines combinators which create terms in the EDSL from terms in the
--   EDSL. Notable examples are <a>|=</a> and <a>||=</a>, <a>|=</a> is
--   sugar for <a>AssignStat</a>, it is a binding form that declares
--   <tt>foo = bar</tt> <i>assuming</i> foo has been already declared.
--   <a>||=</a> is more sugar on top of <a>|=</a>, it is also a binding
--   form that declares the LHS of <a>|=</a> before calling <a>|=</a> to
--   bind a value, bar, to a variable foo. Other common examples are the
--   <a>if_</a> and <a>math_</a> helpers such as
--   <a>math_cos</a>.</li></ul></li>
--   <li>ConsumersThe entire JS backend consumes this module, e.g., the
--   modules in GHC.StgToJS.*.</li>
--   <li>NotationIn this module we use <tt>==&gt;</tt> in docstrings to
--   show the translation from the JS EDSL domain to JS code. For example,
--   <tt>foo ||= bar ==&gt; var foo; foo = bar;</tt> should be read as
--   <tt>foo ||= bar</tt> is in the EDSL domain and results in the JS code
--   <tt>var foo; foo = bar;</tt> when compiled.In most cases functions
--   prefixed with a <tt>j</tt> are monadic because the observably
--   allocate. Notable exceptions are <a>jwhenS</a>, <a>jString</a> and the
--   helpers for HashMaps.</li>
--   </ul>
module GHC.JS.Make

-- | Things that can be marshalled into javascript values. Instantiate for
--   any necessary data structures.
class ToJExpr a
toJExpr :: ToJExpr a => a -> JStgExpr
toJExprFromList :: ToJExpr a => [a] -> JStgExpr

-- | The <a>ToStat</a> class handles injection of of things into the EDSL
--   as a JS statement. This ends up being polymorphic sugar for JS blocks,
--   see helper function <a>expr2stat</a>. Instantiate for any necessary
--   data structures.
class ToStat a
toStat :: ToStat a => a -> JStgStat

-- | Type class that generates fresh <tt>a</tt>'s for the JS backend. You
--   should almost never need to use this directly. Instead use
--   <tt>JSArgument</tt>, for examples of how to employ these classes
--   please see <tt>jVar</tt>, <tt>jFunction</tt> and call sites in the
--   Rts.
class JVarMagic a
fresh :: JVarMagic a => JSM a

-- | Type class that finds the form of arguments required for a JS syntax
--   object. This class gives us a single interface to generate variables
--   for functions that have different arities. Thus with it, we can have
--   only one <tt>jFunction</tt> which is polymorphic over its arity,
--   instead of <tt>jFunction2</tt>, <tt>jFunction3</tt> and so on.
class JSArgument args
argList :: JSArgument args => args -> [Ident]
args :: JSArgument args => JSM args

-- | Convert a FastString to a Javascript String
jString :: FastString -> JStgExpr

-- | Create a new anonymous function. The result is a <a>JExpr</a>
--   expression. Usage:
--   
--   <pre>
--   jLam $ \x -&gt; jVar x + one_
--   jLam $ \f -&gt; (jLam $ \x -&gt; (f `app` (x `app` x))) `app` (jLam $ \x -&gt; (f `app` (x `app` x)))
--   </pre>
jLam :: JSArgument args => (args -> JSM JStgStat) -> JSM JStgExpr

-- | Special case of <tt>jLam</tt> where the anonymous function requires no
--   fresh arguments.
jLam' :: JStgStat -> JStgExpr

-- | Construct a top-level function subject to JS hoisting. This combinator
--   is polymorphic over function arity so you can you use to define a JS
--   syntax object in Haskell, which is a function in JS that takes 2 or 4
--   or whatever arguments. For a singleton function use the <tt>Solo</tt>
--   constructor <tt>MkSolo</tt>. Usage:
--   
--   an example from the Rts that defines a 1-arity JS function &gt;
--   jFunction (global "h$getReg") ((MkSolo n) -&gt; return $ SwitchStat n
--   getRegCases mempty)
--   
--   an example of a two argument function from the Rts &gt; jFunction
--   (global "h$bh_lne") ((x, frameSize) -&gt; bhLneStats s x frameSize)
jFunction :: JSArgument args => Ident -> (args -> JSM JStgStat) -> JSM JStgStat

-- | Construct a top-level function subject to JS hoisting. Special case
--   where the arity cannot be deduced from the <a>args</a> parameter
--   (atleast not without dependent types).
jFunctionSized :: Ident -> Int -> ([JStgExpr] -> JSM JStgStat) -> JSM JStgStat

-- | Construct a top-level function subject to JS hoisting. Special case
--   where the function binds no parameters
jFunction' :: Ident -> JSM JStgStat -> JSM JStgStat

-- | Introduce only one new variable into scope for the duration of the
--   enclosed expression. The result is a block statement. Usage:
--   
--   'jVar $ x -&gt; mconcat [jVar x ||= one_, ...'
jVar :: (JVarMagic t, ToJExpr t) => (t -> JSM JStgStat) -> JSM JStgStat

-- | Introduce one or many new variables into scope for the duration of the
--   enclosed expression. This function reifies the number of arguments
--   based on the container of the input function. We intentionally avoid
--   lists and instead opt for tuples because lists are not sized in
--   general. The result is a block statement. Usage:
--   
--   <pre>
--   jVars $ (x,y) -&gt; mconcat [ x |= one_,  y |= two_,  x + y]
--   </pre>
jVars :: JSArgument args => (args -> JSM JStgStat) -> JSM JStgStat

-- | Create a <tt>for</tt> statement given a function for initialization, a
--   predicate to step to, a step and a body Usage:
--   
--   <pre>
--   jFor (|= zero_) (.&lt;. Int 65536) preIncrS
--          (j -&gt; ...something with the counter j...)
--   </pre>
jFor :: (JStgExpr -> JStgStat) -> (JStgExpr -> JStgExpr) -> (JStgExpr -> JStgStat) -> (JStgExpr -> JStgStat) -> JSM JStgStat

-- | Create a 'for in' statement. Usage:
--   
--   <pre>
--   jForIn {expression} $ x -&gt; {block involving x}
--   </pre>
jForIn :: JStgExpr -> (JStgExpr -> JStgStat) -> JSM JStgStat

-- | As with "jForIn" but creating a "for each in" statement.
jForEachIn :: JStgExpr -> (JStgExpr -> JStgStat) -> JSM JStgStat

-- | As with "jForIn" but creating a "for each in" statement.
jTryCatchFinally :: (Ident -> JStgStat) -> (Ident -> JStgStat) -> (Ident -> JStgStat) -> JSM JStgStat

-- | Declare a variable and then Assign the variable to an expression
--   
--   <pre>
--   foo |= expr ==&gt; var foo; foo = expr;
--   </pre>
(||=) :: Ident -> JStgExpr -> JStgStat
infixl 2 ||=

-- | Assign a variable to an expression
--   
--   <pre>
--   foo |= expr ==&gt; var foo = expr;
--   </pre>
(|=) :: JStgExpr -> JStgExpr -> JStgStat
infixl 2 |=

-- | JS infix Equality operators
(.==.) :: JStgExpr -> JStgExpr -> JStgExpr
infixl 6 .==.

-- | JS infix Equality operators
(.===.) :: JStgExpr -> JStgExpr -> JStgExpr
infixl 6 .===.

-- | JS infix Equality operators
(.!=.) :: JStgExpr -> JStgExpr -> JStgExpr
infixl 6 .!=.

-- | JS infix Equality operators
(.!==.) :: JStgExpr -> JStgExpr -> JStgExpr
infixl 6 .!==.

-- | return the expression at idx of obj
--   
--   <pre>
--   obj .! idx ==&gt; obj[idx]
--   </pre>
(.!) :: JStgExpr -> JStgExpr -> JStgExpr
infixl 8 .!

-- | JS infix Ord operators
(.>.) :: JStgExpr -> JStgExpr -> JStgExpr
infixl 7 .>.

-- | JS infix Ord operators
(.>=.) :: JStgExpr -> JStgExpr -> JStgExpr
infixl 7 .>=.

-- | JS infix Ord operators
(.<.) :: JStgExpr -> JStgExpr -> JStgExpr
infixl 7 .<.

-- | JS infix Ord operators
(.<=.) :: JStgExpr -> JStgExpr -> JStgExpr
infixl 7 .<=.

-- | JS infix bit shift operators
(.<<.) :: JStgExpr -> JStgExpr -> JStgExpr
infixl 9 .<<.

-- | JS infix bit shift operators
(.>>.) :: JStgExpr -> JStgExpr -> JStgExpr
infixl 9 .>>.

-- | JS infix bit shift operators
(.>>>.) :: JStgExpr -> JStgExpr -> JStgExpr
infixl 9 .>>>.

-- | JS infix bit operators
(.|.) :: JStgExpr -> JStgExpr -> JStgExpr

-- | JS infix bit operators
(.||.) :: JStgExpr -> JStgExpr -> JStgExpr
infixl 8 .||.

-- | JS infix bit operators
(.&&.) :: JStgExpr -> JStgExpr -> JStgExpr
infixl 8 .&&.

-- | JS if-expression
--   
--   <pre>
--   if_ e1 e2 e3 ==&gt; e1 ? e2 : e3
--   </pre>
if_ :: JStgExpr -> JStgExpr -> JStgExpr -> JStgExpr

-- | if-expression that returns 1 if condition <a>=</a> true, 0 otherwise
--   
--   <pre>
--   if10 e ==&gt; e ? 1 : 0
--   </pre>
if10 :: JStgExpr -> JStgExpr

-- | if-expression that returns 0 if condition <a>=</a> true, 1 otherwise
--   
--   <pre>
--   if01 e ==&gt; e ? 0 : 1
--   </pre>
if01 :: JStgExpr -> JStgExpr

-- | If-expression which returns statements, see related <a>ifBlockS</a>
--   
--   <pre>
--   if e s1 s2 ==&gt; if(e) { s1 } else { s2 }
--   </pre>
ifS :: JStgExpr -> JStgStat -> JStgStat -> JStgStat

-- | If-expression which returns blocks
--   
--   <pre>
--   ifBlockS e s1 s2 ==&gt; if(e) { s1 } else { s2 }
--   </pre>
ifBlockS :: JStgExpr -> [JStgStat] -> [JStgStat] -> JStgStat
jBlock :: Monoid a => [JSM a] -> JSM a

-- | Version of a JS if-expression which admits monadic actions in its
--   branches
jIf :: JStgExpr -> JSM JStgStat -> JSM JStgStat -> JSM JStgStat

-- | A when-statement as syntactic sugar via <a>ifS</a>
--   
--   <pre>
--   jwhenS cond block ==&gt; if(cond) { block } else {  }
--   </pre>
jwhenS :: JStgExpr -> JStgStat -> JStgStat

-- | an application expression, see related <a>appS</a>
--   
--   <pre>
--   app f xs ==&gt; f(xs)
--   </pre>
app :: FastString -> [JStgExpr] -> JStgExpr

-- | A statement application, see the expression form <a>app</a>
appS :: FastString -> [JStgExpr] -> JStgStat

-- | Return a <a>JStgExpr</a>
returnS :: JStgExpr -> JStgStat

-- | "for" loop with increment at end of body
loop :: JStgExpr -> (JStgExpr -> JStgExpr) -> (JStgExpr -> JSM JStgStat) -> JSM JStgStat

-- | "for" loop with increment at end of body
loopBlockS :: JStgExpr -> (JStgExpr -> JStgExpr) -> (JStgExpr -> [JStgStat]) -> JSM JStgStat

-- | Prefix-increment a <a>JStgExpr</a>
preIncrS :: JStgExpr -> JStgStat

-- | Postfix-increment a <a>JStgExpr</a>
postIncrS :: JStgExpr -> JStgStat

-- | Prefix-decrement a <a>JStgExpr</a>
preDecrS :: JStgExpr -> JStgStat

-- | Postfix-decrement a <a>JStgExpr</a>
postDecrS :: JStgExpr -> JStgStat

-- | Byte indexing of o with a 8-bit offset
off8 :: JStgExpr -> JStgExpr -> JStgExpr

-- | Byte indexing of o with a 16-bit offset
off16 :: JStgExpr -> JStgExpr -> JStgExpr

-- | Byte indexing of o with a 32-bit offset
off32 :: JStgExpr -> JStgExpr -> JStgExpr

-- | Byte indexing of o with a 64-bit offset
off64 :: JStgExpr -> JStgExpr -> JStgExpr

-- | a bit mask to retrieve the lower 8-bits
mask8 :: JStgExpr -> JStgExpr

-- | a bit mask to retrieve the lower 16-bits
mask16 :: JStgExpr -> JStgExpr

-- | Sign-extend/narrow a 8-bit value
signExtend8 :: JStgExpr -> JStgExpr

-- | Sign-extend/narrow a 16-bit value
signExtend16 :: JStgExpr -> JStgExpr

-- | Given a <a>JStgExpr</a>, return the its type.
typeOf :: JStgExpr -> JStgExpr
returnStack :: JStgStat
assignAllEqual :: HasDebugCallStack => [JStgExpr] -> [JStgExpr] -> JStgStat
assignAll :: [JStgExpr] -> [JStgExpr] -> JStgStat
assignAllReverseOrder :: [JStgExpr] -> [JStgExpr] -> JStgStat
declAssignAll :: [Ident] -> [JStgExpr] -> JStgStat

-- | The empty JS statement
nullStat :: JStgStat

-- | Select a property <tt>prop</tt>, from and object <tt>obj</tt>
--   
--   <pre>
--   obj .^ prop ==&gt; obj.prop
--   </pre>
(.^) :: JStgExpr -> FastString -> JStgExpr
infixl 8 .^

-- | The empty JS HashMap
jhEmpty :: Map k JStgExpr

-- | A singleton JS HashMap
jhSingle :: (Ord k, ToJExpr a) => k -> a -> Map k JStgExpr

-- | insert a key-value pair into a JS HashMap
jhAdd :: (Ord k, ToJExpr a) => k -> a -> Map k JStgExpr -> Map k JStgExpr

-- | Construct a JS HashMap from a list of key-value pairs
jhFromList :: [(FastString, JStgExpr)] -> JVal

-- | The JS literal <a>null</a>
null_ :: JStgExpr

-- | The JS literal <a>undefined</a>
undefined_ :: JStgExpr

-- | The JS literal <tt>false</tt>
false_ :: JStgExpr

-- | The JS literal <tt>true</tt>
true_ :: JStgExpr

-- | The JS literal 0
zero_ :: JStgExpr

-- | The JS literal 1
one_ :: JStgExpr

-- | The JS literal 2
two_ :: JStgExpr

-- | The JS literal 3
three_ :: JStgExpr
math_log :: [JStgExpr] -> JStgExpr
math_sin :: [JStgExpr] -> JStgExpr
math_cos :: [JStgExpr] -> JStgExpr
math_tan :: [JStgExpr] -> JStgExpr
math_exp :: [JStgExpr] -> JStgExpr
math_acos :: [JStgExpr] -> JStgExpr
math_asin :: [JStgExpr] -> JStgExpr
math_atan :: [JStgExpr] -> JStgExpr
math_abs :: [JStgExpr] -> JStgExpr
math_pow :: [JStgExpr] -> JStgExpr
math_sqrt :: [JStgExpr] -> JStgExpr
math_asinh :: [JStgExpr] -> JStgExpr
math_acosh :: [JStgExpr] -> JStgExpr
math_atanh :: [JStgExpr] -> JStgExpr
math_cosh :: [JStgExpr] -> JStgExpr
math_sinh :: [JStgExpr] -> JStgExpr
math_tanh :: [JStgExpr] -> JStgExpr
math_expm1 :: [JStgExpr] -> JStgExpr
math_log1p :: [JStgExpr] -> JStgExpr
math_fround :: [JStgExpr] -> JStgExpr
math_min :: [JStgExpr] -> JStgExpr
math_max :: [JStgExpr] -> JStgExpr
data Solo a
MkSolo :: a -> Solo a
pattern Solo :: a -> Solo a

-- | construct a js declaration with the given identifier
decl :: Ident -> JStgStat
instance GHC.Internal.Real.Fractional GHC.JS.JStg.Syntax.JStgExpr
instance (GHC.JS.Make.JVarMagic a, GHC.JS.Make.ToJExpr a) => GHC.JS.Make.JSArgument (GHC.Tuple.Solo a)
instance (GHC.JS.Make.JVarMagic a, GHC.JS.Make.ToJExpr a, GHC.JS.Make.JVarMagic b, GHC.JS.Make.ToJExpr b, GHC.JS.Make.JVarMagic c, GHC.JS.Make.ToJExpr c, GHC.JS.Make.JVarMagic d, GHC.JS.Make.ToJExpr d, GHC.JS.Make.JVarMagic e, GHC.JS.Make.ToJExpr e, GHC.JS.Make.JVarMagic f, GHC.JS.Make.ToJExpr f, GHC.JS.Make.JVarMagic g, GHC.JS.Make.ToJExpr g, GHC.JS.Make.JVarMagic h, GHC.JS.Make.ToJExpr h, GHC.JS.Make.JVarMagic i, GHC.JS.Make.ToJExpr i, GHC.JS.Make.JVarMagic j, GHC.JS.Make.ToJExpr j) => GHC.JS.Make.JSArgument (a, b, c, d, e, f, g, h, i, j)
instance (GHC.JS.Make.JVarMagic a, GHC.JS.Make.JVarMagic b, GHC.JS.Make.ToJExpr a, GHC.JS.Make.ToJExpr b) => GHC.JS.Make.JSArgument (a, b)
instance (GHC.JS.Make.JVarMagic a, GHC.JS.Make.ToJExpr a, GHC.JS.Make.JVarMagic b, GHC.JS.Make.ToJExpr b, GHC.JS.Make.JVarMagic c, GHC.JS.Make.ToJExpr c) => GHC.JS.Make.JSArgument (a, b, c)
instance (GHC.JS.Make.JVarMagic a, GHC.JS.Make.ToJExpr a, GHC.JS.Make.JVarMagic b, GHC.JS.Make.ToJExpr b, GHC.JS.Make.JVarMagic c, GHC.JS.Make.ToJExpr c, GHC.JS.Make.JVarMagic d, GHC.JS.Make.ToJExpr d) => GHC.JS.Make.JSArgument (a, b, c, d)
instance (GHC.JS.Make.JVarMagic a, GHC.JS.Make.ToJExpr a, GHC.JS.Make.JVarMagic b, GHC.JS.Make.ToJExpr b, GHC.JS.Make.JVarMagic c, GHC.JS.Make.ToJExpr c, GHC.JS.Make.JVarMagic d, GHC.JS.Make.ToJExpr d, GHC.JS.Make.JVarMagic e, GHC.JS.Make.ToJExpr e) => GHC.JS.Make.JSArgument (a, b, c, d, e)
instance (GHC.JS.Make.JVarMagic a, GHC.JS.Make.ToJExpr a, GHC.JS.Make.JVarMagic b, GHC.JS.Make.ToJExpr b, GHC.JS.Make.JVarMagic c, GHC.JS.Make.ToJExpr c, GHC.JS.Make.JVarMagic d, GHC.JS.Make.ToJExpr d, GHC.JS.Make.JVarMagic e, GHC.JS.Make.ToJExpr e, GHC.JS.Make.JVarMagic f, GHC.JS.Make.ToJExpr f) => GHC.JS.Make.JSArgument (a, b, c, d, e, f)
instance (GHC.JS.Make.JVarMagic a, GHC.JS.Make.ToJExpr a, GHC.JS.Make.JVarMagic b, GHC.JS.Make.ToJExpr b, GHC.JS.Make.JVarMagic c, GHC.JS.Make.ToJExpr c, GHC.JS.Make.JVarMagic d, GHC.JS.Make.ToJExpr d, GHC.JS.Make.JVarMagic e, GHC.JS.Make.ToJExpr e, GHC.JS.Make.JVarMagic f, GHC.JS.Make.ToJExpr f, GHC.JS.Make.JVarMagic g, GHC.JS.Make.ToJExpr g) => GHC.JS.Make.JSArgument (a, b, c, d, e, f, g)
instance (GHC.JS.Make.JVarMagic a, GHC.JS.Make.ToJExpr a, GHC.JS.Make.JVarMagic b, GHC.JS.Make.ToJExpr b, GHC.JS.Make.JVarMagic c, GHC.JS.Make.ToJExpr c, GHC.JS.Make.JVarMagic d, GHC.JS.Make.ToJExpr d, GHC.JS.Make.JVarMagic e, GHC.JS.Make.ToJExpr e, GHC.JS.Make.JVarMagic f, GHC.JS.Make.ToJExpr f, GHC.JS.Make.JVarMagic g, GHC.JS.Make.ToJExpr g, GHC.JS.Make.JVarMagic h, GHC.JS.Make.ToJExpr h) => GHC.JS.Make.JSArgument (a, b, c, d, e, f, g, h)
instance (GHC.JS.Make.JVarMagic a, GHC.JS.Make.ToJExpr a, GHC.JS.Make.JVarMagic b, GHC.JS.Make.ToJExpr b, GHC.JS.Make.JVarMagic c, GHC.JS.Make.ToJExpr c, GHC.JS.Make.JVarMagic d, GHC.JS.Make.ToJExpr d, GHC.JS.Make.JVarMagic e, GHC.JS.Make.ToJExpr e, GHC.JS.Make.JVarMagic f, GHC.JS.Make.ToJExpr f, GHC.JS.Make.JVarMagic g, GHC.JS.Make.ToJExpr g, GHC.JS.Make.JVarMagic h, GHC.JS.Make.ToJExpr h, GHC.JS.Make.JVarMagic i, GHC.JS.Make.ToJExpr i) => GHC.JS.Make.JSArgument (a, b, c, d, e, f, g, h, i)
instance GHC.JS.Make.JVarMagic GHC.JS.Ident.Ident
instance GHC.JS.Make.JVarMagic GHC.JS.JStg.Syntax.JStgExpr
instance GHC.JS.Make.JVarMagic GHC.JS.JStg.Syntax.JVal
instance GHC.Internal.Num.Num GHC.JS.JStg.Syntax.JStgExpr
instance GHC.JS.Make.ToJExpr GHC.Types.Bool
instance GHC.JS.Make.ToJExpr GHC.Types.Char
instance GHC.JS.Make.ToJExpr GHC.Types.Double
instance GHC.JS.Make.ToJExpr GHC.Data.FastString.FastString
instance GHC.JS.Make.ToJExpr GHC.JS.Ident.Ident
instance GHC.JS.Make.ToJExpr GHC.Types.Int
instance GHC.JS.Make.ToJExpr GHC.Num.Integer.Integer
instance GHC.JS.Make.ToJExpr GHC.JS.JStg.Syntax.JStgExpr
instance GHC.JS.Make.ToJExpr GHC.JS.JStg.Syntax.JVal
instance GHC.JS.Make.ToJExpr a => GHC.JS.Make.ToJExpr [a]
instance GHC.JS.Make.ToJExpr a => GHC.JS.Make.ToJExpr (Data.Map.Internal.Map GHC.Internal.Base.String a)
instance (GHC.JS.Make.ToJExpr a, GHC.JS.Make.ToJExpr b) => GHC.JS.Make.ToJExpr (a, b)
instance (GHC.JS.Make.ToJExpr a, GHC.JS.Make.ToJExpr b, GHC.JS.Make.ToJExpr c) => GHC.JS.Make.ToJExpr (a, b, c)
instance (GHC.JS.Make.ToJExpr a, GHC.JS.Make.ToJExpr b, GHC.JS.Make.ToJExpr c, GHC.JS.Make.ToJExpr d) => GHC.JS.Make.ToJExpr (a, b, c, d)
instance (GHC.JS.Make.ToJExpr a, GHC.JS.Make.ToJExpr b, GHC.JS.Make.ToJExpr c, GHC.JS.Make.ToJExpr d, GHC.JS.Make.ToJExpr e) => GHC.JS.Make.ToJExpr (a, b, c, d, e)
instance (GHC.JS.Make.ToJExpr a, GHC.JS.Make.ToJExpr b, GHC.JS.Make.ToJExpr c, GHC.JS.Make.ToJExpr d, GHC.JS.Make.ToJExpr e, GHC.JS.Make.ToJExpr f) => GHC.JS.Make.ToJExpr (a, b, c, d, e, f)
instance GHC.JS.Make.ToJExpr a => GHC.JS.Make.ToJExpr (GHC.Types.Unique.Map.UniqMap GHC.Data.FastString.FastString a)
instance GHC.JS.Make.ToJExpr ()
instance GHC.JS.Make.ToStat GHC.JS.JStg.Syntax.JStgExpr
instance GHC.JS.Make.ToStat GHC.JS.JStg.Syntax.JStgStat
instance GHC.JS.Make.ToStat [GHC.JS.JStg.Syntax.JStgStat]
instance GHC.JS.Make.ToStat [GHC.JS.JStg.Syntax.JStgExpr]

module GHC.StgToJS.Regs

-- | General purpose "registers"
--   
--   The JS backend arbitrarily supports 128 registers
data StgReg
R1 :: StgReg
R2 :: StgReg
R3 :: StgReg
R4 :: StgReg
R5 :: StgReg
R6 :: StgReg
R7 :: StgReg
R8 :: StgReg
R9 :: StgReg
R10 :: StgReg
R11 :: StgReg
R12 :: StgReg
R13 :: StgReg
R14 :: StgReg
R15 :: StgReg
R16 :: StgReg
R17 :: StgReg
R18 :: StgReg
R19 :: StgReg
R20 :: StgReg
R21 :: StgReg
R22 :: StgReg
R23 :: StgReg
R24 :: StgReg
R25 :: StgReg
R26 :: StgReg
R27 :: StgReg
R28 :: StgReg
R29 :: StgReg
R30 :: StgReg
R31 :: StgReg
R32 :: StgReg
R33 :: StgReg
R34 :: StgReg
R35 :: StgReg
R36 :: StgReg
R37 :: StgReg
R38 :: StgReg
R39 :: StgReg
R40 :: StgReg
R41 :: StgReg
R42 :: StgReg
R43 :: StgReg
R44 :: StgReg
R45 :: StgReg
R46 :: StgReg
R47 :: StgReg
R48 :: StgReg
R49 :: StgReg
R50 :: StgReg
R51 :: StgReg
R52 :: StgReg
R53 :: StgReg
R54 :: StgReg
R55 :: StgReg
R56 :: StgReg
R57 :: StgReg
R58 :: StgReg
R59 :: StgReg
R60 :: StgReg
R61 :: StgReg
R62 :: StgReg
R63 :: StgReg
R64 :: StgReg
R65 :: StgReg
R66 :: StgReg
R67 :: StgReg
R68 :: StgReg
R69 :: StgReg
R70 :: StgReg
R71 :: StgReg
R72 :: StgReg
R73 :: StgReg
R74 :: StgReg
R75 :: StgReg
R76 :: StgReg
R77 :: StgReg
R78 :: StgReg
R79 :: StgReg
R80 :: StgReg
R81 :: StgReg
R82 :: StgReg
R83 :: StgReg
R84 :: StgReg
R85 :: StgReg
R86 :: StgReg
R87 :: StgReg
R88 :: StgReg
R89 :: StgReg
R90 :: StgReg
R91 :: StgReg
R92 :: StgReg
R93 :: StgReg
R94 :: StgReg
R95 :: StgReg
R96 :: StgReg
R97 :: StgReg
R98 :: StgReg
R99 :: StgReg
R100 :: StgReg
R101 :: StgReg
R102 :: StgReg
R103 :: StgReg
R104 :: StgReg
R105 :: StgReg
R106 :: StgReg
R107 :: StgReg
R108 :: StgReg
R109 :: StgReg
R110 :: StgReg
R111 :: StgReg
R112 :: StgReg
R113 :: StgReg
R114 :: StgReg
R115 :: StgReg
R116 :: StgReg
R117 :: StgReg
R118 :: StgReg
R119 :: StgReg
R120 :: StgReg
R121 :: StgReg
R122 :: StgReg
R123 :: StgReg
R124 :: StgReg
R125 :: StgReg
R126 :: StgReg
R127 :: StgReg
R128 :: StgReg

-- | Stack registers
data Special
Stack :: Special
Sp :: Special
sp :: JStgExpr
stack :: JStgExpr
r1 :: JStgExpr
r2 :: JStgExpr
r3 :: JStgExpr
r4 :: JStgExpr

-- | List of registers, starting from R1
regsFromR1 :: [StgReg]

-- | List of registers, starting from R2
regsFromR2 :: [StgReg]

-- | List of registers, starting from R1 as JStgExpr
jsRegsFromR1 :: [JStgExpr]

-- | List of registers, starting from R2 as JExpr
jsRegsFromR2 :: [JStgExpr]

-- | Return registers
--   
--   Extra results from foreign calls can be stored here (while first
--   result is directly returned)
data StgRet
Ret1 :: StgRet
Ret2 :: StgRet
Ret3 :: StgRet
Ret4 :: StgRet
Ret5 :: StgRet
Ret6 :: StgRet
Ret7 :: StgRet
Ret8 :: StgRet
Ret9 :: StgRet
Ret10 :: StgRet
jsRegToInt :: StgReg -> Int
intToJSReg :: Int -> StgReg
jsReg :: Int -> JStgExpr
maxReg :: Int
minReg :: Int
lowRegs :: [Ident]
retRegs :: [Ident]

-- | Given a register, return the JS syntax object representing that
--   register
register :: StgReg -> JStgExpr

-- | Given a register, return the JS syntax object representing that
--   register
foreignRegister :: StgRet -> JStgExpr
instance GHC.Internal.Enum.Bounded GHC.StgToJS.Regs.StgReg
instance GHC.Internal.Enum.Bounded GHC.StgToJS.Regs.StgRet
instance GHC.Internal.Enum.Enum GHC.StgToJS.Regs.StgReg
instance GHC.Internal.Enum.Enum GHC.StgToJS.Regs.StgRet
instance GHC.Classes.Eq GHC.StgToJS.Regs.Special
instance GHC.Classes.Eq GHC.StgToJS.Regs.StgReg
instance GHC.Classes.Eq GHC.StgToJS.Regs.StgRet
instance GHC.Internal.Ix.Ix GHC.StgToJS.Regs.StgReg
instance GHC.Internal.Ix.Ix GHC.StgToJS.Regs.StgRet
instance GHC.Classes.Ord GHC.StgToJS.Regs.StgReg
instance GHC.Classes.Ord GHC.StgToJS.Regs.StgRet
instance GHC.Internal.Show.Show GHC.StgToJS.Regs.Special
instance GHC.Internal.Show.Show GHC.StgToJS.Regs.StgReg
instance GHC.Internal.Show.Show GHC.StgToJS.Regs.StgRet
instance GHC.JS.Make.ToJExpr GHC.StgToJS.Regs.Special
instance GHC.JS.Make.ToJExpr GHC.StgToJS.Regs.StgReg
instance GHC.JS.Make.ToJExpr GHC.StgToJS.Regs.StgRet


-- | This stuff here is related to supporting the Safe Haskell extension,
--   primarily about storing under what trust type a module has been
--   compiled.
module GHC.Types.SafeHaskell

-- | Is an import a safe import?
type IsSafeImport = Bool

-- | The various Safe Haskell modes
data SafeHaskellMode

-- | inferred unsafe
Sf_None :: SafeHaskellMode

-- | declared and checked
Sf_Unsafe :: SafeHaskellMode

-- | declared and checked
Sf_Trustworthy :: SafeHaskellMode

-- | declared and checked
Sf_Safe :: SafeHaskellMode

-- | inferred as safe
Sf_SafeInferred :: SafeHaskellMode

-- | <tt>-fno-safe-haskell</tt> state
Sf_Ignore :: SafeHaskellMode

-- | Safe Haskell information for <tt>ModIface</tt> Simply a wrapper around
--   SafeHaskellMode to separate iface and flags
data IfaceTrustInfo
getSafeMode :: IfaceTrustInfo -> SafeHaskellMode
setSafeMode :: SafeHaskellMode -> IfaceTrustInfo
noIfaceTrustInfo :: IfaceTrustInfo
instance GHC.Utils.Binary.Binary GHC.Types.SafeHaskell.IfaceTrustInfo
instance GHC.Classes.Eq GHC.Types.SafeHaskell.SafeHaskellMode
instance GHC.Utils.Outputable.Outputable GHC.Types.SafeHaskell.IfaceTrustInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.SafeHaskell.SafeHaskellMode
instance GHC.Internal.Show.Show GHC.Types.SafeHaskell.SafeHaskellMode

module GHC.Types.ForeignCall
newtype ForeignCall
CCall :: CCallSpec -> ForeignCall
isSafeForeignCall :: ForeignCall -> Bool
data Safety

-- | Might invoke Haskell GC, or do a call back, or switch threads, etc. So
--   make sure things are tidy before the call. Additionally, in the
--   threaded RTS we arrange for the external call to be executed by a
--   separate OS thread, i.e., _concurrently_ to the execution of other
--   Haskell threads.
PlaySafe :: Safety

-- | Like PlaySafe, but additionally the worker thread running this foreign
--   call may be unceremoniously killed, so it must be scheduled on an
--   unbound thread.
PlayInterruptible :: Safety

-- | None of the above can happen; the call will return without interacting
--   with the runtime system at all. Specifically:
--   
--   <ul>
--   <li>No GC</li>
--   <li>No call backs</li>
--   <li>No blocking</li>
--   <li>No precise exceptions</li>
--   </ul>
PlayRisky :: Safety
playSafe :: Safety -> Bool
playInterruptible :: Safety -> Bool
data CExportSpec
CExportStatic :: SourceText -> CLabelString -> CCallConv -> CExportSpec
type CLabelString = FastString
isCLabelString :: CLabelString -> Bool
pprCLabelString :: CLabelString -> SDoc
data CCallSpec
CCallSpec :: CCallTarget -> CCallConv -> Safety -> CCallSpec

-- | How to call a particular function in C-land.
data CCallTarget
StaticTarget :: SourceText -> CLabelString -> Maybe Unit -> Bool -> CCallTarget
DynamicTarget :: CCallTarget
isDynamicTarget :: CCallTarget -> Bool
data CCallConv
CCallConv :: CCallConv
CApiConv :: CCallConv
StdCallConv :: CCallConv
PrimCallConv :: CCallConv
JavaScriptCallConv :: CCallConv
defaultCCallConv :: CCallConv
ccallConvAttribute :: CCallConv -> SDoc
data Header
Header :: SourceText -> FastString -> Header

-- | A C type, used in CAPI FFI calls
data CType
CType :: SourceText -> Maybe Header -> (SourceText, FastString) -> CType
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.CCallConv
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.CCallSpec
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.CCallTarget
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.CExportSpec
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.CType
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.ForeignCall
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.Header
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.Safety
instance GHC.Internal.Data.Data.Data GHC.Types.ForeignCall.CCallConv
instance GHC.Internal.Data.Data.Data GHC.Types.ForeignCall.CCallTarget
instance GHC.Internal.Data.Data.Data GHC.Types.ForeignCall.CExportSpec
instance GHC.Internal.Data.Data.Data GHC.Types.ForeignCall.CType
instance GHC.Internal.Data.Data.Data GHC.Types.ForeignCall.Header
instance GHC.Internal.Data.Data.Data GHC.Types.ForeignCall.Safety
instance GHC.Internal.Enum.Enum GHC.Types.ForeignCall.CCallConv
instance GHC.Internal.Enum.Enum GHC.Types.ForeignCall.Safety
instance GHC.Classes.Eq GHC.Types.ForeignCall.CCallConv
instance GHC.Classes.Eq GHC.Types.ForeignCall.CCallSpec
instance GHC.Classes.Eq GHC.Types.ForeignCall.CCallTarget
instance GHC.Classes.Eq GHC.Types.ForeignCall.CType
instance GHC.Classes.Eq GHC.Types.ForeignCall.ForeignCall
instance GHC.Classes.Eq GHC.Types.ForeignCall.Header
instance GHC.Classes.Eq GHC.Types.ForeignCall.Safety
instance GHC.Utils.Outputable.Outputable GHC.Types.ForeignCall.CCallConv
instance GHC.Utils.Outputable.Outputable GHC.Types.ForeignCall.CCallSpec
instance GHC.Utils.Outputable.Outputable GHC.Types.ForeignCall.CExportSpec
instance GHC.Utils.Outputable.Outputable GHC.Types.ForeignCall.CType
instance GHC.Utils.Outputable.Outputable GHC.Types.ForeignCall.ForeignCall
instance GHC.Utils.Outputable.Outputable GHC.Types.ForeignCall.Header
instance GHC.Utils.Outputable.Outputable GHC.Types.ForeignCall.Safety
instance GHC.Internal.Show.Show GHC.Types.ForeignCall.Safety

module GHC.Types.FieldLabel

-- | A map from labels to all the auxiliary information
type FieldLabelEnv = DFastStringEnv FieldLabel

-- | Fields in an algebraic record type; see Note [FieldLabel].
data FieldLabel
FieldLabel :: DuplicateRecordFields -> FieldSelectors -> Name -> FieldLabel

-- | Was <tt>DuplicateRecordFields</tt> on in the defining module for this
--   datatype?
[flHasDuplicateRecordFields] :: FieldLabel -> DuplicateRecordFields

-- | Was <tt>FieldSelectors</tt> enabled in the defining module for this
--   datatype? See Note [NoFieldSelectors] in GHC.Rename.Env
[flHasFieldSelector] :: FieldLabel -> FieldSelectors

-- | The <a>Name</a> of the selector function, which uniquely identifies
--   the field label.
[flSelector] :: FieldLabel -> Name

-- | User-visible label of a field.
flLabel :: FieldLabel -> FieldLabelString

-- | Flag to indicate whether the DuplicateRecordFields extension is
--   enabled.
data DuplicateRecordFields

-- | Fields may be duplicated in a single module
DuplicateRecordFields :: DuplicateRecordFields

-- | Fields must be unique within a module (the default)
NoDuplicateRecordFields :: DuplicateRecordFields

-- | Flag to indicate whether the FieldSelectors extension is enabled.
data FieldSelectors

-- | Selector functions are available (the default)
FieldSelectors :: FieldSelectors

-- | Selector functions are not available
NoFieldSelectors :: FieldSelectors
flIsOverloaded :: FieldLabel -> Bool
instance GHC.Utils.Binary.Binary GHC.Types.FieldLabel.DuplicateRecordFields
instance GHC.Utils.Binary.Binary GHC.Types.Name.Name => GHC.Utils.Binary.Binary GHC.Types.FieldLabel.FieldLabel
instance GHC.Utils.Binary.Binary GHC.Types.FieldLabel.FieldSelectors
instance GHC.Internal.Data.Data.Data GHC.Types.FieldLabel.DuplicateRecordFields
instance GHC.Internal.Data.Data.Data GHC.Types.FieldLabel.FieldLabel
instance GHC.Internal.Data.Data.Data GHC.Types.FieldLabel.FieldSelectors
instance GHC.Classes.Eq GHC.Types.FieldLabel.DuplicateRecordFields
instance GHC.Classes.Eq GHC.Types.FieldLabel.FieldLabel
instance GHC.Classes.Eq GHC.Types.FieldLabel.FieldSelectors
instance GHC.Types.Name.Occurrence.HasOccName GHC.Types.FieldLabel.FieldLabel
instance Control.DeepSeq.NFData GHC.Types.FieldLabel.DuplicateRecordFields
instance Control.DeepSeq.NFData GHC.Types.FieldLabel.FieldSelectors
instance GHC.Utils.Outputable.Outputable GHC.Types.FieldLabel.DuplicateRecordFields
instance GHC.Utils.Outputable.Outputable GHC.Types.FieldLabel.FieldLabel
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Basic.FieldLabelString
instance GHC.Utils.Outputable.Outputable GHC.Types.FieldLabel.FieldSelectors
instance GHC.Internal.Show.Show GHC.Types.FieldLabel.DuplicateRecordFields
instance GHC.Internal.Show.Show GHC.Types.FieldLabel.FieldSelectors
instance GHC.Types.Unique.Uniquable Language.Haskell.Syntax.Basic.FieldLabelString

module GHC.Types.CostCentre.State

-- | Per-module state for tracking cost centre indices.
--   
--   See documentation of <a>cc_flavour</a> for more details.
data CostCentreState

-- | Initialize cost centre state.
newCostCentreState :: CostCentreState

-- | An index into a given cost centre module,name,flavour set
data CostCentreIndex
unCostCentreIndex :: CostCentreIndex -> Int

-- | Get a new index for a given cost centre name.
getCCIndex :: FastString -> CostCentreState -> (CostCentreIndex, CostCentreState)
instance GHC.Utils.Binary.Binary GHC.Types.CostCentre.State.CostCentreIndex
instance GHC.Internal.Data.Data.Data GHC.Types.CostCentre.State.CostCentreIndex
instance GHC.Classes.Eq GHC.Types.CostCentre.State.CostCentreIndex
instance GHC.Classes.Ord GHC.Types.CostCentre.State.CostCentreIndex

module GHC.Iface.Ext.Fields
newtype ExtensibleFields
ExtensibleFields :: Map FieldName BinData -> ExtensibleFields
[getExtensibleFields] :: ExtensibleFields -> Map FieldName BinData
type FieldName = String
emptyExtensibleFields :: ExtensibleFields

-- | Reading
readField :: Binary a => FieldName -> ExtensibleFields -> IO (Maybe a)
readFieldWith :: FieldName -> (ReadBinHandle -> IO a) -> ExtensibleFields -> IO (Maybe a)

-- | Writing
writeField :: Binary a => FieldName -> a -> ExtensibleFields -> IO ExtensibleFields
writeFieldWith :: FieldName -> (WriteBinHandle -> IO ()) -> ExtensibleFields -> IO ExtensibleFields
deleteField :: FieldName -> ExtensibleFields -> ExtensibleFields
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Fields.ExtensibleFields
instance Control.DeepSeq.NFData GHC.Iface.Ext.Fields.ExtensibleFields


-- | An exactprintable structure for docstrings
module GHC.Hs.DocString
type LHsDocString = Located HsDocString

-- | Haskell Documentation String
--   
--   Rich structure to support exact printing The location around each
--   chunk doesn't include the decorators
data HsDocString

-- | The first chunk is preceded by "-- <a>decorator</a>" and each
--   following chunk is preceded by "--" Example: -- | This is a docstring
--   for <tt>foo</tt>. It is the line with the decorator '|' and is always
--   included -- This continues that docstring and is the second element in
--   the NonEmpty list foo :: a -&gt; a
MultiLineDocString :: !HsDocStringDecorator -> !NonEmpty LHsDocStringChunk -> HsDocString

-- | The docstring is preceded by "{-<a>decorator</a>" and followed by "-}"
--   The chunk contains balanced pairs of '{-' and '-}'
NestedDocString :: !HsDocStringDecorator -> LHsDocStringChunk -> HsDocString

-- | A docstring generated either internally or via TH Pretty printed with
--   the '-- |' decorator This is because it may contain unbalanced pairs
--   of '{-' and '-}' and not form a valid <a>NestedDocString</a>
GeneratedDocString :: HsDocStringChunk -> HsDocString
data HsDocStringDecorator

-- | '|' is the decorator
HsDocStringNext :: HsDocStringDecorator

-- | <a>^</a> is the decorator
HsDocStringPrevious :: HsDocStringDecorator

-- | '$<a>string</a>' is the decorator
HsDocStringNamed :: !String -> HsDocStringDecorator

-- | The decorator is the given number of <a>*</a>s
HsDocStringGroup :: !Int -> HsDocStringDecorator

-- | A contiguous chunk of documentation
newtype HsDocStringChunk
HsDocStringChunk :: ByteString -> HsDocStringChunk
type LHsDocStringChunk = Located HsDocStringChunk
isEmptyDocString :: HsDocString -> Bool
unpackHDSC :: HsDocStringChunk -> String
mkHsDocStringChunk :: String -> HsDocStringChunk

-- | Create a <a>HsDocString</a> from a UTF8-encoded <a>ByteString</a>.
mkHsDocStringChunkUtf8ByteString :: ByteString -> HsDocStringChunk

-- | Pretty print with decorators, exactly as the user wrote it
pprHsDocString :: HsDocString -> SDoc
pprHsDocStrings :: [HsDocString] -> SDoc
mkGeneratedHsDocString :: String -> HsDocString
docStringChunks :: HsDocString -> [LHsDocStringChunk]

-- | Just get the docstring, without any decorators
renderHsDocString :: HsDocString -> String

-- | Just get the docstring, without any decorators Separates docstrings
--   using "nn", which is how haddock likes to render them
renderHsDocStrings :: [HsDocString] -> String

-- | Pretty print with decorators, exactly as the user wrote it
exactPrintHsDocString :: HsDocString -> String

-- | Annotate a pretty printed thing with its doc The docstring comes after
--   if is <a>HsDocStringPrevious</a> Otherwise it comes before. Note - we
--   convert MultiLineDocString HsDocStringPrevious to HsDocStringNext
--   because we can't control if something else will be pretty printed on
--   the same line
pprWithDocString :: HsDocString -> SDoc -> SDoc
printDecorator :: HsDocStringDecorator -> String
instance GHC.Utils.Binary.Binary GHC.Hs.DocString.HsDocString
instance GHC.Utils.Binary.Binary GHC.Hs.DocString.HsDocStringChunk
instance GHC.Utils.Binary.Binary GHC.Hs.DocString.HsDocStringDecorator
instance GHC.Internal.Data.Data.Data GHC.Hs.DocString.HsDocString
instance GHC.Internal.Data.Data.Data GHC.Hs.DocString.HsDocStringChunk
instance GHC.Internal.Data.Data.Data GHC.Hs.DocString.HsDocStringDecorator
instance GHC.Classes.Eq GHC.Hs.DocString.HsDocString
instance GHC.Classes.Eq GHC.Hs.DocString.HsDocStringChunk
instance GHC.Classes.Eq GHC.Hs.DocString.HsDocStringDecorator
instance Control.DeepSeq.NFData GHC.Hs.DocString.HsDocString
instance Control.DeepSeq.NFData GHC.Hs.DocString.HsDocStringChunk
instance Control.DeepSeq.NFData GHC.Hs.DocString.HsDocStringDecorator
instance GHC.Classes.Ord GHC.Hs.DocString.HsDocStringChunk
instance GHC.Classes.Ord GHC.Hs.DocString.HsDocStringDecorator
instance GHC.Utils.Outputable.Outputable GHC.Hs.DocString.HsDocString
instance GHC.Utils.Outputable.Outputable GHC.Hs.DocString.HsDocStringChunk
instance GHC.Utils.Outputable.Outputable GHC.Hs.DocString.HsDocStringDecorator
instance GHC.Internal.Show.Show GHC.Hs.DocString.HsDocString
instance GHC.Internal.Show.Show GHC.Hs.DocString.HsDocStringChunk
instance GHC.Internal.Show.Show GHC.Hs.DocString.HsDocStringDecorator


-- | Fixity
module GHC.Hs.Basic
instance GHC.Utils.Binary.Binary Language.Haskell.Syntax.Basic.Fixity
instance GHC.Utils.Binary.Binary Language.Haskell.Syntax.Basic.FixityDirection
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Basic.Fixity
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Basic.FixityDirection
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Basic.LexicalFixity


-- | Fixity
module GHC.Types.Fixity
data Fixity
Fixity :: Int -> FixityDirection -> Fixity
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection

-- | Captures the fixity of declarations as they are parsed. This is not
--   necessarily the same as the fixity declaration, as the normal fixity
--   may be overridden using parens or backticks.
data LexicalFixity
Prefix :: LexicalFixity
Infix :: LexicalFixity
maxPrecedence :: Int
minPrecedence :: Int
defaultFixity :: Fixity
negateFixity :: Fixity
funTyFixity :: Fixity
compareFixity :: Fixity -> Fixity -> (Bool, Bool)


-- | A tiny wrapper around <a>IntSet</a> for representing sets of
--   <a>Enum</a> things.
module GHC.Data.EnumSet
data EnumSet (a :: k)
member :: Enum a => a -> EnumSet a -> Bool
insert :: Enum a => a -> EnumSet a -> EnumSet a
delete :: Enum a => a -> EnumSet a -> EnumSet a
toList :: Enum a => EnumSet a -> [a]
fromList :: Enum a => [a] -> EnumSet a
empty :: forall {k} (a :: k). EnumSet a
difference :: forall {k} (a :: k). EnumSet a -> EnumSet a -> EnumSet a
instance forall k (a :: k). GHC.Utils.Binary.Binary (GHC.Data.EnumSet.EnumSet a)
instance forall k (a :: k). GHC.Internal.Base.Monoid (GHC.Data.EnumSet.EnumSet a)
instance forall k (a :: k). Control.DeepSeq.NFData (GHC.Data.EnumSet.EnumSet a)
instance forall k (a :: k). GHC.Internal.Base.Semigroup (GHC.Data.EnumSet.EnumSet a)

module GHC.Driver.Flags

-- | Debugging flags
data DumpFlag
Opt_D_dump_cmm :: DumpFlag
Opt_D_dump_cmm_from_stg :: DumpFlag
Opt_D_dump_cmm_raw :: DumpFlag
Opt_D_dump_cmm_verbose_by_proc :: DumpFlag
Opt_D_dump_cmm_verbose :: DumpFlag
Opt_D_dump_cmm_cfg :: DumpFlag
Opt_D_dump_cmm_cbe :: DumpFlag
Opt_D_dump_cmm_switch :: DumpFlag
Opt_D_dump_cmm_proc :: DumpFlag
Opt_D_dump_cmm_sp :: DumpFlag
Opt_D_dump_cmm_sink :: DumpFlag
Opt_D_dump_cmm_caf :: DumpFlag
Opt_D_dump_cmm_procmap :: DumpFlag
Opt_D_dump_cmm_split :: DumpFlag
Opt_D_dump_cmm_info :: DumpFlag
Opt_D_dump_cmm_cps :: DumpFlag
Opt_D_dump_cmm_thread_sanitizer :: DumpFlag

-- | Dump the cfg used for block layout.
Opt_D_dump_cfg_weights :: DumpFlag
Opt_D_dump_asm :: DumpFlag
Opt_D_dump_asm_native :: DumpFlag
Opt_D_dump_asm_liveness :: DumpFlag
Opt_D_dump_asm_regalloc :: DumpFlag
Opt_D_dump_asm_regalloc_stages :: DumpFlag
Opt_D_dump_asm_conflicts :: DumpFlag
Opt_D_dump_asm_stats :: DumpFlag
Opt_D_dump_c_backend :: DumpFlag
Opt_D_dump_llvm :: DumpFlag
Opt_D_dump_js :: DumpFlag
Opt_D_dump_core_stats :: DumpFlag
Opt_D_dump_deriv :: DumpFlag
Opt_D_dump_ds :: DumpFlag
Opt_D_dump_ds_preopt :: DumpFlag
Opt_D_dump_foreign :: DumpFlag
Opt_D_dump_inlinings :: DumpFlag
Opt_D_dump_verbose_inlinings :: DumpFlag
Opt_D_dump_rule_firings :: DumpFlag
Opt_D_dump_rule_rewrites :: DumpFlag
Opt_D_dump_simpl_trace :: DumpFlag
Opt_D_dump_occur_anal :: DumpFlag
Opt_D_dump_parsed :: DumpFlag
Opt_D_dump_parsed_ast :: DumpFlag
Opt_D_dump_rn :: DumpFlag
Opt_D_dump_rn_ast :: DumpFlag
Opt_D_dump_simpl :: DumpFlag
Opt_D_dump_simpl_iterations :: DumpFlag
Opt_D_dump_spec :: DumpFlag
Opt_D_dump_spec_constr :: DumpFlag
Opt_D_dump_prep :: DumpFlag
Opt_D_dump_late_cc :: DumpFlag

-- | Initial STG (CoreToStg output)
Opt_D_dump_stg_from_core :: DumpFlag

-- | STG after unarise
Opt_D_dump_stg_unarised :: DumpFlag

-- | STG (after stg2stg)
Opt_D_dump_stg_cg :: DumpFlag

-- | Result of tag inference analysis.
Opt_D_dump_stg_tags :: DumpFlag

-- | Final STG (before cmm gen)
Opt_D_dump_stg_final :: DumpFlag
Opt_D_dump_call_arity :: DumpFlag
Opt_D_dump_exitify :: DumpFlag
Opt_D_dump_dmdanal :: DumpFlag
Opt_D_dump_dmd_signatures :: DumpFlag
Opt_D_dump_cpranal :: DumpFlag
Opt_D_dump_cpr_signatures :: DumpFlag
Opt_D_dump_tc :: DumpFlag
Opt_D_dump_tc_ast :: DumpFlag
Opt_D_dump_hie :: DumpFlag
Opt_D_dump_types :: DumpFlag
Opt_D_dump_rules :: DumpFlag
Opt_D_dump_cse :: DumpFlag
Opt_D_dump_float_out :: DumpFlag
Opt_D_dump_float_in :: DumpFlag
Opt_D_dump_liberate_case :: DumpFlag
Opt_D_dump_static_argument_transformation :: DumpFlag
Opt_D_dump_worker_wrapper :: DumpFlag
Opt_D_dump_rn_trace :: DumpFlag
Opt_D_dump_rn_stats :: DumpFlag
Opt_D_dump_opt_cmm :: DumpFlag
Opt_D_dump_simpl_stats :: DumpFlag
Opt_D_dump_cs_trace :: DumpFlag
Opt_D_dump_tc_trace :: DumpFlag
Opt_D_dump_ec_trace :: DumpFlag
Opt_D_dump_if_trace :: DumpFlag
Opt_D_dump_splices :: DumpFlag
Opt_D_th_dec_file :: DumpFlag
Opt_D_dump_BCOs :: DumpFlag
Opt_D_dump_ticked :: DumpFlag
Opt_D_dump_rtti :: DumpFlag
Opt_D_source_stats :: DumpFlag
Opt_D_verbose_stg2stg :: DumpFlag
Opt_D_dump_hi :: DumpFlag
Opt_D_dump_hi_diffs :: DumpFlag
Opt_D_dump_mod_cycles :: DumpFlag
Opt_D_dump_mod_map :: DumpFlag
Opt_D_dump_timings :: DumpFlag
Opt_D_dump_view_pattern_commoning :: DumpFlag
Opt_D_verbose_core2core :: DumpFlag
Opt_D_dump_debug :: DumpFlag
Opt_D_dump_json :: DumpFlag
Opt_D_ppr_debug :: DumpFlag
Opt_D_no_debug_output :: DumpFlag
Opt_D_dump_faststrings :: DumpFlag
Opt_D_faststring_stats :: DumpFlag
Opt_D_ipe_stats :: DumpFlag

-- | Helper function to query whether a given <a>DumpFlag</a> is enabled or
--   not.
getDumpFlagFrom :: (a -> Int) -> (a -> EnumSet DumpFlag) -> DumpFlag -> a -> Bool

-- | Is the flag implicitly enabled when the verbosity is high enough?
enabledIfVerbose :: DumpFlag -> Bool

-- | Enumerates the simple on-or-off dynamic flags
data GeneralFlag

-- | Append dump output to files instead of stdout.
Opt_DumpToFile :: GeneralFlag

-- | Use foo.ways.<a>dumpFlag</a> instead of foo.<a>dumpFlag</a>
Opt_DumpWithWays :: GeneralFlag
Opt_D_dump_minimal_imports :: GeneralFlag
Opt_DoCoreLinting :: GeneralFlag
Opt_DoLinearCoreLinting :: GeneralFlag
Opt_DoStgLinting :: GeneralFlag
Opt_DoCmmLinting :: GeneralFlag
Opt_DoAsmLinting :: GeneralFlag
Opt_DoAnnotationLinting :: GeneralFlag
Opt_DoBoundsChecking :: GeneralFlag
Opt_NoLlvmMangler :: GeneralFlag
Opt_FastLlvm :: GeneralFlag
Opt_NoTypeableBinds :: GeneralFlag
Opt_DistinctConstructorTables :: GeneralFlag
Opt_InfoTableMap :: GeneralFlag
Opt_InfoTableMapWithFallback :: GeneralFlag
Opt_InfoTableMapWithStack :: GeneralFlag
Opt_WarnIsError :: GeneralFlag
Opt_ShowWarnGroups :: GeneralFlag
Opt_HideSourcePaths :: GeneralFlag
Opt_PrintExplicitForalls :: GeneralFlag
Opt_PrintExplicitKinds :: GeneralFlag
Opt_PrintExplicitCoercions :: GeneralFlag
Opt_PrintExplicitRuntimeReps :: GeneralFlag
Opt_PrintEqualityRelations :: GeneralFlag
Opt_PrintAxiomIncomps :: GeneralFlag
Opt_PrintUnicodeSyntax :: GeneralFlag
Opt_PrintExpandedSynonyms :: GeneralFlag
Opt_PrintPotentialInstances :: GeneralFlag
Opt_PrintRedundantPromotionTicks :: GeneralFlag
Opt_PrintTypecheckerElaboration :: GeneralFlag
Opt_CallArity :: GeneralFlag
Opt_Exitification :: GeneralFlag
Opt_Strictness :: GeneralFlag
Opt_LateDmdAnal :: GeneralFlag
Opt_KillAbsence :: GeneralFlag
Opt_KillOneShot :: GeneralFlag
Opt_FullLaziness :: GeneralFlag
Opt_FloatIn :: GeneralFlag

-- | Enable floating out of let-bindings in the simplifier
Opt_LocalFloatOut :: GeneralFlag

-- | Enable floating out of let-bindings at the top level in the simplifier
--   N.B. See Note [RHS Floating]
Opt_LocalFloatOutTopLevel :: GeneralFlag
Opt_LateSpecialise :: GeneralFlag
Opt_Specialise :: GeneralFlag
Opt_SpecialiseAggressively :: GeneralFlag
Opt_CrossModuleSpecialise :: GeneralFlag
Opt_PolymorphicSpecialisation :: GeneralFlag
Opt_InlineGenerics :: GeneralFlag
Opt_InlineGenericsAggressively :: GeneralFlag
Opt_StaticArgumentTransformation :: GeneralFlag
Opt_CSE :: GeneralFlag
Opt_StgCSE :: GeneralFlag
Opt_StgLiftLams :: GeneralFlag
Opt_LiberateCase :: GeneralFlag
Opt_SpecConstr :: GeneralFlag
Opt_SpecConstrKeen :: GeneralFlag
Opt_SpecialiseIncoherents :: GeneralFlag
Opt_DoLambdaEtaExpansion :: GeneralFlag
Opt_DoCleverArgEtaExpansion :: GeneralFlag
Opt_IgnoreAsserts :: GeneralFlag
Opt_DoEtaReduction :: GeneralFlag
Opt_CaseMerge :: GeneralFlag
Opt_CaseFolding :: GeneralFlag
Opt_UnboxStrictFields :: GeneralFlag
Opt_UnboxSmallStrictFields :: GeneralFlag
Opt_DictsCheap :: GeneralFlag
Opt_EnableRewriteRules :: GeneralFlag
Opt_EnableThSpliceWarnings :: GeneralFlag
Opt_RegsGraph :: GeneralFlag
Opt_RegsIterative :: GeneralFlag
Opt_PedanticBottoms :: GeneralFlag
Opt_LlvmFillUndefWithGarbage :: GeneralFlag
Opt_IrrefutableTuples :: GeneralFlag
Opt_CmmSink :: GeneralFlag
Opt_CmmStaticPred :: GeneralFlag
Opt_CmmElimCommonBlocks :: GeneralFlag
Opt_CmmControlFlow :: GeneralFlag
Opt_AsmShortcutting :: GeneralFlag
Opt_OmitYields :: GeneralFlag
Opt_FunToThunk :: GeneralFlag
Opt_DictsStrict :: GeneralFlag

-- | deprecated, no effect and behaviour is now default. Allowed switching
--   of a special demand transformer for dictionary selectors
Opt_DmdTxDictSel :: GeneralFlag
Opt_Loopification :: GeneralFlag

-- | Use the cfg based block layout algorithm.
Opt_CfgBlocklayout :: GeneralFlag

-- | Layout based on last instruction per block.
Opt_WeightlessBlocklayout :: GeneralFlag
Opt_CprAnal :: GeneralFlag
Opt_WorkerWrapper :: GeneralFlag

-- | Do W/W split for unlifting even if we won't unbox anything.
Opt_WorkerWrapperUnlift :: GeneralFlag
Opt_SolveConstantDicts :: GeneralFlag
Opt_AlignmentSanitisation :: GeneralFlag
Opt_CatchNonexhaustiveCases :: GeneralFlag
Opt_NumConstantFolding :: GeneralFlag
Opt_CoreConstantFolding :: GeneralFlag
Opt_FastPAPCalls :: GeneralFlag
Opt_SpecEval :: GeneralFlag
Opt_SpecEvalDictFun :: GeneralFlag
Opt_DoTagInferenceChecks :: GeneralFlag
Opt_SimplPreInlining :: GeneralFlag
Opt_IgnoreInterfacePragmas :: GeneralFlag
Opt_OmitInterfacePragmas :: GeneralFlag
Opt_ExposeAllUnfoldings :: GeneralFlag
Opt_ExposeOverloadedUnfoldings :: GeneralFlag

-- | Keep auto-generated rules even if they seem to have become useless
Opt_KeepAutoRules :: GeneralFlag
Opt_WriteInterface :: GeneralFlag
Opt_WriteHie :: GeneralFlag

-- | render JavaScript pretty-printed instead of minified (compacted)
Opt_DisableJsMinifier :: GeneralFlag

-- | don't link C sources (compiled to JS) with Haskell code (compiled to
--   JS)
Opt_DisableJsCsources :: GeneralFlag
Opt_AutoSccsOnIndividualCafs :: GeneralFlag
Opt_ProfCountEntries :: GeneralFlag
Opt_ProfLateInlineCcs :: GeneralFlag
Opt_ProfLateCcs :: GeneralFlag
Opt_ProfLateOverloadedCcs :: GeneralFlag
Opt_ProfLateoverloadedCallsCCs :: GeneralFlag

-- | Ignore manual SCC annotations
Opt_ProfManualCcs :: GeneralFlag
Opt_Pp :: GeneralFlag
Opt_ForceRecomp :: GeneralFlag
Opt_IgnoreOptimChanges :: GeneralFlag
Opt_IgnoreHpcChanges :: GeneralFlag
Opt_ExcessPrecision :: GeneralFlag
Opt_EagerBlackHoling :: GeneralFlag
Opt_OrigThunkInfo :: GeneralFlag
Opt_NoHsMain :: GeneralFlag
Opt_SplitSections :: GeneralFlag
Opt_StgStats :: GeneralFlag
Opt_HideAllPackages :: GeneralFlag
Opt_HideAllPluginPackages :: GeneralFlag
Opt_PrintBindResult :: GeneralFlag
Opt_Haddock :: GeneralFlag
Opt_HaddockOptions :: GeneralFlag
Opt_BreakOnException :: GeneralFlag
Opt_BreakOnError :: GeneralFlag
Opt_PrintEvldWithShow :: GeneralFlag
Opt_PrintBindContents :: GeneralFlag
Opt_GenManifest :: GeneralFlag
Opt_EmbedManifest :: GeneralFlag
Opt_SharedImplib :: GeneralFlag
Opt_BuildingCabalPackage :: GeneralFlag
Opt_IgnoreDotGhci :: GeneralFlag
Opt_GhciSandbox :: GeneralFlag
Opt_InsertBreakpoints :: GeneralFlag
Opt_GhciHistory :: GeneralFlag
Opt_GhciLeakCheck :: GeneralFlag
Opt_ValidateHie :: GeneralFlag
Opt_LocalGhciHistory :: GeneralFlag
Opt_NoIt :: GeneralFlag
Opt_HelpfulErrors :: GeneralFlag
Opt_DeferTypeErrors :: GeneralFlag
Opt_DeferTypedHoles :: GeneralFlag
Opt_DeferOutOfScopeVariables :: GeneralFlag

-- | <pre>
--   -fPIC
--   </pre>
Opt_PIC :: GeneralFlag

-- | <pre>
--   -fPIE
--   </pre>
Opt_PIE :: GeneralFlag

-- | <pre>
--   -pie
--   </pre>
Opt_PICExecutable :: GeneralFlag
Opt_ExternalDynamicRefs :: GeneralFlag
Opt_Ticky :: GeneralFlag
Opt_Ticky_Allocd :: GeneralFlag
Opt_Ticky_LNE :: GeneralFlag
Opt_Ticky_Dyn_Thunk :: GeneralFlag
Opt_Ticky_Tag :: GeneralFlag

-- | Use regular thunks even when we could use std ap thunks in order to
--   get entry counts
Opt_Ticky_AP :: GeneralFlag
Opt_CmmThreadSanitizer :: GeneralFlag
Opt_RPath :: GeneralFlag
Opt_RelativeDynlibPaths :: GeneralFlag

-- | <pre>
--   -fcompact-unwind
--   </pre>
Opt_CompactUnwind :: GeneralFlag
Opt_Hpc :: GeneralFlag
Opt_FamAppCache :: GeneralFlag
Opt_ExternalInterpreter :: GeneralFlag
Opt_OptimalApplicativeDo :: GeneralFlag
Opt_VersionMacros :: GeneralFlag
Opt_WholeArchiveHsLibs :: GeneralFlag
Opt_SingleLibFolder :: GeneralFlag
Opt_ExposeInternalSymbols :: GeneralFlag
Opt_KeepCAFs :: GeneralFlag
Opt_KeepGoing :: GeneralFlag
Opt_ByteCode :: GeneralFlag
Opt_ByteCodeAndObjectCode :: GeneralFlag
Opt_UnoptimizedCoreForInterpreter :: GeneralFlag
Opt_LinkRts :: GeneralFlag
Opt_ErrorSpans :: GeneralFlag
Opt_DeferDiagnostics :: GeneralFlag

-- | Dump diagnostics as JSON
Opt_DiagnosticsAsJSON :: GeneralFlag
Opt_DiagnosticsShowCaret :: GeneralFlag
Opt_PprCaseAsLet :: GeneralFlag
Opt_PprShowTicks :: GeneralFlag
Opt_ShowHoleConstraints :: GeneralFlag
Opt_ShowValidHoleFits :: GeneralFlag
Opt_SortValidHoleFits :: GeneralFlag
Opt_SortBySizeHoleFits :: GeneralFlag
Opt_SortBySubsumHoleFits :: GeneralFlag
Opt_AbstractRefHoleFits :: GeneralFlag
Opt_UnclutterValidHoleFits :: GeneralFlag
Opt_ShowTypeAppOfHoleFits :: GeneralFlag
Opt_ShowTypeAppVarsOfHoleFits :: GeneralFlag
Opt_ShowDocsOfHoleFits :: GeneralFlag
Opt_ShowTypeOfHoleFits :: GeneralFlag
Opt_ShowProvOfHoleFits :: GeneralFlag
Opt_ShowMatchesOfHoleFits :: GeneralFlag
Opt_ShowLoadedModules :: GeneralFlag
Opt_HexWordLiterals :: GeneralFlag
Opt_SuppressCoercions :: GeneralFlag
Opt_SuppressCoercionTypes :: GeneralFlag
Opt_SuppressVarKinds :: GeneralFlag
Opt_SuppressModulePrefixes :: GeneralFlag
Opt_SuppressTypeApplications :: GeneralFlag
Opt_SuppressIdInfo :: GeneralFlag
Opt_SuppressUnfoldings :: GeneralFlag
Opt_SuppressTypeSignatures :: GeneralFlag
Opt_SuppressUniques :: GeneralFlag
Opt_SuppressStgExts :: GeneralFlag
Opt_SuppressStgReps :: GeneralFlag
Opt_SuppressTicks :: GeneralFlag

-- | Suppress timestamps in dumps
Opt_SuppressTimestamps :: GeneralFlag

-- | Suppress per binding Core size stats in dumps
Opt_SuppressCoreSizes :: GeneralFlag
Opt_ShowErrorContext :: GeneralFlag
Opt_ObjectDeterminism :: GeneralFlag
Opt_AutoLinkPackages :: GeneralFlag
Opt_ImplicitImportQualified :: GeneralFlag
Opt_KeepHscppFiles :: GeneralFlag
Opt_KeepHiDiffs :: GeneralFlag
Opt_KeepHcFiles :: GeneralFlag
Opt_KeepSFiles :: GeneralFlag
Opt_KeepTmpFiles :: GeneralFlag
Opt_KeepRawTokenStream :: GeneralFlag
Opt_KeepLlvmFiles :: GeneralFlag
Opt_KeepHiFiles :: GeneralFlag
Opt_KeepOFiles :: GeneralFlag
Opt_BuildDynamicToo :: GeneralFlag
Opt_WriteIfSimplifiedCore :: GeneralFlag
Opt_UseBytecodeRatherThanObjects :: GeneralFlag
Opt_DistrustAllPackages :: GeneralFlag
Opt_PackageTrust :: GeneralFlag
Opt_PluginTrustworthy :: GeneralFlag
Opt_G_NoStateHack :: GeneralFlag
Opt_G_NoOptCoercion :: GeneralFlag
data Language
Haskell98 :: Language
Haskell2010 :: Language
GHC2021 :: Language
GHC2024 :: Language

-- | The default Language is used if one is not specified explicitly, by
--   both GHC and GHCi.
defaultLanguage :: Language

-- | The set of flags which affect optimisation for the purposes of
--   recompilation avoidance. Specifically, these include flags which
--   affect code generation but not the semantics of the program.
--   
--   See Note [Ignoring some flag changes] in GHC.Iface.Recomp.Flags)
optimisationFlags :: EnumSet GeneralFlag

-- | The set of flags which affect code generation and can change a
--   program's runtime behavior (other than performance). These include
--   flags which affect:
--   
--   <ul>
--   <li>user visible debugging information (e.g. info table
--   provenance)</li>
--   <li>the ability to catch runtime errors (e.g. -fignore-asserts)</li>
--   <li>the runtime result of the program (e.g. -fomit-yields)</li>
--   <li>which code or interface file declarations are emitted</li>
--   </ul>
--   
--   We also considered placing flags which affect asympototic space
--   behavior (e.g. -ffull-laziness) however this would mean that changing
--   optimisation levels would trigger recompilation even with
--   -fignore-optim-changes, regressing #13604.
--   
--   Also, arguably Opt_IgnoreAsserts should be here as well; however, we
--   place it instead in <a>optimisationFlags</a> since it is implied by
--   <tt>-O[12]</tt> and therefore would also break #13604.
--   
--   See #23369.
codeGenFlags :: EnumSet GeneralFlag

-- | A group of warning flags that can be enabled or disabled collectively,
--   e.g. using <tt>-Wcompat</tt> to enable all warnings in the
--   <a>W_compat</a> group.
data WarningGroup
W_compat :: WarningGroup
W_unused_binds :: WarningGroup
W_extended_warnings :: WarningGroup
W_default :: WarningGroup
W_extra :: WarningGroup
W_all :: WarningGroup
W_everything :: WarningGroup
warningGroupName :: WarningGroup -> String
warningGroupFlags :: WarningGroup -> [WarningFlag]

-- | Does this warning group contain (all) extended warning categories? See
--   Note [Warning categories] in GHC.Unit.Module.Warnings.
--   
--   The <a>W_extended_warnings</a> group contains extended warnings but no
--   <a>WarningFlag</a>s, but extended warnings are also treated as part of
--   <a>W_default</a> and every warning group that includes it.
warningGroupIncludesExtendedWarnings :: WarningGroup -> Bool
data WarningFlag
Opt_WarnDuplicateExports :: WarningFlag
Opt_WarnDuplicateConstraints :: WarningFlag
Opt_WarnRedundantConstraints :: WarningFlag
Opt_WarnHiShadows :: WarningFlag
Opt_WarnImplicitPrelude :: WarningFlag
Opt_WarnIncompletePatterns :: WarningFlag
Opt_WarnIncompleteUniPatterns :: WarningFlag
Opt_WarnIncompletePatternsRecUpd :: WarningFlag
Opt_WarnOverflowedLiterals :: WarningFlag
Opt_WarnEmptyEnumerations :: WarningFlag
Opt_WarnMissingFields :: WarningFlag
Opt_WarnMissingImportList :: WarningFlag
Opt_WarnMissingMethods :: WarningFlag
Opt_WarnMissingSignatures :: WarningFlag
Opt_WarnMissingLocalSignatures :: WarningFlag
Opt_WarnNameShadowing :: WarningFlag
Opt_WarnOverlappingPatterns :: WarningFlag
Opt_WarnTypeDefaults :: WarningFlag
Opt_WarnMonomorphism :: WarningFlag
Opt_WarnUnusedTopBinds :: WarningFlag
Opt_WarnUnusedLocalBinds :: WarningFlag
Opt_WarnUnusedPatternBinds :: WarningFlag
Opt_WarnUnusedImports :: WarningFlag
Opt_WarnUnusedMatches :: WarningFlag
Opt_WarnUnusedTypePatterns :: WarningFlag
Opt_WarnUnusedForalls :: WarningFlag
Opt_WarnUnusedRecordWildcards :: WarningFlag
Opt_WarnRedundantBangPatterns :: WarningFlag
Opt_WarnRedundantRecordWildcards :: WarningFlag
Opt_WarnDeprecatedFlags :: WarningFlag
Opt_WarnMissingMonadFailInstances :: WarningFlag
Opt_WarnSemigroup :: WarningFlag
Opt_WarnDodgyExports :: WarningFlag
Opt_WarnDodgyImports :: WarningFlag
Opt_WarnOrphans :: WarningFlag
Opt_WarnAutoOrphans :: WarningFlag
Opt_WarnIdentities :: WarningFlag
Opt_WarnTabs :: WarningFlag
Opt_WarnUnrecognisedPragmas :: WarningFlag
Opt_WarnMisplacedPragmas :: WarningFlag
Opt_WarnDodgyForeignImports :: WarningFlag
Opt_WarnUnusedDoBind :: WarningFlag
Opt_WarnWrongDoBind :: WarningFlag
Opt_WarnAlternativeLayoutRuleTransitional :: WarningFlag
Opt_WarnUnsafe :: WarningFlag
Opt_WarnSafe :: WarningFlag
Opt_WarnTrustworthySafe :: WarningFlag
Opt_WarnMissedSpecs :: WarningFlag
Opt_WarnAllMissedSpecs :: WarningFlag
Opt_WarnUnsupportedCallingConventions :: WarningFlag
Opt_WarnUnsupportedLlvmVersion :: WarningFlag
Opt_WarnMissedExtraSharedLib :: WarningFlag
Opt_WarnInlineRuleShadowing :: WarningFlag
Opt_WarnTypedHoles :: WarningFlag
Opt_WarnPartialTypeSignatures :: WarningFlag
Opt_WarnMissingExportedSignatures :: WarningFlag
Opt_WarnUntickedPromotedConstructors :: WarningFlag
Opt_WarnDerivingTypeable :: WarningFlag
Opt_WarnDeferredTypeErrors :: WarningFlag
Opt_WarnDeferredOutOfScopeVariables :: WarningFlag
Opt_WarnNonCanonicalMonadInstances :: WarningFlag
Opt_WarnNonCanonicalMonadFailInstances :: WarningFlag
Opt_WarnNonCanonicalMonoidInstances :: WarningFlag
Opt_WarnMissingPatternSynonymSignatures :: WarningFlag
Opt_WarnUnrecognisedWarningFlags :: WarningFlag
Opt_WarnSimplifiableClassConstraints :: WarningFlag
Opt_WarnCPPUndef :: WarningFlag
Opt_WarnUnbangedStrictPatterns :: WarningFlag
Opt_WarnMissingHomeModules :: WarningFlag
Opt_WarnPartialFields :: WarningFlag
Opt_WarnMissingExportList :: WarningFlag
Opt_WarnInaccessibleCode :: WarningFlag
Opt_WarnStarIsType :: WarningFlag
Opt_WarnStarBinder :: WarningFlag
Opt_WarnImplicitKindVars :: WarningFlag
Opt_WarnSpaceAfterBang :: WarningFlag
Opt_WarnMissingDerivingStrategies :: WarningFlag
Opt_WarnPrepositiveQualifiedModule :: WarningFlag
Opt_WarnUnusedPackages :: WarningFlag
Opt_WarnInferredSafeImports :: WarningFlag
Opt_WarnMissingSafeHaskellMode :: WarningFlag
Opt_WarnCompatUnqualifiedImports :: WarningFlag
Opt_WarnDerivingDefaults :: WarningFlag
Opt_WarnInvalidHaddock :: WarningFlag
Opt_WarnOperatorWhitespaceExtConflict :: WarningFlag
Opt_WarnOperatorWhitespace :: WarningFlag
Opt_WarnAmbiguousFields :: WarningFlag
Opt_WarnImplicitLift :: WarningFlag
Opt_WarnMissingKindSignatures :: WarningFlag
Opt_WarnMissingPolyKindSignatures :: WarningFlag
Opt_WarnMissingExportedPatternSynonymSignatures :: WarningFlag
Opt_WarnRedundantStrictnessFlags :: WarningFlag
Opt_WarnForallIdentifier :: WarningFlag
Opt_WarnUnicodeBidirectionalFormatCharacters :: WarningFlag
Opt_WarnGADTMonoLocalBinds :: WarningFlag
Opt_WarnTypeEqualityOutOfScope :: WarningFlag
Opt_WarnTypeEqualityRequiresOperators :: WarningFlag
Opt_WarnLoopySuperclassSolve :: WarningFlag
Opt_WarnTermVariableCapture :: WarningFlag
Opt_WarnMissingRoleAnnotations :: WarningFlag
Opt_WarnImplicitRhsQuantification :: WarningFlag
Opt_WarnIncompleteExportWarnings :: WarningFlag
Opt_WarnIncompleteRecordSelectors :: WarningFlag
Opt_WarnBadlyStagedTypes :: WarningFlag
Opt_WarnInconsistentFlags :: WarningFlag
Opt_WarnDataKindsTC :: WarningFlag
Opt_WarnDeprecatedTypeAbstractions :: WarningFlag
Opt_WarnDefaultedExceptionContext :: WarningFlag
Opt_WarnViewPatternSignatures :: WarningFlag

-- | Return the names of a WarningFlag
--   
--   One flag may have several names because of US/UK spelling. The first
--   one is the "preferred one" that will be displayed in warning messages.
warnFlagNames :: WarningFlag -> NonEmpty String

-- | Warning groups.
--   
--   As all warnings are in the Weverything set, it is ignored when
--   displaying to the user which group a warning is in.
warningGroups :: [WarningGroup]

-- | Warning group hierarchies, where there is an explicit inclusion
--   relation.
--   
--   Each inner list is a hierarchy of warning groups, ordered from
--   smallest to largest, where each group is a superset of the one before
--   it.
--   
--   Separating this from <a>warningGroups</a> allows for multiple
--   hierarchies with no inherent relation to be defined.
--   
--   The special-case Weverything group is not included.
warningHierarchies :: [[WarningGroup]]

-- | Find the smallest group in every hierarchy which a warning belongs to,
--   excluding Weverything.
smallestWarningGroups :: WarningFlag -> [WarningGroup]

-- | The smallest group in every hierarchy to which a custom warning
--   category belongs is currently always <tt>-Wextended-warnings</tt>. See
--   Note [Warning categories] in <a>GHC.Unit.Module.Warnings</a>.
smallestWarningGroupsForCategory :: [WarningGroup]

-- | Warnings enabled unless specified otherwise
standardWarnings :: [WarningFlag]

-- | Things you get with -W
minusWOpts :: [WarningFlag]

-- | Things you get with -Wall
minusWallOpts :: [WarningFlag]

-- | Things you get with -Weverything, i.e. *all* known warnings flags
minusWeverythingOpts :: [WarningFlag]

-- | Things you get with -Wcompat.
--   
--   This is intended to group together warnings that will be enabled by
--   default at some point in the future, so that library authors eager to
--   make their code future compatible to fix issues before they even
--   generate warnings.
minusWcompatOpts :: [WarningFlag]

-- | Things you get with -Wunused-binds
unusedBindsFlags :: [WarningFlag]
type TurnOnFlag = Bool
turnOn :: TurnOnFlag
turnOff :: TurnOnFlag
impliedXFlags :: [(Extension, TurnOnFlag, Extension)]
validHoleFitsImpliedGFlags :: [(GeneralFlag, TurnOnFlag, GeneralFlag)]
impliedGFlags :: [(GeneralFlag, TurnOnFlag, GeneralFlag)]
impliedOffGFlags :: [(GeneralFlag, TurnOnFlag, GeneralFlag)]
glasgowExtsFlags :: [Extension]
data ExtensionDeprecation
ExtensionNotDeprecated :: ExtensionDeprecation
ExtensionDeprecatedFor :: [Extension] -> ExtensionDeprecation
ExtensionFlagDeprecatedCond :: TurnOnFlag -> String -> ExtensionDeprecation
ExtensionFlagDeprecated :: String -> ExtensionDeprecation
data Deprecation
NotDeprecated :: Deprecation
Deprecated :: Deprecation
extensionDeprecation :: Extension -> ExtensionDeprecation

-- | Always returns <a>Deprecated</a> even when the flag is only
--   conditionally deprecated.
deprecation :: ExtensionDeprecation -> Deprecation

-- | All the names by which an extension is known.
extensionNames :: Extension -> [(ExtensionDeprecation, String)]
extensionName :: Extension -> String
instance GHC.Utils.Binary.Binary GHC.Driver.Flags.Language
instance GHC.Internal.Enum.Bounded GHC.Driver.Flags.Language
instance GHC.Internal.Enum.Bounded GHC.Driver.Flags.WarningFlag
instance GHC.Internal.Enum.Bounded GHC.Driver.Flags.WarningGroup
instance GHC.Internal.Enum.Enum GHC.Driver.Flags.DumpFlag
instance GHC.Internal.Enum.Enum GHC.Driver.Flags.GeneralFlag
instance GHC.Internal.Enum.Enum GHC.Driver.Flags.Language
instance GHC.Internal.Enum.Enum GHC.Driver.Flags.WarningFlag
instance GHC.Internal.Enum.Enum GHC.Driver.Flags.WarningGroup
instance GHC.Classes.Eq GHC.Driver.Flags.Deprecation
instance GHC.Classes.Eq GHC.Driver.Flags.DumpFlag
instance GHC.Classes.Eq GHC.Driver.Flags.ExtensionDeprecation
instance GHC.Classes.Eq GHC.Driver.Flags.GeneralFlag
instance GHC.Classes.Eq GHC.Driver.Flags.Language
instance GHC.Classes.Eq GHC.Driver.Flags.WarningFlag
instance GHC.Classes.Eq GHC.Driver.Flags.WarningGroup
instance Control.DeepSeq.NFData GHC.Driver.Flags.Language
instance GHC.Classes.Ord GHC.Driver.Flags.Deprecation
instance GHC.Classes.Ord GHC.Driver.Flags.WarningFlag
instance GHC.Utils.Outputable.Outputable GHC.Driver.Flags.Language
instance GHC.Internal.Show.Show GHC.Driver.Flags.DumpFlag
instance GHC.Internal.Show.Show GHC.Driver.Flags.GeneralFlag
instance GHC.Internal.Show.Show GHC.Driver.Flags.Language
instance GHC.Internal.Show.Show GHC.Driver.Flags.WarningFlag


-- | Pretty printing of graphs.
module GHC.Data.Graph.Ppr

-- | Pretty print a graph in a somewhat human readable format.
dumpGraph :: (Outputable k, Outputable color) => Graph k cls color -> SDoc

-- | Pretty print a graph in graphviz .dot format. Conflicts get solid
--   edges. Coalescences get dashed edges.
dotGraph :: (Uniquable k, Outputable k, Outputable cls, Outputable color) => (color -> SDoc) -> Triv k cls color -> Graph k cls color -> SDoc


-- | Basic operations on graphs.
module GHC.Data.Graph.Ops

-- | Add a node to the graph, linking up its edges
addNode :: Uniquable k => k -> Node k cls color -> Graph k cls color -> Graph k cls color

-- | Delete a node and all its edges from the graph.
delNode :: Uniquable k => k -> Graph k cls color -> Maybe (Graph k cls color)

-- | Get a node from the graph, throwing an error if it's not there
getNode :: Uniquable k => Graph k cls color -> k -> Node k cls color

-- | Lookup a node from the graph.
lookupNode :: Uniquable k => Graph k cls color -> k -> Maybe (Node k cls color)

-- | Modify a node in the graph. returns Nothing if the node isn't present.
modNode :: Uniquable k => (Node k cls color -> Node k cls color) -> k -> Graph k cls color -> Maybe (Graph k cls color)

-- | Get the size of the graph, O(n)
size :: Graph k cls color -> Int

-- | Union two graphs together.
union :: Graph k cls color -> Graph k cls color -> Graph k cls color

-- | Add a conflict between nodes to the graph, creating the nodes
--   required. Conflicts are virtual regs which need to be colored
--   differently.
addConflict :: Uniquable k => (k, cls) -> (k, cls) -> Graph k cls color -> Graph k cls color

-- | Delete a conflict edge. k1 -&gt; k2 returns Nothing if the node isn't
--   in the graph
delConflict :: Uniquable k => k -> k -> Graph k cls color -> Maybe (Graph k cls color)

-- | Add some conflicts to the graph, creating nodes if required. All the
--   nodes in the set are taken to conflict with each other.
addConflicts :: Uniquable k => UniqSet k -> (k -> cls) -> Graph k cls color -> Graph k cls color

-- | Add a coalescence edge to the graph, creating nodes if required. It is
--   considered advantageous to assign the same color to nodes in a
--   coalescence.
addCoalesce :: Uniquable k => (k, cls) -> (k, cls) -> Graph k cls color -> Graph k cls color

-- | Delete a coalescence edge (k1 -&gt; k2) from the graph.
delCoalesce :: Uniquable k => k -> k -> Graph k cls color -> Maybe (Graph k cls color)

-- | Add an exclusion to the graph, creating nodes if required. These are
--   extra colors that the node cannot use.
addExclusion :: (Uniquable k, Uniquable color) => k -> (k -> cls) -> color -> Graph k cls color -> Graph k cls color
addExclusions :: (Uniquable k, Uniquable color) => k -> (k -> cls) -> [color] -> Graph k cls color -> Graph k cls color

-- | Add a color preference to the graph, creating nodes if required. The
--   most recently added preference is the most preferred. The algorithm
--   tries to assign a node it's preferred color if possible.
addPreference :: Uniquable k => (k, cls) -> color -> Graph k cls color -> Graph k cls color

-- | Coalesce this pair of nodes unconditionally / aggressively. The
--   resulting node is the one with the least key.
--   
--   returns: Just the pair of keys if the nodes were coalesced the second
--   element of the pair being the least one
--   
--   Nothing if either of the nodes weren't in the graph
coalesceNodes :: (Uniquable k, Ord k, Eq cls) => Bool -> Triv k cls color -> Graph k cls color -> (k, k) -> (Graph k cls color, Maybe (k, k))

-- | Do aggressive coalescing on this graph. returns the new graph and the
--   list of pairs of nodes that got coalesced together. for each pair, the
--   resulting node will have the least key and be second in the pair.
coalesceGraph :: (Uniquable k, Ord k, Eq cls, Outputable k) => Bool -> Triv k cls color -> Graph k cls color -> (Graph k cls color, [(k, k)])

-- | Freeze a node This is for the iterative coalescer. By freezing a node
--   we give up on ever coalescing it. Move all its coalesce edges into the
--   frozen set - and update back edges from other nodes.
freezeNode :: Uniquable k => k -> Graph k cls color -> Graph k cls color

-- | Freeze one node in the graph This if for the iterative coalescer. Look
--   for a move related node of low degree and freeze it.
--   
--   We probably don't need to scan the whole graph looking for the node of
--   absolute lowest degree. Just sample the first few and choose the one
--   with the lowest degree out of those. Also, we don't make any
--   distinction between conflicts of different classes.. this is just a
--   heuristic, after all.
--   
--   IDEA: freezing a node might free it up for Simplify.. would be good to
--   check for triv right here, and add it to a worklist if known
--   triv/non-move nodes.
freezeOneInGraph :: Uniquable k => Graph k cls color -> (Graph k cls color, Bool)

-- | Freeze all the nodes in the graph for debugging the iterative
--   allocator.
freezeAllInGraph :: Uniquable k => Graph k cls color -> Graph k cls color

-- | Find all the nodes in the graph that meet some criteria
scanGraph :: (Node k cls color -> Bool) -> Graph k cls color -> [Node k cls color]

-- | Set the color of a certain node
setColor :: Uniquable k => k -> color -> Graph k cls color -> Graph k cls color

-- | validate the internal structure of a graph all its edges should point
--   to valid nodes If they don't then throw an error
validateGraph :: (Uniquable k, Outputable k, Eq color) => SDoc -> Bool -> Graph k cls color -> Graph k cls color

-- | Slurp out a map of how many nodes had a certain number of conflict
--   neighbours
slurpNodeConflictCount :: Graph k cls color -> UniqFM Int (Int, Int)

module GHC.Data.Graph.Directed
data Graph node
graphFromEdgedVerticesOrd :: Ord key => [Node key payload] -> Graph (Node key payload)
graphFromEdgedVerticesUniq :: Uniquable key => [Node key payload] -> Graph (Node key payload)
graphFromVerticesAndAdjacency :: Ord key => [Node key payload] -> [(key, key)] -> Graph (Node key payload)

-- | Strongly connected component.
data SCC vertex

-- | A single vertex that is not in any cycle.
AcyclicSCC :: vertex -> SCC vertex

-- | A maximal set of mutually reachable vertices.
NECyclicSCC :: {-# UNPACK #-} !NonEmpty vertex -> SCC vertex

-- | Partial pattern synonym for backward compatibility with <tt>containers
--   &lt; 0.7</tt>.
pattern CyclicSCC :: [vertex] -> SCC vertex

-- | Representation for nodes of the Graph.
--   
--   <ul>
--   <li>The <tt>payload</tt> is user data, just carried around in this
--   module</li>
--   <li>The <tt>key</tt> is the node identifier. Key has an Ord instance
--   for performance reasons.</li>
--   <li>The <tt>[key]</tt> are the dependencies of the node; it's ok to
--   have extra keys in the dependencies that are not the key of any Node
--   in the graph</li>
--   </ul>
data Node key payload
DigraphNode :: payload -> key -> [key] -> Node key payload

-- | User data
[node_payload] :: Node key payload -> payload

-- | User defined node id
[node_key] :: Node key payload -> key

-- | Dependencies/successors of the node
[node_dependencies] :: Node key payload -> [key]

-- | The vertices of a strongly connected component.
flattenSCC :: SCC vertex -> [vertex]

-- | The vertices of a list of strongly connected components.
flattenSCCs :: [SCC a] -> [a]
stronglyConnCompG :: Graph node -> [SCC node]
topologicalSortG :: Graph node -> [node]
verticesG :: Graph node -> [node]
edgesG :: Graph node -> [Edge node]
hasVertexG :: Graph node -> node -> Bool
reachableG :: Graph node -> node -> [node]

-- | Given a list of roots return all reachable nodes.
reachablesG :: Graph node -> [node] -> [node]
transposeG :: Graph node -> Graph node

-- | Efficiently construct a map which maps each key to it's set of
--   transitive dependencies. Only works on acyclic input.
allReachable :: Ord key => Graph node -> (node -> key) -> Map key (Set key)

-- | Efficiently construct a map which maps each key to it's set of
--   transitive dependencies. Less efficient than <tt>allReachable</tt>,
--   but works on cyclic input as well.
allReachableCyclic :: Ord key => Graph node -> (node -> key) -> Map key (Set key)
outgoingG :: Graph node -> node -> [node]
emptyG :: Graph node -> Bool

-- | Find a reasonably short cycle a-&gt;b-&gt;c-&gt;a, in a graph The
--   graph might not necessarily be strongly connected.
findCycle :: forall payload key. Ord key => [Node key payload] -> Maybe [payload]
stronglyConnCompFromEdgedVerticesOrd :: Ord key => [Node key payload] -> [SCC payload]
stronglyConnCompFromEdgedVerticesOrdR :: Ord key => [Node key payload] -> [SCC (Node key payload)]
stronglyConnCompFromEdgedVerticesUniq :: Uniquable key => [Node key payload] -> [SCC payload]
stronglyConnCompFromEdgedVerticesUniqR :: Uniquable key => [Node key payload] -> [SCC (Node key payload)]

-- | Edge direction based on DFS Classification
data EdgeType
Forward :: EdgeType
Cross :: EdgeType

-- | Loop back towards the root node. Eg backjumps in loops
Backward :: EdgeType

-- | v -&gt; v
SelfLoop :: EdgeType

-- | Given a start vertex, a way to get successors from a node and a list
--   of (directed) edges classify the types of edges.
classifyEdges :: Uniquable key => key -> (key -> [key]) -> [(key, key)] -> [((key, key), EdgeType)]
instance GHC.Classes.Eq GHC.Data.Graph.Directed.EdgeType
instance GHC.Classes.Eq GHC.Data.Graph.Directed.Time
instance GHC.Internal.Base.Functor (GHC.Data.Graph.Directed.Node key)
instance GHC.Internal.Num.Num GHC.Data.Graph.Directed.Time
instance GHC.Classes.Ord GHC.Data.Graph.Directed.EdgeType
instance GHC.Classes.Ord GHC.Data.Graph.Directed.Time
instance GHC.Utils.Outputable.Outputable node => GHC.Utils.Outputable.Outputable (GHC.Data.Graph.Directed.Edge node)
instance GHC.Utils.Outputable.Outputable GHC.Data.Graph.Directed.EdgeType
instance GHC.Utils.Outputable.Outputable node => GHC.Utils.Outputable.Outputable (GHC.Data.Graph.Directed.Graph node)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b) => GHC.Utils.Outputable.Outputable (GHC.Data.Graph.Directed.Node a b)
instance GHC.Utils.Outputable.Outputable GHC.Data.Graph.Directed.Time


-- | Graph Coloring. This is a generic graph coloring library, abstracted
--   over the type of the node keys, nodes and colors.
module GHC.Data.Graph.Color

-- | Try to color a graph with this set of colors. Uses Chaitin's algorithm
--   to color the graph. The graph is scanned for nodes which are deamed
--   'trivially colorable'. These nodes are pushed onto a stack and removed
--   from the graph. Once this process is complete the graph can be colored
--   by removing nodes from the stack (ie in reverse order) and assigning
--   them colors different to their neighbors.
colorGraph :: (Uniquable k, Uniquable cls, Uniquable color, Eq cls, Ord k, Outputable k, Outputable cls, Outputable color) => Bool -> Int -> UniqFM cls (UniqSet color) -> Triv k cls color -> (Graph k cls color -> k) -> Graph k cls color -> (Graph k cls color, UniqSet k, UniqFM k k)

module GHC.Cmm.Dataflow.Label
data Label
data LabelMap v
data LabelSet
type FactBase f = LabelMap f
lookupFact :: Label -> FactBase f -> Maybe f
mkHooplLabel :: Word64 -> Label
setEmpty :: LabelSet
setNull :: LabelSet -> Bool
setSize :: LabelSet -> Int
setMember :: Label -> LabelSet -> Bool
setSingleton :: Label -> LabelSet
setInsert :: Label -> LabelSet -> LabelSet
setDelete :: Label -> LabelSet -> LabelSet
setUnion :: LabelSet -> LabelSet -> LabelSet
setUnions :: [LabelSet] -> LabelSet
setDifference :: LabelSet -> LabelSet -> LabelSet
setIntersection :: LabelSet -> LabelSet -> LabelSet
setIsSubsetOf :: LabelSet -> LabelSet -> Bool
setFilter :: (Label -> Bool) -> LabelSet -> LabelSet
setFoldl :: (t -> Label -> t) -> t -> LabelSet -> t
setFoldr :: (Label -> t -> t) -> t -> LabelSet -> t
setFromList :: [Label] -> LabelSet
setElems :: LabelSet -> [Label]
mapNull :: LabelMap a -> Bool
mapSize :: LabelMap a -> Int
mapMember :: Label -> LabelMap a -> Bool
mapLookup :: Label -> LabelMap a -> Maybe a
mapFindWithDefault :: a -> Label -> LabelMap a -> a
mapEmpty :: LabelMap v
mapSingleton :: Label -> v -> LabelMap v
mapInsert :: Label -> v -> LabelMap v -> LabelMap v
mapInsertWith :: (v -> v -> v) -> Label -> v -> LabelMap v -> LabelMap v
mapDelete :: Label -> LabelMap v -> LabelMap v
mapAlter :: (Maybe v -> Maybe v) -> Label -> LabelMap v -> LabelMap v
mapAdjust :: (v -> v) -> Label -> LabelMap v -> LabelMap v
mapUnion :: LabelMap v -> LabelMap v -> LabelMap v
mapUnions :: [LabelMap a] -> LabelMap a
mapUnionWithKey :: (Label -> v -> v -> v) -> LabelMap v -> LabelMap v -> LabelMap v
mapDifference :: LabelMap v -> LabelMap b -> LabelMap v
mapIntersection :: LabelMap v -> LabelMap b -> LabelMap v
mapIsSubmapOf :: Eq a => LabelMap a -> LabelMap a -> Bool
mapMap :: (a -> v) -> LabelMap a -> LabelMap v
mapMapWithKey :: (Label -> a -> v) -> LabelMap a -> LabelMap v
mapFoldl :: (a -> b -> a) -> a -> LabelMap b -> a
mapFoldr :: (a -> b -> b) -> b -> LabelMap a -> b
mapFoldlWithKey :: (t -> Label -> b -> t) -> t -> LabelMap b -> t
mapFoldMapWithKey :: Monoid m => (Label -> t -> m) -> LabelMap t -> m
mapFilter :: (v -> Bool) -> LabelMap v -> LabelMap v
mapFilterWithKey :: (Label -> v -> Bool) -> LabelMap v -> LabelMap v
mapElems :: LabelMap a -> [a]
mapKeys :: LabelMap a -> [Label]
mapToList :: LabelMap b -> [(Label, b)]
mapFromList :: [(Label, v)] -> LabelMap v
mapFromListWith :: (v -> v -> v) -> [(Label, v)] -> LabelMap v
instance GHC.Classes.Eq GHC.Cmm.Dataflow.Label.Label
instance GHC.Classes.Eq v => GHC.Classes.Eq (GHC.Cmm.Dataflow.Label.LabelMap v)
instance GHC.Classes.Eq GHC.Cmm.Dataflow.Label.LabelSet
instance GHC.Internal.Data.Foldable.Foldable GHC.Cmm.Dataflow.Label.LabelMap
instance GHC.Internal.Base.Functor GHC.Cmm.Dataflow.Label.LabelMap
instance GHC.Internal.Base.Monoid GHC.Cmm.Dataflow.Label.LabelSet
instance GHC.Classes.Ord GHC.Cmm.Dataflow.Label.Label
instance GHC.Classes.Ord v => GHC.Classes.Ord (GHC.Cmm.Dataflow.Label.LabelMap v)
instance GHC.Classes.Ord GHC.Cmm.Dataflow.Label.LabelSet
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Dataflow.Label.Label
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Cmm.Dataflow.Label.LabelMap a)
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Dataflow.Label.LabelSet
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.Dataflow.Label.Label
instance GHC.Utils.Outputable.OutputableP env a => GHC.Utils.Outputable.OutputableP env (GHC.Cmm.Dataflow.Label.LabelMap a)
instance GHC.Internal.Base.Semigroup GHC.Cmm.Dataflow.Label.LabelSet
instance GHC.Internal.Show.Show GHC.Cmm.Dataflow.Label.Label
instance GHC.Internal.Show.Show v => GHC.Internal.Show.Show (GHC.Cmm.Dataflow.Label.LabelMap v)
instance GHC.Internal.Show.Show GHC.Cmm.Dataflow.Label.LabelSet
instance GHC.Internal.Data.Traversable.Traversable GHC.Cmm.Dataflow.Label.LabelMap
instance GHC.Data.TrieMap.TrieMap GHC.Cmm.Dataflow.Label.LabelMap
instance GHC.Types.Unique.Uniquable GHC.Cmm.Dataflow.Label.Label

module GHC.Data.Graph.Collapse

-- | A "supernode" stands for a collection of one or more nodes (basic
--   blocks) that have been coalesced by the Hecht-Ullman algorithm. A
--   collection in a supernode constitutes a <i>reducible</i> subgraph of a
--   control-flow graph. (When an entire control-flow graph is collapsed to
--   a single supernode, the flow graph is reducible.)
--   
--   The idea of node splitting is to collapse a control-flow graph down to
--   a single supernode, then materialize (`<tt>inflate'</tt>) the
--   reducible equivalent graph from that supernode. The <a>Supernode</a>
--   class defines only the methods needed to collapse; rematerialization
--   is the responsibility of the client.
--   
--   During the Hecht-Ullman algorithm, every supernode has a unique entry
--   point, which is given by <a>superLabel</a>. But this invariant is not
--   guaranteed by the class methods and is not a law of the class. The
--   <a>mapLabels</a> function rewrites all labels that appear in a
--   supernode (both definitions and uses). The <a>freshen</a> function
--   replaces every appearance of a <i>defined</i> label with a fresh
--   label. (Appearances include both definitions and uses.)
--   
--   Laws: <tt> superLabel (n &lt;&gt; n') == superLabel n blocks (n
--   &lt;&gt; n') == blocks n <a>union</a> blocks n' mapLabels f (n
--   &lt;&gt; n') = mapLabels f n &lt;&gt; mapLabels f n' mapLabels id ==
--   id mapLabels (f . g) == mapLabels f . mapLabels g </tt>
--   
--   (We expect <a>freshen</a> to distribute over <a>&lt;&gt;</a>, but
--   because of the fresh names involved, formulating a precise law is a
--   bit challenging.)
class Semigroup node => PureSupernode node
superLabel :: PureSupernode node => node -> Label
mapLabels :: PureSupernode node => (Label -> Label) -> node -> node
class (MonadGetUnique m, PureSupernode node) => Supernode node (m :: Type -> Type)
freshen :: Supernode node m => node -> m node

-- | Using the algorithm of Hecht and Ullman (1972), collapse a graph into
--   a single node, splitting nodes as needed. Record visualization events
--   in monad <tt>m</tt>.
collapseInductiveGraph :: (DynGraph gr, Supernode s m, VizCollapseMonad m gr s) => gr s () -> m (gr s ())

-- | Module : GHC.Data.Graph.Collapse Description : Implement the
--   "collapsing" algorithm Hecht and Ullman
--   
--   A control-flow graph is reducible if and only if it is collapsible
--   according to the definition of Hecht and Ullman (1972). This module
--   implements the collapsing algorithm of Hecht and Ullman, and if it
--   encounters a graph that is not collapsible, it splits nodes until the
--   graph is fully collapsed. It then reports what nodes (if any) had to
--   be split in order to collapse the graph. The information is used
--   upstream to node-split Cmm graphs.
--   
--   The module uses the inductive graph representation cloned from the
--   Functional Graph Library (Hackage package <tt>fgl</tt>, modules
--   <a>*</a>.)
--   
--   If you want to visualize the graph-collapsing algorithm, create an
--   instance of monad <a>VizCollapseMonad</a>. Each step in the algorithm
--   is announced to the monad as a side effect. If you don't care about
--   visualization, you would use the <a>NullCollapseViz</a> monad, in
--   which these operations are no-ops.
class (MonadUniqDSM m, Graph gr, Supernode s m) => VizCollapseMonad (m :: Type -> Type) (gr :: Type -> Type -> Type) s
consumeByInGraph :: VizCollapseMonad m gr s => Node -> Node -> gr s () -> m ()
splitGraphAt :: VizCollapseMonad m gr s => gr s () -> LNode s -> m ()
finalGraph :: VizCollapseMonad m gr s => gr s () -> m ()

-- | The identity monad as a <a>VizCollapseMonad</a>. Use this monad when
--   you want efficiency in graph collapse.
newtype NullCollapseViz a
NullCollapseViz :: UniqDSM a -> NullCollapseViz a
[unNCV] :: NullCollapseViz a -> UniqDSM a
runNullCollapse :: NullCollapseViz a -> UniqDSM a
class Monad m => MonadUniqDSM (m :: Type -> Type)

-- | Lift a pure <a>UniqDSM</a> action into a <a>MonadUniqDSM</a> such as
--   <a>UniqDSMT</a>
liftUniqDSM :: MonadUniqDSM m => UniqDSM a -> m a
instance GHC.Internal.Base.Applicative GHC.Data.Graph.Collapse.NullCollapseViz
instance GHC.Internal.Base.Functor GHC.Data.Graph.Collapse.NullCollapseViz
instance GHC.Types.Unique.DSM.MonadGetUnique GHC.Data.Graph.Collapse.NullCollapseViz
instance GHC.Internal.Base.Monad GHC.Data.Graph.Collapse.NullCollapseViz
instance GHC.Types.Unique.DSM.MonadUniqDSM GHC.Data.Graph.Collapse.NullCollapseViz
instance (GHC.Data.Graph.Inductive.Graph.Graph gr, GHC.Data.Graph.Collapse.Supernode s GHC.Data.Graph.Collapse.NullCollapseViz) => GHC.Data.Graph.Collapse.VizCollapseMonad GHC.Data.Graph.Collapse.NullCollapseViz gr s

module GHC.Cmm.Dataflow.Graph

-- | A (possibly empty) collection of closed/closed blocks
type Body (s :: Type -> k) (n :: Extensibility -> Extensibility -> Type) = Body' s Block n

-- | A control-flow graph, which may take any of four shapes (O/O, O<i>C,
--   C</i>O, C/C). A graph open at the entry has a single, distinguished,
--   anonymous entry point; if a graph is closed at the entry, its entry
--   point(s) are supplied by a context.
type Graph = Graph' LabelMap Block

-- | <tt>Graph'</tt> is abstracted over the block type, so that we can
--   build graphs of annotated blocks for example (Compiler.Hoopl.Dataflow
--   needs this).
data Graph' (s :: Type -> Type) (block :: Extensibility -> Extensibility -> Type -> Extensibility -> Extensibility -> Type) (n :: Extensibility -> Extensibility -> Type) (e :: Extensibility) (x :: Extensibility)
[GNil] :: forall (s :: Type -> Type) (block :: (Extensibility -> Extensibility -> Type) -> Extensibility -> Extensibility -> Type) (n :: Extensibility -> Extensibility -> Type). Graph' s block n 'Open 'Open
[GUnit] :: forall (block :: (Extensibility -> Extensibility -> Type) -> Extensibility -> Extensibility -> Type) (n :: Extensibility -> Extensibility -> Type) (s :: Type -> Type). block n O O -> Graph' s block n 'Open 'Open
[GMany] :: forall (e :: Extensibility) (block :: (Extensibility -> Extensibility -> Type) -> Extensibility -> Extensibility -> Type) (n :: Extensibility -> Extensibility -> Type) (s :: Type -> Type) (x :: Extensibility). MaybeO e (block n O C) -> Body' s block n -> MaybeO x (block n C O) -> Graph' s block n e x

-- | Gives access to the anchor points for nonlocal edges as well as the
--   edges themselves
class NonLocal (thing :: Extensibility -> Extensibility -> Type)
entryLabel :: forall (x :: Extensibility). NonLocal thing => thing C x -> Label
successors :: forall (e :: Extensibility). NonLocal thing => thing e C -> [Label]
addBlock :: (NonLocal block, HasDebugCallStack) => block C C -> LabelMap (block C C) -> LabelMap (block C C)
bodyList :: forall block (n :: Extensibility -> Extensibility -> Type). Body' LabelMap block n -> [(Label, block n C C)]
bodyToBlockList :: forall (n :: Extensibility -> Extensibility -> Type). Body LabelMap n -> [Block n C C]
emptyBody :: forall block (n :: Extensibility -> Extensibility -> Type). Body' LabelMap block n
labelsDefined :: forall (block :: (Extensibility -> Extensibility -> Type) -> Extensibility -> Extensibility -> Type) (n :: Extensibility -> Extensibility -> Type) (e :: Extensibility) (x :: Extensibility). NonLocal (block n) => Graph' LabelMap block n e x -> LabelSet

-- | Maps over all nodes in a graph.
mapGraph :: forall n n' (e :: Extensibility) (x :: Extensibility). (forall (e1 :: Extensibility) (x1 :: Extensibility). () => n e1 x1 -> n' e1 x1) -> Graph n e x -> Graph n' e x

-- | Function <a>mapGraphBlocks</a> enables a change of representation of
--   blocks, nodes, or both. It lifts a polymorphic block transform into a
--   polymorphic graph transform. When the block representation stabilizes,
--   a similar function should be provided for blocks.
mapGraphBlocks :: forall s block (n :: Extensibility -> Extensibility -> Type) block' (n' :: Extensibility -> Extensibility -> Type) (e :: Extensibility) (x :: Extensibility). (forall a b. () => (a -> b) -> s a -> s b) -> (forall (e1 :: Extensibility) (x1 :: Extensibility). () => block n e1 x1 -> block' n' e1 x1) -> Graph' s block n e x -> Graph' s block' n' e x

-- | Returns a list of blocks reachable from the provided Labels in the
--   reverse postorder.
--   
--   This is the most important traversal over this data structure. It
--   drops unreachable code and puts blocks in an order that is good for
--   solving forward dataflow problems quickly. The reverse order is good
--   for solving backward dataflow problems quickly. The forward order is
--   also reasonably good for emitting instructions, except that it will
--   not usually exploit Forrest Baskett's trick of eliminating the
--   unconditional branch from a loop. For that you would need a more
--   serious analysis, probably based on dominators, to identify loop
--   headers.
--   
--   For forward analyses we want reverse postorder visitation, consider:
--   <tt> A -&gt; [B,C] B -&gt; D C -&gt; D </tt> Postorder: [D, C, B, A]
--   (or [D, B, C, A]) Reverse postorder: [A, B, C, D] (or [A, C, B, D])
--   This matters for, e.g., forward analysis, because we want to analyze
--   *both* B and C before we analyze D.
revPostorderFrom :: NonLocal block => LabelMap (block C C) -> Label -> [block C C]
instance GHC.Cmm.Dataflow.Graph.NonLocal n => GHC.Cmm.Dataflow.Graph.NonLocal (GHC.Cmm.Dataflow.Block.Block n)

module Language.Haskell.Syntax.Specificity

-- | ForAllTyFlag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, ForAllTyBinders, TyConBinders,
--   and visibility] in <a>GHC.Core.TyCo.Rep</a>
data ForAllTyFlag
Invisible :: !Specificity -> ForAllTyFlag
Required :: ForAllTyFlag
pattern Specified :: ForAllTyFlag
pattern Inferred :: ForAllTyFlag

-- | Whether an <a>Invisible</a> argument may appear in source Haskell.
data Specificity

-- | the argument may not appear in source Haskell, it is only inferred.
InferredSpec :: Specificity

-- | the argument may appear in source Haskell, but isn't required.
SpecifiedSpec :: Specificity

-- | Does this <a>ForAllTyFlag</a> classify an argument that is written in
--   Haskell?
isVisibleForAllTyFlag :: ForAllTyFlag -> Bool

-- | Does this <a>ForAllTyFlag</a> classify an argument that is not written
--   in Haskell?
isInvisibleForAllTyFlag :: ForAllTyFlag -> Bool
isInferredForAllTyFlag :: ForAllTyFlag -> Bool
isSpecifiedForAllTyFlag :: ForAllTyFlag -> Bool

-- | The ForAllTyFlag on a (Lam a e) term, where <tt>a</tt> is a type
--   variable. If you want other ForAllTyFlag, use a cast. See Note
--   [Required foralls in Core] in GHC.Core.TyCo.Rep
coreTyLamForAllTyFlag :: ForAllTyFlag
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Specificity.ForAllTyFlag
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Specificity.Specificity
instance GHC.Classes.Eq Language.Haskell.Syntax.Specificity.ForAllTyFlag
instance GHC.Classes.Eq Language.Haskell.Syntax.Specificity.Specificity
instance GHC.Classes.Ord Language.Haskell.Syntax.Specificity.ForAllTyFlag
instance GHC.Classes.Ord Language.Haskell.Syntax.Specificity.Specificity

module GHC.Hs.Specificity
instance GHC.Utils.Binary.Binary Language.Haskell.Syntax.Specificity.ForAllTyFlag
instance GHC.Utils.Binary.Binary Language.Haskell.Syntax.Specificity.Specificity
instance Control.DeepSeq.NFData Language.Haskell.Syntax.Specificity.ForAllTyFlag
instance Control.DeepSeq.NFData Language.Haskell.Syntax.Specificity.Specificity
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Specificity.ForAllTyFlag

module GHC.Types.Basic
data LeftOrRight
CLeft :: LeftOrRight
CRight :: LeftOrRight
pickLR :: LeftOrRight -> (a, a) -> a

-- | A *one-index* constructor tag
--   
--   Type of the tags associated with each constructor possibility or
--   superclass selector
type ConTag = Int

-- | A *zero-indexed* constructor tag
type ConTagZ = Int

-- | Tags are allocated from here for real constructors or for superclass
--   selectors
fIRST_TAG :: ConTag

-- | The number of value arguments that can be applied to a value before it
--   does "real work". So: fib 100 has arity 0 x -&gt; fib x has arity 1
--   See also Note [Definition of arity] in <a>GHC.Core.Opt.Arity</a>
type Arity = Int

-- | Syntactic (visibility) arity, i.e. the number of visible arguments.
--   See Note [Visibility and arity]
type VisArity = Int

-- | Representation Arity
--   
--   The number of represented arguments that can be applied to a value
--   before it does "real work". So: fib 100 has representation arity 0 x
--   -&gt; fib x has representation arity 1 (# x, y #) -&gt; fib (x + y)
--   has representation arity 2
type RepArity = Int

-- | The number of arguments that a join point takes. Unlike the arity of a
--   function, this is a purely syntactic property and is fixed when the
--   join point is created (or converted from a value). Both type and value
--   arguments are counted.
type JoinArity = Int

-- | FullArgCount is the number of type or value arguments in an
--   application, or the number of type or value binders in a lambda. Note:
--   it includes both type and value arguments!
type FullArgCount = Int
data JoinPointHood
JoinPoint :: {-# UNPACK #-} !Int -> JoinPointHood
NotJoinPoint :: JoinPointHood
isJoinPoint :: JoinPointHood -> Bool

-- | A power-of-two alignment
data Alignment
mkAlignment :: Int -> Alignment
alignmentOf :: Int -> Alignment
alignmentBytes :: Alignment -> Int
data PromotionFlag
NotPromoted :: PromotionFlag
IsPromoted :: PromotionFlag
isPromoted :: PromotionFlag -> Bool
data FunctionOrData
IsFunction :: FunctionOrData
IsData :: FunctionOrData

-- | Recursivity Flag
data RecFlag
Recursive :: RecFlag
NonRecursive :: RecFlag
isRec :: RecFlag -> Bool
isNonRec :: RecFlag -> Bool
boolToRecFlag :: Bool -> RecFlag

-- | Was this piece of code user-written or generated by the compiler?
--   
--   See Note [Generated code and pattern-match checking].
data Origin
FromSource :: Origin
Generated :: GenReason -> DoPmc -> Origin
isGenerated :: Origin -> Bool

-- | Whether to run pattern-match checks in generated code.
--   
--   See Note [Generated code and pattern-match checking].
data DoPmc
SkipPmc :: DoPmc
DoPmc :: DoPmc

-- | Does this <a>Origin</a> require us to run pattern-match checking, or
--   should we skip these checks?
--   
--   See Note [Generated code and pattern-match checking].
requiresPMC :: Origin -> Bool

-- | This metadata stores the information as to why was the piece of code
--   generated It is useful for generating the right error context See Part
--   3 in Note [Expanding HsDo with XXExprGhcRn] in <a>Do</a>
data GenReason
DoExpansion :: HsDoFlavour -> GenReason
OtherExpansion :: GenReason
isDoExpansionGenerated :: Origin -> Bool
doExpansionFlavour :: Origin -> Maybe HsDoFlavour
doExpansionOrigin :: HsDoFlavour -> Origin
type RuleName = FastString
pprRuleName :: RuleName -> SDoc
data TopLevelFlag
TopLevel :: TopLevelFlag
NotTopLevel :: TopLevelFlag
isTopLevel :: TopLevelFlag -> Bool
isNotTopLevel :: TopLevelFlag -> Bool

-- | The semantics allowed for overlapping instances for a particular
--   instance. See Note [Safe Haskell isSafeOverlap] in GHC.Core.InstEnv
--   for a explanation of the <a>isSafeOverlap</a> field.
data OverlapFlag
OverlapFlag :: OverlapMode -> Bool -> OverlapFlag
[overlapMode] :: OverlapFlag -> OverlapMode
[isSafeOverlap] :: OverlapFlag -> Bool
data OverlapMode

-- | This instance must not overlap another <a>NoOverlap</a> instance.
--   However, it may be overlapped by <a>Overlapping</a> instances, and it
--   may overlap <a>Overlappable</a> instances.
NoOverlap :: SourceText -> OverlapMode

-- | Silently ignore this instance if you find a more specific one that
--   matches the constraint you are trying to resolve
--   
--   Example: constraint (Foo [Int]) instance Foo [Int] instance {-#
--   OVERLAPPABLE #-} Foo [a]
--   
--   Since the second instance has the Overlappable flag, the first
--   instance will be chosen (otherwise its ambiguous which to choose)
Overlappable :: SourceText -> OverlapMode

-- | Silently ignore any more general instances that may be used to solve
--   the constraint.
--   
--   Example: constraint (Foo [Int]) instance {-# OVERLAPPING #-} Foo [Int]
--   instance Foo [a]
--   
--   Since the first instance has the Overlapping flag, the second---more
--   general---instance will be ignored (otherwise it is ambiguous which to
--   choose)
Overlapping :: SourceText -> OverlapMode

-- | Equivalent to having both <a>Overlapping</a> and <a>Overlappable</a>
--   flags.
Overlaps :: SourceText -> OverlapMode

-- | Behave like Overlappable and Overlapping, and in addition pick an
--   arbitrary one if there are multiple matching candidates, and don't
--   worry about later instantiation
--   
--   Example: constraint (Foo [b]) instance {-# INCOHERENT -} Foo [Int]
--   instance Foo [a] Without the Incoherent flag, we'd complain that
--   instantiating <tt>b</tt> would change which instance was chosen. See
--   also Note [Incoherent instances] in <a>GHC.Core.InstEnv</a>
Incoherent :: SourceText -> OverlapMode

-- | Behave like Incoherent, but the instance choice is observable by the
--   program behaviour. See Note [Coherence and specialisation: overview].
--   
--   We don't have surface syntax for the distinction between Incoherent
--   and NonCanonical instances; instead, the flag
--   `-f{no-}specialise-incoherents` (on by default) controls whether
--   <tt>INCOHERENT</tt> instances are regarded as Incoherent or
--   NonCanonical.
NonCanonical :: SourceText -> OverlapMode
setOverlapModeMaybe :: OverlapFlag -> Maybe OverlapMode -> OverlapFlag
hasOverlappingFlag :: OverlapMode -> Bool
hasOverlappableFlag :: OverlapMode -> Bool
hasIncoherentFlag :: OverlapMode -> Bool
hasNonCanonicalFlag :: OverlapMode -> Bool
data Boxity
Boxed :: Boxity
Unboxed :: Boxity
isBoxed :: Boxity -> Bool

-- | Should an argument be passed evaluated *and* tagged.
data CbvMark
MarkedCbv :: CbvMark
NotMarkedCbv :: CbvMark
isMarkedCbv :: CbvMark -> Bool

-- | A general-purpose pretty-printing precedence type.
newtype PprPrec
PprPrec :: Int -> PprPrec
topPrec :: PprPrec
sigPrec :: PprPrec
opPrec :: PprPrec
funPrec :: PprPrec
starPrec :: PprPrec
appPrec :: PprPrec
maxPrec :: PprPrec
maybeParen :: PprPrec -> PprPrec -> SDoc -> SDoc
data TupleSort
BoxedTuple :: TupleSort
UnboxedTuple :: TupleSort
ConstraintTuple :: TupleSort
tupleSortBoxity :: TupleSort -> Boxity
boxityTupleSort :: Boxity -> TupleSort
tupleParens :: TupleSort -> SDoc -> SDoc

-- | Are we dealing with an unboxed tuple or an unboxed sum?
--   
--   Used when validity checking, see <tt>check_ubx_tuple_or_sum</tt>.
data UnboxedTupleOrSum
UnboxedTupleType :: UnboxedTupleOrSum
UnboxedSumType :: UnboxedTupleOrSum
unboxedTupleOrSumExtension :: UnboxedTupleOrSum -> Extension
sumParens :: SDoc -> SDoc

-- | Pretty print an alternative in an unboxed sum e.g. "| a | |".
pprAlternative :: (a -> SDoc) -> a -> ConTag -> Arity -> SDoc

-- | If the <tt>Id</tt> is a lambda-bound variable then it may have
--   lambda-bound variable info. Sometimes we know whether the lambda
--   binding this variable is a "one-shot" lambda; that is, whether it is
--   applied at most once.
--   
--   This information may be useful in optimisation, as computations may
--   safely be floated inside such a lambda without risk of duplicating
--   work.
--   
--   See also Note [OneShotInfo overview] above.
data OneShotInfo

-- | No information
NoOneShotInfo :: OneShotInfo

-- | The lambda is applied at most once.
OneShotLam :: OneShotInfo

-- | It is always safe to assume that an <tt>Id</tt> has no lambda-bound
--   variable information
noOneShotInfo :: OneShotInfo
hasNoOneShotInfo :: OneShotInfo -> Bool
isOneShotInfo :: OneShotInfo -> Bool
bestOneShot :: OneShotInfo -> OneShotInfo -> OneShotInfo
worstOneShot :: OneShotInfo -> OneShotInfo -> OneShotInfo

-- | identifier Occurrence Information
data OccInfo

-- | There are many occurrences, or unknown occurrences
ManyOccs :: !TailCallInfo -> OccInfo
[occ_tail] :: OccInfo -> !TailCallInfo

-- | Marks unused variables. Sometimes useful for lambda and case-bound
--   variables.
IAmDead :: OccInfo

-- | Occurs exactly once (per branch), not inside a rule
OneOcc :: !InsideLam -> {-# UNPACK #-} !BranchCount -> !InterestingCxt -> !TailCallInfo -> OccInfo
[occ_in_lam] :: OccInfo -> !InsideLam
[occ_n_br] :: OccInfo -> {-# UNPACK #-} !BranchCount
[occ_int_cxt] :: OccInfo -> !InterestingCxt
[occ_tail] :: OccInfo -> !TailCallInfo

-- | This identifier breaks a loop of mutually recursive functions. The
--   field marks whether it is only a loop breaker due to a reference in a
--   rule
IAmALoopBreaker :: !RulesOnly -> !TailCallInfo -> OccInfo
[occ_rules_only] :: OccInfo -> !RulesOnly
[occ_tail] :: OccInfo -> !TailCallInfo
noOccInfo :: OccInfo
seqOccInfo :: OccInfo -> ()
zapFragileOcc :: OccInfo -> OccInfo
isOneOcc :: OccInfo -> Bool
isDeadOcc :: OccInfo -> Bool
isStrongLoopBreaker :: OccInfo -> Bool
isWeakLoopBreaker :: OccInfo -> Bool
isManyOccs :: OccInfo -> Bool
isNoOccInfo :: OccInfo -> Bool
strongLoopBreaker :: OccInfo
weakLoopBreaker :: OccInfo

-- | Inside Lambda
data InsideLam

-- | Occurs inside a non-linear lambda Substituting a redex for this
--   occurrence is dangerous because it might duplicate work.
IsInsideLam :: InsideLam
NotInsideLam :: InsideLam
type BranchCount = Int
oneBranch :: BranchCount

-- | Interesting Context
data InterestingCxt

-- | Function: is applied Data value: scrutinised by a case with at least
--   one non-DEFAULT branch
IsInteresting :: InterestingCxt
NotInteresting :: InterestingCxt
data TailCallInfo
AlwaysTailCalled :: {-# UNPACK #-} !JoinArity -> TailCallInfo
NoTailCallInfo :: TailCallInfo
tailCallInfo :: OccInfo -> TailCallInfo
zapOccTailCallInfo :: OccInfo -> OccInfo
isAlwaysTailCalled :: OccInfo -> Bool

-- | Embedding Projection pair
data EP a
EP :: a -> a -> EP a
[fromEP] :: EP a -> a
[toEP] :: EP a -> a

-- | Default Method Specification
data DefMethSpec ty
VanillaDM :: DefMethSpec ty
GenericDM :: ty -> DefMethSpec ty
data SwapFlag
NotSwapped :: SwapFlag
IsSwapped :: SwapFlag
flipSwap :: SwapFlag -> SwapFlag
unSwap :: SwapFlag -> (a -> a -> b) -> a -> a -> b
notSwapped :: SwapFlag -> Bool
isSwapped :: SwapFlag -> Bool
pickSwap :: SwapFlag -> a -> a -> a
data CompilerPhase
InitialPhase :: CompilerPhase
Phase :: PhaseNum -> CompilerPhase
FinalPhase :: CompilerPhase

-- | Phase Number
type PhaseNum = Int
beginPhase :: Activation -> CompilerPhase
nextPhase :: CompilerPhase -> CompilerPhase
laterPhase :: CompilerPhase -> CompilerPhase -> CompilerPhase
data Activation
AlwaysActive :: Activation
ActiveBefore :: SourceText -> PhaseNum -> Activation
ActiveAfter :: SourceText -> PhaseNum -> Activation
FinalActive :: Activation
NeverActive :: Activation
isActive :: CompilerPhase -> Activation -> Bool
competesWith :: Activation -> Activation -> Bool
isNeverActive :: Activation -> Bool
isAlwaysActive :: Activation -> Bool
activeInFinalPhase :: Activation -> Bool
activateAfterInitial :: Activation
activateDuringFinal :: Activation
activeAfter :: CompilerPhase -> Activation

-- | Rule Match Information
data RuleMatchInfo
ConLike :: RuleMatchInfo
FunLike :: RuleMatchInfo
isConLike :: RuleMatchInfo -> Bool
isFunLike :: RuleMatchInfo -> Bool

-- | Inline Specification
data InlineSpec
Inline :: SourceText -> InlineSpec
Inlinable :: SourceText -> InlineSpec
NoInline :: SourceText -> InlineSpec
Opaque :: SourceText -> InlineSpec
NoUserInlinePrag :: InlineSpec
noUserInlineSpec :: InlineSpec -> Bool
data InlinePragma
InlinePragma :: SourceText -> InlineSpec -> Maybe Arity -> Activation -> RuleMatchInfo -> InlinePragma
[inl_src] :: InlinePragma -> SourceText
[inl_inline] :: InlinePragma -> InlineSpec
[inl_sat] :: InlinePragma -> Maybe Arity
[inl_act] :: InlinePragma -> Activation
[inl_rule] :: InlinePragma -> RuleMatchInfo
defaultInlinePragma :: InlinePragma
alwaysInlinePragma :: InlinePragma
neverInlinePragma :: InlinePragma
dfunInlinePragma :: InlinePragma
isDefaultInlinePragma :: InlinePragma -> Bool
isInlinePragma :: InlinePragma -> Bool
isInlinablePragma :: InlinePragma -> Bool
isNoInlinePragma :: InlinePragma -> Bool
isOpaquePragma :: InlinePragma -> Bool
isAnyInlinePragma :: InlinePragma -> Bool
alwaysInlineConLikePragma :: InlinePragma
inlinePragmaSource :: InlinePragma -> SourceText

-- | Outputs string for pragma name for any of
--   INLINE<i>INLINABLE</i>NOINLINE. This differs from the Outputable
--   instance for the InlineSpec type where the pragma name string as well
--   as the accompanying SourceText (if any) is printed.
inlinePragmaName :: InlineSpec -> SDoc
inlineSpecSource :: InlineSpec -> SourceText
inlinePragmaSpec :: InlinePragma -> InlineSpec
inlinePragmaSat :: InlinePragma -> Maybe Arity
inlinePragmaActivation :: InlinePragma -> Activation
inlinePragmaRuleMatchInfo :: InlinePragma -> RuleMatchInfo
setInlinePragmaActivation :: InlinePragma -> Activation -> InlinePragma
setInlinePragmaRuleMatchInfo :: InlinePragma -> RuleMatchInfo -> InlinePragma

-- | Pretty-print without displaying the user-specified <a>InlineSpec</a>.
pprInline :: InlinePragma -> SDoc

-- | Pretty-print including the user-specified <a>InlineSpec</a>.
pprInlineDebug :: InlinePragma -> SDoc
data UnfoldingSource
VanillaSrc :: UnfoldingSource
StableUserSrc :: UnfoldingSource
StableSystemSrc :: UnfoldingSource
CompulsorySrc :: UnfoldingSource
isStableSource :: UnfoldingSource -> Bool
isStableUserSource :: UnfoldingSource -> Bool
isStableSystemSource :: UnfoldingSource -> Bool
isCompulsorySource :: UnfoldingSource -> Bool
data SuccessFlag
Succeeded :: SuccessFlag
Failed :: SuccessFlag
succeeded :: SuccessFlag -> Bool
failed :: SuccessFlag -> Bool
successIf :: Bool -> SuccessFlag

-- | An integer or infinity
data IntWithInf

-- | A representation of infinity
infinity :: IntWithInf

-- | Turn a positive number into an <a>IntWithInf</a>, where 0 represents
--   infinity
treatZeroAsInf :: Int -> IntWithInf

-- | Subtract an <a>Int</a> from an <a>IntWithInf</a>
subWithInf :: IntWithInf -> Int -> IntWithInf

-- | Inject any integer into an <a>IntWithInf</a>
mkIntWithInf :: Int -> IntWithInf
intGtLimit :: Int -> IntWithInf -> Bool

-- | Flag to see whether we're type-checking terms or kind-checking types
data TypeOrKind
TypeLevel :: TypeOrKind
KindLevel :: TypeOrKind
isTypeLevel :: TypeOrKind -> Bool
isKindLevel :: TypeOrKind -> Bool
data Levity
Lifted :: Levity
Unlifted :: Levity
mightBeLifted :: Maybe Levity -> Bool
mightBeUnlifted :: Maybe Levity -> Bool
data TypeOrConstraint
TypeLike :: TypeOrConstraint
ConstraintLike :: TypeOrConstraint

-- | Paints a picture of what a <a>TyCon</a> represents, in broad strokes.
--   This is used towards more informative error messages.
data TyConFlavour tc
ClassFlavour :: TyConFlavour tc
TupleFlavour :: Boxity -> TyConFlavour tc
SumFlavour :: TyConFlavour tc
DataTypeFlavour :: TyConFlavour tc
NewtypeFlavour :: TyConFlavour tc
AbstractTypeFlavour :: TyConFlavour tc
OpenFamilyFlavour :: TypeOrData -> Maybe tc -> TyConFlavour tc
ClosedTypeFamilyFlavour :: TyConFlavour tc
TypeSynonymFlavour :: TyConFlavour tc

-- | e.g., the <tt>(-&gt;)</tt> <a>TyCon</a>.
BuiltInTypeFlavour :: TyConFlavour tc
PromotedDataConFlavour :: TyConFlavour tc

-- | Whether something is a type or a data declaration, e.g. a type family
--   or a data family.
data TypeOrData
IAmData :: TypeOrData
IAmType :: TypeOrData

-- | Get the enclosing class TyCon (if there is one) for the given
--   TyConFlavour
tyConFlavourAssoc_maybe :: TyConFlavour tc -> Maybe tc

-- | Specify whether to default type variables of kind
--   <tt>RuntimeRep</tt><i><a>Levity</a></i><tt>Multiplicity</tt>.
data NonStandardDefaultingStrategy

-- | Default type variables of the given kinds:
--   
--   <ul>
--   <li>default <tt>RuntimeRep</tt> variables to <tt>LiftedRep</tt></li>
--   <li>default <a>Levity</a> variables to <a>Lifted</a></li>
--   <li>default <tt>Multiplicity</tt> variables to <tt>Many</tt></li>
--   </ul>
DefaultNonStandardTyVars :: NonStandardDefaultingStrategy

-- | Try not to default type variables of the kinds
--   <tt>RuntimeRep</tt><i><a>Levity</a></i><tt>Multiplicity</tt>.
--   
--   Note that these might get defaulted anyway, if they are kind variables
--   and `-XNoPolyKinds` is enabled.
TryNotToDefaultNonStandardTyVars :: NonStandardDefaultingStrategy

-- | Specify whether to default kind variables, and type variables of kind
--   <tt>RuntimeRep</tt><i><a>Levity</a></i><tt>Multiplicity</tt>.
data DefaultingStrategy

-- | Default kind variables:
--   
--   <ul>
--   <li>default kind variables of kind <tt>Type</tt> to
--   <tt>Type</tt>,</li>
--   <li>default
--   <tt>RuntimeRep</tt><i><a>Levity</a></i><tt>Multiplicity</tt> kind
--   variables to <tt>LiftedRep</tt><i><a>Lifted</a></i><tt>Many</tt>,
--   respectively.</li>
--   </ul>
--   
--   When this strategy is used, it means that we have determined that the
--   variables we are considering defaulting are all kind variables.
--   
--   Usually, we pass this option when -XNoPolyKinds is enabled.
DefaultKindVars :: DefaultingStrategy

-- | Default (or don't default) non-standard variables, of kinds
--   <tt>RuntimeRep</tt>, <a>Levity</a> and <tt>Multiplicity</tt>.
NonStandardDefaulting :: NonStandardDefaultingStrategy -> DefaultingStrategy
defaultNonStandardTyVars :: DefaultingStrategy -> Bool
data ForeignSrcLang
LangC :: ForeignSrcLang
LangCxx :: ForeignSrcLang
LangObjc :: ForeignSrcLang
LangObjcxx :: ForeignSrcLang
LangAsm :: ForeignSrcLang
LangJs :: ForeignSrcLang
RawObject :: ForeignSrcLang
instance GHC.Utils.Binary.Binary GHC.Types.Basic.Activation
instance GHC.Utils.Binary.Binary Language.Haskell.Syntax.Basic.Boxity
instance GHC.Utils.Binary.Binary GHC.Types.Basic.CbvMark
instance GHC.Utils.Binary.Binary GHC.Types.Basic.FunctionOrData
instance GHC.Utils.Binary.Binary GHC.Types.Basic.InlinePragma
instance GHC.Utils.Binary.Binary GHC.Types.Basic.InlineSpec
instance GHC.Utils.Binary.Binary GHC.Types.Basic.LeftOrRight
instance GHC.Utils.Binary.Binary GHC.Types.Basic.Levity
instance GHC.Utils.Binary.Binary GHC.Types.Basic.OverlapFlag
instance GHC.Utils.Binary.Binary GHC.Types.Basic.OverlapMode
instance GHC.Utils.Binary.Binary Language.Haskell.Syntax.Type.PromotionFlag
instance GHC.Utils.Binary.Binary GHC.Types.Basic.RecFlag
instance GHC.Utils.Binary.Binary GHC.Types.Basic.RuleMatchInfo
instance GHC.Utils.Binary.Binary GHC.Types.Basic.TupleSort
instance GHC.Utils.Binary.Binary GHC.Types.Basic.UnfoldingSource
instance GHC.Internal.Data.Data.Data GHC.Types.Basic.Activation
instance GHC.Internal.Data.Data.Data GHC.Types.Basic.DoPmc
instance GHC.Internal.Data.Data.Data GHC.Types.Basic.FunctionOrData
instance GHC.Internal.Data.Data.Data GHC.Types.Basic.GenReason
instance GHC.Internal.Data.Data.Data GHC.Types.Basic.InlinePragma
instance GHC.Internal.Data.Data.Data GHC.Types.Basic.InlineSpec
instance GHC.Internal.Data.Data.Data GHC.Types.Basic.LeftOrRight
instance GHC.Internal.Data.Data.Data GHC.Types.Basic.Levity
instance GHC.Internal.Data.Data.Data GHC.Types.Basic.Origin
instance GHC.Internal.Data.Data.Data GHC.Types.Basic.OverlapFlag
instance GHC.Internal.Data.Data.Data GHC.Types.Basic.OverlapMode
instance GHC.Internal.Data.Data.Data GHC.Types.Basic.RecFlag
instance GHC.Internal.Data.Data.Data GHC.Types.Basic.RuleMatchInfo
instance GHC.Internal.Data.Data.Data GHC.Types.Basic.TopLevelFlag
instance GHC.Internal.Data.Data.Data GHC.Types.Basic.TupleSort
instance GHC.Internal.Data.Data.Data tc => GHC.Internal.Data.Data.Data (GHC.Types.Basic.TyConFlavour tc)
instance GHC.Internal.Data.Data.Data GHC.Types.Basic.TypeOrConstraint
instance GHC.Internal.Data.Data.Data GHC.Types.Basic.TypeOrData
instance GHC.Classes.Eq GHC.Types.Basic.Activation
instance GHC.Classes.Eq GHC.Types.Basic.Alignment
instance GHC.Classes.Eq GHC.Types.Basic.CbvMark
instance GHC.Classes.Eq GHC.Types.Basic.CompilerPhase
instance GHC.Classes.Eq GHC.Types.Basic.DoPmc
instance GHC.Classes.Eq GHC.Types.Basic.FunctionOrData
instance GHC.Classes.Eq GHC.Types.Basic.GenReason
instance GHC.Classes.Eq GHC.Types.Basic.InlinePragma
instance GHC.Classes.Eq GHC.Types.Basic.InlineSpec
instance GHC.Classes.Eq GHC.Types.Basic.InsideLam
instance GHC.Classes.Eq GHC.Types.Basic.IntWithInf
instance GHC.Classes.Eq GHC.Types.Basic.InterestingCxt
instance GHC.Classes.Eq GHC.Types.Basic.LeftOrRight
instance GHC.Classes.Eq GHC.Types.Basic.Levity
instance GHC.Classes.Eq GHC.Types.Basic.OccInfo
instance GHC.Classes.Eq GHC.Types.Basic.OneShotInfo
instance GHC.Classes.Eq GHC.Types.Basic.Origin
instance GHC.Classes.Eq GHC.Types.Basic.OverlapFlag
instance GHC.Classes.Eq GHC.Types.Basic.OverlapMode
instance GHC.Classes.Eq GHC.Types.Basic.PprPrec
instance GHC.Classes.Eq GHC.Types.Basic.RecFlag
instance GHC.Classes.Eq GHC.Types.Basic.RuleMatchInfo
instance GHC.Classes.Eq GHC.Types.Basic.SwapFlag
instance GHC.Classes.Eq GHC.Types.Basic.TailCallInfo
instance GHC.Classes.Eq GHC.Types.Basic.TupleSort
instance GHC.Classes.Eq tc => GHC.Classes.Eq (GHC.Types.Basic.TyConFlavour tc)
instance GHC.Classes.Eq GHC.Types.Basic.TypeOrConstraint
instance GHC.Classes.Eq GHC.Types.Basic.TypeOrData
instance GHC.Classes.Eq GHC.Types.Basic.TypeOrKind
instance GHC.Classes.Eq GHC.Types.Basic.UnboxedTupleOrSum
instance GHC.Internal.Base.Functor GHC.Types.Basic.TyConFlavour
instance GHC.Internal.Base.Monoid GHC.Types.Basic.InsideLam
instance GHC.Internal.Base.Monoid GHC.Types.Basic.InterestingCxt
instance Control.DeepSeq.NFData tc => Control.DeepSeq.NFData (GHC.Types.Basic.TyConFlavour tc)
instance GHC.Internal.Num.Num GHC.Types.Basic.IntWithInf
instance GHC.Classes.Ord GHC.Types.Basic.Alignment
instance GHC.Classes.Ord GHC.Types.Basic.FunctionOrData
instance GHC.Classes.Ord GHC.Types.Basic.IntWithInf
instance GHC.Classes.Ord GHC.Types.Basic.LeftOrRight
instance GHC.Classes.Ord GHC.Types.Basic.Levity
instance GHC.Classes.Ord GHC.Types.Basic.PprPrec
instance GHC.Classes.Ord GHC.Types.Basic.TupleSort
instance GHC.Classes.Ord GHC.Types.Basic.TypeOrConstraint
instance GHC.Utils.Outputable.OutputableP env GHC.Types.Basic.Alignment
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.Activation
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.Alignment
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Basic.Boxity
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.CbvMark
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.CompilerPhase
instance GHC.Utils.Outputable.Outputable (GHC.Types.Basic.DefMethSpec ty)
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.DefaultingStrategy
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.DoPmc
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.FunctionOrData
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.GenReason
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.InlinePragma
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.InlineSpec
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.IntWithInf
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.LeftOrRight
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.Levity
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.NonStandardDefaultingStrategy
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.OccInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.OneShotInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.Origin
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.OverlapFlag
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.OverlapMode
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Type.PromotionFlag
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.RecFlag
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.RuleMatchInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.SuccessFlag
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.SwapFlag
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.TailCallInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.TopLevelFlag
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.TupleSort
instance GHC.Utils.Outputable.Outputable (GHC.Types.Basic.TyConFlavour tc)
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.TypeOrData
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.TypeOrKind
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.UnboxedTupleOrSum
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.UnfoldingSource
instance GHC.Internal.Base.Semigroup GHC.Types.Basic.InsideLam
instance GHC.Internal.Base.Semigroup GHC.Types.Basic.InterestingCxt
instance GHC.Internal.Base.Semigroup GHC.Types.Basic.SuccessFlag
instance GHC.Internal.Show.Show GHC.Types.Basic.InlineSpec
instance GHC.Internal.Show.Show GHC.Types.Basic.Levity
instance GHC.Internal.Show.Show GHC.Types.Basic.PprPrec
instance GHC.Internal.Show.Show GHC.Types.Basic.RuleMatchInfo


-- | Platform description
module GHC.Platform

-- | Platform description
--   
--   This is used to describe platforms so that we can generate code for
--   them.
data Platform
Platform :: !ArchOS -> !PlatformWordSize -> !ByteOrder -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Maybe PlatformConstants -> Platform

-- | Architecture and OS
[platformArchOS] :: Platform -> !ArchOS

-- | Word size
[platformWordSize] :: Platform -> !PlatformWordSize

-- | Byte order (endianness)
[platformByteOrder] :: Platform -> !ByteOrder
[platformUnregisterised] :: Platform -> !Bool
[platformHasGnuNonexecStack] :: Platform -> !Bool
[platformHasIdentDirective] :: Platform -> !Bool

-- | Enable Darwin .subsections_via_symbols directive
--   
--   See Note [Subsections Via Symbols] in GHC.CmmToAsm.X86.Ppr
[platformHasSubsectionsViaSymbols] :: Platform -> !Bool
[platformIsCrossCompiling] :: Platform -> !Bool

-- | Symbols need underscore prefix
[platformLeadingUnderscore] :: Platform -> !Bool

-- | Determines whether we will be compiling info tables that reside just
--   before the entry code, or with an indirection to the entry code. See
--   TABLES_NEXT_TO_CODE in
--   <tt>rts<i>include</i>rts<i>storage</i>InfoTables.h</tt>.
[platformTablesNextToCode] :: Platform -> !Bool

-- | Some platforms require that we explicitly link against <tt>libm</tt>
--   if any math-y things are used (which we assume to include all
--   programs). See #14022.
[platformHasLibm] :: Platform -> !Bool

-- | Constants such as structure offsets, type sizes, etc.
[platform_constants] :: Platform -> !Maybe PlatformConstants
data PlatformWordSize

-- | A 32-bit platform
PW4 :: PlatformWordSize

-- | A 64-bit platform
PW8 :: PlatformWordSize

-- | Platform architecture
platformArch :: Platform -> Arch

-- | Platform OS
platformOS :: Platform -> OS
data ArchOS
ArchOS :: Arch -> OS -> ArchOS
[archOS_arch] :: ArchOS -> Arch
[archOS_OS] :: ArchOS -> OS
data Arch
ArchUnknown :: Arch
ArchX86 :: Arch
ArchX86_64 :: Arch
ArchPPC :: Arch
ArchPPC_64 :: PPC_64ABI -> Arch
ArchS390X :: Arch
ArchARM :: ArmISA -> [ArmISAExt] -> ArmABI -> Arch
ArchAArch64 :: Arch
ArchAlpha :: Arch
ArchMipseb :: Arch
ArchMipsel :: Arch
ArchRISCV64 :: Arch
ArchLoongArch64 :: Arch
ArchJavaScript :: Arch
ArchWasm32 :: Arch
data OS
OSUnknown :: OS
OSLinux :: OS
OSDarwin :: OS
OSSolaris2 :: OS
OSMinGW32 :: OS
OSFreeBSD :: OS
OSDragonFly :: OS
OSOpenBSD :: OS
OSNetBSD :: OS
OSKFreeBSD :: OS
OSHaiku :: OS
OSQNXNTO :: OS
OSAIX :: OS
OSHurd :: OS
OSWasi :: OS
OSGhcjs :: OS
data ArmISA
ARMv5 :: ArmISA
ARMv6 :: ArmISA
ARMv7 :: ArmISA
data ArmISAExt
VFPv2 :: ArmISAExt
VFPv3 :: ArmISAExt
VFPv3D16 :: ArmISAExt
NEON :: ArmISAExt
IWMMX2 :: ArmISAExt
data ArmABI
SOFT :: ArmABI
SOFTFP :: ArmABI
HARD :: ArmABI
data PPC_64ABI
ELF_V1 :: PPC_64ABI
ELF_V2 :: PPC_64ABI
data ByteOrder
BigEndian :: ByteOrder
LittleEndian :: ByteOrder

-- | This predicate tells us whether the platform is 32-bit.
target32Bit :: Platform -> Bool
isARM :: Arch -> Bool
isPPC :: Arch -> Bool
osElfTarget :: OS -> Bool
osMachOTarget :: OS -> Bool
osSubsectionsViaSymbols :: OS -> Bool
platformUsesFrameworks :: Platform -> Bool
platformWordSizeInBytes :: Platform -> Int
platformWordSizeInBits :: Platform -> Int

-- | Minimum representable Int value for the given platform
platformMinInt :: Platform -> Integer

-- | Maximum representable Int value for the given platform
platformMaxInt :: Platform -> Integer

-- | Maximum representable Word value for the given platform
platformMaxWord :: Platform -> Integer

-- | Test if the given Integer is representable with a platform Int
platformInIntRange :: Platform -> Integer -> Bool

-- | Test if the given Integer is representable with a platform Word
platformInWordRange :: Platform -> Integer -> Bool

-- | For some architectures the C calling convention is that any integer
--   shorter than 64 bits is replaced by its 64 bits representation using
--   sign or zero extension.
platformCConvNeedsExtension :: Platform -> Bool

-- | Does this platform have an RTS linker?
platformHasRTSLinker :: Platform -> Bool

-- | Platform-specific settings formerly hard-coded in Config.hs.
--   
--   These should probably be all be triaged whether they can be computed
--   from other settings or belong in another another place (like
--   <a>Platform</a> above).
data PlatformMisc
PlatformMisc :: String -> Bool -> Bool -> String -> Bool -> PlatformMisc
[platformMisc_targetPlatformString] :: PlatformMisc -> String
[platformMisc_ghcWithInterpreter] :: PlatformMisc -> Bool
[platformMisc_libFFI] :: PlatformMisc -> Bool
[platformMisc_llvmTarget] :: PlatformMisc -> String
[platformMisc_targetRTSLinkerOnlySupportsSharedLibs] :: PlatformMisc -> Bool

-- | x86 SSE instructions
data SseVersion
SSE1 :: SseVersion
SSE2 :: SseVersion
SSE3 :: SseVersion
SSE4 :: SseVersion
SSE42 :: SseVersion

-- | x86 BMI (bit manipulation) instructions
data BmiVersion
BMI1 :: BmiVersion
BMI2 :: BmiVersion
wordAlignment :: Platform -> Alignment
isSseEnabled :: Platform -> Bool
isSse2Enabled :: Platform -> Bool
data PlatformConstants
PlatformConstants :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> !Integer -> !Integer -> !Integer -> !Bool -> PlatformConstants
[pc_CONTROL_GROUP_CONST_291] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_STD_HDR_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_PROF_HDR_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_BLOCK_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_BLOCKS_PER_MBLOCK] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_TICKY_BIN_COUNT] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR7] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR8] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR9] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR10] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rL1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rSp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rSpLim] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rHp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rHpLim] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rCCCS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rCurrentTSO] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rCurrentNursery] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rHpAlloc] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_stgEagerBlackholeInfo] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_stgGCEnter1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_stgGCFun] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_Capability_r] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_start] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_free] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_blocks] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_flags] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_CostCentreStack] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_CostCentreStack_mem_alloc] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_CostCentreStack_mem_alloc] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_CostCentreStack_scc_count] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_CostCentreStack_scc_count] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgHeader_ccs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgHeader_ldvw] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgSMPThunkHeader] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_allocs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgEntCounter_allocs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_allocd] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgEntCounter_allocd] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_registeredp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_link] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_entry_count] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgUpdateFrame_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgOrigThunkInfoFrame_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgMutArrPtrs_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgMutArrPtrs_ptrs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgMutArrPtrs_size] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgSmallMutArrPtrs_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgSmallMutArrPtrs_ptrs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgArrBytes_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgArrBytes_bytes] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgTSO_alloc_limit] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgTSO_cccs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgTSO_stackobj] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgStack_sp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgStack_stack] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgUpdateFrame_updatee] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgOrigThunkInfoFrame_info_ptr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgFunInfoExtraFwd_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgFunInfoExtraFwd_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgFunInfoExtraRev] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgFunInfoExtraRev_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgFunInfoExtraRev_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_SPEC_SELECTEE_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_SPEC_AP_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MIN_PAYLOAD_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MIN_INTLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_INTLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MIN_CHARLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_CHARLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MUT_ARR_PTRS_CARD_BITS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Vanilla_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Float_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Double_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Long_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_XMM_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Vanilla_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Float_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Double_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_XMM_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Long_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_RESERVED_C_STACK_BYTES] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_RESERVED_STACK_WORDS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_AP_STACK_SPLIM] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_WORD_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_CINT_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_CLONG_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_CLONG_LONG_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_BITMAP_BITS_SHIFT] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_TAG_BITS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_LDV_SHIFT] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_ILDV_CREATE_MASK] :: PlatformConstants -> !Integer
[pc_ILDV_STATE_CREATE] :: PlatformConstants -> !Integer
[pc_ILDV_STATE_USE] :: PlatformConstants -> !Integer
[pc_USE_INLINE_SRT_FIELD] :: PlatformConstants -> !Bool

-- | Try to locate "DerivedConstants.h" file in the given dirs and to parse
--   the PlatformConstants from it.
--   
--   See Note [Platform constants]
lookupPlatformConstants :: [FilePath] -> IO (Maybe PlatformConstants)
platformConstants :: Platform -> PlatformConstants
platformSOName :: Platform -> FilePath -> FilePath
platformHsSOName :: Platform -> FilePath -> FilePath
platformSOExt :: Platform -> FilePath
genericPlatform :: Platform
instance GHC.Classes.Eq GHC.Platform.BmiVersion
instance GHC.Classes.Eq GHC.Platform.Platform
instance GHC.Classes.Eq GHC.Platform.PlatformWordSize
instance GHC.Classes.Eq GHC.Platform.SseVersion
instance GHC.Classes.Ord GHC.Platform.BmiVersion
instance GHC.Classes.Ord GHC.Platform.Platform
instance GHC.Classes.Ord GHC.Platform.PlatformWordSize
instance GHC.Classes.Ord GHC.Platform.SseVersion
instance GHC.Internal.Read.Read GHC.Platform.Platform
instance GHC.Internal.Read.Read GHC.Platform.PlatformWordSize
instance GHC.Internal.Show.Show GHC.Platform.Platform
instance GHC.Internal.Show.Show GHC.Platform.PlatformWordSize


-- | Various utilities used in generating assembler.
--   
--   These are used not only by the native code generator, but also by the
--   <a>GHC.Driver.Pipeline</a>
module GHC.Utils.Asm

-- | Generate a section type (e.g. <tt>@progbits</tt>). See #13937.
sectionType :: IsLine doc => Platform -> String -> doc


-- | Run-time settings
module GHC.Settings
data Settings
Settings :: {-# UNPACK #-} !GhcNameVersion -> {-# UNPACK #-} !FileSettings -> Platform -> {-# UNPACK #-} !ToolSettings -> {-# UNPACK #-} !PlatformMisc -> [(String, String)] -> Settings
[sGhcNameVersion] :: Settings -> {-# UNPACK #-} !GhcNameVersion
[sFileSettings] :: Settings -> {-# UNPACK #-} !FileSettings
[sTargetPlatform] :: Settings -> Platform
[sToolSettings] :: Settings -> {-# UNPACK #-} !ToolSettings
[sPlatformMisc] :: Settings -> {-# UNPACK #-} !PlatformMisc
[sRawSettings] :: Settings -> [(String, String)]

-- | Settings for other executables GHC calls.
--   
--   Probably should further split down by phase, or split between
--   platform-specific and platform-agnostic.
data ToolSettings
ToolSettings :: Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> String -> (String, [Option]) -> (String, [Option]) -> (String, [Option]) -> String -> String -> String -> (String, [Option]) -> (String, [Option]) -> (String, [Option]) -> Maybe (String, [Option]) -> String -> String -> String -> String -> String -> (String, [Option]) -> (String, [Option]) -> (String, [Option]) -> String -> [String] -> [String] -> [String] -> [String] -> Fingerprint -> Fingerprint -> Fingerprint -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> ToolSettings
[toolSettings_ldSupportsCompactUnwind] :: ToolSettings -> Bool
[toolSettings_ldSupportsFilelist] :: ToolSettings -> Bool
[toolSettings_ldSupportsSingleModule] :: ToolSettings -> Bool
[toolSettings_mergeObjsSupportsResponseFiles] :: ToolSettings -> Bool
[toolSettings_ldIsGnuLd] :: ToolSettings -> Bool
[toolSettings_ccSupportsNoPie] :: ToolSettings -> Bool
[toolSettings_useInplaceMinGW] :: ToolSettings -> Bool
[toolSettings_arSupportsDashL] :: ToolSettings -> Bool
[toolSettings_cmmCppSupportsG0] :: ToolSettings -> Bool
[toolSettings_pgm_L] :: ToolSettings -> String

-- | The Haskell C preprocessor and default options (not added by -optP)
[toolSettings_pgm_P] :: ToolSettings -> (String, [Option])

-- | The JavaScript C preprocessor and default options (not added by -optP)
[toolSettings_pgm_JSP] :: ToolSettings -> (String, [Option])

-- | The C-- C Preprocessor and default options (not added by -optP)
[toolSettings_pgm_CmmP] :: ToolSettings -> (String, [Option])
[toolSettings_pgm_F] :: ToolSettings -> String
[toolSettings_pgm_c] :: ToolSettings -> String
[toolSettings_pgm_cxx] :: ToolSettings -> String

-- | The C preprocessor (distinct from the Haskell C preprocessor!)
[toolSettings_pgm_cpp] :: ToolSettings -> (String, [Option])
[toolSettings_pgm_a] :: ToolSettings -> (String, [Option])
[toolSettings_pgm_l] :: ToolSettings -> (String, [Option])

-- | N.B. On Windows we don't have a linker which supports object merging,
--   hence the <a>Maybe</a>. See Note [Object merging] in
--   <a>GHC.Driver.Pipeline.Execute</a> for details.
[toolSettings_pgm_lm] :: ToolSettings -> Maybe (String, [Option])
[toolSettings_pgm_windres] :: ToolSettings -> String
[toolSettings_pgm_ar] :: ToolSettings -> String
[toolSettings_pgm_otool] :: ToolSettings -> String
[toolSettings_pgm_install_name_tool] :: ToolSettings -> String
[toolSettings_pgm_ranlib] :: ToolSettings -> String

-- | LLVM: opt llvm optimiser
[toolSettings_pgm_lo] :: ToolSettings -> (String, [Option])

-- | LLVM: llc static compiler
[toolSettings_pgm_lc] :: ToolSettings -> (String, [Option])

-- | LLVM: assembler
[toolSettings_pgm_las] :: ToolSettings -> (String, [Option])
[toolSettings_pgm_i] :: ToolSettings -> String
[toolSettings_opt_L] :: ToolSettings -> [String]
[toolSettings_opt_P] :: ToolSettings -> [String]
[toolSettings_opt_JSP] :: ToolSettings -> [String]
[toolSettings_opt_CmmP] :: ToolSettings -> [String]

-- | cached Fingerprint of sOpt_P See Note [Repeated -optP hashing]
[toolSettings_opt_P_fingerprint] :: ToolSettings -> Fingerprint

-- | cached Fingerprint of sOpt_JSP See Note [Repeated -optP hashing]
[toolSettings_opt_JSP_fingerprint] :: ToolSettings -> Fingerprint

-- | cached Fingerprint of sOpt_CmmP See Note [Repeated -optP hashing]
[toolSettings_opt_CmmP_fingerprint] :: ToolSettings -> Fingerprint
[toolSettings_opt_F] :: ToolSettings -> [String]
[toolSettings_opt_c] :: ToolSettings -> [String]
[toolSettings_opt_cxx] :: ToolSettings -> [String]
[toolSettings_opt_a] :: ToolSettings -> [String]
[toolSettings_opt_l] :: ToolSettings -> [String]
[toolSettings_opt_lm] :: ToolSettings -> [String]
[toolSettings_opt_windres] :: ToolSettings -> [String]

-- | LLVM: llvm optimiser
[toolSettings_opt_lo] :: ToolSettings -> [String]

-- | LLVM: llc static compiler
[toolSettings_opt_lc] :: ToolSettings -> [String]
[toolSettings_opt_las] :: ToolSettings -> [String]

-- | iserv options
[toolSettings_opt_i] :: ToolSettings -> [String]
[toolSettings_extraGccViaCFlags] :: ToolSettings -> [String]

-- | Paths to various files and directories used by GHC, including those
--   that provide more settings.
data FileSettings
FileSettings :: FilePath -> FilePath -> Maybe FilePath -> FilePath -> FilePath -> FileSettings
[fileSettings_ghcUsagePath] :: FileSettings -> FilePath
[fileSettings_ghciUsagePath] :: FileSettings -> FilePath
[fileSettings_toolDir] :: FileSettings -> Maybe FilePath
[fileSettings_topDir] :: FileSettings -> FilePath
[fileSettings_globalPackageDatabase] :: FileSettings -> FilePath

-- | Settings for what GHC this is.
data GhcNameVersion
GhcNameVersion :: String -> String -> GhcNameVersion
[ghcNameVersion_programName] :: GhcNameVersion -> String
[ghcNameVersion_projectVersion] :: GhcNameVersion -> String

-- | Platform description
--   
--   This is used to describe platforms so that we can generate code for
--   them.
data Platform
Platform :: !ArchOS -> !PlatformWordSize -> !ByteOrder -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Maybe PlatformConstants -> Platform

-- | Architecture and OS
[platformArchOS] :: Platform -> !ArchOS

-- | Word size
[platformWordSize] :: Platform -> !PlatformWordSize

-- | Byte order (endianness)
[platformByteOrder] :: Platform -> !ByteOrder
[platformUnregisterised] :: Platform -> !Bool
[platformHasGnuNonexecStack] :: Platform -> !Bool
[platformHasIdentDirective] :: Platform -> !Bool

-- | Enable Darwin .subsections_via_symbols directive
--   
--   See Note [Subsections Via Symbols] in GHC.CmmToAsm.X86.Ppr
[platformHasSubsectionsViaSymbols] :: Platform -> !Bool
[platformIsCrossCompiling] :: Platform -> !Bool

-- | Symbols need underscore prefix
[platformLeadingUnderscore] :: Platform -> !Bool

-- | Determines whether we will be compiling info tables that reside just
--   before the entry code, or with an indirection to the entry code. See
--   TABLES_NEXT_TO_CODE in
--   <tt>rts<i>include</i>rts<i>storage</i>InfoTables.h</tt>.
[platformTablesNextToCode] :: Platform -> !Bool

-- | Some platforms require that we explicitly link against <tt>libm</tt>
--   if any math-y things are used (which we assume to include all
--   programs). See #14022.
[platformHasLibm] :: Platform -> !Bool

-- | Constants such as structure offsets, type sizes, etc.
[platform_constants] :: Platform -> !Maybe PlatformConstants

-- | Platform-specific settings formerly hard-coded in Config.hs.
--   
--   These should probably be all be triaged whether they can be computed
--   from other settings or belong in another another place (like
--   <a>Platform</a> above).
data PlatformMisc
PlatformMisc :: String -> Bool -> Bool -> String -> Bool -> PlatformMisc
[platformMisc_targetPlatformString] :: PlatformMisc -> String
[platformMisc_ghcWithInterpreter] :: PlatformMisc -> Bool
[platformMisc_libFFI] :: PlatformMisc -> Bool
[platformMisc_llvmTarget] :: PlatformMisc -> String
[platformMisc_targetRTSLinkerOnlySupportsSharedLibs] :: PlatformMisc -> Bool

-- | Dynamic library suffix
dynLibSuffix :: GhcNameVersion -> String
sProgramName :: Settings -> String
sProjectVersion :: Settings -> String
sGhcUsagePath :: Settings -> FilePath
sGhciUsagePath :: Settings -> FilePath
sToolDir :: Settings -> Maybe FilePath
sTopDir :: Settings -> FilePath
sGlobalPackageDatabasePath :: Settings -> FilePath
sLdSupportsCompactUnwind :: Settings -> Bool
sLdSupportsFilelist :: Settings -> Bool
sMergeObjsSupportsResponseFiles :: Settings -> Bool
sLdIsGnuLd :: Settings -> Bool
sGccSupportsNoPie :: Settings -> Bool
sUseInplaceMinGW :: Settings -> Bool
sArSupportsDashL :: Settings -> Bool
sPgm_L :: Settings -> String
sPgm_P :: Settings -> (String, [Option])
sPgm_JSP :: Settings -> (String, [Option])
sPgm_CmmP :: Settings -> (String, [Option])
sPgm_F :: Settings -> String
sPgm_c :: Settings -> String
sPgm_cxx :: Settings -> String
sPgm_cpp :: Settings -> (String, [Option])
sPgm_a :: Settings -> (String, [Option])
sPgm_l :: Settings -> (String, [Option])
sPgm_lm :: Settings -> Maybe (String, [Option])
sPgm_windres :: Settings -> String
sPgm_ar :: Settings -> String
sPgm_otool :: Settings -> String
sPgm_install_name_tool :: Settings -> String
sPgm_ranlib :: Settings -> String
sPgm_lo :: Settings -> (String, [Option])
sPgm_lc :: Settings -> (String, [Option])
sPgm_las :: Settings -> (String, [Option])
sPgm_i :: Settings -> String
sOpt_L :: Settings -> [String]
sOpt_P :: Settings -> [String]
sOpt_P_fingerprint :: Settings -> Fingerprint
sOpt_JSP :: Settings -> [String]
sOpt_JSP_fingerprint :: Settings -> Fingerprint
sOpt_CmmP :: Settings -> [String]
sOpt_CmmP_fingerprint :: Settings -> Fingerprint
sOpt_F :: Settings -> [String]
sOpt_c :: Settings -> [String]
sOpt_cxx :: Settings -> [String]
sOpt_a :: Settings -> [String]
sOpt_l :: Settings -> [String]
sOpt_lm :: Settings -> [String]
sOpt_windres :: Settings -> [String]
sOpt_lo :: Settings -> [String]
sOpt_lc :: Settings -> [String]
sOpt_i :: Settings -> [String]
sExtraGccViaCFlags :: Settings -> [String]
sTargetPlatformString :: Settings -> String
sGhcWithInterpreter :: Settings -> Bool
sLibFFI :: Settings -> Bool
sTargetRTSLinkerOnlySupportsSharedLibs :: Settings -> Bool

module GHC.Settings.IO
data SettingsError
SettingsError_MissingData :: String -> SettingsError
SettingsError_BadData :: String -> SettingsError
initSettings :: forall (m :: Type -> Type). MonadIO m => String -> ExceptT SettingsError m Settings


-- | Ways
--   
--   The central concept of a "way" is that all objects in a given program
--   must be compiled in the same "way". Certain options change parameters
--   of the virtual machine, eg. profiling adds an extra word to the object
--   header, so profiling objects cannot be linked with non-profiling
--   objects.
--   
--   After parsing the command-line options, we determine which "way" we
--   are building - this might be a combination way, eg.
--   profiling+threaded.
--   
--   There are two kinds of ways: - RTS only: only affect the runtime
--   system (RTS) and don't affect code generation (e.g. threaded, debug) -
--   Full ways: affect code generation and the RTS (e.g. profiling, dynamic
--   linking)
--   
--   We then find the "build-tag" associated with this way, and this
--   becomes the suffix used to find .hi files and libraries used in this
--   compilation.
module GHC.Platform.Ways

-- | A way
--   
--   Don't change the constructor order as it is used by <a>waysTag</a> to
--   create a unique tag (e.g. thr_debug_p) which is expected by other
--   tools (e.g. Cabal).
data Way

-- | for GHC API clients building custom variants
WayCustom :: String -> Way

-- | (RTS only) Multithreaded runtime system
WayThreaded :: Way

-- | Debugging, enable trace messages and extra checks
WayDebug :: Way

-- | Profiling, enable cost-centre stacks and profiling reports
WayProf :: Way

-- | Dynamic linking
WayDyn :: Way
type Ways = Set Way

-- | Test if a way is enabled
hasWay :: Ways -> Way -> Bool

-- | Test if a way is not enabled
hasNotWay :: Ways -> Way -> Bool

-- | Add a way
addWay :: Way -> Ways -> Ways

-- | Remove a way
removeWay :: Way -> Ways -> Ways

-- | Check if a combination of ways is allowed
allowed_combination :: Ways -> Bool

-- | Turn these flags on when enabling this way
wayGeneralFlags :: Platform -> Way -> [GeneralFlag]

-- | Turn these flags off when enabling this way
wayUnsetGeneralFlags :: Platform -> Way -> [GeneralFlag]

-- | Pass these options to the C compiler when enabling this way
wayOptc :: Platform -> Way -> [String]
wayOptcxx :: Platform -> Way -> [String]

-- | Pass these options to linker when enabling this way
wayOptl :: Platform -> Way -> [String]

-- | Pass these options to the preprocessor when enabling this way
wayOptP :: Platform -> Way -> [String]
wayDesc :: Way -> String

-- | Return true for ways that only impact the RTS, not the generated code
wayRTSOnly :: Way -> Bool

-- | Unique build-tag associated to a way
wayTag :: Way -> String

-- | Unique tag associated to a list of ways
waysTag :: Ways -> String

-- | Unique build-tag associated to a list of ways
--   
--   RTS only ways are filtered out because they have no impact on the
--   build.
waysBuildTag :: Ways -> String

-- | Filter ways that have an impact on compilation
fullWays :: Ways -> Ways

-- | Filter RTS-only ways (ways that don't have an impact on compilation)
rtsWays :: Ways -> Ways

-- | Host ways.
hostWays :: Ways

-- | Host "full" ways (i.e. ways that have an impact on the compilation,
--   not RTS only ways).
--   
--   These ways must be used when compiling codes targeting the internal
--   interpreter.
hostFullWays :: Ways

-- | Consult the RTS to find whether it has been built with profiling
--   enabled.
hostIsProfiled :: Bool

-- | Consult the RTS to find whether GHC itself has been built with dynamic
--   linking. This can't be statically known at compile-time, because we
--   build both the static and dynamic versions together with -dynamic-too.
hostIsDynamic :: Bool

-- | Consult the RTS to find whether it is threaded.
hostIsThreaded :: Bool

-- | Consult the RTS to find whether it is debugged.
hostIsDebugged :: Bool

-- | Consult the RTS to find whether it is tracing.
hostIsTracing :: Bool
instance GHC.Classes.Eq GHC.Platform.Ways.Way
instance GHC.Classes.Ord GHC.Platform.Ways.Way
instance GHC.Internal.Read.Read GHC.Platform.Ways.Way
instance GHC.Internal.Show.Show GHC.Platform.Ways.Way


-- | Info about installed units (compiled libraries)
module GHC.Unit.Info

-- | Information about an unit (a unit is an installed module library).
--   
--   This is a subset of Cabal's <tt>InstalledPackageInfo</tt>, with just
--   the bits that GHC is interested in.
--   
--   Some types are left as parameters to be instantiated differently in
--   ghc-pkg and in ghc itself.
data GenericUnitInfo srcpkgid srcpkgname uid modulename mod
GenericUnitInfo :: uid -> uid -> [(modulename, mod)] -> srcpkgid -> srcpkgname -> Version -> Maybe srcpkgname -> ShortText -> [uid] -> [(uid, ShortText)] -> [FilePathST] -> [ShortText] -> [ShortText] -> [ShortText] -> [FilePathST] -> [FilePathST] -> [ShortText] -> [FilePathST] -> [ShortText] -> [ShortText] -> [ShortText] -> [FilePathST] -> [FilePathST] -> [FilePathST] -> [(modulename, Maybe mod)] -> [modulename] -> Bool -> Bool -> Bool -> GenericUnitInfo srcpkgid srcpkgname uid modulename mod

-- | Unique unit identifier that is used during compilation (e.g. to
--   generate symbols).
[unitId] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> uid

-- | Identifier of an indefinite unit (i.e. with module holes) that this
--   unit is an instance of.
--   
--   For non instantiated units, unitInstanceOf=unitId
[unitInstanceOf] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> uid

-- | How this unit instantiates some of its module holes. Map hole module
--   names to actual module
[unitInstantiations] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [(modulename, mod)]

-- | Source package identifier.
--   
--   Cabal instantiates this with Distribution.Types.PackageId.PackageId
--   type which only contains the source package name and version. Notice
--   that it doesn't contain the Hackage revision, nor any kind of hash.
[unitPackageId] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> srcpkgid

-- | Source package name
[unitPackageName] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> srcpkgname

-- | Source package version
[unitPackageVersion] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> Version

-- | Name of the component.
--   
--   Cabal supports more than one components (libraries, executables,
--   testsuites) in the same package. Each component has a name except the
--   default one (that can only be a library component) for which we use
--   <a>Nothing</a>.
--   
--   GHC only deals with "library" components as they are the only kind of
--   components that can be registered in a database and used by other
--   modules.
[unitComponentName] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> Maybe srcpkgname

-- | ABI hash used to avoid mixing up units compiled with different
--   dependencies, compiler, options, etc.
[unitAbiHash] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> ShortText

-- | Identifiers of the units this one depends on
[unitDepends] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [uid]

-- | Like <a>unitDepends</a>, but each dependency is annotated with the ABI
--   hash we expect the dependency to respect.
[unitAbiDepends] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [(uid, ShortText)]

-- | Directories containing module interfaces
[unitImportDirs] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [FilePathST]

-- | Names of the Haskell libraries provided by this unit
[unitLibraries] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [ShortText]

-- | Names of the external system libraries that this unit depends on. See
--   also <a>unitExtDepLibsGhc</a> field.
[unitExtDepLibsSys] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [ShortText]

-- | Because of slight differences between the GHC dynamic linker (in
--   GHC.Runtime.Linker) and the native system linker, some packages have
--   to link with a different list of libraries when using GHC's. Examples
--   include: libs that are actually gnu ld scripts, and the possibility
--   that the .a libs do not exactly match the .so/.dll equivalents.
--   
--   If this field is set, then we use that instead of the
--   <a>unitExtDepLibsSys</a> field.
[unitExtDepLibsGhc] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [ShortText]

-- | Directories containing libraries provided by this unit. See also
--   <a>unitLibraryDynDirs</a>.
--   
--   It seems to be used to store paths to external library dependencies
--   too.
[unitLibraryDirs] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [FilePathST]

-- | Directories containing the dynamic libraries provided by this unit.
--   See also <a>unitLibraryDirs</a>.
--   
--   It seems to be used to store paths to external dynamic library
--   dependencies too.
[unitLibraryDynDirs] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [FilePathST]

-- | Names of the external MacOS frameworks that this unit depends on.
[unitExtDepFrameworks] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [ShortText]

-- | Directories containing MacOS frameworks that this unit depends on.
[unitExtDepFrameworkDirs] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [FilePathST]

-- | Linker (e.g. ld) command line options
[unitLinkerOptions] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [ShortText]

-- | C compiler options that needs to be passed to the C compiler when we
--   compile some C code against this unit.
[unitCcOptions] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [ShortText]

-- | C header files that are required by this unit (provided by this unit
--   or external)
[unitIncludes] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [ShortText]

-- | Directories containing C header files that this unit depends on.
[unitIncludeDirs] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [FilePathST]

-- | Paths to Haddock interface files for this unit
[unitHaddockInterfaces] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [FilePathST]

-- | Paths to Haddock directories containing HTML files
[unitHaddockHTMLs] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [FilePathST]

-- | Modules exposed by the unit.
--   
--   A module can be re-exported from another package. In this case, we
--   indicate the module origin in the second parameter.
[unitExposedModules] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [(modulename, Maybe mod)]

-- | Hidden modules.
--   
--   These are useful for error reporting (e.g. if a hidden module is
--   imported)
[unitHiddenModules] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [modulename]

-- | True if this unit has some module holes that need to be instantiated
--   with real modules to make the unit usable (a.k.a. Backpack).
[unitIsIndefinite] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> Bool

-- | True if the unit is exposed. A unit could be installed in a database
--   by "disabled" by not being exposed.
[unitIsExposed] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> Bool

-- | True if the unit is trusted (cf Safe Haskell)
[unitIsTrusted] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> Bool

-- | Information about an installed unit
--   
--   We parameterize on the unit identifier: * UnitKey: identifier used in
--   the database (cf <a>UnitKeyInfo</a>) * UnitId: identifier used to
--   generate code (cf <a>UnitInfo</a>)
--   
--   These two identifiers are different for wired-in packages. See Note
--   [About units] in <a>GHC.Unit</a>
type GenUnitInfo unit = GenericUnitInfo PackageId PackageName unit ModuleName GenModule GenUnit unit

-- | Information about an installed unit (units are identified by their
--   internal UnitId)
type UnitInfo = GenUnitInfo UnitId

-- | A unit key in the database
newtype UnitKey
UnitKey :: FastString -> UnitKey

-- | Information about an installed unit (units are identified by their
--   database UnitKey)
type UnitKeyInfo = GenUnitInfo UnitKey

-- | Convert a DbUnitInfo (read from a package database) into
--   <a>UnitKeyInfo</a>
mkUnitKeyInfo :: DbUnitInfo -> UnitKeyInfo

-- | Map over the unit parameter
mapUnitInfo :: IsUnitId v => (u -> v) -> GenUnitInfo u -> GenUnitInfo v

-- | Create a UnitPprInfo from a UnitInfo
mkUnitPprInfo :: (u -> FastString) -> GenUnitInfo u -> UnitPprInfo

-- | Make a <a>Unit</a> from a <a>UnitInfo</a>
--   
--   If the unit is definite, make a <a>RealUnit</a> from <a>unitId</a>
--   field.
--   
--   If the unit is indefinite, make a <a>VirtUnit</a> from
--   <a>unitInstanceOf</a> and <a>unitInstantiations</a> fields. Note that
--   in this case we don't keep track of <a>unitId</a>. It can be retrieved
--   later with "improvement", i.e. matching on
--   `unitInstanceOf/unitInstantiations` fields (see Note [About units] in
--   GHC.Unit).
mkUnit :: UnitInfo -> Unit
newtype PackageId
PackageId :: FastString -> PackageId
newtype PackageName
PackageName :: FastString -> PackageName
[unPackageName] :: PackageName -> FastString
data Version
Version :: [Int] -> [String] -> Version
[versionBranch] :: Version -> [Int]
[versionTags] :: Version -> [String]
unitPackageNameString :: GenUnitInfo u -> String
unitPackageIdString :: GenUnitInfo u -> String
pprUnitInfo :: UnitInfo -> SDoc

-- | Find all the include directories in the given units
collectIncludeDirs :: [UnitInfo] -> [FilePath]

-- | Find all the C-compiler options in the given units
collectExtraCcOpts :: [UnitInfo] -> [String]

-- | Find all the library directories in the given units for the given ways
collectLibraryDirs :: Ways -> [UnitInfo] -> [FilePath]

-- | Find all the frameworks in the given units
collectFrameworks :: [UnitInfo] -> [String]

-- | Find all the package framework paths in these and the preload packages
collectFrameworksDirs :: [UnitInfo] -> [String]
unitHsLibs :: GhcNameVersion -> Ways -> UnitInfo -> [String]
instance GHC.Classes.Eq GHC.Unit.Info.PackageId
instance GHC.Classes.Eq GHC.Unit.Info.PackageName
instance GHC.Utils.Outputable.Outputable GHC.Unit.Info.PackageId
instance GHC.Utils.Outputable.Outputable GHC.Unit.Info.PackageName
instance GHC.Types.Unique.Uniquable GHC.Unit.Info.PackageId
instance GHC.Types.Unique.Uniquable GHC.Unit.Info.PackageName


-- | Platform profiles
module GHC.Platform.Profile

-- | A platform profile fully describes the kind of objects that are
--   generated for a platform.
--   
--   <a>Platform</a> doesn't fully describe the ABI of an object. Compiler
--   ways (profiling, debug, dynamic) also modify the ABI.
data Profile
Profile :: !Platform -> !Ways -> Profile

-- | Platform
[profilePlatform] :: Profile -> !Platform

-- | Ways
[profileWays] :: Profile -> !Ways

-- | Unique build tag for the profile
profileBuildTag :: Profile -> String

-- | Get platform constants
profileConstants :: Profile -> PlatformConstants

-- | Is profiling enabled
profileIsProfiling :: Profile -> Bool

-- | Word size in bytes
profileWordSizeInBytes :: Profile -> Int
instance GHC.Classes.Eq GHC.Platform.Profile.Profile
instance GHC.Classes.Ord GHC.Platform.Profile.Profile
instance GHC.Internal.Read.Read GHC.Platform.Profile.Profile
instance GHC.Internal.Show.Show GHC.Platform.Profile.Profile


-- | Configuration options for Lift the lambda lifter.
module GHC.Stg.Lift.Config
data StgLiftConfig
StgLiftConfig :: !Profile -> !Maybe Int -> !Maybe Int -> !Bool -> StgLiftConfig
[c_targetProfile] :: StgLiftConfig -> !Profile

-- | Maximum number of arguments after lambda lifting a recursive function.
[c_liftLamsRecArgs] :: StgLiftConfig -> !Maybe Int

-- | Maximum number of arguments after lambda lifting non-recursive
--   function.
[c_liftLamsNonRecArgs] :: StgLiftConfig -> !Maybe Int

-- | Lambda lift even when this turns a known call into an unknown call.
[c_liftLamsKnown] :: StgLiftConfig -> !Bool
instance GHC.Classes.Eq GHC.Stg.Lift.Config.StgLiftConfig
instance GHC.Classes.Ord GHC.Stg.Lift.Config.StgLiftConfig
instance GHC.Internal.Read.Read GHC.Stg.Lift.Config.StgLiftConfig
instance GHC.Internal.Show.Show GHC.Stg.Lift.Config.StgLiftConfig

module GHC.Runtime.Heap.Layout

-- | Word offset, or word count
type WordOff = Int

-- | Byte offset, or byte count
type ByteOff = Int

-- | Convert the given number of words to a number of bytes.
--   
--   This function morally has type <tt>WordOff -&gt; ByteOff</tt>, but
--   uses <tt>Num a</tt> to allow for overloading.
wordsToBytes :: Num a => Platform -> a -> a

-- | First round the given byte count up to a multiple of the machine's
--   word size and then convert the result to words.
bytesToWordsRoundUp :: Platform -> ByteOff -> WordOff

-- | Round up the given byte count to the next byte count that's a multiple
--   of the machine's word size.
roundUpToWords :: Platform -> ByteOff -> ByteOff

-- | Round up <tt>base</tt> to a multiple of <tt>size</tt>.
roundUpTo :: ByteOff -> ByteOff -> ByteOff
data StgWord
fromStgWord :: StgWord -> Integer
toStgWord :: Platform -> Integer -> StgWord
data StgHalfWord
fromStgHalfWord :: StgHalfWord -> Integer
toStgHalfWord :: Platform -> Integer -> StgHalfWord

-- | Half word size in bytes
halfWordSize :: Platform -> ByteOff
halfWordSizeInBits :: Platform -> Int

-- | A description of the layout of a closure. Corresponds directly to the
--   closure types in includes/rts/storage/ClosureTypes.h.
data SMRep
HeapRep :: IsStatic -> !WordOff -> !WordOff -> ClosureTypeInfo -> SMRep
ArrayPtrsRep :: !WordOff -> !WordOff -> SMRep
SmallArrayPtrsRep :: !WordOff -> SMRep
ArrayWordsRep :: !WordOff -> SMRep
StackRep :: Liveness -> SMRep
RTSRep :: Int -> SMRep -> SMRep

-- | True &lt;=&gt; This is a static closure. Affects how we
--   garbage-collect it. Static closure have an extra static link field at
--   the end. Constructors do not have a static variant; see Note [static
--   constructors]
type IsStatic = Bool
data ClosureTypeInfo
Constr :: ConTagZ -> ConstrDescription -> ClosureTypeInfo
Fun :: FunArity -> ArgDescr -> ClosureTypeInfo
Thunk :: ClosureTypeInfo
ThunkSelector :: SelectorOffset -> ClosureTypeInfo
BlackHole :: ClosureTypeInfo
IndStatic :: ClosureTypeInfo

-- | An ArgDescr describes the argument pattern of a function
data ArgDescr
ArgSpec :: !Int -> ArgDescr
ArgGen :: Liveness -> ArgDescr
ArgUnknown :: ArgDescr

-- | We represent liveness bitmaps as a Bitmap (whose internal
--   representation really is a bitmap). These are pinned onto case return
--   vectors to indicate the state of the stack for the garbage collector.
--   
--   In the compiled program, liveness bitmaps that fit inside a single
--   word (StgWord) are stored as a single word, while larger bitmaps are
--   stored as a pointer to an array of words.
type Liveness = [Bool]
type ConstrDescription = ByteString
mkHeapRep :: Profile -> IsStatic -> WordOff -> WordOff -> ClosureTypeInfo -> SMRep
blackHoleRep :: SMRep
indStaticRep :: SMRep
mkStackRep :: [Bool] -> SMRep
mkRTSRep :: Int -> SMRep -> SMRep
arrPtrsRep :: Platform -> WordOff -> SMRep
smallArrPtrsRep :: WordOff -> SMRep
arrWordsRep :: Platform -> ByteOff -> SMRep
isStaticRep :: SMRep -> IsStatic
isConRep :: SMRep -> Bool
isThunkRep :: SMRep -> Bool
isFunRep :: SMRep -> Bool
isStaticNoCafCon :: SMRep -> Bool
isStackRep :: SMRep -> Bool

-- | The total size of the closure, in words.
heapClosureSizeW :: Profile -> SMRep -> WordOff

-- | Size of a closure header (StgHeader in
--   includes/rts/storage/Closures.h)
fixedHdrSizeW :: Profile -> WordOff
arrWordsHdrSize :: Profile -> ByteOff
arrWordsHdrSizeW :: Profile -> WordOff
arrPtrsHdrSize :: Profile -> ByteOff
arrPtrsHdrSizeW :: Profile -> WordOff

-- | Size of the profiling part of a closure header (StgProfHeader in
--   includes/rts/storage/Closures.h)
profHdrSize :: Profile -> WordOff
thunkHdrSize :: Profile -> WordOff
nonHdrSize :: Platform -> SMRep -> ByteOff
nonHdrSizeW :: SMRep -> WordOff
smallArrPtrsHdrSize :: Profile -> ByteOff
smallArrPtrsHdrSizeW :: Profile -> WordOff
hdrSize :: Profile -> SMRep -> ByteOff
hdrSizeW :: Profile -> SMRep -> WordOff
fixedHdrSize :: Profile -> ByteOff

-- | Derives the RTS closure type from an <a>SMRep</a>
rtsClosureType :: SMRep -> Int
rET_SMALL :: Int
rET_BIG :: Int
aRG_GEN :: Int
aRG_GEN_BIG :: Int

-- | The byte offset into the card table of the card for a given element
card :: Platform -> Int -> Int

-- | Convert a number of elements to a number of cards, rounding up
cardRoundUp :: Platform -> Int -> Int

-- | The size of a card table, in bytes
cardTableSizeB :: Platform -> Int -> ByteOff

-- | The size of a card table, in words
cardTableSizeW :: Platform -> Int -> WordOff
instance GHC.Internal.Bits.Bits GHC.Runtime.Heap.Layout.StgWord
instance GHC.Classes.Eq GHC.Runtime.Heap.Layout.ArgDescr
instance GHC.Classes.Eq GHC.Runtime.Heap.Layout.ClosureTypeInfo
instance GHC.Classes.Eq GHC.Runtime.Heap.Layout.SMRep
instance GHC.Classes.Eq GHC.Runtime.Heap.Layout.StgHalfWord
instance GHC.Classes.Eq GHC.Runtime.Heap.Layout.StgWord
instance GHC.Classes.Ord GHC.Runtime.Heap.Layout.ArgDescr
instance GHC.Classes.Ord GHC.Runtime.Heap.Layout.ClosureTypeInfo
instance GHC.Classes.Ord GHC.Runtime.Heap.Layout.SMRep
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Heap.Layout.ArgDescr
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Heap.Layout.ClosureTypeInfo
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Heap.Layout.SMRep
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Heap.Layout.StgHalfWord
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Heap.Layout.StgWord

module GHC.Linker.Static.Utils

-- | Compute the output file name of a program.
--   
--   StaticLink boolean is used to indicate if the program is actually a
--   static library (e.g., on iOS).
--   
--   Use the provided filename (if any), otherwise use "main.exe"
--   (Windows), "a.out (otherwise without StaticLink set), "liba.a". In
--   every case, add the extension if it is missing.
exeFileName :: ArchOS -> Bool -> Maybe FilePath -> FilePath

module GHC.Driver.Phases

-- | Untyped Phase description
data Phase
Unlit :: HscSource -> Phase
Cpp :: HscSource -> Phase
HsPp :: HscSource -> Phase
Hsc :: HscSource -> Phase
Ccxx :: Phase
Cc :: Phase
Cobjc :: Phase
Cobjcxx :: Phase
HCc :: Phase
As :: Bool -> Phase
LlvmOpt :: Phase
LlvmLlc :: Phase
LlvmMangle :: Phase
CmmCpp :: Phase
Cmm :: Phase
MergeForeign :: Phase
Js :: Phase
StopLn :: Phase
happensBefore :: Platform -> Phase -> Phase -> Bool
eqPhase :: Phase -> Phase -> Bool
isStopLn :: Phase -> Bool
startPhase :: String -> Phase
phaseInputExt :: Phase -> String
data StopPhase

-- | <pre>
--   -E
--   </pre>
StopPreprocess :: StopPhase

-- | <pre>
--   -C
--   </pre>
StopC :: StopPhase

-- | <pre>
--   -S
--   </pre>
StopAs :: StopPhase

-- | <pre>
--   -c
--   </pre>
NoStop :: StopPhase
stopPhaseToPhase :: StopPhase -> Phase
isHaskellishSuffix :: String -> Bool
isHaskellSrcSuffix :: String -> Bool
isBackpackishSuffix :: String -> Bool
isObjectSuffix :: Platform -> String -> Bool
isCishSuffix :: String -> Bool
isDynLibSuffix :: Platform -> String -> Bool
isHaskellUserSrcSuffix :: String -> Bool
isHaskellSigSuffix :: String -> Bool
isSourceSuffix :: String -> Bool

-- | When we are given files (modified by -x arguments) we need to
--   determine if they are Haskellish or not to figure out how we should
--   try to compile it. The rules are:
--   
--   <ol>
--   <li>If no -x flag was specified, we check to see if the file looks
--   like a module name, has no extension, or has a Haskell source
--   extension.</li>
--   <li>If an -x flag was specified, we just make sure the specified
--   suffix is a Haskell one.</li>
--   </ol>
isHaskellishTarget :: (String, Maybe Phase) -> Bool
isHaskellishFilename :: FilePath -> Bool
isHaskellSrcFilename :: FilePath -> Bool
isHaskellSigFilename :: FilePath -> Bool
isObjectFilename :: Platform -> FilePath -> Bool
isCishFilename :: FilePath -> Bool
isDynLibFilename :: Platform -> FilePath -> Bool
isHaskellUserSrcFilename :: FilePath -> Bool
isSourceFilename :: FilePath -> Bool

-- | Foreign language of the phase if the phase deals with a foreign code
phaseForeignLanguage :: Phase -> Maybe ForeignSrcLang
instance GHC.Classes.Eq GHC.Driver.Phases.Phase
instance GHC.Utils.Outputable.Outputable GHC.Driver.Phases.Phase
instance GHC.Internal.Show.Show GHC.Driver.Phases.Phase

module GHC.Data.Bitmap

-- | A bitmap represented by a sequence of <a>StgWord</a>s on the
--   <i>target</i> architecture. These are used for bitmaps in info tables
--   and other generated code which need to be emitted as sequences of
--   StgWords.
type Bitmap = [StgWord]

-- | Make a bitmap from a sequence of bits
mkBitmap :: Platform -> [Bool] -> Bitmap

-- | Make a bitmap where the slots specified are the <i>zeros</i> in the
--   bitmap. eg. <tt>[0,1,3], size 4 ==&gt; 0x4</tt> (we leave any bits
--   outside the size as zero, just to make the bitmap easier to read).
--   
--   The list of <tt>Int</tt>s <i>must</i> be already sorted and
--   duplicate-free.
intsToReverseBitmap :: Platform -> Int -> [Int] -> Bitmap

-- | Magic number, must agree with <tt>BITMAP_BITS_SHIFT</tt> in
--   InfoTables.h. Some kinds of bitmap pack a size/bitmap into a single
--   word if possible, or fall back to an external pointer when the bitmap
--   is too large. This value represents the largest size of bitmap that
--   can be packed into a single word.
mAX_SMALL_BITMAP_SIZE :: Platform -> Int

module GHC.Core.Rules.Config

-- | Rule options
data RuleOpts
RuleOpts :: !Platform -> !Bool -> !Bool -> !Bool -> RuleOpts

-- | Target platform
[roPlatform] :: RuleOpts -> !Platform

-- | Enable more advanced numeric constant folding
[roNumConstantFolding] :: RuleOpts -> !Bool

-- | Cut down precision of Rational values to that of Float/Double if
--   disabled
[roExcessRationalPrecision] :: RuleOpts -> !Bool

-- | Enable rules for bignums
[roBignumRules] :: RuleOpts -> !Bool


-- | GHC LLVM Mangler
--   
--   This script processes the assembly produced by LLVM, rewriting all
--   symbols of type <tt>function to </tt>object. This keeps them from
--   going through the PLT, which would be bad due to tables-next-to-code.
--   On x86_64, it also rewrites AVX instructions that require alignment to
--   their unaligned counterparts, since the stack is only 16-byte aligned
--   but these instructions require 32-byte alignment.
module GHC.CmmToLlvm.Mangler

-- | Read in assembly file and process
llvmFixupAsm :: Platform -> FilePath -> FilePath -> IO ()


-- | Llvm code generator configuration
module GHC.CmmToLlvm.Config
data LlvmCgConfig
LlvmCgConfig :: !Platform -> !SDocContext -> !Bool -> !Bool -> !Bool -> Maybe BmiVersion -> Maybe LlvmVersion -> !Bool -> !String -> !LlvmConfig -> LlvmCgConfig

-- | Target platform
[llvmCgPlatform] :: LlvmCgConfig -> !Platform

-- | Context for LLVM code generation
[llvmCgContext] :: LlvmCgConfig -> !SDocContext

-- | Fill undefined literals with garbage values
[llvmCgFillUndefWithGarbage] :: LlvmCgConfig -> !Bool

-- | Split sections
[llvmCgSplitSection] :: LlvmCgConfig -> !Bool
[llvmCgAvxEnabled] :: LlvmCgConfig -> !Bool

-- | (x86) BMI instructions
[llvmCgBmiVersion] :: LlvmCgConfig -> Maybe BmiVersion

-- | version of Llvm we're using
[llvmCgLlvmVersion] :: LlvmCgConfig -> Maybe LlvmVersion

-- | True ==&gt; warn unsupported Llvm version
[llvmCgDoWarn] :: LlvmCgConfig -> !Bool

-- | target triple passed to LLVM
[llvmCgLlvmTarget] :: LlvmCgConfig -> !String

-- | Supported LLVM configurations. see Note [LLVM configuration]
[llvmCgLlvmConfig] :: LlvmCgConfig -> !LlvmConfig
data LlvmConfig
LlvmConfig :: [(String, LlvmTarget)] -> [(Int, String)] -> LlvmConfig
[llvmTargets] :: LlvmConfig -> [(String, LlvmTarget)]
[llvmPasses] :: LlvmConfig -> [(Int, String)]
data LlvmTarget
LlvmTarget :: String -> String -> [String] -> LlvmTarget
[lDataLayout] :: LlvmTarget -> String
[lCPU] :: LlvmTarget -> String
[lAttributes] :: LlvmTarget -> [String]
initLlvmConfig :: FilePath -> IO LlvmConfig


-- | LLVM config cache
module GHC.Driver.LlvmConfigCache

-- | Cache LLVM configuration read from files in top_dir
--   
--   See Note [LLVM configuration] in GHC.CmmToLlvm.Config
--   
--   Currently implemented with unsafe lazy IO. But it could be implemented
--   with an IORef as the exposed interface is in IO.
data LlvmConfigCache
initLlvmConfigCache :: FilePath -> IO LlvmConfigCache
readLlvmConfigCache :: LlvmConfigCache -> IO LlvmConfig

module GHC.Cmm.Type
data CmmType
b8 :: CmmType
b16 :: CmmType
b32 :: CmmType
b64 :: CmmType
b128 :: CmmType
b256 :: CmmType
b512 :: CmmType
f32 :: CmmType
f64 :: CmmType
bWord :: Platform -> CmmType
bHalfWord :: Platform -> CmmType
gcWord :: Platform -> CmmType
cInt :: Platform -> CmmType
cmmBits :: Width -> CmmType
cmmFloat :: Width -> CmmType
typeWidth :: CmmType -> Width
setCmmTypeWidth :: Width -> CmmType -> CmmType
cmmEqType :: CmmType -> CmmType -> Bool

-- | A weaker notion of equality of <a>CmmType</a>s than <a>cmmEqType</a>,
--   used (only) in Cmm Lint.
--   
--   Why "weaker"? Because:
--   
--   <ul>
--   <li>we don't distinguish GcPtr vs NonGcPtr, because the the RTS files
--   are not yet well-typed wrt pointers,</li>
--   <li>for vectors, we only compare the widths, because in practice
--   things like X86 xmm registers support different types of data (e.g.
--   4xf32, 2xf64, 2xu64 etc).</li>
--   </ul>
cmmCompatType :: CmmType -> CmmType -> Bool
isFloatType :: CmmType -> Bool
isGcPtrType :: CmmType -> Bool
isBitsType :: CmmType -> Bool
isWordAny :: CmmType -> Bool
isWord32 :: CmmType -> Bool
isWord64 :: CmmType -> Bool
isFloat64 :: CmmType -> Bool
isFloat32 :: CmmType -> Bool
data Width
W8 :: Width
W16 :: Width
W32 :: Width
W64 :: Width
W128 :: Width
W256 :: Width
W512 :: Width

-- | A width in bits.
widthInBits :: Width -> Int

-- | A width in bytes.
--   
--   <pre>
--   widthFromBytes (widthInBytes w) === w
--   </pre>
widthInBytes :: Width -> Int

-- | log_2 of the width in bytes, useful for generating shifts.
widthInLog :: Width -> Int

-- | <ul>
--   <li>Partial* A width from the number of bytes.</li>
--   </ul>
widthFromBytes :: Int -> Width

-- | The width of the current platform's word size.
wordWidth :: Platform -> Width

-- | The width of the current platform's half-word size.
halfWordWidth :: Platform -> Width
cIntWidth :: Platform -> Width

-- | A bit-mask for the lower half-word of current platform.
halfWordMask :: Platform -> Integer

-- | Narrow a signed or unsigned value to the given width. The result will
--   reside in <tt>[0, +2^width)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; narrowU W8 256    == 256
--   
--   &gt;&gt;&gt; narrowU W8 255    == 255
--   
--   &gt;&gt;&gt; narrowU W8 128    == 128
--   
--   &gt;&gt;&gt; narrowU W8 127    == 127
--   
--   &gt;&gt;&gt; narrowU W8 0      == 0
--   
--   &gt;&gt;&gt; narrowU W8 (-127) == 129
--   
--   &gt;&gt;&gt; narrowU W8 (-128) == 128
--   
--   &gt;&gt;&gt; narrowU W8 (-129) == 127
--   
--   &gt;&gt;&gt; narrowU W8 (-255) == 1
--   
--   &gt;&gt;&gt; narrowU W8 (-256) == 0
--   </pre>
narrowU :: Width -> Integer -> Integer

-- | Narrow a signed value to the given width. The result will reside in
--   <tt>[-2^(width-1), +2^(width-1))</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; narrowS W8 256    == 0
--   
--   &gt;&gt;&gt; narrowS W8 255    == -1
--   
--   &gt;&gt;&gt; narrowS W8 128    == -128
--   
--   &gt;&gt;&gt; narrowS W8 127    == 127
--   
--   &gt;&gt;&gt; narrowS W8 0      == 0
--   
--   &gt;&gt;&gt; narrowS W8 (-127) == -127
--   
--   &gt;&gt;&gt; narrowS W8 (-128) == -128
--   
--   &gt;&gt;&gt; narrowS W8 (-129) == 127
--   
--   &gt;&gt;&gt; narrowS W8 (-255) == 1
--   
--   &gt;&gt;&gt; narrowS W8 (-256) == 0
--   </pre>
narrowS :: Width -> Integer -> Integer
rEP_CostCentreStack_mem_alloc :: Platform -> CmmType
rEP_CostCentreStack_scc_count :: Platform -> CmmType
rEP_StgEntCounter_allocs :: Platform -> CmmType
rEP_StgEntCounter_allocd :: Platform -> CmmType
data ForeignHint
NoHint :: ForeignHint
AddrHint :: ForeignHint
SignedHint :: ForeignHint
type Length = Int
vec :: Length -> CmmType -> CmmType
vec2 :: CmmType -> CmmType
vec4 :: CmmType -> CmmType
vec8 :: CmmType -> CmmType
vec16 :: CmmType -> CmmType
vec2f64 :: CmmType
vec2b64 :: CmmType
vec4f32 :: CmmType
vec4b32 :: CmmType
vec8b16 :: CmmType
vec16b8 :: CmmType
cmmVec :: Int -> CmmType -> CmmType
vecLength :: CmmType -> Length
vecElemType :: CmmType -> CmmType
isVecType :: CmmType -> Bool

-- | is <tt>-falignment-sanitisation</tt> enabled?
type DoAlignSanitisation = Bool
instance GHC.Classes.Eq GHC.Cmm.Type.CmmCat
instance GHC.Classes.Eq GHC.Cmm.Type.ForeignHint
instance GHC.Classes.Eq GHC.Cmm.Type.Width
instance GHC.Classes.Ord GHC.Cmm.Type.Width
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Type.CmmCat
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Type.CmmType
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Type.ForeignHint
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Type.Width
instance GHC.Internal.Show.Show GHC.Cmm.Type.CmmCat
instance GHC.Internal.Show.Show GHC.Cmm.Type.CmmType
instance GHC.Internal.Show.Show GHC.Cmm.Type.Width


-- | Native code generator configuration
module GHC.CmmToAsm.Config

-- | Native code generator configuration
data NCGConfig
NCGConfig :: !Platform -> !SDocContext -> !Module -> !Maybe Int -> !Bool -> !Bool -> !Word -> !Word -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> Maybe SseVersion -> !Bool -> !Bool -> !Bool -> Maybe BmiVersion -> !Bool -> !Bool -> !Bool -> !Weights -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> NCGConfig

-- | Target platform
[ncgPlatform] :: NCGConfig -> !Platform

-- | Context for ASM code generation
[ncgAsmContext] :: NCGConfig -> !SDocContext

-- | The name of the module we are currently compiling
[ncgThisModule] :: NCGConfig -> !Module

-- | Mandatory proc alignment
[ncgProcAlignment] :: NCGConfig -> !Maybe Int

-- | Generate code to link against dynamic libraries
[ncgExternalDynamicRefs] :: NCGConfig -> !Bool

-- | Enable Position-Independent Code
[ncgPIC] :: NCGConfig -> !Bool

-- | If inlining <tt>memcpy</tt> produces less than this threshold (in
--   pseudo-instruction unit), do it
[ncgInlineThresholdMemcpy] :: NCGConfig -> !Word

-- | Ditto for <tt>memset</tt>
[ncgInlineThresholdMemset] :: NCGConfig -> !Word

-- | Split sections
[ncgSplitSections] :: NCGConfig -> !Bool
[ncgRegsIterative] :: NCGConfig -> !Bool
[ncgRegsGraph] :: NCGConfig -> !Bool

-- | Perform ASM linting pass
[ncgAsmLinting] :: NCGConfig -> !Bool

-- | Perform CMM constant folding
[ncgDoConstantFolding] :: NCGConfig -> !Bool

-- | (x86) SSE instructions
[ncgSseVersion] :: NCGConfig -> Maybe SseVersion
[ncgAvxEnabled] :: NCGConfig -> !Bool
[ncgAvx2Enabled] :: NCGConfig -> !Bool
[ncgAvx512fEnabled] :: NCGConfig -> !Bool

-- | (x86) BMI instructions
[ncgBmiVersion] :: NCGConfig -> Maybe BmiVersion
[ncgDumpRegAllocStages] :: NCGConfig -> !Bool
[ncgDumpAsmStats] :: NCGConfig -> !Bool
[ncgDumpAsmConflicts] :: NCGConfig -> !Bool

-- | CFG edge weights
[ncgCfgWeights] :: NCGConfig -> !Weights

-- | Use CFG based block layout algorithm
[ncgCfgBlockLayout] :: NCGConfig -> !Bool

-- | Layout based on last instruction per block.
[ncgCfgWeightlessLayout] :: NCGConfig -> !Bool

-- | Enable Dwarf generation
[ncgDwarfEnabled] :: NCGConfig -> !Bool

-- | Enable unwindings
[ncgDwarfUnwindings] :: NCGConfig -> !Bool

-- | Strip out block information from generated Dwarf
[ncgDwarfStripBlockInfo] :: NCGConfig -> !Bool

-- | Expose symbol table entries for internal symbols
[ncgExposeInternalSymbols] :: NCGConfig -> !Bool

-- | Enable GHC-specific source note DIEs
[ncgDwarfSourceNotes] :: NCGConfig -> !Bool

-- | Enable static control-flow prediction
[ncgCmmStaticPred] :: NCGConfig -> !Bool

-- | Enable shortcutting (don't jump to blocks only containing a jump)
[ncgEnableShortcutting] :: NCGConfig -> !Bool

-- | Compute block unwinding tables
[ncgComputeUnwinding] :: NCGConfig -> !Bool

-- | Whether to enable the dead-code elimination
[ncgEnableDeadCodeElimination] :: NCGConfig -> !Bool

-- | Return Word size
ncgWordWidth :: NCGConfig -> Width

-- | Size in bytes of the pre-allocated spill space on the C stack
ncgSpillPreallocSize :: NCGConfig -> Int

-- | Return Word size
platformWordWidth :: Platform -> Width

module GHC.Cmm.Reg
data CmmReg
CmmLocal :: {-# UNPACK #-} !LocalReg -> CmmReg
CmmGlobal :: GlobalRegUse -> CmmReg
cmmRegType :: CmmReg -> CmmType
cmmRegWidth :: CmmReg -> Width
data LocalReg

-- | Parameters: 1. Identifier 2. Type
LocalReg :: {-# UNPACK #-} !Unique -> !CmmType -> LocalReg
localRegType :: LocalReg -> CmmType

-- | An abstract global register for the STG machine.
--   
--   See also <a>GlobalRegUse</a>, which denotes a usage of a register at a
--   particular type (e.g. using a 32-bit wide register to store an 8-bit
--   wide value), as per Note [GlobalReg vs GlobalRegUse].
data GlobalReg
VanillaReg :: {-# UNPACK #-} !Int -> GlobalReg
FloatReg :: {-# UNPACK #-} !Int -> GlobalReg
DoubleReg :: {-# UNPACK #-} !Int -> GlobalReg
LongReg :: {-# UNPACK #-} !Int -> GlobalReg
XmmReg :: {-# UNPACK #-} !Int -> GlobalReg
YmmReg :: {-# UNPACK #-} !Int -> GlobalReg
ZmmReg :: {-# UNPACK #-} !Int -> GlobalReg

-- | Stack ptr; points to last occupied stack location.
Sp :: GlobalReg

-- | Stack limit
SpLim :: GlobalReg

-- | Heap ptr; points to last occupied heap location.
Hp :: GlobalReg

-- | Heap limit register
HpLim :: GlobalReg

-- | Current cost-centre stack
CCCS :: GlobalReg

-- | pointer to current thread's TSO
CurrentTSO :: GlobalReg

-- | pointer to allocation area
CurrentNursery :: GlobalReg

-- | allocation count for heap check failure
HpAlloc :: GlobalReg

-- | address of stg_EAGER_BLACKHOLE_info
EagerBlackholeInfo :: GlobalReg

-- | address of stg_gc_enter_1
GCEnter1 :: GlobalReg

-- | address of stg_gc_fun
GCFun :: GlobalReg

-- | Base offset for the register table, used for accessing registers which
--   do not have real registers assigned to them. This register will only
--   appear after we have expanded GlobalReg into memory accesses (where
--   necessary) in the native code generator.
BaseReg :: GlobalReg

-- | The register used by the platform for the C stack pointer. This is a
--   break in the STG abstraction used exclusively to setup stack unwinding
--   information.
MachSp :: GlobalReg

-- | A dummy register used to indicate to the stack unwinder where a
--   routine would return to.
UnwindReturnReg :: GlobalReg

-- | Base Register for PIC (position-independent code) calculations.
--   
--   Only used inside the native code generator. Its exact meaning differs
--   from platform to platform (see module PositionIndependentCode).
PicBaseReg :: GlobalReg
isArgReg :: GlobalReg -> Bool
globalRegSpillType :: Platform -> GlobalReg -> CmmType
pprGlobalReg :: IsLine doc => GlobalReg -> doc
spReg :: Platform -> CmmReg
hpReg :: Platform -> CmmReg
spLimReg :: Platform -> CmmReg
hpLimReg :: Platform -> CmmReg
nodeReg :: Platform -> CmmReg
currentTSOReg :: Platform -> CmmReg
currentNurseryReg :: Platform -> CmmReg
hpAllocReg :: Platform -> CmmReg
cccsReg :: Platform -> CmmReg
node :: GlobalReg
baseReg :: Platform -> CmmReg

-- | A use of a global register at a particular type.
--   
--   While a <a>GlobalReg</a> identifies a global register in the STG
--   machine, a <a>GlobalRegUse</a> also contains information about the
--   type we are storing in the register.
--   
--   See Note [GlobalReg vs GlobalRegUse] for more information.
data GlobalRegUse
GlobalRegUse :: !GlobalReg -> !CmmType -> GlobalRegUse

-- | The underlying <a>GlobalReg</a>
[globalRegUse_reg] :: GlobalRegUse -> !GlobalReg

-- | The <a>CmmType</a> at which we are using the <a>GlobalReg</a>.
--   
--   Its width must be less than the width of the <a>GlobalReg</a>:
--   
--   <pre>
--   typeWidth ty &lt;= typeWidth (globalRegSpillType platform reg)
--   </pre>
[globalRegUse_type] :: GlobalRegUse -> !CmmType
pprGlobalRegUse :: IsLine doc => GlobalRegUse -> doc

-- | Global registers used for argument passing.
--   
--   See Note [realArgRegsCover] in GHC.Cmm.CallConv.
data GlobalArgRegs

-- | General-purpose (integer) argument-passing registers.
GP_ARG_REGS :: GlobalArgRegs

-- | Scalar (integer &amp; floating-point) argument-passing registers.
SCALAR_ARG_REGS :: GlobalArgRegs

-- | 16 byte vector argument-passing registers, together with integer &amp;
--   floating-point argument-passing scalar registers.
V16_ARG_REGS :: GlobalArgRegs

-- | 32 byte vector argument-passing registers, together with integer &amp;
--   floating-point argument-passing scalar registers.
V32_ARG_REGS :: GlobalArgRegs

-- | 64 byte vector argument-passing registers, together with integer &amp;
--   floating-point argument-passing scalar registers.
V64_ARG_REGS :: GlobalArgRegs
instance GHC.Classes.Eq GHC.Cmm.Reg.CmmReg
instance GHC.Classes.Eq GHC.Cmm.Reg.GlobalArgRegs
instance GHC.Classes.Eq GHC.Cmm.Reg.GlobalReg
instance GHC.Classes.Eq GHC.Cmm.Reg.GlobalRegUse
instance GHC.Classes.Eq GHC.Cmm.Reg.LocalReg
instance GHC.Classes.Ord GHC.Cmm.Reg.CmmReg
instance GHC.Classes.Ord GHC.Cmm.Reg.GlobalArgRegs
instance GHC.Classes.Ord GHC.Cmm.Reg.GlobalReg
instance GHC.Classes.Ord GHC.Cmm.Reg.GlobalRegUse
instance GHC.Classes.Ord GHC.Cmm.Reg.LocalReg
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Reg.CmmReg
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Reg.GlobalReg
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Reg.GlobalRegUse
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Reg.LocalReg
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.Reg.GlobalReg
instance GHC.Internal.Show.Show GHC.Cmm.Reg.CmmReg
instance GHC.Internal.Show.Show GHC.Cmm.Reg.GlobalArgRegs
instance GHC.Internal.Show.Show GHC.Cmm.Reg.GlobalReg
instance GHC.Internal.Show.Show GHC.Cmm.Reg.GlobalRegUse
instance GHC.Internal.Show.Show GHC.Cmm.Reg.LocalReg
instance GHC.Types.Unique.Uniquable GHC.Cmm.Reg.LocalReg

module GHC.Cmm.MachOp

-- | Machine-level primops; ones which we can reasonably delegate to the
--   native code generators to handle.
--   
--   Most operations are parameterised by the <a>Width</a> that they
--   operate on. Some operations have separate signed and unsigned
--   versions, and float and integer versions.
--   
--   Note that there are variety of places in the native code generator
--   where we assume that the code produced for a MachOp does not introduce
--   new blocks.
data MachOp
MO_Add :: Width -> MachOp
MO_Sub :: Width -> MachOp
MO_Eq :: Width -> MachOp
MO_Ne :: Width -> MachOp
MO_Mul :: Width -> MachOp
MO_S_MulMayOflo :: Width -> MachOp
MO_S_Quot :: Width -> MachOp
MO_S_Rem :: Width -> MachOp
MO_S_Neg :: Width -> MachOp
MO_U_Quot :: Width -> MachOp
MO_U_Rem :: Width -> MachOp
MO_S_Ge :: Width -> MachOp
MO_S_Le :: Width -> MachOp
MO_S_Gt :: Width -> MachOp
MO_S_Lt :: Width -> MachOp
MO_U_Ge :: Width -> MachOp
MO_U_Le :: Width -> MachOp
MO_U_Gt :: Width -> MachOp
MO_U_Lt :: Width -> MachOp
MO_F_Add :: Width -> MachOp
MO_F_Sub :: Width -> MachOp
MO_F_Neg :: Width -> MachOp
MO_F_Mul :: Width -> MachOp
MO_F_Quot :: Width -> MachOp

-- | Fused multiply-add, see <a>FMASign</a>.
MO_FMA :: FMASign -> Length -> Width -> MachOp
MO_F_Eq :: Width -> MachOp
MO_F_Ne :: Width -> MachOp
MO_F_Ge :: Width -> MachOp
MO_F_Le :: Width -> MachOp
MO_F_Gt :: Width -> MachOp
MO_F_Lt :: Width -> MachOp
MO_F_Min :: Width -> MachOp
MO_F_Max :: Width -> MachOp
MO_And :: Width -> MachOp
MO_Or :: Width -> MachOp
MO_Xor :: Width -> MachOp
MO_Not :: Width -> MachOp
MO_Shl :: Width -> MachOp
MO_U_Shr :: Width -> MachOp
MO_S_Shr :: Width -> MachOp
MO_SF_Round :: Width -> Width -> MachOp
MO_FS_Truncate :: Width -> Width -> MachOp
MO_SS_Conv :: Width -> Width -> MachOp
MO_UU_Conv :: Width -> Width -> MachOp
MO_XX_Conv :: Width -> Width -> MachOp
MO_FF_Conv :: Width -> Width -> MachOp
MO_WF_Bitcast :: Width -> MachOp
MO_FW_Bitcast :: Width -> MachOp
MO_V_Broadcast :: Length -> Width -> MachOp
MO_V_Insert :: Length -> Width -> MachOp
MO_V_Extract :: Length -> Width -> MachOp
MO_V_Add :: Length -> Width -> MachOp
MO_V_Sub :: Length -> Width -> MachOp
MO_V_Mul :: Length -> Width -> MachOp
MO_VS_Quot :: Length -> Width -> MachOp
MO_VS_Rem :: Length -> Width -> MachOp
MO_VS_Neg :: Length -> Width -> MachOp
MO_VU_Quot :: Length -> Width -> MachOp
MO_VU_Rem :: Length -> Width -> MachOp
MO_V_Shuffle :: Length -> Width -> [Int] -> MachOp
MO_VF_Shuffle :: Length -> Width -> [Int] -> MachOp
MO_VF_Broadcast :: Length -> Width -> MachOp
MO_VF_Insert :: Length -> Width -> MachOp
MO_VF_Extract :: Length -> Width -> MachOp
MO_VF_Add :: Length -> Width -> MachOp
MO_VF_Sub :: Length -> Width -> MachOp
MO_VF_Neg :: Length -> Width -> MachOp
MO_VF_Mul :: Length -> Width -> MachOp
MO_VF_Quot :: Length -> Width -> MachOp
MO_VS_Min :: Length -> Width -> MachOp
MO_VS_Max :: Length -> Width -> MachOp
MO_VU_Min :: Length -> Width -> MachOp
MO_VU_Max :: Length -> Width -> MachOp
MO_VF_Min :: Length -> Width -> MachOp
MO_VF_Max :: Length -> Width -> MachOp

-- | An atomic read with no memory ordering. Address msut be naturally
--   aligned.
MO_RelaxedRead :: Width -> MachOp
MO_AlignmentCheck :: Int -> Width -> MachOp
pprMachOp :: MachOp -> SDoc

-- | Returns <a>True</a> if the MachOp has commutable arguments. This is
--   used in the platform-independent Cmm optimisations.
--   
--   If in doubt, return <a>False</a>. This generates worse code on the
--   native routes, but is otherwise harmless.
isCommutableMachOp :: MachOp -> Bool

-- | Returns <a>True</a> if the MachOp is associative (i.e. <tt>(x+y)+z ==
--   x+(y+z)</tt>) This is used in the platform-independent Cmm
--   optimisations.
--   
--   If in doubt, return <a>False</a>. This generates worse code on the
--   native routes, but is otherwise harmless.
isAssociativeMachOp :: MachOp -> Bool

-- | Returns <a>True</a> if the MachOp is a comparison.
--   
--   If in doubt, return False. This generates worse code on the native
--   routes, but is otherwise harmless.
isComparisonMachOp :: MachOp -> Bool

-- | Returns <tt>Just w</tt> if the operation is an integer comparison with
--   width <tt>w</tt>, or <tt>Nothing</tt> otherwise.
maybeIntComparison :: MachOp -> Maybe Width

-- | Returns the MachRep of the result of a MachOp.
machOpResultType :: Platform -> MachOp -> [CmmType] -> CmmType

-- | This function is used for debugging only: we can check whether an
--   application of a MachOp is "type-correct" by checking that the
--   MachReps of its arguments are the same as the MachOp expects. This is
--   used when linting a CmmExpr.
machOpArgReps :: Platform -> MachOp -> [Width]
maybeInvertComparison :: MachOp -> Maybe MachOp
isFloatComparison :: MachOp -> Bool
mo_wordAdd :: Platform -> MachOp
mo_wordSub :: Platform -> MachOp
mo_wordEq :: Platform -> MachOp
mo_wordNe :: Platform -> MachOp
mo_wordMul :: Platform -> MachOp
mo_wordSQuot :: Platform -> MachOp
mo_wordSRem :: Platform -> MachOp
mo_wordSNeg :: Platform -> MachOp
mo_wordUQuot :: Platform -> MachOp
mo_wordURem :: Platform -> MachOp
mo_wordSGe :: Platform -> MachOp
mo_wordSLe :: Platform -> MachOp
mo_wordSGt :: Platform -> MachOp
mo_wordSLt :: Platform -> MachOp
mo_wordUGe :: Platform -> MachOp
mo_wordULe :: Platform -> MachOp
mo_wordUGt :: Platform -> MachOp
mo_wordULt :: Platform -> MachOp
mo_wordAnd :: Platform -> MachOp
mo_wordOr :: Platform -> MachOp
mo_wordXor :: Platform -> MachOp
mo_wordNot :: Platform -> MachOp
mo_wordShl :: Platform -> MachOp
mo_wordSShr :: Platform -> MachOp
mo_wordUShr :: Platform -> MachOp
mo_u_8To32 :: MachOp
mo_s_8To32 :: MachOp
mo_u_16To32 :: MachOp
mo_s_16To32 :: MachOp
mo_u_8ToWord :: Platform -> MachOp
mo_s_8ToWord :: Platform -> MachOp
mo_u_16ToWord :: Platform -> MachOp
mo_s_16ToWord :: Platform -> MachOp
mo_u_32ToWord :: Platform -> MachOp
mo_s_32ToWord :: Platform -> MachOp
mo_32To8 :: MachOp
mo_32To16 :: MachOp
mo_WordTo8 :: Platform -> MachOp
mo_WordTo16 :: Platform -> MachOp
mo_WordTo32 :: Platform -> MachOp
mo_WordTo64 :: Platform -> MachOp
data CallishMachOp
MO_F64_Pwr :: CallishMachOp
MO_F64_Sin :: CallishMachOp
MO_F64_Cos :: CallishMachOp
MO_F64_Tan :: CallishMachOp
MO_F64_Sinh :: CallishMachOp
MO_F64_Cosh :: CallishMachOp
MO_F64_Tanh :: CallishMachOp
MO_F64_Asin :: CallishMachOp
MO_F64_Acos :: CallishMachOp
MO_F64_Atan :: CallishMachOp
MO_F64_Asinh :: CallishMachOp
MO_F64_Acosh :: CallishMachOp
MO_F64_Atanh :: CallishMachOp
MO_F64_Log :: CallishMachOp
MO_F64_Log1P :: CallishMachOp
MO_F64_Exp :: CallishMachOp
MO_F64_ExpM1 :: CallishMachOp
MO_F64_Fabs :: CallishMachOp
MO_F64_Sqrt :: CallishMachOp
MO_F32_Pwr :: CallishMachOp
MO_F32_Sin :: CallishMachOp
MO_F32_Cos :: CallishMachOp
MO_F32_Tan :: CallishMachOp
MO_F32_Sinh :: CallishMachOp
MO_F32_Cosh :: CallishMachOp
MO_F32_Tanh :: CallishMachOp
MO_F32_Asin :: CallishMachOp
MO_F32_Acos :: CallishMachOp
MO_F32_Atan :: CallishMachOp
MO_F32_Asinh :: CallishMachOp
MO_F32_Acosh :: CallishMachOp
MO_F32_Atanh :: CallishMachOp
MO_F32_Log :: CallishMachOp
MO_F32_Log1P :: CallishMachOp
MO_F32_Exp :: CallishMachOp
MO_F32_ExpM1 :: CallishMachOp
MO_F32_Fabs :: CallishMachOp
MO_F32_Sqrt :: CallishMachOp
MO_I64_ToI :: CallishMachOp
MO_I64_FromI :: CallishMachOp
MO_W64_ToW :: CallishMachOp
MO_W64_FromW :: CallishMachOp
MO_x64_Neg :: CallishMachOp
MO_x64_Add :: CallishMachOp
MO_x64_Sub :: CallishMachOp
MO_x64_Mul :: CallishMachOp
MO_I64_Quot :: CallishMachOp
MO_I64_Rem :: CallishMachOp
MO_W64_Quot :: CallishMachOp
MO_W64_Rem :: CallishMachOp
MO_x64_And :: CallishMachOp
MO_x64_Or :: CallishMachOp
MO_x64_Xor :: CallishMachOp
MO_x64_Not :: CallishMachOp
MO_x64_Shl :: CallishMachOp
MO_I64_Shr :: CallishMachOp
MO_W64_Shr :: CallishMachOp
MO_x64_Eq :: CallishMachOp
MO_x64_Ne :: CallishMachOp
MO_I64_Ge :: CallishMachOp
MO_I64_Gt :: CallishMachOp
MO_I64_Le :: CallishMachOp
MO_I64_Lt :: CallishMachOp
MO_W64_Ge :: CallishMachOp
MO_W64_Gt :: CallishMachOp
MO_W64_Le :: CallishMachOp
MO_W64_Lt :: CallishMachOp
MO_UF_Conv :: Width -> CallishMachOp
MO_S_Mul2 :: Width -> CallishMachOp
MO_S_QuotRem :: Width -> CallishMachOp
MO_U_QuotRem :: Width -> CallishMachOp
MO_U_QuotRem2 :: Width -> CallishMachOp
MO_Add2 :: Width -> CallishMachOp
MO_AddWordC :: Width -> CallishMachOp
MO_SubWordC :: Width -> CallishMachOp
MO_AddIntC :: Width -> CallishMachOp
MO_SubIntC :: Width -> CallishMachOp
MO_U_Mul2 :: Width -> CallishMachOp
MO_Touch :: CallishMachOp
MO_Prefetch_Data :: Int -> CallishMachOp
MO_Memcpy :: Int -> CallishMachOp
MO_Memset :: Int -> CallishMachOp
MO_Memmove :: Int -> CallishMachOp
MO_Memcmp :: Int -> CallishMachOp
MO_PopCnt :: Width -> CallishMachOp
MO_Pdep :: Width -> CallishMachOp
MO_Pext :: Width -> CallishMachOp
MO_Clz :: Width -> CallishMachOp
MO_Ctz :: Width -> CallishMachOp
MO_BSwap :: Width -> CallishMachOp
MO_BRev :: Width -> CallishMachOp
MO_AcquireFence :: CallishMachOp
MO_ReleaseFence :: CallishMachOp
MO_SeqCstFence :: CallishMachOp

-- | Atomic read-modify-write. Arguments are <tt>[dest, n]</tt>.
MO_AtomicRMW :: Width -> AtomicMachOp -> CallishMachOp

-- | Atomic read. Arguments are <tt>[addr]</tt>.
MO_AtomicRead :: Width -> MemoryOrdering -> CallishMachOp

-- | Atomic write. Arguments are <tt>[addr, value]</tt>.
MO_AtomicWrite :: Width -> MemoryOrdering -> CallishMachOp

-- | Atomic compare-and-swap. Arguments are <tt>[dest, expected, new]</tt>.
--   Sequentially consistent. Possible future refactoring: should this be
--   an<a>MO_AtomicRMW</a> variant?
MO_Cmpxchg :: Width -> CallishMachOp

-- | Atomic swap. Arguments are <tt>[dest, new]</tt>
MO_Xchg :: Width -> CallishMachOp
MO_SuspendThread :: CallishMachOp
MO_ResumeThread :: CallishMachOp

-- | Return (results_hints,args_hints)
callishMachOpHints :: CallishMachOp -> ([ForeignHint], [ForeignHint])
pprCallishMachOp :: CallishMachOp -> SDoc

-- | The alignment of a <tt>memcpy</tt>-ish operation.
machOpMemcpyishAlign :: CallishMachOp -> Maybe Int

-- | C11 memory ordering semantics.
data MemoryOrdering

-- | relaxed ordering
MemOrderRelaxed :: MemoryOrdering

-- | acquire ordering
MemOrderAcquire :: MemoryOrdering

-- | release ordering
MemOrderRelease :: MemoryOrdering

-- | sequentially consistent
MemOrderSeqCst :: MemoryOrdering

-- | The operation to perform atomically.
data AtomicMachOp
AMO_Add :: AtomicMachOp
AMO_Sub :: AtomicMachOp
AMO_And :: AtomicMachOp
AMO_Nand :: AtomicMachOp
AMO_Or :: AtomicMachOp
AMO_Xor :: AtomicMachOp

-- | Where are the signs in a fused multiply-add instruction?
--   
--   <tt>x*y + z</tt> vs <tt>x*y - z</tt> vs <tt>-x*y+z</tt> vs
--   <tt>-x*y-z</tt>.
--   
--   Warning: the signs aren't consistent across architectures (X86,
--   PowerPC, AArch64). The user-facing implementation uses the X86
--   convention, while the relevant backends use their corresponding
--   conventions.
data FMASign

-- | Fused multiply-add <tt>x*y + z</tt>.
FMAdd :: FMASign

-- | Fused multiply-subtract. On X86: <tt>x*y - z</tt>.
FMSub :: FMASign

-- | Fused multiply-add. On X86: <tt>-x*y + z</tt>.
FNMAdd :: FMASign

-- | Fused multiply-subtract. On X86: <tt>-x*y - z</tt>.
FNMSub :: FMASign
pprFMASign :: IsLine doc => FMASign -> doc
instance GHC.Classes.Eq GHC.Cmm.MachOp.AtomicMachOp
instance GHC.Classes.Eq GHC.Cmm.MachOp.CallishMachOp
instance GHC.Classes.Eq GHC.Cmm.MachOp.FMASign
instance GHC.Classes.Eq GHC.Cmm.MachOp.MachOp
instance GHC.Classes.Eq GHC.Cmm.MachOp.MemoryOrdering
instance GHC.Classes.Ord GHC.Cmm.MachOp.MemoryOrdering
instance GHC.Internal.Show.Show GHC.Cmm.MachOp.AtomicMachOp
instance GHC.Internal.Show.Show GHC.Cmm.MachOp.CallishMachOp
instance GHC.Internal.Show.Show GHC.Cmm.MachOp.FMASign
instance GHC.Internal.Show.Show GHC.Cmm.MachOp.MachOp
instance GHC.Internal.Show.Show GHC.Cmm.MachOp.MemoryOrdering


-- | Generating C symbol names emitted by the compiler.
module GHC.CmmToAsm.CPrim
atomicReadLabel :: Width -> FastString
atomicWriteLabel :: Width -> FastString
atomicRMWLabel :: Width -> AtomicMachOp -> FastString
cmpxchgLabel :: Width -> FastString
xchgLabel :: Width -> FastString
popCntLabel :: Width -> FastString
pdepLabel :: Width -> FastString
pextLabel :: Width -> FastString
bSwapLabel :: Width -> FastString
bRevLabel :: Width -> FastString
clzLabel :: Width -> FastString
ctzLabel :: Width -> FastString
word2FloatLabel :: Width -> FastString


-- | Cmm compilation configuration
module GHC.Cmm.Config
data CmmConfig
CmmConfig :: !Profile -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> CmmConfig

-- | Target Profile
[cmmProfile] :: CmmConfig -> !Profile

-- | Optimize Cmm Control Flow or not
[cmmOptControlFlow] :: CmmConfig -> !Bool

-- | Do Cmm Linting Optimization or not
[cmmDoLinting] :: CmmConfig -> !Bool

-- | Eliminate common blocks or not
[cmmOptElimCommonBlks] :: CmmConfig -> !Bool

-- | Perform sink after stack layout or not
[cmmOptSink] :: CmmConfig -> !Bool

-- | Instrument memory accesses for ThreadSanitizer
[cmmOptThreadSanitizer] :: CmmConfig -> !Bool

-- | Generate stack unwinding instructions (for debugging)
[cmmGenStackUnwindInstr] :: CmmConfig -> !Bool

-- | Generate code to link against dynamic libraries
[cmmExternalDynamicRefs] :: CmmConfig -> !Bool

-- | Should the Cmm pass replace Stg switch statements
[cmmDoCmmSwitchPlans] :: CmmConfig -> !Bool

-- | Should Cmm split proc points or not
[cmmSplitProcPoints] :: CmmConfig -> !Bool

-- | retrieve the target Cmm platform
cmmPlatform :: CmmConfig -> Platform


-- | Foreign export stubs
module GHC.Types.ForeignStubs

-- | Foreign export stubs
data ForeignStubs

-- | We don't have any stubs
NoStubs :: ForeignStubs

-- | There are some stubs. Parameters:
--   
--   1) Header file prototypes for "foreign exported" functions
--   
--   2) C stubs to use when calling "foreign exported" functions
ForeignStubs :: CHeader -> CStub -> ForeignStubs
newtype CHeader
CHeader :: SDoc -> CHeader
[getCHeader] :: CHeader -> SDoc
data CStub
CStub :: SDoc -> [CLabel] -> [CLabel] -> CStub
[getCStub] :: CStub -> SDoc

-- | Initializers to be run at startup See Note [Initializers and
--   finalizers in Cmm] in <a>GHC.Cmm.InitFini</a>.
[getInitializers] :: CStub -> [CLabel]

-- | Finalizers to be run at shutdown
[getFinalizers] :: CStub -> [CLabel]

-- | <tt>initializerCStub fn_nm decls body</tt> is a <a>CStub</a>
--   containing C initializer function (e.g. an entry of the
--   <tt>.init_array</tt> section) named <tt>fn_nm</tt> with the given body
--   and the given set of declarations.
initializerCStub :: Platform -> CLabel -> SDoc -> SDoc -> CStub

-- | <tt>finalizerCStub fn_nm decls body</tt> is a <a>CStub</a> containing
--   C finalizer function (e.g. an entry of the <tt>.fini_array</tt>
--   section) named <tt>fn_nm</tt> with the given body and the given set of
--   declarations.
finalizerCStub :: Platform -> CLabel -> SDoc -> SDoc -> CStub
appendStubC :: ForeignStubs -> CStub -> ForeignStubs
instance GHC.Internal.Base.Monoid GHC.Types.ForeignStubs.CHeader
instance GHC.Internal.Base.Monoid GHC.Types.ForeignStubs.CStub
instance GHC.Internal.Base.Semigroup GHC.Types.ForeignStubs.CHeader
instance GHC.Internal.Base.Semigroup GHC.Types.ForeignStubs.CStub


-- | This is where we define a mapping from Uniques to their associated
--   known-key Names for things associated with tuples and sums. We use
--   this mapping while deserializing known-key Names in interface file
--   symbol tables, which are encoded as their Unique. See Note [Symbol
--   table representation of names] for details.
module GHC.Builtin.Uniques

-- | Get the <a>Name</a> associated with a known-key <a>Unique</a>.
knownUniqueName :: Unique -> Maybe Name
mkSumTyConUnique :: Arity -> Unique
mkSumDataConUnique :: ConTagZ -> Arity -> Unique
isSumTyConUnique :: Unique -> Maybe Arity
mkTupleTyConUnique :: Boxity -> Arity -> Unique
mkTupleDataConUnique :: Boxity -> Arity -> Unique

-- | This function is an inverse of <a>mkTupleTyConUnique</a>
isTupleTyConUnique :: Unique -> Maybe (Boxity, Arity)

-- | This function is an inverse of <tt>mkTupleTyDataUnique</tt> that also
--   matches the worker and promoted tycon.
isTupleDataConLikeUnique :: Unique -> Maybe (Boxity, Arity)
mkCTupleTyConUnique :: Arity -> Unique
mkCTupleDataConUnique :: Arity -> Unique
mkCTupleSelIdUnique :: ConTagZ -> Arity -> Unique
mkAlphaTyVarUnique :: Int -> Unique
mkPrimOpIdUnique :: Int -> Unique
mkPrimOpWrapperUnique :: Int -> Unique
mkPreludeMiscIdUnique :: Int -> Unique
mkPreludeDataConUnique :: Int -> Unique
mkPreludeTyConUnique :: Int -> Unique
mkPreludeClassUnique :: Int -> Unique
mkRegSingleUnique :: Int -> Unique
mkRegPairUnique :: Int -> Unique
mkRegClassUnique :: Int -> Unique
mkRegSubUnique :: Int -> Unique
mkCostCentreUnique :: Int -> Unique
varNSUnique :: Unique
dataNSUnique :: Unique
tvNSUnique :: Unique
tcNSUnique :: Unique
mkFldNSUnique :: FastString -> Unique
isFldNSUnique :: Unique -> Bool
mkBuiltinUnique :: Int -> Unique
mkPseudoUniqueE :: Int -> Unique
tyConRepNameUnique :: Unique -> Unique
dataConWorkerUnique :: Unique -> Unique
dataConTyRepNameUnique :: Unique -> Unique
initExitJoinUnique :: Unique
mkBoxingTyConUnique :: Int -> Unique
boxingDataConUnique :: Unique -> Unique


-- | GHC uses several kinds of name internally:
--   
--   <ul>
--   <li><a>OccName</a> represents names as strings with just a little more
--   information: the "namespace" that the name came from, e.g. the
--   namespace of value, type constructors or data constructors</li>
--   <li><a>RdrName</a>: see <a>GHC.Types.Name.Reader#name_types</a></li>
--   <li><a>Name</a>: see <a>GHC.Types.Name#name_types</a></li>
--   <li><a>Id</a>: see <a>GHC.Types.Id#name_types</a></li>
--   <li><a>Var</a>: see <a>GHC.Types.Var#name_types</a></li>
--   </ul>
module GHC.Types.Name.Occurrence
data NameSpace
tcName :: NameSpace
clsName :: NameSpace
tcClsName :: NameSpace
dataName :: NameSpace
varName :: NameSpace
fieldName :: FastString -> NameSpace
tvName :: NameSpace
srcDataName :: NameSpace
pprNameSpace :: NameSpace -> SDoc
pprNonVarNameSpace :: NameSpace -> SDoc
pprNameSpaceBrief :: NameSpace -> SDoc

-- | Occurrence Name
--   
--   In this context that means: "classified (i.e. as a type name, value
--   name, etc) but not qualified and not yet resolved"
data OccName
pprOccName :: IsLine doc => OccName -> doc

-- | Mangle field names to avoid duplicate symbols.
--   
--   See Note [Mangling OccNames].
occNameMangledFS :: OccName -> FastString
mkOccName :: NameSpace -> String -> OccName
mkOccNameFS :: NameSpace -> FastString -> OccName
mkVarOcc :: String -> OccName
mkVarOccFS :: FastString -> OccName
mkRecFieldOcc :: FastString -> String -> OccName
mkRecFieldOccFS :: FastString -> FastString -> OccName
mkDataOcc :: String -> OccName
mkDataOccFS :: FastString -> OccName
mkTyVarOcc :: String -> OccName
mkTyVarOccFS :: FastString -> OccName
mkTcOcc :: String -> OccName
mkTcOccFS :: FastString -> OccName
mkClsOcc :: String -> OccName
mkClsOccFS :: FastString -> OccName
mkDFunOcc :: String -> Bool -> OccSet -> OccName
setOccNameSpace :: NameSpace -> OccName -> OccName
demoteOccName :: OccName -> Maybe OccName
demoteOccTvName :: OccName -> Maybe OccName
promoteOccName :: OccName -> Maybe OccName
varToRecFieldOcc :: HasDebugCallStack => FastString -> OccName -> OccName
recFieldToVarOcc :: HasDebugCallStack => OccName -> OccName

-- | Other names in the compiler add additional information to an OccName.
--   This class provides a consistent way to access the underlying OccName.
class HasOccName name
occName :: HasOccName name => name -> OccName

-- | Test for definitions internally generated by GHC. This predicate is
--   used to suppress printing of internal definitions in some debug prints
isDerivedOccName :: OccName -> Bool
mkDataConWrapperOcc :: OccName -> OccName
mkWorkerOcc :: OccName -> OccName
mkMatcherOcc :: OccName -> OccName
mkBuilderOcc :: OccName -> OccName
mkDefaultMethodOcc :: OccName -> OccName
isDefaultMethodOcc :: OccName -> Bool

-- | Is an <a>OccName</a> one of a Typeable <tt>TyCon</tt> or
--   <tt>Module</tt> binding? This is needed as these bindings are renamed
--   differently. See Note [Grand plan for Typeable] in
--   <a>GHC.Tc.Instance.Typeable</a>.
isTypeableBindOcc :: OccName -> Bool
mkNewTyCoOcc :: OccName -> OccName
mkClassOpAuxOcc :: OccName -> OccName
mkCon2TagOcc :: OccName -> OccName
mkTag2ConOcc :: OccName -> OccName
mkMaxTagOcc :: OccName -> OccName
mkClassDataConOcc :: OccName -> OccName
mkDictOcc :: OccName -> OccName
mkIPOcc :: OccName -> OccName
mkSpecOcc :: OccName -> OccName
mkForeignExportOcc :: OccName -> OccName
mkRepEqOcc :: OccName -> OccName
mkGenR :: OccName -> OccName
mkGen1R :: OccName -> OccName
mkDataTOcc :: OccName -> OccName
mkDataCOcc :: OccName -> OccName
mkDataConWorkerOcc :: OccName -> OccName
mkSuperDictSelOcc :: Int -> OccName -> OccName
mkSuperDictAuxOcc :: Int -> OccName -> OccName
mkLocalOcc :: Unique -> OccName -> OccName
mkMethodOcc :: OccName -> OccName

-- | Derive a name for the representation type constructor of a
--   <tt>data</tt>/<tt>newtype</tt> instance.
mkInstTyTcOcc :: String -> OccSet -> OccName
mkInstTyCoOcc :: OccName -> OccName
mkEqPredCoOcc :: OccName -> OccName
mkTyConRepOcc :: OccName -> OccName
occNameFS :: OccName -> FastString
occNameString :: OccName -> String
occNameSpace :: OccName -> NameSpace
isVarOcc :: OccName -> Bool
isTvOcc :: OccName -> Bool
isTcOcc :: OccName -> Bool
isDataOcc :: OccName -> Bool

-- | Test if the <a>OccName</a> is a data constructor that starts with a
--   symbol (e.g. <tt>:</tt>, or <tt>[]</tt>)
isDataSymOcc :: OccName -> Bool

-- | Test if the <a>OccName</a> is that for any operator (whether it is a
--   data constructor or variable or whatever)
isSymOcc :: OccName -> Bool

-- | <i>Value</i> <tt>OccNames</tt>s are those that are either in the
--   variable, field name or data constructor namespaces
isValOcc :: OccName -> Bool
isFieldOcc :: OccName -> Bool
fieldOcc_maybe :: OccName -> Maybe FastString

-- | Wrap parens around an operator
parenSymOcc :: OccName -> SDoc -> SDoc

-- | Haskell 98 encourages compilers to suppress warnings about unused
--   names in a pattern if they start with <tt>_</tt>: this implements that
--   test
startsWithUnderscore :: OccName -> Bool
isUnderscore :: OccName -> Bool
isTcClsNameSpace :: NameSpace -> Bool
isTvNameSpace :: NameSpace -> Bool
isDataConNameSpace :: NameSpace -> Bool
isVarNameSpace :: NameSpace -> Bool
isValNameSpace :: NameSpace -> Bool
isFieldNameSpace :: NameSpace -> Bool

-- | Is this a term variable or field name namespace?
isTermVarOrFieldNameSpace :: NameSpace -> Bool

-- | A map keyed on <a>OccName</a>. See Note [OccEnv].
data OccEnv a

-- | The empty <a>OccEnv</a>.
emptyOccEnv :: OccEnv a

-- | A singleton <a>OccEnv</a>.
unitOccEnv :: OccName -> a -> OccEnv a

-- | Add a single element to an <a>OccEnv</a>.
extendOccEnv :: OccEnv a -> OccName -> a -> OccEnv a

-- | Map over an <a>OccEnv</a> (<a>Functor</a> instance).
mapOccEnv :: (a -> b) -> OccEnv a -> OccEnv b

-- | Map over an <a>OccEnv</a> strictly.
strictMapOccEnv :: (a -> b) -> OccEnv a -> OccEnv b

-- | <tt>mapMaybe</tt> for b <a>OccEnv</a>.
mapMaybeOccEnv :: (a -> Maybe b) -> OccEnv a -> OccEnv b

-- | Look an element up in an <a>OccEnv</a>.
lookupOccEnv :: OccEnv a -> OccName -> Maybe a

-- | Lookup an element in an <a>OccEnv</a>, ignoring <a>NameSpace</a>s
--   entirely.
lookupOccEnv_AllNameSpaces :: OccEnv a -> OccName -> [a]

-- | Lookup an element in an <a>OccEnv</a>, looking in the record field
--   namespace for a variable.
lookupOccEnv_WithFields :: OccEnv a -> OccName -> [a]

-- | Look up all the record fields that match with the given
--   <a>FastString</a> in an <a>OccEnv</a>.
lookupFieldsOccEnv :: OccEnv a -> FastString -> [a]

-- | Create an <a>OccEnv</a> from a list.
--   
--   <a>OccName</a>s later on in the list override earlier <a>OccName</a>s.
mkOccEnv :: [(OccName, a)] -> OccEnv a

-- | Create an <a>OccEnv</a> from a list, combining different values with
--   the same <a>OccName</a> using the combining function.
mkOccEnv_C :: (a -> a -> a) -> [(OccName, a)] -> OccEnv a

-- | Extend an <a>OccEnv</a> by a list.
--   
--   <a>OccName</a>s later on in the list override earlier <a>OccName</a>s.
extendOccEnvList :: OccEnv a -> [(OccName, a)] -> OccEnv a

-- | Compute whether there is a value keyed by the given <a>OccName</a>.
elemOccEnv :: OccName -> OccEnv a -> Bool

-- | Obtain the elements of an <a>OccEnv</a>.
--   
--   The resulting order is non-deterministic.
nonDetOccEnvElts :: OccEnv a -> [a]

-- | Fold over an <a>OccEnv</a>. Non-deterministic, unless the folding
--   function is commutative (i.e. <tt>a1 <tt>f</tt> ( a2 <tt>f</tt> b ) ==
--   a2 <tt>f</tt> ( a1 <tt>f</tt> b )</tt> for all <tt>a1</tt>,
--   <tt>a2</tt>, <tt>b</tt>).
nonDetFoldOccEnv :: (a -> b -> b) -> b -> OccEnv a -> b

-- | Union of two <a>OccEnv</a>s, right-biased.
plusOccEnv :: OccEnv a -> OccEnv a -> OccEnv a

-- | Union of two <a>OccEnv</a>s with a combining function.
plusOccEnv_C :: (a -> a -> a) -> OccEnv a -> OccEnv a -> OccEnv a

-- | Add a single element to an <a>OccEnv</a>, using a different function
--   whether the <a>OccName</a> already exists or not.
extendOccEnv_Acc :: (a -> b -> b) -> (a -> b) -> OccEnv b -> OccName -> a -> OccEnv b

-- | Filter out all elements in an <a>OccEnv</a> using a predicate.
filterOccEnv :: (a -> Bool) -> OccEnv a -> OccEnv a

-- | Delete multiple elements from an <a>OccEnv</a>.
delListFromOccEnv :: OccEnv a -> [OccName] -> OccEnv a

-- | Delete one element from an <a>OccEnv</a>.
delFromOccEnv :: OccEnv a -> OccName -> OccEnv a

-- | Alter an <a>OccEnv</a>, adding or removing an element at the given
--   key.
alterOccEnv :: (Maybe a -> Maybe a) -> OccEnv a -> OccName -> OccEnv a

-- | Remove elements of the first <a>OccEnv</a> that appear in the second
--   <a>OccEnv</a>.
minusOccEnv :: OccEnv a -> OccEnv b -> OccEnv a

-- | Alters (replaces or removes) those elements of the first <a>OccEnv</a>
--   that are mentioned in the second <a>OccEnv</a>.
--   
--   Same idea as <a>differenceWith</a>.
minusOccEnv_C :: (a -> b -> Maybe a) -> OccEnv a -> OccEnv b -> OccEnv a
minusOccEnv_C_Ns :: (UniqFM NameSpace a -> UniqFM NameSpace b -> UniqFM NameSpace a) -> OccEnv a -> OccEnv b -> OccEnv a
pprOccEnv :: (a -> SDoc) -> OccEnv a -> SDoc

-- | Force an <a>OccEnv</a> with the provided function.
forceOccEnv :: (a -> ()) -> OccEnv a -> ()
intersectOccEnv_C :: (a -> b -> c) -> OccEnv a -> OccEnv b -> OccEnv c
data OccSet
emptyOccSet :: OccSet
unitOccSet :: OccName -> OccSet
mkOccSet :: [OccName] -> OccSet
extendOccSet :: OccSet -> OccName -> OccSet
extendOccSetList :: OccSet -> [OccName] -> OccSet
unionOccSets :: OccSet -> OccSet -> OccSet
unionManyOccSets :: [OccSet] -> OccSet
elemOccSet :: OccName -> OccSet -> Bool
isEmptyOccSet :: OccSet -> Bool
mainOcc :: OccName
ppMainFn :: OccName -> SDoc
type TidyOccEnv = UniqFM FastString Int
emptyTidyOccEnv :: TidyOccEnv
initTidyOccEnv :: [OccName] -> TidyOccEnv
trimTidyOccEnv :: TidyOccEnv -> [OccName] -> TidyOccEnv
tidyOccName :: TidyOccEnv -> OccName -> (TidyOccEnv, OccName)
avoidClashesOccEnv :: TidyOccEnv -> [OccName] -> TidyOccEnv
delTidyOccEnvList :: TidyOccEnv -> [OccName] -> TidyOccEnv

-- | A non-deterministic set of FastStrings. See Note [Deterministic
--   UniqFM] in <a>GHC.Types.Unique.DFM</a> for explanation why it's not
--   deterministic and why it matters. Use DFastStringEnv if the set
--   eventually gets converted into a list or folded over in a way where
--   the order changes the generated code.
type FastStringEnv a = UniqFM FastString a
emptyFsEnv :: FastStringEnv a
lookupFsEnv :: FastStringEnv a -> FastString -> Maybe a
extendFsEnv :: FastStringEnv a -> FastString -> a -> FastStringEnv a
mkFsEnv :: [(FastString, a)] -> FastStringEnv a
instance GHC.Utils.Binary.Binary GHC.Types.Name.Occurrence.NameSpace
instance GHC.Utils.Binary.Binary GHC.Types.Name.Occurrence.OccName
instance GHC.Internal.Data.Data.Data GHC.Types.Name.Occurrence.OccName
instance GHC.Classes.Eq GHC.Types.Name.Occurrence.NameSpace
instance GHC.Classes.Eq GHC.Types.Name.Occurrence.OccName
instance GHC.Internal.Base.Functor GHC.Types.Name.Occurrence.OccEnv
instance GHC.Types.Name.Occurrence.HasOccName GHC.Types.Name.Occurrence.OccName
instance Control.DeepSeq.NFData GHC.Types.Name.Occurrence.NameSpace
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Types.Name.Occurrence.OccEnv a)
instance Control.DeepSeq.NFData GHC.Types.Name.Occurrence.OccName
instance GHC.Classes.Ord GHC.Types.Name.Occurrence.NameSpace
instance GHC.Classes.Ord GHC.Types.Name.Occurrence.OccName
instance GHC.Utils.Outputable.OutputableBndr GHC.Types.Name.Occurrence.OccName
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Types.Name.Occurrence.OccEnv a)
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.Occurrence.OccName
instance GHC.Types.Unique.Uniquable GHC.Types.Name.Occurrence.NameSpace


-- | GHC uses several kinds of name internally:
--   
--   <ul>
--   <li><a>OccName</a>: see
--   <a>GHC.Types.Name.Occurrence#name_types</a></li>
--   <li><a>RdrName</a>: see <a>GHC.Types.Name.Reader#name_types</a></li>
--   <li><a>Name</a> is the type of names that have had their scoping and
--   binding resolved. They have an <a>OccName</a> but also a <a>Unique</a>
--   that disambiguates Names that have the same <a>OccName</a> and indeed
--   is used for all <a>Name</a> comparison. Names also contain information
--   about where they originated from, see
--   <a>GHC.Types.Name#name_sorts</a></li>
--   <li><a>Id</a>: see <a>GHC.Types.Id#name_types</a></li>
--   <li><a>Var</a>: see <a>GHC.Types.Var#name_types</a></li>
--   </ul>
--   
--   Names are one of:
--   
--   <ul>
--   <li>External, if they name things declared in other modules. Some
--   external Names are wired in, i.e. they name primitives defined in the
--   compiler itself</li>
--   <li>Internal, if they name things in the module being compiled. Some
--   internal Names are system names, if they are names manufactured by the
--   compiler</li>
--   </ul>
module GHC.Types.Name

-- | A unique, unambiguous name for something, containing information about
--   where that thing originated.
data Name

-- | BuiltInSyntax is for things like <tt>(:)</tt>, <tt>[]</tt> and tuples,
--   which have special syntactic forms. They aren't in scope as such.
data BuiltInSyntax
BuiltInSyntax :: BuiltInSyntax
UserSyntax :: BuiltInSyntax

-- | Create a name brought into being by the compiler
mkSystemName :: Unique -> OccName -> Name
mkSystemNameAt :: Unique -> OccName -> SrcSpan -> Name

-- | Create a name which is (for now at least) local to the current module
--   and hence does not need a <a>Module</a> to disambiguate it from other
--   <a>Name</a>s
mkInternalName :: Unique -> OccName -> SrcSpan -> Name
mkClonedInternalName :: Unique -> Name -> Name
mkDerivedInternalName :: (OccName -> OccName) -> Unique -> Name -> Name
mkSystemVarName :: Unique -> FastString -> Name
mkSysTvName :: Unique -> FastString -> Name

-- | Make a name for a foreign call
mkFCallName :: Unique -> FastString -> Name

-- | Create a name which definitely originates in the given module
mkExternalName :: Unique -> Module -> OccName -> SrcSpan -> Name

-- | Create a name which is actually defined by the compiler itself
mkWiredInName :: Module -> OccName -> Unique -> TyThing -> BuiltInSyntax -> Name
nameUnique :: Name -> Unique
setNameUnique :: Name -> Unique -> Name
nameOccName :: Name -> OccName
nameNameSpace :: Name -> NameSpace
nameModule :: HasDebugCallStack => Name -> Module
nameModule_maybe :: Name -> Maybe Module
setNameLoc :: Name -> SrcSpan -> Name
tidyNameOcc :: Name -> OccName -> Name

-- | Make the <a>Name</a> into an internal name, regardless of what it was
--   to begin with
localiseName :: Name -> Name
namePun_maybe :: Name -> Maybe FastString
pprName :: IsLine doc => Name -> doc
nameSrcLoc :: Name -> SrcLoc
nameSrcSpan :: Name -> SrcSpan
pprNameDefnLoc :: Name -> SDoc
pprDefinedAt :: Name -> SDoc

-- | Print fully qualified name (with unit-id and module, but no unique)
pprFullName :: Module -> Name -> SDoc

-- | Print a ticky ticky styled name
--   
--   Module argument is the module to use for internal and system names.
--   When printing the name in a ticky profile, the module name is included
--   even for local things. However, ticky uses the format "x (M)" rather
--   than "M.x". Hence, this function provides a separation from normal
--   styling.
pprTickyName :: Module -> Name -> SDoc
isSystemName :: Name -> Bool
isInternalName :: Name -> Bool
isExternalName :: Name -> Bool
isTyVarName :: Name -> Bool
isTyConName :: Name -> Bool
isDataConName :: Name -> Bool
isValName :: Name -> Bool
isVarName :: Name -> Bool

-- | Will the <a>Name</a> come from a dynamically linked package?
isDynLinkName :: Platform -> Module -> Name -> Bool
isFieldName :: Name -> Bool
isWiredInName :: Name -> Bool
isWiredIn :: NamedThing thing => thing -> Bool
isBuiltInSyntax :: Name -> Bool
isTupleTyConName :: Name -> Bool
isSumTyConName :: Name -> Bool

-- | This matches a datacon as well as its worker and promoted tycon.
isUnboxedTupleDataConLikeName :: Name -> Bool
isHoleName :: Name -> Bool
wiredInNameTyThing_maybe :: Name -> Maybe TyThing

-- | Returns True if the name is (a) Internal (b) External but from the
--   specified module (c) External but from the <tt>interactive</tt>
--   package
--   
--   The key idea is that False means: the entity is defined in some other
--   module you can find the details (type, fixity, instances) in some
--   interface file those details will be stored in the EPT or HPT
--   
--   True means: the entity is defined in this module or earlier in the
--   GHCi session you can find details (type, fixity, instances) in the
--   TcGblEnv or TcLclEnv
--   
--   The isInteractiveModule part is because successive interactions of a
--   GHCi session each give rise to a fresh module (Ghci1, Ghci2, etc), but
--   they all come from the magic <tt>interactive</tt> package; and all the
--   details are kept in the TcLclEnv, TcGblEnv, NOT in the HPT or EPT. See
--   Note [The interactive package] in <a>GHC.Runtime.Context</a>
nameIsLocalOrFrom :: Module -> Name -> Bool

-- | Returns True if the name is external or from the <tt>interactive</tt>
--   package See documentation of <a>nameIsLocalOrFrom</a> function
nameIsExternalOrFrom :: Module -> Name -> Bool
nameIsHomePackage :: Module -> Name -> Bool
nameIsHomePackageImport :: Module -> Name -> Bool

-- | Returns True if the Name comes from some other package: neither this
--   package nor the interactive package.
nameIsFromExternalPackage :: HomeUnit -> Name -> Bool

-- | Compare Names lexicographically This only works for Names that
--   originate in the source code or have been tidied.
stableNameCmp :: Name -> Name -> Ordering

-- | A class allowing convenient access to the <a>Name</a> of various
--   datatypes
class NamedThing a
getOccName :: NamedThing a => a -> OccName
getName :: NamedThing a => a -> Name
getSrcLoc :: NamedThing a => a -> SrcLoc
getSrcSpan :: NamedThing a => a -> SrcSpan
getOccString :: NamedThing a => a -> String
getOccFS :: NamedThing a => a -> FastString
pprInfixName :: (Outputable a, NamedThing a) => a -> SDoc
pprPrefixName :: NamedThing a => a -> SDoc
pprModulePrefix :: PprStyle -> Module -> OccName -> SDoc

-- | Print the string of Name unqualifiedly directly.
pprNameUnqualified :: Name -> SDoc

-- | Get a string representation of a <a>Name</a> that's unique and stable
--   across recompilations. Used for deterministic generation of binds for
--   derived instances. eg.
--   "$aeson_70dylHtv1FFGeai1IoxcQr$Data.Aeson.Types.Internal$String"
nameStableString :: Name -> String
instance GHC.Utils.Binary.Binary GHC.Types.Name.Name
instance GHC.Internal.Data.Data.Data GHC.Types.Name.Name
instance GHC.Classes.Eq GHC.Types.Name.Name
instance GHC.Types.Name.Occurrence.HasOccName GHC.Types.Name.Name
instance Control.DeepSeq.NFData GHC.Types.FieldLabel.FieldLabel
instance Control.DeepSeq.NFData GHC.Types.Name.Name
instance Control.DeepSeq.NFData GHC.Types.Name.NameSort
instance GHC.Types.Name.NamedThing e => GHC.Types.Name.NamedThing (GHC.Types.SrcLoc.Located e)
instance GHC.Types.Name.NamedThing GHC.Types.Name.Name
instance GHC.Classes.Ord GHC.Types.Name.Name
instance GHC.Utils.Outputable.OutputableBndr GHC.Types.Name.Name
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.Name
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.NameSort
instance GHC.Types.Unique.Uniquable GHC.Types.Name.Name

module GHC.Types.Name.Set
type NameSet = UniqSet Name
emptyNameSet :: NameSet
unitNameSet :: Name -> NameSet
mkNameSet :: [Name] -> NameSet
unionNameSet :: NameSet -> NameSet -> NameSet
unionNameSets :: [NameSet] -> NameSet
minusNameSet :: NameSet -> NameSet -> NameSet
elemNameSet :: Name -> NameSet -> Bool
extendNameSet :: NameSet -> Name -> NameSet
extendNameSetList :: NameSet -> [Name] -> NameSet
delFromNameSet :: NameSet -> Name -> NameSet
delListFromNameSet :: NameSet -> [Name] -> NameSet
isEmptyNameSet :: NameSet -> Bool
filterNameSet :: (Name -> Bool) -> NameSet -> NameSet
intersectsNameSet :: NameSet -> NameSet -> Bool

-- | True if there is a non-empty intersection. <tt>s1
--   <a>intersectsNameSet</a> s2</tt> doesn't compute <tt>s2</tt> if
--   <tt>s1</tt> is empty
disjointNameSet :: NameSet -> NameSet -> Bool
intersectNameSet :: NameSet -> NameSet -> NameSet
nameSetAny :: (Name -> Bool) -> NameSet -> Bool
nameSetAll :: (Name -> Bool) -> NameSet -> Bool

-- | Get the elements of a NameSet with some stable ordering. This only
--   works for Names that originate in the source code or have been tidied.
--   See Note [Deterministic UniqFM] to learn about nondeterminism
nameSetElemsStable :: NameSet -> [Name]
type FreeVars = NameSet
isEmptyFVs :: NameSet -> Bool
emptyFVs :: FreeVars
plusFVs :: [FreeVars] -> FreeVars
plusFV :: FreeVars -> FreeVars -> FreeVars
mkFVs :: [Name] -> FreeVars
addOneFV :: FreeVars -> Name -> FreeVars
unitFV :: Name -> FreeVars
delFV :: Name -> FreeVars -> FreeVars
delFVs :: [Name] -> FreeVars -> FreeVars
intersectFVs :: FreeVars -> FreeVars -> FreeVars
intersectsFVs :: FreeVars -> FreeVars -> Bool

-- | A set of names that are defined somewhere
type Defs = NameSet

-- | A set of names that are used somewhere
type Uses = NameSet

-- | <tt>(Just ds, us) =&gt;</tt> The use of any member of the <tt>ds</tt>
--   implies that all the <tt>us</tt> are used too. Also, <tt>us</tt> may
--   mention <tt>ds</tt>.
--   
--   <tt>Nothing =&gt;</tt> Nothing is defined in this group, but
--   nevertheless all the uses are essential. Used for instance
--   declarations, for example
type DefUse = (Maybe Defs, Uses)

-- | A number of <a>DefUse</a>s in dependency order: earlier <a>Defs</a>
--   scope over later <a>Uses</a> In a single (def, use) pair, the defs
--   also scope over the uses
type DefUses = OrdList DefUse
emptyDUs :: DefUses
usesOnly :: Uses -> DefUses
mkDUs :: [(Defs, Uses)] -> DefUses
plusDU :: DefUses -> DefUses -> DefUses

-- | Given some <a>DefUses</a> and some <a>Uses</a>, find all the uses,
--   transitively. The result is a superset of the input <a>Uses</a>; and
--   includes things defined in the input <a>DefUses</a> (but only if they
--   are used)
findUses :: DefUses -> Uses -> Uses
duDefs :: DefUses -> Defs

-- | Collect all <a>Uses</a>, regardless of whether the group is itself
--   used, but remove <a>Defs</a> on the way
duUses :: DefUses -> Uses

-- | Just like <a>duUses</a>, but <a>Defs</a> are not eliminated from the
--   <a>Uses</a> returned
allUses :: DefUses -> Uses

-- | <tt>Id</tt>s which have no CAF references. This is a result of
--   analysis of C--. It is always safe to use an empty <a>NonCaffySet</a>.
--   TODO Refer to Note.
newtype NonCaffySet
NonCaffySet :: NameSet -> NonCaffySet
[ncs_nameSet] :: NonCaffySet -> NameSet
instance GHC.Internal.Base.Monoid GHC.Types.Name.Set.NonCaffySet
instance GHC.Internal.Base.Semigroup GHC.Types.Name.Set.NonCaffySet

module GHC.Types.Name.Env

-- | Name Environment
type NameEnv a = UniqFM Name a
mkNameEnv :: [(Name, a)] -> NameEnv a
mkNameEnvWith :: (a -> Name) -> [a] -> NameEnv a
fromUniqMap :: UniqMap Name a -> NameEnv a
emptyNameEnv :: NameEnv a
isEmptyNameEnv :: NameEnv a -> Bool
unitNameEnv :: Name -> a -> NameEnv a
nonDetNameEnvElts :: NameEnv a -> [a]
extendNameEnv_C :: (a -> a -> a) -> NameEnv a -> Name -> a -> NameEnv a
extendNameEnv_Acc :: (a -> b -> b) -> (a -> b) -> NameEnv b -> Name -> a -> NameEnv b
extendNameEnv :: NameEnv a -> Name -> a -> NameEnv a
extendNameEnvList :: NameEnv a -> [(Name, a)] -> NameEnv a
extendNameEnvList_C :: (a -> a -> a) -> NameEnv a -> [(Name, a)] -> NameEnv a
filterNameEnv :: (elt -> Bool) -> NameEnv elt -> NameEnv elt
anyNameEnv :: (elt -> Bool) -> NameEnv elt -> Bool
mapMaybeNameEnv :: (a -> Maybe b) -> NameEnv a -> NameEnv b
extendNameEnvListWith :: (a -> Name) -> NameEnv a -> [a] -> NameEnv a
plusNameEnv :: NameEnv a -> NameEnv a -> NameEnv a
plusNameEnv_C :: (a -> a -> a) -> NameEnv a -> NameEnv a -> NameEnv a
plusNameEnv_CD :: (a -> a -> a) -> NameEnv a -> a -> NameEnv a -> a -> NameEnv a
plusNameEnv_CD2 :: (Maybe a -> Maybe a -> a) -> NameEnv a -> NameEnv a -> NameEnv a
alterNameEnv :: (Maybe a -> Maybe a) -> NameEnv a -> Name -> NameEnv a
plusNameEnvList :: [NameEnv a] -> NameEnv a
plusNameEnvListWith :: (a -> a -> a) -> [NameEnv a] -> NameEnv a
lookupNameEnv :: NameEnv a -> Name -> Maybe a
lookupNameEnv_NF :: NameEnv a -> Name -> a
delFromNameEnv :: NameEnv a -> Name -> NameEnv a
delListFromNameEnv :: NameEnv a -> [Name] -> NameEnv a
elemNameEnv :: Name -> NameEnv a -> Bool
mapNameEnv :: (elt1 -> elt2) -> NameEnv elt1 -> NameEnv elt2
disjointNameEnv :: NameEnv a -> NameEnv a -> Bool
seqEltsNameEnv :: (elt -> ()) -> NameEnv elt -> ()

-- | Deterministic Name Environment
--   
--   See Note [Deterministic UniqFM] in <a>GHC.Types.Unique.DFM</a> for
--   explanation why we need DNameEnv.
type DNameEnv a = UniqDFM Name a
emptyDNameEnv :: DNameEnv a
isEmptyDNameEnv :: DNameEnv a -> Bool
lookupDNameEnv :: DNameEnv a -> Name -> Maybe a
delFromDNameEnv :: DNameEnv a -> Name -> DNameEnv a
filterDNameEnv :: (a -> Bool) -> DNameEnv a -> DNameEnv a
mapDNameEnv :: (a -> b) -> DNameEnv a -> DNameEnv b
adjustDNameEnv :: (a -> a) -> DNameEnv a -> Name -> DNameEnv a
alterDNameEnv :: (Maybe a -> Maybe a) -> DNameEnv a -> Name -> DNameEnv a
extendDNameEnv :: DNameEnv a -> Name -> a -> DNameEnv a
eltsDNameEnv :: DNameEnv a -> [a]
extendDNameEnv_C :: (a -> a -> a) -> DNameEnv a -> Name -> a -> DNameEnv a
plusDNameEnv_C :: (elt -> elt -> elt) -> DNameEnv elt -> DNameEnv elt -> DNameEnv elt
foldDNameEnv :: (a -> b -> b) -> b -> DNameEnv a -> b
nonDetStrictFoldDNameEnv :: (a -> b -> b) -> b -> DNameEnv a -> b
depAnal :: (node -> [Name]) -> (node -> [Name]) -> [node] -> [SCC node]


-- | GHC uses several kinds of name internally:
--   
--   <ul>
--   <li><a>OccName</a>: see
--   <a>GHC.Types.Name.Occurrence#name_types</a></li>
--   <li><a>RdrName</a>: see <a>GHC.Types.Name.Reader#name_types</a></li>
--   <li><a>Name</a>: see <a>GHC.Types.Name#name_types</a></li>
--   <li><a>Id</a>: see <a>GHC.Types.Id#name_types</a></li>
--   <li><a>Var</a> is a synonym for the <a>Id</a> type but it may
--   additionally potentially contain type variables, which have a
--   <a>Kind</a> rather than a <a>Type</a> and only contain some extra
--   details during typechecking.</li>
--   </ul>
--   
--   These <a>Var</a> names may either be global or local, see
--   <a>GHC.Types.Var#globalvslocal</a>
--   
--   Global <a>Id</a>s and <a>Var</a>s are those that are imported or
--   correspond to a data constructor, primitive operation, or record
--   selectors. Local <a>Id</a>s and <a>Var</a>s are those bound within an
--   expression (e.g. by a lambda) or at the top level of the module being
--   compiled.
module GHC.Types.Var

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var

-- | Coercion Variable
type CoVar = Id

-- | Identifier
type Id = Var
type NcId = Id

-- | Dictionary Identifier
type DictId = EvId

-- | Dictionary Function Identifier
type DFunId = Id

-- | Evidence Variable
type EvVar = EvId

-- | Equality Variable
type EqVar = EvId

-- | Evidence Identifier
type EvId = Id

-- | Implicit parameter Identifier
type IpId = EvId
type JoinId = Id

-- | Type or kind Variable
type TyVar = Var

-- | Type variable that might be a metavariable
type TcTyVar = Var

-- | Type Variable
type TypeVar = Var

-- | Kind Variable
type KindVar = Var

-- | Type or Kind Variable
type TKVar = Var

-- | Type or Coercion Variable
type TyCoVar = Id
type InVar = Var
type InCoVar = CoVar
type InId = Id
type InTyVar = TyVar
type OutVar = Var
type OutCoVar = CoVar
type OutId = Id
type OutTyVar = TyVar
varName :: Var -> Name
varUnique :: Var -> Unique

-- | The type or kind of the <a>Var</a> in question
varType :: Var -> Kind
varMult :: Var -> Mult
varMultMaybe :: Id -> Maybe Mult
setVarName :: Var -> Name -> Var
setVarUnique :: Var -> Unique -> Var
setVarType :: Var -> Type -> Var

-- | Update a <a>Var</a>s type. Does not update the <i>multiplicity</i>
--   stored in an <a>Id</a>, if any. Because of the possibility for abuse,
--   ASSERTs that there is no multiplicity to update.
updateVarType :: (Type -> Type) -> Var -> Var

-- | Update a <a>Var</a>s type monadically. Does not update the
--   <i>multiplicity</i> stored in an <a>Id</a>, if any. Because of the
--   possibility for abuse, ASSERTs that there is no multiplicity to
--   update.
updateVarTypeM :: Monad m => (Type -> m Type) -> Var -> m Var
mkGlobalVar :: IdDetails -> Name -> Type -> IdInfo -> Id
mkLocalVar :: IdDetails -> Name -> Mult -> Type -> IdInfo -> Id

-- | Exported <a>Var</a>s will not be removed as dead code
mkExportedLocalVar :: IdDetails -> Name -> Type -> IdInfo -> Id
mkCoVar :: Name -> Type -> CoVar
idInfo :: HasDebugCallStack => Id -> IdInfo
idDetails :: Id -> IdDetails
lazySetIdInfo :: Id -> IdInfo -> Var
setIdDetails :: Id -> IdDetails -> Id

-- | If it's a local, make it global
globaliseId :: Id -> Id

-- | Exports the given local <a>Id</a>. Can also be called on global
--   <a>Id</a>s, such as data constructors and class operations, which are
--   born as global <a>Id</a>s and automatically exported
setIdExported :: Id -> Id

-- | We can only do this to LocalIds
setIdNotExported :: Id -> Id
setIdMult :: Id -> Mult -> Id
updateIdTypeButNotMult :: (Type -> Type) -> Id -> Id
updateIdTypeAndMult :: (Type -> Type) -> Id -> Id
updateIdTypeAndMultM :: Monad m => (Type -> m Type) -> Id -> m Id

-- | Is this a value-level (i.e., computationally relevant)
--   <a>Id</a>entifier? Satisfies <tt>isId = not . isTyVar</tt>.
isId :: Var -> Bool

-- | Is this a type-level (i.e., computationally irrelevant, thus erasable)
--   variable? Satisfies <tt>isTyVar = not . isId</tt>.
isTyVar :: Var -> Bool
isTcTyVar :: Var -> Bool

-- | <a>isLocalVar</a> returns <tt>True</tt> for type variables as well as
--   local <a>Id</a>s These are the variables that we need to pay attention
--   to when finding free variables, or doing dependency analysis.
isLocalVar :: Var -> Bool
isLocalId :: Var -> Bool
isLocalId_maybe :: Var -> Maybe ExportFlag

-- | Is this a coercion variable? Satisfies <tt><a>isId</a> v ==&gt;
--   <a>isCoVar</a> v == not (<a>isNonCoVarId</a> v)</tt>.
isCoVar :: Var -> Bool

-- | Is this a term variable (<a>Id</a>) that is <i>not</i> a coercion
--   variable? Satisfies <tt><a>isId</a> v ==&gt; <a>isCoVar</a> v == not
--   (<a>isNonCoVarId</a> v)</tt>.
isNonCoVarId :: Var -> Bool
isTyCoVar :: Var -> Bool
isGlobalId :: Var -> Bool

-- | <tt>isExportedIdVar</tt> means "don't throw this away"
isExportedId :: Var -> Bool

-- | <a>mustHaveLocalBinding</a> returns <tt>True</tt> of <a>Id</a>s and
--   <a>TyVar</a>s that must have a binding in this module. The converse is
--   not quite right: there are some global <a>Id</a>s that must have
--   bindings, such as record selectors. But that doesn't matter, because
--   it's only used for assertions
mustHaveLocalBinding :: Var -> Bool

-- | ForAllTyFlag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, ForAllTyBinders, TyConBinders,
--   and visibility] in <a>GHC.Core.TyCo.Rep</a>
data ForAllTyFlag
Invisible :: !Specificity -> ForAllTyFlag
Required :: ForAllTyFlag
pattern Specified :: ForAllTyFlag
pattern Inferred :: ForAllTyFlag

-- | Whether an <a>Invisible</a> argument may appear in source Haskell.
data Specificity

-- | the argument may not appear in source Haskell, it is only inferred.
InferredSpec :: Specificity

-- | the argument may appear in source Haskell, but isn't required.
SpecifiedSpec :: Specificity

-- | Does this <a>ForAllTyFlag</a> classify an argument that is written in
--   Haskell?
isVisibleForAllTyFlag :: ForAllTyFlag -> Bool

-- | Does this <a>ForAllTyFlag</a> classify an argument that is not written
--   in Haskell?
isInvisibleForAllTyFlag :: ForAllTyFlag -> Bool
isInferredForAllTyFlag :: ForAllTyFlag -> Bool
isSpecifiedForAllTyFlag :: ForAllTyFlag -> Bool

-- | The ForAllTyFlag on a (Lam a e) term, where <tt>a</tt> is a type
--   variable. If you want other ForAllTyFlag, use a cast. See Note
--   [Required foralls in Core] in GHC.Core.TyCo.Rep
coreTyLamForAllTyFlag :: ForAllTyFlag

-- | The non-dependent version of <a>ForAllTyFlag</a>. See Note [FunTyFlag]
--   Appears here partly so that it's together with its friends
--   ForAllTyFlag and ForallVisFlag, but also because it is used in
--   IfaceType, rather early in the compilation chain
data FunTyFlag
FTF_T_T :: FunTyFlag
FTF_T_C :: FunTyFlag
FTF_C_T :: FunTyFlag
FTF_C_C :: FunTyFlag
isVisibleFunArg :: FunTyFlag -> Bool
isInvisibleFunArg :: FunTyFlag -> Bool
isFUNArg :: FunTyFlag -> Bool
mkFunTyFlag :: TypeOrConstraint -> TypeOrConstraint -> FunTyFlag
visArg :: TypeOrConstraint -> FunTyFlag
invisArg :: TypeOrConstraint -> FunTyFlag
visArgTypeLike :: FunTyFlag
visArgConstraintLike :: FunTyFlag
invisArgTypeLike :: FunTyFlag
invisArgConstraintLike :: FunTyFlag
funTyFlagArgTypeOrConstraint :: FunTyFlag -> TypeOrConstraint
funTyFlagResultTypeOrConstraint :: FunTyFlag -> TypeOrConstraint
data TypeOrConstraint
TypeLike :: TypeOrConstraint
ConstraintLike :: TypeOrConstraint

-- | A <a>PiTyBinder</a> represents an argument to a function. PiTyBinders
--   can be dependent (<a>Named</a>) or nondependent (<a>Anon</a>). They
--   may also be visible or not. See Note [PiTyBinders]
data PiTyBinder
Named :: ForAllTyBinder -> PiTyBinder
Anon :: Scaled Type -> FunTyFlag -> PiTyBinder

-- | <a>PiTyVarBinder</a> is like <a>PiTyBinder</a>, but there can only be
--   <a>TyVar</a> in the <a>Named</a> field.
type PiTyVarBinder = PiTyBinder

-- | Does this binder bind an invisible argument?
isInvisiblePiTyBinder :: PiTyBinder -> Bool

-- | Does this binder bind a visible argument?
isVisiblePiTyBinder :: PiTyBinder -> Bool

-- | If its a named binder, is the binder a tyvar? Returns True for
--   nondependent binder. This check that we're really returning a
--   *Ty*Binder (as opposed to a coercion binder). That way, if/when we
--   allow coercion quantification in more places, we'll know we missed
--   updating some function.
isTyBinder :: PiTyBinder -> Bool
isNamedPiTyBinder :: PiTyBinder -> Bool

-- | Does this binder bind a variable that is <i>not</i> erased? Returns
--   <a>True</a> for anonymous binders.
isAnonPiTyBinder :: PiTyBinder -> Bool
namedPiTyBinder_maybe :: PiTyBinder -> Maybe TyCoVar

-- | Extract a relevant type, if there is one.
anonPiTyBinderType_maybe :: PiTyBinder -> Maybe Type
piTyBinderType :: PiTyBinder -> Type
data VarBndr var argf
Bndr :: var -> argf -> VarBndr var argf

-- | Variable Binder
--   
--   A <a>ForAllTyBinder</a> is the binder of a ForAllTy It's convenient to
--   define this synonym here rather its natural home in
--   <a>GHC.Core.TyCo.Rep</a>, because it's used in
--   GHC.Core.DataCon.hs-boot
--   
--   A <a>TyVarBinder</a> is a binder with only TyVar
type ForAllTyBinder = VarBndr TyCoVar ForAllTyFlag
type TyVarBinder = VarBndr TyVar ForAllTyFlag
type InvisTyBinder = VarBndr TyCoVar Specificity
type InvisTVBinder = VarBndr TyVar Specificity
type ReqTyBinder = VarBndr TyCoVar ()
type ReqTVBinder = VarBndr TyVar ()
binderVar :: VarBndr tv argf -> tv
binderVars :: [VarBndr tv argf] -> [tv]
binderFlag :: VarBndr tv argf -> argf
binderFlags :: [VarBndr tv argf] -> [argf]
binderType :: VarBndr TyCoVar argf -> Type

-- | Make a named binder
mkForAllTyBinder :: vis -> TyCoVar -> VarBndr TyCoVar vis

-- | Make many named binders
mkForAllTyBinders :: vis -> [TyCoVar] -> [VarBndr TyCoVar vis]

-- | Make a named binder <tt>var</tt> should be a type variable
mkTyVarBinder :: vis -> TyVar -> VarBndr TyVar vis

-- | Make many named binders Input vars should be type variables
mkTyVarBinders :: vis -> [TyVar] -> [VarBndr TyVar vis]
isVisibleForAllTyBinder :: ForAllTyBinder -> Bool
isInvisibleForAllTyBinder :: ForAllTyBinder -> Bool
isTyVarBinder :: VarBndr TyCoVar vis -> Bool
tyVarSpecToBinder :: VarBndr a Specificity -> VarBndr a ForAllTyFlag
tyVarSpecToBinders :: [VarBndr a Specificity] -> [VarBndr a ForAllTyFlag]
tyVarReqToBinder :: VarBndr a () -> VarBndr a ForAllTyFlag
tyVarReqToBinders :: [VarBndr a ()] -> [VarBndr a ForAllTyFlag]
mapVarBndr :: (var -> var') -> VarBndr var flag -> VarBndr var' flag
mapVarBndrs :: (var -> var') -> [VarBndr var flag] -> [VarBndr var' flag]
data ExportFlag

-- | Not exported: may be discarded as dead code.
NotExported :: ExportFlag

-- | Exported: kept alive
Exported :: ExportFlag
mkTyVar :: Name -> Kind -> TyVar
mkTcTyVar :: Name -> Kind -> TcTyVarDetails -> TyVar
tyVarName :: TyVar -> Name
tyVarKind :: TyVar -> Kind
tcTyVarDetails :: TyVar -> TcTyVarDetails
setTcTyVarDetails :: TyVar -> TcTyVarDetails -> TyVar
setTyVarName :: TyVar -> Name -> TyVar
setTyVarUnique :: TyVar -> Unique -> TyVar
setTyVarKind :: TyVar -> Kind -> TyVar
updateTyVarKind :: (Kind -> Kind) -> TyVar -> TyVar
updateTyVarKindM :: Monad m => (Kind -> m Kind) -> TyVar -> m TyVar

-- | Compare Vars by their Uniques. This is what Ord Var does, provided
--   here to make it explicit at the call-site that it can introduce
--   non-determinism. See Note [Unique Determinism]
nonDetCmpVar :: Var -> Var -> Ordering
instance GHC.Utils.Binary.Binary GHC.Types.Var.FunTyFlag
instance (GHC.Utils.Binary.Binary tv, GHC.Utils.Binary.Binary vis) => GHC.Utils.Binary.Binary (GHC.Types.Var.VarBndr tv vis)
instance GHC.Internal.Data.Data.Data GHC.Types.Var.FunTyFlag
instance GHC.Internal.Data.Data.Data GHC.Types.Var.PiTyBinder
instance GHC.Internal.Data.Data.Data GHC.Types.Var.Var
instance (GHC.Internal.Data.Data.Data var, GHC.Internal.Data.Data.Data argf) => GHC.Internal.Data.Data.Data (GHC.Types.Var.VarBndr var argf)
instance GHC.Classes.Eq GHC.Types.Var.FunTyFlag
instance GHC.Classes.Eq GHC.Types.Var.Var
instance (GHC.Classes.Eq var, GHC.Classes.Eq argf) => GHC.Classes.Eq (GHC.Types.Var.VarBndr var argf)
instance GHC.Types.Name.Occurrence.HasOccName GHC.Types.Var.Var
instance GHC.Types.Name.NamedThing GHC.Types.Var.Var
instance GHC.Types.Name.NamedThing tv => GHC.Types.Name.NamedThing (GHC.Types.Var.VarBndr tv flag)
instance GHC.Classes.Ord GHC.Types.Var.FunTyFlag
instance GHC.Classes.Ord GHC.Types.Var.Var
instance (GHC.Classes.Ord var, GHC.Classes.Ord argf) => GHC.Classes.Ord (GHC.Types.Var.VarBndr var argf)
instance GHC.Utils.Outputable.Outputable GHC.Types.Var.FunTyFlag
instance GHC.Utils.Outputable.Outputable GHC.Types.Var.PiTyBinder
instance GHC.Utils.Outputable.Outputable GHC.Types.Var.Var
instance GHC.Utils.Outputable.Outputable tv => GHC.Utils.Outputable.Outputable (GHC.Types.Var.VarBndr tv Language.Haskell.Syntax.Specificity.ForAllTyFlag)
instance GHC.Utils.Outputable.Outputable tv => GHC.Utils.Outputable.Outputable (GHC.Types.Var.VarBndr tv Language.Haskell.Syntax.Specificity.Specificity)
instance GHC.Types.Unique.Uniquable GHC.Types.Var.Var

module GHC.Types.Var.Set

-- | A non-deterministic Variable Set
--   
--   A non-deterministic set of variables. See Note [Deterministic UniqFM]
--   in <a>GHC.Types.Unique.DFM</a> for explanation why it's not
--   deterministic and why it matters. Use DVarSet if the set eventually
--   gets converted into a list or folded over in a way where the order
--   changes the generated code, for example when abstracting variables.
type VarSet = UniqSet Var

-- | Identifier Set
type IdSet = UniqSet Id

-- | Type Variable Set
type TyVarSet = UniqSet TyVar

-- | Coercion Variable Set
type CoVarSet = UniqSet CoVar

-- | Type or Coercion Variable Set
type TyCoVarSet = UniqSet TyCoVar
emptyVarSet :: VarSet
unitVarSet :: Var -> VarSet
mkVarSet :: [Var] -> VarSet
extendVarSet :: VarSet -> Var -> VarSet
extendVarSetList :: VarSet -> [Var] -> VarSet
elemVarSet :: Var -> VarSet -> Bool
subVarSet :: VarSet -> VarSet -> Bool
unionVarSet :: VarSet -> VarSet -> VarSet
unionVarSets :: [VarSet] -> VarSet

-- | map the function over the list, and union the results
mapUnionVarSet :: (a -> VarSet) -> [a] -> VarSet
intersectVarSet :: VarSet -> VarSet -> VarSet
intersectsVarSet :: VarSet -> VarSet -> Bool
disjointVarSet :: VarSet -> VarSet -> Bool
isEmptyVarSet :: VarSet -> Bool
delVarSet :: VarSet -> Var -> VarSet
delVarSetList :: VarSet -> [Var] -> VarSet
delVarSetByKey :: VarSet -> Unique -> VarSet
minusVarSet :: VarSet -> VarSet -> VarSet
filterVarSet :: (Var -> Bool) -> VarSet -> VarSet
mapVarSet :: Uniquable b => (a -> b) -> UniqSet a -> UniqSet b
anyVarSet :: (Var -> Bool) -> VarSet -> Bool
allVarSet :: (Var -> Bool) -> VarSet -> Bool
transCloVarSet :: (VarSet -> VarSet) -> VarSet -> VarSet
fixVarSet :: (VarSet -> VarSet) -> VarSet -> VarSet
lookupVarSet_Directly :: VarSet -> Unique -> Maybe Var
lookupVarSet :: VarSet -> Var -> Maybe Var
lookupVarSetByName :: VarSet -> Name -> Maybe Var
sizeVarSet :: VarSet -> Int
seqVarSet :: VarSet -> ()
elemVarSetByKey :: Unique -> VarSet -> Bool
partitionVarSet :: (Var -> Bool) -> VarSet -> (VarSet, VarSet)

-- | Determines the pluralisation suffix appropriate for the length of a
--   set in the same way that plural from Outputable does for lists.
pluralVarSet :: VarSet -> SDoc

-- | Pretty-print a non-deterministic set. The order of variables is
--   non-deterministic and for pretty-printing that shouldn't be a problem.
--   Having this function helps contain the non-determinism created with
--   nonDetEltsUFM. Passing a list to the pretty-printing function allows
--   the caller to decide on the order of Vars (eg. toposort them) without
--   them having to use nonDetEltsUFM at the call site. This prevents from
--   let-binding non-deterministically ordered lists and reusing them where
--   determinism matters.
pprVarSet :: VarSet -> ([Var] -> SDoc) -> SDoc
nonDetStrictFoldVarSet :: (Var -> a -> a) -> a -> VarSet -> a

-- | Deterministic Variable Set
type DVarSet = UniqDSet Var

-- | Deterministic Identifier Set
type DIdSet = UniqDSet Id

-- | Deterministic Type Variable Set
type DTyVarSet = UniqDSet TyVar

-- | Deterministic Coercion Variable Set
type DCoVarSet = UniqDSet CoVar

-- | Deterministic Type or Coercion Variable Set
type DTyCoVarSet = UniqDSet TyCoVar
emptyDVarSet :: DVarSet
unitDVarSet :: Var -> DVarSet
mkDVarSet :: [Var] -> DVarSet
extendDVarSet :: DVarSet -> Var -> DVarSet

-- | Add a list of variables to DVarSet
extendDVarSetList :: DVarSet -> [Var] -> DVarSet
elemDVarSet :: Var -> DVarSet -> Bool
dVarSetElems :: DVarSet -> [Var]
subDVarSet :: DVarSet -> DVarSet -> Bool
unionDVarSet :: DVarSet -> DVarSet -> DVarSet
unionDVarSets :: [DVarSet] -> DVarSet

-- | Map the function over the list, and union the results
mapUnionDVarSet :: (a -> DVarSet) -> [a] -> DVarSet
intersectDVarSet :: DVarSet -> DVarSet -> DVarSet
dVarSetIntersectVarSet :: DVarSet -> VarSet -> DVarSet

-- | True if non-empty intersection
intersectsDVarSet :: DVarSet -> DVarSet -> Bool

-- | True if empty intersection
disjointDVarSet :: DVarSet -> DVarSet -> Bool
isEmptyDVarSet :: DVarSet -> Bool
delDVarSet :: DVarSet -> Var -> DVarSet

-- | Delete a list of variables from DVarSet
delDVarSetList :: DVarSet -> [Var] -> DVarSet
minusDVarSet :: DVarSet -> DVarSet -> DVarSet
nonDetStrictFoldDVarSet :: (Var -> a -> a) -> a -> DVarSet -> a
filterDVarSet :: (Var -> Bool) -> DVarSet -> DVarSet
mapDVarSet :: Uniquable b => (a -> b) -> UniqDSet a -> UniqDSet b
strictFoldDVarSet :: (a -> r -> r) -> r -> UniqDSet a -> r
dVarSetMinusVarSet :: DVarSet -> VarSet -> DVarSet
anyDVarSet :: (Var -> Bool) -> DVarSet -> Bool
allDVarSet :: (Var -> Bool) -> DVarSet -> Bool

-- | transCloVarSet for DVarSet
transCloDVarSet :: (DVarSet -> DVarSet) -> DVarSet -> DVarSet
sizeDVarSet :: DVarSet -> Int
seqDVarSet :: DVarSet -> ()

-- | Partition DVarSet according to the predicate given
partitionDVarSet :: (Var -> Bool) -> DVarSet -> (DVarSet, DVarSet)

-- | Convert a DVarSet to a VarSet by forgetting the order of insertion
dVarSetToVarSet :: DVarSet -> VarSet


-- | Utilities for efficiently and deterministically computing free
--   variables.
module GHC.Utils.FV
type FV = InterestingVarFun -> VarSet -> VarAcc -> VarAcc

-- | Predicate on possible free variables: returns <tt>True</tt> iff the
--   variable is interesting
type InterestingVarFun = Var -> Bool

-- | Run a free variable computation, returning a list of distinct free
--   variables in deterministic order.
fvVarList :: FV -> [Var]

-- | Run a free variable computation, returning a non-deterministic set of
--   free variables. Don't use if the set will be later converted to a list
--   and the order of that list will impact the generated code.
fvVarSet :: FV -> VarSet

-- | Run a free variable computation, returning a deterministic set of free
--   variables. Note that this is just a wrapper around the version that
--   returns a deterministic list. If you need a list you should use
--   <a>fvVarList</a>.
fvDVarSet :: FV -> DVarSet

-- | Add a variable - when free, to the returned free variables. Ignores
--   duplicates and respects the filtering function.
unitFV :: Id -> FV

-- | Return no free variables.
emptyFV :: FV

-- | Add multiple variables - when free, to the returned free variables.
--   Ignores duplicates and respects the filtering function.
mkFVs :: [Var] -> FV

-- | Union two free variable computations.
unionFV :: FV -> FV -> FV

-- | Union many free variable computations.
unionsFV :: [FV] -> FV

-- | Mark the variable as not free by putting it in scope.
delFV :: Var -> FV -> FV

-- | Mark many free variables as not free.
delFVs :: VarSet -> FV -> FV

-- | Filter a free variable computation.
filterFV :: InterestingVarFun -> FV -> FV

-- | Map a free variable computation over a list and union the results.
mapUnionFV :: (a -> FV) -> [a] -> FV
fvDVarSetSome :: InterestingVarFun -> FV -> DVarSet

module GHC.Types.SptEntry

-- | An entry to be inserted into a module's static pointer table. See Note
--   [Grand plan for static forms] in <a>GHC.Iface.Tidy.StaticPtrTable</a>.
data SptEntry
SptEntry :: Id -> Fingerprint -> SptEntry
instance GHC.Utils.Outputable.Outputable GHC.Types.SptEntry.SptEntry

module GHC.Data.Graph.UnVar
data UnVarSet
emptyUnVarSet :: UnVarSet
mkUnVarSet :: [Var] -> UnVarSet
unionUnVarSet :: UnVarSet -> UnVarSet -> UnVarSet
unionUnVarSets :: [UnVarSet] -> UnVarSet
extendUnVarSet :: Var -> UnVarSet -> UnVarSet
extendUnVarSetList :: [Var] -> UnVarSet -> UnVarSet
delUnVarSet :: UnVarSet -> Var -> UnVarSet
delUnVarSetList :: UnVarSet -> [Var] -> UnVarSet
elemUnVarSet :: Var -> UnVarSet -> Bool
isEmptyUnVarSet :: UnVarSet -> Bool
data UnVarGraph
emptyUnVarGraph :: UnVarGraph
unionUnVarGraph :: UnVarGraph -> UnVarGraph -> UnVarGraph
unionUnVarGraphs :: [UnVarGraph] -> UnVarGraph
completeGraph :: UnVarSet -> UnVarGraph
completeBipartiteGraph :: UnVarSet -> UnVarSet -> UnVarGraph
neighbors :: UnVarGraph -> Var -> UnVarSet
hasLoopAt :: UnVarGraph -> Var -> Bool
delNode :: UnVarGraph -> Var -> UnVarGraph
domUFMUnVarSet :: forall {k} (key :: k) elt. UniqFM key elt -> UnVarSet
instance GHC.Classes.Eq GHC.Data.Graph.UnVar.UnVarSet
instance GHC.Utils.Outputable.Outputable GHC.Data.Graph.UnVar.UnVarGraph
instance GHC.Utils.Outputable.Outputable GHC.Data.Graph.UnVar.UnVarSet

module GHC.Types.Var.Env

-- | Variable Environment
type VarEnv elt = UniqFM Var elt

-- | Identifier Environment
type IdEnv elt = UniqFM Id elt

-- | Type Variable Environment
type TyVarEnv elt = UniqFM Var elt

-- | Coercion Variable Environment
type CoVarEnv elt = UniqFM CoVar elt

-- | Type or Coercion Variable Environment
type TyCoVarEnv elt = UniqFM TyCoVar elt
emptyVarEnv :: VarEnv a
unitVarEnv :: Var -> a -> VarEnv a
mkVarEnv :: [(Var, a)] -> VarEnv a
mkVarEnv_Directly :: [(Unique, a)] -> VarEnv a
elemVarEnv :: Var -> VarEnv a -> Bool
disjointVarEnv :: VarEnv a -> VarEnv a -> Bool
anyVarEnv :: forall {k} elt (key :: k). (elt -> Bool) -> UniqFM key elt -> Bool
extendVarEnv :: VarEnv a -> Var -> a -> VarEnv a
extendVarEnv_C :: (a -> a -> a) -> VarEnv a -> Var -> a -> VarEnv a
extendVarEnv_Acc :: (a -> b -> b) -> (a -> b) -> VarEnv b -> Var -> a -> VarEnv b
extendVarEnvList :: VarEnv a -> [(Var, a)] -> VarEnv a
plusVarEnv :: VarEnv a -> VarEnv a -> VarEnv a
plusVarEnv_C :: (a -> a -> a) -> VarEnv a -> VarEnv a -> VarEnv a
plusVarEnv_CD :: (a -> a -> a) -> VarEnv a -> a -> VarEnv a -> a -> VarEnv a
plusMaybeVarEnv_C :: (a -> a -> Maybe a) -> VarEnv a -> VarEnv a -> VarEnv a
plusVarEnvList :: [VarEnv a] -> VarEnv a
alterVarEnv :: (Maybe a -> Maybe a) -> VarEnv a -> Var -> VarEnv a
delVarEnvList :: VarEnv a -> [Var] -> VarEnv a
delVarEnv :: VarEnv a -> Var -> VarEnv a
minusVarEnv :: VarEnv a -> VarEnv b -> VarEnv a
lookupVarEnv :: VarEnv a -> Var -> Maybe a
lookupVarEnv_NF :: VarEnv a -> Var -> a
lookupWithDefaultVarEnv :: VarEnv a -> a -> Var -> a
lookupVarEnv_Directly :: VarEnv a -> Unique -> Maybe a
mapVarEnv :: (a -> b) -> VarEnv a -> VarEnv b
zipVarEnv :: [Var] -> [a] -> VarEnv a
modifyVarEnv :: (a -> a) -> VarEnv a -> Var -> VarEnv a
modifyVarEnv_Directly :: forall {k} a (key :: k). (a -> a) -> UniqFM key a -> Unique -> UniqFM key a
isEmptyVarEnv :: VarEnv a -> Bool
elemVarEnvByKey :: Unique -> VarEnv a -> Bool
filterVarEnv :: (a -> Bool) -> VarEnv a -> VarEnv a

-- | Only keep variables contained in the VarSet
restrictVarEnv :: VarEnv a -> VarSet -> VarEnv a
partitionVarEnv :: (a -> Bool) -> VarEnv a -> (VarEnv a, VarEnv a)
varEnvDomain :: VarEnv elt -> UnVarSet
nonDetStrictFoldVarEnv_Directly :: (Unique -> a -> r -> r) -> r -> VarEnv a -> r

-- | Deterministic Variable Environment
type DVarEnv elt = UniqDFM Var elt

-- | Deterministic Identifier Environment Sadly not always indexed by Id,
--   but it is in the common case.
type DIdEnv elt = UniqDFM Var elt

-- | Deterministic Type Variable Environment
type DTyVarEnv elt = UniqDFM TyVar elt
emptyDVarEnv :: DVarEnv a
mkDVarEnv :: [(Var, a)] -> DVarEnv a
dVarEnvElts :: DVarEnv a -> [a]
extendDVarEnv :: DVarEnv a -> Var -> a -> DVarEnv a
extendDVarEnv_C :: (a -> a -> a) -> DVarEnv a -> Var -> a -> DVarEnv a
extendDVarEnvList :: DVarEnv a -> [(Var, a)] -> DVarEnv a
lookupDVarEnv :: DVarEnv a -> Var -> Maybe a
elemDVarEnv :: Var -> DVarEnv a -> Bool
isEmptyDVarEnv :: DVarEnv a -> Bool
foldDVarEnv :: (a -> b -> b) -> b -> DVarEnv a -> b
nonDetStrictFoldDVarEnv :: (a -> b -> b) -> b -> DVarEnv a -> b
mapDVarEnv :: (a -> b) -> DVarEnv a -> DVarEnv b
filterDVarEnv :: (a -> Bool) -> DVarEnv a -> DVarEnv a
modifyDVarEnv :: (a -> a) -> DVarEnv a -> Var -> DVarEnv a
alterDVarEnv :: (Maybe a -> Maybe a) -> DVarEnv a -> Var -> DVarEnv a
plusDVarEnv :: DVarEnv a -> DVarEnv a -> DVarEnv a
plusDVarEnv_C :: (a -> a -> a) -> DVarEnv a -> DVarEnv a -> DVarEnv a
unitDVarEnv :: Var -> a -> DVarEnv a
delDVarEnv :: DVarEnv a -> Var -> DVarEnv a
delDVarEnvList :: DVarEnv a -> [Var] -> DVarEnv a
minusDVarEnv :: DVarEnv a -> DVarEnv a' -> DVarEnv a
partitionDVarEnv :: (a -> Bool) -> DVarEnv a -> (DVarEnv a, DVarEnv a)
anyDVarEnv :: (a -> Bool) -> DVarEnv a -> Bool

-- | A set of variables that are in scope at some point.
--   
--   Note that this is a <i>superset</i> of the variables that are
--   currently in scope. See Note [The InScopeSet invariant].
--   
--   "Secrets of the Glasgow Haskell Compiler inliner" Section 3.2 provides
--   the motivation for this abstraction.
newtype InScopeSet
InScope :: VarSet -> InScopeSet
emptyInScopeSet :: InScopeSet
mkInScopeSet :: VarSet -> InScopeSet
mkInScopeSetList :: [Var] -> InScopeSet
delInScopeSet :: InScopeSet -> Var -> InScopeSet
extendInScopeSet :: InScopeSet -> Var -> InScopeSet
extendInScopeSetList :: InScopeSet -> [Var] -> InScopeSet
extendInScopeSetSet :: InScopeSet -> VarSet -> InScopeSet
getInScopeVars :: InScopeSet -> VarSet

-- | Look up a variable the <a>InScopeSet</a>. This lets you map from the
--   variable's identity (unique) to its full value.
lookupInScope :: InScopeSet -> Var -> Maybe Var
lookupInScope_Directly :: InScopeSet -> Unique -> Maybe Var
unionInScope :: InScopeSet -> InScopeSet -> InScopeSet
elemInScopeSet :: Var -> InScopeSet -> Bool

-- | <tt>uniqAway in_scope v</tt> finds a unique that is not used in the
--   in-scope set, and gives that to v. See Note [Local uniques] and Note
--   [The InScopeSet invariant].
uniqAway :: InScopeSet -> Var -> Var
varSetInScope :: VarSet -> InScopeSet -> Bool

-- | <tt>unsafeGetFreshUnique in_scope</tt> finds a unique that is not
--   in-scope in the given <a>InScopeSet</a>. This must be used very
--   carefully since one can very easily introduce non-unique
--   <a>Unique</a>s this way. See Note [Local uniques].
unsafeGetFreshLocalUnique :: InScopeSet -> Unique

-- | Rename Environment 2
--   
--   When we are comparing (or matching) types or terms, we are faced with
--   "going under" corresponding binders. E.g. when comparing:
--   
--   <pre>
--   \x. e1     ~   \y. e2
--   </pre>
--   
--   Basically we want to rename [<tt>x</tt> -&gt; <tt>y</tt>] or
--   [<tt>y</tt> -&gt; <tt>x</tt>], but there are lots of things we must be
--   careful of. In particular, <tt>x</tt> might be free in <tt>e2</tt>, or
--   y in <tt>e1</tt>. So the idea is that we come up with a fresh binder
--   that is free in neither, and rename <tt>x</tt> and <tt>y</tt>
--   respectively. That means we must maintain:
--   
--   <ol>
--   <li>A renaming for the left-hand expression</li>
--   <li>A renaming for the right-hand expressions</li>
--   <li>An in-scope set</li>
--   </ol>
--   
--   Furthermore, when matching, we want to be able to have an 'occurs
--   check', to prevent:
--   
--   <pre>
--   \x. f   ~   \y. y
--   </pre>
--   
--   matching with [<tt>f</tt> -&gt; <tt>y</tt>]. So for each expression we
--   want to know that set of locally-bound variables. That is precisely
--   the domain of the mappings 1. and 2., but we must ensure that we
--   always extend the mappings as we go in.
--   
--   All of this information is bundled up in the <a>RnEnv2</a>
data RnEnv2
mkRnEnv2 :: InScopeSet -> RnEnv2

-- | <tt>rnBndr2 env bL bR</tt> goes under a binder <tt>bL</tt> in the Left
--   term, and binder <tt>bR</tt> in the Right term. It finds a new binder,
--   <tt>new_b</tt>, and returns an environment mapping <tt>bL -&gt;
--   new_b</tt> and <tt>bR -&gt; new_b</tt>
rnBndr2 :: RnEnv2 -> Var -> Var -> RnEnv2

-- | Applies <a>rnBndr2</a> to several variables: the two variable lists
--   must be of equal length
rnBndrs2 :: RnEnv2 -> [Var] -> [Var] -> RnEnv2

-- | Similar to <a>rnBndr2</a> but returns the new variable as well as the
--   new environment. Postcondition: the type of the returned Var is that
--   of bR
rnBndr2_var :: RnEnv2 -> Var -> Var -> (RnEnv2, Var)

-- | Look up the renaming of an occurrence in the left or right term
rnOccL :: RnEnv2 -> Var -> Var

-- | Look up the renaming of an occurrence in the left or right term
rnOccR :: RnEnv2 -> Var -> Var

-- | Tells whether a variable is locally bound
inRnEnvL :: RnEnv2 -> Var -> Bool

-- | Tells whether a variable is locally bound
inRnEnvR :: RnEnv2 -> Var -> Bool

-- | `anyInRnEnvR env set` == `any (inRnEnvR rn_env) (toList set)` but lazy
--   in the second argument if the right side of the env is empty.
anyInRnEnvR :: RnEnv2 -> VarSet -> Bool

-- | Look up the renaming of an occurrence in the left or right term
rnOccL_maybe :: RnEnv2 -> Var -> Maybe Var

-- | Look up the renaming of an occurrence in the left or right term
rnOccR_maybe :: RnEnv2 -> Var -> Maybe Var

-- | Similar to <a>rnBndr2</a> but used when there's a binder on the left
--   side only.
rnBndrL :: RnEnv2 -> Var -> (RnEnv2, Var)

-- | Similar to <a>rnBndr2</a> but used when there's a binder on the right
--   side only.
rnBndrR :: RnEnv2 -> Var -> (RnEnv2, Var)

-- | Wipe the left or right side renaming
nukeRnEnvL :: RnEnv2 -> RnEnv2

-- | Wipe the left or right side renaming
nukeRnEnvR :: RnEnv2 -> RnEnv2

-- | swap the meaning of left and right
rnSwap :: RnEnv2 -> RnEnv2
delBndrL :: RnEnv2 -> Var -> RnEnv2
delBndrR :: RnEnv2 -> Var -> RnEnv2
delBndrsL :: RnEnv2 -> [Var] -> RnEnv2
delBndrsR :: RnEnv2 -> [Var] -> RnEnv2
extendRnInScopeSetList :: RnEnv2 -> [Var] -> RnEnv2

-- | Similar to <a>rnBndrL</a> but used for eta expansion See Note [Eta
--   expansion]
rnEtaL :: RnEnv2 -> Var -> (RnEnv2, Var)

-- | Similar to <a>rnBndr2</a> but used for eta expansion See Note [Eta
--   expansion]
rnEtaR :: RnEnv2 -> Var -> (RnEnv2, Var)
rnInScope :: Var -> RnEnv2 -> Bool
rnInScopeSet :: RnEnv2 -> InScopeSet
lookupRnInScope :: RnEnv2 -> Var -> Var

-- | Retrieve the left mapping
rnEnvL :: RnEnv2 -> VarEnv Var

-- | Retrieve the right mapping
rnEnvR :: RnEnv2 -> VarEnv Var

-- | Tidy Environment
--   
--   When tidying up print names, we keep a mapping of in-scope occ-names
--   (the <a>TidyOccEnv</a>) and a Var-to-Var of the current renamings
type TidyEnv = (TidyOccEnv, VarEnv Var)
emptyTidyEnv :: TidyEnv
mkEmptyTidyEnv :: TidyOccEnv -> TidyEnv
delTidyEnvList :: TidyEnv -> [Var] -> TidyEnv
instance GHC.Utils.Outputable.Outputable GHC.Types.Var.Env.InScopeSet

module GHC.Stg.InferTags.TagSig

-- | Information to be exposed in interface files which is produced by the
--   stg2stg passes.
type StgCgInfos = NameEnv TagSig
newtype TagSig
TagSig :: TagInfo -> TagSig
data TagInfo
TagDunno :: TagInfo
TagTuple :: [TagInfo] -> TagInfo
TagProper :: TagInfo
TagTagged :: TagInfo
isTaggedSig :: TagSig -> Bool
seqTagSig :: TagSig -> ()
seqTagInfo :: TagInfo -> ()
instance GHC.Utils.Binary.Binary GHC.Stg.InferTags.TagSig.TagInfo
instance GHC.Utils.Binary.Binary GHC.Stg.InferTags.TagSig.TagSig
instance GHC.Classes.Eq GHC.Stg.InferTags.TagSig.TagInfo
instance GHC.Classes.Eq GHC.Stg.InferTags.TagSig.TagSig
instance GHC.Utils.Outputable.OutputableBndr (GHC.Types.Var.Id, GHC.Stg.InferTags.TagSig.TagSig)
instance GHC.Utils.Outputable.Outputable GHC.Stg.InferTags.TagSig.TagInfo
instance GHC.Utils.Outputable.Outputable GHC.Stg.InferTags.TagSig.TagSig


-- | Renamer-level information about <a>Name</a>s.
--   
--   Renamer equivalent of <tt>TyThing</tt>.
module GHC.Types.GREInfo

-- | Information about a <a>Name</a> that is pertinent to the renamer.
--   
--   See Note [GREInfo]
data GREInfo

-- | No particular information... e.g. a function
Vanilla :: GREInfo

-- | An unbound GRE... could be anything
UnboundGRE :: GREInfo

-- | <tt>TyCon</tt>
IAmTyCon :: !TyConFlavour Name -> GREInfo

-- | <a>ConLike</a>
IAmConLike :: !ConInfo -> GREInfo
IAmRecField :: !RecFieldInfo -> GREInfo
plusGREInfo :: GREInfo -> GREInfo -> GREInfo

-- | Information known to the renamer about a data constructor or pattern
--   synonym.
--   
--   See Note [Local constructor info in the renamer].
data ConInfo
ConInfo :: !ConLikeInfo -> !ConFieldInfo -> ConInfo
[conLikeInfo] :: ConInfo -> !ConLikeInfo
[conFieldInfo] :: ConInfo -> !ConFieldInfo

-- | Whether a constructor is a data constructor or a pattern synonym.
--   
--   See Note [Local constructor info in the renamer].
data ConLikeInfo
ConIsData :: [Name] -> ConLikeInfo

-- | All the <tt>DataCon</tt>s of the parent <tt>TyCon</tt>, including the
--   <a>ConLike</a> itself.
--   
--   Used in <a>isIrrefutableHsPat</a>.
[conLikeDataCons] :: ConLikeInfo -> [Name]
ConIsPatSyn :: ConLikeInfo

-- | Information about the record fields of a constructor.
--   
--   See Note [Local constructor info in the renamer]
data ConFieldInfo
ConHasRecordFields :: NonEmpty FieldLabel -> ConFieldInfo
ConHasPositionalArgs :: ConFieldInfo
ConIsNullary :: ConFieldInfo
mkConInfo :: ConLikeInfo -> Arity -> [FieldLabel] -> ConInfo
mkConFieldInfo :: Arity -> [FieldLabel] -> ConFieldInfo
conInfoFields :: ConInfo -> [FieldLabel]
conFieldInfoFields :: ConFieldInfo -> [FieldLabel]

-- | The <a>Name</a> of a <a>ConLike</a>.
--   
--   Useful when we are in the renamer and don't yet have a full
--   <tt>DataCon</tt> or <tt>PatSyn</tt> to hand.
data ConLikeName
DataConName :: !Name -> ConLikeName
[conLikeName_Name] :: ConLikeName -> !Name
PatSynName :: !Name -> ConLikeName
[conLikeName_Name] :: ConLikeName -> !Name
data RecFieldInfo
RecFieldInfo :: !FieldLabel -> !UniqSet ConLikeName -> RecFieldInfo
[recFieldLabel] :: RecFieldInfo -> !FieldLabel

-- | The constructors which have this field label. Always non-empty.
--   
--   NB: these constructors will always share a single parent, as the field
--   label disambiguates between parents in the presence of duplicate
--   record fields.
[recFieldCons] :: RecFieldInfo -> !UniqSet ConLikeName
instance GHC.Internal.Data.Data.Data GHC.Types.GREInfo.ConFieldInfo
instance GHC.Internal.Data.Data.Data GHC.Types.GREInfo.ConInfo
instance GHC.Internal.Data.Data.Data GHC.Types.GREInfo.ConLikeInfo
instance GHC.Internal.Data.Data.Data GHC.Types.GREInfo.ConLikeName
instance GHC.Internal.Data.Data.Data GHC.Types.GREInfo.GREInfo
instance GHC.Internal.Data.Data.Data GHC.Types.GREInfo.RecFieldInfo
instance GHC.Classes.Eq GHC.Types.GREInfo.ConFieldInfo
instance GHC.Classes.Eq GHC.Types.GREInfo.ConInfo
instance GHC.Classes.Eq GHC.Types.GREInfo.ConLikeInfo
instance GHC.Classes.Eq GHC.Types.GREInfo.ConLikeName
instance GHC.Classes.Eq GHC.Types.GREInfo.RecFieldInfo
instance Control.DeepSeq.NFData GHC.Types.GREInfo.ConFieldInfo
instance Control.DeepSeq.NFData GHC.Types.GREInfo.ConInfo
instance Control.DeepSeq.NFData GHC.Types.GREInfo.ConLikeInfo
instance Control.DeepSeq.NFData GHC.Types.GREInfo.ConLikeName
instance Control.DeepSeq.NFData GHC.Types.GREInfo.GREInfo
instance Control.DeepSeq.NFData GHC.Types.GREInfo.RecFieldInfo
instance GHC.Utils.Outputable.OutputableBndr GHC.Types.GREInfo.ConLikeName
instance GHC.Utils.Outputable.Outputable GHC.Types.GREInfo.ConFieldInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.GREInfo.ConInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.GREInfo.ConLikeInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.GREInfo.ConLikeName
instance GHC.Utils.Outputable.Outputable GHC.Types.GREInfo.GREInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.GREInfo.RecFieldInfo
instance GHC.Types.Unique.Uniquable GHC.Types.GREInfo.ConLikeName

module GHC.Types.Fixity.Env

-- | Fixity environment mapping names to their fixities
type FixityEnv = NameEnv FixItem

-- | Fixity information for an <a>Name</a>. We keep the OccName in the
--   range so that we can generate an interface from it
data FixItem
FixItem :: OccName -> Fixity -> FixItem
emptyFixityEnv :: FixityEnv
lookupFixity :: FixityEnv -> Name -> Fixity

-- | Creates cached lookup for the <tt>mi_fix_fn</tt> field of
--   <tt>ModIface</tt>
mkIfaceFixCache :: [(OccName, Fixity)] -> OccName -> Maybe Fixity
emptyIfaceFixCache :: OccName -> Maybe Fixity
instance GHC.Utils.Outputable.Outputable GHC.Types.Fixity.Env.FixItem

module GHC.Types.CostCentre

-- | A Cost Centre is a single <tt>{-# SCC #-}</tt> annotation.
data CostCentre
NormalCC :: CCFlavour -> CcName -> Module -> SrcSpan -> CostCentre

-- | Two cost centres may have the same name and module but different
--   SrcSpans, so we need a way to distinguish them easily and give them
--   different object-code labels. So every CostCentre has an associated
--   flavour that indicates how it was generated, and flavours that allow
--   multiple instances of the same name and module have a deterministic
--   0-based index.
[cc_flavour] :: CostCentre -> CCFlavour

-- | Name of the cost centre itself
[cc_name] :: CostCentre -> CcName

-- | Name of module defining this CC.
[cc_mod] :: CostCentre -> Module
[cc_loc] :: CostCentre -> SrcSpan
AllCafsCC :: Module -> SrcSpan -> CostCentre

-- | Name of module defining this CC.
[cc_mod] :: CostCentre -> Module
[cc_loc] :: CostCentre -> SrcSpan
type CcName = FastString

-- | The flavour of a cost centre.
--   
--   Index fields represent 0-based indices giving source-code ordering of
--   centres with the same module, name, and flavour.
data CCFlavour
mkCafFlavour :: CCFlavour
mkExprCCFlavour :: CostCentreIndex -> CCFlavour
mkDeclCCFlavour :: CostCentreIndex -> CCFlavour
mkHpcCCFlavour :: CostCentreIndex -> CCFlavour
mkLateCCFlavour :: CostCentreIndex -> CCFlavour
mkCallerCCFlavour :: CostCentreIndex -> CCFlavour
getAllCAFsCC :: Module -> (CostCentre, CostCentreStack)
pprCostCentre :: IsLine doc => CostCentre -> doc

-- | A Cost Centre Stack is something that can be attached to a closure.
--   This is either:
--   
--   <ul>
--   <li>the current cost centre stack (CCCS)</li>
--   <li>a pre-defined cost centre stack (there are several pre-defined
--   CCSs, see below).</li>
--   </ul>
data CostCentreStack
pprCostCentreStack :: IsLine doc => CostCentreStack -> doc
type CollectedCCs = ([CostCentre], [CostCentreStack])
emptyCollectedCCs :: CollectedCCs
collectCC :: CostCentre -> CostCentreStack -> CollectedCCs -> CollectedCCs
currentCCS :: CostCentreStack
dontCareCCS :: CostCentreStack
isCurrentCCS :: CostCentreStack -> Bool
maybeSingletonCCS :: CostCentreStack -> Maybe CostCentre
mkUserCC :: FastString -> Module -> SrcSpan -> CCFlavour -> CostCentre
mkAutoCC :: Id -> Module -> CostCentre
mkAllCafsCC :: Module -> SrcSpan -> CostCentre
mkSingletonCCS :: CostCentre -> CostCentreStack
isCafCCS :: CostCentreStack -> Bool
isCafCC :: CostCentre -> Bool

-- | Is this a cost-centre which records scc counts
isSccCountCC :: CostCentre -> Bool

-- | Is this a cost-centre which can be sccd ?
sccAbleCC :: CostCentre -> Bool
ccFromThisModule :: CostCentre -> Module -> Bool

-- | Print a flavour in Core
pprCostCentreCore :: CostCentre -> SDoc
costCentreUserName :: CostCentre -> String
costCentreUserNameFS :: CostCentre -> FastString
costCentreSrcSpan :: CostCentre -> SrcSpan
cmpCostCentre :: CostCentre -> CostCentre -> Ordering
instance GHC.Utils.Binary.Binary GHC.Types.CostCentre.CCFlavour
instance GHC.Utils.Binary.Binary GHC.Types.CostCentre.CostCentre
instance GHC.Internal.Data.Data.Data GHC.Types.CostCentre.CCFlavour
instance GHC.Internal.Data.Data.Data GHC.Types.CostCentre.CostCentre
instance GHC.Internal.Data.Data.Data GHC.Types.CostCentre.IndexedCCFlavour
instance GHC.Internal.Enum.Enum GHC.Types.CostCentre.IndexedCCFlavour
instance GHC.Classes.Eq GHC.Types.CostCentre.CCFlavour
instance GHC.Classes.Eq GHC.Types.CostCentre.CostCentre
instance GHC.Classes.Eq GHC.Types.CostCentre.CostCentreStack
instance GHC.Classes.Eq GHC.Types.CostCentre.IndexedCCFlavour
instance GHC.Classes.Ord GHC.Types.CostCentre.CCFlavour
instance GHC.Classes.Ord GHC.Types.CostCentre.CostCentre
instance GHC.Classes.Ord GHC.Types.CostCentre.CostCentreStack
instance GHC.Classes.Ord GHC.Types.CostCentre.IndexedCCFlavour
instance GHC.Utils.Outputable.Outputable GHC.Types.CostCentre.CostCentre
instance GHC.Utils.Outputable.Outputable GHC.Types.CostCentre.CostCentreStack


-- | Types related to late cost center insertion
module GHC.Core.LateCC.Types

-- | Late cost center insertion configuration.
--   
--   Specifies whether cost centers are added to overloaded function call
--   sites and/or top-level bindings, and which top-level bindings they are
--   added to. Also holds the cost center insertion environment.
data LateCCConfig
LateCCConfig :: !LateCCBindSpec -> !Bool -> !LateCCEnv -> LateCCConfig
[lateCCConfig_whichBinds] :: LateCCConfig -> !LateCCBindSpec
[lateCCConfig_overloadedCalls] :: LateCCConfig -> !Bool
[lateCCConfig_env] :: LateCCConfig -> !LateCCEnv

-- | The types of top-level bindings we support adding cost centers to.
data LateCCBindSpec
LateCCNone :: LateCCBindSpec
LateCCBinds :: LateCCBindSpec
LateCCOverloadedBinds :: LateCCBindSpec

-- | Late cost centre insertion environment
data LateCCEnv
LateCCEnv :: !Module -> Maybe FastString -> !Bool -> !Bool -> LateCCEnv

-- | Current module
[lateCCEnv_module] :: LateCCEnv -> !Module

-- | Current file, if we have one
[lateCCEnv_file] :: LateCCEnv -> Maybe FastString

-- | Whether the inserted cost centers should count entries
[lateCCEnv_countEntries] :: LateCCEnv -> !Bool

-- | Whether to collect the cost centres we insert. See Note [Collecting
--   late cost centres]
[lateCCEnv_collectCCs] :: LateCCEnv -> !Bool

-- | Late cost centre insertion state, indexed by some extra state type
--   that an insertion method may require.
data LateCCState s
LateCCState :: !Set CostCentre -> !CostCentreState -> !s -> LateCCState s

-- | Cost centres that have been inserted
[lateCCState_ccs] :: LateCCState s -> !Set CostCentre

-- | Per-module state tracking for cost centre indices
[lateCCState_ccState] :: LateCCState s -> !CostCentreState
[lateCCState_extra] :: LateCCState s -> !s

-- | The empty late cost centre insertion state
initLateCCState :: s -> LateCCState s

-- | Late cost centre insertion monad
type LateCCM s = ReaderT LateCCEnv State LateCCState s

module GHC.Types.Avail

-- | A collection of <a>AvailInfo</a> - several things that are "available"
type Avails = [AvailInfo]

-- | Records what things are "available", i.e. in scope
data AvailInfo

-- | An ordinary identifier in scope, or a field label without a parent
--   type (see Note [Representing pattern synonym fields in AvailInfo]).
Avail :: Name -> AvailInfo

-- | A type or class in scope
--   
--   The <b>AvailTC Invariant</b>: If the type or class is itself to be in
--   scope, it must be <i>first</i> in this list. Thus, typically:
--   
--   <pre>
--   AvailTC Eq [Eq, ==, \/=]
--   </pre>
AvailTC :: Name -> [Name] -> AvailInfo
availsToNameSet :: [AvailInfo] -> NameSet
availsToNameEnv :: [AvailInfo] -> NameEnv AvailInfo

-- | Does this <a>AvailInfo</a> export the parent decl? This depends on the
--   invariant that the parent is first if it appears at all.
availExportsDecl :: AvailInfo -> Bool

-- | Just the main name made available, i.e. not the available pieces of
--   type or class brought into scope by the <a>AvailInfo</a>
availName :: AvailInfo -> Name

-- | Names and fields made available by the availability information.
availNames :: AvailInfo -> [Name]

-- | Names and fields made available by the availability information, other
--   than the main decl itself.
availSubordinateNames :: AvailInfo -> [Name]

-- | Compare lexicographically
stableAvailCmp :: AvailInfo -> AvailInfo -> Ordering
plusAvail :: AvailInfo -> AvailInfo -> AvailInfo

-- | trims an <a>AvailInfo</a> to keep only a single name
trimAvail :: AvailInfo -> Name -> AvailInfo

-- | filters an <a>AvailInfo</a> by the given predicate
filterAvail :: (Name -> Bool) -> AvailInfo -> [AvailInfo] -> [AvailInfo]

-- | filters <a>AvailInfo</a>s by the given predicate
filterAvails :: (Name -> Bool) -> [AvailInfo] -> [AvailInfo]

-- | Combines <a>AvailInfo</a>s from the same family <tt>avails</tt> may
--   have several items with the same availName E.g import Ix( Ix(..),
--   index ) will give Ix(Ix,index,range) and Ix(index) We want to combine
--   these; plusAvail does that
nubAvails :: [AvailInfo] -> [AvailInfo]

-- | Sort <a>Avails</a>/<a>AvailInfo</a>s
sortAvails :: Avails -> DetOrdAvails

-- | Occurrences of Avails in interface files must be deterministically
--   ordered to guarantee interface file determinism.
--   
--   We guarantee a deterministic order by either using the order
--   explicitly given by the user (e.g. in an explicit constructor export
--   list) or instead by sorting the avails with <a>sortAvails</a>.
newtype DetOrdAvails
DefinitelyDeterministicAvails :: Avails -> DetOrdAvails

-- | It's always safe to match on <a>DetOrdAvails</a>
pattern DetOrdAvails :: Avails -> DetOrdAvails
instance GHC.Utils.Binary.Binary GHC.Types.Avail.AvailInfo
instance GHC.Utils.Binary.Binary GHC.Types.Avail.DetOrdAvails
instance GHC.Internal.Data.Data.Data GHC.Types.Avail.AvailInfo
instance Control.DeepSeq.NFData GHC.Types.Avail.AvailInfo
instance Control.DeepSeq.NFData GHC.Types.Avail.DetOrdAvails
instance GHC.Utils.Outputable.Outputable GHC.Types.Avail.AvailInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Avail.DetOrdAvails


-- | GHC uses several kinds of name internally:
--   
--   <ul>
--   <li><a>OccName</a>: see
--   <a>GHC.Types.Name.Occurrence#name_types</a></li>
--   <li><a>RdrName</a> is the type of names that come directly from the
--   parser. They have not yet had their scoping and binding resolved by
--   the renamer and can be thought of to a first approximation as an
--   <a>OccName</a> with an optional module qualifier</li>
--   <li><a>Name</a>: see <a>GHC.Types.Name#name_types</a></li>
--   <li><a>Id</a>: see <a>GHC.Types.Id#name_types</a></li>
--   <li><a>Var</a>: see <a>GHC.Types.Var#name_types</a></li>
--   </ul>
module GHC.Types.Name.Reader

-- | Reader Name
--   
--   Do not use the data constructors of RdrName directly: prefer the
--   family of functions that creates them, such as <a>mkRdrUnqual</a>
--   
--   <ul>
--   <li>Note: A Located RdrName will only have API Annotations if it is a
--   compound one, e.g.</li>
--   </ul>
--   
--   <pre>
--   `bar`
--   ( ~ )
--   </pre>
data RdrName

-- | Unqualified name
--   
--   Used for ordinary, unqualified occurrences, e.g. <tt>x</tt>,
--   <tt>y</tt> or <tt>Foo</tt>. Create such a <a>RdrName</a> with
--   <a>mkRdrUnqual</a>
Unqual :: OccName -> RdrName

-- | Qualified name
--   
--   A qualified name written by the user in <i>source</i> code. The module
--   isn't necessarily the module where the thing is defined; just the one
--   from which it is imported. Examples are <tt>Bar.x</tt>, <tt>Bar.y</tt>
--   or <tt>Bar.Foo</tt>. Create such a <a>RdrName</a> with
--   <a>mkRdrQual</a>
Qual :: ModuleName -> OccName -> RdrName

-- | Original name
--   
--   An original name; the module is the <i>defining</i> module. This is
--   used when GHC generates code that will be fed into the renamer (e.g.
--   from deriving clauses), but where we want to say "Use Prelude.map
--   dammit". One of these can be created with <a>mkOrig</a>
Orig :: Module -> OccName -> RdrName

-- | Exact name
--   
--   We know exactly the <a>Name</a>. This is used:
--   
--   <ol>
--   <li>When the parser parses built-in syntax like <tt>[]</tt> and
--   <tt>(,)</tt>, but wants a <a>RdrName</a> from it</li>
--   <li>By Template Haskell, when TH has generated a unique name</li>
--   </ol>
--   
--   Such a <a>RdrName</a> can be created by using <a>getRdrName</a> on a
--   <a>Name</a>
Exact :: Name -> RdrName
mkRdrUnqual :: OccName -> RdrName
mkRdrQual :: ModuleName -> OccName -> RdrName
mkUnqual :: NameSpace -> FastString -> RdrName
mkVarUnqual :: FastString -> RdrName

-- | Make a qualified <a>RdrName</a> in the given namespace and where the
--   <a>ModuleName</a> and the <a>OccName</a> are taken from the first and
--   second elements of the tuple respectively
mkQual :: NameSpace -> (FastString, FastString) -> RdrName
mkOrig :: Module -> OccName -> RdrName
nameRdrName :: Name -> RdrName
getRdrName :: NamedThing thing => thing -> RdrName
rdrNameOcc :: RdrName -> OccName
rdrNameSpace :: RdrName -> NameSpace
demoteRdrName :: RdrName -> Maybe RdrName
demoteRdrNameTv :: RdrName -> Maybe RdrName
promoteRdrName :: RdrName -> Maybe RdrName
isRdrDataCon :: RdrName -> Bool
isRdrTyVar :: RdrName -> Bool
isRdrTc :: RdrName -> Bool
isQual :: RdrName -> Bool
isQual_maybe :: RdrName -> Maybe (ModuleName, OccName)
isUnqual :: RdrName -> Bool
isOrig :: RdrName -> Bool
isOrig_maybe :: RdrName -> Maybe (Module, OccName)
isExact :: RdrName -> Bool
isExact_maybe :: RdrName -> Maybe Name
isSrcRdrName :: RdrName -> Bool

-- | Local Reader Environment See Note [LocalRdrEnv]
data LocalRdrEnv
emptyLocalRdrEnv :: LocalRdrEnv
extendLocalRdrEnv :: LocalRdrEnv -> Name -> LocalRdrEnv
extendLocalRdrEnvList :: LocalRdrEnv -> [Name] -> LocalRdrEnv
lookupLocalRdrEnv :: LocalRdrEnv -> RdrName -> Maybe Name
lookupLocalRdrOcc :: LocalRdrEnv -> OccName -> Maybe Name
elemLocalRdrEnv :: RdrName -> LocalRdrEnv -> Bool
inLocalRdrEnvScope :: Name -> LocalRdrEnv -> Bool
localRdrEnvElts :: LocalRdrEnv -> [Name]
minusLocalRdrEnv :: LocalRdrEnv -> OccEnv a -> LocalRdrEnv
minusLocalRdrEnvList :: LocalRdrEnv -> [OccName] -> LocalRdrEnv

-- | Parametrises <a>GlobalRdrEnv</a> over the presence or absence of
--   <a>GREInfo</a>.
--   
--   See Note [IfGlobalRdrEnv].
type GlobalRdrEnvX info = OccEnv [GlobalRdrEltX info]

-- | Global Reader Environment
--   
--   Keyed by <a>OccName</a>; when looking up a qualified name we look up
--   the <a>OccName</a> part, and then check the <tt>Provenance</tt> to see
--   if the appropriate qualification is valid. This saves routinely
--   doubling the size of the env by adding both qualified and unqualified
--   names to the domain.
--   
--   The list in the codomain is required because there may be name clashes
--   These only get reported on lookup, not on construction
--   
--   INVARIANT 1: All the members of the list have distinct <a>gre_name</a>
--   fields; that is, no duplicate Names
--   
--   INVARIANT 2: Imported provenance =&gt; Name is an ExternalName However
--   LocalDefs can have an InternalName. This happens only when
--   type-checking a [d| ... |] Template Haskell quotation; see this note
--   in GHC.Rename.Names Note [Top-level Names in Template Haskell decl
--   quotes]
--   
--   INVARIANT 3: If the GlobalRdrEnv maps [occ -&gt; gre], then greOccName
--   gre = occ
type GlobalRdrEnv = GlobalRdrEnvX GREInfo

-- | A <a>GlobalRdrEnv</a> in which the <a>GlobalRdrElt</a>s don't have any
--   <a>GREInfo</a> attached to them. This is useful to avoid space leaks,
--   see Note [IfGlobalRdrEnv].
type IfGlobalRdrEnv = GlobalRdrEnvX ()
emptyGlobalRdrEnv :: GlobalRdrEnvX info
mkGlobalRdrEnv :: [GlobalRdrElt] -> GlobalRdrEnv
plusGlobalRdrEnv :: GlobalRdrEnv -> GlobalRdrEnv -> GlobalRdrEnv
extendGlobalRdrEnv :: GlobalRdrEnv -> GlobalRdrElt -> GlobalRdrEnv
greOccName :: GlobalRdrEltX info -> OccName
pprGlobalRdrEnv :: Bool -> GlobalRdrEnv -> SDoc
globalRdrEnvElts :: GlobalRdrEnvX info -> [GlobalRdrEltX info]
globalRdrEnvLocal :: GlobalRdrEnvX info -> GlobalRdrEnvX info

-- | When looking up GREs, we may or may not want to include fields that
--   were defined in modules with <tt>NoFieldSelectors</tt> enabled. See
--   Note [NoFieldSelectors].
data FieldsOrSelectors

-- | Include normal names, and fields with selectors, but ignore fields
--   without selectors.
WantNormal :: FieldsOrSelectors

-- | Include normal names and all fields (regardless of whether they have
--   selectors).
WantBoth :: FieldsOrSelectors

-- | Include only fields, with or without selectors, ignoring any
--   non-fields in scope.
WantField :: FieldsOrSelectors
filterFieldGREs :: FieldsOrSelectors -> [GlobalRdrElt] -> [GlobalRdrElt]
allowGRE :: FieldsOrSelectors -> GlobalRdrElt -> Bool

-- | What should we look up in a <a>GlobalRdrEnv</a>? Should we only look
--   up names with the exact same <a>OccName</a>, or do we allow different
--   <a>NameSpace</a>s?
--   
--   Depending on the answer, we might need more or less information from
--   the <a>GlobalRdrEnv</a>, e.g. if we want to include matching record
--   fields we need to know if the corresponding record fields define field
--   selectors, for which we need to consult the <a>GREInfo</a>. This is
--   why this datatype is a GADT.
--   
--   See Note [IfGlobalRdrEnv].
data LookupGRE info

-- | Look for this specific <a>OccName</a>, with the exact same
--   <a>NameSpace</a>, in the <a>GlobalRdrEnv</a>.
[LookupOccName] :: forall info. OccName -> WhichGREs info -> LookupGRE info

-- | Look up the <a>OccName</a> of this <a>RdrName</a> in the
--   <a>GlobalRdrEnv</a>, filtering out those whose qualification matches
--   that of the <a>RdrName</a>.
--   
--   Lookup returns an empty result for <a>Exact</a> or <a>Orig</a>
--   <a>RdrName</a>s.
[LookupRdrName] :: forall info. RdrName -> WhichGREs info -> LookupGRE info

-- | Look for <a>GRE</a>s with the same unique as the given <a>Name</a> in
--   the <a>GlobalRdrEnv</a>.
[LookupExactName] :: forall info. Name -> Bool -> LookupGRE info

-- | Look up children <a>GlobalRdrElt</a>s with a given <a>Parent</a>.
[LookupChildren] :: forall info. OccName -> LookupChild -> LookupGRE info

-- | Look something up in the Global Reader Environment.
--   
--   The <a>LookupGRE</a> argument specifies what to look up, and in
--   particular whether there should there be any lee-way if the
--   <a>NameSpace</a>s don't exactly match.
lookupGRE :: GlobalRdrEnvX info -> LookupGRE info -> [GlobalRdrEltX info]

-- | How should we look up in a <a>GlobalRdrEnv</a>? Which
--   <a>NameSpace</a>s are considered relevant for a given lookup?
data WhichGREs info

-- | Only consider <a>GlobalRdrElt</a>s with the exact <a>NameSpace</a> we
--   look up.
[SameNameSpace] :: forall info. WhichGREs info

-- | Allow <a>GlobalRdrElt</a>s with different <a>NameSpace</a>s, e.g.
--   allow looking up record fields from the variable <a>NameSpace</a>, or
--   looking up a <a>TyCon</a> from the data constructor <a>NameSpace</a>.
[RelevantGREs] :: !FieldsOrSelectors -> !Bool -> !Bool -> WhichGREs GREInfo

-- | Look up as many possibly relevant <a>GlobalRdrElt</a>s as possible.
pattern AllRelevantGREs :: WhichGREs GREInfo

-- | Look up relevant GREs, taking into account the interaction between the
--   variable and field <a>NameSpace</a>s as determined by the
--   <tt>FieldsOrSelector</tt> argument.
pattern RelevantGREsFOS :: FieldsOrSelectors -> WhichGREs GREInfo

-- | After looking up something with the given <a>NameSpace</a>, is the
--   resulting <a>GlobalRdrElt</a> we have obtained relevant, according to
--   the <a>RelevantGREs</a> specification of which <a>NameSpace</a>s are
--   relevant?
greIsRelevant :: WhichGREs GREInfo -> NameSpace -> GlobalRdrElt -> Bool
data LookupChild
LookupChild :: Name -> Bool -> Bool -> LookupChild

-- | the parent we are looking up children of
[wantedParent] :: LookupChild -> Name

-- | for type constructors, should we look in the data constructor
--   namespace first?
[lookupDataConFirst] :: LookupChild -> Bool

-- | should we prioritise getting the right <a>Parent</a>?
--   
--   <ul>
--   <li><tt>True</tt>: prioritise getting the right <a>Parent</a></li>
--   <li><tt>False</tt>: prioritise getting the right <a>NameSpace</a></li>
--   </ul>
--   
--   See Note [childGREPriority].
[prioritiseParent] :: LookupChild -> Bool

-- | Look for precisely this <a>Name</a> in the environment, in the <b>same
--   <a>NameSpace</a></b> as the <a>Name</a>.
--   
--   This tests whether it is in scope, ignoring anything else that might
--   be in scope which doesn't have the same <a>Unique</a>.
lookupGRE_Name :: Outputable info => GlobalRdrEnvX info -> Name -> Maybe (GlobalRdrEltX info)

-- | Look for a particular record field selector in the environment.
lookupGRE_FieldLabel :: GlobalRdrEnv -> FieldLabel -> Maybe FieldGlobalRdrElt
getGRE_NameQualifier_maybes :: GlobalRdrEnv -> Name -> [Maybe [ModuleName]]

-- | Apply a transformation function to the GREs for these OccNames
transformGREs :: (GlobalRdrElt -> GlobalRdrElt) -> [OccName] -> GlobalRdrEnv -> GlobalRdrEnv

-- | Takes a list of GREs which have the right OccName <tt>x</tt> Pick
--   those GREs that are in scope * Qualified, as <a>x</a> if want_qual is
--   Qual M _ * Unqualified, as <tt>x</tt> if want_unqual is Unqual _
--   
--   Return each such GRE, with its ImportSpecs filtered, to reflect how it
--   is in scope qualified or unqualified respectively. See Note [GRE
--   filtering]
pickGREs :: RdrName -> [GlobalRdrEltX info] -> [GlobalRdrEltX info]

-- | Pick GREs that are in scope *both* qualified *and* unqualified Return
--   each GRE that is, as a pair (qual_gre, unqual_gre) These two GREs are
--   the original GRE with imports filtered to express how it is in scope
--   qualified an unqualified respectively
--   
--   Used only for the 'module M' item in export list; see
--   <a>exports_from_avail</a>
pickGREsModExp :: ModuleName -> [GlobalRdrEltX info] -> [(GlobalRdrEltX info, GlobalRdrEltX info)]
availFromGRE :: GlobalRdrEltX info -> AvailInfo
greRdrNames :: GlobalRdrEltX info -> [RdrName]
greSrcSpan :: Outputable info => GlobalRdrEltX info -> SrcSpan
greQualModName :: Outputable info => GlobalRdrEltX info -> ModuleName

-- | Takes a list of distinct GREs and folds them into AvailInfos. This is
--   more efficient than mapping each individual GRE to an AvailInfo and
--   then folding using <a>plusAvail</a>, but needs the uniqueness
--   assumption.
gresToAvailInfo :: [GlobalRdrEltX info] -> [AvailInfo]

-- | The module in which the name pointed to by the GRE is defined.
greDefinitionModule :: GlobalRdrEltX info -> Maybe Module

-- | The SrcSpan of the name pointed to by the GRE.
greDefinitionSrcSpan :: GlobalRdrEltX info -> SrcSpan

-- | Returns the field label of this GRE, if it has one
greFieldLabel_maybe :: GlobalRdrElt -> Maybe FieldLabel

-- | Global Reader Element
--   
--   Something in scope in the renamer; usually a member of the
--   <a>GlobalRdrEnv</a>. See Note [GlobalRdrElt provenance].
--   
--   Why do we parametrise over the <a>gre_info</a> field? See Note
--   [IfGlobalRdrEnv].
data GlobalRdrEltX info
GRE :: !Name -> !Parent -> !Bool -> !Bag ImportSpec -> info -> GlobalRdrEltX info
[gre_name] :: GlobalRdrEltX info -> !Name

-- | See Note [Parents]
[gre_par] :: GlobalRdrEltX info -> !Parent

-- | True <a>=</a> the thing was defined locally
[gre_lcl] :: GlobalRdrEltX info -> !Bool

-- | In scope through these imports See Note [GlobalRdrElt provenance] for
--   the relation between gre_lcl and gre_imp.
[gre_imp] :: GlobalRdrEltX info -> !Bag ImportSpec

-- | Information the renamer knows about this particular <a>Name</a>.
--   
--   Careful about forcing this field! Forcing it can trigger the loading
--   of interface files.
--   
--   Note [Retrieving the GREInfo from interfaces] in GHC.Types.GREInfo.
[gre_info] :: GlobalRdrEltX info -> info

-- | Global Reader Element
--   
--   Something in scope in the renamer; usually a member of the
--   <a>GlobalRdrEnv</a>. See Note [GlobalRdrElt provenance].
type GlobalRdrElt = GlobalRdrEltX GREInfo

-- | A <a>GlobalRdrElt</a> in which we stripped out the <a>GREInfo</a>
--   field, in order to avoid space leaks.
--   
--   See Note [IfGlobalRdrEnv].
type IfGlobalRdrElt = GlobalRdrEltX ()

-- | A <a>FieldGlobalRdrElt</a> is a <a>GlobalRdrElt</a> in which the
--   <a>gre_info</a> field is <a>IAmRecField</a>.
type FieldGlobalRdrElt = GlobalRdrElt
greName :: GlobalRdrEltX info -> Name
greNameSpace :: GlobalRdrEltX info -> NameSpace
greParent :: GlobalRdrEltX info -> Parent
greInfo :: GlobalRdrElt -> GREInfo
plusGRE :: GlobalRdrElt -> GlobalRdrElt -> GlobalRdrElt
insertGRE :: GlobalRdrElt -> [GlobalRdrElt] -> [GlobalRdrElt]

-- | Drop all <a>GREInfo</a> fields in a <a>GlobalRdrEnv</a> in order to
--   avoid space leaks. See Note [Forcing GREInfo] in GHC.Types.GREInfo.
forceGlobalRdrEnv :: GlobalRdrEnvX info -> IfGlobalRdrEnv

-- | Hydrate a previously dehydrated <a>GlobalRdrEnv</a>, by (lazily!)
--   looking up the <a>GREInfo</a> using the provided function.
--   
--   See Note [Forcing GREInfo] in GHC.Types.GREInfo.
hydrateGlobalRdrEnv :: (Name -> IO info) -> GlobalRdrEnvX noInfo -> GlobalRdrEnvX info

-- | Is this <a>GlobalRdrElt</a> defined locally?
isLocalGRE :: GlobalRdrEltX info -> Bool

-- | Is this <a>GlobalRdrElt</a> imported?
--   
--   Not just the negation of <a>isLocalGRE</a>, because it might be an
--   Exact or Orig name reference. See Note [GlobalRdrElt provenance].
isImportedGRE :: GlobalRdrEltX info -> Bool

-- | Is this a record field GRE?
--   
--   Important: does <i>not</i> consult the <tt>GreInfo</tt> field.
isRecFldGRE :: GlobalRdrEltX info -> Bool
fieldGREInfo :: HasDebugCallStack => FieldGlobalRdrElt -> RecFieldInfo

-- | Is this a record field defined with DuplicateRecordFields?
isDuplicateRecFldGRE :: GlobalRdrElt -> Bool

-- | Is this a record field defined with NoFieldSelectors? (See Note
--   [NoFieldSelectors] in GHC.Rename.Env)
isNoFieldSelectorGRE :: GlobalRdrElt -> Bool

-- | Is this a record field defined with FieldSelectors? (See Note
--   [NoFieldSelectors] in GHC.Rename.Env)
isFieldSelectorGRE :: GlobalRdrElt -> Bool

-- | Test if an unqualified version of this thing would be in scope
unQualOK :: GlobalRdrEltX info -> Bool

-- | Is in scope qualified with the given module?
qualSpecOK :: ModuleName -> ImportSpec -> Bool

-- | Is in scope unqualified?
unQualSpecOK :: ImportSpec -> Bool

-- | Print out one place where the name was define/imported (With
--   -dppr-debug, print them all)
pprNameProvenance :: GlobalRdrEltX info -> SDoc
mkGRE :: (Name -> Maybe ImportSpec) -> GREInfo -> Parent -> Name -> GlobalRdrElt
mkExactGRE :: Name -> GREInfo -> GlobalRdrElt
mkLocalGRE :: GREInfo -> Parent -> Name -> GlobalRdrElt
mkLocalVanillaGRE :: Parent -> Name -> GlobalRdrElt

-- | Create a local <a>GlobalRdrElt</a> for a <a>TyCon</a>.
mkLocalTyConGRE :: TyConFlavour Name -> Name -> GlobalRdrElt
mkLocalConLikeGRE :: Parent -> (ConLikeName, ConInfo) -> GlobalRdrElt
mkLocalFieldGREs :: Parent -> [(ConLikeName, ConInfo)] -> [GlobalRdrElt]
gresToNameSet :: [GlobalRdrEltX info] -> NameSet

-- | <tt>greClashesWith new_gre old_gre</tt> computes whether
--   <tt>new_gre</tt> clashes with <tt>old_gre</tt> (assuming they both
--   have the same underlying <a>occNameFS</a>).
greClashesWith :: GlobalRdrElt -> GlobalRdrElt -> Bool
shadowNames :: Bool -> GlobalRdrEnv -> GlobalRdrEnv -> GlobalRdrEnv

-- | The <a>Name</a> of a <a>ConLike</a>.
--   
--   Useful when we are in the renamer and don't yet have a full
--   <tt>DataCon</tt> or <tt>PatSyn</tt> to hand.
data ConLikeName
DataConName :: !Name -> ConLikeName
[conLikeName_Name] :: ConLikeName -> !Name
PatSynName :: !Name -> ConLikeName
[conLikeName_Name] :: ConLikeName -> !Name

-- | Information about a <a>Name</a> that is pertinent to the renamer.
--   
--   See Note [GREInfo]
data GREInfo

-- | No particular information... e.g. a function
Vanilla :: GREInfo

-- | An unbound GRE... could be anything
UnboundGRE :: GREInfo

-- | <tt>TyCon</tt>
IAmTyCon :: !TyConFlavour Name -> GREInfo

-- | <a>ConLike</a>
IAmConLike :: !ConInfo -> GREInfo
IAmRecField :: !RecFieldInfo -> GREInfo
data RecFieldInfo
RecFieldInfo :: !FieldLabel -> !UniqSet ConLikeName -> RecFieldInfo
[recFieldLabel] :: RecFieldInfo -> !FieldLabel

-- | The constructors which have this field label. Always non-empty.
--   
--   NB: these constructors will always share a single parent, as the field
--   label disambiguates between parents in the presence of duplicate
--   record fields.
[recFieldCons] :: RecFieldInfo -> !UniqSet ConLikeName
plusGREInfo :: GREInfo -> GREInfo -> GREInfo
recFieldConLike_maybe :: HasDebugCallStack => GlobalRdrElt -> Maybe ConInfo
recFieldInfo_maybe :: HasDebugCallStack => GlobalRdrElt -> Maybe RecFieldInfo
fieldGRE_maybe :: GlobalRdrElt -> Maybe FieldGlobalRdrElt
fieldGRELabel :: HasDebugCallStack => FieldGlobalRdrElt -> FieldLabel

-- | See Note [Parents]
data Parent
NoParent :: Parent
ParentIs :: !Name -> Parent
[par_is] :: Parent -> !Name
greParent_maybe :: GlobalRdrEltX info -> Maybe Name
mkParent :: Name -> AvailInfo -> Parent
availParent :: AvailInfo -> Parent

-- | Import Specification
--   
--   The <a>ImportSpec</a> of something says how it came to be imported
--   It's quite elaborate so that we can give accurate unused-name
--   warnings.
data ImportSpec
ImpSpec :: !ImpDeclSpec -> !ImpItemSpec -> ImportSpec
[is_decl] :: ImportSpec -> !ImpDeclSpec
[is_item] :: ImportSpec -> !ImpItemSpec

-- | Import Declaration Specification
--   
--   Describes a particular import declaration and is shared among all the
--   <tt>Provenance</tt>s for that decl
data ImpDeclSpec
ImpDeclSpec :: !Module -> !ModuleName -> !PkgQual -> !Bool -> !SrcSpan -> !IsBootInterface -> ImpDeclSpec

-- | Module imported, e.g. <tt>import Muggle</tt> Note the <tt>Muggle</tt>
--   may well not be the defining module for this thing!
[is_mod] :: ImpDeclSpec -> !Module

-- | Import alias, e.g. from <tt>as M</tt> (or <tt>Muggle</tt> if there is
--   no <tt>as</tt> clause)
[is_as] :: ImpDeclSpec -> !ModuleName

-- | Was this a package import?
[is_pkg_qual] :: ImpDeclSpec -> !PkgQual

-- | Was this import qualified?
[is_qual] :: ImpDeclSpec -> !Bool

-- | The location of the entire import declaration
[is_dloc] :: ImpDeclSpec -> !SrcSpan

-- | Was this a SOURCE import?
[is_isboot] :: ImpDeclSpec -> !IsBootInterface

-- | Import Item Specification
--   
--   Describes import info a particular Name
data ImpItemSpec

-- | The import had no import list, or had a hiding list
ImpAll :: ImpItemSpec

-- | The import had an import list. The <a>is_explicit</a> field is
--   <tt>True</tt> iff the thing was named <i>explicitly</i> in the import
--   specs rather than being imported as part of a "..." group. Consider:
--   
--   <pre>
--   import C( T(..) )
--   </pre>
--   
--   Here the constructors of <tt>T</tt> are not named explicitly; only
--   <tt>T</tt> is named explicitly.
ImpSome :: !Bool -> !SrcSpan -> ImpItemSpec
[is_explicit] :: ImpItemSpec -> !Bool
[is_iloc] :: ImpItemSpec -> !SrcSpan
importSpecLoc :: ImportSpec -> SrcSpan
importSpecModule :: ImportSpec -> ModuleName
isExplicitItem :: ImpItemSpec -> Bool
bestImport :: NonEmpty ImportSpec -> ImportSpec

-- | Indicate if the given name is the "@" operator
opIsAt :: RdrName -> Bool
instance GHC.Internal.Data.Data.Data info => GHC.Internal.Data.Data.Data (GHC.Types.Name.Reader.GlobalRdrEltX info)
instance GHC.Internal.Data.Data.Data GHC.Types.Name.Reader.ImpDeclSpec
instance GHC.Internal.Data.Data.Data GHC.Types.Name.Reader.ImpItemSpec
instance GHC.Internal.Data.Data.Data GHC.Types.Name.Reader.ImportSpec
instance GHC.Internal.Data.Data.Data GHC.Types.Name.Reader.Parent
instance GHC.Internal.Data.Data.Data GHC.Types.Name.Reader.RdrName
instance GHC.Classes.Eq GHC.Types.Name.Reader.FieldsOrSelectors
instance GHC.Classes.Eq GHC.Types.Name.Reader.ImpDeclSpec
instance GHC.Classes.Eq GHC.Types.Name.Reader.ImpItemSpec
instance GHC.Classes.Eq GHC.Types.Name.Reader.ImportSpec
instance GHC.Classes.Eq GHC.Types.Name.Reader.Parent
instance GHC.Classes.Eq GHC.Types.Name.Reader.RdrName
instance GHC.Types.Name.Occurrence.HasOccName (GHC.Types.Name.Reader.GlobalRdrEltX info)
instance GHC.Types.Name.Occurrence.HasOccName GHC.Types.Name.Reader.RdrName
instance GHC.Internal.Base.Monoid GHC.Types.Name.Reader.ShadowedFieldGREs
instance GHC.Internal.Base.Monoid GHC.Types.Name.Reader.ShadowedGREs
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Types.Name.Reader.GlobalRdrEltX a)
instance Control.DeepSeq.NFData GHC.Types.Name.Reader.ImpDeclSpec
instance Control.DeepSeq.NFData GHC.Types.Name.Reader.ImportSpec
instance Control.DeepSeq.NFData GHC.Types.Name.Reader.Parent
instance GHC.Classes.Ord GHC.Types.Name.Reader.RdrName
instance GHC.Utils.Outputable.OutputableBndr GHC.Types.Name.Reader.RdrName
instance GHC.Utils.Outputable.Outputable info => GHC.Utils.Outputable.Outputable (GHC.Types.Name.Reader.GlobalRdrEltX info)
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.Reader.ImportSpec
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.Reader.LocalRdrEnv
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.Reader.LookupChild
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.Reader.Parent
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.Reader.RdrName
instance GHC.Utils.Outputable.Outputable (GHC.Types.Name.Reader.WhichGREs info)
instance GHC.Internal.Base.Semigroup GHC.Types.Name.Reader.ShadowedFieldGREs
instance GHC.Internal.Base.Semigroup GHC.Types.Name.Reader.ShadowedGREs
instance GHC.Internal.Show.Show GHC.Types.Name.Reader.FieldsOrSelectors

module GHC.Unit.Module.Imported

-- | Records the modules directly imported by a module for extracting e.g.
--   usage information, and also to give better error message
type ImportedMods = Map Module [ImportedBy]

-- | If a module was "imported" by the user, we associate it with more
--   detailed usage information <a>ImportedModsVal</a>; a module imported
--   by the system only gets used for usage information.
data ImportedBy
ImportedByUser :: ImportedModsVal -> ImportedBy
ImportedBySystem :: ImportedBy
data ImportedModsVal
ImportedModsVal :: ModuleName -> SrcSpan -> IsSafeImport -> Bool -> !GlobalRdrEnv -> Bool -> ImportedModsVal

-- | The name the module is imported with
[imv_name] :: ImportedModsVal -> ModuleName

-- | the source span of the whole import
[imv_span] :: ImportedModsVal -> SrcSpan

-- | whether this is a safe import
[imv_is_safe] :: ImportedModsVal -> IsSafeImport

-- | whether this is an "hiding" import
[imv_is_hiding] :: ImportedModsVal -> Bool

-- | all the things the module could provide.
--   
--   NB. BangPattern here: otherwise this leaks. (#15111)
[imv_all_exports] :: ImportedModsVal -> !GlobalRdrEnv

-- | whether this is a qualified import
[imv_qualified] :: ImportedModsVal -> Bool
importedByUser :: [ImportedBy] -> [ImportedModsVal]


-- | Support for source code annotation feature of GHC. That is the ANN
--   pragma.
--   
--   (c) The University of Glasgow 2006 (c) The GRASP/AQUA Project, Glasgow
--   University, 1992-1998
module GHC.Types.Annotations

-- | Represents an annotation after it has been sufficiently desugared from
--   it's initial form of <a>AnnDecl</a>
data Annotation
Annotation :: CoreAnnTarget -> AnnPayload -> Annotation

-- | The target of the annotation
[ann_target] :: Annotation -> CoreAnnTarget
[ann_value] :: Annotation -> AnnPayload
type AnnPayload = Serialized

-- | An annotation target
data AnnTarget name

-- | We are annotating something with a name: a type or identifier
NamedTarget :: name -> AnnTarget name

-- | We are annotating a particular module
ModuleTarget :: Module -> AnnTarget name

-- | The kind of annotation target found in the middle end of the compiler
type CoreAnnTarget = AnnTarget Name

-- | A collection of annotations
data AnnEnv

-- | Construct a new annotation environment that contains the list of
--   annotations provided.
mkAnnEnv :: [Annotation] -> AnnEnv

-- | Add the given annotation to the environment.
extendAnnEnvList :: AnnEnv -> [Annotation] -> AnnEnv

-- | Union two annotation environments.
plusAnnEnv :: AnnEnv -> AnnEnv -> AnnEnv

-- | An empty annotation environment.
emptyAnnEnv :: AnnEnv

-- | Find the annotations attached to the given target as <a>Typeable</a>
--   values of your choice. If no deserializer is specified, only transient
--   annotations will be returned.
findAnns :: Typeable a => ([Word8] -> a) -> AnnEnv -> CoreAnnTarget -> [a]

-- | Find the annotations attached to the given target as <a>Typeable</a>
--   values of your choice. If no deserializer is specified, only transient
--   annotations will be returned.
findAnnsByTypeRep :: AnnEnv -> CoreAnnTarget -> TypeRep -> [[Word8]]

-- | Deserialize all annotations of a given type. This happens lazily, that
--   is no deserialization will take place until the [a] is actually
--   demanded and the [a] can also be empty (the UniqFM is not filtered).
deserializeAnns :: Typeable a => ([Word8] -> a) -> AnnEnv -> (ModuleEnv [a], NameEnv [a])
instance GHC.Utils.Binary.Binary name => GHC.Utils.Binary.Binary (GHC.Types.Annotations.AnnTarget name)
instance GHC.Internal.Base.Functor GHC.Types.Annotations.AnnTarget
instance GHC.Utils.Outputable.Outputable name => GHC.Utils.Outputable.Outputable (GHC.Types.Annotations.AnnTarget name)
instance GHC.Utils.Outputable.Outputable GHC.Types.Annotations.Annotation

module GHC.Parser.Annotation

-- | A token stored in the syntax tree. For example, when parsing a
--   let-expression, we store <tt>EpToken "let"</tt> and <tt>EpToken
--   "in"</tt>. The locations of those tokens can be used to faithfully
--   reproduce (exactprint) the original program text.
data EpToken (tok :: Symbol)
NoEpTok :: EpToken (tok :: Symbol)
EpTok :: !EpaLocation -> EpToken (tok :: Symbol)

-- | With <tt>UnicodeSyntax</tt>, there might be multiple ways to write the
--   same token. For example an arrow could be either <tt>-&gt;</tt> or
--   <tt>→</tt>. This choice must be recorded in order to exactprint such
--   tokens, so instead of <tt>EpToken "-&gt;"</tt> we introduce
--   <tt>EpUniToken "-&gt;" "→"</tt>.
data EpUniToken (tok :: Symbol) (utok :: Symbol)
NoEpUniTok :: EpUniToken (tok :: Symbol) (utok :: Symbol)
EpUniTok :: !EpaLocation -> !IsUnicodeSyntax -> EpUniToken (tok :: Symbol) (utok :: Symbol)
getEpTokenSrcSpan :: forall (tok :: Symbol). EpToken tok -> SrcSpan
getEpTokenLocs :: forall (tok :: Symbol). [EpToken tok] -> [EpaLocation]
getEpTokenLoc :: forall (tok :: Symbol). EpToken tok -> EpaLocation
getEpUniTokenLoc :: forall (tok :: Symbol) (toku :: Symbol). EpUniToken tok toku -> EpaLocation
type TokDcolon = EpUniToken "::" "\8759"
type TokDarrow = EpUniToken "=>" "\8658"
type TokRarrow = EpUniToken "->" "\8594"
type TokForall = EpUniToken "forall" "\8704"

-- | Layout information for declarations.
data EpLayout

-- | Explicit braces written by the user.
--   
--   <pre>
--   class C a where { foo :: a; bar :: a }
--   </pre>
EpExplicitBraces :: !EpToken "{" -> !EpToken "}" -> EpLayout

-- | Virtual braces inserted by the layout algorithm.
--   
--   <pre>
--   class C a where
--     foo :: a
--     bar :: a
--   </pre>
EpVirtualBraces :: !Int -> EpLayout

-- | Empty or compiler-generated blocks do not have layout information
--   associated with them.
EpNoLayout :: EpLayout
data EpaComment
EpaComment :: EpaCommentTok -> RealSrcSpan -> EpaComment
[ac_tok] :: EpaComment -> EpaCommentTok

-- | The location of the prior token, used in exact printing. The
--   <a>EpaComment</a> appears as an <a>LEpaComment</a> containing its
--   location. The difference between the end of the prior token and the
--   start of this location is used for the spacing when exact printing the
--   comment.
[ac_prior_tok] :: EpaComment -> RealSrcSpan
data EpaCommentTok

-- | a docstring that can be pretty printed using pprHsDocString
EpaDocComment :: HsDocString -> EpaCommentTok

-- | doc options (prune, ignore-exports, etc)
EpaDocOptions :: String -> EpaCommentTok

-- | comment starting by "--"
EpaLineComment :: String -> EpaCommentTok

-- | comment in {- -}
EpaBlockComment :: String -> EpaCommentTok

-- | Certain tokens can have alternate representations when unicode syntax
--   is enabled. This flag is attached to those tokens in the lexer so that
--   the original source representation can be reproduced in the
--   corresponding <tt>EpAnnotation</tt>
data IsUnicodeSyntax
UnicodeSyntax :: IsUnicodeSyntax
NormalSyntax :: IsUnicodeSyntax

-- | Some template haskell tokens have two variants, one with an <tt>e</tt>
--   the other not:
--   
--   <pre>
--   [| or [e|
--   [|| or [e||
--   </pre>
--   
--   This type indicates whether the <tt>e</tt> is present or not.
data HasE
HasE :: HasE
NoE :: HasE
type EpaLocation = EpaLocation' [LEpaComment]

-- | The anchor for an exact print annotation. The Parser inserts the
--   <tt><a>EpaSpan</a></tt> variant, giving the exact location of the
--   original item in the parsed source. This can be replaced by the
--   <tt><a>EpaDelta</a></tt> version, to provide a position for the item
--   relative to the end of the previous item in the source. This is useful
--   when editing an AST prior to exact printing the changed one. The
--   EpaDelta also contains the original <tt><a>SrcSpan</a></tt> for use by
--   tools wanting to manipulate the AST after converting it using
--   ghc-exactprint' <tt><tt>makeDeltaAst</tt></tt>.
data EpaLocation' a
EpaSpan :: !SrcSpan -> EpaLocation' a
EpaDelta :: !SrcSpan -> !DeltaPos -> !a -> EpaLocation' a

-- | Used in the parser only, extract the <a>RealSrcSpan</a> from an
--   <a>EpaLocation</a>. The parser will never insert a <a>DeltaPos</a>, so
--   the partial function is safe.
epaLocationRealSrcSpan :: EpaLocation' a -> RealSrcSpan

-- | Tokens embedded in the AST have an EpaLocation, unless they come from
--   generated code (e.g. by TH).
data TokenLocation
NoTokenLoc :: TokenLocation
TokenLoc :: !EpaLocation -> TokenLocation

-- | Spacing between output items when exact printing. It captures the
--   spacing from the current print position on the page to the position
--   required for the thing about to be printed. This is either on the same
--   line in which case is is simply the number of spaces to emit, or it is
--   some number of lines down, with a given column offset. The exact
--   printing algorithm keeps track of the column offset pertaining to the
--   current anchor position, so the <a>deltaColumn</a> is the additional
--   spaces to add in this case. See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/api-annotations</a> for
--   details.
data DeltaPos
SameLine :: !Int -> DeltaPos
[deltaColumn] :: DeltaPos -> !Int
DifferentLine :: !Int -> !Int -> DeltaPos

-- | deltaLine should always be &gt; 0
[deltaLine] :: DeltaPos -> !Int
[deltaColumn] :: DeltaPos -> !Int

-- | Smart constructor for a <a>DeltaPos</a>. It preserves the invariant
--   that for the <a>DifferentLine</a> constructor <a>deltaLine</a> is
--   always &gt; 0.
deltaPos :: Int -> Int -> DeltaPos
getDeltaLine :: DeltaPos -> Int

-- | The exact print annotations (EPAs) are kept in the HsSyn AST for the
--   GhcPs phase. They are usually inserted into the AST by the parser, and
--   in case of generated code (e.g. by TemplateHaskell) they are usually
--   initialized using <a>NoAnn</a> type class.
--   
--   A goal of the annotations is that an AST can be edited, including
--   moving subtrees from one place to another, duplicating them, and so
--   on. This means that each fragment must be self-contained. To this end,
--   each annotated fragment keeps track of the anchor position it was
--   originally captured at, being simply the start span of the topmost
--   element of the ast fragment. This gives us a way to later re-calculate
--   all Located items in this layer of the AST, as well as any annotations
--   captured. The comments associated with the AST fragment are also
--   captured here.
--   
--   The <tt>ann</tt> type parameter allows this general structure to be
--   specialised to the specific set of locations of original exact print
--   annotation elements. For example
--   
--   <pre>
--   type SrcSpannAnnA = EpAnn AnnListItem
--   </pre>
--   
--   is a commonly used type alias that specializes the <tt>ann</tt> type
--   parameter to <a>AnnListItem</a>.
--   
--   The spacing between the items under the scope of a given EpAnn is
--   normally derived from the original <tt>Anchor</tt>. But if a
--   sub-element is not in its original position, the required spacing can
--   be captured using an appropriate <a>EpaDelta</a> value for the
--   <a>entry</a> Anchor. This allows us to freely move elements around,
--   and stitch together new AST fragments out of old ones, and have them
--   still printed out in a precise way.
data EpAnn ann
EpAnn :: !EpaLocation -> !ann -> !EpAnnComments -> EpAnn ann

-- | Base location for the start of the syntactic element holding the
--   annotations.
[entry] :: EpAnn ann -> !EpaLocation

-- | Annotations added by the Parser
[anns] :: EpAnn ann -> !ann

-- | Comments enclosed in the SrcSpan of the element this <a>EpAnn</a> is
--   attached to
[comments] :: EpAnn ann -> !EpAnnComments
spanAsAnchor :: SrcSpan -> EpaLocation' a
realSpanAsAnchor :: RealSrcSpan -> EpaLocation' a
noSpanAnchor :: NoAnn a => EpaLocation' a
class NoAnn a

-- | equivalent of <a>mempty</a>, but does not need Semigroup
noAnn :: NoAnn a => a

-- | When we are parsing we add comments that belong to a particular AST
--   element, and print them together with the element, interleaving them
--   into the output stream. But when editing the AST to move fragments
--   around it is useful to be able to first separate the comments into
--   those occurring before the AST element and those following it. The
--   <a>EpaCommentsBalanced</a> constructor is used to do this. The GHC
--   parser will only insert the <a>EpaComments</a> form.
data EpAnnComments
EpaComments :: ![LEpaComment] -> EpAnnComments
[priorComments] :: EpAnnComments -> ![LEpaComment]
EpaCommentsBalanced :: ![LEpaComment] -> ![LEpaComment] -> EpAnnComments
[priorComments] :: EpAnnComments -> ![LEpaComment]
[followingComments] :: EpAnnComments -> ![LEpaComment]
type LEpaComment = GenLocated NoCommentsLocation EpaComment
type NoCommentsLocation = EpaLocation' NoComments
data NoComments
NoComments :: NoComments
emptyComments :: EpAnnComments
epaToNoCommentsLocation :: EpaLocation -> NoCommentsLocation
noCommentsToEpaLocation :: NoCommentsLocation -> EpaLocation
getFollowingComments :: EpAnnComments -> [LEpaComment]
setFollowingComments :: EpAnnComments -> [LEpaComment] -> EpAnnComments
setPriorComments :: EpAnnComments -> [LEpaComment] -> EpAnnComments
type EpAnnCO = EpAnn NoEpAnns
type LocatedA = GenLocated SrcSpanAnnA
type LocatedL = GenLocated SrcSpanAnnL
type LocatedC = GenLocated SrcSpanAnnC
type LocatedN = GenLocated SrcSpanAnnN

-- | General representation of a <a>GenLocated</a> type carrying a
--   parameterised annotation type.
type LocatedAn an = GenLocated EpAnn an
type LocatedP = GenLocated SrcSpanAnnP
type LocatedLC = GenLocated SrcSpanAnnLC
type LocatedLS = GenLocated SrcSpanAnnLS
type LocatedLW = GenLocated SrcSpanAnnLW
type LocatedLI = GenLocated SrcSpanAnnLI
type SrcSpanAnnA = EpAnn AnnListItem
type SrcSpanAnnL = EpAnn AnnList ()
type SrcSpanAnnP = EpAnn AnnPragma
type SrcSpanAnnC = EpAnn AnnContext
type SrcSpanAnnN = EpAnn NameAnn
type SrcSpanAnnLC = EpAnn AnnList [EpToken ","]
type SrcSpanAnnLW = EpAnn AnnList EpToken "where"
type SrcSpanAnnLS = EpAnn AnnList ()
type SrcSpanAnnLI = EpAnn AnnList (EpToken "hiding", [EpToken ","])
type LocatedE = GenLocated EpaLocation

-- | Annotation for items appearing in a list. They can have one or more
--   trailing punctuations items, such as commas or semicolons.
data AnnListItem
AnnListItem :: [TrailingAnn] -> AnnListItem
[lann_trailing] :: AnnListItem -> [TrailingAnn]

-- | Annotation for the "container" of a list. This captures surrounding
--   items such as braces if present, and introductory keywords such as
--   'where'.
data AnnList a
AnnList :: !Maybe EpaLocation -> !AnnListBrackets -> [EpToken ";"] -> !a -> ![TrailingAnn] -> AnnList a

-- | start point of a list having layout
[al_anchor] :: AnnList a -> !Maybe EpaLocation
[al_brackets] :: AnnList a -> !AnnListBrackets
[al_semis] :: AnnList a -> [EpToken ";"]
[al_rest] :: AnnList a -> !a

-- | items appearing after the list, such as '=&gt;' for a context
[al_trailing] :: AnnList a -> ![TrailingAnn]
data AnnListBrackets
ListParens :: EpToken "(" -> EpToken ")" -> AnnListBrackets
ListBraces :: EpToken "{" -> EpToken "}" -> AnnListBrackets
ListSquare :: EpToken "[" -> EpToken "]" -> AnnListBrackets
ListBanana :: EpUniToken "(|" "\10631" -> EpUniToken "|)" "\10632" -> AnnListBrackets
ListNone :: AnnListBrackets

-- | exact print annotation for an item having surrounding "brackets", such
--   as tuples or lists
data AnnParen

-- | '(', ')'
AnnParens :: EpToken "(" -> EpToken ")" -> AnnParen

-- | '(#', '#)'
AnnParensHash :: EpToken "(#" -> EpToken "#)" -> AnnParen

-- | '[', ']'
AnnParensSquare :: EpToken "[" -> EpToken "]" -> AnnParen

-- | exact print annotation used for capturing the locations of annotations
--   in pragmas.
data AnnPragma
AnnPragma :: EpaLocation -> EpToken "#-}" -> (EpToken "[", EpToken "]") -> EpaLocation -> EpaLocation -> EpToken "type" -> EpToken "module" -> AnnPragma
[apr_open] :: AnnPragma -> EpaLocation
[apr_close] :: AnnPragma -> EpToken "#-}"
[apr_squares] :: AnnPragma -> (EpToken "[", EpToken "]")
[apr_loc1] :: AnnPragma -> EpaLocation
[apr_loc2] :: AnnPragma -> EpaLocation
[apr_type] :: AnnPragma -> EpToken "type"
[apr_module] :: AnnPragma -> EpToken "module"

-- | Exact print annotation for the <tt>Context</tt> data type.
data AnnContext
AnnContext :: Maybe TokDarrow -> [EpToken "("] -> [EpToken ")"] -> AnnContext

-- | location of the '=&gt;', if present.
[ac_darrow] :: AnnContext -> Maybe TokDarrow

-- | zero or more opening parentheses.
[ac_open] :: AnnContext -> [EpToken "("]

-- | zero or more closing parentheses.
[ac_close] :: AnnContext -> [EpToken ")"]

-- | exact print annotations for a <tt>RdrName</tt>. There are many kinds
--   of adornment that can be attached to a given <tt>RdrName</tt>. This
--   type captures them, as detailed on the individual constructors.
data NameAnn

-- | Used for a name with an adornment, so <tt>`foo`</tt>, <tt>(bar)</tt>
NameAnn :: NameAdornment -> EpaLocation -> [TrailingAnn] -> NameAnn
[nann_adornment] :: NameAnn -> NameAdornment
[nann_name] :: NameAnn -> EpaLocation
[nann_trailing] :: NameAnn -> [TrailingAnn]

-- | Used for <tt>(,,,)</tt>, or <tt>()</tt>
NameAnnCommas :: NameAdornment -> [EpToken ","] -> [TrailingAnn] -> NameAnn
[nann_adornment] :: NameAnn -> NameAdornment
[nann_commas] :: NameAnn -> [EpToken ","]
[nann_trailing] :: NameAnn -> [TrailingAnn]

-- | Used for <tt>(# | | #)</tt>
NameAnnBars :: (EpToken "(#", EpToken "#)") -> [EpToken "|"] -> [TrailingAnn] -> NameAnn
[nann_parensh] :: NameAnn -> (EpToken "(#", EpToken "#)")
[nann_bars] :: NameAnn -> [EpToken "|"]
[nann_trailing] :: NameAnn -> [TrailingAnn]

-- | Used for <tt>()</tt>, <tt>(##)</tt>, <tt>[]</tt>
NameAnnOnly :: NameAdornment -> [TrailingAnn] -> NameAnn
[nann_adornment] :: NameAnn -> NameAdornment
[nann_trailing] :: NameAnn -> [TrailingAnn]

-- | Used for <tt>-&gt;</tt>, as an identifier
NameAnnRArrow :: Maybe (EpToken "(") -> TokRarrow -> Maybe (EpToken ")") -> [TrailingAnn] -> NameAnn
[nann_mopen] :: NameAnn -> Maybe (EpToken "(")
[nann_arrow] :: NameAnn -> TokRarrow
[nann_mclose] :: NameAnn -> Maybe (EpToken ")")
[nann_trailing] :: NameAnn -> [TrailingAnn]

-- | Used for an item with a leading <tt>'</tt>. The annotation for
--   unquoted item is stored in <a>nann_quoted</a>.
NameAnnQuote :: EpToken "'" -> SrcSpanAnnN -> [TrailingAnn] -> NameAnn
[nann_quote] :: NameAnn -> EpToken "'"
[nann_quoted] :: NameAnn -> SrcSpanAnnN
[nann_trailing] :: NameAnn -> [TrailingAnn]

-- | Used when adding a <a>TrailingAnn</a> to an existing <a>LocatedN</a>
--   which has no Api Annotation.
NameAnnTrailing :: [TrailingAnn] -> NameAnn
[nann_trailing] :: NameAnn -> [TrailingAnn]

-- | A <a>NameAnn</a> can capture the locations of surrounding adornments,
--   such as parens or backquotes. This data type identifies what
--   particular pair are being used.
data NameAdornment
NameParens :: EpToken "(" -> EpToken ")" -> NameAdornment
NameParensHash :: EpToken "(#" -> EpToken "#)" -> NameAdornment
NameBackquotes :: EpToken "`" -> EpToken "`" -> NameAdornment
NameSquare :: EpToken "[" -> EpToken "]" -> NameAdornment
NameNoAdornment :: NameAdornment
data NoEpAnns
NoEpAnns :: NoEpAnns

-- | Captures the sort order of sub elements for <tt>ValBinds</tt>,
--   <tt>ClassDecl</tt>, <tt>ClsInstDecl</tt>
data AnnSortKey tag
NoAnnSortKey :: AnnSortKey tag
AnnSortKey :: [tag] -> AnnSortKey tag

-- | Used to track interleaving of class methods, class signatures,
--   associated types and associate type defaults in <tt>ClassDecl</tt> and
--   <tt>ClsInstDecl</tt>.
data DeclTag
ClsMethodTag :: DeclTag
ClsSigTag :: DeclTag
ClsAtTag :: DeclTag
ClsAtdTag :: DeclTag

-- | Used to track of interleaving of binds and signatures for ValBind
data BindTag
BindTag :: BindTag
SigDTag :: BindTag

-- | Captures the location of punctuation occurring between items, normally
--   in a list. It is captured as a trailing annotation.
data TrailingAnn

-- | Trailing ';'
AddSemiAnn :: EpToken ";" -> TrailingAnn

-- | Trailing ','
AddCommaAnn :: EpToken "," -> TrailingAnn

-- | Trailing '|'
AddVbarAnn :: EpToken "|" -> TrailingAnn

-- | Trailing '=&gt;' / <tt>⇒</tt>
AddDarrowAnn :: TokDarrow -> TrailingAnn
ta_location :: TrailingAnn -> EpaLocation

-- | Helper function used in the parser to add a <a>TrailingAnn</a> items
--   to an existing annotation.
addTrailingAnnToA :: TrailingAnn -> EpAnnComments -> EpAnn AnnListItem -> EpAnn AnnListItem

-- | Helper function used in the parser to add a <a>TrailingAnn</a> items
--   to an existing annotation.
addTrailingAnnToL :: TrailingAnn -> EpAnnComments -> EpAnn (AnnList a) -> EpAnn (AnnList a)

-- | Helper function used in the parser to add a comma location to an
--   existing annotation.
addTrailingCommaToN :: EpAnn NameAnn -> EpaLocation -> EpAnn NameAnn
noTrailingN :: SrcSpanAnnN -> SrcSpanAnnN

-- | Helper function for converting annotation types. Discards any
--   annotations
l2l :: (HasLoc a, HasAnnotation b) => a -> b

-- | Helper function for converting annotation types. Discards any
--   annotations
la2la :: (HasLoc l, HasAnnotation l2) => GenLocated l a -> GenLocated l2 a
reLoc :: (HasLoc (GenLocated a e), HasAnnotation b) => GenLocated a e -> GenLocated b e
class HasLoc a

-- | conveniently calculate locations for things without locations attached
getHasLoc :: HasLoc a => a -> SrcSpan
getHasLocList :: HasLoc a => [a] -> SrcSpan
srcSpan2e :: SrcSpan -> EpaLocation
realSrcSpan :: SrcSpan -> RealSrcSpan
reAnnL :: ann -> EpAnnComments -> Located e -> GenLocated (EpAnn ann) e
reAnnC :: AnnContext -> EpAnnComments -> Located a -> LocatedC a
addAnnsA :: SrcSpanAnnA -> [TrailingAnn] -> EpAnnComments -> SrcSpanAnnA

-- | The annotations need to all come after the anchor. Make sure this is
--   the case.
widenSpanL :: SrcSpan -> [EpaLocation] -> SrcSpan
widenSpanT :: forall (tok :: Symbol). SrcSpan -> EpToken tok -> SrcSpan
widenAnchorT :: forall (tok :: Symbol). EpaLocation -> EpToken tok -> EpaLocation
widenAnchorS :: EpaLocation -> SrcSpan -> EpaLocation
widenLocatedAnL :: EpAnn an -> [EpaLocation] -> EpAnn an
listLocation :: [LocatedAn an a] -> EpaLocation
getLocAnn :: Located a -> SrcSpanAnnA
epAnnComments :: EpAnn an -> EpAnnComments
sortLocatedA :: HasLoc (EpAnn a) => [GenLocated (EpAnn a) e] -> [GenLocated (EpAnn a) e]
mapLocA :: NoAnn ann => (a -> b) -> GenLocated SrcSpan a -> GenLocated (EpAnn ann) b
combineLocsA :: Semigroup a => GenLocated (EpAnn a) e1 -> GenLocated (EpAnn a) e2 -> EpAnn a
combineSrcSpansA :: Semigroup a => EpAnn a -> EpAnn a -> EpAnn a

-- | Combine locations from two <a>Located</a> things and add them to a
--   third thing
addCLocA :: (HasLoc a, HasLoc b, HasAnnotation l) => a -> b -> c -> GenLocated l c
class HasAnnotation e
noAnnSrcSpan :: HasAnnotation e => SrcSpan -> e
locA :: HasLoc a => a -> SrcSpan
noLocA :: HasAnnotation e => a -> GenLocated e a
getLocA :: HasLoc a => GenLocated a e -> SrcSpan
noSrcSpanA :: HasAnnotation e => e
noComments :: EpAnnCO
comment :: RealSrcSpan -> EpAnnComments -> EpAnnCO

-- | Add additional comments to a <a>EpAnn</a>, used for manipulating the
--   AST prior to exact printing the changed one.
addCommentsToEpAnn :: NoAnn ann => EpAnn ann -> EpAnnComments -> EpAnn ann

-- | Replace any existing comments on a <a>EpAnn</a>, used for manipulating
--   the AST prior to exact printing the changed one.
setCommentsEpAnn :: NoAnn ann => EpAnn ann -> EpAnnComments -> EpAnn ann

-- | Transfer comments and trailing items from the annotations in the first
--   <a>SrcSpanAnnA</a> argument to those in the second.
transferAnnsA :: SrcSpanAnnA -> SrcSpanAnnA -> (SrcSpanAnnA, SrcSpanAnnA)

-- | Transfer trailing items from the annotations in the first
--   <a>SrcSpanAnnA</a> argument to those in the second.
transferAnnsOnlyA :: SrcSpanAnnA -> SrcSpanAnnA -> (SrcSpanAnnA, SrcSpanAnnA)

-- | Transfer comments from the annotations in the first <a>SrcSpanAnnA</a>
--   argument to those in the second.
transferCommentsOnlyA :: EpAnn a -> EpAnn b -> (EpAnn a, EpAnn b)

-- | Transfer prior comments only from the annotations in the first
--   <a>SrcSpanAnnA</a> argument to those in the second.
transferPriorCommentsA :: SrcSpanAnnA -> SrcSpanAnnA -> (SrcSpanAnnA, SrcSpanAnnA)

-- | Transfer trailing items but not comments from the annotations in the
--   first <a>SrcSpanAnnA</a> argument to those in the second.
transferFollowingA :: SrcSpanAnnA -> SrcSpanAnnA -> (SrcSpanAnnA, SrcSpanAnnA)

-- | Remove the exact print annotations payload, leaving only the anchor
--   and comments.
commentsOnlyA :: NoAnn ann => EpAnn ann -> EpAnn ann

-- | Remove the comments, leaving the exact print annotations payload
removeCommentsA :: EpAnn ann -> EpAnn ann
placeholderRealSpan :: RealSrcSpan
instance GHC.Internal.Data.Data.Data GHC.Parser.Annotation.AnnContext
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Parser.Annotation.AnnList a)
instance GHC.Internal.Data.Data.Data GHC.Parser.Annotation.AnnListBrackets
instance GHC.Internal.Data.Data.Data GHC.Parser.Annotation.AnnListItem
instance GHC.Internal.Data.Data.Data GHC.Parser.Annotation.AnnParen
instance GHC.Internal.Data.Data.Data GHC.Parser.Annotation.AnnPragma
instance GHC.Internal.Data.Data.Data tag => GHC.Internal.Data.Data.Data (GHC.Parser.Annotation.AnnSortKey tag)
instance GHC.Internal.Data.Data.Data GHC.Parser.Annotation.BindTag
instance GHC.Internal.Data.Data.Data GHC.Parser.Annotation.DeclTag
instance GHC.Internal.Data.Data.Data ann => GHC.Internal.Data.Data.Data (GHC.Parser.Annotation.EpAnn ann)
instance GHC.Internal.Data.Data.Data GHC.Parser.Annotation.EpAnnComments
instance GHC.Internal.Data.Data.Data GHC.Parser.Annotation.EpLayout
instance GHC.Internal.TypeLits.KnownSymbol tok => GHC.Internal.Data.Data.Data (GHC.Parser.Annotation.EpToken tok)
instance (GHC.Internal.TypeLits.KnownSymbol tok, GHC.Internal.TypeLits.KnownSymbol utok) => GHC.Internal.Data.Data.Data (GHC.Parser.Annotation.EpUniToken tok utok)
instance GHC.Internal.Data.Data.Data GHC.Parser.Annotation.EpaComment
instance GHC.Internal.Data.Data.Data GHC.Parser.Annotation.EpaCommentTok
instance GHC.Internal.Data.Data.Data GHC.Parser.Annotation.HasE
instance GHC.Internal.Data.Data.Data GHC.Parser.Annotation.IsUnicodeSyntax
instance GHC.Internal.Data.Data.Data GHC.Parser.Annotation.NameAdornment
instance GHC.Internal.Data.Data.Data GHC.Parser.Annotation.NameAnn
instance GHC.Internal.Data.Data.Data GHC.Parser.Annotation.NoEpAnns
instance GHC.Internal.Data.Data.Data GHC.Parser.Annotation.TokenLocation
instance GHC.Internal.Data.Data.Data GHC.Parser.Annotation.TrailingAnn
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Parser.Annotation.AnnList a)
instance GHC.Classes.Eq GHC.Parser.Annotation.AnnListBrackets
instance GHC.Classes.Eq GHC.Parser.Annotation.AnnListItem
instance GHC.Classes.Eq GHC.Parser.Annotation.AnnPragma
instance GHC.Classes.Eq tag => GHC.Classes.Eq (GHC.Parser.Annotation.AnnSortKey tag)
instance GHC.Classes.Eq GHC.Parser.Annotation.BindTag
instance GHC.Classes.Eq GHC.Parser.Annotation.DeclTag
instance GHC.Classes.Eq ann => GHC.Classes.Eq (GHC.Parser.Annotation.EpAnn ann)
instance GHC.Classes.Eq GHC.Parser.Annotation.EpAnnComments
instance GHC.Classes.Eq (GHC.Parser.Annotation.EpToken tok)
instance GHC.Classes.Eq (GHC.Parser.Annotation.EpUniToken tok utok)
instance GHC.Classes.Eq GHC.Parser.Annotation.EpaComment
instance GHC.Classes.Eq GHC.Parser.Annotation.EpaCommentTok
instance GHC.Classes.Eq GHC.Parser.Annotation.HasE
instance GHC.Classes.Eq GHC.Parser.Annotation.IsUnicodeSyntax
instance GHC.Classes.Eq GHC.Parser.Annotation.NameAdornment
instance GHC.Classes.Eq GHC.Parser.Annotation.NameAnn
instance GHC.Classes.Eq GHC.Parser.Annotation.NoEpAnns
instance GHC.Classes.Eq GHC.Parser.Annotation.TokenLocation
instance GHC.Classes.Eq GHC.Parser.Annotation.TrailingAnn
instance GHC.Internal.Base.Functor GHC.Parser.Annotation.EpAnn
instance GHC.Parser.Annotation.NoAnn ann => GHC.Parser.Annotation.HasAnnotation (GHC.Parser.Annotation.EpAnn ann)
instance GHC.Parser.Annotation.HasAnnotation GHC.Parser.Annotation.EpaLocation
instance GHC.Parser.Annotation.HasAnnotation GHC.Types.SrcLoc.SrcSpan
instance GHC.Parser.Annotation.HasLoc (GHC.Parser.Annotation.EpAnn a)
instance GHC.Parser.Annotation.HasLoc (GHC.Parser.Annotation.EpToken tok)
instance GHC.Parser.Annotation.HasLoc (GHC.Parser.Annotation.EpUniToken tok utok)
instance GHC.Parser.Annotation.HasLoc GHC.Parser.Annotation.EpaLocation
instance GHC.Parser.Annotation.HasLoc l => GHC.Parser.Annotation.HasLoc (GHC.Types.SrcLoc.GenLocated l a)
instance GHC.Parser.Annotation.HasLoc a => GHC.Parser.Annotation.HasLoc (GHC.Internal.Maybe.Maybe a)
instance GHC.Parser.Annotation.HasLoc GHC.Types.SrcLoc.SrcSpan
instance GHC.Internal.Base.Monoid (GHC.Parser.Annotation.AnnSortKey tag)
instance GHC.Types.Name.NamedThing (GHC.Types.SrcLoc.Located a) => GHC.Types.Name.NamedThing (GHC.Parser.Annotation.LocatedAn an a)
instance GHC.Parser.Annotation.NoAnn GHC.Parser.Annotation.AnnContext
instance GHC.Parser.Annotation.NoAnn a => GHC.Parser.Annotation.NoAnn (GHC.Parser.Annotation.AnnList a)
instance GHC.Parser.Annotation.NoAnn GHC.Parser.Annotation.AnnListItem
instance GHC.Parser.Annotation.NoAnn GHC.Parser.Annotation.AnnParen
instance GHC.Parser.Annotation.NoAnn GHC.Parser.Annotation.AnnPragma
instance GHC.Parser.Annotation.NoAnn GHC.Types.Bool
instance GHC.Parser.Annotation.NoAnn a => GHC.Parser.Annotation.NoAnn (GHC.Internal.Data.Either.Either a b)
instance GHC.Parser.Annotation.NoAnn ann => GHC.Parser.Annotation.NoAnn (GHC.Parser.Annotation.EpAnn ann)
instance GHC.Parser.Annotation.NoAnn (GHC.Parser.Annotation.EpToken s)
instance GHC.Parser.Annotation.NoAnn (GHC.Parser.Annotation.EpUniToken s t)
instance GHC.Parser.Annotation.NoAnn GHC.Parser.Annotation.EpaLocation
instance GHC.Parser.Annotation.NoAnn [a]
instance GHC.Parser.Annotation.NoAnn (GHC.Internal.Maybe.Maybe a)
instance GHC.Parser.Annotation.NoAnn GHC.Parser.Annotation.NameAnn
instance GHC.Parser.Annotation.NoAnn GHC.Parser.Annotation.NoEpAnns
instance GHC.Parser.Annotation.NoAnn GHC.Types.SourceText.SourceText
instance (GHC.Parser.Annotation.NoAnn a, GHC.Parser.Annotation.NoAnn b) => GHC.Parser.Annotation.NoAnn (a, b)
instance (GHC.Parser.Annotation.NoAnn a, GHC.Parser.Annotation.NoAnn b, GHC.Parser.Annotation.NoAnn c) => GHC.Parser.Annotation.NoAnn (a, b, c)
instance (GHC.Parser.Annotation.NoAnn a, GHC.Parser.Annotation.NoAnn b, GHC.Parser.Annotation.NoAnn c, GHC.Parser.Annotation.NoAnn d) => GHC.Parser.Annotation.NoAnn (a, b, c, d)
instance GHC.Parser.Annotation.NoAnn ()
instance GHC.Classes.Ord GHC.Parser.Annotation.BindTag
instance GHC.Classes.Ord GHC.Parser.Annotation.DeclTag
instance GHC.Classes.Ord GHC.Parser.Annotation.HasE
instance GHC.Classes.Ord GHC.Parser.Annotation.IsUnicodeSyntax
instance GHC.Classes.Ord GHC.Parser.Annotation.NoEpAnns
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.OutputableBndr e) => GHC.Utils.Outputable.OutputableBndr (GHC.Types.SrcLoc.GenLocated (GHC.Parser.Annotation.EpAnn a) e)
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.AnnContext
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Parser.Annotation.AnnList a)
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.AnnListBrackets
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.AnnListItem
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.AnnParen
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.AnnPragma
instance GHC.Utils.Outputable.Outputable tag => GHC.Utils.Outputable.Outputable (GHC.Parser.Annotation.AnnSortKey tag)
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.BindTag
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.DeclTag
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Parser.Annotation.EpAnn a)
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.EpAnnComments
instance GHC.Internal.TypeLits.KnownSymbol tok => GHC.Utils.Outputable.Outputable (GHC.Parser.Annotation.EpToken tok)
instance (GHC.Internal.TypeLits.KnownSymbol tok, GHC.Internal.TypeLits.KnownSymbol utok) => GHC.Utils.Outputable.Outputable (GHC.Parser.Annotation.EpUniToken tok utok)
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.EpaComment
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Types.SrcLoc.GenLocated GHC.Parser.Annotation.TokenLocation a)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable e) => GHC.Utils.Outputable.Outputable (GHC.Types.SrcLoc.GenLocated (GHC.Parser.Annotation.EpAnn a) e)
instance GHC.Utils.Outputable.Outputable e => GHC.Utils.Outputable.Outputable (GHC.Types.SrcLoc.GenLocated GHC.Parser.Annotation.EpaLocation e)
instance GHC.Utils.Outputable.Outputable (GHC.Types.SrcLoc.GenLocated GHC.Types.SrcLoc.NoCommentsLocation GHC.Parser.Annotation.EpaComment)
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.IsUnicodeSyntax
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.NameAdornment
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.NameAnn
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.NoEpAnns
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.TrailingAnn
instance GHC.Internal.Base.Semigroup GHC.Parser.Annotation.AnnListItem
instance GHC.Internal.Base.Semigroup (GHC.Parser.Annotation.AnnSortKey tag)
instance GHC.Internal.Base.Semigroup a => GHC.Internal.Base.Semigroup (GHC.Parser.Annotation.EpAnn a)
instance GHC.Internal.Base.Semigroup GHC.Parser.Annotation.EpAnnComments
instance GHC.Internal.Base.Semigroup GHC.Parser.Annotation.EpaLocation
instance GHC.Internal.Show.Show GHC.Parser.Annotation.BindTag
instance GHC.Internal.Show.Show GHC.Parser.Annotation.DeclTag
instance GHC.Internal.Show.Show GHC.Parser.Annotation.EpaComment
instance GHC.Internal.Show.Show GHC.Parser.Annotation.EpaCommentTok
instance GHC.Internal.Show.Show GHC.Parser.Annotation.HasE
instance GHC.Internal.Show.Show GHC.Parser.Annotation.IsUnicodeSyntax


-- | Boolean formulas without quantifiers and without negation. Such a
--   formula consists of variables, conjunctions (and), and disjunctions
--   (or).
--   
--   This module is used to represent minimal complete definitions for
--   classes.
module GHC.Data.BooleanFormula
data BooleanFormula a
Var :: a -> BooleanFormula a
And :: [LBooleanFormula a] -> BooleanFormula a
Or :: [LBooleanFormula a] -> BooleanFormula a
Parens :: LBooleanFormula a -> BooleanFormula a
type LBooleanFormula a = LocatedL BooleanFormula a
mkFalse :: BooleanFormula a
mkTrue :: BooleanFormula a
mkAnd :: Eq a => [LBooleanFormula a] -> BooleanFormula a
mkOr :: Eq a => [LBooleanFormula a] -> BooleanFormula a
mkVar :: a -> BooleanFormula a
isFalse :: BooleanFormula a -> Bool
isTrue :: BooleanFormula a -> Bool
eval :: (a -> Bool) -> BooleanFormula a -> Bool
simplify :: Eq a => (a -> Maybe Bool) -> BooleanFormula a -> BooleanFormula a
isUnsatisfied :: Eq a => (a -> Bool) -> BooleanFormula a -> Maybe (BooleanFormula a)
implies :: Uniquable a => BooleanFormula a -> BooleanFormula a -> Bool
impliesAtom :: Eq a => BooleanFormula a -> a -> Bool
pprBooleanFormula :: (Rational -> a -> SDoc) -> Rational -> BooleanFormula a -> SDoc
pprBooleanFormulaNice :: Outputable a => BooleanFormula a -> SDoc
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Data.BooleanFormula.BooleanFormula a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Data.BooleanFormula.BooleanFormula a)
instance GHC.Internal.Data.Foldable.Foldable GHC.Data.BooleanFormula.BooleanFormula
instance GHC.Internal.Base.Functor GHC.Data.BooleanFormula.BooleanFormula
instance GHC.Utils.Outputable.OutputableBndr a => GHC.Utils.Outputable.Outputable (GHC.Data.BooleanFormula.BooleanFormula a)
instance GHC.Internal.Data.Traversable.Traversable GHC.Data.BooleanFormula.BooleanFormula

module GHC.Hs.Extension
type IsSrcSpanAnn (p :: Pass) a = (Anno IdGhcP p ~ EpAnn a, NoAnn a, IsPass p)

-- | Used as a data type index for the hsSyn AST; also serves as a
--   singleton type for Pass
data GhcPass (c :: Pass)
[GhcPs] :: GhcPass 'Parsed
[GhcRn] :: GhcPass 'Renamed
[GhcTc] :: GhcPass 'Typechecked
data Pass
Parsed :: Pass
Renamed :: Pass
Typechecked :: Pass
type GhcPs = GhcPass 'Parsed
type GhcRn = GhcPass 'Renamed
type GhcTc = GhcPass 'Typechecked

-- | Allows us to check what phase we're in at GHC's runtime. For example,
--   this class allows us to write
--   
--   <pre>
--   f :: forall p. IsPass p =&gt; HsExpr (GhcPass p) -&gt; blah
--   f e = case ghcPass @p of
--           GhcPs -&gt;    ... in this RHS we have HsExpr GhcPs...
--           GhcRn -&gt;    ... in this RHS we have HsExpr GhcRn...
--           GhcTc -&gt;    ... in this RHS we have HsExpr GhcTc...
--   </pre>
--   
--   which is very useful, for example, when pretty-printing. See Note
--   [IsPass].
class (NoGhcTcPass NoGhcTcPass p ~ NoGhcTcPass p, IsPass NoGhcTcPass p) => IsPass (p :: Pass)
ghcPass :: IsPass p => GhcPass p

-- | Maps the "normal" id type for a given GHC pass
type family IdGhcP (pass :: Pass)
type family NoGhcTcPass (p :: Pass) :: Pass

-- | Constraint type to bundle up the requirement for <a>OutputableBndr</a>
--   on both the <tt>id</tt> and the <a>NoGhcTc</a> of it. See Note
--   [NoGhcTc].
type OutputableBndrId (pass :: Pass) = (OutputableBndr IdGhcP pass, OutputableBndr IdGhcP NoGhcTcPass pass, Outputable GenLocated Anno IdGhcP pass IdGhcP pass, Outputable GenLocated Anno IdGhcP NoGhcTcPass pass IdGhcP NoGhcTcPass pass, IsPass pass)
pprIfPs :: forall (p :: Pass). IsPass p => (p ~ 'Parsed => SDoc) -> SDoc
pprIfRn :: forall (p :: Pass). IsPass p => (p ~ 'Renamed => SDoc) -> SDoc
pprIfTc :: forall (p :: Pass). IsPass p => (p ~ 'Typechecked => SDoc) -> SDoc
instance GHC.Internal.Data.Typeable.Internal.Typeable p => GHC.Internal.Data.Data.Data (GHC.Hs.Extension.GhcPass p)
instance GHC.Internal.Data.Data.Data GHC.Hs.Extension.Pass
instance GHC.Hs.Extension.IsPass 'GHC.Hs.Extension.Parsed
instance GHC.Hs.Extension.IsPass 'GHC.Hs.Extension.Renamed
instance GHC.Hs.Extension.IsPass 'GHC.Hs.Extension.Typechecked
instance Language.Haskell.Syntax.Extension.MapXRec (GHC.Hs.Extension.GhcPass p)
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Extension.DataConCantHappen
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Extension.NoExtField
instance Language.Haskell.Syntax.Extension.UnXRec (GHC.Hs.Extension.GhcPass p)


-- | Types and functions for raw and lexed docstrings.
module GHC.Hs.Doc

-- | A docstring with the (probable) identifiers found in it.
type HsDoc = WithHsDocIdentifiers HsDocString

-- | Annotate a value with the probable identifiers found in it These will
--   be used by haddock to generate links.
--   
--   The identifiers are bundled along with their location in the source
--   file. This is useful for tooling to know exactly where they originate.
--   
--   This type is currently used in two places - for regular documentation
--   comments, with <tt>a</tt> set to <a>HsDocString</a>, and for adding
--   identifier information to warnings, where <tt>a</tt> is
--   <tt>StringLiteral</tt>
data WithHsDocIdentifiers a pass
WithHsDocIdentifiers :: !a -> ![Located (IdP pass)] -> WithHsDocIdentifiers a pass
[hsDocString] :: WithHsDocIdentifiers a pass -> !a
[hsDocIdentifiers] :: WithHsDocIdentifiers a pass -> ![Located (IdP pass)]

-- | Extract a mapping from the lexed identifiers to the names they may
--   correspond to.
hsDocIds :: WithHsDocIdentifiers a GhcRn -> NameSet
type LHsDoc pass = Located HsDoc pass

-- | Print a doc with its identifiers, useful for debugging
pprHsDocDebug :: Outputable (IdP name) => HsDoc name -> SDoc

-- | Pretty print a thing with its doc The docstring will include the
--   comment decorators '-- |', '{-|' etc and will come either before or
--   after depending on how it was written i.e it will come after the thing
--   if it is a '-- ^' or '{-^' and before otherwise.
pprWithDoc :: LHsDoc name -> SDoc -> SDoc

-- | See <tt>pprWithHsDoc</tt>
pprMaybeWithDoc :: Maybe (LHsDoc name) -> SDoc -> SDoc

-- | Maps of docs that were added via Template Haskell's <tt>putDoc</tt>.
data ExtractedTHDocs
ExtractedTHDocs :: Maybe (HsDoc GhcRn) -> UniqMap Name (HsDoc GhcRn) -> UniqMap Name (IntMap (HsDoc GhcRn)) -> UniqMap Name (HsDoc GhcRn) -> ExtractedTHDocs

-- | The added module header documentation, if it exists.
[ethd_mod_header] :: ExtractedTHDocs -> Maybe (HsDoc GhcRn)

-- | The documentation added to declarations.
[ethd_decl_docs] :: ExtractedTHDocs -> UniqMap Name (HsDoc GhcRn)

-- | The documentation added to function arguments.
[ethd_arg_docs] :: ExtractedTHDocs -> UniqMap Name (IntMap (HsDoc GhcRn))

-- | The documentation added to class and family instances.
[ethd_inst_docs] :: ExtractedTHDocs -> UniqMap Name (HsDoc GhcRn)

-- | A simplified version of <a>IE</a>.
data DocStructureItem
DsiSectionHeading :: !Int -> !HsDoc GhcRn -> DocStructureItem
DsiDocChunk :: !HsDoc GhcRn -> DocStructureItem
DsiNamedChunkRef :: !String -> DocStructureItem
DsiExports :: !DetOrdAvails -> DocStructureItem
DsiModExport :: !NonEmpty ModuleName -> !DetOrdAvails -> DocStructureItem
type DocStructure = [DocStructureItem]
data Docs
Docs :: Maybe (HsDoc GhcRn) -> UniqMap Name (HsDoc GhcRn) -> UniqMap Name [HsDoc GhcRn] -> UniqMap Name (IntMap (HsDoc GhcRn)) -> DocStructure -> Map String (HsDoc GhcRn) -> Maybe String -> Maybe Language -> EnumSet Extension -> Docs

-- | Module header.
[docs_mod_hdr] :: Docs -> Maybe (HsDoc GhcRn)

-- | Docs attached to module exports.
[docs_exports] :: Docs -> UniqMap Name (HsDoc GhcRn)

-- | Docs for declarations: functions, data types, instances, methods etc.
--   A list because sometimes subsequent haddock comments can be combined
--   into one
[docs_decls] :: Docs -> UniqMap Name [HsDoc GhcRn]

-- | Docs for arguments. E.g. function arguments, method arguments.
[docs_args] :: Docs -> UniqMap Name (IntMap (HsDoc GhcRn))
[docs_structure] :: Docs -> DocStructure

-- | Map from chunk name to content.
--   
--   This map will be empty unless we have an explicit export list from
--   which we can reference the chunks.
[docs_named_chunks] :: Docs -> Map String (HsDoc GhcRn)

-- | Haddock options from <tt>OPTIONS_HADDOCK</tt> or from
--   <tt>-haddock-opts</tt>.
[docs_haddock_opts] :: Docs -> Maybe String

-- | The <a>Language</a> used in the module, for example
--   <a>Haskell2010</a>.
[docs_language] :: Docs -> Maybe Language

-- | The full set of language extensions used in the module.
[docs_extensions] :: Docs -> EnumSet Extension
emptyDocs :: Docs
instance GHC.Utils.Binary.Binary GHC.Hs.Doc.DocStructureItem
instance GHC.Utils.Binary.Binary GHC.Hs.Doc.Docs
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Hs.Doc.WithHsDocIdentifiers a GHC.Hs.Extension.GhcRn)
instance (GHC.Internal.Data.Data.Data pass, GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Extension.IdP pass), GHC.Internal.Data.Data.Data a) => GHC.Internal.Data.Data.Data (GHC.Hs.Doc.WithHsDocIdentifiers a pass)
instance (GHC.Classes.Eq (Language.Haskell.Syntax.Extension.IdP pass), GHC.Classes.Eq a) => GHC.Classes.Eq (GHC.Hs.Doc.WithHsDocIdentifiers a pass)
instance Control.DeepSeq.NFData GHC.Hs.Doc.DocStructureItem
instance Control.DeepSeq.NFData GHC.Hs.Doc.Docs
instance (Control.DeepSeq.NFData (Language.Haskell.Syntax.Extension.IdP pass), Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (GHC.Hs.Doc.WithHsDocIdentifiers a pass)
instance GHC.Utils.Outputable.Outputable GHC.Hs.Doc.DocStructureItem
instance GHC.Utils.Outputable.Outputable GHC.Hs.Doc.Docs
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Hs.Doc.WithHsDocIdentifiers a pass)

module Language.Haskell.Syntax.Type

-- | This is used in the syntax. In constructor declaration. It must keep
--   the arrow representation.
data HsScaled pass a
HsScaled :: HsArrow pass -> a -> HsScaled pass a
hsMult :: HsScaled pass a -> HsArrow pass
hsScaledThing :: HsScaled pass a -> a
type HsArrow pass = HsArrowOf LHsType pass pass

-- | Denotes the type of arrows in the surface language
data HsArrowOf mult pass

-- | a -&gt; b or a → b
HsUnrestrictedArrow :: !XUnrestrictedArrow mult pass -> HsArrowOf mult pass

-- | a %1 -&gt; b or a %1 → b, or a ⊸ b
HsLinearArrow :: !XLinearArrow mult pass -> HsArrowOf mult pass

-- | a %m -&gt; b or a %m → b (very much including `a %Many -&gt; b`! This
--   is how the programmer wrote it). It is stored as an <a>HsType</a> so
--   as to preserve the syntax as written in the program.
HsExplicitMult :: !XExplicitMult mult pass -> !mult -> HsArrowOf mult pass
XArrow :: !XXArrow mult pass -> HsArrowOf mult pass
type family XUnrestrictedArrow mult p
type family XLinearArrow mult p
type family XExplicitMult mult p
type family XXArrow mult p

-- | Haskell Type
data HsType pass
HsForAllTy :: XForAllTy pass -> HsForAllTelescope pass -> LHsType pass -> HsType pass
[hst_xforall] :: HsType pass -> XForAllTy pass
[hst_tele] :: HsType pass -> HsForAllTelescope pass
[hst_body] :: HsType pass -> LHsType pass
HsQualTy :: XQualTy pass -> LHsContext pass -> LHsType pass -> HsType pass
[hst_xqual] :: HsType pass -> XQualTy pass
[hst_ctxt] :: HsType pass -> LHsContext pass
[hst_body] :: HsType pass -> LHsType pass
HsTyVar :: XTyVar pass -> PromotionFlag -> LIdP pass -> HsType pass
HsAppTy :: XAppTy pass -> LHsType pass -> LHsType pass -> HsType pass
HsAppKindTy :: XAppKindTy pass -> LHsType pass -> LHsKind pass -> HsType pass
HsFunTy :: XFunTy pass -> HsArrow pass -> LHsType pass -> LHsType pass -> HsType pass
HsListTy :: XListTy pass -> LHsType pass -> HsType pass
HsTupleTy :: XTupleTy pass -> HsTupleSort -> [LHsType pass] -> HsType pass
HsSumTy :: XSumTy pass -> [LHsType pass] -> HsType pass
HsOpTy :: XOpTy pass -> PromotionFlag -> LHsType pass -> LIdP pass -> LHsType pass -> HsType pass
HsParTy :: XParTy pass -> LHsType pass -> HsType pass

-- | <pre>
--   (?x :: ty)
--   </pre>
HsIParamTy :: XIParamTy pass -> XRec pass HsIPName -> LHsType pass -> HsType pass
HsStarTy :: XStarTy pass -> Bool -> HsType pass

-- | <pre>
--   (ty :: kind)
--   </pre>
HsKindSig :: XKindSig pass -> LHsType pass -> LHsKind pass -> HsType pass
HsSpliceTy :: XSpliceTy pass -> HsUntypedSplice pass -> HsType pass
HsDocTy :: XDocTy pass -> LHsType pass -> LHsDoc pass -> HsType pass
HsBangTy :: XBangTy pass -> HsBang -> LHsType pass -> HsType pass
HsRecTy :: XRecTy pass -> [LConDeclField pass] -> HsType pass
HsExplicitListTy :: XExplicitListTy pass -> PromotionFlag -> [LHsType pass] -> HsType pass
HsExplicitTupleTy :: XExplicitTupleTy pass -> PromotionFlag -> [LHsType pass] -> HsType pass
HsTyLit :: XTyLit pass -> HsTyLit pass -> HsType pass
HsWildCardTy :: XWildCardTy pass -> HsType pass
XHsType :: !XXType pass -> HsType pass

-- | Located Haskell Type
type LHsType pass = XRec pass HsType pass

-- | Haskell Kind
type HsKind pass = HsType pass

-- | Located Haskell Kind
type LHsKind pass = XRec pass HsKind pass
data HsBndrVis pass
HsBndrRequired :: !XBndrRequired pass -> HsBndrVis pass
HsBndrInvisible :: !XBndrInvisible pass -> HsBndrVis pass
XBndrVis :: !XXBndrVis pass -> HsBndrVis pass
type family XBndrRequired p
type family XBndrInvisible p
type family XXBndrVis p
data HsBndrVar pass
HsBndrVar :: !XBndrVar pass -> !LIdP pass -> HsBndrVar pass
HsBndrWildCard :: !XBndrWildCard pass -> HsBndrVar pass
XBndrVar :: !XXBndrVar pass -> HsBndrVar pass
type family XBndrVar p
type family XBndrWildCard p
type family XXBndrVar p
data HsBndrKind pass
HsBndrKind :: !XBndrKind pass -> LHsKind pass -> HsBndrKind pass
HsBndrNoKind :: !XBndrNoKind pass -> HsBndrKind pass
XBndrKind :: !XXBndrKind pass -> HsBndrKind pass
type family XBndrKind p
type family XBndrNoKind p
type family XXBndrKind p
isHsBndrInvisible :: HsBndrVis pass -> Bool
isHsBndrWildCard :: HsBndrVar pass -> Bool

-- | The type variable binders in an <a>HsForAllTy</a>. See also <tt>Note
--   [Variable Specificity and Forall Visibility]</tt> in
--   <a>GHC.Tc.Gen.HsType</a>.
data HsForAllTelescope pass

-- | A visible <tt>forall</tt> (e.g., <tt>forall a -&gt; {...}</tt>). These
--   do not have any notion of specificity, so we use <tt>()</tt> as a
--   placeholder value.
HsForAllVis :: XHsForAllVis pass -> [LHsTyVarBndr () pass] -> HsForAllTelescope pass
[hsf_xvis] :: HsForAllTelescope pass -> XHsForAllVis pass
[hsf_vis_bndrs] :: HsForAllTelescope pass -> [LHsTyVarBndr () pass]

-- | An invisible <tt>forall</tt> (e.g., <tt>forall a {b} c. {...}</tt>),
--   where each binder has a <a>Specificity</a>.
HsForAllInvis :: XHsForAllInvis pass -> [LHsTyVarBndr Specificity pass] -> HsForAllTelescope pass
[hsf_xinvis] :: HsForAllTelescope pass -> XHsForAllInvis pass
[hsf_invis_bndrs] :: HsForAllTelescope pass -> [LHsTyVarBndr Specificity pass]
XHsForAllTelescope :: !XXHsForAllTelescope pass -> HsForAllTelescope pass

-- | Haskell Type Variable Binder See Note [Type variable binders]
data HsTyVarBndr flag pass
HsTvb :: XTyVarBndr pass -> flag -> HsBndrVar pass -> HsBndrKind pass -> HsTyVarBndr flag pass
[tvb_ext] :: HsTyVarBndr flag pass -> XTyVarBndr pass
[tvb_flag] :: HsTyVarBndr flag pass -> flag
[tvb_var] :: HsTyVarBndr flag pass -> HsBndrVar pass
[tvb_kind] :: HsTyVarBndr flag pass -> HsBndrKind pass
XTyVarBndr :: !XXTyVarBndr pass -> HsTyVarBndr flag pass

-- | Located Haskell Type Variable Binder
type LHsTyVarBndr flag pass = XRec pass HsTyVarBndr flag pass

-- | Located Haskell Quantified Type Variables
data LHsQTyVars pass
HsQTvs :: XHsQTvs pass -> [LHsTyVarBndr (HsBndrVis pass) pass] -> LHsQTyVars pass
[hsq_ext] :: LHsQTyVars pass -> XHsQTvs pass
[hsq_explicit] :: LHsQTyVars pass -> [LHsTyVarBndr (HsBndrVis pass) pass]
XLHsQTyVars :: !XXLHsQTyVars pass -> LHsQTyVars pass

-- | The outermost type variables in a type that obeys the
--   <tt>forall</tt>-or-nothing rule. See <tt>Note [forall-or-nothing
--   rule]</tt>.
data HsOuterTyVarBndrs flag pass

-- | Implicit forall, e.g., <tt>f :: a -&gt; b -&gt; b</tt>
HsOuterImplicit :: XHsOuterImplicit pass -> HsOuterTyVarBndrs flag pass
[hso_ximplicit] :: HsOuterTyVarBndrs flag pass -> XHsOuterImplicit pass

-- | Explicit forall, e.g., <tt>f :: forall a b. a -&gt; b -&gt; b</tt>
HsOuterExplicit :: XHsOuterExplicit pass flag -> [LHsTyVarBndr flag (NoGhcTc pass)] -> HsOuterTyVarBndrs flag pass
[hso_xexplicit] :: HsOuterTyVarBndrs flag pass -> XHsOuterExplicit pass flag
[hso_bndrs] :: HsOuterTyVarBndrs flag pass -> [LHsTyVarBndr flag (NoGhcTc pass)]
XHsOuterTyVarBndrs :: !XXHsOuterTyVarBndrs pass -> HsOuterTyVarBndrs flag pass

-- | Used for type-family instance equations, e.g.,
--   
--   <pre>
--   type instance forall a. F [a] = Tree a
--   </pre>
--   
--   The notion of specificity is irrelevant in type family equations, so
--   we use <tt>()</tt> for the <a>HsOuterTyVarBndrs</a> <tt>flag</tt>.
type HsOuterFamEqnTyVarBndrs = HsOuterTyVarBndrs ()

-- | Used for signatures, e.g.,
--   
--   <pre>
--   f :: forall a {b}. blah
--   </pre>
--   
--   We use <a>Specificity</a> for the <a>HsOuterTyVarBndrs</a>
--   <tt>flag</tt> to allow distinguishing between specified and inferred
--   type variables.
type HsOuterSigTyVarBndrs = HsOuterTyVarBndrs Specificity

-- | Haskell Wildcard Binders
data HsWildCardBndrs pass thing
HsWC :: XHsWC pass thing -> thing -> HsWildCardBndrs pass thing
[hswc_ext] :: HsWildCardBndrs pass thing -> XHsWC pass thing
[hswc_body] :: HsWildCardBndrs pass thing -> thing
XHsWildCardBndrs :: !XXHsWildCardBndrs pass thing -> HsWildCardBndrs pass thing

-- | Types that can appear in pattern signatures, as well as the signatures
--   for term-level binders in RULES. See <tt>Note [Pattern signature
--   binders and scoping]</tt>.
--   
--   This is very similar to <tt>HsSigWcType</tt>, but with slightly
--   different semantics: see <tt>Note [HsType binders]</tt>. See also
--   <tt>Note [The wildcard story for types]</tt>.
data HsPatSigType pass
HsPS :: XHsPS pass -> LHsType pass -> HsPatSigType pass

-- | After renamer: <tt>HsPSRn</tt>
[hsps_ext] :: HsPatSigType pass -> XHsPS pass

-- | Main payload (the type itself)
[hsps_body] :: HsPatSigType pass -> LHsType pass
XHsPatSigType :: !XXHsPatSigType pass -> HsPatSigType pass

-- | A type signature that obeys the <tt>forall</tt>-or-nothing rule. In
--   other words, an <a>LHsType</a> that uses an
--   <a>HsOuterSigTyVarBndrs</a> to represent its outermost type variable
--   quantification. See <tt>Note [Representing type signatures]</tt>.
data HsSigType pass
HsSig :: XHsSig pass -> HsOuterSigTyVarBndrs pass -> LHsType pass -> HsSigType pass
[sig_ext] :: HsSigType pass -> XHsSig pass
[sig_bndrs] :: HsSigType pass -> HsOuterSigTyVarBndrs pass
[sig_body] :: HsSigType pass -> LHsType pass
XHsSigType :: !XXHsSigType pass -> HsSigType pass

-- | Located Haskell Signature Type
type LHsSigType pass = XRec pass HsSigType pass

-- | Located Haskell Signature Wildcard Type
type LHsSigWcType pass = HsWildCardBndrs pass LHsSigType pass

-- | Located Haskell Wildcard Type
type LHsWcType pass = HsWildCardBndrs pass LHsType pass
data HsTyPat pass
HsTP :: XHsTP pass -> LHsType pass -> HsTyPat pass

-- | After renamer: <tt>HsTyPatRn</tt>
[hstp_ext] :: HsTyPat pass -> XHsTP pass

-- | Main payload (the type itself)
[hstp_body] :: HsTyPat pass -> LHsType pass
XHsTyPat :: !XXHsTyPat pass -> HsTyPat pass
type LHsTyPat pass = XRec pass HsTyPat pass

-- | Haskell Tuple Sort
data HsTupleSort
HsUnboxedTuple :: HsTupleSort
HsBoxedOrConstraintTuple :: HsTupleSort

-- | Haskell Context
type HsContext pass = [LHsType pass]

-- | Located Haskell Context
type LHsContext pass = XRec pass HsContext pass

-- | Haskell Type Literal
data HsTyLit pass
HsNumTy :: XNumTy pass -> Integer -> HsTyLit pass
HsStrTy :: XStrTy pass -> FastString -> HsTyLit pass
HsCharTy :: XCharTy pass -> Char -> HsTyLit pass
XTyLit :: !XXTyLit pass -> HsTyLit pass

-- | These names are used early on to store the names of implicit
--   parameters. They completely disappear after type-checking.
newtype HsIPName
HsIPName :: FastString -> HsIPName
hsIPNameFS :: HsIPName -> FastString

-- | Arguments in an expression/type after splitting
data HsArg p tm ty
HsValArg :: !XValArg p -> tm -> HsArg p tm ty
HsTypeArg :: !XTypeArg p -> ty -> HsArg p tm ty
HsArgPar :: !XArgPar p -> HsArg p tm ty
XArg :: !XXArg p -> HsArg p tm ty
type family XValArg p
type family XTypeArg p
type family XArgPar p
type family XXArg p
type LHsTypeArg p = HsArg p LHsType p LHsKind p

-- | Located Bang Type
type LBangType pass = XRec pass BangType pass

-- | Bang Type
--   
--   In the parser, strictness and packedness annotations bind more tightly
--   than docstrings. This means that when consuming a <a>BangType</a> (and
--   looking for <a>HsBangTy</a>) we must be ready to peer behind a
--   potential layer of <a>HsDocTy</a>. See #15206 for motivation and
--   <tt>getBangType</tt> for an example.
type BangType pass = HsType pass

-- | Haskell Bang
--   
--   Bangs on data constructor arguments written by the user.
--   
--   <tt>(HsBang SrcUnpack SrcLazy)</tt> and <tt>(HsBang SrcUnpack
--   NoSrcStrict)</tt> (without StrictData) makes no sense, we emit a
--   warning (in checkValidDataCon) and treat it like <tt>(HsBang
--   NoSrcUnpack SrcLazy)</tt>
--   
--   <a>HsSrcBang</a> is a wrapper around this, associating it with a
--   <a>SourceText</a> as written by the user. In the AST, the
--   <tt>SourceText</tt> is hidden inside the extension point
--   <a>XBangTy</a>.
data HsBang
HsBang :: SrcUnpackedness -> SrcStrictness -> HsBang

-- | Is a TyCon a promoted data constructor or just a normal type
--   constructor?
data PromotionFlag
NotPromoted :: PromotionFlag
IsPromoted :: PromotionFlag
isPromoted :: PromotionFlag -> Bool

-- | Constructor Declaration Field
data ConDeclField pass
ConDeclField :: XConDeclField pass -> [LFieldOcc pass] -> LBangType pass -> Maybe (LHsDoc pass) -> ConDeclField pass
[cd_fld_ext] :: ConDeclField pass -> XConDeclField pass

-- | See Note [ConDeclField pass]
[cd_fld_names] :: ConDeclField pass -> [LFieldOcc pass]
[cd_fld_type] :: ConDeclField pass -> LBangType pass
[cd_fld_doc] :: ConDeclField pass -> Maybe (LHsDoc pass)
XConDeclField :: !XXConDeclField pass -> ConDeclField pass

-- | Located Constructor Declaration Field
type LConDeclField pass = XRec pass ConDeclField pass

-- | Describes the arguments to a data constructor. This is a common
--   representation for several constructor-related concepts, including:
--   
--   <ul>
--   <li>The arguments in a Haskell98-style constructor declaration (see
--   <tt>HsConDeclH98Details</tt> in <a>GHC.Hs.Decls</a>).</li>
--   <li>The arguments in constructor patterns in <tt>case</tt>/function
--   definitions (see <tt>HsConPatDetails</tt> in <a>GHC.Hs.Pat</a>).</li>
--   <li>The left-hand side arguments in a pattern synonym binding (see
--   <tt>HsPatSynDetails</tt> in <a>GHC.Hs.Binds</a>).</li>
--   </ul>
--   
--   One notable exception is the arguments in a GADT constructor, which
--   uses a separate data type entirely (see <tt>HsConDeclGADTDetails</tt>
--   in <a>GHC.Hs.Decls</a>). This is because GADT constructors cannot be
--   declared with infix syntax, unlike the concepts above (#18844).
data HsConDetails tyarg arg rec
PrefixCon :: [tyarg] -> [arg] -> HsConDetails tyarg arg rec
RecCon :: rec -> HsConDetails tyarg arg rec
InfixCon :: arg -> arg -> HsConDetails tyarg arg rec

-- | An empty list that can be used to indicate that there are no type
--   arguments allowed in cases where HsConDetails is applied to Void.
noTypeArgs :: [Void]

-- | Field Occurrence
--   
--   Represents an *occurrence* of a field. This may or may not be a
--   binding occurrence (e.g. this type is used in <a>ConDeclField</a> and
--   <tt>RecordPatSynField</tt> which bind their fields, but also in
--   <tt>HsRecField</tt> for record construction and patterns, which do
--   not).
--   
--   We store both the <tt>RdrName</tt> the user originally wrote, and
--   after the renamer we use the extension field to store the selector
--   function.
--   
--   There is a wrinkle in that update field occurances are sometimes
--   ambiguous during the rename stage. See note [Ambiguous FieldOcc in
--   record updates] to see how we currently handle this.
data FieldOcc pass
FieldOcc :: XCFieldOcc pass -> LIdP pass -> FieldOcc pass
[foExt] :: FieldOcc pass -> XCFieldOcc pass
[foLabel] :: FieldOcc pass -> LIdP pass
XFieldOcc :: !XXFieldOcc pass -> FieldOcc pass

-- | Located Field Occurrence
type LFieldOcc pass = XRec pass FieldOcc pass
mapHsOuterImplicit :: (XHsOuterImplicit pass -> XHsOuterImplicit pass) -> HsOuterTyVarBndrs flag pass -> HsOuterTyVarBndrs flag pass
hsQTvExplicit :: LHsQTyVars pass -> [LHsTyVarBndr (HsBndrVis pass) pass]

-- | Does this <a>HsTyVarBndr</a> come with an explicit kind annotation?
isHsKindedTyVar :: HsTyVarBndr flag pass -> Bool
hsPatSigType :: HsPatSigType pass -> LHsType pass
instance (GHC.Internal.Data.Data.Data tyarg, GHC.Internal.Data.Data.Data rec, GHC.Internal.Data.Data.Data arg) => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsConDetails tyarg arg rec)
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Type.HsIPName
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Type.HsTupleSort
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Type.PromotionFlag
instance (GHC.Classes.Eq (Language.Haskell.Syntax.Extension.LIdP pass), GHC.Classes.Eq (Language.Haskell.Syntax.Extension.XCFieldOcc pass), GHC.Classes.Eq (Language.Haskell.Syntax.Extension.XXFieldOcc pass)) => GHC.Classes.Eq (Language.Haskell.Syntax.Type.FieldOcc pass)
instance GHC.Classes.Eq Language.Haskell.Syntax.Type.HsIPName
instance GHC.Classes.Eq Language.Haskell.Syntax.Type.PromotionFlag
instance GHC.Classes.Ord Language.Haskell.Syntax.Type.PromotionFlag

module Language.Haskell.Syntax.Binds

-- | Haskell Local Bindings
type HsLocalBinds id = HsLocalBindsLR id id

-- | Located Haskell local bindings
type LHsLocalBinds id = XRec id HsLocalBinds id

-- | Haskell Local Bindings with separate Left and Right identifier types
--   
--   Bindings in a 'let' expression or a 'where' clause
data HsLocalBindsLR idL idR

-- | Haskell Value Bindings
HsValBinds :: XHsValBinds idL idR -> HsValBindsLR idL idR -> HsLocalBindsLR idL idR

-- | Haskell Implicit Parameter Bindings
HsIPBinds :: XHsIPBinds idL idR -> HsIPBinds idR -> HsLocalBindsLR idL idR

-- | Empty Local Bindings
EmptyLocalBinds :: XEmptyLocalBinds idL idR -> HsLocalBindsLR idL idR
XHsLocalBindsLR :: !XXHsLocalBindsLR idL idR -> HsLocalBindsLR idL idR
type LHsLocalBindsLR idL idR = XRec idL HsLocalBindsLR idL idR

-- | Haskell Value Bindings
type HsValBinds id = HsValBindsLR id id

-- | Haskell Value bindings with separate Left and Right identifier types
--   (not implicit parameters) Used for both top level and nested bindings
--   May contain pattern synonym bindings
data HsValBindsLR idL idR

-- | Value Bindings In
--   
--   Before renaming RHS; idR is always RdrName Not dependency analysed
--   Recursive by default
ValBinds :: XValBinds idL idR -> LHsBindsLR idL idR -> [LSig idR] -> HsValBindsLR idL idR

-- | Value Bindings Out
--   
--   After renaming RHS; idR can be Name or Id Dependency analysed, later
--   bindings in the list may depend on earlier ones.
XValBindsLR :: !XXValBindsLR idL idR -> HsValBindsLR idL idR

-- | Located Haskell Binding
type LHsBind id = LHsBindLR id id

-- | Located Haskell Bindings
type LHsBinds id = LHsBindsLR id id

-- | Haskell Binding
type HsBind id = HsBindLR id id

-- | Located Haskell Bindings with separate Left and Right identifier types
type LHsBindsLR idL idR = [LHsBindLR idL idR]

-- | Located Haskell Binding with separate Left and Right identifier types
type LHsBindLR idL idR = XRec idL HsBindLR idL idR

-- | Haskell Binding with separate Left and Right id's
data HsBindLR idL idR

-- | Function-like Binding
--   
--   FunBind is used for both functions <tt>f x = e</tt> and variables
--   <tt>f = x -&gt; e</tt> and strict variables <tt>!x = x + 1</tt>
--   
--   Reason 1: Special case for type inference: see <a>tcMonoBinds</a>.
--   
--   Reason 2: Instance decls can only have FunBinds, which is convenient.
--   If you change this, you'll need to change e.g. rnMethodBinds
--   
--   But note that the form <tt>f :: a-&gt;a = ...</tt> parses as a pattern
--   binding, just like <tt>(f :: a -&gt; a) = ... </tt>
--   
--   Strict bindings have their strictness recorded in the
--   <tt>SrcStrictness</tt> of their <tt>MatchContext</tt>. See Note
--   [FunBind vs PatBind] for details about the relationship between
--   FunBind and PatBind.
FunBind :: XFunBind idL idR -> LIdP idL -> MatchGroup idR (LHsExpr idR) -> HsBindLR idL idR
[fun_ext] :: HsBindLR idL idR -> XFunBind idL idR
[fun_id] :: HsBindLR idL idR -> LIdP idL

-- | The payload
[fun_matches] :: HsBindLR idL idR -> MatchGroup idR (LHsExpr idR)

-- | Pattern Binding
--   
--   The pattern is never a simple variable; That case is done by FunBind.
--   See Note [FunBind vs PatBind] for details about the relationship
--   between FunBind and PatBind.
PatBind :: XPatBind idL idR -> LPat idL -> HsMultAnn idL -> GRHSs idR (LHsExpr idR) -> HsBindLR idL idR
[pat_ext] :: HsBindLR idL idR -> XPatBind idL idR
[pat_lhs] :: HsBindLR idL idR -> LPat idL

-- | See Note [Multiplicity annotations].
[pat_mult] :: HsBindLR idL idR -> HsMultAnn idL
[pat_rhs] :: HsBindLR idL idR -> GRHSs idR (LHsExpr idR)

-- | Variable Binding
--   
--   Dictionary binding and suchlike. All VarBinds are introduced by the
--   type checker
VarBind :: XVarBind idL idR -> IdP idL -> LHsExpr idR -> HsBindLR idL idR
[var_ext] :: HsBindLR idL idR -> XVarBind idL idR
[var_id] :: HsBindLR idL idR -> IdP idL

-- | Located only for consistency
[var_rhs] :: HsBindLR idL idR -> LHsExpr idR

-- | Patterns Synonym Binding
PatSynBind :: XPatSynBind idL idR -> PatSynBind idL idR -> HsBindLR idL idR
XHsBindsLR :: !XXHsBindsLR idL idR -> HsBindLR idL idR

-- | Pattern Synonym binding
data PatSynBind idL idR
PSB :: XPSB idL idR -> LIdP idL -> HsPatSynDetails idR -> LPat idR -> HsPatSynDir idR -> PatSynBind idL idR
[psb_ext] :: PatSynBind idL idR -> XPSB idL idR

-- | Name of the pattern synonym
[psb_id] :: PatSynBind idL idR -> LIdP idL

-- | Formal parameter names
[psb_args] :: PatSynBind idL idR -> HsPatSynDetails idR

-- | Right-hand side
[psb_def] :: PatSynBind idL idR -> LPat idR

-- | Directionality
[psb_dir] :: PatSynBind idL idR -> HsPatSynDir idR
XPatSynBind :: !XXPatSynBind idL idR -> PatSynBind idL idR

-- | Multiplicity annotations, on binders, are always resolved (to a
--   unification variable if there is no annotation) during type-checking.
--   The resolved multiplicity is stored in the extension fields.
data HsMultAnn pass
HsNoMultAnn :: !XNoMultAnn pass -> HsMultAnn pass
HsPct1Ann :: !XPct1Ann pass -> HsMultAnn pass
HsMultAnn :: !XMultAnn pass -> LHsType (NoGhcTc pass) -> HsMultAnn pass
XMultAnn :: !XXMultAnn pass -> HsMultAnn pass
type family XNoMultAnn p
type family XPct1Ann p
type family XMultAnn p
type family XXMultAnn p

-- | Haskell Implicit Parameter Bindings
data HsIPBinds id
IPBinds :: XIPBinds id -> [LIPBind id] -> HsIPBinds id
XHsIPBinds :: !XXHsIPBinds id -> HsIPBinds id

-- | Located Implicit Parameter Binding
type LIPBind id = XRec id IPBind id

-- | Implicit parameter bindings.
data IPBind id
IPBind :: XCIPBind id -> XRec id HsIPName -> LHsExpr id -> IPBind id
XIPBind :: !XXIPBind id -> IPBind id

-- | Located Signature
type LSig pass = XRec pass Sig pass

-- | Signatures and pragmas
data Sig pass

-- | An ordinary type signature
--   
--   <pre>
--   f :: Num a =&gt; a -&gt; a
--   </pre>
--   
--   After renaming, this list of Names contains the named wildcards
--   brought into scope by this signature. For a signature <tt>_ -&gt; _a
--   -&gt; Bool</tt>, the renamer will leave the unnamed wildcard
--   <tt>_</tt> untouched, and the named wildcard <tt>_a</tt> is then
--   replaced with fresh meta vars in the type. Their names are stored in
--   the type signature that brought them into scope, in this third field
--   to be more specific.
TypeSig :: XTypeSig pass -> [LIdP pass] -> LHsSigWcType pass -> Sig pass

-- | A pattern synonym type signature
--   
--   <pre>
--   pattern Single :: () =&gt; (Show a) =&gt; a -&gt; [a]
--   </pre>
PatSynSig :: XPatSynSig pass -> [LIdP pass] -> LHsSigType pass -> Sig pass

-- | A signature for a class method False: ordinary class-method signature
--   True: generic-default class method signature e.g. class C a where op
--   :: a -&gt; a -- Ordinary default op :: Eq a =&gt; a -&gt; a -- Generic
--   default No wildcards allowed here
ClassOpSig :: XClassOpSig pass -> Bool -> [LIdP pass] -> LHsSigType pass -> Sig pass

-- | An ordinary fixity declaration
--   
--   <pre>
--   infixl 8 ***
--   </pre>
FixSig :: XFixSig pass -> FixitySig pass -> Sig pass

-- | An inline pragma
--   
--   <pre>
--   {#- INLINE f #-}
--   </pre>
InlineSig :: XInlineSig pass -> LIdP pass -> InlinePragma -> Sig pass

-- | A specialisation pragma
--   
--   <pre>
--   {-# SPECIALISE f :: Int -&gt; Int #-}
--   </pre>
SpecSig :: XSpecSig pass -> LIdP pass -> [LHsSigType pass] -> InlinePragma -> Sig pass

-- | A specialisation pragma for instance declarations only
--   
--   <pre>
--   {-# SPECIALISE instance Eq [Int] #-}
--   </pre>
--   
--   (Class tys); should be a specialisation of the current instance
--   declaration
SpecInstSig :: XSpecInstSig pass -> LHsSigType pass -> Sig pass

-- | A minimal complete definition pragma
--   
--   <pre>
--   {-# MINIMAL a | (b, c | (d | e)) #-}
--   </pre>
MinimalSig :: XMinimalSig pass -> LBooleanFormula (LIdP pass) -> Sig pass

-- | A "set cost centre" pragma for declarations
--   
--   <pre>
--   {-# SCC funName #-}
--   </pre>
--   
--   or
--   
--   <pre>
--   {-# SCC funName "cost_centre_name" #-}
--   </pre>
SCCFunSig :: XSCCFunSig pass -> LIdP pass -> Maybe (XRec pass StringLiteral) -> Sig pass

-- | A complete match pragma
--   
--   <pre>
--   {-# COMPLETE C, D [:: T] #-}
--   </pre>
--   
--   Used to inform the pattern match checker about additional complete
--   matchings which, for example, arise from pattern synonym definitions.
CompleteMatchSig :: XCompleteMatchSig pass -> [LIdP pass] -> Maybe (LIdP pass) -> Sig pass
XSig :: !XXSig pass -> Sig pass

-- | Located Fixity Signature
type LFixitySig pass = XRec pass FixitySig pass

-- | Fixity Signature
data FixitySig pass
FixitySig :: XFixitySig pass -> [LIdP pass] -> Fixity -> FixitySig pass
XFixitySig :: !XXFixitySig pass -> FixitySig pass
isFixityLSig :: UnXRec p => LSig p -> Bool
isTypeLSig :: UnXRec p => LSig p -> Bool
isSpecLSig :: UnXRec p => LSig p -> Bool
isSpecInstLSig :: UnXRec p => LSig p -> Bool
isPragLSig :: UnXRec p => LSig p -> Bool
isInlineLSig :: UnXRec p => LSig p -> Bool
isMinimalLSig :: UnXRec p => LSig p -> Bool
isSCCFunSig :: UnXRec p => LSig p -> Bool
isCompleteMatchSig :: UnXRec p => LSig p -> Bool

-- | Haskell Pattern Synonym Details
type HsPatSynDetails pass = HsConDetails Void LIdP pass [RecordPatSynField pass]

-- | Record Pattern Synonym Field
data RecordPatSynField pass
RecordPatSynField :: FieldOcc pass -> LIdP pass -> RecordPatSynField pass

-- | Field label visible in rest of the file
[recordPatSynField] :: RecordPatSynField pass -> FieldOcc pass

-- | Filled in by renamer, the name used internally by the pattern
[recordPatSynPatVar] :: RecordPatSynField pass -> LIdP pass

-- | Haskell Pattern Synonym Direction
data HsPatSynDir id
Unidirectional :: HsPatSynDir id
ImplicitBidirectional :: HsPatSynDir id
ExplicitBidirectional :: MatchGroup id (LHsExpr id) -> HsPatSynDir id

module Language.Haskell.Syntax.ImpExp

-- | Located Import Declaration
type LImportDecl pass = XRec pass ImportDecl pass

-- | If/how an import is <tt>qualified</tt>.
data ImportDeclQualifiedStyle

-- | <tt>qualified</tt> appears in prepositive position.
QualifiedPre :: ImportDeclQualifiedStyle

-- | <tt>qualified</tt> appears in postpositive position.
QualifiedPost :: ImportDeclQualifiedStyle

-- | Not qualified.
NotQualified :: ImportDeclQualifiedStyle

-- | Indicates whether a module name is referring to a boot interface
--   (hs-boot file) or regular module (hs file). We need to treat boot
--   modules specially when building compilation graphs, since they break
--   cycles. Regular source files and signature files are treated
--   equivalently.
data IsBootInterface
NotBoot :: IsBootInterface
IsBoot :: IsBootInterface

-- | Import Declaration
--   
--   A single Haskell <tt>import</tt> declaration.
data ImportDecl pass
ImportDecl :: XCImportDecl pass -> XRec pass ModuleName -> ImportDeclPkgQual pass -> IsBootInterface -> Bool -> ImportDeclQualifiedStyle -> Maybe (XRec pass ModuleName) -> Maybe (ImportListInterpretation, XRec pass [LIE pass]) -> ImportDecl pass

-- | Locations of keywords like <tt>import</tt>, <tt>qualified</tt>, etc.
--   are captured here.
[ideclExt] :: ImportDecl pass -> XCImportDecl pass

-- | Module name.
[ideclName] :: ImportDecl pass -> XRec pass ModuleName

-- | Package qualifier.
[ideclPkgQual] :: ImportDecl pass -> ImportDeclPkgQual pass

-- | IsBoot &lt;=&gt; {-# SOURCE #-} import
[ideclSource] :: ImportDecl pass -> IsBootInterface

-- | True =&gt; safe import
[ideclSafe] :: ImportDecl pass -> Bool

-- | If/how the import is qualified.
[ideclQualified] :: ImportDecl pass -> ImportDeclQualifiedStyle

-- | as Module
[ideclAs] :: ImportDecl pass -> Maybe (XRec pass ModuleName)

-- | Explicit import list (EverythingBut =&gt; hiding, names)
[ideclImportList] :: ImportDecl pass -> Maybe (ImportListInterpretation, XRec pass [LIE pass])
XImportDecl :: !XXImportDecl pass -> ImportDecl pass

-- | Whether the import list is exactly what to import, or whether
--   <tt>hiding</tt> was used, and therefore everything but what was listed
--   should be imported
data ImportListInterpretation
Exactly :: ImportListInterpretation
EverythingBut :: ImportListInterpretation

-- | Located Import or Export
type LIE pass = XRec pass IE pass

-- | A docstring attached to an export list item.
type ExportDoc pass = LHsDoc pass

-- | Imported or exported entity.
data IE pass

-- | Imported or exported variable
--   
--   <pre>
--   module Mod ( test )
--   import Mod ( test )
--   </pre>
IEVar :: XIEVar pass -> LIEWrappedName pass -> Maybe (ExportDoc pass) -> IE pass

-- | Imported or exported Thing with absent subordinate list
--   
--   The thing is a Class/Type (can't tell)
--   
--   <pre>
--   module Mod ( Test )
--   import Mod ( Test )
--   </pre>
IEThingAbs :: XIEThingAbs pass -> LIEWrappedName pass -> Maybe (ExportDoc pass) -> IE pass

-- | Imported or exported thing with wildcard subordinate list (e.g.
--   <tt>(..)</tt>)
--   
--   The thing is a Class/Type and the All refers to methods/constructors
--   
--   <pre>
--   module Mod ( Test(..) )
--   import Mod ( Test(..) )
--   </pre>
IEThingAll :: XIEThingAll pass -> LIEWrappedName pass -> Maybe (ExportDoc pass) -> IE pass

-- | Imported or exported thing with explicit subordinate list.
--   
--   The thing is a Class/Type (can't tell) and the imported or exported
--   things are its children.
--   
--   <pre>
--   module Mod ( Test(f, g) )
--   import Mod ( Test(f, g) )
--   </pre>
IEThingWith :: XIEThingWith pass -> LIEWrappedName pass -> IEWildcard -> [LIEWrappedName pass] -> Maybe (ExportDoc pass) -> IE pass

-- | Export of entire module. Can only occur in export list.
--   
--   <pre>
--   module Mod ( module Mod2 )
--   </pre>
IEModuleContents :: XIEModuleContents pass -> XRec pass ModuleName -> IE pass

-- | A Haddock section in an export list.
--   
--   <pre>
--   module Mod
--     ( -- * Section heading
--       ...
--     )
--   </pre>
IEGroup :: XIEGroup pass -> Int -> LHsDoc pass -> IE pass

-- | A bit of unnamed documentation.
--   
--   <pre>
--   module Mod
--     ( -- | Documentation
--       ...
--     )
--   </pre>
IEDoc :: XIEDoc pass -> LHsDoc pass -> IE pass

-- | A reference to a named documentation chunk.
--   
--   <pre>
--   module Mod
--     ( -- $chunkName
--       ...
--     )
--   </pre>
IEDocNamed :: XIEDocNamed pass -> String -> IE pass
XIE :: !XXIE pass -> IE pass

-- | Wildcard in an import or export sublist, like the <tt>..</tt> in
--   <tt>import Mod ( T(Mk1, Mk2, ..) )</tt>.
data IEWildcard

-- | no wildcard in this list
NoIEWildcard :: IEWildcard

-- | wildcard after the given # of items in this list The <tt>Int</tt> is
--   in the range [0..n], where n is the length of the list.
IEWildcard :: Int -> IEWildcard

-- | A name in an import or export specification which may have adornments.
--   Used primarily for accurate pretty printing of ParsedSource, and API
--   Annotation placement.
data IEWrappedName p

-- | unadorned name, e.g <tt>myFun</tt>
IEName :: XIEName p -> LIdP p -> IEWrappedName p

-- | <tt>default X ()</tt>, see Note [Named default declarations] in
--   GHC.Tc.Gen.Default
IEDefault :: XIEDefault p -> LIdP p -> IEWrappedName p

-- | <pre>
--   pattern X
--   </pre>
--   
--   exactprint: the location of <tt>pattern</tt> keyword is captured via
--   <a>EpaLocation</a>
IEPattern :: XIEPattern p -> LIdP p -> IEWrappedName p

-- | <pre>
--   type (:+:)
--   </pre>
--   
--   exactprint: the location of <tt>type</tt> keyword is captured via
--   <a>EpaLocation</a>
IEType :: XIEType p -> LIdP p -> IEWrappedName p
XIEWrappedName :: !XXIEWrappedName p -> IEWrappedName p

-- | Located name with possible adornment
type LIEWrappedName p = XRec p IEWrappedName p
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.ImpExp.IEWildcard
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.ImpExp.ImportDeclQualifiedStyle
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.ImpExp.ImportListInterpretation
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.ImpExp.IsBootInterface
instance GHC.Classes.Eq Language.Haskell.Syntax.ImpExp.IEWildcard
instance GHC.Classes.Eq Language.Haskell.Syntax.ImpExp.ImportDeclQualifiedStyle
instance GHC.Classes.Eq Language.Haskell.Syntax.ImpExp.ImportListInterpretation
instance GHC.Classes.Eq Language.Haskell.Syntax.ImpExp.IsBootInterface
instance Control.DeepSeq.NFData Language.Haskell.Syntax.ImpExp.ImportListInterpretation
instance Control.DeepSeq.NFData Language.Haskell.Syntax.ImpExp.IsBootInterface
instance GHC.Classes.Ord Language.Haskell.Syntax.ImpExp.IsBootInterface
instance GHC.Internal.Show.Show Language.Haskell.Syntax.ImpExp.IsBootInterface


-- | Warnings for a module
module GHC.Unit.Module.Warnings
newtype WarningCategory
WarningCategory :: FastString -> WarningCategory
mkWarningCategory :: FastString -> WarningCategory

-- | The <tt>deprecations</tt> category is used for all DEPRECATED pragmas
--   and for WARNING pragmas that do not specify a category.
defaultWarningCategory :: WarningCategory

-- | Is this warning category allowed to appear in user-defined WARNING
--   pragmas? It must either be the known category <tt>deprecations</tt>,
--   or be a custom category that begins with <tt>x-</tt> and contains only
--   valid characters (letters, numbers, apostrophes and dashes).
validWarningCategory :: WarningCategory -> Bool
data InWarningCategory
InWarningCategory :: !EpToken "in" -> !SourceText -> LocatedE WarningCategory -> InWarningCategory
[iwc_in] :: InWarningCategory -> !EpToken "in"
[iwc_st] :: InWarningCategory -> !SourceText
[iwc_wc] :: InWarningCategory -> LocatedE WarningCategory
fromWarningCategory :: WarningCategory -> InWarningCategory

-- | A finite or infinite set of warning categories.
--   
--   Unlike <tt>WarningFlag</tt>, there are (in principle) infinitely many
--   warning categories, so we cannot necessarily enumerate all of them.
--   However the set is constructed by adding or removing categories one at
--   a time, so we can represent it as either a finite set of categories,
--   or a cofinite set (where we store the complement).
data WarningCategorySet

-- | The empty set of warning categories.
emptyWarningCategorySet :: WarningCategorySet

-- | The set consisting of all possible warning categories.
completeWarningCategorySet :: WarningCategorySet

-- | Is this set empty?
nullWarningCategorySet :: WarningCategorySet -> Bool

-- | Does this warning category belong to the set?
elemWarningCategorySet :: WarningCategory -> WarningCategorySet -> Bool

-- | Insert an element into a warning category set.
insertWarningCategorySet :: WarningCategory -> WarningCategorySet -> WarningCategorySet

-- | Delete an element from a warning category set.
deleteWarningCategorySet :: WarningCategory -> WarningCategorySet -> WarningCategorySet

-- | Warning information from a module
data Warnings pass
WarnSome :: DeclWarnOccNames pass -> ExportWarnNames pass -> Warnings pass

-- | Whole module deprecated
WarnAll :: WarningTxt pass -> Warnings pass

-- | Warning Text
--   
--   reason/explanation from a WARNING or DEPRECATED pragma
data WarningTxt pass
WarningTxt :: Maybe (LocatedE InWarningCategory) -> SourceText -> [LocatedE (WithHsDocIdentifiers StringLiteral pass)] -> WarningTxt pass
DeprecatedTxt :: SourceText -> [LocatedE (WithHsDocIdentifiers StringLiteral pass)] -> WarningTxt pass
type LWarningTxt pass = XRec pass WarningTxt pass

-- | Deprecated declarations
type DeclWarnOccNames pass = [(OccName, WarningTxt pass)]

-- | Names that are deprecated as exports
type ExportWarnNames pass = [(Name, WarningTxt pass)]

-- | To which warning category does this WARNING or DEPRECATED pragma
--   belong? See Note [Warning categories].
warningTxtCategory :: WarningTxt pass -> WarningCategory

-- | The message that the WarningTxt was specified to output
warningTxtMessage :: WarningTxt p -> [LocatedE (WithHsDocIdentifiers StringLiteral p)]

-- | True if the 2 WarningTxts have the same category and messages
warningTxtSame :: WarningTxt p1 -> WarningTxt p2 -> Bool
pprWarningTxtForMsg :: WarningTxt p -> SDoc
emptyWarn :: Warnings p

-- | Constructs the cache for the <tt>mi_decl_warn_fn</tt> field of a
--   <tt>ModIface</tt>
mkIfaceDeclWarnCache :: Warnings p -> OccName -> Maybe (WarningTxt p)

-- | Constructs the cache for the <tt>mi_export_warn_fn</tt> field of a
--   <tt>ModIface</tt>
mkIfaceExportWarnCache :: Warnings p -> Name -> Maybe (WarningTxt p)
emptyIfaceWarnCache :: name -> Maybe (WarningTxt p)
insertWarnDecls :: Warnings p -> [(OccName, WarningTxt p)] -> Warnings p
insertWarnExports :: Warnings p -> [(Name, WarningTxt p)] -> Warnings p
instance GHC.Utils.Binary.Binary GHC.Unit.Module.Warnings.WarningCategory
instance GHC.Internal.Data.Data.Data GHC.Unit.Module.Warnings.InWarningCategory
instance GHC.Internal.Data.Data.Data GHC.Unit.Module.Warnings.WarningCategory
instance (GHC.Internal.Data.Data.Data pass, GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Extension.IdP pass)) => GHC.Internal.Data.Data.Data (GHC.Unit.Module.Warnings.WarningTxt pass)
instance GHC.Classes.Eq GHC.Unit.Module.Warnings.InWarningCategory
instance GHC.Classes.Eq GHC.Unit.Module.Warnings.WarningCategory
instance GHC.Classes.Eq (Language.Haskell.Syntax.Extension.IdP pass) => GHC.Classes.Eq (GHC.Unit.Module.Warnings.WarningTxt pass)
instance GHC.Classes.Eq (Language.Haskell.Syntax.Extension.IdP pass) => GHC.Classes.Eq (GHC.Unit.Module.Warnings.Warnings pass)
instance GHC.Internal.Generics.Generic (GHC.Unit.Module.Warnings.WarningTxt pass)
instance Control.DeepSeq.NFData GHC.Unit.Module.Warnings.WarningCategory
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.Warnings.InWarningCategory
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.Warnings.WarningCategory
instance GHC.Utils.Outputable.Outputable (GHC.Unit.Module.Warnings.WarningTxt pass)
instance GHC.Internal.Show.Show GHC.Unit.Module.Warnings.WarningCategory
instance GHC.Types.Unique.Uniquable GHC.Unit.Module.Warnings.WarningCategory


-- | Abstract syntax of global declarations.
--   
--   Definitions for: <tt>SynDecl</tt> and <tt>ConDecl</tt>,
--   <tt>ClassDecl</tt>, <tt>InstDecl</tt>, <tt>DefaultDecl</tt> and
--   <tt>ForeignDecl</tt>.
module Language.Haskell.Syntax.Decls

-- | A Haskell Declaration
data HsDecl p

-- | Type or Class Declaration
TyClD :: XTyClD p -> TyClDecl p -> HsDecl p

-- | Instance declaration
InstD :: XInstD p -> InstDecl p -> HsDecl p

-- | Deriving declaration
DerivD :: XDerivD p -> DerivDecl p -> HsDecl p

-- | Value declaration
ValD :: XValD p -> HsBind p -> HsDecl p

-- | Signature declaration
SigD :: XSigD p -> Sig p -> HsDecl p

-- | Standalone kind signature
KindSigD :: XKindSigD p -> StandaloneKindSig p -> HsDecl p

-- | 'default' declaration
DefD :: XDefD p -> DefaultDecl p -> HsDecl p

-- | Foreign declaration
ForD :: XForD p -> ForeignDecl p -> HsDecl p

-- | Warning declaration
WarningD :: XWarningD p -> WarnDecls p -> HsDecl p

-- | Annotation declaration
AnnD :: XAnnD p -> AnnDecl p -> HsDecl p

-- | Rule declaration
RuleD :: XRuleD p -> RuleDecls p -> HsDecl p

-- | Splice declaration (Includes quasi-quotes)
SpliceD :: XSpliceD p -> SpliceDecl p -> HsDecl p

-- | Documentation comment declaration
DocD :: XDocD p -> DocDecl p -> HsDecl p

-- | Role annotation declaration
RoleAnnotD :: XRoleAnnotD p -> RoleAnnotDecl p -> HsDecl p
XHsDecl :: !XXHsDecl p -> HsDecl p
type LHsDecl p = XRec p HsDecl p

-- | Haskell Data type Definition
data HsDataDefn pass

-- | Declares a data type or newtype, giving its constructors <tt>
--   data/newtype T a = <a>constrs</a> data/newtype instance T [a] =
--   <a>constrs</a> </tt>
HsDataDefn :: XCHsDataDefn pass -> Maybe (LHsContext pass) -> Maybe (XRec pass CType) -> Maybe (LHsKind pass) -> DataDefnCons (LConDecl pass) -> HsDeriving pass -> HsDataDefn pass
[dd_ext] :: HsDataDefn pass -> XCHsDataDefn pass

-- | Context
[dd_ctxt] :: HsDataDefn pass -> Maybe (LHsContext pass)
[dd_cType] :: HsDataDefn pass -> Maybe (XRec pass CType)

-- | Optional kind signature.
--   
--   <tt>(Just k)</tt> for a GADT-style <tt>data</tt>, or <tt>data
--   instance</tt> decl, with explicit kind sig
--   
--   Always <tt>Nothing</tt> for H98-syntax decls
[dd_kindSig] :: HsDataDefn pass -> Maybe (LHsKind pass)

-- | Data constructors
--   
--   For <tt>data T a = T1 | T2 a</tt> the <a>LConDecl</a>s all have
--   <a>ConDeclH98</a>. For <tt>data T a where { T1 :: T a }</tt> the
--   <tt>LConDecls</tt> all have <a>ConDeclGADT</a>.
[dd_cons] :: HsDataDefn pass -> DataDefnCons (LConDecl pass)

-- | Optional 'deriving' clause
[dd_derivs] :: HsDataDefn pass -> HsDeriving pass
XHsDataDefn :: !XXHsDataDefn pass -> HsDataDefn pass

-- | Haskell Deriving clause
type HsDeriving pass = [LHsDerivingClause pass]
type LHsFunDep pass = XRec pass FunDep pass
data FunDep pass
FunDep :: XCFunDep pass -> [LIdP pass] -> [LIdP pass] -> FunDep pass
XFunDep :: !XXFunDep pass -> FunDep pass

-- | A single <tt>deriving</tt> clause of a data declaration.
data HsDerivingClause pass
HsDerivingClause :: XCHsDerivingClause pass -> Maybe (LDerivStrategy pass) -> LDerivClauseTys pass -> HsDerivingClause pass
[deriv_clause_ext] :: HsDerivingClause pass -> XCHsDerivingClause pass

-- | The user-specified strategy (if any) to use when deriving
--   <a>deriv_clause_tys</a>.
[deriv_clause_strategy] :: HsDerivingClause pass -> Maybe (LDerivStrategy pass)

-- | The types to derive.
[deriv_clause_tys] :: HsDerivingClause pass -> LDerivClauseTys pass
XHsDerivingClause :: !XXHsDerivingClause pass -> HsDerivingClause pass
type LHsDerivingClause pass = XRec pass HsDerivingClause pass

-- | The types mentioned in a single <tt>deriving</tt> clause. This can
--   come in two forms, <a>DctSingle</a> or <a>DctMulti</a>, depending on
--   whether the types are surrounded by enclosing parentheses or not.
--   These parentheses are semantically different than <a>HsParTy</a>. For
--   example, <tt>deriving ()</tt> means "derive zero classes" rather than
--   "derive an instance of the 0-tuple".
--   
--   <a>DerivClauseTys</a> use <a>LHsSigType</a> because <tt>deriving</tt>
--   clauses can mention type variables that aren't bound by the datatype,
--   e.g.
--   
--   <pre>
--   data T b = ... deriving (C [a])
--   </pre>
--   
--   should produce a derived instance for <tt>C [a] (T b)</tt>.
data DerivClauseTys pass

-- | A <tt>deriving</tt> clause with a single type. Moreover, that type can
--   only be a type constructor without any arguments.
--   
--   Example: <tt>deriving Eq</tt>
DctSingle :: XDctSingle pass -> LHsSigType pass -> DerivClauseTys pass

-- | A <tt>deriving</tt> clause with a comma-separated list of types,
--   surrounded by enclosing parentheses.
--   
--   Example: <tt>deriving (Eq, C a)</tt>
DctMulti :: XDctMulti pass -> [LHsSigType pass] -> DerivClauseTys pass
XDerivClauseTys :: !XXDerivClauseTys pass -> DerivClauseTys pass
type LDerivClauseTys pass = XRec pass DerivClauseTys pass

-- | When we only care whether a data-type declaration is `data` or
--   `newtype`, but not what constructors it has
data NewOrData

-- | <pre>
--   newtype Blah ...
--   </pre>
NewType :: NewOrData

-- | <pre>
--   data Blah ...
--   </pre>
DataType :: NewOrData

-- | Whether a data-type declaration is <tt>data</tt> or <tt>newtype</tt>,
--   and its constructors.
data DataDefnCons a
NewTypeCon :: a -> DataDefnCons a
DataTypeCons :: Bool -> [a] -> DataDefnCons a
dataDefnConsNewOrData :: DataDefnCons a -> NewOrData

-- | Are the constructors within a <tt>type data</tt> declaration? See Note
--   [Type data declarations] in GHC.Rename.Module.
isTypeDataDefnCons :: DataDefnCons a -> Bool

-- | Retrieve the first data constructor in a <a>DataDefnCons</a> (if one
--   exists).
firstDataDefnCon :: DataDefnCons a -> Maybe a
data StandaloneKindSig pass
StandaloneKindSig :: XStandaloneKindSig pass -> LIdP pass -> LHsSigType pass -> StandaloneKindSig pass
XStandaloneKindSig :: !XXStandaloneKindSig pass -> StandaloneKindSig pass

-- | Located Standalone Kind Signature
type LStandaloneKindSig pass = XRec pass StandaloneKindSig pass

-- | A type or class declaration.
data TyClDecl pass

-- | <pre>
--   type/data family T :: *-&gt;*
--   </pre>
FamDecl :: XFamDecl pass -> FamilyDecl pass -> TyClDecl pass
[tcdFExt] :: TyClDecl pass -> XFamDecl pass
[tcdFam] :: TyClDecl pass -> FamilyDecl pass

-- | <tt>type</tt> declaration
SynDecl :: XSynDecl pass -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> LHsType pass -> TyClDecl pass

-- | Post renamer, FVs
[tcdSExt] :: TyClDecl pass -> XSynDecl pass

-- | Type constructor
[tcdLName] :: TyClDecl pass -> LIdP pass

-- | Type variables; for an associated type these include outer binders
[tcdTyVars] :: TyClDecl pass -> LHsQTyVars pass

-- | Fixity used in the declaration
[tcdFixity] :: TyClDecl pass -> LexicalFixity

-- | RHS of type declaration
[tcdRhs] :: TyClDecl pass -> LHsType pass

-- | <tt>data</tt> declaration
DataDecl :: XDataDecl pass -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> HsDataDefn pass -> TyClDecl pass

-- | Post renamer, CUSK flag, FVs
[tcdDExt] :: TyClDecl pass -> XDataDecl pass

-- | Type constructor
[tcdLName] :: TyClDecl pass -> LIdP pass

-- | Type variables; for an associated type these include outer binders
[tcdTyVars] :: TyClDecl pass -> LHsQTyVars pass

-- | Fixity used in the declaration
[tcdFixity] :: TyClDecl pass -> LexicalFixity
[tcdDataDefn] :: TyClDecl pass -> HsDataDefn pass
ClassDecl :: XClassDecl pass -> Maybe (LHsContext pass) -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> [LHsFunDep pass] -> [LSig pass] -> LHsBinds pass -> [LFamilyDecl pass] -> [LTyFamDefltDecl pass] -> [LDocDecl pass] -> TyClDecl pass

-- | Post renamer, FVs
[tcdCExt] :: TyClDecl pass -> XClassDecl pass

-- | Context...
[tcdCtxt] :: TyClDecl pass -> Maybe (LHsContext pass)

-- | Type constructor
[tcdLName] :: TyClDecl pass -> LIdP pass

-- | Type variables; for an associated type these include outer binders
[tcdTyVars] :: TyClDecl pass -> LHsQTyVars pass

-- | Fixity used in the declaration
[tcdFixity] :: TyClDecl pass -> LexicalFixity

-- | Functional deps
[tcdFDs] :: TyClDecl pass -> [LHsFunDep pass]

-- | Methods' signatures
[tcdSigs] :: TyClDecl pass -> [LSig pass]

-- | Default methods
[tcdMeths] :: TyClDecl pass -> LHsBinds pass

-- | Associated types;
[tcdATs] :: TyClDecl pass -> [LFamilyDecl pass]

-- | Associated type defaults
[tcdATDefs] :: TyClDecl pass -> [LTyFamDefltDecl pass]

-- | Haddock docs
[tcdDocs] :: TyClDecl pass -> [LDocDecl pass]
XTyClDecl :: !XXTyClDecl pass -> TyClDecl pass

-- | Located Declaration of a Type or Class
type LTyClDecl pass = XRec pass TyClDecl pass

-- | Type or Class Group
data TyClGroup pass
TyClGroup :: XCTyClGroup pass -> [LTyClDecl pass] -> [LRoleAnnotDecl pass] -> [LStandaloneKindSig pass] -> [LInstDecl pass] -> TyClGroup pass
[group_ext] :: TyClGroup pass -> XCTyClGroup pass
[group_tyclds] :: TyClGroup pass -> [LTyClDecl pass]
[group_roles] :: TyClGroup pass -> [LRoleAnnotDecl pass]
[group_kisigs] :: TyClGroup pass -> [LStandaloneKindSig pass]
[group_instds] :: TyClGroup pass -> [LInstDecl pass]
XTyClGroup :: !XXTyClGroup pass -> TyClGroup pass
tyClGroupTyClDecls :: [TyClGroup pass] -> [LTyClDecl pass]
tyClGroupInstDecls :: [TyClGroup pass] -> [LInstDecl pass]
tyClGroupRoleDecls :: [TyClGroup pass] -> [LRoleAnnotDecl pass]
tyClGroupKindSigs :: [TyClGroup pass] -> [LStandaloneKindSig pass]

-- | type class
isClassDecl :: TyClDecl pass -> Bool

-- | <tt>True</tt> <a>=</a> argument is a <tt>data</tt>/<tt>newtype</tt>
--   declaration.
isDataDecl :: TyClDecl pass -> Bool

-- | type or type instance declaration
isSynDecl :: TyClDecl pass -> Bool

-- | type/data family declaration
isFamilyDecl :: TyClDecl pass -> Bool

-- | type family declaration
isTypeFamilyDecl :: TyClDecl pass -> Bool

-- | data family declaration
isDataFamilyDecl :: TyClDecl pass -> Bool

-- | open type family info
isOpenTypeFamilyInfo :: FamilyInfo pass -> Bool

-- | closed type family info
isClosedTypeFamilyInfo :: FamilyInfo pass -> Bool
tyClDeclTyVars :: TyClDecl pass -> LHsQTyVars pass

-- | type Family Declaration
data FamilyDecl pass
FamilyDecl :: XCFamilyDecl pass -> FamilyInfo pass -> TopLevelFlag -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> LFamilyResultSig pass -> Maybe (LInjectivityAnn pass) -> FamilyDecl pass
[fdExt] :: FamilyDecl pass -> XCFamilyDecl pass
[fdInfo] :: FamilyDecl pass -> FamilyInfo pass
[fdTopLevel] :: FamilyDecl pass -> TopLevelFlag
[fdLName] :: FamilyDecl pass -> LIdP pass
[fdTyVars] :: FamilyDecl pass -> LHsQTyVars pass
[fdFixity] :: FamilyDecl pass -> LexicalFixity
[fdResultSig] :: FamilyDecl pass -> LFamilyResultSig pass
[fdInjectivityAnn] :: FamilyDecl pass -> Maybe (LInjectivityAnn pass)
XFamilyDecl :: !XXFamilyDecl pass -> FamilyDecl pass

-- | Located type Family Declaration
type LFamilyDecl pass = XRec pass FamilyDecl pass

-- | Instance Declaration
data InstDecl pass
ClsInstD :: XClsInstD pass -> ClsInstDecl pass -> InstDecl pass
[cid_d_ext] :: InstDecl pass -> XClsInstD pass
[cid_inst] :: InstDecl pass -> ClsInstDecl pass
DataFamInstD :: XDataFamInstD pass -> DataFamInstDecl pass -> InstDecl pass
[dfid_ext] :: InstDecl pass -> XDataFamInstD pass
[dfid_inst] :: InstDecl pass -> DataFamInstDecl pass
TyFamInstD :: XTyFamInstD pass -> TyFamInstDecl pass -> InstDecl pass
[tfid_ext] :: InstDecl pass -> XTyFamInstD pass
[tfid_inst] :: InstDecl pass -> TyFamInstDecl pass
XInstDecl :: !XXInstDecl pass -> InstDecl pass

-- | Located Instance Declaration
type LInstDecl pass = XRec pass InstDecl pass
data FamilyInfo pass
DataFamily :: FamilyInfo pass
OpenTypeFamily :: FamilyInfo pass

-- | <a>Nothing</a> if we're in an hs-boot file and the user said "type
--   family Foo x where .."
ClosedTypeFamily :: Maybe [LTyFamInstEqn pass] -> FamilyInfo pass
familyInfoTyConFlavour :: Maybe tc -> FamilyInfo pass -> TyConFlavour tc

-- | Type Family Instance Declaration
data TyFamInstDecl pass
TyFamInstDecl :: XCTyFamInstDecl pass -> TyFamInstEqn pass -> TyFamInstDecl pass
[tfid_xtn] :: TyFamInstDecl pass -> XCTyFamInstDecl pass
[tfid_eqn] :: TyFamInstDecl pass -> TyFamInstEqn pass
XTyFamInstDecl :: !XXTyFamInstDecl pass -> TyFamInstDecl pass

-- | Located Type Family Instance Declaration
type LTyFamInstDecl pass = XRec pass TyFamInstDecl pass

-- | Type family default declarations. A convenient synonym for
--   <a>TyFamInstDecl</a>. See <tt>Note [Type family instance declarations
--   in HsSyn]</tt>.
type TyFamDefltDecl = TyFamInstDecl

-- | Located type family default declarations.
type LTyFamDefltDecl pass = XRec pass TyFamDefltDecl pass

-- | Data Family Instance Declaration
newtype DataFamInstDecl pass
DataFamInstDecl :: FamEqn pass (HsDataDefn pass) -> DataFamInstDecl pass
[dfid_eqn] :: DataFamInstDecl pass -> FamEqn pass (HsDataDefn pass)

-- | Located Data Family Instance Declaration
type LDataFamInstDecl pass = XRec pass DataFamInstDecl pass

-- | Family Equation
--   
--   One equation in a type family instance declaration, data family
--   instance declaration, or type family default. See Note [Type family
--   instance declarations in HsSyn] See Note [Family instance declaration
--   binders]
data FamEqn pass rhs
FamEqn :: XCFamEqn pass rhs -> LIdP pass -> HsOuterFamEqnTyVarBndrs pass -> HsFamEqnPats pass -> LexicalFixity -> rhs -> FamEqn pass rhs
[feqn_ext] :: FamEqn pass rhs -> XCFamEqn pass rhs
[feqn_tycon] :: FamEqn pass rhs -> LIdP pass

-- | Optional quantified type vars
[feqn_bndrs] :: FamEqn pass rhs -> HsOuterFamEqnTyVarBndrs pass
[feqn_pats] :: FamEqn pass rhs -> HsFamEqnPats pass

-- | Fixity used in the declaration
[feqn_fixity] :: FamEqn pass rhs -> LexicalFixity
[feqn_rhs] :: FamEqn pass rhs -> rhs
XFamEqn :: !XXFamEqn pass rhs -> FamEqn pass rhs

-- | Type Family Instance Equation
type TyFamInstEqn pass = FamEqn pass LHsType pass

-- | Located Type Family Instance Equation
type LTyFamInstEqn pass = XRec pass TyFamInstEqn pass

-- | HsFamEqnPats represents patterns on the left-hand side of a type
--   instance, e.g. `type instance F <tt>k (a :: k) = a` has patterns
--   `</tt>k` and `(a :: k)`.
--   
--   HsFamEqnPats used to be called HsTyPats but it was renamed to avoid
--   confusion with a different notion of type patterns, see #23657.
type HsFamEqnPats pass = [LHsTypeArg pass]

-- | Located Class Instance Declaration
type LClsInstDecl pass = XRec pass ClsInstDecl pass

-- | Class Instance Declaration
data ClsInstDecl pass
ClsInstDecl :: XCClsInstDecl pass -> LHsSigType pass -> LHsBinds pass -> [LSig pass] -> [LTyFamInstDecl pass] -> [LDataFamInstDecl pass] -> Maybe (XRec pass OverlapMode) -> ClsInstDecl pass
[cid_ext] :: ClsInstDecl pass -> XCClsInstDecl pass
[cid_poly_ty] :: ClsInstDecl pass -> LHsSigType pass
[cid_binds] :: ClsInstDecl pass -> LHsBinds pass
[cid_sigs] :: ClsInstDecl pass -> [LSig pass]
[cid_tyfam_insts] :: ClsInstDecl pass -> [LTyFamInstDecl pass]
[cid_datafam_insts] :: ClsInstDecl pass -> [LDataFamInstDecl pass]
[cid_overlap_mode] :: ClsInstDecl pass -> Maybe (XRec pass OverlapMode)
XClsInstDecl :: !XXClsInstDecl pass -> ClsInstDecl pass

-- | Stand-alone 'deriving instance' declaration
data DerivDecl pass
DerivDecl :: XCDerivDecl pass -> LHsSigWcType pass -> Maybe (LDerivStrategy pass) -> Maybe (XRec pass OverlapMode) -> DerivDecl pass
[deriv_ext] :: DerivDecl pass -> XCDerivDecl pass

-- | The instance type to derive.
--   
--   It uses an <a>LHsSigWcType</a> because the context is allowed to be a
--   single wildcard:
--   
--   <pre>
--   deriving instance _ =&gt; Eq (Foo a)
--   </pre>
--   
--   Which signifies that the context should be inferred.
[deriv_type] :: DerivDecl pass -> LHsSigWcType pass
[deriv_strategy] :: DerivDecl pass -> Maybe (LDerivStrategy pass)
[deriv_overlap_mode] :: DerivDecl pass -> Maybe (XRec pass OverlapMode)
XDerivDecl :: !XXDerivDecl pass -> DerivDecl pass

-- | Located stand-alone 'deriving instance' declaration
type LDerivDecl pass = XRec pass DerivDecl pass

-- | Which technique the user explicitly requested when deriving an
--   instance.
data DerivStrategy pass

-- | GHC's "standard" strategy, which is to implement a custom instance for
--   the data type. This only works for certain types that GHC knows about
--   (e.g., <a>Eq</a>, <a>Show</a>, <a>Functor</a> when
--   <tt>-XDeriveFunctor</tt> is enabled, etc.)
StockStrategy :: XStockStrategy pass -> DerivStrategy pass

-- | <pre>
--   -XDeriveAnyClass
--   </pre>
AnyclassStrategy :: XAnyClassStrategy pass -> DerivStrategy pass

-- | <pre>
--   -XGeneralizedNewtypeDeriving
--   </pre>
NewtypeStrategy :: XNewtypeStrategy pass -> DerivStrategy pass

-- | <pre>
--   -XDerivingVia
--   </pre>
ViaStrategy :: XViaStrategy pass -> DerivStrategy pass

-- | A <tt>Located</tt> <a>DerivStrategy</a>.
type LDerivStrategy pass = XRec pass DerivStrategy pass

-- | Located Rule Declarations
type LRuleDecls pass = XRec pass RuleDecls pass

-- | Rule Declarations
data RuleDecls pass
HsRules :: XCRuleDecls pass -> [LRuleDecl pass] -> RuleDecls pass
[rds_ext] :: RuleDecls pass -> XCRuleDecls pass
[rds_rules] :: RuleDecls pass -> [LRuleDecl pass]
XRuleDecls :: !XXRuleDecls pass -> RuleDecls pass

-- | Rule Declaration
data RuleDecl pass
HsRule :: XHsRule pass -> XRec pass RuleName -> Activation -> Maybe [LHsTyVarBndr () (NoGhcTc pass)] -> [LRuleBndr pass] -> XRec pass (HsExpr pass) -> XRec pass (HsExpr pass) -> RuleDecl pass

-- | After renamer, free-vars from the LHS and RHS
[rd_ext] :: RuleDecl pass -> XHsRule pass

-- | Note [Pragma source text] in <a>GHC.Types.SourceText</a>
[rd_name] :: RuleDecl pass -> XRec pass RuleName
[rd_act] :: RuleDecl pass -> Activation

-- | Forall'd type vars
[rd_tyvs] :: RuleDecl pass -> Maybe [LHsTyVarBndr () (NoGhcTc pass)]

-- | Forall'd term vars, before typechecking; after typechecking this
--   includes all forall'd vars
[rd_tmvs] :: RuleDecl pass -> [LRuleBndr pass]
[rd_lhs] :: RuleDecl pass -> XRec pass (HsExpr pass)
[rd_rhs] :: RuleDecl pass -> XRec pass (HsExpr pass)
XRuleDecl :: !XXRuleDecl pass -> RuleDecl pass

-- | Located Rule Declaration
type LRuleDecl pass = XRec pass RuleDecl pass

-- | Rule Binder
data RuleBndr pass
RuleBndr :: XCRuleBndr pass -> LIdP pass -> RuleBndr pass
RuleBndrSig :: XRuleBndrSig pass -> LIdP pass -> HsPatSigType pass -> RuleBndr pass
XRuleBndr :: !XXRuleBndr pass -> RuleBndr pass

-- | Located Rule Binder
type LRuleBndr pass = XRec pass RuleBndr pass
collectRuleBndrSigTys :: [RuleBndr pass] -> [HsPatSigType pass]

-- | Default Declaration
data DefaultDecl pass
DefaultDecl :: XCDefaultDecl pass -> Maybe (LIdP pass) -> [LHsType pass] -> DefaultDecl pass
[defd_ext] :: DefaultDecl pass -> XCDefaultDecl pass
[defd_class] :: DefaultDecl pass -> Maybe (LIdP pass)
[defd_defaults] :: DefaultDecl pass -> [LHsType pass]
XDefaultDecl :: !XXDefaultDecl pass -> DefaultDecl pass

-- | Located Default Declaration
type LDefaultDecl pass = XRec pass DefaultDecl pass

-- | A splice can appear with various decorations wrapped around it. This
--   data type captures explicitly how it was originally written, for use
--   in the pretty printer.
data SpliceDecoration

-- | $splice
DollarSplice :: SpliceDecoration

-- | bare splice
BareSplice :: SpliceDecoration

-- | Splice Declaration
data SpliceDecl p
SpliceDecl :: XSpliceDecl p -> XRec p (HsUntypedSplice p) -> SpliceDecoration -> SpliceDecl p
XSpliceDecl :: !XXSpliceDecl p -> SpliceDecl p

-- | Located Splice Declaration
type LSpliceDecl pass = XRec pass SpliceDecl pass

-- | Foreign Declaration
data ForeignDecl pass
ForeignImport :: XForeignImport pass -> LIdP pass -> LHsSigType pass -> ForeignImport pass -> ForeignDecl pass
[fd_i_ext] :: ForeignDecl pass -> XForeignImport pass
[fd_name] :: ForeignDecl pass -> LIdP pass
[fd_sig_ty] :: ForeignDecl pass -> LHsSigType pass
[fd_fi] :: ForeignDecl pass -> ForeignImport pass
ForeignExport :: XForeignExport pass -> LIdP pass -> LHsSigType pass -> ForeignExport pass -> ForeignDecl pass
[fd_e_ext] :: ForeignDecl pass -> XForeignExport pass
[fd_name] :: ForeignDecl pass -> LIdP pass
[fd_sig_ty] :: ForeignDecl pass -> LHsSigType pass
[fd_fe] :: ForeignDecl pass -> ForeignExport pass
XForeignDecl :: !XXForeignDecl pass -> ForeignDecl pass

-- | Located Foreign Declaration
type LForeignDecl pass = XRec pass ForeignDecl pass
data ForeignImport pass
CImport :: XCImport pass -> XRec pass CCallConv -> XRec pass Safety -> Maybe Header -> CImportSpec -> ForeignImport pass
XForeignImport :: !XXForeignImport pass -> ForeignImport pass
data ForeignExport pass
CExport :: XCExport pass -> XRec pass CExportSpec -> ForeignExport pass
XForeignExport :: !XXForeignExport pass -> ForeignExport pass
data CImportSpec
CLabel :: CLabelString -> CImportSpec
CFunction :: CCallTarget -> CImportSpec
CWrapper :: CImportSpec

-- | <pre>
--   data T b = forall a. Eq a =&gt; MkT a b
--     MkT :: forall b a. Eq a =&gt; MkT a b
--   
--   data T b where
--        MkT1 :: Int -&gt; T Int
--   
--   data T = Int <tt>MkT</tt> Int
--          | MkT2
--   
--   data T a where
--        Int <tt>MkT</tt> Int :: T Int
--   </pre>
--   
--   data Constructor Declaration
data ConDecl pass
ConDeclGADT :: XConDeclGADT pass -> NonEmpty (LIdP pass) -> XRec pass (HsOuterSigTyVarBndrs pass) -> Maybe (LHsContext pass) -> HsConDeclGADTDetails pass -> LHsType pass -> Maybe (LHsDoc pass) -> ConDecl pass
[con_g_ext] :: ConDecl pass -> XConDeclGADT pass
[con_names] :: ConDecl pass -> NonEmpty (LIdP pass)

-- | The outermost type variable binders, be they explicit or implicit. The
--   <a>XRec</a> is used to anchor exact print annotations, AnnForall and
--   AnnDot.
[con_bndrs] :: ConDecl pass -> XRec pass (HsOuterSigTyVarBndrs pass)

-- | User-written context (if any)
[con_mb_cxt] :: ConDecl pass -> Maybe (LHsContext pass)

-- | Arguments; never infix
[con_g_args] :: ConDecl pass -> HsConDeclGADTDetails pass

-- | Result type
[con_res_ty] :: ConDecl pass -> LHsType pass

-- | A possible Haddock comment.
[con_doc] :: ConDecl pass -> Maybe (LHsDoc pass)
ConDeclH98 :: XConDeclH98 pass -> LIdP pass -> Bool -> [LHsTyVarBndr Specificity pass] -> Maybe (LHsContext pass) -> HsConDeclH98Details pass -> Maybe (LHsDoc pass) -> ConDecl pass
[con_ext] :: ConDecl pass -> XConDeclH98 pass
[con_name] :: ConDecl pass -> LIdP pass

-- | True <a>=</a> explicit user-written forall e.g. data T a = forall b.
--   MkT b (b-&gt;a) con_ex_tvs = {b} False =&gt; con_ex_tvs is empty
[con_forall] :: ConDecl pass -> Bool

-- | Existentials only
[con_ex_tvs] :: ConDecl pass -> [LHsTyVarBndr Specificity pass]

-- | User-written context (if any)
[con_mb_cxt] :: ConDecl pass -> Maybe (LHsContext pass)

-- | Arguments; can be infix
[con_args] :: ConDecl pass -> HsConDeclH98Details pass

-- | A possible Haddock comment.
[con_doc] :: ConDecl pass -> Maybe (LHsDoc pass)
XConDecl :: !XXConDecl pass -> ConDecl pass

-- | Located data Constructor Declaration
type LConDecl pass = XRec pass ConDecl pass

-- | The arguments in a Haskell98-style data constructor.
type HsConDeclH98Details pass = HsConDetails Void HsScaled pass LBangType pass XRec pass [LConDeclField pass]

-- | The arguments in a GADT constructor. Unlike Haskell98-style
--   constructors, GADT constructors cannot be declared with infix syntax.
--   As a result, we do not use <a>HsConDetails</a> here, as
--   <a>InfixCon</a> would be an unrepresentable state. (There is a notion
--   of infix GADT constructors for the purposes of derived Show
--   instances—see Note [Infix GADT constructors] in GHC.Tc.TyCl—but that
--   is an orthogonal concern.)
data HsConDeclGADTDetails pass
PrefixConGADT :: !XPrefixConGADT pass -> [HsScaled pass (LBangType pass)] -> HsConDeclGADTDetails pass
RecConGADT :: !XRecConGADT pass -> XRec pass [LConDeclField pass] -> HsConDeclGADTDetails pass
XConDeclGADTDetails :: !XXConDeclGADTDetails pass -> HsConDeclGADTDetails pass
type family XPrefixConGADT p
type family XRecConGADT p
type family XXConDeclGADTDetails p

-- | Documentation comment Declaration
data DocDecl pass
DocCommentNext :: LHsDoc pass -> DocDecl pass
DocCommentPrev :: LHsDoc pass -> DocDecl pass
DocCommentNamed :: String -> LHsDoc pass -> DocDecl pass
DocGroup :: Int -> LHsDoc pass -> DocDecl pass

-- | Located Documentation comment Declaration
type LDocDecl pass = XRec pass DocDecl pass
docDeclDoc :: DocDecl pass -> LHsDoc pass

-- | Warning pragma Declaration
data WarnDecl pass
Warning :: XWarning pass -> [LIdP pass] -> WarningTxt pass -> WarnDecl pass
XWarnDecl :: !XXWarnDecl pass -> WarnDecl pass

-- | Located Warning pragma Declaration
type LWarnDecl pass = XRec pass WarnDecl pass

-- | Warning pragma Declarations
data WarnDecls pass
Warnings :: XWarnings pass -> [LWarnDecl pass] -> WarnDecls pass
[wd_ext] :: WarnDecls pass -> XWarnings pass
[wd_warnings] :: WarnDecls pass -> [LWarnDecl pass]
XWarnDecls :: !XXWarnDecls pass -> WarnDecls pass

-- | Located Warning Declarations
type LWarnDecls pass = XRec pass WarnDecls pass

-- | Annotation Declaration
data AnnDecl pass
HsAnnotation :: XHsAnnotation pass -> AnnProvenance pass -> XRec pass (HsExpr pass) -> AnnDecl pass
XAnnDecl :: !XXAnnDecl pass -> AnnDecl pass

-- | Located Annotation Declaration
type LAnnDecl pass = XRec pass AnnDecl pass

-- | Annotation Provenance
data AnnProvenance pass
ValueAnnProvenance :: LIdP pass -> AnnProvenance pass
TypeAnnProvenance :: LIdP pass -> AnnProvenance pass
ModuleAnnProvenance :: AnnProvenance pass
annProvenanceName_maybe :: UnXRec p => AnnProvenance p -> Maybe (IdP p)

-- | Role Annotation Declaration
data RoleAnnotDecl pass
RoleAnnotDecl :: XCRoleAnnotDecl pass -> LIdP pass -> [XRec pass (Maybe Role)] -> RoleAnnotDecl pass
XRoleAnnotDecl :: !XXRoleAnnotDecl pass -> RoleAnnotDecl pass

-- | Located Role Annotation Declaration
type LRoleAnnotDecl pass = XRec pass RoleAnnotDecl pass

-- | type Family Result Signature
data FamilyResultSig pass
NoSig :: XNoSig pass -> FamilyResultSig pass
KindSig :: XCKindSig pass -> LHsKind pass -> FamilyResultSig pass
TyVarSig :: XTyVarSig pass -> LHsTyVarBndr () pass -> FamilyResultSig pass
XFamilyResultSig :: !XXFamilyResultSig pass -> FamilyResultSig pass

-- | Located type Family Result Signature
type LFamilyResultSig pass = XRec pass FamilyResultSig pass

-- | If the user supplied an injectivity annotation it is represented using
--   InjectivityAnn. At the moment this is a single injectivity condition -
--   see Note [Injectivity annotation]. `Located name` stores the LHS of
--   injectivity condition. `[Located name]` stores the RHS of injectivity
--   condition. Example:
--   
--   type family Foo a b c = r | r -&gt; a c where ...
--   
--   This will be represented as "InjectivityAnn <tt>r</tt> [<tt>a</tt>,
--   <tt>c</tt>]"
data InjectivityAnn pass
InjectivityAnn :: XCInjectivityAnn pass -> LIdP pass -> [LIdP pass] -> InjectivityAnn pass
XInjectivityAnn :: !XXInjectivityAnn pass -> InjectivityAnn pass

-- | Located Injectivity Annotation
type LInjectivityAnn pass = XRec pass InjectivityAnn pass

-- | Haskell Group
--   
--   A <a>HsDecl</a> is categorised into a <a>HsGroup</a> before being fed
--   to the renamer.
data HsGroup p
HsGroup :: XCHsGroup p -> HsValBinds p -> [LSpliceDecl p] -> [TyClGroup p] -> [LDerivDecl p] -> [LFixitySig p] -> [LDefaultDecl p] -> [LForeignDecl p] -> [LWarnDecls p] -> [LAnnDecl p] -> [LRuleDecls p] -> [LDocDecl p] -> HsGroup p
[hs_ext] :: HsGroup p -> XCHsGroup p
[hs_valds] :: HsGroup p -> HsValBinds p
[hs_splcds] :: HsGroup p -> [LSpliceDecl p]
[hs_tyclds] :: HsGroup p -> [TyClGroup p]
[hs_derivds] :: HsGroup p -> [LDerivDecl p]
[hs_fixds] :: HsGroup p -> [LFixitySig p]
[hs_defds] :: HsGroup p -> [LDefaultDecl p]
[hs_fords] :: HsGroup p -> [LForeignDecl p]
[hs_warnds] :: HsGroup p -> [LWarnDecls p]
[hs_annds] :: HsGroup p -> [LAnnDecl p]
[hs_ruleds] :: HsGroup p -> [LRuleDecls p]
[hs_docs] :: HsGroup p -> [LDocDecl p]
XHsGroup :: !XXHsGroup p -> HsGroup p
hsGroupInstDecls :: HsGroup id -> [LInstDecl id]
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Decls.CImportSpec
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.DataDefnCons a)
instance (GHC.Internal.Data.Data.Data pass, GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Extension.IdP pass)) => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.DocDecl pass)
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Decls.NewOrData
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Decls.SpliceDecoration
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Haskell.Syntax.Decls.DataDefnCons a)
instance GHC.Classes.Eq Language.Haskell.Syntax.Decls.NewOrData
instance GHC.Classes.Eq Language.Haskell.Syntax.Decls.SpliceDecoration
instance GHC.Internal.Data.Foldable.Foldable Language.Haskell.Syntax.Decls.DataDefnCons
instance GHC.Internal.Base.Functor Language.Haskell.Syntax.Decls.DataDefnCons
instance GHC.Internal.Show.Show Language.Haskell.Syntax.Decls.SpliceDecoration
instance GHC.Internal.Data.Traversable.Traversable Language.Haskell.Syntax.Decls.DataDefnCons

module GHC.Hs.ImpExp
exportDocstring :: LHsDoc pass -> SDoc
ieDeprecation :: forall (p :: Pass). IsPass p => IE (GhcPass p) -> Maybe (WarningTxt (GhcPass p))
ieLWrappedName :: forall (p :: Pass). LIEWrappedName (GhcPass p) -> LIdP (GhcPass p)
ieName :: forall (p :: Pass). IE (GhcPass p) -> IdP (GhcPass p)
ieNames :: forall (p :: Pass). IE (GhcPass p) -> [IdP (GhcPass p)]
ieWrappedLName :: forall (p :: Pass). IEWrappedName (GhcPass p) -> LIdP (GhcPass p)
ieWrappedName :: forall (p :: Pass). IEWrappedName (GhcPass p) -> IdP (GhcPass p)

-- | Given two possible located <tt>qualified</tt> tokens, compute a style
--   (in a conforming Haskell program only one of the two can be not
--   <a>Nothing</a>). This is called from <a>GHC.Parser</a>.
importDeclQualifiedStyle :: Maybe (EpToken "qualified") -> Maybe (EpToken "qualified") -> (Maybe (EpToken "qualified"), ImportDeclQualifiedStyle)

-- | Convenience function to answer the question if an import decl. is
--   qualified.
isImportDeclQualified :: ImportDeclQualifiedStyle -> Bool
lieWrappedName :: forall (p :: Pass). LIEWrappedName (GhcPass p) -> IdP (GhcPass p)
pprImpExp :: (HasOccName name, OutputableBndr name) => name -> SDoc
replaceLWrappedName :: LIEWrappedName GhcPs -> IdP GhcRn -> LIEWrappedName GhcRn
replaceWrappedName :: IEWrappedName GhcPs -> IdP GhcRn -> IEWrappedName GhcRn
simpleImportDecl :: ModuleName -> ImportDecl GhcPs
data EpAnnImportDecl
EpAnnImportDecl :: EpToken "import" -> Maybe (EpaLocation, EpToken "#-}") -> Maybe (EpToken "safe") -> Maybe (EpToken "qualified") -> Maybe EpaLocation -> Maybe (EpToken "as") -> EpAnnImportDecl

-- | The location of the <tt>import</tt> keyword
[importDeclAnnImport] :: EpAnnImportDecl -> EpToken "import"

-- | The locations of <tt>{-# SOURCE</tt> and <tt>#-}</tt> respectively
[importDeclAnnPragma] :: EpAnnImportDecl -> Maybe (EpaLocation, EpToken "#-}")

-- | The location of the <tt>safe</tt> keyword
[importDeclAnnSafe] :: EpAnnImportDecl -> Maybe (EpToken "safe")

-- | The location of the <tt>qualified</tt> keyword
[importDeclAnnQualified] :: EpAnnImportDecl -> Maybe (EpToken "qualified")

-- | The location of the package name (when using
--   <tt>-XPackageImports</tt>)
[importDeclAnnPackage] :: EpAnnImportDecl -> Maybe EpaLocation

-- | The location of the <tt>as</tt> keyword
[importDeclAnnAs] :: EpAnnImportDecl -> Maybe (EpToken "as")
type IEThingWithAnns = (EpToken "(", EpToken "..", EpToken ",", EpToken ")")
data XImportDeclPass
XImportDeclPass :: EpAnn EpAnnImportDecl -> SourceText -> Bool -> XImportDeclPass
[ideclAnn] :: XImportDeclPass -> EpAnn EpAnnImportDecl
[ideclSourceText] :: XImportDeclPass -> SourceText

-- | GHC generates an <a>ImportDecl</a> to represent the invisible `import
--   Prelude` that appears in any file that omits `import Prelude`, setting
--   this field to indicate that the import doesn't appear in the original
--   source. True =&gt; implicit import (of Prelude)
[ideclImplicit] :: XImportDeclPass -> Bool
instance GHC.Internal.Data.Data.Data GHC.Hs.ImpExp.EpAnnImportDecl
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.ImpExp.IEWrappedName GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.ImpExp.IEWrappedName GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.ImpExp.IEWrappedName GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data GHC.Hs.ImpExp.XImportDeclPass
instance GHC.Classes.Eq (Language.Haskell.Syntax.ImpExp.IEWrappedName GHC.Hs.Extension.GhcPs)
instance GHC.Classes.Eq (Language.Haskell.Syntax.ImpExp.IEWrappedName GHC.Hs.Extension.GhcRn)
instance GHC.Classes.Eq (Language.Haskell.Syntax.ImpExp.IEWrappedName GHC.Hs.Extension.GhcTc)
instance (GHC.Types.Name.Occurrence.HasOccName (Language.Haskell.Syntax.Extension.IdP (GHC.Hs.Extension.GhcPass p)), GHC.Hs.Extension.OutputableBndrId p) => GHC.Types.Name.Occurrence.HasOccName (Language.Haskell.Syntax.ImpExp.IEWrappedName (GHC.Hs.Extension.GhcPass p))
instance GHC.Parser.Annotation.NoAnn GHC.Hs.ImpExp.EpAnnImportDecl
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.OutputableBndr (Language.Haskell.Syntax.ImpExp.IEWrappedName (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.ImpExp.IE (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.ImpExp.IEWrappedName (GHC.Hs.Extension.GhcPass p))
instance (GHC.Hs.Extension.OutputableBndrId p, GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Extension.Anno (Language.Haskell.Syntax.ImpExp.IE (GHC.Hs.Extension.GhcPass p))), GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Extension.ImportDeclPkgQual (GHC.Hs.Extension.GhcPass p))) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.ImpExp.ImportDecl (GHC.Hs.Extension.GhcPass p))

module GHC.Core.Opt.CallerCC.Types
data NamePattern
PChar :: Char -> NamePattern -> NamePattern
PWildcard :: NamePattern -> NamePattern
PEnd :: NamePattern
data CallerCcFilter
CallerCcFilter :: Maybe ModuleName -> NamePattern -> CallerCcFilter
[ccfModuleName] :: CallerCcFilter -> Maybe ModuleName
[ccfFuncName] :: CallerCcFilter -> NamePattern
occNameMatches :: NamePattern -> OccName -> Bool
parseCallerCcFilter :: String -> Either String CallerCcFilter
parseNamePattern :: Parser NamePattern
instance GHC.Utils.Binary.Binary GHC.Core.Opt.CallerCC.Types.CallerCcFilter
instance GHC.Utils.Binary.Binary GHC.Core.Opt.CallerCC.Types.NamePattern
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.CallerCC.Types.CallerCcFilter
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.CallerCC.Types.NamePattern


-- | Module for coercion axioms, used to represent type family instances
--   and newtypes
module GHC.Core.Coercion.Axiom
data BranchFlag
type Branched = 'Branched
type Unbranched = 'Unbranched
type BranchIndex = Int
newtype Branches (br :: BranchFlag)
MkBranches :: Array BranchIndex CoAxBranch -> Branches (br :: BranchFlag)
[unMkBranches] :: Branches (br :: BranchFlag) -> Array BranchIndex CoAxBranch
manyBranches :: [CoAxBranch] -> Branches Branched
unbranched :: CoAxBranch -> Branches Unbranched
fromBranches :: forall (br :: BranchFlag). Branches br -> [CoAxBranch]
numBranches :: forall (br :: BranchFlag). Branches br -> Int

-- | The <tt>[CoAxBranch]</tt> passed into the mapping function is a list
--   of all previous branches, reversed
mapAccumBranches :: forall (br :: BranchFlag). ([CoAxBranch] -> CoAxBranch -> CoAxBranch) -> Branches br -> Branches br

-- | A <a>CoAxiom</a> is a "coercion constructor", i.e. a named equality
--   axiom.
data CoAxiom (br :: BranchFlag)
CoAxiom :: Unique -> Name -> Role -> TyCon -> Branches br -> Bool -> CoAxiom (br :: BranchFlag)
[co_ax_unique] :: CoAxiom (br :: BranchFlag) -> Unique
[co_ax_name] :: CoAxiom (br :: BranchFlag) -> Name
[co_ax_role] :: CoAxiom (br :: BranchFlag) -> Role
[co_ax_tc] :: CoAxiom (br :: BranchFlag) -> TyCon
[co_ax_branches] :: CoAxiom (br :: BranchFlag) -> Branches br
[co_ax_implicit] :: CoAxiom (br :: BranchFlag) -> Bool

-- | A branch of a coercion axiom, which provides the evidence for
--   unwrapping a newtype or a type-family reduction step using a single
--   equation.
data CoAxBranch
CoAxBranch :: SrcSpan -> [TyVar] -> [TyVar] -> [CoVar] -> [Role] -> [Type] -> Type -> [CoAxBranch] -> CoAxBranch

-- | Location of the defining equation See Note [CoAxiom locations]
[cab_loc] :: CoAxBranch -> SrcSpan

-- | Bound type variables; not necessarily fresh See Note [CoAxBranch type
--   variables]
[cab_tvs] :: CoAxBranch -> [TyVar]

-- | Eta-reduced tyvars cab_tvs and cab_lhs may be eta-reduced; see Note
--   [Eta reduction for data families]
[cab_eta_tvs] :: CoAxBranch -> [TyVar]

-- | Bound coercion variables Always empty, for now. See Note [Constraints
--   in patterns] in GHC.Tc.TyCl
[cab_cvs] :: CoAxBranch -> [CoVar]

-- | See Note [CoAxBranch roles]
[cab_roles] :: CoAxBranch -> [Role]

-- | Type patterns to match against
[cab_lhs] :: CoAxBranch -> [Type]

-- | Right-hand side of the equality See Note [CoAxioms are homogeneous]
[cab_rhs] :: CoAxBranch -> Type

-- | The previous incompatible branches See Note [Storing compatibility]
[cab_incomps] :: CoAxBranch -> [CoAxBranch]
toBranchedAxiom :: forall (br :: BranchFlag). CoAxiom br -> CoAxiom Branched
toUnbranchedAxiom :: forall (br :: BranchFlag). CoAxiom br -> CoAxiom Unbranched
coAxiomName :: forall (br :: BranchFlag). CoAxiom br -> Name
coAxiomArity :: forall (br :: BranchFlag). CoAxiom br -> BranchIndex -> Arity
coAxiomBranches :: forall (br :: BranchFlag). CoAxiom br -> Branches br
coAxiomTyCon :: forall (br :: BranchFlag). CoAxiom br -> TyCon
isImplicitCoAxiom :: forall (br :: BranchFlag). CoAxiom br -> Bool
coAxiomNumPats :: forall (br :: BranchFlag). CoAxiom br -> Int
coAxiomNthBranch :: forall (br :: BranchFlag). CoAxiom br -> BranchIndex -> CoAxBranch
coAxiomSingleBranch_maybe :: forall (br :: BranchFlag). CoAxiom br -> Maybe CoAxBranch
coAxiomRole :: forall (br :: BranchFlag). CoAxiom br -> Role
coAxiomSingleBranch :: CoAxiom Unbranched -> CoAxBranch
coAxBranchTyVars :: CoAxBranch -> [TyVar]
coAxBranchCoVars :: CoAxBranch -> [CoVar]
coAxBranchRoles :: CoAxBranch -> [Role]
coAxBranchLHS :: CoAxBranch -> [Type]
coAxBranchRHS :: CoAxBranch -> Type
coAxBranchSpan :: CoAxBranch -> SrcSpan
coAxBranchIncomps :: CoAxBranch -> [CoAxBranch]
placeHolderIncomps :: [CoAxBranch]

-- | See Note [Roles] in GHC.Core.Coercion
--   
--   Order of constructors matters: the Ord instance coincides with the
--   *super*typing relation on roles.
data Role
Nominal :: Role
Representational :: Role
Phantom :: Role
fsFromRole :: Role -> FastString

-- | CoAxiomRule describes a built-in axiom, one that we assume to be true
--   See Note [CoAxiomRule]
data CoAxiomRule
BuiltInFamRew :: BuiltInFamRewrite -> CoAxiomRule
BuiltInFamInj :: BuiltInFamInjectivity -> CoAxiomRule
BranchedAxiom :: CoAxiom Branched -> BranchIndex -> CoAxiomRule
UnbranchedAxiom :: CoAxiom Unbranched -> CoAxiomRule
data BuiltInFamRewrite
BIF_Rewrite :: FastString -> CoAxiomRule -> TyCon -> Arity -> ([Type] -> Maybe ([Type], Type)) -> ([TypeEqn] -> Maybe TypeEqn) -> BuiltInFamRewrite
[bifrw_name] :: BuiltInFamRewrite -> FastString
[bifrw_axr] :: BuiltInFamRewrite -> CoAxiomRule
[bifrw_fam_tc] :: BuiltInFamRewrite -> TyCon
[bifrw_arity] :: BuiltInFamRewrite -> Arity
[bifrw_match] :: BuiltInFamRewrite -> [Type] -> Maybe ([Type], Type)
[bifrw_proves] :: BuiltInFamRewrite -> [TypeEqn] -> Maybe TypeEqn
data BuiltInFamInjectivity
BIF_Interact :: FastString -> CoAxiomRule -> (TypeEqn -> Maybe TypeEqn) -> BuiltInFamInjectivity
[bifinj_name] :: BuiltInFamInjectivity -> FastString
[bifinj_axr] :: BuiltInFamInjectivity -> CoAxiomRule

-- | Always unary: just one TypeEqn argument Returns <tt>Nothing</tt> when
--   it doesn't like the supplied argument. When this happens in a coercion
--   that means that the coercion is ill-formed, and Core Lint checks for
--   that.
[bifinj_proves] :: BuiltInFamInjectivity -> TypeEqn -> Maybe TypeEqn

-- | A more explicit representation for `t1 ~ t2`.
type TypeEqn = Pair Type
coAxiomRuleArgRoles :: CoAxiomRule -> [Role]
coAxiomRuleRole :: CoAxiomRule -> Role
coAxiomRuleBranch_maybe :: CoAxiomRule -> Maybe (TyCon, Role, CoAxBranch)
isNewtypeAxiomRule_maybe :: CoAxiomRule -> Maybe (TyCon, CoAxBranch)
data BuiltInSynFamily
BuiltInSynFamily :: [BuiltInFamRewrite] -> [BuiltInFamInjectivity] -> BuiltInSynFamily
[sfMatchFam] :: BuiltInSynFamily -> [BuiltInFamRewrite]
[sfInteract] :: BuiltInSynFamily -> [BuiltInFamInjectivity]
trivialBuiltInFamily :: BuiltInSynFamily
instance GHC.Utils.Binary.Binary Language.Haskell.Syntax.Basic.Role
instance GHC.Internal.Data.Data.Data GHC.Core.Coercion.Axiom.CoAxBranch
instance GHC.Internal.Data.Typeable.Internal.Typeable br => GHC.Internal.Data.Data.Data (GHC.Core.Coercion.Axiom.CoAxiom br)
instance GHC.Internal.Data.Data.Data GHC.Core.Coercion.Axiom.CoAxiomRule
instance GHC.Classes.Eq (GHC.Core.Coercion.Axiom.CoAxiom br)
instance GHC.Classes.Eq GHC.Core.Coercion.Axiom.CoAxiomRule
instance GHC.Types.Name.NamedThing (GHC.Core.Coercion.Axiom.CoAxiom br)
instance GHC.Utils.Outputable.Outputable GHC.Core.Coercion.Axiom.CoAxBranch
instance GHC.Utils.Outputable.Outputable (GHC.Core.Coercion.Axiom.CoAxiom br)
instance GHC.Utils.Outputable.Outputable GHC.Core.Coercion.Axiom.CoAxiomRule
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Basic.Role
instance GHC.Types.Unique.Uniquable (GHC.Core.Coercion.Axiom.CoAxiom br)

module GHC.Core.Class
data Class
type ClassOpItem = (Id, DefMethInfo)
data ClassATItem

-- | Default associated type (if any) from this template.
--   
--   As per Note [Associated type defaults], the Type has been renamed to
--   use the class tyvars, while the <a>TyFamEqnValidityInfo</a> uses the
--   original user-written type variables.
ATI :: TyCon -> Maybe (Type, TyFamEqnValidityInfo) -> ClassATItem

-- | Information about a type family equation, used for validity checking
--   of closed type family equations and associated type family default
--   equations.
--   
--   This type exists to delay validity-checking after typechecking type
--   declaration groups, to avoid cyclic evaluation inside the typechecking
--   knot.
--   
--   See <tt>Note [Type-checking default assoc decls]</tt> in
--   <a>GHC.Tc.TyCl</a>.
data TyFamEqnValidityInfo

-- | Used for equations which don't need any validity checking, for example
--   equations imported from another module.
NoVI :: TyFamEqnValidityInfo

-- | Information necessary for validity checking of a type family equation.
VI :: SrcSpan -> [TcTyVar] -> TyVarSet -> [Type] -> Type -> TyFamEqnValidityInfo
[vi_loc] :: TyFamEqnValidityInfo -> SrcSpan

-- | LHS quantified type variables
[vi_qtvs] :: TyFamEqnValidityInfo -> [TcTyVar]

-- | non-user-written type variables (for error message reporting)
--   
--   Example: with -XPolyKinds, typechecking <tt>type instance forall a. F
--   = ()</tt> introduces the kind variable <tt>k</tt> for the kind of
--   <tt>a</tt>. See #23734.
[vi_non_user_tvs] :: TyFamEqnValidityInfo -> TyVarSet

-- | LHS patterns
[vi_pats] :: TyFamEqnValidityInfo -> [Type]

-- | RHS of the equation
--   
--   NB: for associated type family default declarations, this is the RHS
--   *before* applying the substitution from Note [Type-checking default
--   assoc decls] in GHC.Tc.TyCl.
[vi_rhs] :: TyFamEqnValidityInfo -> Type
type ClassMinimalDef = BooleanFormula Name
type DefMethInfo = Maybe (Name, DefMethSpec Type)
pprDefMethInfo :: DefMethInfo -> SDoc
type FunDep a = ([a], [a])
pprFundeps :: Outputable a => [FunDep a] -> SDoc
pprFunDep :: Outputable a => FunDep a -> SDoc
mkClass :: Name -> [TyVar] -> [FunDep TyVar] -> [PredType] -> [Id] -> [ClassATItem] -> [ClassOpItem] -> ClassMinimalDef -> TyCon -> Class
mkAbstractClass :: Name -> [TyVar] -> [FunDep TyVar] -> TyCon -> Class
classTyVars :: Class -> [TyVar]
classArity :: Class -> Arity
classKey :: Class -> Unique
className :: Class -> Name
classATs :: Class -> [TyCon]
classATItems :: Class -> [ClassATItem]
classTyCon :: Class -> TyCon
classMethods :: Class -> [Id]
classOpItems :: Class -> [ClassOpItem]
classBigSig :: Class -> ([TyVar], [PredType], [Id], [ClassOpItem])
classExtraBigSig :: Class -> ([TyVar], [FunDep TyVar], [PredType], [Id], [ClassATItem], [ClassOpItem])
classTvsFds :: Class -> ([TyVar], [FunDep TyVar])
classSCTheta :: Class -> [PredType]
classHasSCs :: Class -> Bool
classAllSelIds :: Class -> [Id]
classSCSelId :: Class -> Int -> Id
classSCSelIds :: Class -> [Id]
classMinimalDef :: Class -> ClassMinimalDef
classHasFds :: Class -> Bool
isAbstractClass :: Class -> Bool
instance GHC.Internal.Data.Data.Data GHC.Core.Class.Class
instance GHC.Classes.Eq GHC.Core.Class.Class
instance GHC.Types.Name.NamedThing GHC.Core.Class.Class
instance GHC.Utils.Outputable.Outputable GHC.Core.Class.Class
instance GHC.Types.Unique.Uniquable GHC.Core.Class.Class

module GHC.Platform.Reg.Class

-- | The class of a register. Used in the register allocator. We treat all
--   registers in a class as being interchangeable.
newtype RegClass
RegClass :: Int -> RegClass

-- | The register architecture of a given machine.
data RegArch

-- | Floating-point and vector registers are unified (e.g. X86, AArch64).
Unified :: RegArch

-- | Floating-point and vector registers are separate (e.g. RISC-V).
Separate :: RegArch

-- | No vector registers.
NoVectors :: RegArch

-- | What is the register architecture of the given architecture?
registerArch :: Arch -> RegArch
instance GHC.Classes.Eq GHC.Platform.Reg.Class.RegArch
instance GHC.Classes.Eq GHC.Platform.Reg.Class.RegClass
instance GHC.Classes.Ord GHC.Platform.Reg.Class.RegArch
instance GHC.Classes.Ord GHC.Platform.Reg.Class.RegClass
instance GHC.Utils.Outputable.Outputable GHC.Platform.Reg.Class.RegArch
instance GHC.Utils.Outputable.Outputable GHC.Platform.Reg.Class.RegClass
instance GHC.Internal.Show.Show GHC.Platform.Reg.Class.RegArch
instance GHC.Internal.Show.Show GHC.Platform.Reg.Class.RegClass
instance GHC.Types.Unique.Uniquable GHC.Platform.Reg.Class.RegClass


-- | Register classes for architectures which don't have separate registers
--   for scalar floating-point values separate from vector registers.
module GHC.Platform.Reg.Class.Unified

-- | The class of a register. Used in the register allocator. We treat all
--   registers in a class as being interchangeable.
data RegClass
pattern RcInteger :: RegClass
pattern RcFloatOrVector :: RegClass
pprRegClass :: RegClass -> SDoc
allRegClasses :: [RegClass]


-- | Register classes for architectures which have registers for scalar
--   floating-point values that are separate from all vector registers.
module GHC.Platform.Reg.Class.Separate

-- | The class of a register. Used in the register allocator. We treat all
--   registers in a class as being interchangeable.
data RegClass
pattern RcInteger :: RegClass
pattern RcFloat :: RegClass
pattern RcVector :: RegClass
pprRegClass :: RegClass -> SDoc
allRegClasses :: [RegClass]


-- | Register classes for architectures which don't have any vector
--   registers.
module GHC.Platform.Reg.Class.NoVectors

-- | The class of a register. Used in the register allocator. We treat all
--   registers in a class as being interchangeable.
data RegClass
pattern RcInteger :: RegClass
pattern RcFloat :: RegClass
pprRegClass :: RegClass -> SDoc
allRegClasses :: [RegClass]


-- | An architecture independent description of a register. This needs to
--   stay architecture independent because it is used by NCGMonad and the
--   register allocators, which are shared by all architectures.
module GHC.Platform.Reg

-- | An identifier for a primitive real machine register.
type RegNo = Int

-- | A register, either virtual or real
data Reg
RegVirtual :: !VirtualReg -> Reg
RegReal :: !RealReg -> Reg
regSingle :: RegNo -> Reg
realRegSingle :: RegNo -> RealReg
isRealReg :: Reg -> Bool
takeRealReg :: Reg -> Maybe RealReg
isVirtualReg :: Reg -> Bool
takeVirtualReg :: Reg -> Maybe VirtualReg
data VirtualReg

-- | Integer virtual register
VirtualRegI :: {-# UNPACK #-} !Unique -> VirtualReg
[virtualRegUnique] :: VirtualReg -> {-# UNPACK #-} !Unique

-- | High part of 2-word virtual register
VirtualRegHi :: {-# UNPACK #-} !Unique -> VirtualReg
[virtualRegUnique] :: VirtualReg -> {-# UNPACK #-} !Unique

-- | Double virtual register
VirtualRegD :: {-# UNPACK #-} !Unique -> VirtualReg
[virtualRegUnique] :: VirtualReg -> {-# UNPACK #-} !Unique

-- | 128-bit wide vector virtual register
VirtualRegV128 :: {-# UNPACK #-} !Unique -> VirtualReg
[virtualRegUnique] :: VirtualReg -> {-# UNPACK #-} !Unique
renameVirtualReg :: Unique -> VirtualReg -> VirtualReg
classOfVirtualReg :: Arch -> VirtualReg -> RegClass
getHiVirtualRegFromLo :: VirtualReg -> VirtualReg
getHiVRegFromLo :: Reg -> Reg

-- | RealRegs are machine regs which are available for allocation, in the
--   usual way. We know what class they are, because that's part of the
--   processor's architecture.
newtype RealReg
RealRegSingle :: RegNo -> RealReg
regNosOfRealReg :: RealReg -> [RegNo]
realRegsAlias :: RealReg -> RealReg -> Bool

-- | The patch function supplied by the allocator maps VirtualReg to
--   RealReg regs, but sometimes we want to apply it to plain old Reg.
liftPatchFnToRegReg :: (VirtualReg -> RealReg) -> Reg -> Reg
instance GHC.Classes.Eq GHC.Platform.Reg.RealReg
instance GHC.Classes.Eq GHC.Platform.Reg.Reg
instance GHC.Classes.Eq GHC.Platform.Reg.VirtualReg
instance GHC.Classes.Ord GHC.Platform.Reg.RealReg
instance GHC.Classes.Ord GHC.Platform.Reg.Reg
instance GHC.Classes.Ord GHC.Platform.Reg.VirtualReg
instance GHC.Utils.Outputable.Outputable GHC.Platform.Reg.RealReg
instance GHC.Utils.Outputable.Outputable GHC.Platform.Reg.Reg
instance GHC.Utils.Outputable.Outputable GHC.Platform.Reg.VirtualReg
instance GHC.Internal.Show.Show GHC.Platform.Reg.RealReg
instance GHC.Internal.Show.Show GHC.Platform.Reg.Reg
instance GHC.Internal.Show.Show GHC.Platform.Reg.VirtualReg
instance GHC.Types.Unique.Uniquable GHC.Platform.Reg.RealReg
instance GHC.Types.Unique.Uniquable GHC.Platform.Reg.Reg
instance GHC.Types.Unique.Uniquable GHC.Platform.Reg.VirtualReg

module GHC.CmmToAsm.Reg.Utils
toRegMap :: UniqFM VirtualReg elt -> UniqFM Reg elt
toVRegMap :: UniqFM Reg elt -> UniqFM VirtualReg elt

module GHC.CmmToAsm.Reg.Graph.TrivColorable
trivColorable :: Platform -> (RegClass -> VirtualReg -> Int) -> (RegClass -> RealReg -> Int) -> Triv VirtualReg RegClass RealReg


-- | Utils for calculating general worst, bound, squeese and free,
--   functions.
--   
--   as per: "A Generalized Algorithm for Graph-Coloring Register
--   Allocation" Michael Smith, Normal Ramsey, Glenn Holloway. PLDI 2004
--   
--   These general versions are not used in GHC proper because they are too
--   slow. Instead, hand written optimised versions are provided for each
--   architecture in MachRegs*.hs
--   
--   This code is here because we can test the architecture specific code
--   against it.
module GHC.CmmToAsm.Reg.Graph.Base
data RegClass
ClassG32 :: RegClass
ClassG16 :: RegClass
ClassG8 :: RegClass
ClassF64 :: RegClass

-- | A register of some class
data Reg
Reg :: RegClass -> Int -> Reg
RegSub :: RegSub -> Reg -> Reg

-- | A subcomponent of another register
data RegSub
SubL16 :: RegSub
SubL8 :: RegSub
SubL8H :: RegSub

-- | Worst case displacement
--   
--   a node N of classN has some number of neighbors, all of which are from
--   classC.
--   
--   (worst neighbors classN classC) is the maximum number of potential
--   colors for N that can be lost by coloring its neighbors.
--   
--   This should be hand coded/cached for each particular architecture,
--   because the compute time is very long..
worst :: (RegClass -> UniqSet Reg) -> (Reg -> UniqSet Reg) -> Int -> RegClass -> RegClass -> Int

-- | For a node N of classN and neighbors of classesC (bound classN
--   classesC) is the maximum number of potential colors for N that can be
--   lost by coloring its neighbors.
bound :: (RegClass -> UniqSet Reg) -> (Reg -> UniqSet Reg) -> RegClass -> [RegClass] -> Int

-- | The total squeese on a particular node with a list of neighbors.
--   
--   A version of this should be constructed for each particular
--   architecture, possibly including uses of bound, so that aliased
--   registers don't get counted twice, as per the paper.
squeese :: (RegClass -> UniqSet Reg) -> (Reg -> UniqSet Reg) -> RegClass -> [(Int, RegClass)] -> Int
instance GHC.Internal.Enum.Enum GHC.CmmToAsm.Reg.Graph.Base.RegClass
instance GHC.Internal.Enum.Enum GHC.CmmToAsm.Reg.Graph.Base.RegSub
instance GHC.Classes.Eq GHC.CmmToAsm.Reg.Graph.Base.Reg
instance GHC.Classes.Eq GHC.CmmToAsm.Reg.Graph.Base.RegClass
instance GHC.Classes.Eq GHC.CmmToAsm.Reg.Graph.Base.RegSub
instance GHC.Classes.Ord GHC.CmmToAsm.Reg.Graph.Base.RegSub
instance GHC.Internal.Show.Show GHC.CmmToAsm.Reg.Graph.Base.Reg
instance GHC.Internal.Show.Show GHC.CmmToAsm.Reg.Graph.Base.RegClass
instance GHC.Internal.Show.Show GHC.CmmToAsm.Reg.Graph.Base.RegSub
instance GHC.Types.Unique.Uniquable GHC.CmmToAsm.Reg.Graph.Base.Reg


-- | A description of the register set of the X86.
--   
--   This isn't used directly in GHC proper.
--   
--   See RegArchBase.hs for the reference. See MachRegs.hs for the actual
--   trivColorable function used in GHC.
module GHC.CmmToAsm.Reg.Graph.X86

-- | Determine the class of a register
classOfReg :: Reg -> RegClass

-- | Determine all the regs that make up a certain class.
regsOfClass :: RegClass -> UniqSet Reg

-- | Determine the common name of a reg returns Nothing if this reg is not
--   part of the machine.
regName :: Reg -> Maybe String

-- | Which regs alias what other regs.
regAlias :: Reg -> UniqSet Reg

-- | Optimised versions of RegColorBase.{worst, squeese} specific to x86
worst :: Int -> RegClass -> RegClass -> Int
squeese :: RegClass -> [(Int, RegClass)] -> Int

module GHC.Builtin.Names

-- | Unique identifier.
--   
--   The type of unique identifiers that are used in many places in GHC for
--   fast ordering and equality tests. You should generate these with the
--   functions from the <tt>UniqSupply</tt> module
--   
--   These are sometimes also referred to as "keys" in comments in GHC.
data Unique

-- | Class of things that we can obtain a <a>Unique</a> from
class Uniquable a
getUnique :: Uniquable a => a -> Unique
hasKey :: Uniquable a => a -> Unique -> Bool
absentConstraintErrorIdKey :: Unique
absentErrorIdKey :: Unique
absentSumFieldErrorIdKey :: Unique
addrPrimTyConKey :: Unique
allNameStringList :: [String]
allNameStrings :: Infinite String
all_RDR :: RdrName
alt_RDR :: RdrName
alternativeClassKey :: Unique
alternativeClassName :: Name
and_RDR :: RdrName
anyTyConKey :: Unique
apAClassOpKey :: Unique
apAName :: Name
ap_RDR :: RdrName
appAIdKey :: Unique
appAName :: Name
appendIdKey :: Unique
appendName :: Name
append_RDR :: RdrName
applicativeClassKey :: Unique
applicativeClassName :: Name
arrAIdKey :: Unique
arrAName :: Name
arrayPrimTyConKey :: Unique
assertErrorIdKey :: Unique
assertErrorName :: Name
assertIdKey :: Unique
assertName :: Name
augmentIdKey :: Unique
augmentName :: Name
basicKnownKeyNames :: [Name]
bcoPrimTyConKey :: Unique
bignatCompareIdKey :: Unique
bignatCompareName :: Name
bignatCompareWordIdKey :: Unique
bignatCompareWordName :: Name
bignatEqIdKey :: Unique
bignatEqName :: Name
bindIOIdKey :: Unique
bindIOName :: Name
bindMClassOpKey :: Unique
bindMName :: Name
bindM_RDR :: RdrName
bnbVarQual :: String -> Unique -> Name
bniVarQual :: String -> Unique -> Name
bnnVarQual :: String -> Unique -> Name
boolTyConKey :: Unique
boundedClassKey :: Unique
boundedClassName :: Name
boxedRepDataConKey :: Unique
boxedRepDataConTyConKey :: Unique
boxityConKey :: Unique
buildIdKey :: Unique
buildName :: Name
build_RDR :: RdrName
byteArrayPrimTyConKey :: Unique
c1TyConKey :: Unique
c1TyConName :: Name
cONSTRAINTTyConKey :: Unique
cTyConKey :: Unique
cTyConName :: Name
callStackTyConKey :: Unique
callStackTyConName :: Name
ccArrowTyConKey :: Unique
charDataConKey :: Unique
charPrimTyConKey :: Unique
charTyConKey :: Unique
choiceAIdKey :: Unique
choiceAName :: Name
choose_RDR :: RdrName
clsQual :: Module -> FastString -> Unique -> Name
clsQual_RDR :: Module -> FastString -> RdrName
coerceKey :: Unique
coercibleDataConKey :: Unique
coercibleSCSelIdKey :: Unique
coercibleTyConKey :: Unique
coercionTokenIdKey :: Unique
comp1DataCon_RDR :: RdrName
compTyConKey :: Unique
compTyConName :: Name
compactPrimTyConKey :: Unique
compare_RDR :: RdrName
composeAIdKey :: Unique
composeAName :: Name
compose_RDR :: RdrName
conFixity_RDR :: RdrName
conIsRecord_RDR :: RdrName
conName_RDR :: RdrName
concatIdKey :: Unique
concatName :: Name
consDataConKey :: Unique
considerAccessibleIdKey :: Unique
considerAccessibleName :: Name
constPtrConName :: Name
constPtrTyConKey :: Unique
constraintKindRepKey :: Unique
constraintKindRepName :: Name
constraintKindTyConKey :: Unique
constructorClassKey :: Unique
constructorClassName :: Name
crossDataConKey :: Unique
cstringLengthIdKey :: Unique
cstringLengthName :: Name
ctArrowTyConKey :: Unique
d1TyConKey :: Unique
d1TyConName :: Name
dTyConKey :: Unique
dTyConName :: Name
dataClassKey :: Unique
dataClassName :: Name
dataQual_RDR :: Module -> FastString -> RdrName
dataToTagClassKey :: Unique
dataToTagClassName :: Name
dataToTag_RDR :: RdrName
datatypeClassKey :: Unique
datatypeClassName :: Name
datatypeName_RDR :: RdrName
dcQual :: Module -> FastString -> Unique -> Name
decidedLazyDataConKey :: Unique
decidedLazyDataConName :: Name
decidedStrictDataConKey :: Unique
decidedStrictDataConName :: Name
decidedUnpackDataConKey :: Unique
decidedUnpackDataConName :: Name
derivableClassKeys :: [Unique]
dictTyConKey :: Unique
divIntIdKey :: Unique
divIntName :: Name
dollarIdKey :: Unique
dollarName :: Name
doubleDataConKey :: Unique
doublePrimTyConKey :: Unique
doubleTyConKey :: Unique
doubleX2PrimTyConKey :: Unique
doubleX4PrimTyConKey :: Unique
doubleX8PrimTyConKey :: Unique
eitherTyConKey :: Unique
eitherTyConName :: Name
emptyCallStackKey :: Unique
emptyCallStackName :: Name
emptyExceptionContextKey :: Unique
emptyExceptionContextName :: Name
enumClassKey :: Unique
enumClassName :: Name
enumFromClassOpKey :: Unique
enumFromName :: Name
enumFromThenClassOpKey :: Unique
enumFromThenName :: Name
enumFromThenToClassOpKey :: Unique
enumFromThenToName :: Name
enumFromThenTo_RDR :: RdrName
enumFromThen_RDR :: RdrName
enumFromToClassOpKey :: Unique
enumFromToName :: Name
enumFromTo_RDR :: RdrName
enumFrom_RDR :: RdrName
enumIntToWord_RDR :: RdrName
eqClassKey :: Unique
eqClassName :: Name
eqClassOpKey :: Unique
eqDataConKey :: Unique
eqName :: Name
eqPhantPrimTyConKey :: Unique
eqPrimTyConKey :: Unique
eqReprPrimTyConKey :: Unique
eqSCSelIdKey :: Unique
eqStringIdKey :: Unique
eqStringName :: Name
eqTag_RDR :: RdrName
eqTyConKey :: Unique
eq_RDR :: RdrName
errorMessageTypeErrorFamKey :: Unique
errorMessageTypeErrorFamName :: Name
error_RDR :: RdrName
exceptionContextTyConKey :: Unique
exceptionContextTyConName :: Name
expectP_RDR :: RdrName
fUNTyConKey :: Unique
failIOIdKey :: Unique
failIOName :: Name
failMClassOpKey :: Unique
failMName :: Name
failM_RDR :: RdrName
falseDataConKey :: Unique
fieldQual_RDR :: Module -> FastString -> FastString -> RdrName
filterIdKey :: Unique
filterName :: Name
fingerprintDataConKey :: Unique
fingerprintDataConName :: Name
firstAIdKey :: Unique
firstAName :: Name
floatDataConKey :: Unique
floatPrimTyConKey :: Unique
floatTyConKey :: Unique
floatX16PrimTyConKey :: Unique
floatX4PrimTyConKey :: Unique
floatX8PrimTyConKey :: Unique
floatingClassKey :: Unique
floatingClassName :: Name
fmapClassOpKey :: Unique
fmapName :: Name
fmap_RDR :: RdrName
foldMap_RDR :: RdrName
foldableClassKey :: Unique
foldableClassName :: Name
foldable_foldr_RDR :: RdrName
foldrIdKey :: Unique
foldrName :: Name
foldr_RDR :: RdrName
foreignObjPrimTyConKey :: Unique
fractionalClassKey :: Unique
fractionalClassKeys :: [Unique]
fractionalClassName :: Name
from1_RDR :: RdrName
fromEnum_RDR :: RdrName
fromIntegerClassOpKey :: Unique
fromIntegerName :: Name
fromIntegralIdKey :: Unique
fromIntegralName :: Name
fromLabelClassOpKey :: Unique
fromLabelClassOpName :: Name
fromListClassOpKey :: Unique
fromListNClassOpKey :: Unique
fromListNName :: Name
fromListName :: Name
fromRationalClassOpKey :: Unique
fromRationalName :: Name
fromStaticPtrClassOpKey :: Unique
fromStaticPtrName :: Name
fromStringClassOpKey :: Unique
fromStringName :: Name
from_RDR :: RdrName
frontendPluginTyConKey :: Unique
frontendPluginTyConName :: Name
funPtrTyConKey :: Unique
funPtrTyConName :: Name
functorClassKey :: Unique
functorClassName :: Name
gHC_CLASSES :: Module
gHC_CSTRING :: Module
gHC_INTERNAL_ARROW :: Module
gHC_INTERNAL_BASE :: Module
gHC_INTERNAL_CONC :: Module
gHC_INTERNAL_CONTROL_EXCEPTION_BASE :: Module
gHC_INTERNAL_CONTROL_MONAD_ZIP :: Module
gHC_INTERNAL_DATA_COERCE :: Module
gHC_INTERNAL_DATA_DATA :: Module
gHC_INTERNAL_DATA_EITHER :: Module
gHC_INTERNAL_DATA_FOLDABLE :: Module
gHC_INTERNAL_DATA_STRING :: Module
gHC_INTERNAL_DATA_TRAVERSABLE :: Module
gHC_INTERNAL_DEBUG_TRACE :: Module
gHC_INTERNAL_DESUGAR :: Module
gHC_INTERNAL_DYNAMIC :: Module
gHC_INTERNAL_ENUM :: Module
gHC_INTERNAL_ERR :: Module
gHC_INTERNAL_EXCEPTION_CONTEXT :: Module
gHC_INTERNAL_EXTS :: Module
gHC_INTERNAL_FINGERPRINT_TYPE :: Module
gHC_INTERNAL_FLOAT :: Module
gHC_INTERNAL_FOREIGN_C_CONSTPTR :: Module
gHC_INTERNAL_GENERICS :: Module
gHC_INTERNAL_GHCI :: Module
gHC_INTERNAL_GHCI_HELPERS :: Module
gHC_INTERNAL_INT :: Module
gHC_INTERNAL_IO :: Module
gHC_INTERNAL_IO_Exception :: Module
gHC_INTERNAL_IS_LIST :: Module
gHC_INTERNAL_IX :: Module
gHC_INTERNAL_LEX :: Module
gHC_INTERNAL_LIST :: Module
gHC_INTERNAL_MAYBE :: Module
gHC_INTERNAL_MONAD :: Module
gHC_INTERNAL_MONAD_FAIL :: Module
gHC_INTERNAL_MONAD_FIX :: Module
gHC_INTERNAL_NUM :: Module
gHC_INTERNAL_NUM_BIGNAT :: Module
gHC_INTERNAL_NUM_INTEGER :: Module
gHC_INTERNAL_NUM_NATURAL :: Module
gHC_INTERNAL_OVER_LABELS :: Module
gHC_INTERNAL_PTR :: Module
gHC_INTERNAL_RANDOM :: Module
gHC_INTERNAL_READ :: Module
gHC_INTERNAL_READ_PREC :: Module
gHC_INTERNAL_REAL :: Module
gHC_INTERNAL_RECORDS :: Module
gHC_INTERNAL_SHOW :: Module
gHC_INTERNAL_SRCLOC :: Module
gHC_INTERNAL_ST :: Module
gHC_INTERNAL_STABLE :: Module
gHC_INTERNAL_STACK :: Module
gHC_INTERNAL_STACK_TYPES :: Module
gHC_INTERNAL_STATICPTR :: Module
gHC_INTERNAL_STATICPTR_INTERNAL :: Module
gHC_INTERNAL_SYSTEM_IO :: Module
gHC_INTERNAL_TOP_HANDLER :: Module
gHC_INTERNAL_TUPLE :: Module
gHC_INTERNAL_TYPEABLE :: Module
gHC_INTERNAL_TYPEABLE_INTERNAL :: Module
gHC_INTERNAL_TYPEERROR :: Module
gHC_INTERNAL_TYPELITS :: Module
gHC_INTERNAL_TYPELITS_INTERNAL :: Module
gHC_INTERNAL_TYPENATS :: Module
gHC_INTERNAL_TYPENATS_INTERNAL :: Module
gHC_INTERNAL_UNSAFE_COERCE :: Module
gHC_INTERNAL_WORD :: Module
gHC_MAGIC :: Module
gHC_MAGIC_DICT :: Module
gHC_PRIM :: Module
gHC_PRIMOPWRAPPERS :: Module
gHC_PRIM_PANIC :: Module
gHC_TYPES :: Module
geClassOpKey :: Unique
geName :: Name
ge_RDR :: RdrName
gen1ClassKey :: Unique
gen1ClassName :: Name
genClassKey :: Unique
genClassName :: Name
genUnitDataConKey :: Unique
genericClassNames :: [Name]
genericTyConNames :: [Name]
getFieldClassOpKey :: Unique
getFieldName :: Name
ghciIoClassKey :: Unique
ghciIoClassName :: Name
ghciStepIoMClassOpKey :: Unique
ghciStepIoMName :: Name
gtTag_RDR :: RdrName
gt_RDR :: RdrName
guardMIdKey :: Unique
guardMName :: Name
hasFieldClassName :: Name
hasFieldClassNameKey :: Unique
heqDataConKey :: Unique
heqSCSelIdKey :: Unique
heqTyConKey :: Unique
ident_RDR :: RdrName
impossibleConstraintErrorIdKey :: Unique
impossibleErrorIdKey :: Unique
inRange_RDR :: RdrName
index_RDR :: RdrName
infixDataCon_RDR :: RdrName
infixIDataConKey :: Unique
infixIDataConName :: Name
inlDataConKey :: Unique
inlineIdKey :: Unique
inlineIdName :: Name
inrDataConKey :: Unique
int16PrimTyConKey :: Unique
int16TyConKey :: Unique
int16TyConName :: Name
int16X16PrimTyConKey :: Unique
int16X32PrimTyConKey :: Unique
int16X8PrimTyConKey :: Unique
int32PrimTyConKey :: Unique
int32TyConKey :: Unique
int32TyConName :: Name
int32X16PrimTyConKey :: Unique
int32X4PrimTyConKey :: Unique
int32X8PrimTyConKey :: Unique
int64PrimTyConKey :: Unique
int64TyConKey :: Unique
int64TyConName :: Name
int64X2PrimTyConKey :: Unique
int64X4PrimTyConKey :: Unique
int64X8PrimTyConKey :: Unique
int8PrimTyConKey :: Unique
int8TyConKey :: Unique
int8TyConName :: Name
int8X16PrimTyConKey :: Unique
int8X32PrimTyConKey :: Unique
int8X64PrimTyConKey :: Unique
intDataConKey :: Unique
intPrimTyConKey :: Unique
intTyConKey :: Unique
integerAbsIdKey :: Unique
integerAbsName :: Name
integerAddIdKey :: Unique
integerAddName :: Name
integerAndIdKey :: Unique
integerAndName :: Name
integerBitIdKey :: Unique
integerBitName :: Name
integerComplementIdKey :: Unique
integerComplementName :: Name
integerDivIdKey :: Unique
integerDivModIdKey :: Unique
integerDivModName :: Name
integerDivName :: Name
integerEncodeDoubleIdKey :: Unique
integerEncodeDoubleName :: Name
integerEncodeFloatIdKey :: Unique
integerEncodeFloatName :: Name
integerFromInt64IdKey :: Unique
integerFromInt64Name :: Name
integerFromNaturalIdKey :: Unique
integerFromNaturalName :: Name
integerFromWord64IdKey :: Unique
integerFromWord64Name :: Name
integerFromWordIdKey :: Unique
integerFromWordName :: Name
integerGcdIdKey :: Unique
integerGcdName :: Name
integerINDataConKey :: Unique
integerIPDataConKey :: Unique
integerISDataConKey :: Unique
integerLcmIdKey :: Unique
integerLcmName :: Name
integerModIdKey :: Unique
integerModName :: Name
integerMulIdKey :: Unique
integerMulName :: Name
integerNegateIdKey :: Unique
integerNegateName :: Name
integerOrIdKey :: Unique
integerOrName :: Name
integerPopCountIdKey :: Unique
integerPopCountName :: Name
integerQuotIdKey :: Unique
integerQuotName :: Name
integerQuotRemIdKey :: Unique
integerQuotRemName :: Name
integerRemIdKey :: Unique
integerRemName :: Name
integerShiftLIdKey :: Unique
integerShiftLName :: Name
integerShiftRIdKey :: Unique
integerShiftRName :: Name
integerSubIdKey :: Unique
integerSubName :: Name
integerTestBitIdKey :: Unique
integerTestBitName :: Name
integerToDoubleIdKey :: Unique
integerToDoubleName :: Name
integerToFloatIdKey :: Unique
integerToFloatName :: Name
integerToInt64IdKey :: Unique
integerToInt64Name :: Name
integerToIntIdKey :: Unique
integerToIntName :: Name
integerToNaturalClampIdKey :: Unique
integerToNaturalClampName :: Name
integerToNaturalIdKey :: Unique
integerToNaturalName :: Name
integerToNaturalThrowIdKey :: Unique
integerToNaturalThrowName :: Name
integerToWord64IdKey :: Unique
integerToWord64Name :: Name
integerToWordIdKey :: Unique
integerToWordName :: Name
integerTyConKey :: Unique
integerXorIdKey :: Unique
integerXorName :: Name
integralClassKey :: Unique
integralClassName :: Name
interactiveClassKeys :: [Unique]
interactiveClassNames :: [Name]
ioDataConKey :: Unique
ioDataConName :: Name
ioPortPrimTyConKey :: Unique
ioTyConKey :: Unique
ioTyConName :: Name
ipClassKey :: Unique
ipClassName :: Name
isListClassKey :: Unique
isListClassName :: Name
isNewtypeName_RDR :: RdrName
isStringClassKey :: Unique
isStringClassName :: Name
isUnboundName :: Name -> Bool
itName :: Unique -> SrcSpan -> Name
ixClassKey :: Unique
ixClassName :: Name
joinMIdKey :: Unique
joinMName :: Name
jsvalTyConKey :: Unique
jsvalTyConName :: Name
justDataConKey :: Unique
k1DataCon_RDR :: RdrName
k1TyConKey :: Unique
k1TyConName :: Name
kindConKey :: Unique
kindRepAppDataConKey :: Unique
kindRepAppDataConName :: Name
kindRepFunDataConKey :: Unique
kindRepFunDataConName :: Name
kindRepTYPEDataConKey :: Unique
kindRepTYPEDataConName :: Name
kindRepTyConAppDataConKey :: Unique
kindRepTyConAppDataConName :: Name
kindRepTyConKey :: Unique
kindRepTyConName :: Name
kindRepTypeLitDDataConKey :: Unique
kindRepTypeLitDDataConName :: Name
kindRepTypeLitSDataConKey :: Unique
kindRepTypeLitSDataConName :: Name
kindRepVarDataConKey :: Unique
kindRepVarDataConName :: Name
knownCharClassName :: Name
knownCharClassNameKey :: Unique
knownNatClassName :: Name
knownNatClassNameKey :: Unique
knownSymbolClassName :: Name
knownSymbolClassNameKey :: Unique
l1DataCon_RDR :: RdrName
lazyIdKey :: Unique
le_RDR :: RdrName
leftAssocDataCon_RDR :: RdrName
leftAssociativeDataConKey :: Unique
leftAssociativeDataConName :: Name
leftDataConKey :: Unique
leftDataConName :: Name
leftSectionKey :: Unique
left_RDR :: RdrName
levityTyConKey :: Unique
lexP_RDR :: RdrName
liftA2_RDR :: RdrName
liftMIdKey :: Unique
liftMName :: Name
liftedDataConKey :: Unique
liftedRepTyConKey :: Unique
liftedTypeKindTyConKey :: Unique
listTyConKey :: Unique
loopAIdKey :: Unique
loopAName :: Name
ltTag_RDR :: RdrName
lt_RDR :: RdrName
m1DataCon_RDR :: RdrName
m1TyConKey :: Unique
m1TyConName :: Name
mAIN_NAME :: ModuleName
mVarPrimTyConKey :: Unique
main_RDR_Unqual :: RdrName
makeStaticKey :: Unique
makeStaticName :: Name
manyDataConKey :: Unique
mapIdKey :: Unique
mapName :: Name
map_RDR :: RdrName
mappendClassOpKey :: Unique
mappendName :: Name
mappend_RDR :: RdrName
maxBound_RDR :: RdrName
maybeTyConKey :: Unique
mconcatClassOpKey :: Unique
mconcatName :: Name
memptyClassOpKey :: Unique
memptyName :: Name
mempty_RDR :: RdrName
metaConsDataConKey :: Unique
metaConsDataConName :: Name
metaDataDataConKey :: Unique
metaDataDataConName :: Name
metaSelDataConKey :: Unique
metaSelDataConName :: Name
mfixIdKey :: Unique
mfixName :: Name
minBound_RDR :: RdrName
minusClassOpKey :: Unique
minusName :: Name
mkBignumModule :: FastString -> Module
mkDictDataConKey :: Unique
mkGhcInternalModule :: FastString -> Module
mkGhcInternalModule_ :: ModuleName -> Module
mkInteractiveModule :: String -> Module
mkMainModule :: FastString -> Module
mkMainModule_ :: ModuleName -> Module
mkPrimModule :: FastString -> Module
mkRationalBase10IdKey :: Unique
mkRationalBase10Name :: Name
mkRationalBase2IdKey :: Unique
mkRationalBase2Name :: Name
mkThisGhcModule :: FastString -> Module
mkThisGhcModule_ :: ModuleName -> Module
mkTrAppKey :: Unique
mkTrAppName :: Name
mkTrConKey :: Unique
mkTrConName :: Name
mkTrFunKey :: Unique
mkTrFunName :: Name
mkTrTypeKey :: Unique
mkTrTypeName :: Name
mkTyConKey :: Unique
mkUnboundName :: OccName -> Name
mk_known_key_name :: NameSpace -> Module -> FastString -> Unique -> Name
modIntIdKey :: Unique
modIntName :: Name
moduleName_RDR :: RdrName
monadClassKey :: Unique
monadClassName :: Name
monadFailClassKey :: Unique
monadFailClassName :: Name
monadFixClassKey :: Unique
monadFixClassName :: Name
monadPlusClassKey :: Unique
monadPlusClassName :: Name
monoidClassKey :: Unique
monoidClassName :: Name
multMulTyConKey :: Unique
multiplicityTyConKey :: Unique
mutVarPrimTyConKey :: Unique
mutableArrayPrimTyConKey :: Unique
mutableByteArrayPrimTyConKey :: Unique
mzipIdKey :: Unique
mzipName :: Name
naturalAddIdKey :: Unique
naturalAddName :: Name
naturalAndIdKey :: Unique
naturalAndName :: Name
naturalAndNotIdKey :: Unique
naturalAndNotName :: Name
naturalBitIdKey :: Unique
naturalBitName :: Name
naturalGcdIdKey :: Unique
naturalGcdName :: Name
naturalLcmIdKey :: Unique
naturalLcmName :: Name
naturalLog2IdKey :: Unique
naturalLog2Name :: Name
naturalLogBaseIdKey :: Unique
naturalLogBaseName :: Name
naturalLogBaseWordIdKey :: Unique
naturalLogBaseWordName :: Name
naturalMulIdKey :: Unique
naturalMulName :: Name
naturalNBDataConKey :: Unique
naturalNSDataConKey :: Unique
naturalOrIdKey :: Unique
naturalOrName :: Name
naturalPopCountIdKey :: Unique
naturalPopCountName :: Name
naturalPowModIdKey :: Unique
naturalPowModName :: Name
naturalQuotIdKey :: Unique
naturalQuotName :: Name
naturalQuotRemIdKey :: Unique
naturalQuotRemName :: Name
naturalRemIdKey :: Unique
naturalRemName :: Name
naturalShiftLIdKey :: Unique
naturalShiftLName :: Name
naturalShiftRIdKey :: Unique
naturalShiftRName :: Name
naturalSizeInBaseIdKey :: Unique
naturalSizeInBaseName :: Name
naturalSubIdKey :: Unique
naturalSubName :: Name
naturalSubThrowIdKey :: Unique
naturalSubThrowName :: Name
naturalSubUnsafeIdKey :: Unique
naturalSubUnsafeName :: Name
naturalTestBitIdKey :: Unique
naturalTestBitName :: Name
naturalToDoubleIdKey :: Unique
naturalToDoubleName :: Name
naturalToFloatIdKey :: Unique
naturalToFloatName :: Name
naturalToWordIdKey :: Unique
naturalToWordName :: Name
naturalTyConKey :: Unique
naturalXorIdKey :: Unique
naturalXorName :: Name
negateClassOpKey :: Unique
negateName :: Name
newStablePtrIdKey :: Unique
newStablePtrName :: Name
nilDataConKey :: Unique
noMethodBindingErrorIdKey :: Unique
noSourceStrictnessDataConKey :: Unique
noSourceStrictnessDataConName :: Name
noSourceUnpackednessDataConKey :: Unique
noSourceUnpackednessDataConName :: Name
noinlineConstraintIdKey :: Unique
noinlineIdKey :: Unique
nonEmptyTyConKey :: Unique
nonEmptyTyConName :: Name
nonExhaustiveGuardsErrorIdKey :: Unique
nospecIdKey :: Unique
notAssocDataCon_RDR :: RdrName
notAssociativeDataConKey :: Unique
notAssociativeDataConName :: Name
not_RDR :: RdrName
nothingDataConKey :: Unique
nullAddrIdKey :: Unique
null_RDR :: RdrName
numClassKey :: Unique
numClassName :: Name
numericClassKeys :: [Unique]
oneDataConKey :: Unique
oneShotKey :: Unique
ordClassKey :: Unique
ordClassName :: Name
ordEQDataConKey :: Unique
ordEQDataConName :: Name
ordGTDataConKey :: Unique
ordGTDataConName :: Name
ordLTDataConKey :: Unique
ordLTDataConName :: Name
orderingTyConKey :: Unique
orderingTyConName :: Name
otherwiseIdKey :: Unique
otherwiseIdName :: Name
pLUGINS :: Module
pRELUDE_NAME :: ModuleName
packageName_RDR :: RdrName
par1DataCon_RDR :: RdrName
par1TyConKey :: Unique
par1TyConName :: Name
parens_RDR :: RdrName
patErrorIdKey :: Unique
pfail_RDR :: RdrName
pluginTyConKey :: Unique
pluginTyConName :: Name
plus_RDR :: RdrName
prec_RDR :: RdrName
predError_RDR :: RdrName
pred_RDR :: RdrName
prefixDataCon_RDR :: RdrName
prefixIDataConKey :: Unique
prefixIDataConName :: Name
printIdKey :: Unique
printName :: Name
prodDataCon_RDR :: RdrName
prodTyConKey :: Unique
prodTyConName :: Name
promptTagPrimTyConKey :: Unique
proxyHashKey :: Unique
proxyPrimTyConKey :: Unique
ptrTyConKey :: Unique
ptrTyConName :: Name
punc_RDR :: RdrName
pureAClassOpKey :: Unique
pureAName :: Name
pure_RDR :: RdrName
pushCallStackKey :: Unique
pushCallStackName :: Name
r1DataCon_RDR :: RdrName
rOOT_MAIN :: Module
rTyConKey :: Unique
rTyConName :: Name
randomClassKey :: Unique
randomGenClassKey :: Unique
range_RDR :: RdrName
ratioDataConKey :: Unique
ratioDataConName :: Name
ratioTyConKey :: Unique
ratioTyConName :: Name
rationalToDoubleIdKey :: Unique
rationalToDoubleName :: Name
rationalToFloatIdKey :: Unique
rationalToFloatName :: Name
rationalTyConKey :: Unique
rationalTyConName :: Name
readClassKey :: Unique
readClassName :: Name
readFieldHash_RDR :: RdrName
readField_RDR :: RdrName
readListDefault_RDR :: RdrName
readListPrecDefault_RDR :: RdrName
readListPrec_RDR :: RdrName
readList_RDR :: RdrName
readPrec_RDR :: RdrName
readSymField_RDR :: RdrName
realClassKey :: Unique
realClassName :: Name
realFloatClassKey :: Unique
realFloatClassName :: Name
realFracClassKey :: Unique
realFracClassName :: Name
realToFracIdKey :: Unique
realToFracName :: Name
realWorldPrimIdKey :: Unique
realWorldTyConKey :: Unique
rec0TyConKey :: Unique
rec0TyConName :: Name
rec1DataCon_RDR :: RdrName
rec1TyConKey :: Unique
rec1TyConName :: Name
recConErrorIdKey :: Unique
recSelErrorIdKey :: Unique
rep1TyConKey :: Unique
rep1TyConName :: Name
repTyConKey :: Unique
repTyConName :: Name
replace_RDR :: RdrName
reset_RDR :: RdrName
returnIOIdKey :: Unique
returnIOName :: Name
returnMClassOpKey :: Unique
returnMName :: Name
returnM_RDR :: RdrName
rightAssocDataCon_RDR :: RdrName
rightAssociativeDataConKey :: Unique
rightAssociativeDataConName :: Name
rightDataConKey :: Unique
rightDataConName :: Name
rightSectionKey :: Unique
right_RDR :: RdrName
rootMainKey :: Unique
runMainIOName :: Name
runMainKey :: Unique
runRWKey :: Unique
runRWName :: Name
runtimeRepSimpleDataConKeys :: [Unique]
runtimeRepTyConKey :: Unique
s1TyConKey :: Unique
s1TyConName :: Name
sTyConKey :: Unique
sTyConName :: Name
sappendClassOpKey :: Unique
sappendName :: Name
selName_RDR :: RdrName
selectorClassKey :: Unique
selectorClassName :: Name
semigroupClassKey :: Unique
semigroupClassName :: Name
seqHashKey :: Unique
seqHashName :: Name
seqIdKey :: Unique
setFieldClassOpKey :: Unique
setFieldName :: Name
showClassKey :: Unique
showClassName :: Name
showCommaSpace_RDR :: RdrName
showParen_RDR :: RdrName
showSpace_RDR :: RdrName
showString_RDR :: RdrName
showsPrec_RDR :: RdrName
shows_RDR :: RdrName
smallArrayPrimTyConKey :: Unique
smallMutableArrayPrimTyConKey :: Unique
someTypeRepDataConKey :: Unique
someTypeRepDataConName :: Name
someTypeRepTyConKey :: Unique
someTypeRepTyConName :: Name
sourceLazyDataConKey :: Unique
sourceLazyDataConName :: Name
sourceNoUnpackDataConKey :: Unique
sourceNoUnpackDataConName :: Name
sourceStrictDataConKey :: Unique
sourceStrictDataConName :: Name
sourceUnpackDataConKey :: Unique
sourceUnpackDataConName :: Name
specTyConKey :: Unique
specTyConName :: Name
srcLocDataConKey :: Unique
srcLocDataConName :: Name
stableNameDataConKey :: Unique
stableNamePrimTyConKey :: Unique
stableNameTyConKey :: Unique
stablePtrPrimTyConKey :: Unique
stablePtrTyConKey :: Unique
stablePtrTyConName :: Name
stackSnapshotPrimTyConKey :: Unique
standardClassKeys :: [Unique]
starArrStarArrStarKindRepKey :: Unique
starArrStarArrStarKindRepName :: Name
starArrStarKindRepKey :: Unique
starArrStarKindRepName :: Name
starKindRepKey :: Unique
starKindRepName :: Name
statePrimTyConKey :: Unique
staticPtrDataConKey :: Unique
staticPtrDataConName :: Name
staticPtrInfoDataConKey :: Unique
staticPtrInfoDataConName :: Name
staticPtrInfoTyConKey :: Unique
staticPtrInfoTyConName :: Name
staticPtrTyConKey :: Unique
staticPtrTyConName :: Name
step_RDR :: RdrName
stringTyConKey :: Unique
succError_RDR :: RdrName
succ_RDR :: RdrName
sumRepDataConKey :: Unique
sumTyConKey :: Unique
sumTyConName :: Name
symbol_RDR :: RdrName
tVarPrimTyConKey :: Unique
tYPETyConKey :: Unique
tcArrowTyConKey :: Unique
tcQual :: Module -> FastString -> Unique -> Name
tcQual_RDR :: Module -> FastString -> RdrName
thenAClassOpKey :: Unique
thenAName :: Name
thenIOIdKey :: Unique
thenIOName :: Name
thenMClassOpKey :: Unique
thenMName :: Name
threadIdPrimTyConKey :: Unique
times_RDR :: RdrName
to1_RDR :: RdrName
toAnnotationWrapperIdKey :: Unique
toAnnotationWrapperName :: Name
toDynIdKey :: Unique
toDynName :: Name
toEnumError_RDR :: RdrName
toEnum_RDR :: RdrName
toIntegerClassOpKey :: Unique
toIntegerName :: Name
toListClassOpKey :: Unique
toListName :: Name
toRationalClassOpKey :: Unique
toRationalName :: Name
to_RDR :: RdrName
trGhcPrimModuleKey :: Unique
trGhcPrimModuleName :: Name
trModuleDataConKey :: Unique
trModuleDataConName :: Name
trModuleTyConKey :: Unique
trModuleTyConName :: Name
trNameDDataConKey :: Unique
trNameDDataConName :: Name
trNameSDataConKey :: Unique
trNameSDataConName :: Name
trNameTyConKey :: Unique
trNameTyConName :: Name
trTyConDataConKey :: Unique
trTyConDataConName :: Name
trTyConTyConKey :: Unique
trTyConTyConName :: Name
traceKey :: Unique
traceName :: Name
traversableClassKey :: Unique
traversableClassName :: Name
traverse_RDR :: RdrName
trueDataConKey :: Unique
tupleRepDataConKey :: Unique
tupleRepDataConTyConKey :: Unique
typeCharCmpTyFamNameKey :: Unique
typeCharKindConNameKey :: Unique
typeCharToNatTyFamNameKey :: Unique
typeCharTypeRepKey :: Unique
typeCharTypeRepName :: Name
typeConKey :: Unique
typeConsSymbolTyFamNameKey :: Unique
typeErrorAppendDataConKey :: Unique
typeErrorAppendDataConName :: Name
typeErrorIdKey :: Unique
typeErrorShowTypeDataConKey :: Unique
typeErrorShowTypeDataConName :: Name
typeErrorTextDataConKey :: Unique
typeErrorTextDataConName :: Name
typeErrorVAppendDataConKey :: Unique
typeErrorVAppendDataConName :: Name
typeLeqCharTyFamNameKey :: Unique
typeLitCharDataConKey :: Unique
typeLitCharDataConName :: Name
typeLitNatDataConKey :: Unique
typeLitNatDataConName :: Name
typeLitSortTyConKey :: Unique
typeLitSortTyConName :: Name
typeLitSymbolDataConKey :: Unique
typeLitSymbolDataConName :: Name
typeNatAddTyFamNameKey :: Unique
typeNatCmpTyFamNameKey :: Unique
typeNatDivTyFamNameKey :: Unique
typeNatExpTyFamNameKey :: Unique
typeNatLogTyFamNameKey :: Unique
typeNatModTyFamNameKey :: Unique
typeNatMulTyFamNameKey :: Unique
typeNatSubTyFamNameKey :: Unique
typeNatToCharTyFamNameKey :: Unique
typeNatTypeRepKey :: Unique
typeNatTypeRepName :: Name
typeRepIdKey :: Unique
typeRepIdName :: Name
typeRepTyConKey :: Unique
typeRepTyConName :: Name
typeSymbolAppendFamNameKey :: Unique
typeSymbolCmpTyFamNameKey :: Unique
typeSymbolKindConNameKey :: Unique
typeSymbolTypeRepKey :: Unique
typeSymbolTypeRepName :: Name
typeUnconsSymbolTyFamNameKey :: Unique
typeableClassKey :: Unique
typeableClassName :: Name
u1DataCon_RDR :: RdrName
u1TyConKey :: Unique
u1TyConName :: Name
uAddrDataCon_RDR :: RdrName
uAddrHash_RDR :: RdrName
uAddrTyConKey :: Unique
uAddrTyConName :: Name
uCharDataCon_RDR :: RdrName
uCharHash_RDR :: RdrName
uCharTyConKey :: Unique
uCharTyConName :: Name
uDoubleDataCon_RDR :: RdrName
uDoubleHash_RDR :: RdrName
uDoubleTyConKey :: Unique
uDoubleTyConName :: Name
uFloatDataCon_RDR :: RdrName
uFloatHash_RDR :: RdrName
uFloatTyConKey :: Unique
uFloatTyConName :: Name
uIntDataCon_RDR :: RdrName
uIntHash_RDR :: RdrName
uIntTyConKey :: Unique
uIntTyConName :: Name
uRecTyConKey :: Unique
uRecTyConName :: Name
uWordDataCon_RDR :: RdrName
uWordHash_RDR :: RdrName
uWordTyConKey :: Unique
uWordTyConName :: Name
unComp1_RDR :: RdrName
unK1_RDR :: RdrName
unPar1_RDR :: RdrName
unRec1_RDR :: RdrName
unboundKey :: Unique
unliftedDataConKey :: Unique
unliftedRepTyConKey :: Unique
unliftedTypeKindTyConKey :: Unique
unpackCStringAppendIdKey :: Unique
unpackCStringAppendName :: Name
unpackCStringAppendUtf8IdKey :: Unique
unpackCStringAppendUtf8Name :: Name
unpackCStringFoldrIdKey :: Unique
unpackCStringFoldrName :: Name
unpackCStringFoldrUtf8IdKey :: Unique
unpackCStringFoldrUtf8Name :: Name
unpackCStringIdKey :: Unique
unpackCStringName :: Name
unpackCStringUtf8IdKey :: Unique
unpackCStringUtf8Name :: Name
unrestrictedFunTyConKey :: Unique
unsafeCoercePrimIdKey :: Unique
unsafeCoercePrimName :: Name
unsafeEqualityProofIdKey :: Unique
unsafeEqualityProofName :: Name
unsafeEqualityTyConKey :: Unique
unsafeEqualityTyConName :: Name
unsafeIndex_RDR :: RdrName
unsafeRangeSize_RDR :: RdrName
unsafeReflDataConKey :: Unique
unsafeReflDataConName :: Name
unsatisfiableClassName :: Name
unsatisfiableClassNameKey :: Unique
unsatisfiableIdName :: Name
unsatisfiableIdNameKey :: Unique
v1TyConKey :: Unique
v1TyConName :: Name
varQual :: Module -> FastString -> Unique -> Name
varQual_RDR :: Module -> FastString -> RdrName
vecCountDataConKeys :: [Unique]
vecCountTyConKey :: Unique
vecElemDataConKeys :: [Unique]
vecElemTyConKey :: Unique
vecRepDataConKey :: Unique
voidArgIdKey :: Unique
voidPrimIdKey :: Unique
voidTyConKey :: Unique
voidTyConName :: Name
weakPrimTyConKey :: Unique
wildCardKey :: Unique
wildCardName :: Name
withDictClassKey :: Unique
withDictClassName :: Name
word16PrimTyConKey :: Unique
word16TyConKey :: Unique
word16TyConName :: Name
word16X16PrimTyConKey :: Unique
word16X32PrimTyConKey :: Unique
word16X8PrimTyConKey :: Unique
word32PrimTyConKey :: Unique
word32TyConKey :: Unique
word32TyConName :: Name
word32X16PrimTyConKey :: Unique
word32X4PrimTyConKey :: Unique
word32X8PrimTyConKey :: Unique
word64PrimTyConKey :: Unique
word64TyConKey :: Unique
word64TyConName :: Name
word64X2PrimTyConKey :: Unique
word64X4PrimTyConKey :: Unique
word64X8PrimTyConKey :: Unique
word8DataConKey :: Unique
word8PrimTyConKey :: Unique
word8TyConKey :: Unique
word8TyConName :: Name
word8X16PrimTyConKey :: Unique
word8X32PrimTyConKey :: Unique
word8X64PrimTyConKey :: Unique
wordDataConKey :: Unique
wordPrimTyConKey :: Unique
wordTyConKey :: Unique
zeroBitRepTyConKey :: Unique
zeroBitTypeTyConKey :: Unique
zipIdKey :: Unique
zipName :: Name
zonkAnyTyConKey :: Unique

module GHC.Core.TyCon

-- | TyCons represent type constructors. Type constructors are introduced
--   by things such as:
--   
--   1) Data declarations: <tt>data Foo = ...</tt> creates the <tt>Foo</tt>
--   type constructor of kind <tt>Type</tt>
--   
--   2) Type synonyms: <tt>type Foo = ...</tt> creates the <tt>Foo</tt>
--   type constructor
--   
--   3) Newtypes: <tt>newtype Foo a = MkFoo ...</tt> creates the
--   <tt>Foo</tt> type constructor of kind <tt>Type -&gt; Type</tt>
--   
--   4) Class declarations: <tt>class Foo where</tt> creates the
--   <tt>Foo</tt> type constructor of kind <tt>Constraint</tt>
--   
--   This data type also encodes a number of primitive, built in type
--   constructors such as those for function and tuple types.
--   
--   If you edit this type, you may need to update the GHC formalism See
--   Note [GHC Formalism] in GHC.Core.Lint
data TyCon

-- | Represents right-hand-sides of <a>TyCon</a>s for algebraic types
data AlgTyConRhs

-- | Says that we know nothing about this data type, except that it's
--   represented by a pointer. Used when we export a data type abstractly
--   into an .hi file.
AbstractTyCon :: AlgTyConRhs

-- | Information about those <a>TyCon</a>s derived from a <tt>data</tt>
--   declaration. This includes data types with no constructors at all.
DataTyCon :: [DataCon] -> Int -> Bool -> Bool -> Bool -> AlgTyConRhs

-- | The data type constructors; can be empty if the user declares the type
--   to have no constructors
--   
--   INVARIANT: Kept in order of increasing <a>DataCon</a> tag (see the tag
--   assignment in mkTyConTagMap)
[data_cons] :: AlgTyConRhs -> [DataCon]

-- | Cached value: length data_cons
[data_cons_size] :: AlgTyConRhs -> Int

-- | Cached value: is this an enumeration type? See Note [Enumeration
--   types]
[is_enum] :: AlgTyConRhs -> Bool
[is_type_data] :: AlgTyConRhs -> Bool

-- | <a>True</a> if the data type constructor has a known, fixed levity
--   when fully applied to its arguments, False otherwise.
--   
--   This can only be <a>False</a> with UnliftedDatatypes, e.g.
--   
--   <pre>
--   data A :: TYPE (BoxedRep l) where { MkA :: Int -&gt; A }
--   </pre>
--   
--   This boolean is cached to make it cheaper to check for levity and
--   representation-polymorphism in tcHasFixedRuntimeRep.
[data_fixed_lev] :: AlgTyConRhs -> Bool
TupleTyCon :: DataCon -> TupleSort -> AlgTyConRhs

-- | The unique constructor for the <tt>newtype</tt>. It has no
--   existentials
[data_con] :: AlgTyConRhs -> DataCon

-- | Is this a boxed, unboxed or constraint tuple?
[tup_sort] :: AlgTyConRhs -> TupleSort

-- | An unboxed sum type.
SumTyCon :: [DataCon] -> Int -> AlgTyConRhs

-- | The data type constructors; can be empty if the user declares the type
--   to have no constructors
--   
--   INVARIANT: Kept in order of increasing <a>DataCon</a> tag (see the tag
--   assignment in mkTyConTagMap)
[data_cons] :: AlgTyConRhs -> [DataCon]

-- | Cached value: length data_cons
[data_cons_size] :: AlgTyConRhs -> Int

-- | Information about those <a>TyCon</a>s derived from a <tt>newtype</tt>
--   declaration
NewTyCon :: DataCon -> Type -> ([TyVar], Type) -> CoAxiom Unbranched -> Bool -> AlgTyConRhs

-- | The unique constructor for the <tt>newtype</tt>. It has no
--   existentials
[data_con] :: AlgTyConRhs -> DataCon

-- | Cached value: the argument type of the constructor, which is just the
--   representation type of the <a>TyCon</a> (remember that
--   <tt>newtype</tt>s do not exist at runtime so need a different
--   representation type).
--   
--   The free <a>TyVar</a>s of this type are the <a>tyConTyVars</a> from
--   the corresponding <a>TyCon</a>
[nt_rhs] :: AlgTyConRhs -> Type

-- | Same as the <a>nt_rhs</a>, but this time eta-reduced. Hence the list
--   of <a>TyVar</a>s in this field may be shorter than the declared arity
--   of the <a>TyCon</a>.
[nt_etad_rhs] :: AlgTyConRhs -> ([TyVar], Type)
[nt_co] :: AlgTyConRhs -> CoAxiom Unbranched

-- | <a>True</a> if the newtype has a known, fixed representation when
--   fully applied to its arguments, <a>False</a> otherwise. This can only
--   ever be <a>False</a> with UnliftedNewtypes.
--   
--   Example:
--   
--   <pre>
--   newtype N (a :: TYPE r) = MkN a
--   </pre>
--   
--   Invariant: nt_fixed_rep nt = tcHasFixedRuntimeRep (nt_rhs nt)
--   
--   This boolean is cached to make it cheaper to check if a variable
--   binding is representation-polymorphic in tcHasFixedRuntimeRep.
[nt_fixed_rep] :: AlgTyConRhs -> Bool

-- | Extract those <a>DataCon</a>s that we are able to learn about. Note
--   that visibility in this sense does not correspond to visibility in the
--   context of any particular user program!
visibleDataCons :: AlgTyConRhs -> [DataCon]

-- | Describes the flavour of an algebraic type constructor. For classes
--   and data families, this flavour includes a reference to the parent
--   <a>TyCon</a>.
data AlgTyConFlav

-- | An ordinary algebraic type constructor. This includes unlifted and
--   representation-polymorphic datatypes and newtypes and unboxed tuples,
--   but NOT unboxed sums; see UnboxedSumTyCon.
VanillaAlgTyCon :: TyConRepName -> AlgTyConFlav

-- | An unboxed sum type constructor. This is distinct from VanillaAlgTyCon
--   because we currently don't allow unboxed sums to be Typeable since
--   there are too many of them. See #13276.
UnboxedSumTyCon :: AlgTyConFlav

-- | Type constructors representing a class dictionary. See Note [ATyCon
--   for classes] in <a>GHC.Core.TyCo.Rep</a>
ClassTyCon :: Class -> TyConRepName -> AlgTyConFlav

-- | Type constructors representing an *instance* of a *data* family.
--   Parameters:
--   
--   1) The type family in question
--   
--   2) Instance types; free variables are the <a>tyConTyVars</a> of the
--   current <a>TyCon</a> (not the family one). INVARIANT: the number of
--   types matches the arity of the family <a>TyCon</a>
--   
--   3) A <tt>CoTyCon</tt> identifying the representation type with the
--   type instance family
DataFamInstTyCon :: CoAxiom Unbranched -> TyCon -> [Type] -> AlgTyConFlav
isNoParent :: AlgTyConFlav -> Bool

-- | Information pertaining to the expansion of a type synonym
--   (<tt>type</tt>)
data FamTyConFlav

-- | Represents an open type family without a fixed right hand side.
--   Additional instances can appear at any time.
--   
--   These are introduced by either a top level declaration:
--   
--   <pre>
--   data family T a :: Type
--   </pre>
--   
--   Or an associated data type declaration, within a class declaration:
--   
--   <pre>
--   class C a b where
--     data T b :: Type
--   </pre>
DataFamilyTyCon :: TyConRepName -> FamTyConFlav

-- | An open type synonym family e.g. <tt>type family F x y :: Type -&gt;
--   Type</tt>
OpenSynFamilyTyCon :: FamTyConFlav

-- | A closed type synonym family e.g. <tt>type family F x where { F Int =
--   Bool }</tt>
ClosedSynFamilyTyCon :: Maybe (CoAxiom Branched) -> FamTyConFlav

-- | A closed type synonym family declared in an hs-boot file with type
--   family F a where ..
AbstractClosedSynFamilyTyCon :: FamTyConFlav

-- | Built-in type family used by the TypeNats solver
BuiltInSynFamTyCon :: BuiltInSynFamily -> FamTyConFlav

-- | See Note [Roles] in GHC.Core.Coercion
--   
--   Order of constructors matters: the Ord instance coincides with the
--   *super*typing relation on roles.
data Role
Nominal :: Role
Representational :: Role
Phantom :: Role
data Injectivity
NotInjective :: Injectivity
Injective :: [Bool] -> Injectivity

-- | Some promoted datacons signify extra info relevant to GHC. For
--   example, the <a>IntRep</a> constructor of <a>RuntimeRep</a>
--   corresponds to the <a>IntRep</a> constructor of <a>PrimRep</a>. This
--   data structure allows us to store this information right in the
--   <a>TyCon</a>. The other approach would be to look up things like
--   <a>RuntimeRep</a>'s <a>PrimRep</a> by known-key every time. See also
--   Note [Getting from RuntimeRep to PrimRep] in <a>GHC.Types.RepType</a>
data PromDataConInfo

-- | an ordinary promoted data con
NoPromInfo :: PromDataConInfo

-- | A constructor of <a>RuntimeRep</a>. The argument to the function
--   should be the list of arguments to the promoted datacon.
RuntimeRep :: ([Type] -> [PrimRep]) -> PromDataConInfo

-- | A constructor of <a>VecCount</a>
VecCount :: Int -> PromDataConInfo

-- | A constructor of <a>VecElem</a>
VecElem :: PrimElemRep -> PromDataConInfo

-- | A constructor of <a>Levity</a>
Levity :: Levity -> PromDataConInfo

-- | Paints a picture of what a <a>TyCon</a> represents, in broad strokes.
--   This is used towards more informative error messages.
data TyConFlavour tc
ClassFlavour :: TyConFlavour tc
TupleFlavour :: Boxity -> TyConFlavour tc
SumFlavour :: TyConFlavour tc
DataTypeFlavour :: TyConFlavour tc
NewtypeFlavour :: TyConFlavour tc
AbstractTypeFlavour :: TyConFlavour tc
OpenFamilyFlavour :: TypeOrData -> Maybe tc -> TyConFlavour tc
ClosedTypeFamilyFlavour :: TyConFlavour tc
TypeSynonymFlavour :: TyConFlavour tc

-- | e.g., the <tt>(-&gt;)</tt> <a>TyCon</a>.
BuiltInTypeFlavour :: TyConFlavour tc
PromotedDataConFlavour :: TyConFlavour tc
type TyConBinder = VarBndr TyVar TyConBndrVis
data TyConBndrVis

-- | A named, forall-bound variable (invisible or not)
NamedTCB :: ForAllTyFlag -> TyConBndrVis

-- | an ordinary, visible type argument
AnonTCB :: TyConBndrVis
mkNamedTyConBinder :: ForAllTyFlag -> TyVar -> TyConBinder
mkNamedTyConBinders :: ForAllTyFlag -> [TyVar] -> [TyConBinder]

-- | Make a Required TyConBinder. It chooses between NamedTCB and AnonTCB
--   based on whether the tv is mentioned in the dependent set
mkRequiredTyConBinder :: TyCoVarSet -> TyVar -> TyConBinder
mkAnonTyConBinder :: TyVar -> TyConBinder
mkAnonTyConBinders :: [TyVar] -> [TyConBinder]
tyConBinderForAllTyFlag :: TyConBinder -> ForAllTyFlag
tyConBndrVisForAllTyFlag :: TyConBndrVis -> ForAllTyFlag
isNamedTyConBinder :: TyConBinder -> Bool
isVisibleTyConBinder :: VarBndr tv TyConBndrVis -> Bool
isInvisibleTyConBinder :: VarBndr tv TyConBndrVis -> Bool
isVisibleTcbVis :: TyConBndrVis -> Bool
isInvisSpecTcbVis :: TyConBndrVis -> Bool

-- | The labels for the fields of this particular <a>TyCon</a>
tyConFieldLabels :: TyCon -> [FieldLabel]

-- | Look up a field label belonging to this <a>TyCon</a>
lookupTyConFieldLabel :: FieldLabelString -> TyCon -> Maybe FieldLabel

-- | This is the making of an algebraic <a>TyCon</a>.
mkAlgTyCon :: Name -> [TyConBinder] -> Kind -> [Role] -> Maybe CType -> [PredType] -> AlgTyConRhs -> AlgTyConFlav -> Bool -> TyCon

-- | Simpler specialization of <a>mkAlgTyCon</a> for classes
mkClassTyCon :: Name -> [TyConBinder] -> [Role] -> AlgTyConRhs -> Class -> Name -> TyCon

-- | Create an primitive <a>TyCon</a>, such as <tt>Int#</tt>, <tt>Type</tt>
--   or <tt>RealWorld</tt> Primitive TyCons are marshalable iff not lifted.
--   If you'd like to change this, modify marshalablePrimTyCon.
mkPrimTyCon :: Name -> [TyConBinder] -> Kind -> [Role] -> TyCon
mkTupleTyCon :: Name -> [TyConBinder] -> Kind -> DataCon -> TupleSort -> AlgTyConFlav -> TyCon
mkSumTyCon :: Name -> [TyConBinder] -> Kind -> [DataCon] -> AlgTyConFlav -> TyCon

-- | Create an <a>AlgTyConRhs</a> from the data constructors.
--   
--   Use <tt>mkLevPolyDataConRhs</tt> if the datatype can be
--   levity-polymorphic or if it comes from a "data type" declaration
mkDataTyConRhs :: [DataCon] -> AlgTyConRhs

-- | Create an <a>AlgTyConRhs</a> from the data constructors, for a
--   potentially levity-polymorphic datatype (with
--   <tt>UnliftedDatatypes</tt>).
mkLevPolyDataTyConRhs :: Bool -> Bool -> [DataCon] -> AlgTyConRhs

-- | Create a type synonym <a>TyCon</a>
mkSynonymTyCon :: Name -> [TyConBinder] -> Kind -> [Role] -> Type -> Bool -> Bool -> Bool -> Bool -> TyCon

-- | Create a type family <a>TyCon</a>
mkFamilyTyCon :: Name -> [TyConBinder] -> Kind -> Maybe Name -> FamTyConFlav -> Maybe Class -> Injectivity -> TyCon

-- | Create a promoted data constructor <a>TyCon</a> Somewhat dodgily, we
--   give it the same Name as the data constructor itself; when we
--   pretty-print the TyCon we add a quote; see the Outputable TyCon
--   instance
mkPromotedDataCon :: DataCon -> Name -> TyConRepName -> [TyConBinder] -> Kind -> [Role] -> PromDataConInfo -> TyCon

-- | Makes a tycon suitable for use during type-checking. It stores a
--   variety of details about the definition of the TyCon, but no
--   right-hand side. It lives only during the type-checking of a
--   mutually-recursive group of tycons; it is then zonked to a proper
--   TyCon in zonkTcTyCon. See Note [TcTyCon, MonoTcTyCon, and PolyTcTyCon]
--   in <a>GHC.Tc.TyCl</a>
mkTcTyCon :: Name -> [TyConBinder] -> Kind -> [(Name, TcTyVar)] -> Bool -> TyConFlavour TyCon -> TyCon

-- | No scoped type variables (to be used with mkTcTyCon).
noTcTyConScopedTyVars :: [(Name, TcTyVar)]

-- | Returns <tt>True</tt> if the supplied <a>TyCon</a> resulted from
--   either a <tt>data</tt> or <tt>newtype</tt> declaration
isAlgTyCon :: TyCon -> Bool

-- | Returns <tt>True</tt> for vanilla AlgTyCons -- that is, those created
--   with a <tt>data</tt> or <tt>newtype</tt> declaration.
isVanillaAlgTyCon :: TyCon -> Bool

-- | Is this <a>TyCon</a> that for a class instance?
isClassTyCon :: TyCon -> Bool

-- | Is this <a>TyCon</a> that for a data family instance?
isFamInstTyCon :: TyCon -> Bool

-- | Does this <a>TyCon</a> represent something that cannot be defined in
--   Haskell?
isPrimTyCon :: TyCon -> Bool

-- | Does this <a>TyCon</a> represent a tuple?
--   
--   NB: when compiling <tt>Data.Tuple</tt>, the tycons won't reply
--   <tt>True</tt> to <a>isTupleTyCon</a>, because they are built as
--   <tt>AlgTyCons</tt>. However they get spat into the interface file as
--   tuple tycons, so I don't think it matters.
isTupleTyCon :: TyCon -> Bool

-- | Is this the <a>TyCon</a> for an unboxed tuple?
isUnboxedTupleTyCon :: TyCon -> Bool

-- | Is this the <a>TyCon</a> for a boxed tuple?
isBoxedTupleTyCon :: TyCon -> Bool

-- | Is this the <a>TyCon</a> for an unboxed sum?
isUnboxedSumTyCon :: TyCon -> Bool

-- | Is this the <a>TyCon</a> for a <i>promoted</i> tuple?
isPromotedTupleTyCon :: TyCon -> Bool
isLiftedAlgTyCon :: TyCon -> Bool

-- | Is this a <a>TyCon</a> representing a regular H98 type synonym
--   (<tt>type</tt>)?
isTypeSynonymTyCon :: TyCon -> Bool

-- | True iff we can decompose (T a b c) into ((T a b) c) I.e. is it
--   injective and generative w.r.t nominal equality? That is, if (T a b)
--   ~N d e f, is it always the case that (T ~N d), (a ~N e) and (b ~N f)?
--   Specifically NOT true of synonyms (open and otherwise)
--   
--   It'd be unusual to call tyConMustBeSaturated on a regular H98 type
--   synonym, because you should probably have expanded it first But
--   regardless, it's not decomposable
tyConMustBeSaturated :: TyCon -> Bool

-- | Is this a PromotedDataCon?
isPromotedDataCon :: TyCon -> Bool

-- | Retrieves the promoted DataCon if this is a PromotedDataCon;
isPromotedDataCon_maybe :: TyCon -> Maybe DataCon

-- | This function identifies PromotedDataCon's from data constructors in
--   `data T = K1 | K2`, promoted by -XDataKinds. These type constructors
--   are printed with a tick mark 'K1 and 'K2, and similarly have a tick
--   mark added to their OccName's.
--   
--   In contrast, constructors in `type data T = K1 | K2` are printed and
--   represented with their original undecorated names. See Note [Type data
--   declarations] in GHC.Rename.Module
isDataKindsPromotedDataCon :: TyCon -> Bool

-- | Is this <a>TyCon</a> really meant for use at the kind level? That is,
--   should it be permitted without <tt>DataKinds</tt>?
isKindTyCon :: TyCon -> Bool

-- | This is <a>Name</a> really meant for use at the kind level? That is,
--   should it be permitted wihout <tt>DataKinds</tt>?
isKindName :: Name -> Bool
isLiftedTypeKindTyConName :: Name -> Bool
isTauTyCon :: TyCon -> Bool

-- | Is this tycon neither a type family nor a synonym that expands to a
--   type family?
isFamFreeTyCon :: TyCon -> Bool

-- | Is this a forgetful type synonym? If this is a type synonym whose RHS
--   does not mention one (or more) of its bound variables, returns True.
--   Thus, False means that all bound variables appear on the RHS; True may
--   not mean anything, as the test to set this flag is conservative.
--   
--   See Note [Forgetful type synonyms]
isForgetfulSynTyCon :: TyCon -> Bool

-- | Returns <tt>True</tt> for data types that are <i>definitely</i>
--   represented by heap-allocated constructors. These are scrutinised by
--   Core-level <tt>case</tt> expressions, and they get info tables
--   allocated for them.
--   
--   Generally, the function will be true for all <tt>data</tt> types and
--   false for <tt>newtype</tt>s, unboxed tuples, unboxed sums and type
--   family <a>TyCon</a>s. But it is not guaranteed to return <tt>True</tt>
--   in all cases that it could.
--   
--   NB: for a data type family, only the <i>instance</i> <a>TyCon</a>s get
--   an info table. The family declaration <a>TyCon</a> does not
isDataTyCon :: TyCon -> Bool

-- | Was this <a>TyCon</a> declared as "type data"? See Note [Type data
--   declarations] in GHC.Rename.Module.
isTypeDataTyCon :: TyCon -> Bool

-- | Is this an algebraic <a>TyCon</a> which is just an enumeration of
--   values?
isEnumerationTyCon :: TyCon -> Bool

-- | Is this <a>TyCon</a> that for a <tt>newtype</tt>
isNewTyCon :: TyCon -> Bool

-- | Test if the <a>TyCon</a> is algebraic but abstract (invisible data
--   constructors)
isAbstractTyCon :: TyCon -> Bool

-- | Is this a <a>TyCon</a>, synonym or otherwise, that defines a family?
isFamilyTyCon :: TyCon -> Bool

-- | Is this a <a>TyCon</a>, synonym or otherwise, that defines a family
--   with instances?
isOpenFamilyTyCon :: TyCon -> Bool

-- | Is this a type family <a>TyCon</a> (whether open or closed)?
isTypeFamilyTyCon :: TyCon -> Bool

-- | Is this a data family <a>TyCon</a>?
isDataFamilyTyCon :: TyCon -> Bool

-- | Is this an open type family TyCon?
isOpenTypeFamilyTyCon :: TyCon -> Bool

-- | Is this a non-empty closed type family? Returns <a>Nothing</a> for
--   abstract or empty closed families.
isClosedSynFamilyTyConWithAxiom_maybe :: TyCon -> Maybe (CoAxiom Branched)

-- | <tt><a>tyConInjectivityInfo</a> tc</tt> returns <tt><a>Injective</a>
--   is</tt> if <tt>tc</tt> is an injective tycon (where <tt>is</tt> states
--   for which <a>tyConBinders</a> <tt>tc</tt> is injective), or
--   <a>NotInjective</a> otherwise.
tyConInjectivityInfo :: TyCon -> Injectivity
isBuiltInSynFamTyCon_maybe :: TyCon -> Maybe BuiltInSynFamily

-- | Is this an algebraic <a>TyCon</a> declared with the GADT syntax?
isGadtSyntaxTyCon :: TyCon -> Bool

-- | <a>isInjectiveTyCon</a> is true of <a>TyCon</a>s for which this
--   property holds (where r is the role passed in): If (T a1 b1 c1) ~r (T
--   a2 b2 c2), then (a1 ~r1 a2), (b1 ~r2 b2), and (c1 ~r3 c2) (where r1,
--   r2, and r3, are the roles given by tyConRolesX tc r) See also Note
--   [Decomposing TyConApp equalities] in <a>GHC.Tc.Solver.Equality</a>
isInjectiveTyCon :: TyCon -> Role -> Bool

-- | <a>isGenerativeTyCon</a> is true of <a>TyCon</a>s for which this
--   property holds (where r is the role passed in): If (T tys ~r t), then
--   (t's head ~r T). See also Note [Decomposing TyConApp equalities] in
--   <a>GHC.Tc.Solver.Equality</a>
--   
--   NB: at Nominal role, isGenerativeTyCon is simple: isGenerativeTyCon tc
--   Nominal = not (isTypeFamilyTyCon tc || isSynonymTyCon tc)
isGenerativeTyCon :: TyCon -> Role -> Bool

-- | Is this an <a>AlgTyConRhs</a> of a <a>TyCon</a> that is generative and
--   injective with respect to representational equality?
isGenInjAlgRhs :: AlgTyConRhs -> Bool

-- | Is this TyCon for an associated type?
isTyConAssoc :: TyCon -> Bool

-- | Get the enclosing class TyCon (if there is one) for the given TyCon.
tyConAssoc_maybe :: TyCon -> Maybe TyCon

-- | Get the enclosing class TyCon (if there is one) for the given
--   TyConFlavour
tyConFlavourAssoc_maybe :: TyConFlavour tc -> Maybe tc

-- | Identifies implicit tycons that, in particular, do not go into
--   interface files (because they are implicitly reconstructed when the
--   interface is read).
--   
--   Note that:
--   
--   <ul>
--   <li>Associated families are implicit, as they are re-constructed from
--   the class declaration in which they reside, and</li>
--   <li>Family instances are <i>not</i> implicit as they represent the
--   instance body (similar to a <tt>dfun</tt> does that for a class
--   instance).</li>
--   <li>Tuples are implicit iff they have a wired-in name (namely: boxed
--   and unboxed tuples are wired-in and implicit, but constraint tuples
--   are not)</li>
--   </ul>
isImplicitTyCon :: TyCon -> Bool

-- | Check if the tycon actually refers to a proper `data` or `newtype`
--   with user defined constructors rather than one from a class or other
--   construction.
isTyConWithSrcDataCons :: TyCon -> Bool

-- | Is this a TcTyCon? (That is, one only used during type-checking?)
isTcTyCon :: TyCon -> Bool
setTcTyConKind :: TyCon -> Kind -> TyCon

-- | Does this <a>TyCon</a> have a syntactically fixed RuntimeRep when
--   fully applied, as per Note [Fixed RuntimeRep] in
--   GHC.Tc.Utils.Concrete?
--   
--   False is safe. True means we're sure. Does only a quick check, based
--   on the TyCon's category.
--   
--   See Note [Representation-polymorphic TyCons]
tcHasFixedRuntimeRep :: TyCon -> Bool

-- | Is this <a>TyCon</a> concrete? More specifically, if <tt>tys</tt> are
--   all concrete, is (T tys) concrete? (for synonyms this requires us to
--   look at the RHS) Used for representation polymorphism checks. See Note
--   [Concrete types] in GHC.Tc.Utils.Concrete
isConcreteTyCon :: TyCon -> Bool

-- | Returns <tt>True</tt> if a boxed type headed by the given
--   <tt>TyCon</tt> satisfies condition DTT2 of Note [DataToTag overview]
--   in GHC.Tc.Instance.Class
isValidDTT2TyCon :: TyCon -> Bool

-- | Name of the constructor
tyConName :: TyCon -> Name

-- | Returns whether or not this <a>TyCon</a> is definite, or a hole that
--   may be filled in at some later point. See Note [Skolem abstract data]
tyConSkolem :: TyCon -> Bool

-- | Kind of this TyCon
tyConKind :: TyCon -> Kind

-- | A Unique of this TyCon. Invariant: identical to Unique of Name stored
--   in tyConName field.
tyConUnique :: TyCon -> Unique

-- | TyVar binders
tyConTyVars :: TyCon -> [TyVar]
tyConVisibleTyVars :: TyCon -> [TyVar]
tyConCType_maybe :: TyCon -> Maybe CType

-- | As <a>tyConDataCons_maybe</a>, but returns the empty list of
--   constructors if no constructors could be found
tyConDataCons :: TyCon -> [DataCon]

-- | Determine the <a>DataCon</a>s originating from the given <a>TyCon</a>,
--   if the <a>TyCon</a> is the sort that can have any constructors (note:
--   this does not include abstract algebraic types)
tyConDataCons_maybe :: TyCon -> Maybe [DataCon]

-- | If the given <a>TyCon</a> has a <i>single</i> data constructor, i.e.
--   it is a <tt>data</tt> type with one alternative, a tuple type or a
--   <tt>newtype</tt> then that constructor is returned. If the
--   <a>TyCon</a> has more than one constructor, or represents a primitive
--   or function type constructor then <tt>Nothing</tt> is returned.
tyConSingleDataCon_maybe :: TyCon -> Maybe DataCon

-- | Like <a>tyConSingleDataCon_maybe</a>, but panics if <a>Nothing</a>.
tyConSingleDataCon :: TyCon -> DataCon

-- | Returns <tt>Just dcs</tt> if the given <a>TyCon</a> is a <tt>data</tt>
--   type, a tuple type or a sum type with data constructors dcs. If the
--   <a>TyCon</a> has more than one constructor, or represents a primitive
--   or function type constructor then <tt>Nothing</tt> is returned.
--   
--   Like <a>tyConDataCons_maybe</a>, but returns <a>Nothing</a> for
--   newtypes.
tyConAlgDataCons_maybe :: TyCon -> Maybe [DataCon]

-- | Like <a>tyConSingleDataCon_maybe</a>, but returns <a>Nothing</a> for
--   newtypes.
tyConSingleAlgDataCon_maybe :: TyCon -> Maybe DataCon

-- | Determine the number of value constructors a <a>TyCon</a> has. Panics
--   if the <a>TyCon</a> is not algebraic or a tuple
tyConFamilySize :: TyCon -> Int

-- | Find the "stupid theta" of the <a>TyCon</a>. A "stupid theta" is the
--   context to the left of an algebraic type declaration, e.g. <tt>Eq
--   a</tt> in the declaration <tt>data Eq a =&gt; T a ...</tt>. See
--   <tt>Note [The stupid context]</tt> in <a>GHC.Core.DataCon</a>.
tyConStupidTheta :: TyCon -> [PredType]

-- | Arity
tyConArity :: TyCon -> Arity

-- | A pre-allocated <tt>TyConApp tycon []</tt>
tyConNullaryTy :: TyCon -> Type

-- | (mkTyConTy tc) returns (TyConApp tc []) but arranges to share that
--   TyConApp among all calls See Note [Sharing nullary TyConApps] So it's
--   just an alias for tyConNullaryTy!
mkTyConTy :: TyCon -> Type

-- | The role for each type variable This list has length = tyConArity See
--   also Note [TyCon Role signatures]
tyConRoles :: TyCon -> [Role]
tyConFlavour :: TyCon -> TyConFlavour TyCon
tyConTuple_maybe :: TyCon -> Maybe TupleSort

-- | If this <a>TyCon</a> is that for a class instance, return the class it
--   is for. Otherwise returns <tt>Nothing</tt>
tyConClass_maybe :: TyCon -> Maybe Class

-- | Return the associated types of the <a>TyCon</a>, if any
tyConATs :: TyCon -> [TyCon]

-- | If this <a>TyCon</a> is that of a data family instance, return the
--   family in question and the instance types. Otherwise, return
--   <tt>Nothing</tt>
tyConFamInst_maybe :: TyCon -> Maybe (TyCon, [Type])
tyConFamInstSig_maybe :: TyCon -> Maybe (TyCon, [Type], CoAxiom Unbranched)

-- | If this <a>TyCon</a> is that of a data family instance, return a
--   <a>TyCon</a> which represents a coercion identifying the
--   representation type with the type instance family. Otherwise, return
--   <tt>Nothing</tt>
tyConFamilyCoercion_maybe :: TyCon -> Maybe (CoAxiom Unbranched)

-- | Extract type variable naming the result of injective type family
tyConFamilyResVar_maybe :: TyCon -> Maybe Name

-- | Extract the <a>TyVar</a>s bound by a vanilla type synonym and the
--   corresponding (unsubstituted) right hand side.
synTyConDefn_maybe :: TyCon -> Maybe ([TyVar], Type)

-- | Extract the information pertaining to the right hand side of a type
--   synonym (<tt>type</tt>) declaration.
synTyConRhs_maybe :: TyCon -> Maybe Type

-- | Extract the flavour of a type family (with all the extra information
--   that it carries)
famTyConFlav_maybe :: TyCon -> Maybe FamTyConFlav

-- | Extract an <a>AlgTyConRhs</a> with information about data constructors
--   from an algebraic or tuple <a>TyCon</a>. Panics for any other sort of
--   <a>TyCon</a>
algTyConRhs :: TyCon -> AlgTyConRhs

-- | Extract the bound type variables and type expansion of a type synonym
--   <a>TyCon</a>. Panics if the <a>TyCon</a> is not a synonym
newTyConRhs :: TyCon -> ([TyVar], Type)

-- | The number of type parameters that need to be passed to a newtype to
--   resolve it. May be less than in the definition if it can be
--   eta-contracted.
newTyConEtadArity :: TyCon -> Int

-- | Extract the bound type variables and type expansion of an
--   eta-contracted type synonym <a>TyCon</a>. Panics if the <a>TyCon</a>
--   is not a synonym
newTyConEtadRhs :: TyCon -> ([TyVar], Type)

-- | Take a <a>TyCon</a> apart into the <a>TyVar</a>s it scopes over, the
--   <a>Type</a> it expands into, and (possibly) a coercion from the
--   representation type to the <tt>newtype</tt>. Returns <tt>Nothing</tt>
--   if this is not possible.
unwrapNewTyCon_maybe :: TyCon -> Maybe ([TyVar], Type, CoAxiom Unbranched)
unwrapNewTyConEtad_maybe :: TyCon -> Maybe ([TyVar], Type, CoAxiom Unbranched)
newTyConDataCon_maybe :: TyCon -> Maybe DataCon

-- | Maps a label to information about the field
algTcFields :: TyConDetails -> FieldLabelEnv

-- | Extract any <tt>RuntimeRepInfo</tt> from this TyCon
tyConPromDataConInfo :: TyCon -> PromDataConInfo

-- | Full binders
tyConBinders :: TyCon -> [TyConBinder]

-- | Result kind
tyConResKind :: TyCon -> Kind
tyConInvisTVBinders :: [TyConBinder] -> [InvisTVBinder]
tcTyConScopedTyVars :: TyCon -> [(Name, TcTyVar)]
isMonoTcTyCon :: TyCon -> Bool
tyConHasClosedResKind :: TyCon -> Bool
mkTyConTagMap :: TyCon -> NameEnv ConTag
data ExpandSynResult tyco
NoExpansion :: ExpandSynResult tyco
ExpandsSyn :: [(TyVar, tyco)] -> Type -> [tyco] -> ExpandSynResult tyco
expandSynTyCon_maybe :: TyCon -> [tyco] -> ExpandSynResult tyco
newTyConCo :: TyCon -> CoAxiom Unbranched

-- | Extracts the <tt>newtype</tt> coercion from such a <a>TyCon</a>, which
--   can be used to construct something with the <tt>newtype</tt>s type
--   from its representation type (right hand side). If the supplied
--   <a>TyCon</a> is not a <tt>newtype</tt>, returns <tt>Nothing</tt>
newTyConCo_maybe :: TyCon -> Maybe (CoAxiom Unbranched)
pprPromotionQuote :: TyCon -> SDoc
mkTyConKind :: [TyConBinder] -> Kind -> Kind

-- | Is this flavour of <a>TyCon</a> an open type family or a data family?
tcFlavourIsOpen :: TyConFlavour tc -> Bool
type TyConRepName = Name
tyConRepName_maybe :: TyCon -> Maybe TyConRepName

-- | Make a <a>Name</a> for the <tt>Typeable</tt> representation of the
--   given wired-in type
mkPrelTyConRepName :: Name -> TyConRepName

-- | The name (and defining module) for the Typeable representation (TyCon)
--   of a type constructor.
--   
--   See Note [Grand plan for Typeable] in <a>GHC.Tc.Instance.Typeable</a>.
tyConRepModOcc :: Module -> OccName -> (Module, OccName)

-- | A <a>PrimRep</a> is an abstraction of a <i>non-void</i> type. (Use
--   <tt>PrimRepOrVoidRep</tt> if you want void types too.) It contains
--   information that the code generator needs in order to pass arguments,
--   return results, and store values of this type. See also Note
--   [RuntimeRep and PrimRep] in <a>GHC.Types.RepType</a> and Note
--   [VoidRep] in <a>GHC.Types.RepType</a>.
data PrimRep

-- | Boxed, heap value
BoxedRep :: {-# UNPACK #-} !Maybe Levity -> PrimRep

-- | Signed, 8-bit value
Int8Rep :: PrimRep

-- | Signed, 16-bit value
Int16Rep :: PrimRep

-- | Signed, 32-bit value
Int32Rep :: PrimRep

-- | Signed, 64 bit value
Int64Rep :: PrimRep

-- | Signed, word-sized value
IntRep :: PrimRep

-- | Unsigned, 8 bit value
Word8Rep :: PrimRep

-- | Unsigned, 16 bit value
Word16Rep :: PrimRep

-- | Unsigned, 32 bit value
Word32Rep :: PrimRep

-- | Unsigned, 64 bit value
Word64Rep :: PrimRep

-- | Unsigned, word-sized value
WordRep :: PrimRep

-- | A pointer, but <i>not</i> to a Haskell value (use <a>BoxedRep</a>)
AddrRep :: PrimRep
FloatRep :: PrimRep
DoubleRep :: PrimRep

-- | A vector
VecRep :: Int -> PrimElemRep -> PrimRep
data PrimElemRep
Int8ElemRep :: PrimElemRep
Int16ElemRep :: PrimElemRep
Int32ElemRep :: PrimElemRep
Int64ElemRep :: PrimElemRep
Word8ElemRep :: PrimElemRep
Word16ElemRep :: PrimElemRep
Word32ElemRep :: PrimElemRep
Word64ElemRep :: PrimElemRep
FloatElemRep :: PrimElemRep
DoubleElemRep :: PrimElemRep
data Levity
Lifted :: Levity
Unlifted :: Levity
data PrimOrVoidRep
VoidRep :: PrimOrVoidRep
NVRep :: PrimRep -> PrimOrVoidRep
primElemRepToPrimRep :: PrimElemRep -> PrimRep
isGcPtrRep :: PrimRep -> Bool

-- | The size of a <a>PrimRep</a> in bytes.
--   
--   This applies also when used in a constructor, where we allow packing
--   the fields. For instance, in <tt>data Foo = Foo Float# Float#</tt> the
--   two fields will take only 8 bytes, which for 64-bit arch will be equal
--   to 1 word. See also mkVirtHeapOffsetsWithPadding for details of how
--   data fields are laid out.
primRepSizeB :: Platform -> PrimRep -> Int

-- | Like primRepSizeB but assumes pointers/words are 8 words wide.
--   
--   This can be useful to compute the size of a rep as if we were
--   compiling for a 64bit platform.
primRepSizeW64_B :: PrimRep -> Int
primElemRepSizeB :: Platform -> PrimElemRep -> Int

-- | Like primElemRepSizeB but assumes pointers/words are 8 words wide.
--   
--   This can be useful to compute the size of a rep as if we were
--   compiling for a 64bit platform.
primElemRepSizeW64_B :: PrimElemRep -> Int

-- | Return if Rep stands for floating type, returns Nothing for vector
--   types.
primRepIsFloat :: PrimRep -> Maybe Bool
primRepsCompatible :: Platform -> [PrimRep] -> [PrimRep] -> Bool
primRepCompatible :: Platform -> PrimRep -> PrimRep -> Bool
primRepIsWord :: PrimRep -> Bool
primRepIsInt :: PrimRep -> Bool
instance GHC.Utils.Binary.Binary GHC.Core.TyCon.Injectivity
instance GHC.Utils.Binary.Binary GHC.Core.TyCon.PrimElemRep
instance GHC.Utils.Binary.Binary GHC.Core.TyCon.PrimRep
instance GHC.Utils.Binary.Binary GHC.Core.TyCon.TyConBndrVis
instance GHC.Internal.Data.Data.Data GHC.Core.TyCon.PrimElemRep
instance GHC.Internal.Data.Data.Data GHC.Core.TyCon.PrimOrVoidRep
instance GHC.Internal.Data.Data.Data GHC.Core.TyCon.PrimRep
instance GHC.Internal.Data.Data.Data GHC.Core.TyCon.TyCon
instance GHC.Internal.Enum.Enum GHC.Core.TyCon.PrimElemRep
instance GHC.Classes.Eq GHC.Core.TyCon.Injectivity
instance GHC.Classes.Eq GHC.Core.TyCon.PrimElemRep
instance GHC.Classes.Eq GHC.Core.TyCon.PrimOrVoidRep
instance GHC.Classes.Eq GHC.Core.TyCon.PrimRep
instance GHC.Classes.Eq GHC.Core.TyCon.TyCon
instance GHC.Types.Name.NamedThing GHC.Core.TyCon.TyCon
instance GHC.Classes.Ord GHC.Core.TyCon.PrimElemRep
instance GHC.Classes.Ord GHC.Core.TyCon.PrimOrVoidRep
instance GHC.Classes.Ord GHC.Core.TyCon.PrimRep
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.AlgTyConFlav
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.FamTyConFlav
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.PrimElemRep
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.PrimRep
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.TyCon
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.TyConBndrVis
instance GHC.Utils.Outputable.OutputableBndr tv => GHC.Utils.Outputable.Outputable (GHC.Types.Var.VarBndr tv GHC.Core.TyCon.TyConBndrVis)
instance GHC.Internal.Show.Show GHC.Core.TyCon.PrimElemRep
instance GHC.Internal.Show.Show GHC.Core.TyCon.PrimOrVoidRep
instance GHC.Internal.Show.Show GHC.Core.TyCon.PrimRep
instance GHC.Types.Unique.Uniquable GHC.Core.TyCon.TyCon

module GHC.Core.TyCon.Set
type TyConSet = UniqSet TyCon
emptyTyConSet :: TyConSet
unitTyConSet :: TyCon -> TyConSet
mkTyConSet :: [TyCon] -> TyConSet
unionTyConSet :: TyConSet -> TyConSet -> TyConSet
unionTyConSets :: [TyConSet] -> TyConSet
minusTyConSet :: TyConSet -> TyConSet -> TyConSet
elemTyConSet :: TyCon -> TyConSet -> Bool
extendTyConSet :: TyConSet -> TyCon -> TyConSet
extendTyConSetList :: TyConSet -> [TyCon] -> TyConSet
delFromTyConSet :: TyConSet -> TyCon -> TyConSet
delListFromTyConSet :: TyConSet -> [TyCon] -> TyConSet
isEmptyTyConSet :: TyConSet -> Bool
filterTyConSet :: (TyCon -> Bool) -> TyConSet -> TyConSet

-- | True if there is a non-empty intersection. <tt>s1
--   <a>intersectsTyConSet</a> s2</tt> doesn't compute <tt>s2</tt> if
--   <tt>s1</tt> is empty
intersectsTyConSet :: TyConSet -> TyConSet -> Bool
disjointTyConSet :: TyConSet -> TyConSet -> Bool
intersectTyConSet :: TyConSet -> TyConSet -> TyConSet
nameSetAny :: (TyCon -> Bool) -> TyConSet -> Bool
nameSetAll :: (TyCon -> Bool) -> TyConSet -> Bool

module GHC.Core.TyCon.Env

-- | TyCon Environment
type TyConEnv a = UniqFM TyCon a
mkTyConEnv :: [(TyCon, a)] -> TyConEnv a
mkTyConEnvWith :: (a -> TyCon) -> [a] -> TyConEnv a
emptyTyConEnv :: TyConEnv a
isEmptyTyConEnv :: TyConEnv a -> Bool
unitTyConEnv :: TyCon -> a -> TyConEnv a
nonDetTyConEnvElts :: TyConEnv a -> [a]
extendTyConEnv_C :: (a -> a -> a) -> TyConEnv a -> TyCon -> a -> TyConEnv a
extendTyConEnv_Acc :: (a -> b -> b) -> (a -> b) -> TyConEnv b -> TyCon -> a -> TyConEnv b
extendTyConEnv :: TyConEnv a -> TyCon -> a -> TyConEnv a
extendTyConEnvList :: TyConEnv a -> [(TyCon, a)] -> TyConEnv a
extendTyConEnvList_C :: (a -> a -> a) -> TyConEnv a -> [(TyCon, a)] -> TyConEnv a
filterTyConEnv :: (elt -> Bool) -> TyConEnv elt -> TyConEnv elt
anyTyConEnv :: (elt -> Bool) -> TyConEnv elt -> Bool
plusTyConEnv :: TyConEnv a -> TyConEnv a -> TyConEnv a
plusTyConEnv_C :: (a -> a -> a) -> TyConEnv a -> TyConEnv a -> TyConEnv a
plusTyConEnv_CD :: (a -> a -> a) -> TyConEnv a -> a -> TyConEnv a -> a -> TyConEnv a
plusTyConEnv_CD2 :: (Maybe a -> Maybe a -> a) -> TyConEnv a -> TyConEnv a -> TyConEnv a
alterTyConEnv :: (Maybe a -> Maybe a) -> TyConEnv a -> TyCon -> TyConEnv a
lookupTyConEnv :: TyConEnv a -> TyCon -> Maybe a
lookupTyConEnv_NF :: TyConEnv a -> TyCon -> a
delFromTyConEnv :: TyConEnv a -> TyCon -> TyConEnv a
delListFromTyConEnv :: TyConEnv a -> [TyCon] -> TyConEnv a
elemTyConEnv :: TyCon -> TyConEnv a -> Bool
mapTyConEnv :: (elt1 -> elt2) -> TyConEnv elt1 -> TyConEnv elt2
disjointTyConEnv :: TyConEnv a -> TyConEnv a -> Bool

-- | Deterministic TyCon Environment
--   
--   See Note [Deterministic UniqFM] in <a>GHC.Types.Unique.DFM</a> for
--   explanation why we need DTyConEnv.
type DTyConEnv a = UniqDFM TyCon a
emptyDTyConEnv :: DTyConEnv a
isEmptyDTyConEnv :: DTyConEnv a -> Bool
lookupDTyConEnv :: DTyConEnv a -> TyCon -> Maybe a
delFromDTyConEnv :: DTyConEnv a -> TyCon -> DTyConEnv a
filterDTyConEnv :: (a -> Bool) -> DTyConEnv a -> DTyConEnv a
mapDTyConEnv :: (a -> b) -> DTyConEnv a -> DTyConEnv b
mapMaybeDTyConEnv :: (a -> Maybe b) -> DTyConEnv a -> DTyConEnv b
adjustDTyConEnv :: (a -> a) -> DTyConEnv a -> TyCon -> DTyConEnv a
alterDTyConEnv :: (Maybe a -> Maybe a) -> DTyConEnv a -> TyCon -> DTyConEnv a
extendDTyConEnv :: DTyConEnv a -> TyCon -> a -> DTyConEnv a
foldDTyConEnv :: (elt -> a -> a) -> a -> DTyConEnv elt -> a

module GHC.Core.TyCon.RecWalk
data RecTcChecker

-- | Initialise a <a>RecTcChecker</a> with <a>defaultRecTcMaxBound</a>.
initRecTc :: RecTcChecker

-- | The default upper bound (100) for the number of times a
--   <a>RecTcChecker</a> is allowed to encounter each <a>TyCon</a>.
defaultRecTcMaxBound :: Int

-- | Change the upper bound for the number of times a <a>RecTcChecker</a>
--   is allowed to encounter each <a>TyCon</a>.
setRecTcMaxBound :: Int -> RecTcChecker -> RecTcChecker
checkRecTc :: RecTcChecker -> TyCon -> Maybe RecTcChecker
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.RecWalk.RecTcChecker

module GHC.Core.TyCo.Rep
data Type

-- | Vanilla type or kind variable (*never* a coercion variable)
TyVarTy :: Var -> Type

-- | Type application to something other than a <a>TyCon</a>. Parameters:
--   
--   1) Function: must <i>not</i> be a <a>TyConApp</a> or <a>CastTy</a>,
--   must be another <a>AppTy</a>, or <a>TyVarTy</a> See Note [Respecting
--   definitional equality] (EQ1) about the no <a>CastTy</a> requirement
--   
--   2) Argument type
AppTy :: Type -> Type -> Type

-- | Application of a <a>TyCon</a>, including newtypes <i>and</i> synonyms.
--   Invariant: saturated applications of <tt>FunTyCon</tt> must use
--   <a>FunTy</a> and saturated synonyms must use their own constructors.
--   However, <i>unsaturated</i> <tt>FunTyCon</tt>s do appear as
--   <a>TyConApp</a>s. Parameters:
--   
--   1) Type constructor being applied to.
--   
--   2) Type arguments. Might not have enough type arguments here to
--   saturate the constructor. Even type synonyms are not necessarily
--   saturated; for example unsaturated type synonyms can appear as the
--   right hand side of a type synonym.
TyConApp :: TyCon -> [KindOrType] -> Type

-- | A Π type. See Note [Why ForAllTy can quantify over a coercion
--   variable] INVARIANT: If the binder is a coercion variable, it must be
--   mentioned in the Type. See Note [Unused coercion variable in ForAllTy]
ForAllTy :: {-# UNPACK #-} !ForAllTyBinder -> Type -> Type

-- | FUN m t1 t2 Very common, so an important special case See Note
--   [Function types]
FunTy :: FunTyFlag -> Mult -> Type -> Type -> Type
[ft_af] :: Type -> FunTyFlag
[ft_mult] :: Type -> Mult
[ft_arg] :: Type -> Type
[ft_res] :: Type -> Type

-- | Type literals are similar to type constructors.
LitTy :: TyLit -> Type

-- | A kind cast. The coercion is always nominal. INVARIANT: The cast is
--   never reflexive (EQ2) INVARIANT: The Type is not a CastTy (use TransCo
--   instead) (EQ3) INVARIANT: The Type is not a ForAllTy over a tyvar
--   (EQ4) See Note [Respecting definitional equality]
CastTy :: Type -> KindCoercion -> Type

-- | Injection of a Coercion into a type This should only ever be used in
--   the RHS of an AppTy, in the list of a TyConApp, when applying a
--   promoted GADT data constructor
CoercionTy :: Coercion -> Type
data TyLit
NumTyLit :: Integer -> TyLit
StrTyLit :: FastString -> TyLit
CharTyLit :: Char -> TyLit

-- | The key representation of types within the compiler
type KindOrType = Type

-- | The key type representing kinds in the compiler.
type Kind = Type

-- | Type synonym used for types of kind RuntimeRep.
type RuntimeRepType = Type

-- | Type synonym used for types of kind Levity.
type LevityType = Type

-- | A type labeled <a>KnotTied</a> might have knot-tied tycons in it. See
--   Note [Type checking recursive type and class declarations] in
--   <a>GHC.Tc.TyCl</a>
type KnotTied (ty :: k) = ty

-- | A type of the form <tt>p</tt> of constraint kind represents a value
--   whose type is the Haskell predicate <tt>p</tt>, where a predicate is
--   what occurs before the <tt>=&gt;</tt> in a Haskell type.
--   
--   We use <a>PredType</a> as documentation to mark those types that we
--   guarantee to have this kind.
--   
--   It can be expanded into its representation, but:
--   
--   <ul>
--   <li>The type checker must treat it as opaque</li>
--   <li>The rest of the compiler treats it as transparent</li>
--   </ul>
--   
--   Consider these examples:
--   
--   <pre>
--   f :: (Eq a) =&gt; a -&gt; Int
--   g :: (?x :: Int -&gt; Int) =&gt; a -&gt; Int
--   h :: (r\l) =&gt; {r} =&gt; {l::Int | r}
--   </pre>
--   
--   Here the <tt>Eq a</tt> and <tt>?x :: Int -&gt; Int</tt> and
--   <tt>rl</tt> are all called "predicates"
type PredType = Type

-- | A collection of <a>PredType</a>s
type ThetaType = [PredType]
type FRRType = Type

-- | ForAllTyFlag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, ForAllTyBinders, TyConBinders,
--   and visibility] in <a>GHC.Core.TyCo.Rep</a>
data ForAllTyFlag
Invisible :: !Specificity -> ForAllTyFlag
Required :: ForAllTyFlag
pattern Inferred :: ForAllTyFlag
pattern Specified :: ForAllTyFlag

-- | The non-dependent version of <a>ForAllTyFlag</a>. See Note [FunTyFlag]
--   Appears here partly so that it's together with its friends
--   ForAllTyFlag and ForallVisFlag, but also because it is used in
--   IfaceType, rather early in the compilation chain
data FunTyFlag
FTF_T_T :: FunTyFlag
FTF_T_C :: FunTyFlag
FTF_C_T :: FunTyFlag
FTF_C_C :: FunTyFlag

-- | A <a>Coercion</a> is concrete evidence of the equality/convertibility
--   of two types.
data Coercion
Refl :: Type -> Coercion
GRefl :: Role -> Type -> MCoercionN -> Coercion
TyConAppCo :: Role -> TyCon -> [Coercion] -> Coercion
AppCo :: Coercion -> CoercionN -> Coercion
ForAllCo :: TyCoVar -> !ForAllTyFlag -> !ForAllTyFlag -> KindCoercion -> Coercion -> Coercion
[fco_tcv] :: Coercion -> TyCoVar
[fco_visL] :: Coercion -> !ForAllTyFlag
[fco_visR] :: Coercion -> !ForAllTyFlag
[fco_kind] :: Coercion -> KindCoercion
[fco_body] :: Coercion -> Coercion
FunCo :: Role -> FunTyFlag -> FunTyFlag -> CoercionN -> Coercion -> Coercion -> Coercion
[fco_role] :: Coercion -> Role
[fco_afl] :: Coercion -> FunTyFlag
[fco_afr] :: Coercion -> FunTyFlag
[fco_mult] :: Coercion -> CoercionN
[fco_arg] :: Coercion -> Coercion
[fco_res] :: Coercion -> Coercion
CoVarCo :: CoVar -> Coercion
AxiomCo :: CoAxiomRule -> [Coercion] -> Coercion
UnivCo :: UnivCoProvenance -> Role -> Type -> Type -> [Coercion] -> Coercion
[uco_prov] :: Coercion -> UnivCoProvenance
[uco_role] :: Coercion -> Role
[uco_lty] :: Coercion -> Type
[uco_rty] :: Coercion -> Type
[uco_deps] :: Coercion -> [Coercion]
SymCo :: Coercion -> Coercion
TransCo :: Coercion -> Coercion -> Coercion
SelCo :: CoSel -> Coercion -> Coercion
LRCo :: LeftOrRight -> CoercionN -> Coercion
InstCo :: Coercion -> CoercionN -> Coercion
KindCo :: Coercion -> Coercion
SubCo :: CoercionN -> Coercion

-- | See Note [Coercion holes] Only present during typechecking
HoleCo :: CoercionHole -> Coercion
data CoSel
SelTyCon :: Int -> Role -> CoSel
SelFun :: FunSel -> CoSel
SelForAll :: CoSel
data FunSel
SelMult :: FunSel
SelArg :: FunSel
SelRes :: FunSel

-- | For simplicity, we have just one UnivCo that represents a coercion
--   from some type to some other type, with (in general) no restrictions
--   on the type. The UnivCoProvenance specifies more exactly what the
--   coercion really is and why a program should (or shouldn't!) trust the
--   coercion. It is reasonable to consider each constructor of
--   <a>UnivCoProvenance</a> as a totally independent coercion form; their
--   only commonality is that they don't tell you what types they coercion
--   between. (That info is in the <a>UnivCo</a> constructor of
--   <a>Coercion</a>.
data UnivCoProvenance

-- | See Note [Phantom coercions]. Only in Phantom roled coercions
PhantomProv :: UnivCoProvenance

-- | From the fact that any two coercions are considered equivalent. See
--   Note [ProofIrrelProv]. Can be used in Nominal or Representational
--   coercions
ProofIrrelProv :: UnivCoProvenance

-- | From a plugin, which asserts that this coercion is sound. The string
--   and the variable set are for the use by the plugin.
PluginProv :: String -> UnivCoProvenance

-- | A coercion to be filled in by the type-checker. See Note [Coercion
--   holes]
data CoercionHole
CoercionHole :: CoVar -> IORef (Maybe Coercion) -> Bool -> CoercionHole
[ch_co_var] :: CoercionHole -> CoVar
[ch_ref] :: CoercionHole -> IORef (Maybe Coercion)
[ch_hetero_kind] :: CoercionHole -> Bool
coHoleCoVar :: CoercionHole -> CoVar
setCoHoleCoVar :: CoercionHole -> CoVar -> CoercionHole
isHeteroKindCoHole :: CoercionHole -> Bool
type CoercionN = Coercion
type CoercionR = Coercion
type CoercionP = Coercion
type KindCoercion = CoercionN

-- | A semantically more meaningful type to represent what may or may not
--   be a useful <a>Coercion</a>.
data MCoercion
MRefl :: MCoercion
MCo :: Coercion -> MCoercion
type MCoercionR = MCoercion
type MCoercionN = MCoercion

-- | <a>mkNakedTyConTy</a> creates a nullary <a>TyConApp</a>. In general
--   you should rather use <a>mkTyConTy</a>, which picks the shared nullary
--   TyConApp from inside the TyCon (via tyConNullaryTy. But we have to
--   build the TyConApp tc [] in that TyCon field; that's what
--   <a>mkNakedTyConTy</a> is for.
mkNakedTyConTy :: TyCon -> Type
mkTyVarTy :: TyVar -> Type
mkTyVarTys :: [TyVar] -> [Type]
mkTyCoVarTy :: TyCoVar -> Type
mkTyCoVarTys :: [TyCoVar] -> [Type]
mkFunTy :: HasDebugCallStack => FunTyFlag -> Mult -> Type -> Type -> Type
infixr 3 `mkFunTy`
mkNakedFunTy :: FunTyFlag -> Kind -> Kind -> Kind
mkVisFunTy :: HasDebugCallStack => Mult -> Type -> Type -> Type
mkScaledFunTys :: HasDebugCallStack => [Scaled Type] -> Type -> Type
mkInvisFunTy :: HasDebugCallStack => Type -> Type -> Type
infixr 3 `mkInvisFunTy`
mkInvisFunTys :: HasDebugCallStack => [Type] -> Type -> Type
tcMkVisFunTy :: Mult -> Type -> Type -> Type
tcMkInvisFunTy :: TypeOrConstraint -> Type -> Type -> Type
tcMkScaledFunTy :: Scaled Type -> Type -> Type
tcMkScaledFunTys :: [Scaled Type] -> Type -> Type

-- | Like <tt>mkTyCoForAllTy</tt>, but does not check the occurrence of the
--   binder See Note [Unused coercion variable in ForAllTy]
mkForAllTy :: ForAllTyBinder -> Type -> Type

-- | Wraps foralls over the type using the provided <a>TyCoVar</a>s from
--   left to right
mkForAllTys :: [ForAllTyBinder] -> Type -> Type

-- | Wraps foralls over the type using the provided <a>InvisTVBinder</a>s
--   from left to right
mkInvisForAllTys :: [InvisTVBinder] -> Type -> Type
mkPiTy :: HasDebugCallStack => PiTyBinder -> Type -> Type
mkPiTys :: HasDebugCallStack => [PiTyBinder] -> Type -> Type

-- | Make nested arrow types | Special, common, case: Arrow type with mult
--   Many
mkVisFunTyMany :: HasDebugCallStack => Type -> Type -> Type
infixr 3 `mkVisFunTyMany`
mkVisFunTysMany :: [Type] -> Type -> Type
nonDetCmpTyLit :: TyLit -> TyLit -> Ordering
cmpTyLit :: TyLit -> TyLit -> Ordering
pickLR :: LeftOrRight -> (a, a) -> a
data TyCoFolder env a
TyCoFolder :: (Type -> Maybe Type) -> (env -> TyVar -> a) -> (env -> CoVar -> a) -> (env -> CoercionHole -> a) -> (env -> TyCoVar -> ForAllTyFlag -> env) -> TyCoFolder env a
[tcf_view] :: TyCoFolder env a -> Type -> Maybe Type
[tcf_tyvar] :: TyCoFolder env a -> env -> TyVar -> a
[tcf_covar] :: TyCoFolder env a -> env -> CoVar -> a

-- | What to do with coercion holes. See Note [Coercion holes] in
--   <a>GHC.Core.TyCo.Rep</a>.
[tcf_hole] :: TyCoFolder env a -> env -> CoercionHole -> a

-- | The returned env is used in the extended scope
[tcf_tycobinder] :: TyCoFolder env a -> env -> TyCoVar -> ForAllTyFlag -> env
foldTyCo :: Monoid a => TyCoFolder env a -> env -> (Type -> a, [Type] -> a, Coercion -> a, [Coercion] -> a)

-- | A view function that looks through nothing.
noView :: Type -> Maybe Type
typeSize :: Type -> Int
typesSize :: [Type] -> Int
coercionSize :: Coercion -> Int

-- | A shorthand for data with an attached <a>Mult</a> element (the
--   multiplicity).
data Scaled a
Scaled :: !Mult -> a -> Scaled a
scaledMult :: Scaled a -> Mult
scaledThing :: Scaled a -> a

-- | Apply a function to both the Mult and the Type in a 'Scaled Type'
mapScaledType :: (Type -> Type) -> Scaled Type -> Scaled Type

-- | Mult is a type alias for Type.
--   
--   Mult must contain Type because multiplicity variables are mere type
--   variables (of kind Multiplicity) in Haskell. So the simplest
--   implementation is to make Mult be Type.
--   
--   Multiplicities can be formed with: - One: GHC.Types.One (= oneDataCon)
--   - Many: GHC.Types.Many (= manyDataCon) - Multiplication:
--   GHC.Types.MultMul (= multMulTyCon)
--   
--   So that Mult feels a bit more structured, we provide pattern synonyms
--   and smart constructors for these.
type Mult = Type
instance GHC.Utils.Binary.Binary GHC.Core.TyCo.Rep.CoSel
instance GHC.Utils.Binary.Binary GHC.Core.TyCo.Rep.UnivCoProvenance
instance GHC.Internal.Data.Data.Data GHC.Core.TyCo.Rep.CoSel
instance GHC.Internal.Data.Data.Data GHC.Core.TyCo.Rep.Coercion
instance GHC.Internal.Data.Data.Data GHC.Core.TyCo.Rep.CoercionHole
instance GHC.Internal.Data.Data.Data GHC.Core.TyCo.Rep.FunSel
instance GHC.Internal.Data.Data.Data GHC.Core.TyCo.Rep.MCoercion
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Core.TyCo.Rep.Scaled a)
instance GHC.Internal.Data.Data.Data GHC.Core.TyCo.Rep.TyLit
instance GHC.Internal.Data.Data.Data GHC.Core.TyCo.Rep.Type
instance GHC.Internal.Data.Data.Data GHC.Core.TyCo.Rep.UnivCoProvenance
instance GHC.Classes.Eq GHC.Core.TyCo.Rep.CoSel
instance GHC.Classes.Eq GHC.Core.TyCo.Rep.FunSel
instance GHC.Classes.Eq GHC.Core.TyCo.Rep.TyLit
instance GHC.Classes.Eq GHC.Core.TyCo.Rep.UnivCoProvenance
instance Control.DeepSeq.NFData GHC.Core.TyCo.Rep.CoSel
instance Control.DeepSeq.NFData GHC.Core.TyCo.Rep.UnivCoProvenance
instance GHC.Classes.Ord GHC.Core.TyCo.Rep.CoSel
instance GHC.Classes.Ord GHC.Core.TyCo.Rep.FunSel
instance GHC.Classes.Ord GHC.Core.TyCo.Rep.UnivCoProvenance
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.CoSel
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.Coercion
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.CoercionHole
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.FunSel
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.MCoercion
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Core.TyCo.Rep.Scaled a)
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.TyLit
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.Type
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.UnivCoProvenance
instance GHC.Types.Unique.Uniquable GHC.Core.TyCo.Rep.CoercionHole


-- | The <a>ZonkEnv</a> zonking environment, and the <a>ZonkT</a> and
--   <a>ZonkBndrT</a> monad transformers, for the final zonking to type in
--   <a>GHC.Tc.Zonk.Type</a>.
--   
--   See Note [Module structure for zonking] in GHC.Tc.Zonk.Type.
module GHC.Tc.Zonk.Env

-- | See Note [The ZonkEnv]
data ZonkEnv
ZonkEnv :: !ZonkFlexi -> TyCoVarEnv TyCoVar -> IdEnv Id -> IORef (TyVarEnv Type) -> ZonkEnv
[ze_flexi] :: ZonkEnv -> !ZonkFlexi
[ze_tv_env] :: ZonkEnv -> TyCoVarEnv TyCoVar
[ze_id_env] :: ZonkEnv -> IdEnv Id
[ze_meta_tv_env] :: ZonkEnv -> IORef (TyVarEnv Type)
getZonkEnv :: forall (m :: Type -> Type). Monad m => ZonkT m ZonkEnv

-- | How should we handle unfilled unification variables in the zonker?
--   
--   See Note [Un-unified unification variables]
data ZonkFlexi

-- | Default unbound unification variables to Any
DefaultFlexi :: ZonkFlexi

-- | Skolemise unbound unification variables See Note [Zonking the LHS of a
--   RULE]
SkolemiseFlexi :: ZonkFlexi

-- | Used in the GHCi debugger
RuntimeUnkFlexi :: ZonkFlexi

-- | Panic on unfilled meta-variables See Note [Error on unconstrained
--   meta-variables] in GHC.Tc.Utils.TcMType
NoFlexi :: ZonkFlexi
initZonkEnv :: MonadIO m => ZonkFlexi -> ZonkT m b -> m b

-- | A reader monad over <a>ZonkEnv</a>, for zonking computations which
--   don't modify the <a>ZonkEnv</a> (e.g. don't bind any variables).
--   
--   Use <a>ZonkBndrT</a> when you need to modify the <a>ZonkEnv</a> (e.g.
--   to bind a variable).
data ZonkT (m :: Type -> Type) a
pattern ZonkT :: (ZonkEnv -> m a) -> ZonkT m a

-- | Zonk binders, bringing them into scope in the inner computation.
--   
--   Can be thought of as a state monad transformer <tt>StateT ZonkEnv m
--   a</tt>, but written in continuation-passing style.
--   
--   See Note [Continuation-passing style for zonking].
newtype ZonkBndrT (m :: Type -> Type) a
ZonkBndrT :: (forall r. () => (a -> ZonkT m r) -> ZonkT m r) -> ZonkBndrT (m :: Type -> Type) a
[runZonkBndrT'] :: ZonkBndrT (m :: Type -> Type) a -> forall r. () => (a -> ZonkT m r) -> ZonkT m r

-- | Zonk some binders and run the continuation.
--   
--   Example:
--   
--   <pre>
--   zonk (ForAllTy (Bndr tv vis) body_ty)
--    = runZonkBndrT (zonkTyBndrX tv) $ \ tv' -&gt;
--      do { body_ty' &lt;- zonkTcTypeToTypeX body_ty
--         ; return (ForAllTy (Bndr tv' vis) body_ty') }
--   </pre>
--   
--   See Note [Continuation-passing style for zonking].
runZonkBndrT :: forall (m :: Type -> Type) a. ZonkBndrT m a -> forall r. () => (a -> ZonkT m r) -> ZonkT m r

-- | Embed a computation that doesn't modify the <a>ZonkEnv</a> into
--   <a>ZonkBndrT</a>.
noBinders :: forall (m :: Type -> Type) a. Monad m => ZonkT m a -> ZonkBndrT m a

-- | Run a nested computation that modifies the <a>ZonkEnv</a>, without
--   affecting the outer environment.
don'tBind :: forall (m :: Type -> Type) a. Monad m => ZonkBndrT m a -> ZonkT m a
setZonkType :: forall (m :: Type -> Type) a. ZonkFlexi -> ZonkT m a -> ZonkT m a
extendZonkEnv :: forall (m :: Type -> Type). [Var] -> ZonkBndrT m ()
extendIdZonkEnv :: forall (m :: Type -> Type). Var -> ZonkBndrT m ()

-- | Extend the knot-tied environment.
extendIdZonkEnvRec :: forall (m :: Type -> Type). [Var] -> ZonkBndrT m ()
extendTyZonkEnv :: forall (m :: Type -> Type). TyVar -> ZonkBndrT m ()
instance GHC.Internal.Base.Applicative (GHC.Tc.Zonk.Env.ZonkBndrT m)
instance GHC.Internal.Base.Applicative m => GHC.Internal.Base.Applicative (GHC.Tc.Zonk.Env.ZonkT m)
instance GHC.Internal.Base.Functor (GHC.Tc.Zonk.Env.ZonkBndrT m)
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (GHC.Tc.Zonk.Env.ZonkT m)
instance GHC.Internal.Control.Monad.IO.Class.MonadIO m => GHC.Internal.Control.Monad.Fix.MonadFix (GHC.Tc.Zonk.Env.ZonkBndrT m)
instance GHC.Internal.Control.Monad.Fix.MonadFix m => GHC.Internal.Control.Monad.Fix.MonadFix (GHC.Tc.Zonk.Env.ZonkT m)
instance GHC.Internal.Control.Monad.IO.Class.MonadIO m => GHC.Internal.Control.Monad.IO.Class.MonadIO (GHC.Tc.Zonk.Env.ZonkBndrT m)
instance GHC.Internal.Control.Monad.IO.Class.MonadIO m => GHC.Internal.Control.Monad.IO.Class.MonadIO (GHC.Tc.Zonk.Env.ZonkT m)
instance Control.Monad.Trans.Class.MonadTrans GHC.Tc.Zonk.Env.ZonkT
instance GHC.Internal.Base.Monad (GHC.Tc.Zonk.Env.ZonkBndrT m)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (GHC.Tc.Zonk.Env.ZonkT m)
instance GHC.Utils.Outputable.Outputable GHC.Tc.Zonk.Env.ZonkEnv

module GHC.Builtin.Names.TH
templateHaskellNames :: [Name]
thSyn :: Module
thLib :: Module
qqLib :: Module
liftLib :: Module
mkTHModule :: FastString -> Module
libFun :: FastString -> Unique -> Name
libTc :: FastString -> Unique -> Name
thFun :: FastString -> Unique -> Name
thTc :: FastString -> Unique -> Name
thCls :: FastString -> Unique -> Name
thCon :: FastString -> Unique -> Name
liftFun :: FastString -> Unique -> Name
thFld :: FastString -> FastString -> Unique -> Name
qqFld :: FastString -> Unique -> Name
liftClassName :: Name
quoteClassName :: Name
qTyConName :: Name
nameTyConName :: Name
fieldExpTyConName :: Name
patTyConName :: Name
fieldPatTyConName :: Name
expTyConName :: Name
decTyConName :: Name
decsTyConName :: Name
typeTyConName :: Name
matchTyConName :: Name
clauseTyConName :: Name
funDepTyConName :: Name
predTyConName :: Name
codeTyConName :: Name
injAnnTyConName :: Name
overlapTyConName :: Name
modNameTyConName :: Name
returnQName :: Name
bindQName :: Name
sequenceQName :: Name
newNameName :: Name
mkNameName :: Name
mkNameG_vName :: Name
mkNameG_dName :: Name
mkNameG_tcName :: Name
mkNameG_fldName :: Name
mkNameLName :: Name
mkNameQName :: Name
mkNameSName :: Name
mkModNameName :: Name
unTypeName :: Name
unTypeCodeName :: Name
unsafeCodeCoerceName :: Name
liftName :: Name
liftStringName :: Name
liftTypedName :: Name
charLName :: Name
stringLName :: Name
integerLName :: Name
intPrimLName :: Name
wordPrimLName :: Name
floatPrimLName :: Name
doublePrimLName :: Name
rationalLName :: Name
stringPrimLName :: Name
charPrimLName :: Name
litPName :: Name
varPName :: Name
tupPName :: Name
unboxedTupPName :: Name
unboxedSumPName :: Name
conPName :: Name
infixPName :: Name
tildePName :: Name
bangPName :: Name
asPName :: Name
wildPName :: Name
recPName :: Name
listPName :: Name
sigPName :: Name
viewPName :: Name
orPName :: Name
typePName :: Name
invisPName :: Name
fieldPatName :: Name
matchName :: Name
clauseName :: Name
varEName :: Name
conEName :: Name
litEName :: Name
appEName :: Name
appTypeEName :: Name
infixEName :: Name
infixAppName :: Name
sectionLName :: Name
sectionRName :: Name
lamEName :: Name
lamCaseEName :: Name
lamCasesEName :: Name
tupEName :: Name
unboxedTupEName :: Name
unboxedSumEName :: Name
condEName :: Name
multiIfEName :: Name
letEName :: Name
caseEName :: Name
doEName :: Name
mdoEName :: Name
compEName :: Name
fromEName :: Name
fromThenEName :: Name
fromToEName :: Name
fromThenToEName :: Name
listEName :: Name
sigEName :: Name
recConEName :: Name
recUpdEName :: Name
staticEName :: Name
unboundVarEName :: Name
labelEName :: Name
implicitParamVarEName :: Name
getFieldEName :: Name
projectionEName :: Name
typeEName :: Name
forallEName :: Name
forallVisEName :: Name
constrainedEName :: Name
fieldExpName :: Name
guardedBName :: Name
normalBName :: Name
normalGEName :: Name
patGEName :: Name
bindSName :: Name
letSName :: Name
noBindSName :: Name
parSName :: Name
recSName :: Name
funDName :: Name
valDName :: Name
dataDName :: Name
newtypeDName :: Name
typeDataDName :: Name
tySynDName :: Name
classDName :: Name
instanceWithOverlapDName :: Name
standaloneDerivWithStrategyDName :: Name
sigDName :: Name
kiSigDName :: Name
defaultDName :: Name
defaultSigDName :: Name
forImpDName :: Name
pragInlDName :: Name
pragOpaqueDName :: Name
pragSpecDName :: Name
pragSpecInlDName :: Name
pragSpecInstDName :: Name
pragRuleDName :: Name
pragCompleteDName :: Name
pragAnnDName :: Name
pragSCCFunDName :: Name
pragSCCFunNamedDName :: Name
dataInstDName :: Name
newtypeInstDName :: Name
tySynInstDName :: Name
openTypeFamilyDName :: Name
closedTypeFamilyDName :: Name
dataFamilyDName :: Name
infixLWithSpecDName :: Name
infixRWithSpecDName :: Name
infixNWithSpecDName :: Name
roleAnnotDName :: Name
patSynDName :: Name
patSynSigDName :: Name
implicitParamBindDName :: Name
cxtName :: Name
noSourceUnpackednessName :: Name
sourceNoUnpackName :: Name
sourceUnpackName :: Name
noSourceStrictnessName :: Name
sourceLazyName :: Name
sourceStrictName :: Name
normalCName :: Name
recCName :: Name
infixCName :: Name
forallCName :: Name
gadtCName :: Name
recGadtCName :: Name
bangName :: Name
bangTypeName :: Name
varBangTypeName :: Name
unidirPatSynName :: Name
implBidirPatSynName :: Name
explBidirPatSynName :: Name
prefixPatSynName :: Name
infixPatSynName :: Name
recordPatSynName :: Name
forallTName :: Name
forallVisTName :: Name
varTName :: Name
conTName :: Name
tupleTName :: Name
unboxedTupleTName :: Name
unboxedSumTName :: Name
arrowTName :: Name
mulArrowTName :: Name
listTName :: Name
appTName :: Name
appKindTName :: Name
sigTName :: Name
equalityTName :: Name
litTName :: Name
promotedTName :: Name
promotedTupleTName :: Name
promotedNilTName :: Name
promotedConsTName :: Name
wildCardTName :: Name
infixTName :: Name
implicitParamTName :: Name
numTyLitName :: Name
strTyLitName :: Name
charTyLitName :: Name
plainTVName :: Name
kindedTVName :: Name
plainInvisTVName :: Name
kindedInvisTVName :: Name
plainBndrTVName :: Name
kindedBndrTVName :: Name
specifiedSpecName :: Name
inferredSpecName :: Name
bndrReqName :: Name
bndrInvisName :: Name
nominalRName :: Name
representationalRName :: Name
phantomRName :: Name
inferRName :: Name
starKName :: Name
constraintKName :: Name
noSigName :: Name
kindSigName :: Name
tyVarSigName :: Name
injectivityAnnName :: Name
cCallName :: Name
stdCallName :: Name
cApiCallName :: Name
primCallName :: Name
javaScriptCallName :: Name
unsafeName :: Name
safeName :: Name
interruptibleName :: Name
ruleVarName :: Name
typedRuleVarName :: Name
funDepName :: Name
tySynEqnName :: Name
valueAnnotationName :: Name
typeAnnotationName :: Name
moduleAnnotationName :: Name
derivClauseName :: Name
stockStrategyName :: Name
anyclassStrategyName :: Name
newtypeStrategyName :: Name
viaStrategyName :: Name
expQTyConName :: Name
decsQTyConName :: Name
typeQTyConName :: Name
patQTyConName :: Name
stmtTyConName :: Name
conTyConName :: Name
bangTypeTyConName :: Name
varBangTypeTyConName :: Name
ruleBndrTyConName :: Name
tySynEqnTyConName :: Name
roleTyConName :: Name
derivClauseTyConName :: Name
kindTyConName :: Name
tyVarBndrUnitTyConName :: Name
tyVarBndrSpecTyConName :: Name
tyVarBndrVisTyConName :: Name
derivStrategyTyConName :: Name
quoteExpName :: Name
quotePatName :: Name
quoteDecName :: Name
quoteTypeName :: Name
noInlineDataConName :: Name
inlineDataConName :: Name
inlinableDataConName :: Name
conLikeDataConName :: Name
funLikeDataConName :: Name
allPhasesDataConName :: Name
fromPhaseDataConName :: Name
beforePhaseDataConName :: Name
overlappableDataConName :: Name
overlappingDataConName :: Name
overlapsDataConName :: Name
incoherentDataConName :: Name
noNamespaceSpecifierDataConName :: Name
typeNamespaceSpecifierDataConName :: Name
dataNamespaceSpecifierDataConName :: Name
liftClassKey :: Unique
quoteClassKey :: Unique
expTyConKey :: Unique
matchTyConKey :: Unique
clauseTyConKey :: Unique
qTyConKey :: Unique
expQTyConKey :: Unique
patTyConKey :: Unique
stmtTyConKey :: Unique
conTyConKey :: Unique
typeQTyConKey :: Unique
typeTyConKey :: Unique
decTyConKey :: Unique
bangTypeTyConKey :: Unique
varBangTypeTyConKey :: Unique
fieldExpTyConKey :: Unique
fieldPatTyConKey :: Unique
nameTyConKey :: Unique
patQTyConKey :: Unique
funDepTyConKey :: Unique
predTyConKey :: Unique
predQTyConKey :: Unique
tyVarBndrUnitTyConKey :: Unique
decsQTyConKey :: Unique
ruleBndrTyConKey :: Unique
tySynEqnTyConKey :: Unique
roleTyConKey :: Unique
injAnnTyConKey :: Unique
kindTyConKey :: Unique
overlapTyConKey :: Unique
derivClauseTyConKey :: Unique
derivStrategyTyConKey :: Unique
decsTyConKey :: Unique
tyVarBndrSpecTyConKey :: Unique
codeTyConKey :: Unique
modNameTyConKey :: Unique
tyVarBndrVisTyConKey :: Unique
noInlineDataConKey :: Unique
inlineDataConKey :: Unique
inlinableDataConKey :: Unique
conLikeDataConKey :: Unique
funLikeDataConKey :: Unique
allPhasesDataConKey :: Unique
fromPhaseDataConKey :: Unique
beforePhaseDataConKey :: Unique
overlappableDataConKey :: Unique
overlappingDataConKey :: Unique
overlapsDataConKey :: Unique
incoherentDataConKey :: Unique
noNamespaceSpecifierDataConKey :: Unique
typeNamespaceSpecifierDataConKey :: Unique
dataNamespaceSpecifierDataConKey :: Unique
returnQIdKey :: Unique
bindQIdKey :: Unique
sequenceQIdKey :: Unique
liftIdKey :: Unique
newNameIdKey :: Unique
mkNameIdKey :: Unique
mkNameG_vIdKey :: Unique
mkNameG_dIdKey :: Unique
mkNameG_tcIdKey :: Unique
mkNameLIdKey :: Unique
mkNameSIdKey :: Unique
unTypeIdKey :: Unique
unTypeCodeIdKey :: Unique
liftTypedIdKey :: Unique
mkModNameIdKey :: Unique
unsafeCodeCoerceIdKey :: Unique
mkNameQIdKey :: Unique
mkNameG_fldIdKey :: Unique
charLIdKey :: Unique
stringLIdKey :: Unique
integerLIdKey :: Unique
intPrimLIdKey :: Unique
wordPrimLIdKey :: Unique
floatPrimLIdKey :: Unique
doublePrimLIdKey :: Unique
rationalLIdKey :: Unique
stringPrimLIdKey :: Unique
charPrimLIdKey :: Unique
liftStringIdKey :: Unique
litPIdKey :: Unique
varPIdKey :: Unique
tupPIdKey :: Unique
unboxedTupPIdKey :: Unique
unboxedSumPIdKey :: Unique
conPIdKey :: Unique
infixPIdKey :: Unique
tildePIdKey :: Unique
bangPIdKey :: Unique
asPIdKey :: Unique
wildPIdKey :: Unique
recPIdKey :: Unique
listPIdKey :: Unique
sigPIdKey :: Unique
viewPIdKey :: Unique
typePIdKey :: Unique
invisPIdKey :: Unique
orPIdKey :: Unique
fieldPatIdKey :: Unique
matchIdKey :: Unique
clauseIdKey :: Unique
varEIdKey :: Unique
conEIdKey :: Unique
litEIdKey :: Unique
appEIdKey :: Unique
appTypeEIdKey :: Unique
infixEIdKey :: Unique
infixAppIdKey :: Unique
sectionLIdKey :: Unique
sectionRIdKey :: Unique
lamEIdKey :: Unique
lamCaseEIdKey :: Unique
lamCasesEIdKey :: Unique
tupEIdKey :: Unique
unboxedTupEIdKey :: Unique
unboxedSumEIdKey :: Unique
condEIdKey :: Unique
multiIfEIdKey :: Unique
letEIdKey :: Unique
caseEIdKey :: Unique
doEIdKey :: Unique
compEIdKey :: Unique
fromEIdKey :: Unique
fromThenEIdKey :: Unique
fromToEIdKey :: Unique
fromThenToEIdKey :: Unique
listEIdKey :: Unique
sigEIdKey :: Unique
recConEIdKey :: Unique
recUpdEIdKey :: Unique
staticEIdKey :: Unique
unboundVarEIdKey :: Unique
labelEIdKey :: Unique
implicitParamVarEIdKey :: Unique
mdoEIdKey :: Unique
getFieldEIdKey :: Unique
projectionEIdKey :: Unique
typeEIdKey :: Unique
forallEIdKey :: Unique
forallVisEIdKey :: Unique
constrainedEIdKey :: Unique
fieldExpIdKey :: Unique
guardedBIdKey :: Unique
normalBIdKey :: Unique
normalGEIdKey :: Unique
patGEIdKey :: Unique
bindSIdKey :: Unique
letSIdKey :: Unique
noBindSIdKey :: Unique
parSIdKey :: Unique
recSIdKey :: Unique
funDIdKey :: Unique
valDIdKey :: Unique
dataDIdKey :: Unique
newtypeDIdKey :: Unique
tySynDIdKey :: Unique
classDIdKey :: Unique
instanceWithOverlapDIdKey :: Unique
instanceDIdKey :: Unique
sigDIdKey :: Unique
forImpDIdKey :: Unique
pragInlDIdKey :: Unique
pragSpecDIdKey :: Unique
pragSpecInlDIdKey :: Unique
pragSpecInstDIdKey :: Unique
pragRuleDIdKey :: Unique
pragAnnDIdKey :: Unique
dataFamilyDIdKey :: Unique
openTypeFamilyDIdKey :: Unique
dataInstDIdKey :: Unique
newtypeInstDIdKey :: Unique
tySynInstDIdKey :: Unique
closedTypeFamilyDIdKey :: Unique
infixLWithSpecDIdKey :: Unique
infixRWithSpecDIdKey :: Unique
infixNWithSpecDIdKey :: Unique
roleAnnotDIdKey :: Unique
standaloneDerivWithStrategyDIdKey :: Unique
defaultSigDIdKey :: Unique
patSynDIdKey :: Unique
patSynSigDIdKey :: Unique
pragCompleteDIdKey :: Unique
implicitParamBindDIdKey :: Unique
kiSigDIdKey :: Unique
defaultDIdKey :: Unique
pragOpaqueDIdKey :: Unique
typeDataDIdKey :: Unique
pragSCCFunDKey :: Unique
pragSCCFunNamedDKey :: Unique
cxtIdKey :: Unique
noSourceUnpackednessKey :: Unique
sourceNoUnpackKey :: Unique
sourceUnpackKey :: Unique
noSourceStrictnessKey :: Unique
sourceLazyKey :: Unique
sourceStrictKey :: Unique
normalCIdKey :: Unique
recCIdKey :: Unique
infixCIdKey :: Unique
forallCIdKey :: Unique
gadtCIdKey :: Unique
recGadtCIdKey :: Unique
bangIdKey :: Unique
bangTKey :: Unique
varBangTKey :: Unique
unidirPatSynIdKey :: Unique
implBidirPatSynIdKey :: Unique
explBidirPatSynIdKey :: Unique
prefixPatSynIdKey :: Unique
infixPatSynIdKey :: Unique
recordPatSynIdKey :: Unique
forallTIdKey :: Unique
forallVisTIdKey :: Unique
varTIdKey :: Unique
conTIdKey :: Unique
tupleTIdKey :: Unique
unboxedTupleTIdKey :: Unique
unboxedSumTIdKey :: Unique
arrowTIdKey :: Unique
listTIdKey :: Unique
appTIdKey :: Unique
appKindTIdKey :: Unique
sigTIdKey :: Unique
equalityTIdKey :: Unique
litTIdKey :: Unique
promotedTIdKey :: Unique
promotedTupleTIdKey :: Unique
promotedNilTIdKey :: Unique
promotedConsTIdKey :: Unique
wildCardTIdKey :: Unique
implicitParamTIdKey :: Unique
infixTIdKey :: Unique
numTyLitIdKey :: Unique
strTyLitIdKey :: Unique
charTyLitIdKey :: Unique
plainTVIdKey :: Unique
kindedTVIdKey :: Unique
plainInvisTVIdKey :: Unique
kindedInvisTVIdKey :: Unique
plainBndrTVIdKey :: Unique
kindedBndrTVIdKey :: Unique
nominalRIdKey :: Unique
representationalRIdKey :: Unique
phantomRIdKey :: Unique
inferRIdKey :: Unique
starKIdKey :: Unique
constraintKIdKey :: Unique
noSigIdKey :: Unique
kindSigIdKey :: Unique
tyVarSigIdKey :: Unique
injectivityAnnIdKey :: Unique
cCallIdKey :: Unique
stdCallIdKey :: Unique
cApiCallIdKey :: Unique
primCallIdKey :: Unique
javaScriptCallIdKey :: Unique
unsafeIdKey :: Unique
safeIdKey :: Unique
interruptibleIdKey :: Unique
funDepIdKey :: Unique
mulArrowTIdKey :: Unique
tySynEqnIdKey :: Unique
quoteExpKey :: Unique
quotePatKey :: Unique
quoteDecKey :: Unique
quoteTypeKey :: Unique
ruleVarIdKey :: Unique
typedRuleVarIdKey :: Unique
valueAnnotationIdKey :: Unique
typeAnnotationIdKey :: Unique
moduleAnnotationIdKey :: Unique
derivClauseIdKey :: Unique
stockStrategyIdKey :: Unique
anyclassStrategyIdKey :: Unique
newtypeStrategyIdKey :: Unique
viaStrategyIdKey :: Unique
specifiedSpecKey :: Unique
inferredSpecKey :: Unique
bndrReqKey :: Unique
bndrInvisKey :: Unique
lift_RDR :: RdrName
liftTyped_RDR :: RdrName
unsafeCodeCoerce_RDR :: RdrName


-- | This module defines TyCons that can't be expressed in Haskell. They
--   are all, therefore, wired-in TyCons. C.f module
--   <a>GHC.Builtin.Types</a>
module GHC.Builtin.Types.Prim
mkTemplateKindVar :: Kind -> TyVar
mkTemplateKindVars :: [Kind] -> [TyVar]
mkTemplateTyVars :: [Kind] -> [TyVar]
mkTemplateTyVarsFrom :: Int -> [Kind] -> [TyVar]
mkTemplateKiTyVars :: [Kind] -> ([Kind] -> [Kind]) -> [TyVar]
mkTemplateKiTyVar :: Kind -> (Kind -> [Kind]) -> [TyVar]
mkTemplateTyConBinders :: [Kind] -> ([Kind] -> [Kind]) -> [TyConBinder]
mkTemplateKindTyConBinders :: [Kind] -> [TyConBinder]
mkTemplateAnonTyConBinders :: [Kind] -> [TyConBinder]
alphaTyVars :: [TyVar]
alphaTyVar :: TyVar
betaTyVar :: TyVar
gammaTyVar :: TyVar
deltaTyVar :: TyVar
alphaTyVarSpec :: TyVarBinder
betaTyVarSpec :: TyVarBinder
gammaTyVarSpec :: TyVarBinder
deltaTyVarSpec :: TyVarBinder
alphaTys :: [Type]
alphaTy :: Type
betaTy :: Type
gammaTy :: Type
deltaTy :: Type
alphaTyVarsUnliftedRep :: [TyVar]
alphaTyVarUnliftedRep :: TyVar
alphaTysUnliftedRep :: [Type]
alphaTyUnliftedRep :: Type
runtimeRep1TyVar :: TyVar
runtimeRep2TyVar :: TyVar
runtimeRep3TyVar :: TyVar
runtimeRep1TyVarInf :: TyVarBinder
runtimeRep2TyVarInf :: TyVarBinder
runtimeRep1Ty :: RuntimeRepType
runtimeRep2Ty :: RuntimeRepType
runtimeRep3Ty :: RuntimeRepType
levity1TyVar :: TyVar
levity2TyVar :: TyVar
levity1TyVarInf :: TyVarBinder
levity2TyVarInf :: TyVarBinder
levity1Ty :: Type
levity2Ty :: Type
alphaConstraintTyVar :: TyVar
alphaConstraintTy :: Type
openAlphaTyVar :: TyVar
openBetaTyVar :: TyVar
openGammaTyVar :: TyVar
openAlphaTyVarSpec :: TyVarBinder
openBetaTyVarSpec :: TyVarBinder
openGammaTyVarSpec :: TyVarBinder
openAlphaTy :: Type
openBetaTy :: Type
openGammaTy :: Type
levPolyAlphaTyVar :: TyVar
levPolyBetaTyVar :: TyVar
levPolyAlphaTyVarSpec :: TyVarBinder
levPolyBetaTyVarSpec :: TyVarBinder
levPolyAlphaTy :: Type
levPolyBetaTy :: Type
multiplicityTyVar1 :: TyVar
multiplicityTyVar2 :: TyVar
tYPETyCon :: TyCon
tYPETyConName :: Name
tYPEKind :: Type
cONSTRAINTTyCon :: TyCon
cONSTRAINTTyConName :: Name
cONSTRAINTKind :: Type
funTyFlagTyCon :: FunTyFlag -> TyCon
isArrowTyCon :: TyCon -> Bool

-- | The <tt>FUN</tt> type constructor.
--   
--   <pre>
--   FUN :: forall (m :: Multiplicity) -&gt;
--          forall {rep1 :: RuntimeRep} {rep2 :: RuntimeRep}.
--          TYPE rep1 -&gt; TYPE rep2 -&gt; Type
--   </pre>
--   
--   The runtime representations quantification is left inferred. This
--   means they cannot be specified with <tt>-XTypeApplications</tt>.
--   
--   This is a deliberate choice to allow future extensions to the function
--   arrow.
fUNTyCon :: TyCon
fUNTyConName :: Name
ctArrowTyCon :: TyCon
ctArrowTyConName :: Name
ccArrowTyCon :: TyCon
ccArrowTyConName :: Name
tcArrowTyCon :: TyCon
tcArrowTyConName :: Name

-- | Primitive <a>TyCon</a>s that are defined in GHC.Prim but not
--   "exposed". See Note [Unexposed TyCons]
unexposedPrimTyCons :: [TyCon]

-- | Primitive <a>TyCon</a>s that are defined in, and exported from,
--   GHC.Prim.
exposedPrimTyCons :: [TyCon]
primTyCons :: [TyCon]
charPrimTyCon :: TyCon
charPrimTy :: Type
charPrimTyConName :: Name
intPrimTyCon :: TyCon
intPrimTy :: Type
intPrimTyConName :: Name
wordPrimTyCon :: TyCon
wordPrimTy :: Type
wordPrimTyConName :: Name
addrPrimTyCon :: TyCon
addrPrimTy :: Type
addrPrimTyConName :: Name
floatPrimTyCon :: TyCon
floatPrimTy :: Type
floatPrimTyConName :: Name
doublePrimTyCon :: TyCon
doublePrimTy :: Type
doublePrimTyConName :: Name
statePrimTyCon :: TyCon
mkStatePrimTy :: Type -> Type
realWorldTyCon :: TyCon
realWorldTy :: Type
realWorldStatePrimTy :: Type
realWorldMutableByteArrayPrimTy :: Type
proxyPrimTyCon :: TyCon
mkProxyPrimTy :: Type -> Type -> Type
arrayPrimTyCon :: TyCon
mkArrayPrimTy :: Type -> Type
byteArrayPrimTyCon :: TyCon
byteArrayPrimTy :: Type
smallArrayPrimTyCon :: TyCon
mkSmallArrayPrimTy :: Type -> Type
mutableArrayPrimTyCon :: TyCon
mkMutableArrayPrimTy :: Type -> Type -> Type
mutableByteArrayPrimTyCon :: TyCon
mkMutableByteArrayPrimTy :: Type -> Type
smallMutableArrayPrimTyCon :: TyCon
mkSmallMutableArrayPrimTy :: Type -> Type -> Type
mutVarPrimTyCon :: TyCon
mkMutVarPrimTy :: Type -> Type -> Type
mVarPrimTyCon :: TyCon
mkMVarPrimTy :: Type -> Type -> Type
ioPortPrimTyCon :: TyCon
mkIOPortPrimTy :: Type -> Type -> Type
tVarPrimTyCon :: TyCon
mkTVarPrimTy :: Type -> Type -> Type
stablePtrPrimTyCon :: TyCon
mkStablePtrPrimTy :: Type -> Type
stableNamePrimTyCon :: TyCon
mkStableNamePrimTy :: Type -> Type
compactPrimTyCon :: TyCon
compactPrimTy :: Type
bcoPrimTyCon :: TyCon
bcoPrimTy :: Type
weakPrimTyCon :: TyCon
mkWeakPrimTy :: Type -> Type
threadIdPrimTyCon :: TyCon
threadIdPrimTy :: Type
stackSnapshotPrimTyCon :: TyCon
stackSnapshotPrimTy :: Type
promptTagPrimTyCon :: TyCon
mkPromptTagPrimTy :: Type -> Type
int8PrimTyCon :: TyCon
int8PrimTy :: Type
int8PrimTyConName :: Name
word8PrimTyCon :: TyCon
word8PrimTy :: Type
word8PrimTyConName :: Name
int16PrimTyCon :: TyCon
int16PrimTy :: Type
int16PrimTyConName :: Name
word16PrimTyCon :: TyCon
word16PrimTy :: Type
word16PrimTyConName :: Name
int32PrimTyCon :: TyCon
int32PrimTy :: Type
int32PrimTyConName :: Name
word32PrimTyCon :: TyCon
word32PrimTy :: Type
word32PrimTyConName :: Name
int64PrimTyCon :: TyCon
int64PrimTy :: Type
int64PrimTyConName :: Name
word64PrimTyCon :: TyCon
word64PrimTy :: Type
word64PrimTyConName :: Name
eqPrimTyCon :: TyCon
eqReprPrimTyCon :: TyCon
eqPhantPrimTyCon :: TyCon

-- | Given a Role, what TyCon is the type of equality predicates at that
--   role?
equalityTyCon :: Role -> TyCon
int8X16PrimTy :: Type
int8X16PrimTyCon :: TyCon
int16X8PrimTy :: Type
int16X8PrimTyCon :: TyCon
int32X4PrimTy :: Type
int32X4PrimTyCon :: TyCon
int64X2PrimTy :: Type
int64X2PrimTyCon :: TyCon
int8X32PrimTy :: Type
int8X32PrimTyCon :: TyCon
int16X16PrimTy :: Type
int16X16PrimTyCon :: TyCon
int32X8PrimTy :: Type
int32X8PrimTyCon :: TyCon
int64X4PrimTy :: Type
int64X4PrimTyCon :: TyCon
int8X64PrimTy :: Type
int8X64PrimTyCon :: TyCon
int16X32PrimTy :: Type
int16X32PrimTyCon :: TyCon
int32X16PrimTy :: Type
int32X16PrimTyCon :: TyCon
int64X8PrimTy :: Type
int64X8PrimTyCon :: TyCon
word8X16PrimTy :: Type
word8X16PrimTyCon :: TyCon
word16X8PrimTy :: Type
word16X8PrimTyCon :: TyCon
word32X4PrimTy :: Type
word32X4PrimTyCon :: TyCon
word64X2PrimTy :: Type
word64X2PrimTyCon :: TyCon
word8X32PrimTy :: Type
word8X32PrimTyCon :: TyCon
word16X16PrimTy :: Type
word16X16PrimTyCon :: TyCon
word32X8PrimTy :: Type
word32X8PrimTyCon :: TyCon
word64X4PrimTy :: Type
word64X4PrimTyCon :: TyCon
word8X64PrimTy :: Type
word8X64PrimTyCon :: TyCon
word16X32PrimTy :: Type
word16X32PrimTyCon :: TyCon
word32X16PrimTy :: Type
word32X16PrimTyCon :: TyCon
word64X8PrimTy :: Type
word64X8PrimTyCon :: TyCon
floatX4PrimTy :: Type
floatX4PrimTyCon :: TyCon
doubleX2PrimTy :: Type
doubleX2PrimTyCon :: TyCon
floatX8PrimTy :: Type
floatX8PrimTyCon :: TyCon
doubleX4PrimTy :: Type
doubleX4PrimTyCon :: TyCon
floatX16PrimTy :: Type
floatX16PrimTyCon :: TyCon
doubleX8PrimTy :: Type
doubleX8PrimTyCon :: TyCon

module GHC.Core.TyCo.FVs
shallowTyCoVarsOfType :: Type -> TyCoVarSet
shallowTyCoVarsOfTypes :: [Type] -> TyCoVarSet
tyCoVarsOfType :: Type -> TyCoVarSet
tyCoVarsOfTypes :: [Type] -> TyCoVarSet

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in a
--   deterministic set. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfTypeDSet :: Type -> DTyCoVarSet

-- | Returns free variables of types, including kind variables as a
--   deterministic set. For type synonyms it does <i>not</i> expand the
--   synonym.
tyCoVarsOfTypesDSet :: [Type] -> DTyCoVarSet
tyCoFVsBndr :: ForAllTyBinder -> FV -> FV
tyCoFVsVarBndr :: Var -> FV -> FV
tyCoFVsVarBndrs :: [Var] -> FV -> FV

-- | The worker for <a>tyCoFVsOfType</a> and <tt>tyCoFVsOfTypeList</tt>.
--   The previous implementation used <a>unionVarSet</a> which is O(n+m)
--   and can make the function quadratic. It's exported, so that it can be
--   composed with other functions that compute free variables. See Note
--   [FV naming conventions] in <a>GHC.Utils.FV</a>.
--   
--   Eta-expanded because that makes it run faster (apparently) See Note
--   [FV eta expansion] in <a>GHC.Utils.FV</a> for explanation.
tyCoFVsOfType :: Type -> FV

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in
--   deterministic order. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfTypeList :: Type -> [TyCoVar]
tyCoFVsOfTypes :: [Type] -> FV

-- | Returns free variables of types, including kind variables as a
--   deterministically ordered list. For type synonyms it does <i>not</i>
--   expand the synonym.
tyCoVarsOfTypesList :: [Type] -> [TyCoVar]
deepTcvFolder :: TyCoFolder TyCoVarSet (Endo TyCoVarSet)

-- | Returns free variables of types, including kind variables as a
--   non-deterministic set. For type synonyms it does <i>not</i> expand the
--   synonym.
shallowTyCoVarsOfTyVarEnv :: TyVarEnv Type -> TyCoVarSet
shallowTyCoVarsOfCoVarEnv :: CoVarEnv Coercion -> TyCoVarSet
shallowTyCoVarsOfCo :: Coercion -> TyCoVarSet
shallowTyCoVarsOfCos :: [Coercion] -> TyCoVarSet
tyCoVarsOfCo :: Coercion -> TyCoVarSet
tyCoVarsOfCos :: [Coercion] -> TyCoVarSet
tyCoVarsOfMCo :: MCoercion -> TyCoVarSet
coVarsOfType :: Type -> CoVarSet
coVarsOfTypes :: [Type] -> CoVarSet
coVarsOfCo :: Coercion -> CoVarSet
coVarsOfCos :: [Coercion] -> CoVarSet

-- | Get a deterministic set of the vars free in a coercion
tyCoVarsOfCoDSet :: Coercion -> DTyCoVarSet
tyCoFVsOfCo :: Coercion -> FV
tyCoFVsOfCos :: [Coercion] -> FV
tyCoVarsOfCoList :: Coercion -> [TyCoVar]
coVarsOfCoDSet :: Coercion -> DCoVarSet
coVarsOfCosDSet :: [Coercion] -> DCoVarSet

-- | Given a covar and a coercion, returns True if covar is almost devoid
--   in the coercion. That is, covar can only appear in Refl and GRefl. See
--   (FC6) in Note [ForAllCo] in <a>GHC.Core.TyCo.Rep</a>
almostDevoidCoVarOfCo :: CoVar -> Coercion -> Bool

-- | Returns the free variables of a <a>Type</a> that are in injective
--   positions. Specifically, it finds the free variables while:
--   
--   <ul>
--   <li>Expanding type synonyms</li>
--   <li>Ignoring the coercion in <tt>(ty |&gt; co)</tt></li>
--   <li>Ignoring the non-injective fields of a <a>TyConApp</a></li>
--   </ul>
--   
--   For example, if <tt>F</tt> is a non-injective type family, then:
--   
--   <pre>
--   injectiveTyVarsOf( Either c (Maybe (a, F b c)) ) = {a,c}
--   </pre>
--   
--   If <tt><a>injectiveVarsOfType</a> ty = itvs</tt>, then knowing
--   <tt>ty</tt> fixes <tt>itvs</tt>. More formally, if <tt>a</tt> is in
--   <tt><a>injectiveVarsOfType</a> ty</tt> and <tt>S1(ty) ~ S2(ty)</tt>,
--   then <tt>S1(a) ~ S2(a)</tt>, where <tt>S1</tt> and <tt>S2</tt> are
--   arbitrary substitutions.
--   
--   See <tt>Note [When does a tycon application need an explicit kind
--   signature?]</tt>.
injectiveVarsOfType :: Bool -> Type -> FV

-- | Returns the free variables of a <a>Type</a> that are in injective
--   positions. Specifically, it finds the free variables while:
--   
--   <ul>
--   <li>Expanding type synonyms</li>
--   <li>Ignoring the coercion in <tt>(ty |&gt; co)</tt></li>
--   <li>Ignoring the non-injective fields of a <a>TyConApp</a></li>
--   </ul>
--   
--   See <tt>Note [When does a tycon application need an explicit kind
--   signature?]</tt>.
injectiveVarsOfTypes :: Bool -> [Type] -> FV
isInjectiveInType :: TyVar -> Type -> Bool

-- | Returns the set of variables that are used invisibly anywhere within
--   the given type. A variable will be included even if it is used both
--   visibly and invisibly. An invisible use site includes: * In the kind
--   of a variable * In the kind of a bound variable in a forall * In a
--   coercion * In a Specified or Inferred argument to a function See Note
--   [VarBndrs, ForAllTyBinders, TyConBinders, and visibility] in
--   <a>GHC.Core.TyCo.Rep</a>
invisibleVarsOfType :: Type -> FV

-- | Like <a>invisibleVarsOfType</a>, but for many types.
invisibleVarsOfTypes :: [Type] -> FV
anyFreeVarsOfType :: (TyCoVar -> Bool) -> Type -> Bool
anyFreeVarsOfTypes :: (TyCoVar -> Bool) -> [Type] -> Bool
anyFreeVarsOfCo :: (TyCoVar -> Bool) -> Coercion -> Bool
noFreeVarsOfType :: Type -> Bool
noFreeVarsOfTypes :: [Type] -> Bool
noFreeVarsOfCo :: Coercion -> Bool

-- | All type constructors occurring in the type; looking through type
--   synonyms, but not newtypes. When it finds a Class, it returns the
--   class TyCon.
tyConsOfType :: Type -> UniqSet TyCon
tyConsOfTypes :: [Type] -> UniqSet TyCon
visVarsOfTypes :: [Type] -> Pair TyCoVarSet

-- | Retrieve the free variables in this type, splitting them based on
--   whether they are used visibly or invisibly. Invisible ones come first.
visVarsOfType :: Type -> Pair TyCoVarSet
occCheckExpand :: [Var] -> Type -> Maybe Type

-- | Do a topological sort on a list of tyvars, so that binders occur
--   before occurrences E.g. given [ a::k, k::*, b::k ] it'll return a
--   well-scoped list [ k::*, a::k, b::k ]
--   
--   This is a deterministic sorting operation (that is, doesn't depend on
--   Uniques).
--   
--   It is also meant to be stable: that is, variables should not be
--   reordered unnecessarily. This is specified in Note [ScopedSort] See
--   also Note [Ordering of implicit variables] in <a>GHC.Rename.HsType</a>
scopedSort :: [TyCoVar] -> [TyCoVar]

-- | Get the free vars of a type in scoped order
tyCoVarsOfTypeWellScoped :: Type -> [TyVar]

-- | Get the free vars of types in scoped order
tyCoVarsOfTypesWellScoped :: [Type] -> [TyVar]

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministic set.
closeOverKindsDSet :: DTyVarSet -> DTyVarSet

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministically ordered list.
closeOverKindsList :: [TyVar] -> [TyVar]
closeOverKinds :: TyCoVarSet -> TyCoVarSet
newtype Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a
runTyCoVars :: Endo TyCoVarSet -> TyCoVarSet


-- | Tidying types and coercions for printing in error messages.
module GHC.Core.TyCo.Tidy

-- | Tidy a Type
--   
--   See Note [Strictness in tidyType and friends]
tidyType :: TidyEnv -> Type -> Type

-- | Tidy a list of Types
--   
--   See Note [Strictness in tidyType and friends]
tidyTypes :: TidyEnv -> [Type] -> [Type]

-- | Tidy a Coercion
--   
--   See Note [Strictness in tidyType and friends]
tidyCo :: TidyEnv -> Coercion -> Coercion
tidyCos :: TidyEnv -> [Coercion] -> [Coercion]

-- | Calls <a>tidyType</a> on a top-level type (i.e. with an empty tidying
--   environment)
tidyTopType :: Type -> Type
tidyOpenType :: TidyEnv -> Type -> Type
tidyOpenTypes :: TidyEnv -> [Type] -> [Type]
tidyOpenTypeX :: TidyEnv -> Type -> (TidyEnv, Type)

-- | Grabs the free type variables, tidies them and then uses
--   <a>tidyType</a> to work over the type itself
tidyOpenTypesX :: TidyEnv -> [Type] -> (TidyEnv, [Type])

-- | Add the free <a>TyVar</a>s to the env in tidy form, so that we can
--   tidy the type they are free in Precondition: input free vars are
--   closed over kinds and This function does a scopedSort, so that tidied
--   variables have tidied kinds. See Note [Tidying is idempotent]
tidyFreeTyCoVars :: TidyEnv -> [TyCoVar] -> TidyEnv

-- | Treat a new <a>TyCoVar</a> as a binder, and give it a fresh tidy name
--   using the environment if one has not already been allocated. See also
--   <a>tidyVarBndr</a> See Note [Tidying is idempotent]
tidyFreeTyCoVarX :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)
tidyFreeTyCoVarsX :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])
tidyAvoiding :: [OccName] -> (TidyEnv -> a -> TidyEnv) -> a -> TidyEnv
tidyVarBndr :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)

-- | This tidies up a type for printing in an error message, or in an
--   interface file.
--   
--   It doesn't change the uniques at all, just the print names.
tidyVarBndrs :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])
avoidNameClashes :: [TyCoVar] -> TidyEnv -> TidyEnv
tidyForAllTyBinder :: TidyEnv -> VarBndr TyCoVar vis -> (TidyEnv, VarBndr TyCoVar vis)
tidyForAllTyBinders :: TidyEnv -> [VarBndr TyCoVar vis] -> (TidyEnv, [VarBndr TyCoVar vis])
tidyTyCoVarOcc :: TidyEnv -> TyCoVar -> TyCoVar


-- | Substitution into types and coercions.
module GHC.Core.TyCo.Subst

-- | Type &amp; coercion &amp; id substitution
--   
--   The <a>Subst</a> data type defined in this module contains
--   substitution for tyvar, covar and id. However, operations on
--   IdSubstEnv (mapping from <a>Id</a> to <a>CoreExpr</a>) that require
--   the definition of the <a>Expr</a> data type are defined in
--   GHC.Core.Subst to avoid circular module dependency.
data Subst
Subst :: InScopeSet -> IdSubstEnv -> TvSubstEnv -> CvSubstEnv -> Subst

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type

-- | A substitution of <a>Coercion</a>s for <a>CoVar</a>s
type CvSubstEnv = CoVarEnv Coercion

-- | A substitution of <tt>Expr</tt>s for non-coercion <a>Id</a>s
type IdSubstEnv = IdEnv CoreExpr
emptyIdSubstEnv :: IdSubstEnv
emptyTvSubstEnv :: TvSubstEnv
emptyCvSubstEnv :: CvSubstEnv

-- | Composes two substitutions, applying the second one provided first,
--   like in function composition. This function leaves IdSubstEnv
--   untouched because IdSubstEnv is not used during substitution for
--   types.
composeTCvSubst :: Subst -> Subst -> Subst
emptySubst :: Subst
mkEmptySubst :: InScopeSet -> Subst

-- | Checks whether the tyvar and covar environments are empty. This
--   function should be used over <a>isEmptySubst</a> when substituting for
--   types, because types currently do not contain expressions; we can
--   safely disregard the expression environment when deciding whether to
--   skip a substitution. Using <a>isEmptyTCvSubst</a> gives us a
--   non-trivial performance boost (up to 70% less allocation for T18223)
isEmptyTCvSubst :: Subst -> Bool
isEmptySubst :: Subst -> Bool
mkTCvSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> Subst

-- | Make a TCvSubst with specified tyvar subst and empty covar subst
mkTvSubst :: InScopeSet -> TvSubstEnv -> Subst

-- | Make a TCvSubst with specified covar subst and empty tyvar subst
mkCvSubst :: InScopeSet -> CvSubstEnv -> Subst
mkIdSubst :: InScopeSet -> IdSubstEnv -> Subst
getTvSubstEnv :: Subst -> TvSubstEnv
getIdSubstEnv :: Subst -> IdSubstEnv
getCvSubstEnv :: Subst -> CvSubstEnv

-- | Find the in-scope set: see Note [The substitution invariant]
getSubstInScope :: Subst -> InScopeSet
setInScope :: Subst -> InScopeSet -> Subst

-- | Returns the free variables of the types in the range of a substitution
--   as a non-deterministic set.
getSubstRangeTyCoFVs :: Subst -> VarSet
isInScope :: Var -> Subst -> Bool
elemSubst :: Var -> Subst -> Bool
notElemSubst :: Var -> Subst -> Bool

-- | Remove all substitutions that might have been built up while
--   preserving the in-scope set originally called zapSubstEnv
zapSubst :: Subst -> Subst

-- | Add the <a>Var</a> to the in-scope set
extendSubstInScope :: Subst -> Var -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeList :: Subst -> [Var] -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeSet :: Subst -> VarSet -> Subst
extendTCvSubst :: Subst -> TyCoVar -> Type -> Subst
extendTCvSubstWithClone :: Subst -> TyCoVar -> TyCoVar -> Subst

-- | Add a substitution from a <a>CoVar</a> to a <a>Coercion</a> to the
--   <a>Subst</a>: you must ensure that the in-scope set satisfies Note
--   [The substitution invariant] after extending the substitution like
--   this
extendCvSubst :: Subst -> CoVar -> Coercion -> Subst
extendCvSubstWithClone :: Subst -> CoVar -> CoVar -> Subst

-- | Add a substitution for a <a>TyVar</a> to the <a>Subst</a> The
--   <a>TyVar</a> *must* be a real TyVar, and not a CoVar You must ensure
--   that the in-scope set is such that Note [The substitution invariant]
--   holds after extending the substitution like this.
extendTvSubst :: Subst -> TyVar -> Type -> Subst
extendTvSubstWithClone :: Subst -> TyVar -> TyVar -> Subst

-- | Adds multiple <a>TyVar</a> substitutions to the <a>Subst</a>: see also
--   <a>extendTvSubst</a>
extendTvSubstList :: Subst -> [(TyVar, Type)] -> Subst
extendTvSubstAndInScope :: Subst -> TyVar -> Type -> Subst
extendTCvSubstList :: Subst -> [Var] -> [Type] -> Subst
unionSubst :: Subst -> Subst -> Subst

-- | The InScopeSet is just a thunk so with a bit of luck it'll never be
--   evaluated
zipTyEnv :: HasDebugCallStack => [TyVar] -> [Type] -> TvSubstEnv
zipCoEnv :: HasDebugCallStack => [CoVar] -> [Coercion] -> CvSubstEnv

-- | Generates the in-scope set for the <a>Subst</a> from the types in the
--   incoming environment. No CoVars or Ids, please!
zipTvSubst :: HasDebugCallStack => [TyVar] -> [Type] -> Subst

-- | Generates the in-scope set for the <a>Subst</a> from the types in the
--   incoming environment. No TyVars, please!
zipCvSubst :: HasDebugCallStack => [CoVar] -> [Coercion] -> Subst
zipTCvSubst :: HasDebugCallStack => [TyCoVar] -> [Type] -> Subst

-- | Generates the in-scope set for the <tt>TCvSubst</tt> from the types in
--   the incoming environment. No CoVars, please! The InScopeSet is just a
--   thunk so with a bit of luck it'll never be evaluated
mkTvSubstPrs :: [(TyVar, Type)] -> Subst

-- | Type substitution, see <a>zipTvSubst</a>
substTyWith :: HasDebugCallStack => [TyVar] -> [Type] -> Type -> Type

-- | Substitute covars within a type
substTyWithCoVars :: [CoVar] -> [Coercion] -> Type -> Type

-- | Type substitution, see <a>zipTvSubst</a>
substTysWith :: HasDebugCallStack => [TyVar] -> [Type] -> [Type] -> [Type]

-- | Type substitution, see <a>zipTvSubst</a>
substTysWithCoVars :: HasDebugCallStack => [CoVar] -> [Coercion] -> [Type] -> [Type]

-- | Coercion substitution, see <a>zipTvSubst</a>
substCoWith :: HasDebugCallStack => [TyVar] -> [Type] -> Coercion -> Coercion

-- | Substitute within a <a>Type</a> The substitution has to satisfy the
--   invariants described in Note [The substitution invariant].
substTy :: HasDebugCallStack => Subst -> Type -> Type

-- | Substitute within a <a>Type</a> after adding the free variables of the
--   type to the in-scope set. This is useful for the case when the free
--   variables aren't already in the in-scope set or easily available. See
--   also Note [The substitution invariant].
substTyAddInScope :: HasDebugCallStack => Subst -> Type -> Type
substScaledTy :: HasDebugCallStack => Subst -> Scaled Type -> Scaled Type

-- | Substitute within a <a>Type</a> disabling the sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyUnchecked :: Subst -> Type -> Type

-- | Substitute within several <a>Type</a>s disabling the sanity checks.
--   The problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substTysUnchecked to substTys and remove this
--   function. Please don't use in new code.
substTysUnchecked :: Subst -> [Type] -> [Type]
substScaledTysUnchecked :: Subst -> [Scaled Type] -> [Scaled Type]

-- | Substitute within a <a>ThetaType</a> disabling the sanity checks. The
--   problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substThetaUnchecked to substTheta and remove this
--   function. Please don't use in new code.
substThetaUnchecked :: Subst -> ThetaType -> ThetaType

-- | Type substitution, see <a>zipTvSubst</a>. Disables sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyWithUnchecked :: [TyVar] -> [Type] -> Type -> Type
substScaledTyUnchecked :: HasDebugCallStack => Subst -> Scaled Type -> Scaled Type

-- | Substitute within a <a>Coercion</a> disabling sanity checks. The
--   problems that the sanity checks in substCo catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substCoUnchecked to substCo and remove this function. Please
--   don't use in new code.
substCoUnchecked :: Subst -> Coercion -> Coercion

-- | Coercion substitution, see <a>zipTvSubst</a>. Disables sanity checks.
--   The problems that the sanity checks in substCo catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substCoUnchecked to substCo and remove this function.
--   Please don't use in new code.
substCoWithUnchecked :: [TyVar] -> [Type] -> Coercion -> Coercion

-- | Substitute tyvars within a type using a known <a>InScopeSet</a>.
--   Pre-condition: the <tt>in_scope</tt> set should satisfy Note [The
--   substitution invariant]; specifically it should include the free vars
--   of <tt>tys</tt>, and of <tt>ty</tt> minus the domain of the subst.
substTyWithInScope :: HasDebugCallStack => InScopeSet -> [TyVar] -> [Type] -> Type -> Type

-- | Substitute within several <a>Type</a>s The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTys :: HasDebugCallStack => Subst -> [Type] -> [Type]
substScaledTys :: HasDebugCallStack => Subst -> [Scaled Type] -> [Scaled Type]

-- | Substitute within a <a>ThetaType</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTheta :: HasDebugCallStack => Subst -> ThetaType -> ThetaType
lookupTyVar :: Subst -> TyVar -> Maybe Type

-- | Substitute within a <a>Coercion</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substCo :: HasDebugCallStack => Subst -> Coercion -> Coercion

-- | Substitute within several <a>Coercion</a>s The substitution has to
--   satisfy the invariants described in Note [The substitution invariant].
substCos :: HasDebugCallStack => Subst -> [Coercion] -> [Coercion]
substCoVar :: Subst -> CoVar -> Coercion
substCoVars :: Subst -> [CoVar] -> [Coercion]
lookupCoVar :: Subst -> Var -> Maybe Coercion
cloneTyVarBndr :: Subst -> TyVar -> Unique -> (Subst, TyVar)
cloneTyVarBndrs :: Subst -> [TyVar] -> UniqSupply -> (Subst, [TyVar])
substVarBndr :: HasDebugCallStack => Subst -> TyCoVar -> (Subst, TyCoVar)
substVarBndrs :: HasDebugCallStack => Subst -> [TyCoVar] -> (Subst, [TyCoVar])
substTyVarBndr :: HasDebugCallStack => Subst -> TyVar -> (Subst, TyVar)
substTyVarBndrs :: HasDebugCallStack => Subst -> [TyVar] -> (Subst, [TyVar])
substCoVarBndr :: HasDebugCallStack => Subst -> CoVar -> (Subst, CoVar)

-- | Perform a substitution within a <a>DVarSet</a> of free variables,
--   returning the shallow free coercion variables.
substDCoVarSet :: Subst -> DCoVarSet -> DCoVarSet
substTyVar :: Subst -> TyVar -> Type
substTyVars :: Subst -> [TyVar] -> [Type]
substTyVarToTyVar :: HasDebugCallStack => Subst -> TyVar -> TyVar
substTyCoVars :: Subst -> [TyCoVar] -> [Type]
substTyCoBndr :: Subst -> PiTyBinder -> (Subst, PiTyBinder)
substForAllCoBndr :: Subst -> TyCoVar -> KindCoercion -> (Subst, TyCoVar, Coercion)
substVarBndrUsing :: (Subst -> Type -> Type) -> Subst -> TyCoVar -> (Subst, TyCoVar)
substForAllCoBndrUsing :: SwapFlag -> (Coercion -> Coercion) -> Subst -> TyCoVar -> KindCoercion -> (Subst, TyCoVar, KindCoercion)

-- | This checks if the substitution satisfies the invariant from Note [The
--   substitution invariant].
checkValidSubst :: HasDebugCallStack => Subst -> [Type] -> [Coercion] -> a -> a

-- | When calling <a>substTy</a> it should be the case that the in-scope
--   set in the substitution is a superset of the free vars of the range of
--   the substitution. See also Note [The substitution invariant]. TODO:
--   take into account ids and rename as isValidSubst
isValidTCvSubst :: Subst -> Bool
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Subst.Subst


-- | Main functions for manipulating types and type-related things
module GHC.Core.Type
data Type

-- | ForAllTyFlag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, ForAllTyBinders, TyConBinders,
--   and visibility] in <a>GHC.Core.TyCo.Rep</a>
data ForAllTyFlag
Invisible :: !Specificity -> ForAllTyFlag
Required :: ForAllTyFlag
pattern Inferred :: ForAllTyFlag
pattern Specified :: ForAllTyFlag

-- | The non-dependent version of <a>ForAllTyFlag</a>. See Note [FunTyFlag]
--   Appears here partly so that it's together with its friends
--   ForAllTyFlag and ForallVisFlag, but also because it is used in
--   IfaceType, rather early in the compilation chain
data FunTyFlag
FTF_T_T :: FunTyFlag
FTF_T_C :: FunTyFlag
FTF_C_T :: FunTyFlag
FTF_C_C :: FunTyFlag

-- | Whether an <a>Invisible</a> argument may appear in source Haskell.
data Specificity

-- | the argument may not appear in source Haskell, it is only inferred.
InferredSpec :: Specificity

-- | the argument may appear in source Haskell, but isn't required.
SpecifiedSpec :: Specificity

-- | The key representation of types within the compiler
type KindOrType = Type

-- | A type of the form <tt>p</tt> of constraint kind represents a value
--   whose type is the Haskell predicate <tt>p</tt>, where a predicate is
--   what occurs before the <tt>=&gt;</tt> in a Haskell type.
--   
--   We use <a>PredType</a> as documentation to mark those types that we
--   guarantee to have this kind.
--   
--   It can be expanded into its representation, but:
--   
--   <ul>
--   <li>The type checker must treat it as opaque</li>
--   <li>The rest of the compiler treats it as transparent</li>
--   </ul>
--   
--   Consider these examples:
--   
--   <pre>
--   f :: (Eq a) =&gt; a -&gt; Int
--   g :: (?x :: Int -&gt; Int) =&gt; a -&gt; Int
--   h :: (r\l) =&gt; {r} =&gt; {l::Int | r}
--   </pre>
--   
--   Here the <tt>Eq a</tt> and <tt>?x :: Int -&gt; Int</tt> and
--   <tt>rl</tt> are all called "predicates"
type PredType = Type

-- | A collection of <a>PredType</a>s
type ThetaType = [PredType]
type FRRType = Type

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var

-- | Type or kind Variable
type TyVar = Var

-- | Is this a type-level (i.e., computationally irrelevant, thus erasable)
--   variable? Satisfies <tt>isTyVar = not . isId</tt>.
isTyVar :: Var -> Bool

-- | Type or Coercion Variable
type TyCoVar = Id

-- | A <a>PiTyBinder</a> represents an argument to a function. PiTyBinders
--   can be dependent (<a>Named</a>) or nondependent (<a>Anon</a>). They
--   may also be visible or not. See Note [PiTyBinders]
data PiTyBinder

-- | Variable Binder
--   
--   A <a>ForAllTyBinder</a> is the binder of a ForAllTy It's convenient to
--   define this synonym here rather its natural home in
--   <a>GHC.Core.TyCo.Rep</a>, because it's used in
--   GHC.Core.DataCon.hs-boot
--   
--   A <a>TyVarBinder</a> is a binder with only TyVar
type ForAllTyBinder = VarBndr TyCoVar ForAllTyFlag
type TyVarBinder = VarBndr TyVar ForAllTyFlag

-- | Mult is a type alias for Type.
--   
--   Mult must contain Type because multiplicity variables are mere type
--   variables (of kind Multiplicity) in Haskell. So the simplest
--   implementation is to make Mult be Type.
--   
--   Multiplicities can be formed with: - One: GHC.Types.One (= oneDataCon)
--   - Many: GHC.Types.Many (= manyDataCon) - Multiplication:
--   GHC.Types.MultMul (= multMulTyCon)
--   
--   So that Mult feels a bit more structured, we provide pattern synonyms
--   and smart constructors for these.
type Mult = Type

-- | A shorthand for data with an attached <a>Mult</a> element (the
--   multiplicity).
data Scaled a

-- | A type labeled <a>KnotTied</a> might have knot-tied tycons in it. See
--   Note [Type checking recursive type and class declarations] in
--   <a>GHC.Tc.TyCl</a>
type KnotTied (ty :: k) = ty

-- | Type synonym used for types of kind RuntimeRep.
type RuntimeRepType = Type
mkTyVarTy :: TyVar -> Type
mkTyVarTys :: [TyVar] -> [Type]

-- | Attempts to obtain the type variable underlying a <a>Type</a>, and
--   panics with the given message if this is not a type variable type. See
--   also <a>getTyVar_maybe</a>
getTyVar :: HasDebugCallStack => Type -> TyVar

-- | Attempts to obtain the type variable underlying a <a>Type</a>
getTyVar_maybe :: Type -> Maybe TyVar

-- | Attempts to obtain the type variable underlying a <a>Type</a>, without
--   any expansion
repGetTyVar_maybe :: Type -> Maybe TyVar

-- | If the type is a tyvar, possibly under a cast, returns it, along with
--   the coercion. Thus, the co is :: kind tv ~N kind ty
getCastedTyVar_maybe :: Type -> Maybe (TyVar, CoercionN)
tyVarKind :: TyVar -> Kind

-- | The type or kind of the <a>Var</a> in question
varType :: Var -> Kind

-- | Applies a type to another, as in e.g. <tt>k a</tt>
mkAppTy :: Type -> Type -> Type
mkAppTys :: Type -> [Type] -> Type

-- | Attempts to take a type application apart, as in
--   <a>splitAppTy_maybe</a>, and panics if this is not possible
splitAppTy :: Type -> (Type, Type)

-- | Recursively splits a type as far as is possible, leaving a residual
--   type being applied to and the type arguments applied to it. Never
--   fails, even if that means returning an empty list of type
--   applications.
splitAppTys :: HasDebugCallStack => Type -> (Type, [Type])

-- | Like <a>splitAppTys</a>, but doesn't look through type synonyms
splitAppTysNoView :: HasDebugCallStack => Type -> (Type, [Type])

-- | Attempt to take a type application apart, whether it is a function,
--   type constructor, or plain type application. Note that type family
--   applications are NEVER unsaturated by this!
splitAppTy_maybe :: Type -> Maybe (Type, Type)

-- | Does the AppTy split as in <a>splitAppTy_maybe</a>, but assumes that
--   any coreView stuff is already done
splitAppTyNoView_maybe :: HasDebugCallStack => Type -> Maybe (Type, Type)

-- | Just like splitAppTyNoView_maybe, but does not split (c =&gt; t) See
--   Note [Decomposing fat arrow c=&gt;t]
tcSplitAppTyNoView_maybe :: Type -> Maybe (Type, Type)
mkFunTy :: HasDebugCallStack => FunTyFlag -> Mult -> Type -> Type -> Type
infixr 3 `mkFunTy`
mkVisFunTy :: HasDebugCallStack => Mult -> Type -> Type -> Type

-- | Make nested arrow types | Special, common, case: Arrow type with mult
--   Many
mkVisFunTyMany :: HasDebugCallStack => Type -> Type -> Type
infixr 3 `mkVisFunTyMany`
mkVisFunTysMany :: [Type] -> Type -> Type
mkScaledFunTys :: HasDebugCallStack => [Scaled Type] -> Type -> Type
mkInvisFunTy :: HasDebugCallStack => Type -> Type -> Type
infixr 3 `mkInvisFunTy`
mkInvisFunTys :: HasDebugCallStack => [Type] -> Type -> Type
tcMkVisFunTy :: Mult -> Type -> Type -> Type
tcMkScaledFunTys :: [Scaled Type] -> Type -> Type
tcMkInvisFunTy :: TypeOrConstraint -> Type -> Type -> Type

-- | Attempts to extract the multiplicity, argument and result types from a
--   type, and panics if that is not possible. See also
--   <a>splitFunTy_maybe</a>
splitFunTy :: Type -> (Mult, Type, Type)

-- | Attempts to extract the multiplicity, argument and result types from a
--   type
splitFunTy_maybe :: Type -> Maybe (FunTyFlag, Mult, Type, Type)
splitFunTys :: Type -> ([Scaled Type], Type)

-- | Extract the function result type and panic if that is not possible
funResultTy :: HasDebugCallStack => Type -> Type

-- | Extract the function argument type and panic if that is not possible
--   
--   Just like <a>piResultTys</a> but for a single argument Try not to
--   iterate <a>piResultTy</a>, because it's inefficient to substitute one
--   variable at a time; instead use 'piResultTys"
funArgTy :: HasDebugCallStack => Type -> Type

-- | Given the components of a FunTy figure out the corresponding TyConApp.
funTyConAppTy_maybe :: FunTyFlag -> Type -> Type -> Type -> Maybe (TyCon, [Type])
funTyFlagTyCon :: FunTyFlag -> TyCon

-- | Return Just if this TyConApp should be represented as a FunTy
tyConAppFunTy_maybe :: HasDebugCallStack => TyCon -> [Type] -> Maybe Type

-- | Return Just if this TyConAppCo should be represented as a FunCo
tyConAppFunCo_maybe :: HasDebugCallStack => Role -> TyCon -> [Coercion] -> Maybe Coercion

-- | This one works out the FunTyFlag from the argument type See
--   GHC.Types.Var Note [FunTyFlag]
mkFunctionType :: HasDebugCallStack => Mult -> Type -> Type -> Type

-- | Like mkFunctionType, compute the FunTyFlag from the arguments
mkScaledFunctionTys :: [Scaled Type] -> Type -> Type

-- | See GHC.Types.Var Note [FunTyFlag]
chooseFunTyFlag :: HasDebugCallStack => Type -> Type -> FunTyFlag

-- | A key function: builds a <a>TyConApp</a> or <a>FunTy</a> as
--   appropriate to its arguments. Applies its arguments to the constructor
--   from left to right.
mkTyConApp :: TyCon -> [Type] -> Type

-- | (mkTyConTy tc) returns (TyConApp tc []) but arranges to share that
--   TyConApp among all calls See Note [Sharing nullary TyConApps] So it's
--   just an alias for tyConNullaryTy!
mkTyConTy :: TyCon -> Type

-- | The same as <tt>fst . splitTyConApp</tt> We can short-cut the FunTy
--   case
tyConAppTyCon_maybe :: Type -> Maybe TyCon

-- | Retrieve the tycon heading this type, if there is one. Does <i>not</i>
--   look through synonyms.
tyConAppTyConPicky_maybe :: Type -> Maybe TyCon

-- | The same as <tt>snd . splitTyConApp</tt>
tyConAppArgs_maybe :: Type -> Maybe [Type]
tyConAppTyCon :: HasDebugCallStack => Type -> TyCon
tyConAppArgs :: HasDebugCallStack => Type -> [Type]

-- | Attempts to tease a type apart into a type constructor and the
--   application of a number of arguments to that constructor
splitTyConApp_maybe :: HasDebugCallStack => Type -> Maybe (TyCon, [Type])
splitTyConAppNoView_maybe :: HasDebugCallStack => Type -> Maybe (TyCon, [Type])

-- | Attempts to tease a type apart into a type constructor and the
--   application of a number of arguments to that constructor. Panics if
--   that is not possible. See also <a>splitTyConApp_maybe</a>
splitTyConApp :: Type -> (TyCon, [Type])
tcSplitTyConApp :: Type -> (TyCon, [Type])

-- | tcSplitTyConApp_maybe splits a type constructor application into its
--   type constructor and applied types.
--   
--   Differs from splitTyConApp_maybe in that it does *not* split types
--   headed with (=&gt;), as that's not a TyCon in the type-checker.
--   
--   Note that this may fail (in funTyConAppTy_maybe) in the case of a
--   <a>FunTy</a> with an argument of unknown kind <a>FunTy</a> (e.g.
--   `FunTy (a :: k) Int`, since the kind of <tt>a</tt> isn't of the form
--   `TYPE rep`. This isn't usually a problem but may be temporarily the
--   case during canonicalization: see Note [Decomposing FunTy] in
--   GHC.Tc.Solver.Equality and Note [The Purely Kinded Type Invariant
--   (PKTI)] in GHC.Tc.Gen.HsType, Wrinkle around FunTy
--   
--   Consequently, you may need to zonk your type before using this
--   function.
tcSplitTyConApp_maybe :: HasDebugCallStack => Type -> Maybe (TyCon, [Type])

-- | Like <tt>mkTyCoForAllTy</tt>, but does not check the occurrence of the
--   binder See Note [Unused coercion variable in ForAllTy]
mkForAllTy :: ForAllTyBinder -> Type -> Type

-- | Wraps foralls over the type using the provided <a>TyCoVar</a>s from
--   left to right
mkForAllTys :: [ForAllTyBinder] -> Type -> Type

-- | Wraps foralls over the type using the provided <a>InvisTVBinder</a>s
--   from left to right
mkInvisForAllTys :: [InvisTVBinder] -> Type -> Type

-- | Like <a>mkForAllTys</a>, but assumes all variables are dependent and
--   <a>Inferred</a>, a common case
mkTyCoInvForAllTys :: [TyCoVar] -> Type -> Type

-- | Like <a>mkForAllTy</a>, but assumes the variable is dependent and
--   <a>Specified</a>, a common case
mkSpecForAllTy :: TyVar -> Type -> Type

-- | Like <a>mkForAllTys</a>, but assumes all variables are dependent and
--   <a>Specified</a>, a common case
mkSpecForAllTys :: [TyVar] -> Type -> Type

-- | Like mkForAllTys, but assumes all variables are dependent and visible
mkVisForAllTys :: [TyVar] -> Type -> Type

-- | Make a dependent forall over a TyCoVar
mkTyCoForAllTy :: TyCoVar -> ForAllTyFlag -> Type -> Type

-- | Make a dependent forall over a TyCoVar
mkTyCoForAllTys :: [ForAllTyBinder] -> Type -> Type

-- | Make a dependent forall over an <a>Inferred</a> variable
mkTyCoInvForAllTy :: TyCoVar -> Type -> Type

-- | Like <a>mkTyCoInvForAllTy</a>, but tv should be a tyvar
mkInfForAllTy :: TyVar -> Type -> Type

-- | Like <a>mkTyCoInvForAllTys</a>, but tvs should be a list of tyvar
mkInfForAllTys :: [TyVar] -> Type -> Type

-- | Take a ForAllTy apart, returning the list of tycovars and the result
--   type. This always succeeds, even if it returns only an empty list.
--   Note that the result type returned may have free variables that were
--   bound by a forall.
splitForAllTyCoVars :: Type -> ([TyCoVar], Type)

-- | Like <a>splitForAllTyCoVars</a>, but split only for tyvars. This
--   always succeeds, even if it returns only an empty list. Note that the
--   result type returned may have free variables that were bound by a
--   forall.
splitForAllTyVars :: Type -> ([TyVar], Type)

-- | Like <a>splitForAllTyCoVars</a>, but only splits <a>ForAllTy</a>s with
--   <a>Required</a> type variable binders. Furthermore, each returned
--   tyvar is annotated with <tt>()</tt>.
splitForAllReqTyBinders :: Type -> ([ReqTyBinder], Type)

-- | Like <a>splitForAllTyCoVars</a>, but only splits <a>ForAllTy</a>s with
--   <a>Invisible</a> type variable binders. Furthermore, each returned
--   tyvar is annotated with its <a>Specificity</a>.
splitForAllInvisTyBinders :: Type -> ([InvisTyBinder], Type)

-- | Take a ForAllTy apart, returning the binders and result type
splitForAllForAllTyBinders :: Type -> ([ForAllTyBinder], Type)

-- | Attempts to take a ForAllTy apart, returning the full ForAllTyBinder
splitForAllForAllTyBinder_maybe :: Type -> Maybe (ForAllTyBinder, Type)

-- | Attempts to take a ForAllTy apart, returning the Var
splitForAllTyCoVar_maybe :: Type -> Maybe (TyCoVar, Type)

-- | Take a forall type apart, or panics if that is not possible.
splitForAllTyCoVar :: Type -> (TyCoVar, Type)

-- | Attempts to take a ForAllTy apart, but only if the binder is a TyVar
splitForAllTyVar_maybe :: Type -> Maybe (TyVar, Type)

-- | Like <a>splitForAllTyCoVar_maybe</a>, but only returns Just if it is a
--   covar binder.
splitForAllCoVar_maybe :: Type -> Maybe (CoVar, Type)

-- | Attempts to take a forall type apart; works with proper foralls and
--   functions
splitPiTy_maybe :: Type -> Maybe (PiTyBinder, Type)

-- | Takes a forall type apart, or panics
splitPiTy :: Type -> (PiTyBinder, Type)

-- | Split off all PiTyBinders to a type, splitting both proper foralls and
--   functions
splitPiTys :: Type -> ([PiTyBinder], Type)

-- | Extracts a list of run-time arguments from a function type, looking
--   through newtypes to the right of arrows.
--   
--   Examples:
--   
--   <pre>
--   newtype Identity a = I a
--   
--   getRuntimeArgTys (Int -&gt; Bool -&gt; Double) == [(Int, FTF_T_T), (Bool, FTF_T_T)]
--   getRuntimeArgTys (Identity Int -&gt; Bool -&gt; Double) == [(Identity Int, FTF_T_T), (Bool, FTF_T_T)]
--   getRuntimeArgTys (Int -&gt; Identity (Bool -&gt; Identity Double)) == [(Int, FTF_T_T), (Bool, FTF_T_T)]
--   getRuntimeArgTys (forall a. Show a =&gt; Identity a -&gt; a -&gt; Int -&gt; Bool)
--            == [(Show a, FTF_C_T), (Identity a, FTF_T_T),(a, FTF_T_T),(Int, FTF_T_T)]
--   </pre>
--   
--   Note that, in the last case, the returned types might mention an
--   out-of-scope type variable. This function is used only when we really
--   care about the <i>kinds</i> of the returned types, so this is OK.
--   
--   <ul>
--   <li>*Warning**: this function can return an infinite list. For
--   example:</li>
--   </ul>
--   
--   <pre>
--   newtype N a = MkN (a -&gt; N a)
--   getRuntimeArgTys (N a) == repeat (a, FTF_T_T)
--   </pre>
getRuntimeArgTys :: Type -> [(Scaled Type, FunTyFlag)]

-- | Given a list of type-level vars and the free vars of a result kind,
--   makes PiTyBinders, preferring anonymous binders if the variable is, in
--   fact, not dependent. e.g. mkTyConBindersPreferAnon
--   <a>(k:*),(b:k),(c:k)</a> We want (k:*) Named, (b:k) Anon, (c:k) Anon
--   
--   All non-coercion binders are <i>visible</i>.
mkTyConBindersPreferAnon :: [TyVar] -> TyCoVarSet -> [TyConBinder]
mkPiTy :: HasDebugCallStack => PiTyBinder -> Type -> Type
mkPiTys :: HasDebugCallStack => [PiTyBinder] -> Type -> Type
piResultTy :: HasDebugCallStack => Type -> Type -> Type

-- | (piResultTys f_ty [ty1, .., tyn]) gives the type of (f ty1 .. tyn)
--   where f :: f_ty <a>piResultTys</a> is interesting because: 1.
--   <tt>f_ty</tt> may have more for-alls than there are args 2. Less
--   obviously, it may have fewer for-alls For case 2. think of:
--   piResultTys (forall a.a) [forall b.b, Int] This really can happen, but
--   only (I think) in situations involving undefined. For example:
--   undefined :: forall a. a Term: undefined <tt>(forall b. b-&gt;b)
--   </tt>Int This term should have type (Int -&gt; Int), but notice that
--   there are more type args than foralls in <a>undefined</a>s type.
piResultTys :: HasDebugCallStack => Type -> [Type] -> Type
applyTysX :: HasDebugCallStack => [TyVar] -> Type -> [Type] -> Type

-- | Drops all ForAllTys
dropForAlls :: Type -> Type

-- | Given a family instance TyCon and its arg types, return the
--   corresponding family type. E.g:
--   
--   <pre>
--   data family T a
--   data instance T (Maybe b) = MkT b
--   </pre>
--   
--   Where the instance tycon is :RTL, so:
--   
--   <pre>
--   mkFamilyTyConApp :RTL Int  =  T (Maybe Int)
--   </pre>
mkFamilyTyConApp :: TyCon -> [Type] -> Type
buildSynTyCon :: Name -> [KnotTied TyConBinder] -> Kind -> [Role] -> KnotTied Type -> TyCon
mkNumLitTy :: Integer -> Type

-- | Is this a numeric literal. We also look through type synonyms.
isNumLitTy :: Type -> Maybe Integer
mkStrLitTy :: FastString -> Type

-- | Is this a symbol literal. We also look through type synonyms.
isStrLitTy :: Type -> Maybe FastString
mkCharLitTy :: Char -> Type

-- | Is this a char literal? We also look through type synonyms.
isCharLitTy :: Type -> Maybe Char

-- | Is this a type literal (symbol, numeric, or char)?
isLitTy :: Type -> Maybe TyLit
isPredTy :: HasDebugCallStack => Type -> Bool

-- | Extract the RuntimeRep classifier of a type. For instance,
--   <tt>getRuntimeRep_maybe Int = LiftedRep</tt>. Panics if this is not
--   possible.
getRuntimeRep :: HasDebugCallStack => Type -> RuntimeRepType

-- | (splitRuntimeRep_maybe rr) takes a Type rr :: RuntimeRep, and returns
--   the (TyCon,[Type]) for the RuntimeRep, if possible, where the TyCon is
--   one of the promoted DataCons of RuntimeRep. Remember: the unique on
--   TyCon that is a a promoted DataCon is the same as the unique on the
--   DataCon See Note [Promoted data constructors] in GHC.Core.TyCon May
--   not be possible if <tt>rr</tt> is a type variable or type family
--   application
splitRuntimeRep_maybe :: RuntimeRepType -> Maybe (TyCon, [Type])

-- | Given a kind (TYPE rr) or (CONSTRAINT rr), extract its RuntimeRep
--   classifier rr. For example, <tt>kindRep_maybe * = Just LiftedRep</tt>
--   Returns <a>Nothing</a> if the kind is not of form (TYPE rr)
kindRep_maybe :: HasDebugCallStack => Kind -> Maybe RuntimeRepType

-- | Extract the RuntimeRep classifier of a type from its kind. For
--   example, <tt>kindRep * = LiftedRep</tt>; Panics if this is not
--   possible. Treats * and Constraint as the same
kindRep :: HasDebugCallStack => Kind -> RuntimeRepType

-- | Extract the <a>Levity</a> of a type. For example, <tt>getLevity Int =
--   Lifted</tt>, or <tt>getLevity (Array# Int) = Unlifted</tt>.
--   
--   Panics if this is not possible. Does not look through type family
--   applications.
getLevity :: HasDebugCallStack => Type -> Type

-- | <a>levityType_maybe</a> takes a Type of kind Levity, and returns its
--   levity May not be possible for a type variable or type family
--   application
levityType_maybe :: LevityType -> Maybe Levity

-- | Make a <a>CastTy</a>. The Coercion must be nominal. Checks the
--   Coercion for reflexivity, dropping it if it's reflexive. See <tt>Note
--   [Respecting definitional equality]</tt> in <a>GHC.Core.TyCo.Rep</a>
mkCastTy :: Type -> Coercion -> Type
mkCoercionTy :: Coercion -> Type
splitCastTy_maybe :: Type -> Maybe (Type, Coercion)

-- | A type of kind <tt>ErrorMessage</tt> (from the <a>TypeError</a>
--   module).
type ErrorMsgType = Type

-- | Is this type a custom user error? If so, give us the error message.
userTypeError_maybe :: Type -> Maybe ErrorMsgType
deepUserTypeError_maybe :: Type -> Maybe ErrorMsgType

-- | Render a type corresponding to a user type error into a SDoc.
pprUserTypeErrorTy :: ErrorMsgType -> SDoc

-- | Get the type on the LHS of a coercion induced by a type/data family
--   instance.
coAxNthLHS :: forall (br :: BranchFlag). CoAxiom br -> Int -> Type
stripCoercionTy :: Type -> Coercion

-- | Like <a>splitPiTys</a>, but returns only *invisible* binders,
--   including constraints. Stops at the first visible binder.
splitInvisPiTys :: Type -> ([PiTyBinder], Type)

-- | Same as <a>splitInvisPiTys</a>, but stop when - you have found
--   <tt>n</tt> <a>PiTyBinder</a>s, - or you run out of invisible binders
splitInvisPiTysN :: Int -> Type -> ([PiTyBinder], Type)
invisibleTyBndrCount :: Type -> Int

-- | Given a <a>TyCon</a> and a list of argument types, filter out any
--   invisible (i.e., <a>Inferred</a> or <a>Specified</a>) arguments.
filterOutInvisibleTypes :: TyCon -> [Type] -> [Type]

-- | Given a <a>TyCon</a> and a list of argument types, filter out any
--   <a>Inferred</a> arguments.
filterOutInferredTypes :: TyCon -> [Type] -> [Type]

-- | Given a <a>TyCon</a> and a list of argument types, partition the
--   arguments into:
--   
--   <ol>
--   <li><a>Inferred</a> or <a>Specified</a> (i.e., invisible) arguments
--   and</li>
--   <li><a>Required</a> (i.e., visible) arguments</li>
--   </ol>
partitionInvisibleTypes :: TyCon -> [Type] -> ([Type], [Type])

-- | Given a list of things paired with their visibilities, partition the
--   things into (invisible things, visible things).
partitionInvisibles :: [(a, ForAllTyFlag)] -> ([a], [a])

-- | Given a <a>TyCon</a> and a list of argument types to which the
--   <a>TyCon</a> is applied, determine each argument's visibility
--   (<a>Inferred</a>, <a>Specified</a>, or <a>Required</a>).
--   
--   Wrinkle: consider the following scenario:
--   
--   <pre>
--   T :: forall k. k -&gt; k
--   tyConForAllTyFlags T [forall m. m -&gt; m -&gt; m, S, R, Q]
--   </pre>
--   
--   After substituting, we get
--   
--   <pre>
--   T (forall m. m -&gt; m -&gt; m) :: (forall m. m -&gt; m -&gt; m) -&gt; forall n. n -&gt; n -&gt; n
--   </pre>
--   
--   Thus, the first argument is invisible, <tt>S</tt> is visible,
--   <tt>R</tt> is invisible again, and <tt>Q</tt> is visible.
tyConForAllTyFlags :: TyCon -> [Type] -> [ForAllTyFlag]

-- | Given a <a>Type</a> and a list of argument types to which the
--   <a>Type</a> is applied, determine each argument's visibility
--   (<a>Inferred</a>, <a>Specified</a>, or <a>Required</a>).
--   
--   Most of the time, the arguments will be <a>Required</a>, but not
--   always. Consider <tt>f :: forall a. a -&gt; Type</tt>. In <tt>f Type
--   Bool</tt>, the first argument (<tt>Type</tt>) is <a>Specified</a> and
--   the second argument (<tt>Bool</tt>) is <a>Required</a>. It is
--   precisely this sort of higher-rank situation in which
--   <a>appTyForAllTyFlags</a> comes in handy, since <tt>f Type Bool</tt>
--   would be represented in Core using <a>AppTy</a>s. (See also #15792).
appTyForAllTyFlags :: Type -> [Type] -> [ForAllTyFlag]

-- | This describes how a "map" operation over a type/coercion should
--   behave
data TyCoMapper env (m :: Type -> Type)
TyCoMapper :: (env -> TyVar -> m Type) -> (env -> CoVar -> m Coercion) -> (env -> CoercionHole -> m Coercion) -> (forall r. () => env -> TyCoVar -> ForAllTyFlag -> (env -> TyCoVar -> m r) -> m r) -> (TyCon -> m TyCon) -> TyCoMapper env (m :: Type -> Type)
[tcm_tyvar] :: TyCoMapper env (m :: Type -> Type) -> env -> TyVar -> m Type
[tcm_covar] :: TyCoMapper env (m :: Type -> Type) -> env -> CoVar -> m Coercion

-- | What to do with coercion holes. See Note [Coercion holes] in
--   <a>GHC.Core.TyCo.Rep</a>.
[tcm_hole] :: TyCoMapper env (m :: Type -> Type) -> env -> CoercionHole -> m Coercion

-- | The returned env is used in the extended scope
[tcm_tycobinder] :: TyCoMapper env (m :: Type -> Type) -> forall r. () => env -> TyCoVar -> ForAllTyFlag -> (env -> TyCoVar -> m r) -> m r

-- | This is used only for TcTyCons a) To zonk TcTyCons b) To turn TcTyCons
--   into TyCons. See Note [Type checking recursive type and class
--   declarations] in <a>GHC.Tc.TyCl</a>
[tcm_tycon] :: TyCoMapper env (m :: Type -> Type) -> TyCon -> m TyCon
mapTyCo :: Monad m => TyCoMapper () m -> (Type -> m Type, [Type] -> m [Type], Coercion -> m Coercion, [Coercion] -> m [Coercion])
mapTyCoX :: Monad m => TyCoMapper env m -> (env -> Type -> m Type, env -> [Type] -> m [Type], env -> Coercion -> m Coercion, env -> [Coercion] -> m [Coercion])
data TyCoFolder env a
TyCoFolder :: (Type -> Maybe Type) -> (env -> TyVar -> a) -> (env -> CoVar -> a) -> (env -> CoercionHole -> a) -> (env -> TyCoVar -> ForAllTyFlag -> env) -> TyCoFolder env a
[tcf_view] :: TyCoFolder env a -> Type -> Maybe Type
[tcf_tyvar] :: TyCoFolder env a -> env -> TyVar -> a
[tcf_covar] :: TyCoFolder env a -> env -> CoVar -> a

-- | What to do with coercion holes. See Note [Coercion holes] in
--   <a>GHC.Core.TyCo.Rep</a>.
[tcf_hole] :: TyCoFolder env a -> env -> CoercionHole -> a

-- | The returned env is used in the extended scope
[tcf_tycobinder] :: TyCoFolder env a -> env -> TyCoVar -> ForAllTyFlag -> env
foldTyCo :: Monoid a => TyCoFolder env a -> env -> (Type -> a, [Type] -> a, Coercion -> a, [Coercion] -> a)

-- | A view function that looks through nothing.
noView :: Type -> Maybe Type

-- | Unwrap one <tt>layer</tt> of newtype on a type constructor and its
--   arguments, using an eta-reduced version of the <tt>newtype</tt> if
--   possible. This requires tys to have at least <tt>newTyConInstArity
--   tycon</tt> elements.
newTyConInstRhs :: TyCon -> [Type] -> Type

-- | Make a named binder
mkForAllTyBinder :: vis -> TyCoVar -> VarBndr TyCoVar vis

-- | Make many named binders
mkForAllTyBinders :: vis -> [TyCoVar] -> [VarBndr TyCoVar vis]

-- | Make a named binder <tt>var</tt> should be a type variable
mkTyVarBinder :: vis -> TyVar -> VarBndr TyVar vis

-- | Make many named binders Input vars should be type variables
mkTyVarBinders :: vis -> [TyVar] -> [VarBndr TyVar vis]
tyVarSpecToBinders :: [VarBndr a Specificity] -> [VarBndr a ForAllTyFlag]

-- | Does this binder bind a variable that is <i>not</i> erased? Returns
--   <a>True</a> for anonymous binders.
isAnonPiTyBinder :: PiTyBinder -> Bool
binderVar :: VarBndr tv argf -> tv
binderVars :: [VarBndr tv argf] -> [tv]
binderType :: VarBndr TyCoVar argf -> Type
binderFlag :: VarBndr tv argf -> argf
binderFlags :: [VarBndr tv argf] -> [argf]
piTyBinderType :: PiTyBinder -> Type
namedPiTyBinder_maybe :: PiTyBinder -> Maybe TyCoVar

-- | Extract a relevant type, if there is one.
anonPiTyBinderType_maybe :: PiTyBinder -> Maybe Type

-- | Does this <a>ForAllTyFlag</a> classify an argument that is written in
--   Haskell?
isVisibleForAllTyFlag :: ForAllTyFlag -> Bool

-- | Does this <a>ForAllTyFlag</a> classify an argument that is not written
--   in Haskell?
isInvisibleForAllTyFlag :: ForAllTyFlag -> Bool

-- | Does this binder bind a visible argument?
isVisiblePiTyBinder :: PiTyBinder -> Bool

-- | Does this binder bind an invisible argument?
isInvisiblePiTyBinder :: PiTyBinder -> Bool
isNamedPiTyBinder :: PiTyBinder -> Bool
tyConBindersPiTyBinders :: [TyConBinder] -> [PiTyBinder]
isTyVarTy :: Type -> Bool

-- | Is this a function? Note: `forall {b}. Show b =&gt; b -&gt; IO b` will
--   not be considered a function by this function. It would merely be a
--   forall wrapping a function type.
isFunTy :: Type -> Bool
isCoercionTy :: Type -> Bool
isCoercionTy_maybe :: Type -> Maybe Coercion

-- | Checks whether this is a proper forall (with a named binder)
isForAllTy :: Type -> Bool

-- | Like <a>isForAllTy</a>, but returns True only if it is a tyvar binder
isForAllTy_ty :: Type -> Bool

-- | Like <a>isForAllTy</a>, but returns True only if it is a covar binder
isForAllTy_co :: Type -> Bool

-- | Like <a>isForAllTy</a>, but returns True only if it is an inferred
--   tyvar binder
isForAllTy_invis_ty :: Type -> Bool

-- | Is this a function or forall?
isPiTy :: Type -> Bool
isTauTy :: Type -> Bool
isFamFreeTy :: Type -> Bool
isAtomicTy :: Type -> Bool

-- | Determine whether a type could be the type of a join point of given
--   total arity, according to the polymorphism rule. A join point cannot
--   be polymorphic in its return type, since given join j <tt>a </tt>b x y
--   z = e1 in e2, the types of e1 and e2 must be the same, and a and b are
--   not in scope for e2. (See Note [The polymorphism rule of join points]
--   in <a>GHC.Core</a>.) Returns False also if the type simply doesn't
--   have enough arguments.
--   
--   Note that we need to know how many arguments (type *and* value) the
--   putative join point takes; for instance, if j :: forall a. a -&gt; Int
--   then j could be a binary join point returning an Int, but it could
--   *not* be a unary join point returning a -&gt; Int.
--   
--   TODO: See Note [Excess polymorphism and join points]
isValidJoinPointType :: JoinArity -> Type -> Bool

-- | Does a <a>TyCon</a> (that is applied to some number of arguments) need
--   to be ascribed with an explicit kind signature to resolve ambiguity if
--   rendered as a source-syntax type? (See <tt>Note [When does a tycon
--   application need an explicit kind signature?]</tt> for a full
--   explanation of what this function checks for.)
tyConAppNeedsKindSig :: Bool -> TyCon -> Int -> Bool
mkTYPEapp :: RuntimeRepType -> Type

-- | Given a <tt>RuntimeRep</tt>, applies <tt>TYPE</tt> to it. On the fly
--   it rewrites TYPE LiftedRep --&gt; liftedTypeKind (a synonym) TYPE
--   UnliftedRep --&gt; unliftedTypeKind (ditto) TYPE ZeroBitRep --&gt;
--   zeroBitTypeKind (ditto) NB: no need to check for TYPE (BoxedRep
--   Lifted), TYPE (BoxedRep Unlifted) because those inner types should
--   already have been rewritten to LiftedRep and UnliftedRep respectively,
--   by mkTyConApp
--   
--   see Note [TYPE and CONSTRAINT] in GHC.Builtin.Types.Prim. See Note
--   [Using synonyms to compress types] in GHC.Core.Type
mkTYPEapp_maybe :: RuntimeRepType -> Maybe Type

-- | Just like mkTYPEapp
mkCONSTRAINTapp :: RuntimeRepType -> Type

-- | Just like mkTYPEapp_maybe
mkCONSTRAINTapp_maybe :: RuntimeRepType -> Maybe Type

-- | Given a <a>Levity</a>, apply <a>BoxedRep</a> to it On the fly, rewrite
--   BoxedRep Lifted --&gt; liftedRepTy (a synonym) BoxedRep Unlifted
--   --&gt; unliftedRepTy (ditto) See Note [TYPE and CONSTRAINT] in
--   GHC.Builtin.Types.Prim. See Note [Using synonyms to compress types] in
--   GHC.Core.Type
mkBoxedRepApp_maybe :: LevityType -> Maybe Type

-- | Given a `[RuntimeRep]`, apply <tt>TupleRep</tt> to it On the fly,
--   rewrite TupleRep [] -&gt; zeroBitRepTy (a synonym) See Note [TYPE and
--   CONSTRAINT] in GHC.Builtin.Types.Prim. See Note [Using synonyms to
--   compress types] in GHC.Core.Type
mkTupleRepApp_maybe :: Type -> Maybe Type
typeOrConstraintKind :: TypeOrConstraint -> RuntimeRepType -> Kind
sORTKind_maybe :: Kind -> Maybe (TypeOrConstraint, Type)
typeTypeOrConstraint :: HasDebugCallStack => Type -> TypeOrConstraint
typeLevity :: HasDebugCallStack => Type -> Levity

-- | Tries to compute the <a>Levity</a> of the given type. Returns either a
--   definite <a>Levity</a>, or <a>Nothing</a> if we aren't sure (e.g. the
--   type is representation-polymorphic).
--   
--   Panics if the kind does not have the shape <tt>TYPE r</tt>.
typeLevity_maybe :: HasDebugCallStack => Type -> Maybe Levity
tyConIsTYPEorCONSTRAINT :: TyCon -> Bool

-- | Returns True if the argument is (lifted) Type or Constraint See Note
--   [TYPE and CONSTRAINT] in GHC.Builtin.Types.Prim
isLiftedTypeKind :: Kind -> Bool

-- | Returns True if the kind classifies unlifted types (like 'Int#') and
--   False otherwise. Note that this returns False for
--   representation-polymorphic kinds, which may be specialized to a kind
--   that classifies unlifted types.
isUnliftedTypeKind :: Kind -> Bool
pickyIsLiftedTypeKind :: Kind -> Bool

-- | Check whether a type of kind <a>RuntimeRep</a> is lifted.
--   
--   <a>isLiftedRuntimeRep</a> is:
--   
--   <ul>
--   <li>True of <tt>LiftedRep :: RuntimeRep</tt></li>
--   <li>False of type variables, type family applications, and of other
--   reps such as <tt>IntRep :: RuntimeRep</tt>.</li>
--   </ul>
isLiftedRuntimeRep :: RuntimeRepType -> Bool

-- | Check whether a type of kind <a>RuntimeRep</a> is unlifted.
--   
--   <ul>
--   <li>True of definitely unlifted <a>RuntimeRep</a>s such as
--   <tt>UnliftedRep</tt>, <a>IntRep</a>, <a>FloatRep</a>, ...</li>
--   <li>False of <tt>LiftedRep</tt>,</li>
--   <li>False for type variables and type family applications.</li>
--   </ul>
isUnliftedRuntimeRep :: RuntimeRepType -> Bool

-- | Check whether a type (usually of kind <a>RuntimeRep</a>) is lifted,
--   unlifted, or unknown. Returns Nothing if the type isn't of kind
--   <a>RuntimeRep</a>.
--   
--   `runtimeRepLevity_maybe rr` returns:
--   
--   <ul>
--   <li>`Just Lifted` if <tt>rr</tt> is `LiftedRep :: RuntimeRep`</li>
--   <li>`Just Unlifted` if <tt>rr</tt> is definitely unlifted, e.g.
--   <a>IntRep</a></li>
--   <li><a>Nothing</a> if not known (e.g. it's a type variable or a type
--   family application).</li>
--   </ul>
runtimeRepLevity_maybe :: RuntimeRepType -> Maybe Levity

-- | See <a>isBoxedRuntimeRep_maybe</a>.
isBoxedRuntimeRep :: RuntimeRepType -> Bool
isLiftedLevity :: Type -> Bool
isUnliftedLevity :: Type -> Bool

-- | Is the given type definitely unlifted? See
--   <a>Type#type_classification</a> for what an unlifted type is.
--   
--   Panics on representation-polymorphic types; See
--   <a>mightBeUnliftedType</a> for a more approximate predicate that
--   behaves better in the presence of representation polymorphism.
isUnliftedType :: HasDebugCallStack => Type -> Bool

-- | See <a>Type#type_classification</a> for what a boxed type is. Panics
--   on representation-polymorphic types; See <a>mightBeUnliftedType</a>
--   for a more approximate predicate that behaves better in the presence
--   of representation polymorphism.
isBoxedType :: Type -> Bool
isUnboxedTupleType :: Type -> Bool
isUnboxedSumType :: Type -> Bool

-- | Check whether a kind is of the form `TYPE (BoxedRep Lifted)` or `TYPE
--   (BoxedRep Unlifted)`.
--   
--   Returns:
--   
--   <ul>
--   <li>`Just Lifted` for `TYPE (BoxedRep Lifted)` and <a>Type</a>,</li>
--   <li>`Just Unlifted` for `TYPE (BoxedRep Unlifted)` and
--   <tt>UnliftedType</tt>,</li>
--   <li><a>Nothing</a> for anything else, e.g. `TYPE IntRep`, `TYPE
--   (BoxedRep l)`, etc.</li>
--   </ul>
kindBoxedRepLevity_maybe :: Type -> Maybe Levity

-- | Returns:
--   
--   <ul>
--   <li><a>False</a> if the type is <i>guaranteed</i> unlifted or</li>
--   <li><a>True</a> if it lifted, OR we aren't sure (e.g. in a
--   representation-polymorphic case)</li>
--   </ul>
mightBeLiftedType :: Type -> Bool

-- | Returns:
--   
--   <ul>
--   <li><a>False</a> if the type is <i>guaranteed</i> lifted or</li>
--   <li><a>True</a> if it is unlifted, OR we aren't sure (e.g. in a
--   representation-polymorphic case)</li>
--   </ul>
mightBeUnliftedType :: Type -> Bool
definitelyLiftedType :: Type -> Bool
definitelyUnliftedType :: Type -> Bool

-- | See <a>Type#type_classification</a> for what an algebraic type is.
--   Should only be applied to <i>types</i>, as opposed to e.g. partially
--   saturated type constructors
isAlgType :: Type -> Bool

-- | Check whether a type is a data family type
isDataFamilyAppType :: Type -> Bool

-- | Returns true of types that are opaque to Haskell.
isPrimitiveType :: Type -> Bool

-- | Computes whether an argument (or let right hand side) should be
--   computed strictly or lazily, based only on its type. Currently, it's
--   just <a>isUnliftedType</a>. Panics on representation-polymorphic
--   types.
isStrictType :: HasDebugCallStack => Type -> Bool

-- | True <a>=</a> a term of this type cannot be bottom This identifies the
--   types described by Note [NON-BOTTOM-DICTS invariant] in GHC.Core NB:
--   unlifted types are not terminating types! e.g. you can write a term
--   (loop 1)::Int# that diverges.
isTerminatingType :: HasDebugCallStack => Type -> Bool

-- | Is this the type <a>Levity</a>?
isLevityTy :: Type -> Bool

-- | Is a tyvar of type <a>Levity</a>?
isLevityVar :: TyVar -> Bool

-- | Is this the type <a>RuntimeRep</a>?
isRuntimeRepTy :: Type -> Bool

-- | Is a tyvar of type <a>RuntimeRep</a>?
isRuntimeRepVar :: TyVar -> Bool

-- | Is this a type of kind RuntimeRep? (e.g. LiftedRep)
isRuntimeRepKindedTy :: Type -> Bool

-- | Drops prefix of RuntimeRep constructors in <a>TyConApp</a>s. Useful
--   for e.g. dropping 'LiftedRep arguments of unboxed tuple TyCon
--   applications:
--   
--   dropRuntimeRepArgs [ 'LiftedRep, 'IntRep , String, Int# ] == [String,
--   Int#]
dropRuntimeRepArgs :: [Type] -> [Type]

-- | Is this the type <tt>Multiplicity</tt>?
isMultiplicityTy :: Type -> Bool

-- | Is a tyvar of type <tt>Multiplicity</tt>?
isMultiplicityVar :: TyVar -> Bool

-- | Scale a payload by Many
unrestricted :: a -> Scaled a

-- | Scale a payload by One
linear :: a -> Scaled a

-- | Scale a payload by Many; used for type arguments in core
tymult :: a -> Scaled a
mkScaled :: Mult -> a -> Scaled a
irrelevantMult :: Scaled a -> a
scaledSet :: Scaled a -> b -> Scaled b
pattern OneTy :: Mult
pattern ManyTy :: Mult
isOneTy :: Mult -> Bool
isManyTy :: Mult -> Bool

-- | <tt>isLinear t</tt> returns <tt>True</tt> of a if <tt>t</tt> is a type
--   of (curried) function where at least one argument is linear (or
--   otherwise non-unrestricted). We use this function to check whether it
--   is safe to eta reduce an Id in CorePrep. It is always safe to return
--   <a>True</a>, because <a>True</a> deactivates the optimisation.
isLinearType :: Type -> Bool

-- | The key type representing kinds in the compiler.
type Kind = Type
typeKind :: HasDebugCallStack => Type -> Kind

-- | Returns True if a type has a syntactically fixed runtime rep, as per
--   Note [Fixed RuntimeRep] in GHC.Tc.Utils.Concrete.
--   
--   This function is equivalent to `isFixedRuntimeRepKind . typeKind` but
--   much faster.
--   
--   <b>Precondition:</b> The type has kind <tt>(<tt>TYPE</tt> blah)</tt>
typeHasFixedRuntimeRep :: HasDebugCallStack => Type -> Bool

-- | Is this kind equivalent to <a>Type</a> i.e. TYPE LiftedRep?
tcIsLiftedTypeKind :: Kind -> Bool
isConstraintKind :: Kind -> Bool
isConstraintLikeKind :: Kind -> Bool
returnsConstraintKind :: Kind -> Bool

-- | Is this kind equivalent to <tt>TYPE (BoxedRep l)</tt> for some <tt>l
--   :: Levity</tt>?
tcIsBoxedTypeKind :: Kind -> Bool

-- | Is this kind equivalent to <tt>TYPE r</tt> (for some unknown r)?
--   
--   This considers <tt>Constraint</tt> to be distinct from <tt>*</tt>.
isTypeLikeKind :: Kind -> Bool
liftedTypeKind :: Type
unliftedTypeKind :: Type

-- | The worker for <a>tyCoFVsOfType</a> and <tt>tyCoFVsOfTypeList</tt>.
--   The previous implementation used <a>unionVarSet</a> which is O(n+m)
--   and can make the function quadratic. It's exported, so that it can be
--   composed with other functions that compute free variables. See Note
--   [FV naming conventions] in <a>GHC.Utils.FV</a>.
--   
--   Eta-expanded because that makes it run faster (apparently) See Note
--   [FV eta expansion] in <a>GHC.Utils.FV</a> for explanation.
tyCoFVsOfType :: Type -> FV
tyCoFVsBndr :: ForAllTyBinder -> FV -> FV
tyCoFVsVarBndr :: Var -> FV -> FV
tyCoFVsVarBndrs :: [Var] -> FV -> FV
tyCoVarsOfType :: Type -> TyCoVarSet
tyCoVarsOfTypes :: [Type] -> TyCoVarSet

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in a
--   deterministic set. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfTypeDSet :: Type -> DTyCoVarSet
coVarsOfType :: Type -> CoVarSet
coVarsOfTypes :: [Type] -> CoVarSet
anyFreeVarsOfType :: (TyCoVar -> Bool) -> Type -> Bool
anyFreeVarsOfTypes :: (TyCoVar -> Bool) -> [Type] -> Bool
noFreeVarsOfType :: Type -> Bool

-- | Expand out all type synonyms. Actually, it'd suffice to expand out
--   just the ones that discard type variables (e.g. type Funny a = Int)
--   But we don't know which those are currently, so we just expand all.
--   
--   <a>expandTypeSynonyms</a> only expands out type synonyms mentioned in
--   the type, not in the kinds of any TyCon or TyVar mentioned in the
--   type.
--   
--   Keep this synchronized with <tt>synonymTyConsOfType</tt>
expandTypeSynonyms :: Type -> Type

-- | <tt>expandSynTyConApp_maybe tc tys</tt> expands the RHS of type
--   synonym <tt>tc</tt> instantiated at arguments <tt>tys</tt>, or returns
--   <a>Nothing</a> if <tt>tc</tt> is not a synonym.
expandSynTyConApp_maybe :: TyCon -> [Type] -> Maybe Type
typeSize :: Type -> Int
occCheckExpand :: [Var] -> Type -> Maybe Type

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministic set.
closeOverKindsDSet :: DTyVarSet -> DTyVarSet

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministically ordered list.
closeOverKindsList :: [TyVar] -> [TyVar]
closeOverKinds :: TyCoVarSet -> TyCoVarSet

-- | Do a topological sort on a list of tyvars, so that binders occur
--   before occurrences E.g. given [ a::k, k::*, b::k ] it'll return a
--   well-scoped list [ k::*, a::k, b::k ]
--   
--   This is a deterministic sorting operation (that is, doesn't depend on
--   Uniques).
--   
--   It is also meant to be stable: that is, variables should not be
--   reordered unnecessarily. This is specified in Note [ScopedSort] See
--   also Note [Ordering of implicit variables] in <a>GHC.Rename.HsType</a>
scopedSort :: [TyCoVar] -> [TyCoVar]

-- | Get the free vars of a type in scoped order
tyCoVarsOfTypeWellScoped :: Type -> [TyVar]

-- | Get the free vars of types in scoped order
tyCoVarsOfTypesWellScoped :: [Type] -> [TyVar]
seqType :: Type -> ()
seqTypes :: [Type] -> ()

-- | This function strips off the <i>top layer only</i> of a type synonym
--   application (if any) its underlying representation type. Returns
--   <a>Nothing</a> if there is nothing to look through.
--   
--   This function does not look through type family applications.
--   
--   By being non-recursive and inlined, this case analysis gets
--   efficiently joined onto the case analysis that the caller is already
--   doing
coreView :: Type -> Maybe Type

-- | Iterates <a>coreView</a> until there is no more to synonym to expand.
--   NB: coreFullView is non-recursive and can be inlined; core_full_view
--   is the recursive one See Note [Inlining coreView].
coreFullView :: Type -> Type
rewriterView :: Type -> Maybe Type

-- | All type constructors occurring in the type; looking through type
--   synonyms, but not newtypes. When it finds a Class, it returns the
--   class TyCon.
tyConsOfType :: Type -> UniqSet TyCon

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type

-- | A substitution of <tt>Expr</tt>s for non-coercion <a>Id</a>s
type IdSubstEnv = IdEnv CoreExpr

-- | Type &amp; coercion &amp; id substitution
--   
--   The <a>Subst</a> data type defined in this module contains
--   substitution for tyvar, covar and id. However, operations on
--   IdSubstEnv (mapping from <a>Id</a> to <a>CoreExpr</a>) that require
--   the definition of the <a>Expr</a> data type are defined in
--   GHC.Core.Subst to avoid circular module dependency.
data Subst
Subst :: InScopeSet -> IdSubstEnv -> TvSubstEnv -> CvSubstEnv -> Subst
emptyTvSubstEnv :: TvSubstEnv
emptySubst :: Subst
mkEmptySubst :: InScopeSet -> Subst
mkTCvSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> Subst

-- | Generates the in-scope set for the <a>Subst</a> from the types in the
--   incoming environment. No CoVars or Ids, please!
zipTvSubst :: HasDebugCallStack => [TyVar] -> [Type] -> Subst

-- | Generates the in-scope set for the <tt>TCvSubst</tt> from the types in
--   the incoming environment. No CoVars, please! The InScopeSet is just a
--   thunk so with a bit of luck it'll never be evaluated
mkTvSubstPrs :: [(TyVar, Type)] -> Subst
zipTCvSubst :: HasDebugCallStack => [TyCoVar] -> [Type] -> Subst
notElemSubst :: Var -> Subst -> Bool
getTvSubstEnv :: Subst -> TvSubstEnv

-- | Remove all substitutions that might have been built up while
--   preserving the in-scope set originally called zapSubstEnv
zapSubst :: Subst -> Subst

-- | Find the in-scope set: see Note [The substitution invariant]
getSubstInScope :: Subst -> InScopeSet
setInScope :: Subst -> InScopeSet -> Subst

-- | Returns the free variables of the types in the range of a substitution
--   as a non-deterministic set.
getSubstRangeTyCoFVs :: Subst -> VarSet

-- | Add the <a>Var</a> to the in-scope set
extendSubstInScope :: Subst -> Var -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeList :: Subst -> [Var] -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeSet :: Subst -> VarSet -> Subst
extendTCvSubst :: Subst -> TyCoVar -> Type -> Subst

-- | Add a substitution from a <a>CoVar</a> to a <a>Coercion</a> to the
--   <a>Subst</a>: you must ensure that the in-scope set satisfies Note
--   [The substitution invariant] after extending the substitution like
--   this
extendCvSubst :: Subst -> CoVar -> Coercion -> Subst

-- | Add a substitution for a <a>TyVar</a> to the <a>Subst</a> The
--   <a>TyVar</a> *must* be a real TyVar, and not a CoVar You must ensure
--   that the in-scope set is such that Note [The substitution invariant]
--   holds after extending the substitution like this.
extendTvSubst :: Subst -> TyVar -> Type -> Subst

-- | Adds multiple <a>TyVar</a> substitutions to the <a>Subst</a>: see also
--   <a>extendTvSubst</a>
extendTvSubstList :: Subst -> [(TyVar, Type)] -> Subst
extendTvSubstAndInScope :: Subst -> TyVar -> Type -> Subst
extendTCvSubstList :: Subst -> [Var] -> [Type] -> Subst
extendTvSubstWithClone :: Subst -> TyVar -> TyVar -> Subst
extendTCvSubstWithClone :: Subst -> TyCoVar -> TyCoVar -> Subst
isInScope :: Var -> Subst -> Bool

-- | Composes two substitutions, applying the second one provided first,
--   like in function composition. This function leaves IdSubstEnv
--   untouched because IdSubstEnv is not used during substitution for
--   types.
composeTCvSubst :: Subst -> Subst -> Subst

-- | The InScopeSet is just a thunk so with a bit of luck it'll never be
--   evaluated
zipTyEnv :: HasDebugCallStack => [TyVar] -> [Type] -> TvSubstEnv
zipCoEnv :: HasDebugCallStack => [CoVar] -> [Coercion] -> CvSubstEnv
isEmptySubst :: Subst -> Bool
unionSubst :: Subst -> Subst -> Subst

-- | Checks whether the tyvar and covar environments are empty. This
--   function should be used over <a>isEmptySubst</a> when substituting for
--   types, because types currently do not contain expressions; we can
--   safely disregard the expression environment when deciding whether to
--   skip a substitution. Using <a>isEmptyTCvSubst</a> gives us a
--   non-trivial performance boost (up to 70% less allocation for T18223)
isEmptyTCvSubst :: Subst -> Bool

-- | Substitute within a <a>Type</a> The substitution has to satisfy the
--   invariants described in Note [The substitution invariant].
substTy :: HasDebugCallStack => Subst -> Type -> Type

-- | Substitute within several <a>Type</a>s The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTys :: HasDebugCallStack => Subst -> [Type] -> [Type]
substScaledTy :: HasDebugCallStack => Subst -> Scaled Type -> Scaled Type
substScaledTys :: HasDebugCallStack => Subst -> [Scaled Type] -> [Scaled Type]

-- | Type substitution, see <a>zipTvSubst</a>
substTyWith :: HasDebugCallStack => [TyVar] -> [Type] -> Type -> Type

-- | Type substitution, see <a>zipTvSubst</a>
substTysWith :: HasDebugCallStack => [TyVar] -> [Type] -> [Type] -> [Type]

-- | Substitute within a <a>ThetaType</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTheta :: HasDebugCallStack => Subst -> ThetaType -> ThetaType

-- | Substitute within a <a>Type</a> after adding the free variables of the
--   type to the in-scope set. This is useful for the case when the free
--   variables aren't already in the in-scope set or easily available. See
--   also Note [The substitution invariant].
substTyAddInScope :: HasDebugCallStack => Subst -> Type -> Type

-- | Substitute within a <a>Type</a> disabling the sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyUnchecked :: Subst -> Type -> Type

-- | Substitute within several <a>Type</a>s disabling the sanity checks.
--   The problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substTysUnchecked to substTys and remove this
--   function. Please don't use in new code.
substTysUnchecked :: Subst -> [Type] -> [Type]
substScaledTyUnchecked :: HasDebugCallStack => Subst -> Scaled Type -> Scaled Type
substScaledTysUnchecked :: Subst -> [Scaled Type] -> [Scaled Type]

-- | Substitute within a <a>ThetaType</a> disabling the sanity checks. The
--   problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substThetaUnchecked to substTheta and remove this
--   function. Please don't use in new code.
substThetaUnchecked :: Subst -> ThetaType -> ThetaType

-- | Type substitution, see <a>zipTvSubst</a>. Disables sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyWithUnchecked :: [TyVar] -> [Type] -> Type -> Type

-- | Substitute within a <a>Coercion</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substCo :: HasDebugCallStack => Subst -> Coercion -> Coercion

-- | Substitute within a <a>Coercion</a> disabling sanity checks. The
--   problems that the sanity checks in substCo catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substCoUnchecked to substCo and remove this function. Please
--   don't use in new code.
substCoUnchecked :: Subst -> Coercion -> Coercion

-- | Coercion substitution, see <a>zipTvSubst</a>. Disables sanity checks.
--   The problems that the sanity checks in substCo catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substCoUnchecked to substCo and remove this function.
--   Please don't use in new code.
substCoWithUnchecked :: [TyVar] -> [Type] -> Coercion -> Coercion
substTyVarBndr :: HasDebugCallStack => Subst -> TyVar -> (Subst, TyVar)
substTyVarBndrs :: HasDebugCallStack => Subst -> [TyVar] -> (Subst, [TyVar])
substTyVar :: Subst -> TyVar -> Type
substTyVars :: Subst -> [TyVar] -> [Type]
substVarBndr :: HasDebugCallStack => Subst -> TyCoVar -> (Subst, TyCoVar)
substVarBndrs :: HasDebugCallStack => Subst -> [TyCoVar] -> (Subst, [TyCoVar])
substTyCoBndr :: Subst -> PiTyBinder -> (Subst, PiTyBinder)
substTyVarToTyVar :: HasDebugCallStack => Subst -> TyVar -> TyVar
cloneTyVarBndr :: Subst -> TyVar -> Unique -> (Subst, TyVar)
cloneTyVarBndrs :: Subst -> [TyVar] -> UniqSupply -> (Subst, [TyVar])
lookupTyVar :: Subst -> TyVar -> Maybe Type

-- | Tidy a Type
--   
--   See Note [Strictness in tidyType and friends]
tidyType :: TidyEnv -> Type -> Type

-- | Tidy a list of Types
--   
--   See Note [Strictness in tidyType and friends]
tidyTypes :: TidyEnv -> [Type] -> [Type]
tidyOpenType :: TidyEnv -> Type -> Type
tidyOpenTypes :: TidyEnv -> [Type] -> [Type]
tidyOpenTypeX :: TidyEnv -> Type -> (TidyEnv, Type)

-- | Grabs the free type variables, tidies them and then uses
--   <a>tidyType</a> to work over the type itself
tidyOpenTypesX :: TidyEnv -> [Type] -> (TidyEnv, [Type])
tidyVarBndr :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)

-- | This tidies up a type for printing in an error message, or in an
--   interface file.
--   
--   It doesn't change the uniques at all, just the print names.
tidyVarBndrs :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])

-- | Add the free <a>TyVar</a>s to the env in tidy form, so that we can
--   tidy the type they are free in Precondition: input free vars are
--   closed over kinds and This function does a scopedSort, so that tidied
--   variables have tidied kinds. See Note [Tidying is idempotent]
tidyFreeTyCoVars :: TidyEnv -> [TyCoVar] -> TidyEnv

-- | Treat a new <a>TyCoVar</a> as a binder, and give it a fresh tidy name
--   using the environment if one has not already been allocated. See also
--   <a>tidyVarBndr</a> See Note [Tidying is idempotent]
tidyFreeTyCoVarX :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)
tidyFreeTyCoVarsX :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])
tidyTyCoVarOcc :: TidyEnv -> TyCoVar -> TyCoVar

-- | Calls <a>tidyType</a> on a top-level type (i.e. with an empty tidying
--   environment)
tidyTopType :: Type -> Type
tidyForAllTyBinder :: TidyEnv -> VarBndr TyCoVar vis -> (TidyEnv, VarBndr TyCoVar vis)
tidyForAllTyBinders :: TidyEnv -> [VarBndr TyCoVar vis] -> (TidyEnv, [VarBndr TyCoVar vis])

-- | Does this classify a type allowed to have values? Responds True to
--   things like *, TYPE Lifted, TYPE IntRep, TYPE v, Constraint.
--   
--   True of a kind `TYPE _` or `CONSTRAINT _`
isTYPEorCONSTRAINT :: Kind -> Bool

-- | Tests whether the given type is concrete, i.e. it whether it consists
--   only of concrete type constructors, concrete type variables, and
--   applications.
--   
--   See Note [Concrete types] in GHC.Tc.Utils.Concrete.
isConcreteType :: Type -> Bool

-- | Checks that a kind of the form <a>Type</a>, <tt>Constraint</tt> or
--   <tt>'TYPE r</tt> is concrete. See <a>isConcreteType</a>.
--   
--   <b>Precondition:</b> The type has kind `TYPE blah` or `CONSTRAINT
--   blah`
isFixedRuntimeRepKind :: HasDebugCallStack => Kind -> Bool


-- | Source-language literals
module Language.Haskell.Syntax.Lit

-- | Haskell Literal
data HsLit x

-- | Character
HsChar :: XHsChar x -> Char -> HsLit x

-- | Unboxed character
HsCharPrim :: XHsCharPrim x -> Char -> HsLit x

-- | String
HsString :: XHsString x -> FastString -> HsLit x

-- | String
HsMultilineString :: XHsMultilineString x -> FastString -> HsLit x

-- | Packed bytes
HsStringPrim :: XHsStringPrim x -> !ByteString -> HsLit x

-- | Genuinely an Int; arises from <a>GHC.Tc.Deriv.Generate</a>, and from
--   TRANSLATION
HsInt :: XHsInt x -> IntegralLit -> HsLit x

-- | literal <tt>Int#</tt>
HsIntPrim :: XHsIntPrim x -> Integer -> HsLit x

-- | literal <tt>Word#</tt>
HsWordPrim :: XHsWordPrim x -> Integer -> HsLit x

-- | literal <tt>Int8#</tt>
HsInt8Prim :: XHsInt8Prim x -> Integer -> HsLit x

-- | literal <tt>Int16#</tt>
HsInt16Prim :: XHsInt16Prim x -> Integer -> HsLit x

-- | literal <tt>Int32#</tt>
HsInt32Prim :: XHsInt32Prim x -> Integer -> HsLit x

-- | literal <tt>Int64#</tt>
HsInt64Prim :: XHsInt64Prim x -> Integer -> HsLit x

-- | literal <tt>Word8#</tt>
HsWord8Prim :: XHsWord8Prim x -> Integer -> HsLit x

-- | literal <tt>Word16#</tt>
HsWord16Prim :: XHsWord16Prim x -> Integer -> HsLit x

-- | literal <tt>Word32#</tt>
HsWord32Prim :: XHsWord32Prim x -> Integer -> HsLit x

-- | literal <tt>Word64#</tt>
HsWord64Prim :: XHsWord64Prim x -> Integer -> HsLit x

-- | Genuinely an integer; arises only from TRANSLATION (overloaded
--   literals are done with HsOverLit)
HsInteger :: XHsInteger x -> Integer -> Type -> HsLit x

-- | Genuinely a rational; arises only from TRANSLATION (overloaded
--   literals are done with HsOverLit)
HsRat :: XHsRat x -> FractionalLit -> Type -> HsLit x

-- | Unboxed Float
HsFloatPrim :: XHsFloatPrim x -> FractionalLit -> HsLit x

-- | Unboxed Double
HsDoublePrim :: XHsDoublePrim x -> FractionalLit -> HsLit x
XLit :: !XXLit x -> HsLit x

-- | Haskell Overloaded Literal
data HsOverLit p
OverLit :: XOverLit p -> OverLitVal -> HsOverLit p
[ol_ext] :: HsOverLit p -> XOverLit p
[ol_val] :: HsOverLit p -> OverLitVal
XOverLit :: !XXOverLit p -> HsOverLit p

-- | Overloaded Literal Value
data OverLitVal

-- | Integer-looking literals;
HsIntegral :: !IntegralLit -> OverLitVal

-- | Frac-looking literals
HsFractional :: !FractionalLit -> OverLitVal

-- | String-looking literals
HsIsString :: !SourceText -> !FastString -> OverLitVal
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Lit.OverLitVal
instance GHC.Classes.Eq (Language.Haskell.Syntax.Lit.HsLit x)
instance GHC.Classes.Eq Language.Haskell.Syntax.Lit.OverLitVal
instance GHC.Classes.Ord Language.Haskell.Syntax.Lit.OverLitVal

module Language.Haskell.Syntax.Pat

-- | Pattern
data Pat p

-- | Wildcard Pattern, i.e. <tt>_</tt>
WildPat :: XWildPat p -> Pat p

-- | Variable Pattern, e.g. <tt>x</tt>
VarPat :: XVarPat p -> LIdP p -> Pat p

-- | Lazy Pattern, e.g. <tt>~x</tt>
LazyPat :: XLazyPat p -> LPat p -> Pat p

-- | As pattern, e.g. <tt>x@pat</tt>
AsPat :: XAsPat p -> LIdP p -> LPat p -> Pat p

-- | Parenthesised pattern, e.g. <tt>(x)</tt>
ParPat :: XParPat p -> LPat p -> Pat p

-- | Bang pattern, e.g. <tt>!x</tt>
BangPat :: XBangPat p -> LPat p -> Pat p

-- | Syntactic List, e.g. <tt>[x]</tt> or <tt>[x,y]</tt>. Note that
--   <tt>[]</tt> and <tt>(x:xs)</tt> patterns are both represented using
--   <a>ConPat</a>.
ListPat :: XListPat p -> [LPat p] -> Pat p

-- | Tuple pattern, e.g. <tt>(x, y)</tt> (boxed tuples) or <tt>(# x, y
--   #)</tt> (requires <tt>-XUnboxedTuples</tt>)
TuplePat :: XTuplePat p -> [LPat p] -> Boxity -> Pat p

-- | Or Pattern, e.g. <tt>(pat_1; ...; pat_n)</tt>. Used by
--   <tt>-XOrPatterns</tt>
OrPat :: XOrPat p -> NonEmpty (LPat p) -> Pat p

-- | Anonymous sum pattern, e.g. <tt>(# x | #)</tt>. Used by
--   <tt>-XUnboxedSums</tt>
SumPat :: XSumPat p -> LPat p -> ConTag -> SumWidth -> Pat p

-- | Constructor Pattern, e.g. <tt>()</tt>, <tt>[]</tt> or <tt>Nothing</tt>
ConPat :: XConPat p -> XRec p (ConLikeP p) -> HsConPatDetails p -> Pat p
[pat_con_ext] :: Pat p -> XConPat p
[pat_con] :: Pat p -> XRec p (ConLikeP p)
[pat_args] :: Pat p -> HsConPatDetails p

-- | View Pattern, e.g. <tt>someFun -&gt; pat</tt>. Used by
--   <tt>-XViewPatterns</tt>
ViewPat :: XViewPat p -> LHsExpr p -> LPat p -> Pat p

-- | Splice Pattern, e.g. <tt>$(pat)</tt>
SplicePat :: XSplicePat p -> HsUntypedSplice p -> Pat p

-- | Literal Pattern
--   
--   Used for <b>non-overloaded</b> literal patterns: Int#, Char#, Int,
--   Char, String, etc.
LitPat :: XLitPat p -> HsLit p -> Pat p

-- | Natural Pattern, used for all overloaded literals, including
--   overloaded Strings with <tt>-XOverloadedStrings</tt>
NPat :: XNPat p -> XRec p (HsOverLit p) -> Maybe (SyntaxExpr p) -> SyntaxExpr p -> Pat p

-- | n+k pattern, e.g. <tt>n+1</tt>, used by <tt>-XNPlusKPatterns</tt>
NPlusKPat :: XNPlusKPat p -> LIdP p -> XRec p (HsOverLit p) -> HsOverLit p -> SyntaxExpr p -> SyntaxExpr p -> Pat p

-- | Pattern with a type signature, e.g. <tt>x :: Int</tt>
SigPat :: XSigPat p -> LPat p -> HsPatSigType (NoGhcTc p) -> Pat p

-- | Embed the syntax of types into patterns, e.g. <tt>fn (type t) =
--   rhs</tt>. Enabled by <tt>-XExplicitNamespaces</tt> in conjunction with
--   <tt>-XRequiredTypeArguments</tt>.
EmbTyPat :: XEmbTyPat p -> HsTyPat (NoGhcTc p) -> Pat p

-- | Type abstraction which brings into scope type variables associated
--   with invisible forall. E.g. <tt>fn @t ... = rhs</tt>. Used by
--   <tt>-XTypeAbstractions</tt>.
InvisPat :: XInvisPat p -> HsTyPat (NoGhcTc p) -> Pat p

-- | TTG Extension point; see Note [Trees That Grow] in
--   Language.Haskell.Syntax.Extension
XPat :: !XXPat p -> Pat p
type LPat p = XRec p Pat p
type family ConLikeP x
isInvisArgPat :: Pat p -> Bool
isVisArgPat :: Pat p -> Bool

-- | Haskell Constructor Pattern Details
type HsConPatDetails p = HsConDetails HsConPatTyArg NoGhcTc p LPat p HsRecFields p LPat p
hsConPatArgs :: UnXRec p => HsConPatDetails p -> [LPat p]
hsConPatTyArgs :: HsConPatDetails p -> [HsConPatTyArg (NoGhcTc p)]

-- | Type argument in a data constructor pattern, e.g. the <tt>@a</tt> in
--   <tt>f (Just @a x) = ...</tt>.
data HsConPatTyArg p
HsConPatTyArg :: !XConPatTyArg p -> HsTyPat p -> HsConPatTyArg p
type family XConPatTyArg p

-- | Haskell Record Fields
--   
--   HsRecFields is used only for patterns and expressions (not data type
--   declarations)
data HsRecFields p arg
HsRecFields :: !XHsRecFields p -> [LHsRecField p arg] -> Maybe (XRec p RecFieldsDotDot) -> HsRecFields p arg
[rec_ext] :: HsRecFields p arg -> !XHsRecFields p
[rec_flds] :: HsRecFields p arg -> [LHsRecField p arg]
[rec_dotdot] :: HsRecFields p arg -> Maybe (XRec p RecFieldsDotDot)
type family XHsRecFields p

-- | Haskell Field Binding
data HsFieldBind lhs rhs
HsFieldBind :: XHsFieldBind lhs -> lhs -> rhs -> Bool -> HsFieldBind lhs rhs
[hfbAnn] :: HsFieldBind lhs rhs -> XHsFieldBind lhs
[hfbLHS] :: HsFieldBind lhs rhs -> lhs

-- | Filled in by renamer when punning
[hfbRHS] :: HsFieldBind lhs rhs -> rhs

-- | Note [Punning]
[hfbPun] :: HsFieldBind lhs rhs -> Bool

-- | Located Haskell Record Field
type LHsFieldBind p id arg = XRec p HsFieldBind id arg

-- | Haskell Record Field
type HsRecField p arg = HsFieldBind LFieldOcc p arg

-- | Located Haskell Record Field
type LHsRecField p arg = XRec p HsRecField p arg

-- | Haskell Record Update Field
type HsRecUpdField p q = HsFieldBind LFieldOcc p LHsExpr q

-- | Located Haskell Record Update Field
type LHsRecUpdField p q = XRec p HsRecUpdField p q

-- | Newtype to be able to have a specific XRec instance for the Int in
--   <a>rec_dotdot</a>
newtype RecFieldsDotDot
RecFieldsDotDot :: Int -> RecFieldsDotDot
[unRecFieldsDotDot] :: RecFieldsDotDot -> Int
hsRecFields :: UnXRec p => HsRecFields p arg -> [IdP p]
hsRecFieldSel :: UnXRec p => HsRecField p arg -> IdP p
hsRecFieldsArgs :: UnXRec p => HsRecFields p arg -> [arg]
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Pat.RecFieldsDotDot
instance GHC.Classes.Eq Language.Haskell.Syntax.Pat.RecFieldsDotDot
instance GHC.Internal.Data.Foldable.Foldable (Language.Haskell.Syntax.Pat.HsFieldBind lhs)
instance GHC.Internal.Base.Functor (Language.Haskell.Syntax.Pat.HsFieldBind lhs)
instance GHC.Classes.Ord Language.Haskell.Syntax.Pat.RecFieldsDotDot
instance GHC.Internal.Data.Traversable.Traversable (Language.Haskell.Syntax.Pat.HsFieldBind lhs)


-- | Abstract Haskell syntax for expressions.
module Language.Haskell.Syntax.Expr

-- | RecordDotSyntax field updates
type LFieldLabelStrings p = XRec p FieldLabelStrings p
newtype FieldLabelStrings p
FieldLabelStrings :: [XRec p (DotFieldOcc p)] -> FieldLabelStrings p
type RecProj p arg = HsFieldBind LFieldLabelStrings p arg
type LHsRecProj p arg = XRec p RecProj p arg
type RecUpdProj p = RecProj p LHsExpr p
type LHsRecUpdProj p = XRec p RecUpdProj p

-- | Haskell Record Update Fields.
data LHsRecUpdFields p

-- | A regular (non-overloaded) record update.
[RegularRecUpdFields] :: forall p. XLHsRecUpdLabels p -> [LHsRecUpdField p p] -> LHsRecUpdFields p

-- | An overloaded record update.
[OverloadedRecUpdFields] :: forall p. XLHsOLRecUpdLabels p -> [LHsRecUpdProj p] -> LHsRecUpdFields p

-- | Located Haskell Expression
type LHsExpr p = XRec p HsExpr p

-- | Syntax Expression
--   
--   SyntaxExpr is represents the function used in interpreting rebindable
--   syntax. In the parser, we have no information to supply; in the
--   renamer, we have the name of the function (but see Note [Monad fail :
--   Rebindable syntax, overloaded strings] for a wrinkle) and in the
--   type-checker we have a more elaborate structure <tt>SyntaxExprTc</tt>.
--   
--   In some contexts, rebindable syntax is not implemented, and so we have
--   constructors to represent that possibility in both the renamer and
--   typechecker instantiations.
--   
--   E.g. <tt>(&gt;&gt;=)</tt> is filled in before the renamer by the
--   appropriate <tt>Name</tt> for <tt>(&gt;&gt;=)</tt>, and then
--   instantiated by the type checker with its type args etc
type family SyntaxExpr p

-- | A Haskell expression.
data HsExpr p

-- | Variable See Note [Located RdrNames]
HsVar :: XVar p -> LIdP p -> HsExpr p

-- | Unbound variable; also used for "holes" (_ or _x). Turned from HsVar
--   to HsUnboundVar by the renamer, when it finds an out-of-scope variable
--   or hole. The (XUnboundVar p) field becomes an HoleExprRef after
--   typechecking; this is where the erroring expression will be written
--   after solving. See Note [Holes] in GHC.Tc.Types.Constraint.
HsUnboundVar :: XUnboundVar p -> RdrName -> HsExpr p

-- | Overloaded label (Note [Overloaded labels] in GHC.OverloadedLabels)
HsOverLabel :: XOverLabel p -> FastString -> HsExpr p

-- | Implicit parameter (not in use after typechecking)
HsIPVar :: XIPVar p -> HsIPName -> HsExpr p

-- | Overloaded literals
HsOverLit :: XOverLitE p -> HsOverLit p -> HsExpr p

-- | Simple (non-overloaded) literals
HsLit :: XLitE p -> HsLit p -> HsExpr p

-- | Lambda, Lambda-case, and Lambda-cases
HsLam :: XLam p -> HsLamVariant -> MatchGroup p (LHsExpr p) -> HsExpr p

-- | Application
HsApp :: XApp p -> LHsExpr p -> LHsExpr p -> HsExpr p

-- | Visible type application
--   
--   Explicit type argument; e.g f @Int x y NB: Has wildcards, but no
--   implicit quantification
HsAppType :: XAppTypeE p -> LHsExpr p -> LHsWcType (NoGhcTc p) -> HsExpr p

-- | Operator applications: NB Bracketed ops such as (+) come out as Vars.
OpApp :: XOpApp p -> LHsExpr p -> LHsExpr p -> LHsExpr p -> HsExpr p

-- | Negation operator. Contains the negated expression and the name of
--   <tt>negate</tt>
NegApp :: XNegApp p -> LHsExpr p -> SyntaxExpr p -> HsExpr p

-- | Parenthesised expr; see Note [Parens in HsSyn]
HsPar :: XPar p -> LHsExpr p -> HsExpr p
SectionL :: XSectionL p -> LHsExpr p -> LHsExpr p -> HsExpr p
SectionR :: XSectionR p -> LHsExpr p -> LHsExpr p -> HsExpr p

-- | Used for explicit tuples and sections thereof
ExplicitTuple :: XExplicitTuple p -> [HsTupArg p] -> Boxity -> HsExpr p

-- | Used for unboxed sum types
ExplicitSum :: XExplicitSum p -> ConTag -> SumWidth -> LHsExpr p -> HsExpr p
HsCase :: XCase p -> LHsExpr p -> MatchGroup p (LHsExpr p) -> HsExpr p
HsIf :: XIf p -> LHsExpr p -> LHsExpr p -> LHsExpr p -> HsExpr p

-- | Multi-way if
HsMultiIf :: XMultiIf p -> [LGRHS p (LHsExpr p)] -> HsExpr p

-- | let(rec)
HsLet :: XLet p -> HsLocalBinds p -> LHsExpr p -> HsExpr p
HsDo :: XDo p -> HsDoFlavour -> XRec p [ExprLStmt p] -> HsExpr p

-- | Syntactic list: [a,b,c,...]
ExplicitList :: XExplicitList p -> [LHsExpr p] -> HsExpr p

-- | Record construction
RecordCon :: XRecordCon p -> XRec p (ConLikeP p) -> HsRecordBinds p -> HsExpr p
[rcon_ext] :: HsExpr p -> XRecordCon p
[rcon_con] :: HsExpr p -> XRec p (ConLikeP p)
[rcon_flds] :: HsExpr p -> HsRecordBinds p

-- | Record update
RecordUpd :: XRecordUpd p -> LHsExpr p -> LHsRecUpdFields p -> HsExpr p
[rupd_ext] :: HsExpr p -> XRecordUpd p
[rupd_expr] :: HsExpr p -> LHsExpr p
[rupd_flds] :: HsExpr p -> LHsRecUpdFields p

-- | Record field selection e.g <tt>z.x</tt>.
HsGetField :: XGetField p -> LHsExpr p -> XRec p (DotFieldOcc p) -> HsExpr p
[gf_ext] :: HsExpr p -> XGetField p
[gf_expr] :: HsExpr p -> LHsExpr p
[gf_field] :: HsExpr p -> XRec p (DotFieldOcc p)

-- | Record field selector. e.g. <tt>(.x)</tt> or <tt>(.x.y)</tt>
--   
--   This case only arises when the OverloadedRecordDot langauge extensions
--   is enabled. See Note [Record selectors in the AST].
HsProjection :: XProjection p -> NonEmpty (DotFieldOcc p) -> HsExpr p
[proj_ext] :: HsExpr p -> XProjection p
[proj_flds] :: HsExpr p -> NonEmpty (DotFieldOcc p)

-- | Expression with an explicit type signature. <tt>e :: type</tt>
ExprWithTySig :: XExprWithTySig p -> LHsExpr p -> LHsSigWcType (NoGhcTc p) -> HsExpr p

-- | Arithmetic sequence
ArithSeq :: XArithSeq p -> Maybe (SyntaxExpr p) -> ArithSeqInfo p -> HsExpr p
HsTypedBracket :: XTypedBracket p -> LHsExpr p -> HsExpr p
HsUntypedBracket :: XUntypedBracket p -> HsQuote p -> HsExpr p
HsTypedSplice :: XTypedSplice p -> LHsExpr p -> HsExpr p
HsUntypedSplice :: XUntypedSplice p -> HsUntypedSplice p -> HsExpr p

-- | <tt>proc</tt> notation for Arrows
HsProc :: XProc p -> LPat p -> LHsCmdTop p -> HsExpr p
HsStatic :: XStatic p -> LHsExpr p -> HsExpr p
HsPragE :: XPragE p -> HsPragE p -> LHsExpr p -> HsExpr p
HsEmbTy :: XEmbTy p -> LHsWcType (NoGhcTc p) -> HsExpr p

-- | Forall-types <tt>forall tvs. t</tt> and <tt>forall tvs -&gt; t</tt>.
--   Used with <tt>RequiredTypeArguments</tt>, e.g. <tt>fn (forall a. Proxy
--   a)</tt>. See Note [Types in terms]
HsForAll :: XForAll p -> HsForAllTelescope p -> LHsExpr p -> HsExpr p
HsQual :: XQual p -> XRec p [LHsExpr p] -> LHsExpr p -> HsExpr p

-- | Function types <tt>a -&gt; b</tt>. Used with
--   <tt>RequiredTypeArguments</tt>, e.g. <tt>fn (Int -&gt; Bool)</tt>. See
--   Note [Types in terms]
HsFunArr :: XFunArr p -> HsArrowOf (LHsExpr p) p -> LHsExpr p -> LHsExpr p -> HsExpr p
XExpr :: !XXExpr p -> HsExpr p
data DotFieldOcc p
DotFieldOcc :: XCDotFieldOcc p -> XRec p FieldLabelString -> DotFieldOcc p
[dfoExt] :: DotFieldOcc p -> XCDotFieldOcc p
[dfoLabel] :: DotFieldOcc p -> XRec p FieldLabelString
XDotFieldOcc :: !XXDotFieldOcc p -> DotFieldOcc p

-- | A pragma, written as {-# ... #-}, that may appear within an
--   expression.
data HsPragE p
HsPragSCC :: XSCC p -> StringLiteral -> HsPragE p
XHsPragE :: !XXPragE p -> HsPragE p

-- | Located Haskell Tuple Argument
--   
--   <a>HsTupArg</a> is used for tuple sections <tt>(,a,)</tt> is
--   represented by <tt>ExplicitTuple [Missing ty1, Present a, Missing
--   ty3]</tt> Which in turn stands for <tt>(x:ty1 y:ty2. (x,a,y))</tt>
type LHsTupArg id = XRec id HsTupArg id

-- | Haskell Tuple Argument
data HsTupArg id

-- | The argument
Present :: XPresent id -> LHsExpr id -> HsTupArg id

-- | The argument is missing, but this is its type
Missing :: XMissing id -> HsTupArg id

-- | Extension point; see Note [Trees That Grow] in
--   Language.Haskell.Syntax.Extension
XTupArg :: !XXTupArg id -> HsTupArg id

-- | Which kind of lambda case are we dealing with?
data HsLamVariant

-- | `p -&gt; e`
LamSingle :: HsLamVariant

-- | `case pi -&gt; ei `
LamCase :: HsLamVariant

-- | `cases psi -&gt; ei`
LamCases :: HsLamVariant

-- | Located Haskell Command (for arrow syntax)
type LHsCmd id = XRec id HsCmd id

-- | Haskell Command (e.g. a "statement" in an Arrow proc block)
data HsCmd id
HsCmdArrApp :: XCmdArrApp id -> LHsExpr id -> LHsExpr id -> HsArrAppType -> Bool -> HsCmd id
HsCmdArrForm :: XCmdArrForm id -> LHsExpr id -> LexicalFixity -> [LHsCmdTop id] -> HsCmd id
HsCmdApp :: XCmdApp id -> LHsCmd id -> LHsExpr id -> HsCmd id

-- | Lambda-case
HsCmdLam :: XCmdLamCase id -> HsLamVariant -> MatchGroup id (LHsCmd id) -> HsCmd id
HsCmdPar :: XCmdPar id -> LHsCmd id -> HsCmd id
HsCmdCase :: XCmdCase id -> LHsExpr id -> MatchGroup id (LHsCmd id) -> HsCmd id
HsCmdIf :: XCmdIf id -> SyntaxExpr id -> LHsExpr id -> LHsCmd id -> LHsCmd id -> HsCmd id
HsCmdLet :: XCmdLet id -> HsLocalBinds id -> LHsCmd id -> HsCmd id
HsCmdDo :: XCmdDo id -> XRec id [CmdLStmt id] -> HsCmd id
XCmd :: !XXCmd id -> HsCmd id

-- | Haskell arrow application type.
data HsArrAppType

-- | First order arrow application <tt>-&lt;</tt>
HsHigherOrderApp :: HsArrAppType

-- | Higher order arrow application <tt>-&lt;&lt;</tt>
HsFirstOrderApp :: HsArrAppType

-- | Top-level command, introducing a new arrow. This may occur inside a
--   proc (where the stack is empty) or as an argument of a command-forming
--   operator.
--   
--   Located Haskell Top-level Command
type LHsCmdTop p = XRec p HsCmdTop p

-- | Haskell Top-level Command
data HsCmdTop p
HsCmdTop :: XCmdTop p -> LHsCmd p -> HsCmdTop p
XCmdTop :: !XXCmdTop p -> HsCmdTop p

-- | Haskell Record Bindings
type HsRecordBinds p = HsRecFields p LHsExpr p
data MatchGroup p body
MG :: XMG p body -> XRec p [LMatch p body] -> MatchGroup p body
[mg_ext] :: MatchGroup p body -> XMG p body
[mg_alts] :: MatchGroup p body -> XRec p [LMatch p body]
XMatchGroup :: !XXMatchGroup p body -> MatchGroup p body

-- | Located Match
type LMatch id body = XRec id Match id body
data Match p body
Match :: XCMatch p body -> HsMatchContext (LIdP (NoGhcTc p)) -> XRec p [LPat p] -> GRHSs p body -> Match p body
[m_ext] :: Match p body -> XCMatch p body
[m_ctxt] :: Match p body -> HsMatchContext (LIdP (NoGhcTc p))
[m_pats] :: Match p body -> XRec p [LPat p]
[m_grhss] :: Match p body -> GRHSs p body
XMatch :: !XXMatch p body -> Match p body
isInfixMatch :: Match id body -> Bool

-- | Guarded Right-Hand Sides
--   
--   GRHSs are used both for pattern bindings and for Matches
data GRHSs p body
GRHSs :: XCGRHSs p body -> [LGRHS p body] -> HsLocalBinds p -> GRHSs p body
[grhssExt] :: GRHSs p body -> XCGRHSs p body

-- | Guarded RHSs
[grhssGRHSs] :: GRHSs p body -> [LGRHS p body]

-- | The where clause
[grhssLocalBinds] :: GRHSs p body -> HsLocalBinds p
XGRHSs :: !XXGRHSs p body -> GRHSs p body

-- | Located Guarded Right-Hand Side
type LGRHS id body = XRec id GRHS id body

-- | Guarded Right Hand Side.
data GRHS p body
GRHS :: XCGRHS p body -> [GuardLStmt p] -> body -> GRHS p body
XGRHS :: !XXGRHS p body -> GRHS p body

-- | Located <tt>do</tt> block Statement
type LStmt id body = XRec id StmtLR id id body

-- | Located Statement with separate Left and Right id's
type LStmtLR idL idR body = XRec idL StmtLR idL idR body

-- | <tt>do</tt> block Statement
type Stmt id body = StmtLR id id body

-- | Command Located Statement
type CmdLStmt id = LStmt id LHsCmd id

-- | Command Statement
type CmdStmt id = Stmt id LHsCmd id

-- | Expression Located Statement
type ExprLStmt id = LStmt id LHsExpr id

-- | Expression Statement
type ExprStmt id = Stmt id LHsExpr id

-- | Guard Located Statement
type GuardLStmt id = LStmt id LHsExpr id

-- | Guard Statement
type GuardStmt id = Stmt id LHsExpr id

-- | Ghci Located Statement
type GhciLStmt id = LStmt id LHsExpr id

-- | Ghci Statement
type GhciStmt id = Stmt id LHsExpr id
data StmtLR idL idR body
LastStmt :: XLastStmt idL idR body -> body -> Maybe Bool -> SyntaxExpr idR -> StmtLR idL idR body
BindStmt :: XBindStmt idL idR body -> LPat idL -> body -> StmtLR idL idR body
BodyStmt :: XBodyStmt idL idR body -> body -> SyntaxExpr idR -> SyntaxExpr idR -> StmtLR idL idR body
LetStmt :: XLetStmt idL idR body -> HsLocalBindsLR idL idR -> StmtLR idL idR body
ParStmt :: XParStmt idL idR body -> [ParStmtBlock idL idR] -> HsExpr idR -> SyntaxExpr idR -> StmtLR idL idR body
TransStmt :: XTransStmt idL idR body -> TransForm -> [ExprLStmt idL] -> [(IdP idR, IdP idR)] -> LHsExpr idR -> Maybe (LHsExpr idR) -> SyntaxExpr idR -> SyntaxExpr idR -> HsExpr idR -> StmtLR idL idR body
[trS_ext] :: StmtLR idL idR body -> XTransStmt idL idR body
[trS_form] :: StmtLR idL idR body -> TransForm
[trS_stmts] :: StmtLR idL idR body -> [ExprLStmt idL]
[trS_bndrs] :: StmtLR idL idR body -> [(IdP idR, IdP idR)]
[trS_using] :: StmtLR idL idR body -> LHsExpr idR
[trS_by] :: StmtLR idL idR body -> Maybe (LHsExpr idR)
[trS_ret] :: StmtLR idL idR body -> SyntaxExpr idR
[trS_bind] :: StmtLR idL idR body -> SyntaxExpr idR
[trS_fmap] :: StmtLR idL idR body -> HsExpr idR
RecStmt :: XRecStmt idL idR body -> XRec idR [LStmtLR idL idR body] -> [IdP idR] -> [IdP idR] -> SyntaxExpr idR -> SyntaxExpr idR -> SyntaxExpr idR -> StmtLR idL idR body
[recS_ext] :: StmtLR idL idR body -> XRecStmt idL idR body
[recS_stmts] :: StmtLR idL idR body -> XRec idR [LStmtLR idL idR body]
[recS_later_ids] :: StmtLR idL idR body -> [IdP idR]
[recS_rec_ids] :: StmtLR idL idR body -> [IdP idR]
[recS_bind_fn] :: StmtLR idL idR body -> SyntaxExpr idR
[recS_ret_fn] :: StmtLR idL idR body -> SyntaxExpr idR
[recS_mfix_fn] :: StmtLR idL idR body -> SyntaxExpr idR
XStmtLR :: !XXStmtLR idL idR body -> StmtLR idL idR body
data TransForm
ThenForm :: TransForm
GroupForm :: TransForm

-- | Parenthesised Statement Block
data ParStmtBlock idL idR
ParStmtBlock :: XParStmtBlock idL idR -> [ExprLStmt idL] -> [IdP idR] -> SyntaxExpr idR -> ParStmtBlock idL idR
XParStmtBlock :: !XXParStmtBlock idL idR -> ParStmtBlock idL idR

-- | The fail operator
--   
--   This is used for `.. &lt;-` "bind statements" in do notation,
--   including non-monadic "binds" in applicative.
--   
--   The fail operator is 'Just expr' if it potentially fail monadically.
--   if the pattern match cannot fail, or shouldn't fail monadically
--   (regular incomplete pattern exception), it is <a>Nothing</a>.
--   
--   See Note [Monad fail : Rebindable syntax, overloaded strings] for the
--   type of expression in the <a>Just</a> case, and why it is so.
--   
--   See Note [Failing pattern matches in Stmts] for which contexts for
--   '<tt>BindStmt</tt>'s should use the monadic fail and which shouldn't.
type FailOperator id = Maybe SyntaxExpr id

-- | Haskell Splice
data HsUntypedSplice id
HsUntypedSpliceExpr :: XUntypedSpliceExpr id -> LHsExpr id -> HsUntypedSplice id
HsQuasiQuote :: XQuasiQuote id -> IdP id -> XRec id FastString -> HsUntypedSplice id
XUntypedSplice :: !XXUntypedSplice id -> HsUntypedSplice id

-- | Haskell (Untyped) Quote = Expr + Pat + Type + Var
data HsQuote p
ExpBr :: XExpBr p -> LHsExpr p -> HsQuote p
PatBr :: XPatBr p -> LPat p -> HsQuote p
DecBrL :: XDecBrL p -> [LHsDecl p] -> HsQuote p
DecBrG :: XDecBrG p -> HsGroup p -> HsQuote p
TypBr :: XTypBr p -> LHsType p -> HsQuote p
VarBr :: XVarBr p -> Bool -> LIdP p -> HsQuote p
XQuote :: !XXQuote p -> HsQuote p

-- | Arithmetic Sequence Information
data ArithSeqInfo id
From :: LHsExpr id -> ArithSeqInfo id
FromThen :: LHsExpr id -> LHsExpr id -> ArithSeqInfo id
FromTo :: LHsExpr id -> LHsExpr id -> ArithSeqInfo id
FromThenTo :: LHsExpr id -> LHsExpr id -> LHsExpr id -> ArithSeqInfo id

-- | Haskell Match Context
--   
--   Context of a pattern match. This is more subtle than it would seem.
--   See Note [FunBind vs PatBind].
data HsMatchContext fn

-- | A pattern matching on an argument of a function binding
FunRhs :: fn -> LexicalFixity -> SrcStrictness -> XFunRhs -> HsMatchContext fn

-- | function binder of <tt>f</tt> See Note [mc_fun field of FunRhs] See
--   #20415 for a long discussion about this field
[mc_fun] :: HsMatchContext fn -> fn

-- | fixing of <tt>f</tt>
[mc_fixity] :: HsMatchContext fn -> LexicalFixity

-- | was <tt>f</tt> banged? See Note [FunBind vs PatBind]
[mc_strictness] :: HsMatchContext fn -> SrcStrictness
[mc_an] :: HsMatchContext fn -> XFunRhs

-- | Patterns and guards in a case alternative
CaseAlt :: HsMatchContext fn

-- | Patterns and guards in <tt>@, </tt>case<tt> and </tt>cases@
LamAlt :: HsLamVariant -> HsMatchContext fn

-- | Guards of a multi-way if alternative
IfAlt :: HsMatchContext fn

-- | A pattern match inside arrow notation
ArrowMatchCtxt :: HsArrowMatchContext -> HsMatchContext fn

-- | A pattern binding eg [y] &lt;- e = e
PatBindRhs :: HsMatchContext fn

-- | Guards of pattern bindings, e.g., (Just b) | Just _ &lt;- x = e |
--   otherwise = e'
PatBindGuards :: HsMatchContext fn

-- | Record update [used only in GHC.HsToCore.Expr to tell matchWrapper
--   what sort of runtime error message to generate]
RecUpd :: HsMatchContext fn

-- | Pattern of a do-stmt, list comprehension, pattern guard, etc
StmtCtxt :: HsStmtContext fn -> HsMatchContext fn

-- | A Template Haskell pattern splice
ThPatSplice :: HsMatchContext fn

-- | A Template Haskell pattern quotation [p| (a,b) |]
ThPatQuote :: HsMatchContext fn

-- | A pattern synonym declaration
PatSyn :: HsMatchContext fn

-- | An irrefutable pattern
LazyPatCtx :: HsMatchContext fn

-- | Haskell Statement Context.
data HsStmtContext fn

-- | Context for HsDo (do-notation and comprehensions)
HsDoStmt :: HsDoFlavour -> HsStmtContext fn

-- | Pattern guard for specified thing
PatGuard :: HsMatchContext fn -> HsStmtContext fn

-- | A branch of a parallel stmt
ParStmtCtxt :: HsStmtContext fn -> HsStmtContext fn

-- | A branch of a transform stmt
TransStmtCtxt :: HsStmtContext fn -> HsStmtContext fn

-- | do-notation in an arrow-command context
ArrowExpr :: HsStmtContext fn

-- | Haskell arrow match context.
data HsArrowMatchContext

-- | A proc expression
ProcExpr :: HsArrowMatchContext

-- | A case alternative inside arrow notation
ArrowCaseAlt :: HsArrowMatchContext

-- | A , case or cases alternative inside arrow notation
ArrowLamAlt :: HsLamVariant -> HsArrowMatchContext
data HsDoFlavour

-- | <ul>
--   <li><i>ModuleName.</i> do { ... }</li>
--   </ul>
DoExpr :: Maybe ModuleName -> HsDoFlavour

-- | <ul>
--   <li><i>ModuleName.</i> mdo { ... } ie recursive do-expression</li>
--   </ul>
MDoExpr :: Maybe ModuleName -> HsDoFlavour

-- | A command-line Stmt in GHCi pat &lt;- rhs
GhciStmtCtxt :: HsDoFlavour
ListComp :: HsDoFlavour
MonadComp :: HsDoFlavour
qualifiedDoModuleName_maybe :: HsStmtContext fn -> Maybe ModuleName
isPatSynCtxt :: HsMatchContext fn -> Bool
isComprehensionContext :: HsStmtContext fn -> Bool
isDoComprehensionContext :: HsDoFlavour -> Bool

-- | Is this a monadic context?
isMonadStmtContext :: HsStmtContext fn -> Bool
isMonadDoStmtContext :: HsDoFlavour -> Bool
isMonadCompContext :: HsStmtContext fn -> Bool
isMonadDoCompContext :: HsDoFlavour -> Bool
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Expr.HsArrAppType
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Expr.HsDoFlavour
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Expr.HsLamVariant
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Expr.TransForm
instance GHC.Classes.Eq Language.Haskell.Syntax.Expr.HsDoFlavour
instance GHC.Classes.Eq Language.Haskell.Syntax.Expr.HsLamVariant

module Language.Haskell.Syntax

-- | A ModuleName is essentially a simple string, e.g. <tt>Data.List</tt>.
newtype ModuleName
ModuleName :: FastString -> ModuleName

-- | Haskell Module
--   
--   All we actually declare here is the top-level structure for a module.
data HsModule p
HsModule :: XCModule p -> Maybe (XRec p ModuleName) -> Maybe (XRec p [LIE p]) -> [LImportDecl p] -> [LHsDecl p] -> HsModule p

-- | HsModule extension point
[hsmodExt] :: HsModule p -> XCModule p

-- | <tt>Nothing</tt>: "module X where" is omitted (in which case the next
--   field is Nothing too)
[hsmodName] :: HsModule p -> Maybe (XRec p ModuleName)

-- | Export list
--   
--   <ul>
--   <li><tt>Nothing</tt>: export list omitted, so export everything</li>
--   <li><tt>Just []</tt>: export <i>nothing</i></li>
--   <li><tt>Just [...]</tt>: as you would expect...</li>
--   </ul>
[hsmodExports] :: HsModule p -> Maybe (XRec p [LIE p])
[hsmodImports] :: HsModule p -> [LImportDecl p]

-- | Type, class, value, and interface signature decls
[hsmodDecls] :: HsModule p -> [LHsDecl p]
XModule :: !XXModule p -> HsModule p

module GHC.Types.Tickish
data GenTickish (pass :: TickishPass)

-- | An <tt>{-# SCC #-}</tt> profiling annotation, either automatically
--   added by the desugarer as a result of -auto-all, or added by the user.
ProfNote :: CostCentre -> !Bool -> !Bool -> GenTickish (pass :: TickishPass)

-- | the cost centre
[profNoteCC] :: GenTickish (pass :: TickishPass) -> CostCentre

-- | bump the entry count?
[profNoteCount] :: GenTickish (pass :: TickishPass) -> !Bool

-- | scopes over the enclosed expression (i.e. not just a tick) Invariant:
--   the False/False case never happens
[profNoteScope] :: GenTickish (pass :: TickishPass) -> !Bool

-- | A "tick" used by HPC to track the execution of each subexpression in
--   the original source code.
HpcTick :: Module -> !Int -> GenTickish (pass :: TickishPass)
[tickModule] :: GenTickish (pass :: TickishPass) -> Module
[tickId] :: GenTickish (pass :: TickishPass) -> !Int

-- | A breakpoint for the GHCi debugger. This behaves like an HPC tick, but
--   has a list of free variables which will be available for inspection in
--   GHCi when the program stops at the breakpoint.
--   
--   NB. we must take account of these Ids when (a) counting free
--   variables, and (b) substituting (don't substitute for them)
Breakpoint :: XBreakpoint pass -> !Int -> [XTickishId pass] -> Module -> GenTickish (pass :: TickishPass)
[breakpointExt] :: GenTickish (pass :: TickishPass) -> XBreakpoint pass
[breakpointId] :: GenTickish (pass :: TickishPass) -> !Int

-- | the order of this list is important: it matches the order of the lists
--   in the appropriate entry in <a>ModBreaks</a>.
--   
--   Careful about substitution! See Note [substTickish] in
--   <a>GHC.Core.Subst</a>.
[breakpointFVs] :: GenTickish (pass :: TickishPass) -> [XTickishId pass]
[breakpointModule] :: GenTickish (pass :: TickishPass) -> Module

-- | A source note.
--   
--   Source notes are pure annotations: Their presence should neither
--   influence compilation nor execution. The semantics are given by
--   causality: The presence of a source note means that a local change in
--   the referenced source code span will possibly provoke the generated
--   code to change. On the flip-side, the functionality of annotated code
--   *must* be invariant against changes to all source code *except* the
--   spans referenced in the source notes (see "Causality of optimized
--   Haskell" paper for details).
--   
--   Therefore extending the scope of any given source note is always
--   valid. Note that it is still undesirable though, as this reduces their
--   usefulness for debugging and profiling. Therefore we will generally
--   try only to make use of this property where it is necessary to enable
--   optimizations.
SourceNote :: RealSrcSpan -> LexicalFastString -> GenTickish (pass :: TickishPass)

-- | Source covered
[sourceSpan] :: GenTickish (pass :: TickishPass) -> RealSrcSpan

-- | Name for source location (uses same names as CCs)
[sourceName] :: GenTickish (pass :: TickishPass) -> LexicalFastString
type CoreTickish = GenTickish 'TickishPassCore
type StgTickish = GenTickish 'TickishPassStg

-- | Tickish in Cmm context (annotations only)
type CmmTickish = GenTickish 'TickishPassCmm
type family XTickishId (pass :: TickishPass)

-- | A "counting tick" (where tickishCounts is True) is one that counts
--   evaluations in some way. We cannot discard a counting tick, and the
--   compiler should preserve the number of counting ticks as far as
--   possible.
--   
--   However, we still allow the simplifier to increase or decrease
--   sharing, so in practice the actual number of ticks may vary, except
--   that we never change the value from zero to non-zero or vice versa.
tickishCounts :: forall (pass :: TickishPass). GenTickish pass -> Bool

-- | Specifies the scoping behaviour of ticks. This governs the behaviour
--   of ticks that care about the covered code and the cost associated with
--   it. Important for ticks relating to profiling.
data TickishScoping

-- | No scoping: The tick does not care about what code it covers.
--   Transformations can freely move code inside as well as outside without
--   any additional annotation obligations
NoScope :: TickishScoping

-- | Soft scoping: We want all code that is covered to stay covered. Note
--   that this scope type does not forbid transformations from happening,
--   as long as all results of the transformations are still covered by
--   this tick or a copy of it. For example
--   
--   let x = tick<a>...</a> (let y = foo in bar) in baz ===&gt; let x =
--   tick<a>...</a> bar; y = tick<a>...</a> foo in baz
--   
--   Is a valid transformation as far as "bar" and "foo" is concerned,
--   because both still are scoped over by the tick.
--   
--   Note though that one might object to the "let" not being covered by
--   the tick any more. However, we are generally lax with this - constant
--   costs don't matter too much, and given that the "let" was effectively
--   merged we can view it as having lost its identity anyway.
--   
--   Also note that this scoping behaviour allows floating a tick "upwards"
--   in pretty much any situation. For example:
--   
--   case foo of x -&gt; tick<a>...</a> bar ==&gt; tick<a>...</a> case foo
--   of x -&gt; bar
--   
--   While this is always legal, we want to make a best effort to only make
--   us of this where it exposes transformation opportunities.
SoftScope :: TickishScoping

-- | Cost centre scoping: We don't want any costs to move to other
--   cost-centre stacks. This means we not only want no code or cost to get
--   moved out of their cost centres, but we also object to code getting
--   associated with new cost-centre ticks - or changing the order in which
--   they get applied.
--   
--   A rule of thumb is that we don't want any code to gain new
--   annotations. However, there are notable exceptions, for example:
--   
--   let f = y -&gt; foo in tick<a>...</a> ... (f x) ... ==&gt;
--   tick<a>...</a> ... foo[x/y] ...
--   
--   In-lining lambdas like this is always legal, because inlining a
--   function does not change the cost-centre stack when the function is
--   called.
CostCentreScope :: TickishScoping

-- | Returns the intended scoping rule for a Tickish
tickishScoped :: forall (pass :: TickishPass). GenTickish pass -> TickishScoping

-- | Returns whether the tick scoping rule is at least as permissive as the
--   given scoping rule.
tickishScopesLike :: forall (pass :: TickishPass). GenTickish pass -> TickishScoping -> Bool

-- | Returns <tt>True</tt> for ticks that can be floated upwards easily
--   even where it might change execution counts, such as:
--   
--   Just (tick<a>...</a> foo) ==&gt; tick<a>...</a> (Just foo)
--   
--   This is a combination of <tt>tickishSoftScope</tt> and
--   <tt>tickishCounts</tt>. Note that in principle splittable ticks can
--   become floatable using <tt>mkNoTick</tt> -- even though there's
--   currently no tickish for which that is the case.
tickishFloatable :: forall (pass :: TickishPass). GenTickish pass -> Bool

-- | Returns <tt>True</tt> for a tick that is both counting <i>and</i>
--   scoping and can be split into its (tick, scope) parts using
--   <a>mkNoScope</a> and <tt>mkNoTick</tt> respectively.
tickishCanSplit :: forall (pass :: TickishPass). GenTickish pass -> Bool
mkNoCount :: forall (pass :: TickishPass). GenTickish pass -> GenTickish pass
mkNoScope :: forall (pass :: TickishPass). GenTickish pass -> GenTickish pass

-- | Return <tt>True</tt> if this source annotation compiles to some
--   backend code. Without this flag, the tickish is seen as a simple
--   annotation that does not have any associated evaluation code.
--   
--   What this means that we are allowed to disregard the tick if doing so
--   means that we can skip generating any code in the first place. A
--   typical example is top-level bindings:
--   
--   foo = tick<a>...</a> y -&gt; ... ==&gt; foo = y -&gt; tick<a>...</a>
--   ...
--   
--   Here there is just no operational difference between the first and the
--   second version. Therefore code generation should simply translate the
--   code as if it found the latter.
tickishIsCode :: forall (pass :: TickishPass). GenTickish pass -> Bool
isProfTick :: forall (pass :: TickishPass). GenTickish pass -> Bool

-- | Governs the kind of expression that the tick gets placed on when
--   annotating for example using <tt>mkTick</tt>. If we find that we want
--   to put a tickish on an expression ruled out here, we try to float it
--   inwards until we find a suitable expression.
data TickishPlacement

-- | Place ticks exactly on run-time expressions. We can still move the
--   tick through pure compile-time constructs such as other ticks, casts
--   or type lambdas. This is the most restrictive placement rule for
--   ticks, as all tickishs have in common that they want to track runtime
--   processes. The only legal placement rule for counting ticks. NB: We
--   generally try to move these as close to the relevant runtime
--   expression as possible. This means they get pushed through tyoe
--   arguments. E.g. we create `(tick f) <tt>Bool` instead of `tick (f
--   </tt>Bool)`.
PlaceRuntime :: TickishPlacement

-- | As <tt>PlaceRuntime</tt>, but we float the tick through all lambdas.
--   This makes sense where there is little difference between annotating
--   the lambda and annotating the lambda's code.
PlaceNonLam :: TickishPlacement

-- | In addition to floating through lambdas, cost-centre style tickishs
--   can also be moved from constructors, non-function variables and
--   literals. For example:
--   
--   let x = scc<a>...</a> C (scc<a>...</a> y) (scc<a>...</a> 3) in ...
--   
--   Neither the constructor application, the variable or the literal are
--   likely to have any cost worth mentioning. And even if y names a thunk,
--   the call would not care about the evaluation context. Therefore
--   removing all annotations in the above example is safe.
PlaceCostCentre :: TickishPlacement

-- | Placement behaviour we want for the ticks
tickishPlace :: forall (pass :: TickishPass). GenTickish pass -> TickishPlacement

-- | Returns whether one tick "contains" the other one, therefore making
--   the second tick redundant.
tickishContains :: forall (pass :: TickishPass). Eq (GenTickish pass) => GenTickish pass -> GenTickish pass -> Bool
instance GHC.Internal.Data.Data.Data (GHC.Types.Tickish.GenTickish 'GHC.Types.Tickish.TickishPassCore)
instance GHC.Internal.Data.Data.Data (GHC.Types.Tickish.GenTickish 'GHC.Types.Tickish.TickishPassStg)
instance GHC.Internal.Data.Data.Data (GHC.Types.Tickish.GenTickish 'GHC.Types.Tickish.TickishPassCmm)
instance GHC.Classes.Eq (GHC.Types.Tickish.GenTickish 'GHC.Types.Tickish.TickishPassCore)
instance GHC.Classes.Eq (GHC.Types.Tickish.GenTickish 'GHC.Types.Tickish.TickishPassCmm)
instance GHC.Classes.Eq GHC.Types.Tickish.TickishPlacement
instance GHC.Classes.Eq GHC.Types.Tickish.TickishScoping
instance GHC.Classes.Ord (GHC.Types.Tickish.GenTickish 'GHC.Types.Tickish.TickishPassCore)
instance GHC.Classes.Ord (GHC.Types.Tickish.GenTickish 'GHC.Types.Tickish.TickishPassCmm)
instance GHC.Utils.Outputable.Outputable GHC.Types.Tickish.TickishPlacement
instance GHC.Internal.Show.Show GHC.Types.Tickish.TickishPlacement

module GHC.Tc.Errors.Types.PromotionErr
data PromotionErr
TyConPE :: PromotionErr
ClassPE :: PromotionErr
FamDataConPE :: PromotionErr
ConstrainedDataConPE :: ThetaType -> PromotionErr
PatSynPE :: PromotionErr
RecDataConPE :: PromotionErr
TermVariablePE :: PromotionErr
TypeVariablePE :: PromotionErr
pprPECategory :: PromotionErr -> SDoc
peCategory :: PromotionErr -> String
data TermLevelUseErr
TyConTE :: TermLevelUseErr
ClassTE :: TermLevelUseErr
TyVarTE :: TermLevelUseErr
teCategory :: TermLevelUseErr -> String
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.PromotionErr.PromotionErr
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.PromotionErr.TermLevelUseErr
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Types.PromotionErr.PromotionErr


-- | This module defines the semi-ring of multiplicities, and associated
--   functions. Multiplicities annotate arrow types to indicate the
--   linearity of the arrow (in the sense of linear types).
--   
--   Mult is a type synonym for Type, used only when its kind is
--   Multiplicity. To simplify dealing with multiplicities, functions such
--   as mkMultMul perform simplifications such as Many * x = Many on the
--   fly.
module GHC.Core.Multiplicity

-- | Mult is a type alias for Type.
--   
--   Mult must contain Type because multiplicity variables are mere type
--   variables (of kind Multiplicity) in Haskell. So the simplest
--   implementation is to make Mult be Type.
--   
--   Multiplicities can be formed with: - One: GHC.Types.One (= oneDataCon)
--   - Many: GHC.Types.Many (= manyDataCon) - Multiplication:
--   GHC.Types.MultMul (= multMulTyCon)
--   
--   So that Mult feels a bit more structured, we provide pattern synonyms
--   and smart constructors for these.
type Mult = Type
pattern OneTy :: Mult
pattern ManyTy :: Mult
isMultMul :: Mult -> Maybe (Mult, Mult)
mkMultAdd :: Mult -> Mult -> Mult
mkMultMul :: Mult -> Mult -> Mult

-- | <tt>mkMultSup w1 w2</tt> returns a multiplicity such that
--   <tt>mkMultSup w1 w2 &gt;= w1</tt> and <tt>mkMultSup w1 w2 &gt;=
--   w2</tt>. See Note [Overapproximating multiplicities].
mkMultSup :: Mult -> Mult -> Mult

-- | A shorthand for data with an attached <a>Mult</a> element (the
--   multiplicity).
data Scaled a
Scaled :: !Mult -> a -> Scaled a
scaledMult :: Scaled a -> Mult
scaledThing :: Scaled a -> a

-- | Scale a payload by Many
unrestricted :: a -> Scaled a

-- | Scale a payload by One
linear :: a -> Scaled a

-- | Scale a payload by Many; used for type arguments in core
tymult :: a -> Scaled a
irrelevantMult :: Scaled a -> a
mkScaled :: Mult -> a -> Scaled a
scaledSet :: Scaled a -> b -> Scaled b
scaleScaled :: Mult -> Scaled a -> Scaled a
data IsSubmult
Submult :: IsSubmult
Unknown :: IsSubmult

-- | <tt>submult w1 w2</tt> check whether a value of multiplicity
--   <tt>w1</tt> is allowed where a value of multiplicity <tt>w2</tt> is
--   expected. This is a partial order.
submult :: Mult -> Mult -> IsSubmult

-- | Apply a function to both the Mult and the Type in a 'Scaled Type'
mapScaledType :: (Type -> Type) -> Scaled Type -> Scaled Type
pprArrowWithMultiplicity :: FunTyFlag -> Either Bool SDoc -> SDoc

-- | In Core, without `-dlinear-core-lint`, some function must ignore
--   multiplicities. See Note [Linting linearity] in GHC.Core.Lint.
data MultiplicityFlag
RespectMultiplicities :: MultiplicityFlag
IgnoreMultiplicities :: MultiplicityFlag
instance GHC.Classes.Eq GHC.Core.Multiplicity.IsSubmult
instance GHC.Utils.Outputable.Outputable GHC.Core.Multiplicity.IsSubmult
instance GHC.Internal.Show.Show GHC.Core.Multiplicity.IsSubmult

module GHC.Core.UsageEnv
data Usage
Zero :: Usage
Bottom :: Usage
MUsage :: Mult -> Usage
data UsageEnv
addUE :: UsageEnv -> UsageEnv -> UsageEnv
addUsage :: Usage -> Usage -> Usage
bottomUE :: UsageEnv
deleteUE :: NamedThing n => UsageEnv -> n -> UsageEnv

-- | |lookupUE x env| returns the multiplicity assigned to |x| in |env|, if
--   |x| is not bound in |env|, then returns |Zero| or |Bottom|.
lookupUE :: NamedThing n => UsageEnv -> n -> Usage
popUE :: NamedThing n => UsageEnv -> n -> (Usage, UsageEnv)
scaleUE :: Mult -> UsageEnv -> UsageEnv
scaleUsage :: Mult -> Usage -> Usage
supUE :: UsageEnv -> UsageEnv -> UsageEnv
supUEs :: [UsageEnv] -> UsageEnv

-- | Record a single usage of an Id, i.e. {n: 1} Exception: We do not
--   record external names (both GlobalIds and top-level LocalIds) because
--   they're not relevant to linearity checking.
singleUsageUE :: Id -> UsageEnv
zeroUE :: UsageEnv
instance GHC.Utils.Outputable.Outputable GHC.Core.UsageEnv.Usage
instance GHC.Utils.Outputable.Outputable GHC.Core.UsageEnv.UsageEnv


-- | Type equality and comparison
module GHC.Core.TyCo.Compare

-- | Type equality comparing both visible and invisible arguments,
--   expanding synonyms and respecting multiplicities.
eqType :: HasCallStack => Type -> Type -> Bool
eqTypeIgnoringMultiplicity :: Type -> Type -> Bool

-- | Compare types with respect to a (presumably) non-empty <a>RnEnv2</a>.
eqTypeX :: HasCallStack => RnEnv2 -> Type -> Type -> Bool

-- | Type equality on lists of types, looking through type synonyms
eqTypes :: [Type] -> [Type] -> Bool
eqVarBndrs :: HasCallStack => RnEnv2 -> [Var] -> [Var] -> Maybe RnEnv2

-- | Like <tt>pickyEqTypeVis</tt>, but returns a Bool for convenience
pickyEqType :: Type -> Type -> Bool
tcEqType :: HasDebugCallStack => Type -> Type -> Bool
tcEqKind :: HasDebugCallStack => Kind -> Kind -> Bool

-- | Just like <a>tcEqType</a>, but will return True for types of different
--   kinds as long as their non-coercion structure is identical.
tcEqTypeNoKindCheck :: Type -> Type -> Bool

-- | Check whether two TyConApps are the same; if the number of arguments
--   are different, just checks the common prefix of arguments.
tcEqTyConApps :: TyCon -> [Type] -> TyCon -> [Type] -> Bool

-- | Returns True if the <i>visible</i> part of the types might look equal,
--   even if they are really unequal (in the invisible bits)
--   
--   This function is very similar to tc_eq_type but it is much more
--   heuristic. Notably, it is always safe to return True, even with types
--   that might (in truth) be unequal -- this affects error messages only
--   (Originally this test was done by eqType with an extra flag, but the
--   result was hard to understand.)
mayLookIdentical :: Type -> Type -> Bool
nonDetCmpType :: Type -> Type -> Ordering

-- | Do these denote the same level of visibility? <a>Required</a>
--   arguments are visible, others are not. So this function equates
--   <a>Specified</a> and <a>Inferred</a>. Used for printing.
eqForAllVis :: ForAllTyFlag -> ForAllTyFlag -> Bool

-- | Do these denote the same level of visibility? <a>Required</a>
--   arguments are visible, others are not. So this function equates
--   <a>Specified</a> and <a>Inferred</a>. Used for printing.
cmpForAllVis :: ForAllTyFlag -> ForAllTyFlag -> Ordering
instance GHC.Internal.Enum.Bounded GHC.Core.TyCo.Compare.TypeOrdering
instance GHC.Internal.Enum.Enum GHC.Core.TyCo.Compare.TypeOrdering
instance GHC.Classes.Eq GHC.Core.TyCo.Compare.TypeOrdering
instance GHC.Classes.Ord GHC.Core.TyCo.Compare.TypeOrdering


-- | Core literals
module GHC.Types.Literal

-- | So-called <a>Literal</a>s are one of:
--   
--   <ul>
--   <li>An unboxed numeric literal or floating-point literal which is
--   presumed to be surrounded by appropriate constructors (<tt>Int#</tt>,
--   etc.), so that the overall thing makes sense.</li>
--   </ul>
--   
--   We maintain the invariant that the <a>Integer</a> in the
--   <a>LitNumber</a> constructor is actually in the (possibly
--   target-dependent) range. The mkLit{Int,Word}*Wrap smart constructors
--   ensure this by applying the target machine's wrapping semantics. Use
--   these in situations where you know the wrapping semantics are correct.
--   
--   <ul>
--   <li>The literal derived from the label mentioned in a "foreign label"
--   declaration (<a>LitLabel</a>)</li>
--   <li>A <a>LitRubbish</a> to be used in place of values that are never
--   used.</li>
--   <li>A character</li>
--   <li>A string</li>
--   <li>The NULL pointer</li>
--   </ul>
data Literal

-- | <tt>Char#</tt> - at least 31 bits. Create with <a>mkLitChar</a>
LitChar :: Char -> Literal

-- | Any numeric literal that can be internally represented with an
--   Integer.
LitNumber :: !LitNumType -> !Integer -> Literal

-- | A string-literal: stored and emitted UTF-8 encoded, we'll arrange to
--   decode it at runtime. Also emitted with a <tt>'\0'</tt> terminator.
--   Create with <a>mkLitString</a>
LitString :: !ByteString -> Literal

-- | The <tt>NULL</tt> pointer, the only pointer value that can be
--   represented as a Literal. Create with <a>nullAddrLit</a>
LitNullAddr :: Literal

-- | A nonsense value; See Note [Rubbish literals].
LitRubbish :: TypeOrConstraint -> RuntimeRepType -> Literal

-- | <tt>Float#</tt>. Create with <a>mkLitFloat</a>
LitFloat :: Rational -> Literal

-- | <tt>Double#</tt>. Create with <a>mkLitDouble</a>
LitDouble :: Rational -> Literal

-- | A label literal. Parameters:
--   
--   1) The name of the symbol mentioned in the declaration
--   
--   2) Flag indicating whether the symbol references a function or a data
LitLabel :: FastString -> FunctionOrData -> Literal

-- | Numeric literal type
data LitNumType

-- | <tt>Bignat</tt> (see Note [BigNum literals])
LitNumBigNat :: LitNumType

-- | <tt>Int#</tt> - according to target machine
LitNumInt :: LitNumType

-- | <tt>Int8#</tt> - exactly 8 bits
LitNumInt8 :: LitNumType

-- | <tt>Int16#</tt> - exactly 16 bits
LitNumInt16 :: LitNumType

-- | <tt>Int32#</tt> - exactly 32 bits
LitNumInt32 :: LitNumType

-- | <tt>Int64#</tt> - exactly 64 bits
LitNumInt64 :: LitNumType

-- | <tt>Word#</tt> - according to target machine
LitNumWord :: LitNumType

-- | <tt>Word8#</tt> - exactly 8 bits
LitNumWord8 :: LitNumType

-- | <tt>Word16#</tt> - exactly 16 bits
LitNumWord16 :: LitNumType

-- | <tt>Word32#</tt> - exactly 32 bits
LitNumWord32 :: LitNumType

-- | <tt>Word64#</tt> - exactly 64 bits
LitNumWord64 :: LitNumType

-- | Creates a <a>Literal</a> of type <tt>Int#</tt>
mkLitInt :: Platform -> Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int#</tt>. If the argument is out
--   of the (target-dependent) range, it is wrapped. See Note [Word<i>Int
--   underflow</i>overflow]
mkLitIntWrap :: Platform -> Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int#</tt>, as well as a
--   <a>Bool</a>ean flag indicating overflow. That is, if the argument is
--   out of the (target-dependent) range the argument is wrapped and the
--   overflow flag will be set. See Note [Word<i>Int underflow</i>overflow]
mkLitIntWrapC :: Platform -> Integer -> (Literal, Bool)

-- | Creates a <a>Literal</a> of type <tt>Int#</tt> without checking its
--   range.
mkLitIntUnchecked :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word#</tt>
mkLitWord :: Platform -> Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word#</tt>. If the argument is
--   out of the (target-dependent) range, it is wrapped. See Note
--   [Word<i>Int underflow</i>overflow]
mkLitWordWrap :: Platform -> Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word#</tt>, as well as a
--   <a>Bool</a>ean flag indicating carry. That is, if the argument is out
--   of the (target-dependent) range the argument is wrapped and the carry
--   flag will be set. See Note [Word<i>Int underflow</i>overflow]
mkLitWordWrapC :: Platform -> Integer -> (Literal, Bool)

-- | Creates a <a>Literal</a> of type <tt>Word#</tt> without checking its
--   range.
mkLitWordUnchecked :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int8#</tt>
mkLitInt8 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int8#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitInt8Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int8#</tt> without checking its
--   range.
mkLitInt8Unchecked :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word8#</tt>
mkLitWord8 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word8#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitWord8Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word8#</tt> without checking its
--   range.
mkLitWord8Unchecked :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int16#</tt>
mkLitInt16 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int16#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitInt16Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int16#</tt> without checking its
--   range.
mkLitInt16Unchecked :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word16#</tt>
mkLitWord16 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word16#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitWord16Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word16#</tt> without checking its
--   range.
mkLitWord16Unchecked :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int32#</tt>
mkLitInt32 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int32#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitInt32Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int32#</tt> without checking its
--   range.
mkLitInt32Unchecked :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word32#</tt>
mkLitWord32 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word32#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitWord32Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word32#</tt> without checking its
--   range.
mkLitWord32Unchecked :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int64#</tt>
mkLitInt64 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int64#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitInt64Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int64#</tt> without checking its
--   range.
mkLitInt64Unchecked :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word64#</tt>
mkLitWord64 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word64#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitWord64Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word64#</tt> without checking its
--   range.
mkLitWord64Unchecked :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Float#</tt>
mkLitFloat :: Rational -> Literal

-- | Creates a <a>Literal</a> of type <tt>Double#</tt>
mkLitDouble :: Rational -> Literal

-- | Creates a <a>Literal</a> of type <tt>Char#</tt>
mkLitChar :: Char -> Literal

-- | Creates a <a>Literal</a> of type <tt>Addr#</tt>, which is appropriate
--   for passing to e.g. some of the "error" functions in GHC.Err such as
--   <tt>GHC.Err.runtimeError</tt>
mkLitString :: String -> Literal
mkLitBigNat :: Integer -> Literal

-- | Create a numeric <a>Literal</a> of the given type
mkLitNumber :: Platform -> LitNumType -> Integer -> Literal

-- | Make a literal number using wrapping semantics if the value is out of
--   bound.
mkLitNumberWrap :: Platform -> LitNumType -> Integer -> Literal

-- | Create a numeric <a>Literal</a> of the given type if it is in range
mkLitNumberMaybe :: Platform -> LitNumType -> Integer -> Maybe Literal

-- | Find the Haskell <a>Type</a> the literal occupies
literalType :: Literal -> Type
pprLiteral :: (SDoc -> SDoc) -> Literal -> SDoc

-- | Indicate if a numeric literal type supports negative numbers
litNumIsSigned :: LitNumType -> Bool

-- | Get the literal range
litNumRange :: Platform -> LitNumType -> (Maybe Integer, Maybe Integer)

-- | Check that a given number is in the range of a numeric literal
litNumCheckRange :: Platform -> LitNumType -> Integer -> Bool

-- | Wrap a literal number according to its type using wrapping semantics.
litNumWrap :: Platform -> Literal -> Literal

-- | Coerce a literal number into another using wrapping semantics.
litNumCoerce :: LitNumType -> Platform -> Literal -> Literal

-- | Narrow a literal number by converting it into another number type and
--   then converting it back to its original type.
litNumNarrow :: LitNumType -> Platform -> Literal -> Literal

-- | Number of bits
litNumBitSize :: Platform -> LitNumType -> Maybe Word
isMinBound :: Platform -> Literal -> Bool
isMaxBound :: Platform -> Literal -> Bool

-- | True if code space does not go bad if we duplicate this literal
litIsDupable :: Platform -> Literal -> Bool

-- | True if there is absolutely no penalty to duplicating the literal.
--   False principally of strings.
--   
--   "Why?", you say? I'm glad you asked. Well, for one duplicating strings
--   would blow up code sizes. Not only this, it's also unsafe.
--   
--   Consider a program that wants to traverse a string. One way it might
--   do this is to first compute the Addr# pointing to the end of the
--   string, and then, starting from the beginning, bump a pointer using
--   eqAddr# to determine the end. For instance,
--   
--   <pre>
--   -- Given pointers to the start and end of a string, count how many zeros
--   -- the string contains.
--   countZeros :: Addr# -&gt; Addr# -&gt; -&gt; Int
--   countZeros start end = go start 0
--     where
--       go off n
--         | off <tt>addrEq#</tt> end = n
--         | otherwise         = go (off <tt>plusAddr#</tt> 1) n'
--         where n' | isTrue# (indexInt8OffAddr# off 0# ==# 0#) = n + 1
--                  | otherwise                                 = n
--   </pre>
--   
--   Consider what happens if we considered strings to be trivial (and
--   therefore duplicable) and emitted a call like <tt>countZeros "hello"#
--   ("hello"# <tt>plusAddr</tt># 5)</tt>. The beginning and end pointers
--   do not belong to the same string, meaning that an iteration like the
--   above would blow up terribly. This is what happened in #12757.
--   
--   Ultimately the solution here is to make primitive strings a bit more
--   structured, ensuring that the compiler can't inline in ways that will
--   break user code. One approach to this is described in #8472.
litIsTrivial :: Literal -> Bool
litIsLifted :: Literal -> Bool
inCharRange :: Char -> Bool

-- | Tests whether the literal represents a zero of whatever type it is
isZeroLit :: Literal -> Bool

-- | Tests whether the literal represents a one of whatever type it is
isOneLit :: Literal -> Bool
litFitsInChar :: Literal -> Bool

-- | Returns the <a>Integer</a> contained in the <a>Literal</a>, for when
--   that makes sense, i.e. for <a>Char</a> and numbers.
litValue :: Literal -> Integer

-- | Apply a function to the <a>Integer</a> contained in the
--   <a>Literal</a>, for when that makes sense, e.g. for <a>Char</a> and
--   numbers. For fixed-size integral literals, the result will be wrapped
--   in accordance with the semantics of the target type. See Note
--   [Word<i>Int underflow</i>overflow]
mapLitValue :: Platform -> (Integer -> Integer) -> Literal -> Literal

-- | Returns the <a>Integer</a> contained in the <a>Literal</a>, for when
--   that makes sense, i.e. for <a>Char</a> and numbers.
isLitValue_maybe :: Literal -> Maybe Integer
isLitRubbish :: Literal -> Bool
narrowInt8Lit :: Literal -> Literal
narrowInt16Lit :: Literal -> Literal
narrowInt32Lit :: Literal -> Literal
narrowInt64Lit :: Literal -> Literal
narrowWord8Lit :: Literal -> Literal
narrowWord16Lit :: Literal -> Literal
narrowWord32Lit :: Literal -> Literal
narrowWord64Lit :: Literal -> Literal

-- | Extend or narrow a fixed-width literal (e.g. <tt>Int16#</tt>) to a
--   target word-sized literal (<tt>Int#</tt> or <tt>Word#</tt>). Narrowing
--   can only happen on 32-bit architectures when we convert a 64-bit
--   literal into a 32-bit one.
convertToIntLit :: Platform -> Literal -> Literal

-- | Extend or narrow a fixed-width literal (e.g. <tt>Int16#</tt>) to a
--   target word-sized literal (<tt>Int#</tt> or <tt>Word#</tt>). Narrowing
--   can only happen on 32-bit architectures when we convert a 64-bit
--   literal into a 32-bit one.
convertToWordLit :: Platform -> Literal -> Literal
charToIntLit :: Literal -> Literal
intToCharLit :: Literal -> Literal
floatToIntLit :: Literal -> Literal
intToFloatLit :: Literal -> Literal
doubleToIntLit :: Literal -> Literal
intToDoubleLit :: Literal -> Literal
nullAddrLit :: Literal
floatToDoubleLit :: Literal -> Literal
doubleToFloatLit :: Literal -> Literal
instance GHC.Utils.Binary.Binary GHC.Types.Literal.LitNumType
instance GHC.Utils.Binary.Binary GHC.Types.Literal.Literal
instance GHC.Internal.Data.Data.Data GHC.Types.Literal.LitNumType
instance GHC.Internal.Data.Data.Data GHC.Types.Literal.Literal
instance GHC.Internal.Enum.Enum GHC.Types.Literal.LitNumType
instance GHC.Classes.Eq GHC.Types.Literal.LitNumType
instance GHC.Classes.Eq GHC.Types.Literal.Literal
instance GHC.Classes.Ord GHC.Types.Literal.LitNumType
instance GHC.Classes.Ord GHC.Types.Literal.Literal
instance GHC.Utils.Outputable.Outputable GHC.Types.Literal.Literal

module GHC.Iface.Type
type IfExtName = Name

-- | A local name in iface syntax
newtype IfLclName
IfLclName :: LexicalFastString -> IfLclName
[getIfLclName] :: IfLclName -> LexicalFastString
mkIfLclName :: FastString -> IfLclName
ifLclNameFS :: IfLclName -> FastString

-- | A kind of universal type, used for types and kinds.
--   
--   Any time a <tt>Type</tt> is pretty-printed, it is first converted to
--   an <a>IfaceType</a> before being printed. See Note [Pretty printing
--   via Iface syntax] in <a>GHC.Types.TyThing.Ppr</a>
data IfaceType
IfaceFreeTyVar :: TyVar -> IfaceType
IfaceTyVar :: IfLclName -> IfaceType
IfaceLitTy :: IfaceTyLit -> IfaceType
IfaceAppTy :: IfaceType -> IfaceAppArgs -> IfaceType
IfaceFunTy :: FunTyFlag -> IfaceMult -> IfaceType -> IfaceType -> IfaceType
IfaceForAllTy :: IfaceForAllBndr -> IfaceType -> IfaceType
IfaceTyConApp :: IfaceTyCon -> IfaceAppArgs -> IfaceType
IfaceCastTy :: IfaceType -> IfaceCoercion -> IfaceType
IfaceCoercionTy :: IfaceCoercion -> IfaceType
IfaceTupleTy :: TupleSort -> PromotionFlag -> IfaceAppArgs -> IfaceType
type IfacePredType = IfaceType
type IfaceKind = IfaceType
data IfaceCoercion
IfaceReflCo :: IfaceType -> IfaceCoercion
IfaceGReflCo :: Role -> IfaceType -> IfaceMCoercion -> IfaceCoercion
IfaceFunCo :: Role -> IfaceCoercion -> IfaceCoercion -> IfaceCoercion -> IfaceCoercion
IfaceTyConAppCo :: Role -> IfaceTyCon -> [IfaceCoercion] -> IfaceCoercion
IfaceAppCo :: IfaceCoercion -> IfaceCoercion -> IfaceCoercion
IfaceForAllCo :: IfaceBndr -> !ForAllTyFlag -> !ForAllTyFlag -> IfaceCoercion -> IfaceCoercion -> IfaceCoercion
IfaceCoVarCo :: IfLclName -> IfaceCoercion

-- | There are only a fixed number of CoAxiomRules, so it suffices to use
--   an IfaceLclName to distinguish them. See Note [Adding built-in type
--   families] in GHC.Builtin.Types.Literals
IfaceAxiomCo :: IfaceAxiomRule -> [IfaceCoercion] -> IfaceCoercion
IfaceUnivCo :: UnivCoProvenance -> Role -> IfaceType -> IfaceType -> [IfaceCoercion] -> IfaceCoercion
IfaceSymCo :: IfaceCoercion -> IfaceCoercion
IfaceTransCo :: IfaceCoercion -> IfaceCoercion -> IfaceCoercion
IfaceSelCo :: CoSel -> IfaceCoercion -> IfaceCoercion
IfaceLRCo :: LeftOrRight -> IfaceCoercion -> IfaceCoercion
IfaceInstCo :: IfaceCoercion -> IfaceCoercion -> IfaceCoercion
IfaceKindCo :: IfaceCoercion -> IfaceCoercion
IfaceSubCo :: IfaceCoercion -> IfaceCoercion

-- | See Note [Free TyVars and CoVars in IfaceType]
IfaceFreeCoVar :: CoVar -> IfaceCoercion

-- | See Note [Holes in IfaceCoercion]
IfaceHoleCo :: CoVar -> IfaceCoercion
data IfaceAxiomRule
IfaceAR_X :: IfLclName -> IfaceAxiomRule
IfaceAR_B :: IfExtName -> BranchIndex -> IfaceAxiomRule
IfaceAR_U :: IfExtName -> IfaceAxiomRule
data IfaceMCoercion
IfaceMRefl :: IfaceMCoercion
IfaceMCo :: IfaceCoercion -> IfaceMCoercion
type IfaceMult = IfaceType
data IfaceTyCon
IfaceTyCon :: IfExtName -> !IfaceTyConInfo -> IfaceTyCon
[ifaceTyConName] :: IfaceTyCon -> IfExtName

-- | We add a bang to this field as heap analysis showed that this
--   constructor retains a thunk to a value that is usually shared.
--   
--   See !12200 for how this bang saved ~10% residency when loading
--   <tt>mi_extra_decls</tt> on the agda code base.
--   
--   See Note [Sharing IfaceTyConInfo] for why sharing is so important for
--   <a>IfaceTyConInfo</a>.
[ifaceTyConInfo] :: IfaceTyCon -> !IfaceTyConInfo
data IfaceTyConInfo
IfaceTyConInfo :: PromotionFlag -> IfaceTyConSort -> IfaceTyConInfo
[ifaceTyConIsPromoted] :: IfaceTyConInfo -> PromotionFlag
[ifaceTyConSort] :: IfaceTyConInfo -> IfaceTyConSort

-- | This smart constructor allows sharing of the two most common cases.
--   See Note [Sharing IfaceTyConInfo]
mkIfaceTyConInfo :: PromotionFlag -> IfaceTyConSort -> IfaceTyConInfo

-- | The various types of TyCons which have special, built-in syntax.
data IfaceTyConSort

-- | a regular tycon
IfaceNormalTyCon :: IfaceTyConSort

-- | a tuple, e.g. <tt>(a, b, c)</tt> or <tt>(#a, b, c#)</tt>. The arity is
--   the tuple width, not the tycon arity (which is twice the width in the
--   case of unboxed tuples).
IfaceTupleTyCon :: !Arity -> !TupleSort -> IfaceTyConSort

-- | an unboxed sum, e.g. <tt>(# a | b | c #)</tt>
IfaceSumTyCon :: !Arity -> IfaceTyConSort

-- | A heterogeneous equality TyCon (i.e. eqPrimTyCon, eqReprPrimTyCon,
--   heqTyCon) that is actually being applied to two types of the same
--   kind. This affects pretty-printing only: see Note [Equality predicates
--   in IfaceType]
IfaceEqualityTyCon :: IfaceTyConSort
data IfaceTyLit
IfaceNumTyLit :: Integer -> IfaceTyLit
IfaceStrTyLit :: LexicalFastString -> IfaceTyLit
IfaceCharTyLit :: Char -> IfaceTyLit

-- | Stores the arguments in a type application as a list. See <tt>Note
--   [Suppressing invisible arguments]</tt>.
data IfaceAppArgs
IA_Nil :: IfaceAppArgs
IA_Arg :: IfaceType -> ForAllTyFlag -> IfaceAppArgs -> IfaceAppArgs
type IfaceContext = [IfacePredType]
data IfaceBndr
IfaceIdBndr :: {-# UNPACK #-} !IfaceIdBndr -> IfaceBndr
IfaceTvBndr :: {-# UNPACK #-} !IfaceTvBndr -> IfaceBndr
data IfaceOneShot
IfaceNoOneShot :: IfaceOneShot
IfaceOneShot :: IfaceOneShot
type IfaceLamBndr = (IfaceBndr, IfaceOneShot)
type IfaceTvBndr = (IfLclName, IfaceKind)
type IfaceIdBndr = (IfaceType, IfLclName, IfaceType)
type IfaceTyConBinder = VarBndr IfaceBndr TyConBndrVis
type IfaceForAllSpecBndr = VarBndr IfaceBndr Specificity
type IfaceForAllBndr = VarBndr IfaceBndr ForAllTyFlag

-- | ForAllTyFlag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, ForAllTyBinders, TyConBinders,
--   and visibility] in <a>GHC.Core.TyCo.Rep</a>
data ForAllTyFlag
Invisible :: !Specificity -> ForAllTyFlag
Required :: ForAllTyFlag
pattern Inferred :: ForAllTyFlag
pattern Specified :: ForAllTyFlag

-- | The non-dependent version of <a>ForAllTyFlag</a>. See Note [FunTyFlag]
--   Appears here partly so that it's together with its friends
--   ForAllTyFlag and ForallVisFlag, but also because it is used in
--   IfaceType, rather early in the compilation chain
data FunTyFlag
FTF_T_T :: FunTyFlag
FTF_T_C :: FunTyFlag
FTF_C_T :: FunTyFlag
FTF_C_C :: FunTyFlag

-- | Show forall flag
--   
--   Unconditionally show the forall quantifier with
--   (<a>ShowForAllMust</a>) or when (<a>ShowForAllWhen</a>) the names used
--   are free in the binder or when compiling with
--   -fprint-explicit-foralls.
data ShowForAllFlag
ShowForAllMust :: ShowForAllFlag
ShowForAllWhen :: ShowForAllFlag
data ShowSub
ShowSub :: ShowHowMuch -> ShowForAllFlag -> ShowSub
[ss_how_much] :: ShowSub -> ShowHowMuch
[ss_forall] :: ShowSub -> ShowForAllFlag
data ShowHowMuch

-- | Header information only, not rhs
ShowHeader :: AltPpr -> ShowHowMuch

-- | Show the declaration and its RHS. The <tt>Maybe</tt> predicate allows
--   filtering of the sub-components which should be printing; any
--   sub-components filtered out will be elided with <tt>...</tt>.
ShowSome :: Maybe (OccName -> Bool) -> AltPpr -> ShowHowMuch

-- | Everything including GHC-internal information (used in --show-iface)
ShowIface :: ShowHowMuch
newtype AltPpr
AltPpr :: Maybe (OccName -> SDoc) -> AltPpr

-- | Make an <a>IfaceForAllBndr</a> from an <a>IfaceTvBndr</a>.
mkIfaceForAllTvBndr :: ForAllTyFlag -> IfaceTvBndr -> IfaceForAllBndr

-- | Build the <a>tyConKind</a> from the binders and the result kind. Keep
--   in sync with <a>mkTyConKind</a> in <a>GHC.Core.TyCon</a>.
mkIfaceTyConKind :: [IfaceTyConBinder] -> IfaceKind -> IfaceKind
ifaceForAllSpecToBndrs :: [IfaceForAllSpecBndr] -> [IfaceForAllBndr]
ifaceForAllSpecToBndr :: IfaceForAllSpecBndr -> IfaceForAllBndr

-- | Extract an <a>IfaceBndr</a> from an <a>IfaceForAllBndr</a>.
ifForAllBndrVar :: IfaceForAllBndr -> IfaceBndr

-- | Extract the variable name from an <a>IfaceForAllBndr</a>.
ifForAllBndrName :: IfaceForAllBndr -> IfLclName
ifaceBndrName :: IfaceBndr -> IfLclName

-- | Extract an <a>IfaceBndr</a> from an <a>IfaceTyConBinder</a>.
ifTyConBinderVar :: IfaceTyConBinder -> IfaceBndr

-- | Extract the variable name from an <a>IfaceTyConBinder</a>.
ifTyConBinderName :: IfaceTyConBinder -> IfLclName

-- | Serialises an <a>IfaceType</a> to the given <a>WriteBinHandle</a>.
--   
--   Serialising inner <tt>IfaceType'</tt>s uses the <a>put</a> of
--   <a>IfaceType</a> which may be using a deduplication table. See Note
--   [Deduplication during iface binary serialisation].
putIfaceType :: WriteBinHandle -> IfaceType -> IO ()

-- | Deserialises an <a>IfaceType</a> from the given <a>ReadBinHandle</a>.
--   
--   Reading inner <tt>IfaceType'</tt>s uses the <a>get</a> of
--   <a>IfaceType</a> which may be using a deduplication table. See Note
--   [Deduplication during iface binary serialisation].
getIfaceType :: HasCallStack => ReadBinHandle -> IO IfaceType

-- | This is the byte tag we expect to read when the next value is not an
--   <a>IfaceType</a> value, but an offset into a lookup table. See Note
--   [Deduplication during iface binary serialisation].
--   
--   Must not overlap with any byte tag in <a>getIfaceType</a>.
ifaceTypeSharedByte :: Word8

-- | Returns true for Type or (TYPE LiftedRep)
isIfaceLiftedTypeKind :: IfaceKind -> Bool
appArgsIfaceTypes :: IfaceAppArgs -> [IfaceType]
appArgsIfaceTypesForAllTyFlags :: IfaceAppArgs -> [(IfaceType, ForAllTyFlag)]

-- | Do we want to suppress kind annotations on binders? See Note
--   [Suppressing binder signatures]
newtype SuppressBndrSig
SuppressBndrSig :: Bool -> SuppressBndrSig
newtype UseBndrParens
UseBndrParens :: Bool -> UseBndrParens
newtype PrintExplicitKinds
PrintExplicitKinds :: Bool -> PrintExplicitKinds
pprIfaceType :: IfaceType -> SDoc
pprParendIfaceType :: IfaceType -> SDoc
pprPrecIfaceType :: PprPrec -> IfaceType -> SDoc

-- | Prints a context or <tt>()</tt> if empty You give it the context
--   precedence
pprIfaceContext :: PprPrec -> [IfacePredType] -> SDoc

-- | Prints "(C a, D b) =&gt;", including the arrow. Used when we want to
--   print a context in a type, so we use <a>funPrec</a> to decide whether
--   to parenthesise a singleton predicate; e.g. Num a =&gt; a -&gt; a
pprIfaceContextArr :: [IfacePredType] -> SDoc
pprIfaceIdBndr :: IfaceIdBndr -> SDoc
pprIfaceLamBndr :: IfaceLamBndr -> SDoc
pprIfaceTvBndr :: IfaceTvBndr -> SuppressBndrSig -> UseBndrParens -> SDoc
pprIfaceTyConBinders :: SuppressBndrSig -> [IfaceTyConBinder] -> SDoc
pprIfaceBndrs :: [IfaceBndr] -> SDoc
pprIfaceAppArgs :: IfaceAppArgs -> SDoc
pprParendIfaceAppArgs :: IfaceAppArgs -> SDoc
pprIfaceForAllPart :: [IfaceForAllBndr] -> [IfacePredType] -> SDoc -> SDoc

-- | Like <a>pprIfaceForAllPart</a>, but always uses an explicit
--   <tt>forall</tt>.
pprIfaceForAllPartMust :: [IfaceForAllBndr] -> [IfacePredType] -> SDoc -> SDoc

-- | Render the "forall ... ." or "forall ... -&gt;" bit of a type.
pprIfaceForAll :: [IfaceForAllBndr] -> SDoc
pprIfaceSigmaType :: ShowForAllFlag -> IfaceType -> SDoc
pprIfaceTyLit :: IfaceTyLit -> SDoc
pprIfaceCoercion :: IfaceCoercion -> SDoc
pprParendIfaceCoercion :: IfaceCoercion -> SDoc
splitIfaceSigmaTy :: IfaceType -> ([IfaceForAllBndr], [IfacePredType], IfaceType)
pprIfaceTypeApp :: PprPrec -> IfaceTyCon -> IfaceAppArgs -> SDoc
pprUserIfaceForAll :: [IfaceForAllBndr] -> SDoc
pprIfaceCoTcApp :: PprPrec -> IfaceTyCon -> [IfaceCoercion] -> SDoc
pprTyTcApp :: PprPrec -> IfaceTyCon -> IfaceAppArgs -> SDoc
pprIfacePrefixApp :: PprPrec -> SDoc -> [SDoc] -> SDoc
isIfaceRhoType :: IfaceType -> Bool
suppressIfaceInvisibles :: PrintExplicitKinds -> [IfaceTyConBinder] -> [a] -> [a]
stripIfaceInvisVars :: PrintExplicitKinds -> [IfaceTyConBinder] -> [IfaceTyConBinder]
stripInvisArgs :: PrintExplicitKinds -> IfaceAppArgs -> IfaceAppArgs
mkIfaceTySubst :: [(IfLclName, IfaceType)] -> IfaceTySubst
substIfaceTyVar :: IfaceTySubst -> IfLclName -> IfaceType
substIfaceAppArgs :: IfaceTySubst -> IfaceAppArgs -> IfaceAppArgs
inDomIfaceTySubst :: IfaceTySubst -> IfaceTvBndr -> Bool

-- | The type 'Many :: Multiplicity'.
many_ty :: IfaceType
pprTypeArrow :: FunTyFlag -> IfaceMult -> SDoc
instance GHC.Utils.Binary.Binary (GHC.Types.Basic.DefMethSpec GHC.Iface.Type.IfaceType)
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfLclName
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceAppArgs
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceAxiomRule
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceBndr
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceCoercion
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceMCoercion
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceOneShot
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceTyCon
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceTyConInfo
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceTyConSort
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceTyLit
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceType
instance GHC.Classes.Eq GHC.Iface.Type.IfLclName
instance GHC.Classes.Eq GHC.Iface.Type.IfaceAppArgs
instance GHC.Classes.Eq GHC.Iface.Type.IfaceAxiomRule
instance GHC.Classes.Eq GHC.Iface.Type.IfaceBndr
instance GHC.Classes.Eq GHC.Iface.Type.IfaceCoercion
instance GHC.Classes.Eq GHC.Iface.Type.IfaceMCoercion
instance GHC.Classes.Eq GHC.Iface.Type.IfaceTyCon
instance GHC.Classes.Eq GHC.Iface.Type.IfaceTyConInfo
instance GHC.Classes.Eq GHC.Iface.Type.IfaceTyConSort
instance GHC.Classes.Eq GHC.Iface.Type.IfaceTyLit
instance GHC.Classes.Eq GHC.Iface.Type.IfaceType
instance GHC.Classes.Eq GHC.Iface.Type.TupleOrSum
instance GHC.Internal.Base.Monoid GHC.Iface.Type.IfaceAppArgs
instance Control.DeepSeq.NFData GHC.Iface.Type.IfLclName
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceAppArgs
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceAxiomRule
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceBndr
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceCoercion
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceMCoercion
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceOneShot
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceTyCon
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceTyConInfo
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceTyConSort
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceTyLit
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceType
instance GHC.Classes.Ord GHC.Iface.Type.IfLclName
instance GHC.Classes.Ord GHC.Iface.Type.IfaceAppArgs
instance GHC.Classes.Ord GHC.Iface.Type.IfaceAxiomRule
instance GHC.Classes.Ord GHC.Iface.Type.IfaceBndr
instance GHC.Classes.Ord GHC.Iface.Type.IfaceCoercion
instance GHC.Classes.Ord GHC.Iface.Type.IfaceMCoercion
instance GHC.Classes.Ord GHC.Iface.Type.IfaceTyCon
instance GHC.Classes.Ord GHC.Iface.Type.IfaceTyConInfo
instance GHC.Classes.Ord GHC.Iface.Type.IfaceTyConSort
instance GHC.Classes.Ord GHC.Iface.Type.IfaceTyLit
instance GHC.Classes.Ord GHC.Iface.Type.IfaceType
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfLclName
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceAppArgs
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceBndr
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceCoercion
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceOneShot
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceTyCon
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceTyConInfo
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceTyConSort
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceTyLit
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceType
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.ShowHowMuch
instance GHC.Internal.Base.Semigroup GHC.Iface.Type.IfaceAppArgs
instance GHC.Internal.Show.Show GHC.Iface.Type.IfLclName


-- | Computing fingerprints of values serializable with GHC's "Binary"
--   module.
module GHC.Iface.Recomp.Binary
fingerprintBinMem :: WriteBinHandle -> IO Fingerprint
computeFingerprint :: Binary a => (WriteBinHandle -> Name -> IO ()) -> a -> IO Fingerprint

-- | Used when we want to fingerprint a structure without depending on the
--   fingerprints of external Names that it refers to.
putNameLiterally :: WriteBinHandle -> Name -> IO ()


-- | Pretty-printing types and coercions.
module GHC.Core.TyCo.Ppr

-- | A general-purpose pretty-printing precedence type.
newtype PprPrec
PprPrec :: Int -> PprPrec
topPrec :: PprPrec
sigPrec :: PprPrec
opPrec :: PprPrec
funPrec :: PprPrec
appPrec :: PprPrec
maybeParen :: PprPrec -> PprPrec -> SDoc -> SDoc
pprType :: Type -> SDoc
pprParendType :: Type -> SDoc
pprTidiedType :: Type -> SDoc
pprPrecType :: PprPrec -> Type -> SDoc
pprPrecTypeX :: TidyEnv -> PprPrec -> Type -> SDoc
pprTypeApp :: TyCon -> [Type] -> SDoc
pprTCvBndr :: ForAllTyBinder -> SDoc
pprTCvBndrs :: [ForAllTyBinder] -> SDoc
pprSigmaType :: Type -> SDoc
pprTheta :: ThetaType -> SDoc
pprParendTheta :: ThetaType -> SDoc
pprForAll :: [ForAllTyBinder] -> SDoc

-- | Print a user-level forall; see <tt>Note [When to print foralls]</tt>
--   in <a>GHC.Iface.Type</a>.
pprUserForAll :: [ForAllTyBinder] -> SDoc
pprTyVar :: TyVar -> SDoc
pprTyVars :: [TyVar] -> SDoc
pprThetaArrowTy :: ThetaType -> SDoc
pprClassPred :: Class -> [Type] -> SDoc
pprKind :: Kind -> SDoc
pprParendKind :: Kind -> SDoc
pprTyLit :: TyLit -> SDoc
pprDataCons :: TyCon -> SDoc

-- | Display all foralls, runtime-reps, and kind information when provided
--   <a>Bool</a> argument is <a>True</a>. See GHC.Tc.Errors.Ppr Note
--   [Showing invisible bits of types in error messages]
pprWithInvisibleBitsWhen :: Bool -> SDoc -> SDoc

-- | This variant preserves any use of TYPE in a type, effectively locally
--   setting -fprint-explicit-runtime-reps.
pprWithTYPE :: Type -> SDoc

-- | Pretty prints a <a>TyCon</a>, using the family instance in case of a
--   representation tycon. For example:
--   
--   <pre>
--   data T [a] = ...
--   </pre>
--   
--   In that case we want to print <tt>T [a]</tt>, where <tt>T</tt> is the
--   family <a>TyCon</a>
pprSourceTyCon :: TyCon -> SDoc
pprCo :: Coercion -> SDoc
pprParendCo :: Coercion -> SDoc

-- | debugPprType is a simple pretty printer that prints a type without
--   going through IfaceType. It does not format as prettily as the normal
--   route, but it's much more direct, and that can be useful for
--   debugging. E.g. with -dppr-debug it prints the kind on type-variable
--   <i>occurrences</i> which the normal route fundamentally cannot do.
debugPprType :: Type -> SDoc

module GHC.Core.PatSyn

-- | Pattern Synonym
--   
--   See Note [Pattern synonym representation] See Note [Pattern synonym
--   signature contexts]
data PatSyn
type PatSynMatcher = (Name, Type, Bool)
type PatSynBuilder = Maybe (Name, Type, Bool)

-- | Build a new pattern synonym
mkPatSyn :: Name -> Bool -> ([InvisTVBinder], ThetaType) -> ([InvisTVBinder], ThetaType) -> [FRRType] -> Type -> PatSynMatcher -> PatSynBuilder -> [FieldLabel] -> PatSyn

-- | The <a>Name</a> of the <a>PatSyn</a>, giving it a unique, rooted
--   identification
patSynName :: PatSyn -> Name

-- | Arity of the pattern synonym
patSynArity :: PatSyn -> Arity

-- | Should the <a>PatSyn</a> be presented infix?
patSynIsInfix :: PatSyn -> Bool
patSynResultType :: PatSyn -> Type

-- | Is this a 'vanilla' pattern synonym (no existentials, no provided
--   constraints)?
isVanillaPatSyn :: PatSyn -> Bool
patSynArgs :: PatSyn -> [Type]
patSynMatcher :: PatSyn -> PatSynMatcher
patSynBuilder :: PatSyn -> PatSynBuilder
patSynUnivTyVarBinders :: PatSyn -> [InvisTVBinder]
patSynExTyVars :: PatSyn -> [TyVar]
patSynExTyVarBinders :: PatSyn -> [InvisTVBinder]
patSynSig :: PatSyn -> ([TyVar], ThetaType, [TyVar], ThetaType, [Scaled Type], Type)
patSynSigBndr :: PatSyn -> ([InvisTVBinder], ThetaType, [InvisTVBinder], ThetaType, [Scaled Type], Type)
patSynInstArgTys :: PatSyn -> [Type] -> [Type]
patSynInstResTy :: PatSyn -> [Type] -> Type
patSynFieldLabels :: PatSyn -> [FieldLabel]

-- | Extract the type for any given labelled field of the <tt>DataCon</tt>
patSynFieldType :: PatSyn -> FieldLabelString -> Type

-- | Print the type of a pattern synonym. The foralls are printed
--   explicitly
pprPatSynType :: PatSyn -> SDoc
instance GHC.Internal.Data.Data.Data GHC.Core.PatSyn.PatSyn
instance GHC.Classes.Eq GHC.Core.PatSyn.PatSyn
instance GHC.Types.Name.NamedThing GHC.Core.PatSyn.PatSyn
instance GHC.Utils.Outputable.OutputableBndr GHC.Core.PatSyn.PatSyn
instance GHC.Utils.Outputable.Outputable GHC.Core.PatSyn.PatSyn
instance GHC.Types.Unique.Uniquable GHC.Core.PatSyn.PatSyn


-- | <a>RoughMap</a> is an approximate finite map data structure keyed on
--   <tt>[<a>RoughMatchTc</a>]</tt>. This is useful when keying maps on
--   lists of <a>Type</a>s (e.g. an instance head).
module GHC.Core.RoughMap
data RoughMatchTc
RM_KnownTc :: Name -> RoughMatchTc
RM_WildCard :: RoughMatchTc
isRoughWildcard :: RoughMatchTc -> Bool
typeToRoughMatchTc :: Type -> RoughMatchTc
data RoughMatchLookupTc

-- | The position only matches the specified KnownTc
RML_KnownTc :: Name -> RoughMatchLookupTc

-- | The position definitely doesn't match any KnownTc
RML_NoKnownTc :: RoughMatchLookupTc

-- | The position can match anything
RML_WildCard :: RoughMatchLookupTc
typeToRoughMatchLookupTc :: Type -> RoughMatchLookupTc
roughMatchTcToLookup :: RoughMatchTc -> RoughMatchLookupTc
roughMatchTcs :: [Type] -> [RoughMatchTc]
roughMatchTcsLookup :: [Type] -> [RoughMatchLookupTc]
instanceCantMatch :: [RoughMatchTc] -> [RoughMatchTc] -> Bool

-- | Trie of <tt>[RoughMatchTc]</tt>
--   
--   <ul>
--   <li>Examples* <tt> insert [OtherTc] 1 insert [OtherTc] 2 lookup
--   [OtherTc] == [1,2] </tt></li>
--   </ul>
data RoughMap a
emptyRM :: RoughMap a

-- | Order of result is deterministic.
lookupRM :: [RoughMatchLookupTc] -> RoughMap a -> [a]

-- | N.B. Returns a <a>Bag</a> for matches, which allows us to avoid
--   rebuilding all of the lists we find in <a>rm_empty</a>, which would
--   otherwise be necessary due to <a>++</a> if we returned a list. We use
--   a list for unifiers because the tail is computed lazily and we often
--   only care about the first couple of potential unifiers. Constructing a
--   bag forces the tail which performs much too much work.
--   
--   See Note [Matching a RoughMap] See Note [Matches vs Unifiers]
lookupRM' :: [RoughMatchLookupTc] -> RoughMap a -> (Bag a, [a])
insertRM :: [RoughMatchTc] -> a -> RoughMap a -> RoughMap a
filterRM :: (a -> Bool) -> RoughMap a -> RoughMap a

-- | Filter all elements that might match a particular key with the given
--   predicate.
filterMatchingRM :: (a -> Bool) -> [RoughMatchTc] -> RoughMap a -> RoughMap a
elemsRM :: RoughMap a -> [a]
sizeRM :: RoughMap a -> Int
foldRM :: (a -> b -> b) -> b -> RoughMap a -> b
unionRM :: RoughMap a -> RoughMap a -> RoughMap a
instance GHC.Internal.Data.Data.Data GHC.Core.RoughMap.RoughMatchLookupTc
instance GHC.Internal.Data.Data.Data GHC.Core.RoughMap.RoughMatchTc
instance GHC.Internal.Base.Functor GHC.Core.RoughMap.RoughMap
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Core.RoughMap.RoughMap a)
instance GHC.Utils.Outputable.Outputable GHC.Core.RoughMap.RoughMatchLookupTc
instance GHC.Utils.Outputable.Outputable GHC.Core.RoughMap.RoughMatchTc


-- | Module for (a) type kinds and (b) type coercions, as used in System
--   FC. See <a>Expr</a> for more on System FC and how coercions fit into
--   it.
module GHC.Core.Coercion

-- | A <a>Coercion</a> is concrete evidence of the equality/convertibility
--   of two types.
data Coercion
type CoercionN = Coercion
type CoercionR = Coercion
type CoercionP = Coercion

-- | A semantically more meaningful type to represent what may or may not
--   be a useful <a>Coercion</a>.
data MCoercion
MRefl :: MCoercion
MCo :: Coercion -> MCoercion
type MCoercionN = MCoercion
type MCoercionR = MCoercion
data CoSel
SelTyCon :: Int -> Role -> CoSel
SelFun :: FunSel -> CoSel
SelForAll :: CoSel
data FunSel
SelMult :: FunSel
SelArg :: FunSel
SelRes :: FunSel

-- | For simplicity, we have just one UnivCo that represents a coercion
--   from some type to some other type, with (in general) no restrictions
--   on the type. The UnivCoProvenance specifies more exactly what the
--   coercion really is and why a program should (or shouldn't!) trust the
--   coercion. It is reasonable to consider each constructor of
--   <a>UnivCoProvenance</a> as a totally independent coercion form; their
--   only commonality is that they don't tell you what types they coercion
--   between. (That info is in the <a>UnivCo</a> constructor of
--   <a>Coercion</a>.
data UnivCoProvenance

-- | A coercion to be filled in by the type-checker. See Note [Coercion
--   holes]
data CoercionHole
CoercionHole :: CoVar -> IORef (Maybe Coercion) -> Bool -> CoercionHole
[ch_co_var] :: CoercionHole -> CoVar
[ch_ref] :: CoercionHole -> IORef (Maybe Coercion)
[ch_hetero_kind] :: CoercionHole -> Bool
coHoleCoVar :: CoercionHole -> CoVar
setCoHoleCoVar :: CoercionHole -> CoVar -> CoercionHole
data LeftOrRight
CLeft :: LeftOrRight
CRight :: LeftOrRight

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var

-- | Coercion Variable
type CoVar = Id

-- | Type or Coercion Variable
type TyCoVar = Id

-- | See Note [Roles] in GHC.Core.Coercion
--   
--   Order of constructors matters: the Ord instance coincides with the
--   *super*typing relation on roles.
data Role
Nominal :: Role
Representational :: Role
Phantom :: Role
ltRole :: Role -> Role -> Bool
coVarRType :: HasDebugCallStack => CoVar -> Type
coVarLType :: HasDebugCallStack => CoVar -> Type
coVarTypes :: HasDebugCallStack => CoVar -> Pair Type
coVarKind :: CoVar -> Type
coVarTypesRole :: HasDebugCallStack => CoVar -> (Type, Type, Role)
coVarRole :: CoVar -> Role
coercionType :: Coercion -> Type

-- | Makes a coercion type from two types: the types whose equality is
--   proven by the relevant <a>Coercion</a>
mkCoercionType :: Role -> Type -> Type -> Type

-- | If it is the case that
--   
--   <pre>
--   c :: (t1 ~ t2)
--   </pre>
--   
--   i.e. the kind of <tt>c</tt> relates <tt>t1</tt> and <tt>t2</tt>, then
--   <tt>coercionKind c = Pair t1 t2</tt>.
coercionKind :: HasDebugCallStack => Coercion -> Pair Type
coercionLKind :: HasDebugCallStack => Coercion -> Type
coercionRKind :: HasDebugCallStack => Coercion -> Type

-- | Apply <a>coercionKind</a> to multiple <a>Coercion</a>s
coercionKinds :: [Coercion] -> Pair [Type]

-- | Retrieve the role from a coercion.
coercionRole :: Coercion -> Role

-- | Get a coercion's kind and role.
coercionKindRole :: Coercion -> (Pair Type, Role)

-- | Make a generalized reflexive coercion
mkGReflCo :: Role -> Type -> MCoercionN -> Coercion
mkGReflMCo :: HasDebugCallStack => Role -> Type -> CoercionN -> Coercion

-- | Make a reflexive coercion
mkReflCo :: Role -> Type -> Coercion

-- | Make a representational reflexive coercion
mkRepReflCo :: Type -> Coercion

-- | Make a nominal reflexive coercion
mkNomReflCo :: Type -> Coercion
mkCoVarCo :: CoVar -> Coercion
mkCoVarCos :: [CoVar] -> [Coercion]
mkAxInstCo :: Role -> CoAxiomRule -> [Type] -> [Coercion] -> Coercion
mkUnbranchedAxInstCo :: Role -> CoAxiom Unbranched -> [Type] -> [Coercion] -> Coercion
mkAxInstRHS :: forall (br :: BranchFlag). CoAxiom br -> BranchIndex -> [Type] -> [Coercion] -> Type
mkUnbranchedAxInstRHS :: CoAxiom Unbranched -> [Type] -> [Coercion] -> Type

-- | Return the left-hand type of the axiom, when the axiom is instantiated
--   at the types given.
mkAxInstLHS :: forall (br :: BranchFlag). CoAxiom br -> BranchIndex -> [Type] -> [Coercion] -> Type

-- | Instantiate the left-hand side of an unbranched axiom
mkUnbranchedAxInstLHS :: CoAxiom Unbranched -> [Type] -> [Coercion] -> Type

-- | Make a forall <a>Coercion</a>, where both types related by the
--   coercion are quantified over the same variable.
mkPiCo :: Role -> Var -> Coercion -> Coercion
mkPiCos :: Role -> [Var] -> Coercion -> Coercion
mkCoCast :: Coercion -> CoercionR -> Coercion

-- | Create a symmetric version of the given <a>Coercion</a> that asserts
--   equality between the same types but in the other "direction", so a
--   kind of <tt>t1 ~ t2</tt> becomes the kind <tt>t2 ~ t1</tt>.
mkSymCo :: Coercion -> Coercion

-- | mkTransCo creates a new <a>Coercion</a> by composing the two given
--   <a>Coercion</a>s transitively: (co1 ; co2)
mkTransCo :: HasDebugCallStack => Coercion -> Coercion -> Coercion
mkSelCo :: HasDebugCallStack => CoSel -> Coercion -> Coercion
mkSelCoResRole :: CoSel -> Role -> Role

-- | Extract the nth field of a FunCo
getNthFun :: FunSel -> a -> a -> a -> a
selectFromType :: HasDebugCallStack => CoSel -> Type -> Type
mkLRCo :: LeftOrRight -> Coercion -> Coercion

-- | Instantiates a <a>Coercion</a>. Works for both tyvar and covar
mkInstCo :: Coercion -> CoercionN -> Coercion

-- | Apply a <a>Coercion</a> to another <a>Coercion</a>. The second
--   coercion must be Nominal, unless the first is Phantom. If the first is
--   Phantom, then the second can be either Phantom or Nominal.
mkAppCo :: Coercion -> Coercion -> Coercion

-- | Applies multiple <a>Coercion</a>s to another <a>Coercion</a>, from
--   left to right. See also <a>mkAppCo</a>.
mkAppCos :: Coercion -> [Coercion] -> Coercion

-- | Apply a type constructor to a list of coercions. It is the caller's
--   responsibility to get the roles correct on argument coercions.
mkTyConAppCo :: HasDebugCallStack => Role -> TyCon -> [Coercion] -> Coercion

-- | Build a function <a>Coercion</a> from two other <a>Coercion</a>s. That
--   is, given <tt>co1 :: a ~ b</tt> and <tt>co2 :: x ~ y</tt> produce
--   <tt>co :: (a -&gt; x) ~ (b -&gt; y)</tt> or <tt>(a =&gt; x) ~ (b =&gt;
--   y)</tt>, depending on the kind of <tt>a</tt>/<tt>b</tt>. This (most
--   common) version takes a single FunTyFlag, which is used for both
--   fco_afl and ftf_afr of the FunCo
mkFunCo :: Role -> FunTyFlag -> CoercionN -> Coercion -> Coercion -> Coercion
mkFunCo2 :: Role -> FunTyFlag -> FunTyFlag -> CoercionN -> Coercion -> Coercion -> Coercion
mkFunCoNoFTF :: HasDebugCallStack => Role -> CoercionN -> Coercion -> Coercion -> Coercion
mkFunResCo :: Role -> Id -> Coercion -> Coercion
mkNakedFunCo :: Role -> FunTyFlag -> CoercionN -> Coercion -> Coercion -> Coercion
mkNakedForAllCo :: TyVar -> ForAllTyFlag -> ForAllTyFlag -> CoercionN -> Coercion -> Coercion

-- | Make a Coercion from a tycovar, a kind coercion, and a body coercion.
mkForAllCo :: HasDebugCallStack => TyCoVar -> ForAllTyFlag -> ForAllTyFlag -> CoercionN -> Coercion -> Coercion

-- | Make a Coercion quantified over a type/coercion variable; the variable
--   has the same kind and visibility in both sides of the coercion
mkHomoForAllCos :: [ForAllTyBinder] -> Coercion -> Coercion

-- | Make a phantom coercion between two types. The coercion passed in must
--   be a nominal coercion between the kinds of the types.
mkPhantomCo :: Coercion -> Type -> Type -> Coercion

-- | Make a coercion from a coercion hole
mkHoleCo :: CoercionHole -> Coercion

-- | Make a universal coercion between two arbitrary types.
mkUnivCo :: UnivCoProvenance -> [Coercion] -> Role -> Type -> Type -> Coercion
mkSubCo :: HasDebugCallStack => Coercion -> Coercion

-- | Make a "coercion between coercions".
mkProofIrrelCo :: Role -> CoercionN -> Coercion -> Coercion -> Coercion

-- | Like <a>downgradeRole_maybe</a>, but panics if the change isn't a
--   downgrade. See Note [Role twiddling functions]
downgradeRole :: Role -> Role -> Coercion -> Coercion
mkAxiomCo :: CoAxiomRule -> [Coercion] -> Coercion

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, produces <tt>co' ::
--   ty ~r (ty |&gt; co)</tt>
mkGReflRightCo :: Role -> Type -> CoercionN -> Coercion

-- | Given <tt>r</tt>, <tt>ty :: k1</tt>, and <tt>co :: k1 ~N k2</tt>,
--   produces <tt>co' :: (ty |&gt; co) ~r ty</tt>
mkGReflLeftCo :: Role -> Type -> CoercionN -> Coercion

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, <tt>co2:: ty ~r
--   ty'</tt>, produces @co' :: (ty |&gt; co) ~r ty' It is not only a
--   utility function, but it saves allocation when co is a GRefl coercion.
mkCoherenceLeftCo :: Role -> Type -> CoercionN -> Coercion -> Coercion

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, <tt>co2:: ty' ~r
--   ty</tt>, produces @co' :: ty' ~r (ty |&gt; co) It is not only a
--   utility function, but it saves allocation when co is a GRefl coercion.
mkCoherenceRightCo :: HasDebugCallStack => Role -> Type -> CoercionN -> Coercion -> Coercion

-- | Given <tt>co :: (a :: k) ~ (b :: k')</tt> produce <tt>co' :: k ~
--   k'</tt>.
mkKindCo :: Coercion -> Coercion

-- | Creates a new coercion with both of its types casted by different
--   casts <tt>castCoercionKind g h1 h2</tt>, where <tt>g :: t1 ~r t2</tt>,
--   has type <tt>(t1 |&gt; h1) ~r (t2 |&gt; h2)</tt>. <tt>h1</tt> and
--   <tt>h2</tt> must be nominal. It calls <tt>coercionKindRole</tt>, so
--   it's quite inefficient (which <tt>I</tt> stands for) Use
--   <tt>castCoercionKind2</tt> instead if <tt>t1</tt>, <tt>t2</tt>, and
--   <tt>r</tt> are known beforehand.
castCoercionKind :: Coercion -> CoercionN -> CoercionN -> Coercion

-- | <tt>castCoercionKind1 g r t1 t2 h</tt> = <tt>coercionKind g r t1 t2 h
--   h</tt> That is, it's a specialised form of castCoercionKind, where the
--   two kind coercions are identical <tt>castCoercionKind1 g r t1 t2
--   h</tt>, where <tt>g :: t1 ~r t2</tt>, has type <tt>(t1 |&gt; h) ~r (t2
--   |&gt; h)</tt>. <tt>h</tt> must be nominal. See Note
--   [castCoercionKind1]
castCoercionKind1 :: Coercion -> Role -> Type -> Type -> CoercionN -> Coercion

-- | Creates a new coercion with both of its types casted by different
--   casts <tt>castCoercionKind2 g r t1 t2 h1 h2</tt>, where <tt>g :: t1 ~r
--   t2</tt>, has type <tt>(t1 |&gt; h1) ~r (t2 |&gt; h2)</tt>. <tt>h1</tt>
--   and <tt>h2</tt> must be nominal.
castCoercionKind2 :: Coercion -> Role -> Type -> Type -> CoercionN -> CoercionN -> Coercion

-- | Creates a primitive nominal type equality predicate. t1 ~# t2
--   Invariant: the types are not Coercions
mkPrimEqPred :: Type -> Type -> Type

-- | Creates a primitive representational type equality predicate. t1 ~R#
--   t2 Invariant: the types are not Coercions
mkReprPrimEqPred :: Type -> Type -> Type

-- | Makes a lifted equality predicate at the given role
mkPrimEqPredRole :: Role -> Type -> Type -> PredType

-- | Creates a primitive nominal type equality predicate with an explicit
--   (but homogeneous) kind: (~#) k k ty1 ty2
mkNomPrimEqPred :: Kind -> Type -> Type -> Type

-- | If `instNewTyCon_maybe T ts = Just (rep_ty, co)` then `co :: T ts ~R#
--   rep_ty`
--   
--   Checks for a newtype, and for being saturated
instNewTyCon_maybe :: TyCon -> [Type] -> Maybe (Type, Coercion)

-- | A function to check if we can reduce a type by one step. Used with
--   <a>topNormaliseTypeX</a>.
type NormaliseStepper ev = RecTcChecker -> TyCon -> [Type] -> NormaliseStepResult ev

-- | The result of stepping in a normalisation function. See
--   <a>topNormaliseTypeX</a>.
data NormaliseStepResult ev

-- | Nothing more to do
NS_Done :: NormaliseStepResult ev

-- | Utter failure. The outer function should fail too.
NS_Abort :: NormaliseStepResult ev

-- | We stepped, yielding new bits; ^ ev is evidence; Usually a co :: old
--   type ~ new type
NS_Step :: RecTcChecker -> Type -> ev -> NormaliseStepResult ev

-- | Try one stepper and then try the next, if the first doesn't make
--   progress. So if it returns NS_Done, it means that both steppers are
--   satisfied
composeSteppers :: NormaliseStepper ev -> NormaliseStepper ev -> NormaliseStepper ev

-- | A <a>NormaliseStepper</a> that unwraps newtypes, careful not to fall
--   into a loop. If it would fall into a loop, it produces
--   <a>NS_Abort</a>.
unwrapNewTypeStepper :: NormaliseStepper Coercion

-- | Sometimes we want to look through a <tt>newtype</tt> and get its
--   associated coercion. This function strips off <tt>newtype</tt> layers
--   enough to reveal something that isn't a <tt>newtype</tt>.
--   Specifically, here's the invariant:
--   
--   <pre>
--   topNormaliseNewType_maybe rec_nts ty = Just (co, ty')
--   </pre>
--   
--   then (a) <tt>co : ty ~R ty'</tt>. (b) ty' is not a newtype.
--   
--   The function returns <tt>Nothing</tt> for non-<tt>newtypes</tt>, or
--   unsaturated applications
--   
--   This function does *not* look through type families, because it has no
--   access to the type family environment. If you do have that at hand,
--   consider to use topNormaliseType_maybe, which should be a drop-in
--   replacement for topNormaliseNewType_maybe If topNormliseNewType_maybe
--   ty = Just (co, ty'), then co : ty ~R ty'
topNormaliseNewType_maybe :: Type -> Maybe (Coercion, Type)

-- | A general function for normalising the top-level of a type. It
--   continues to use the provided <a>NormaliseStepper</a> until that
--   function fails, and then this function returns. The roles of the
--   coercions produced by the <a>NormaliseStepper</a> must all be the
--   same, which is the role returned from the call to
--   <a>topNormaliseTypeX</a>.
--   
--   Typically ev is Coercion.
--   
--   If topNormaliseTypeX step plus ty = Just (ev, ty') then ty ~ev1~ t1
--   ~ev2~ t2 ... ~evn~ ty' and ev = ev1 <tt>plus</tt> ev2 <tt>plus</tt>
--   ... <tt>plus</tt> evn If it returns Nothing then no newtype unwrapping
--   could happen
topNormaliseTypeX :: NormaliseStepper ev -> (ev -> ev -> ev) -> Type -> Maybe (ev, Type)

-- | This breaks a <a>Coercion</a> with type <tt>T A B C ~ T D E F</tt>
--   into a list of <a>Coercion</a>s of kinds <tt>A ~ D</tt>, <tt>B ~
--   E</tt> and <tt>E ~ F</tt>. Hence:
--   
--   <pre>
--   decomposeCo 3 c [r1, r2, r3] = [nth r1 0 c, nth r2 1 c, nth r3 2 c]
--   </pre>
decomposeCo :: Arity -> Coercion -> Infinite Role -> [Coercion]
decomposeFunCo :: HasDebugCallStack => Coercion -> (CoercionN, Coercion, Coercion)
decomposePiCos :: HasDebugCallStack => CoercionN -> Pair Type -> [Type] -> ([CoercionN], CoercionN)

-- | Extract a covar, if possible. This check is dirty. Be ashamed of
--   yourself. (It's dirty because it cares about the structure of a
--   coercion, which is morally reprehensible.)
getCoVar_maybe :: Coercion -> Maybe CoVar

-- | Attempt to take a coercion application apart.
splitAppCo_maybe :: Coercion -> Maybe (Coercion, Coercion)
splitFunCo_maybe :: Coercion -> Maybe (Coercion, Coercion)
splitForAllCo_maybe :: Coercion -> Maybe (TyCoVar, ForAllTyFlag, ForAllTyFlag, Coercion, Coercion)

-- | Like <a>splitForAllCo_maybe</a>, but only returns Just for tyvar
--   binder
splitForAllCo_ty_maybe :: Coercion -> Maybe (TyVar, ForAllTyFlag, ForAllTyFlag, Coercion, Coercion)

-- | Like <a>splitForAllCo_maybe</a>, but only returns Just for covar
--   binder
splitForAllCo_co_maybe :: Coercion -> Maybe (CoVar, ForAllTyFlag, ForAllTyFlag, Coercion, Coercion)
tyConRole :: Role -> TyCon -> Int -> Role
tyConRolesX :: Role -> TyCon -> Infinite Role
tyConRolesRepresentational :: TyCon -> Infinite Role

-- | Converts a coercion to be nominal, if possible. See Note [Role
--   twiddling functions]
setNominalRole_maybe :: Role -> Coercion -> Maybe CoercionN
tyConRoleListX :: Role -> TyCon -> [Role]
tyConRoleListRepresentational :: TyCon -> [Role]
funRole :: Role -> FunSel -> Role
pickLR :: LeftOrRight -> (a, a) -> a

-- | Tests if this coercion is obviously a generalized reflexive coercion.
--   Guaranteed to work very quickly.
isGReflCo :: Coercion -> Bool

-- | Tests if this coercion is obviously reflexive. Guaranteed to work very
--   quickly. Sometimes a coercion can be reflexive, but not obviously so.
--   c.f. <a>isReflexiveCo</a>
isReflCo :: Coercion -> Bool

-- | Returns the type coerced if this coercion is reflexive. Guaranteed to
--   work very quickly. Sometimes a coercion can be reflexive, but not
--   obviously so. c.f. <a>isReflexiveCo_maybe</a>
isReflCo_maybe :: Coercion -> Maybe (Type, Role)

-- | Returns the type coerced if this coercion is a generalized reflexive
--   coercion. Guaranteed to work very quickly.
isGReflCo_maybe :: Coercion -> Maybe (Type, Role)

-- | Slowly checks if the coercion is reflexive. Don't call this in a loop,
--   as it walks over the entire coercion.
isReflexiveCo :: Coercion -> Bool

-- | Extracts the coerced type from a reflexive coercion. This potentially
--   walks over the entire coercion, so avoid doing this in a loop.
isReflexiveCo_maybe :: Coercion -> Maybe (Type, Role)
isReflCoVar_maybe :: Var -> Maybe Coercion

-- | Tests if this MCoercion is obviously generalized reflexive Guaranteed
--   to work very quickly.
isGReflMCo :: MCoercion -> Bool
mkGReflLeftMCo :: Role -> Type -> MCoercionN -> Coercion
mkGReflRightMCo :: Role -> Type -> MCoercionN -> Coercion

-- | Like <a>mkCoherenceRightCo</a>, but with an <a>MCoercion</a>
mkCoherenceRightMCo :: Role -> Type -> MCoercionN -> Coercion -> Coercion
coToMCo :: Coercion -> MCoercion

-- | Compose two MCoercions via transitivity
mkTransMCo :: MCoercion -> MCoercion -> MCoercion
mkTransMCoL :: MCoercion -> Coercion -> MCoercion
mkTransMCoR :: Coercion -> MCoercion -> MCoercion

-- | Cast a type by an <a>MCoercion</a>
mkCastTyMCo :: Type -> MCoercion -> Type

-- | Get the reverse of an <a>MCoercion</a>
mkSymMCo :: MCoercion -> MCoercion
mkFunResMCo :: Id -> MCoercionR -> MCoercionR
mkPiMCos :: [Var] -> MCoercion -> MCoercion
isReflMCo :: MCoercion -> Bool
checkReflexiveMCo :: MCoercion -> MCoercion
mkCoVar :: Name -> Type -> CoVar

-- | Is this a coercion variable? Satisfies <tt><a>isId</a> v ==&gt;
--   <a>isCoVar</a> v == not (<a>isNonCoVarId</a> v)</tt>.
isCoVar :: Var -> Bool
coVarName :: CoVar -> Name
setCoVarName :: CoVar -> Name -> CoVar
setCoVarUnique :: CoVar -> Unique -> CoVar
tyCoVarsOfCo :: Coercion -> TyCoVarSet
tyCoVarsOfCos :: [Coercion] -> TyCoVarSet
coVarsOfCo :: Coercion -> CoVarSet
tyCoFVsOfCo :: Coercion -> FV
tyCoFVsOfCos :: [Coercion] -> FV

-- | Get a deterministic set of the vars free in a coercion
tyCoVarsOfCoDSet :: Coercion -> DTyCoVarSet
coercionSize :: Coercion -> Int
anyFreeVarsOfCo :: (TyCoVar -> Bool) -> Coercion -> Bool

-- | A substitution of <a>Coercion</a>s for <a>CoVar</a>s
type CvSubstEnv = CoVarEnv Coercion
emptyCvSubstEnv :: CvSubstEnv
lookupCoVar :: Subst -> Var -> Maybe Coercion

-- | Substitute within a <a>Coercion</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substCo :: HasDebugCallStack => Subst -> Coercion -> Coercion

-- | Substitute within several <a>Coercion</a>s The substitution has to
--   satisfy the invariants described in Note [The substitution invariant].
substCos :: HasDebugCallStack => Subst -> [Coercion] -> [Coercion]
substCoVar :: Subst -> CoVar -> Coercion
substCoVars :: Subst -> [CoVar] -> [Coercion]

-- | Coercion substitution, see <a>zipTvSubst</a>
substCoWith :: HasDebugCallStack => [TyVar] -> [Type] -> Coercion -> Coercion
substCoVarBndr :: HasDebugCallStack => Subst -> CoVar -> (Subst, CoVar)
extendTvSubstAndInScope :: Subst -> TyVar -> Type -> Subst
getCvSubstEnv :: Subst -> CvSubstEnv

-- | <tt>liftCoSubst role lc ty</tt> produces a coercion (at role
--   <tt>role</tt>) that coerces between <tt>lc_left(ty)</tt> and
--   <tt>lc_right(ty)</tt>, where <tt>lc_left</tt> is a substitution
--   mapping type variables to the left-hand types of the mapped coercions
--   in <tt>lc</tt>, and similar for <tt>lc_right</tt>.
liftCoSubst :: HasDebugCallStack => Role -> LiftingContext -> Type -> Coercion
liftCoSubstTyVar :: LiftingContext -> Role -> TyVar -> Maybe Coercion
liftCoSubstWith :: Role -> [TyCoVar] -> [Coercion] -> Type -> Coercion
liftCoSubstWithEx :: Role -> [TyVar] -> [Coercion] -> [TyCoVar] -> [Type] -> (Type -> Coercion, [Type])
emptyLiftingContext :: InScopeSet -> LiftingContext

-- | Extend a lifting context with a new mapping.
extendLiftingContext :: LiftingContext -> TyCoVar -> Coercion -> LiftingContext

-- | Extend a lifting context with a new mapping, and extend the in-scope
--   set
extendLiftingContextAndInScope :: LiftingContext -> TyCoVar -> Coercion -> LiftingContext
liftCoSubstVarBndrUsing :: (r -> CoercionN) -> (LiftingContext -> Type -> r) -> LiftingContext -> TyCoVar -> (LiftingContext, TyCoVar, r)

-- | Is a var in the domain of a lifting context?
isMappedByLC :: TyCoVar -> LiftingContext -> Bool

-- | Extend the substitution component of a lifting context with a new
--   binding for a coercion variable. Used during coercion optimisation.
extendLiftingContextCvSubst :: LiftingContext -> CoVar -> Coercion -> LiftingContext
mkSubstLiftingContext :: Subst -> LiftingContext
liftingContextSubst :: LiftingContext -> Subst

-- | Erase the environments in a lifting context
zapLiftingContext :: LiftingContext -> LiftingContext

-- | Like <a>substForAllCoBndr</a>, but works on a lifting context
substForAllCoBndrUsingLC :: SwapFlag -> (Coercion -> Coercion) -> LiftingContext -> TyCoVar -> Coercion -> (LiftingContext, TyCoVar, Coercion)

-- | Lookup a <a>CoVar</a> in the substitution in a <a>LiftingContext</a>
lcLookupCoVar :: LiftingContext -> CoVar -> Maybe Coercion

-- | Get the <a>InScopeSet</a> from a <a>LiftingContext</a>
lcInScopeSet :: LiftingContext -> InScopeSet
type LiftCoEnv = VarEnv Coercion
data LiftingContext
LC :: Subst -> LiftCoEnv -> LiftingContext
liftEnvSubstLeft :: Subst -> LiftCoEnv -> Subst
liftEnvSubstRight :: Subst -> LiftCoEnv -> Subst
substRightCo :: LiftingContext -> Coercion -> Coercion
substLeftCo :: LiftingContext -> Coercion -> Coercion

-- | Apply "sym" to all coercions in a <a>LiftCoEnv</a>
swapLiftCoEnv :: LiftCoEnv -> LiftCoEnv
lcSubstLeft :: LiftingContext -> Subst
lcSubstRight :: LiftingContext -> Subst

-- | Syntactic equality of coercions
eqCoercion :: Coercion -> Coercion -> Bool

-- | Compare two <a>Coercion</a>s, with respect to an RnEnv2
eqCoercionX :: RnEnv2 -> Coercion -> Coercion -> Bool
seqCo :: Coercion -> ()
pprCo :: Coercion -> SDoc
pprParendCo :: Coercion -> SDoc
pprCoAxiom :: forall (br :: BranchFlag). CoAxiom br -> SDoc
pprCoAxBranch :: TyCon -> CoAxBranch -> SDoc
pprCoAxBranchLHS :: TyCon -> CoAxBranch -> SDoc
pprCoAxBranchUser :: TyCon -> CoAxBranch -> SDoc
tidyCoAxBndrsForUser :: TidyEnv -> [Var] -> (TidyEnv, [Var])
etaExpandCoAxBranch :: CoAxBranch -> ([TyVar], [Type], Type)

-- | Tidy a Coercion
--   
--   See Note [Strictness in tidyType and friends]
tidyCo :: TidyEnv -> Coercion -> Coercion
tidyCos :: TidyEnv -> [Coercion] -> [Coercion]

-- | like mkKindCo, but aggressively &amp; recursively optimizes to avoid
--   using a KindCo constructor. The output role is nominal.
promoteCoercion :: HasDebugCallStack => Coercion -> CoercionN

-- | Assuming that two types are the same, ignoring coercions, find a
--   nominal coercion between the types. This is useful when optimizing
--   transitivity over coercion applications, where splitting two AppCos
--   might yield different kinds. See Note [EtaAppCo] in
--   <a>GHC.Core.Coercion.Opt</a>.
buildCoercion :: HasDebugCallStack => Type -> Type -> CoercionN
multToCo :: Mult -> Coercion

-- | Given a coercion `co :: (t1 :: TYPE r1) ~ (t2 :: TYPE r2)` produce a
--   coercion `rep_co :: r1 ~ r2` But actually it is possible that co ::
--   (t1 :: CONSTRAINT r1) ~ (t2 :: CONSTRAINT r2) or co :: (t1 :: TYPE r1)
--   ~ (t2 :: CONSTRAINT r2) or co :: (t1 :: CONSTRAINT r1) ~ (t2 :: TYPE
--   r2) See Note [mkRuntimeRepCo]
mkRuntimeRepCo :: HasDebugCallStack => Coercion -> Coercion

-- | Is there a hetero-kind coercion hole in this type? (That is, a
--   coercion hole with ch_hetero_kind=True.) See wrinkle (EIK2) of Note
--   [Equalities with incompatible kinds] in GHC.Tc.Solver.Equality
hasCoercionHoleTy :: Type -> Bool

-- | Is there a hetero-kind coercion hole in this coercion?
hasCoercionHoleCo :: Coercion -> Bool
hasThisCoercionHoleTy :: Type -> CoercionHole -> Bool

-- | Set the type of a <a>CoercionHole</a>
setCoHoleType :: CoercionHole -> Type -> CoercionHole
instance GHC.Internal.Base.Functor GHC.Core.Coercion.NormaliseStepResult
instance GHC.Utils.Outputable.Outputable GHC.Core.Coercion.LiftingContext
instance GHC.Utils.Outputable.Outputable ev => GHC.Utils.Outputable.Outputable (GHC.Core.Coercion.NormaliseStepResult ev)

module GHC.Core.Predicate

-- | A predicate in the solver. The solver tries to prove Wanted predicates
--   from Given ones.
data Pred

-- | A typeclass predicate.
ClassPred :: Class -> [Type] -> Pred

-- | A type equality predicate, (t1 ~#N t2) or (t1 ~#R t2)
EqPred :: EqRel -> Type -> Type -> Pred

-- | An irreducible predicate.
IrredPred :: PredType -> Pred

-- | A quantified predicate.
--   
--   See Note [Quantified constraints] in GHC.Tc.Solver.Solve
ForAllPred :: [TyVar] -> [PredType] -> PredType -> Pred
classifyPredType :: PredType -> Pred
isPredTy :: HasDebugCallStack => Type -> Bool
isEvVarType :: Type -> Bool

-- | A choice of equality relation. This is separate from the type
--   <a>Role</a> because <a>Phantom</a> does not define a (non-trivial)
--   equality relation.
data EqRel
NomEq :: EqRel
ReprEq :: EqRel
eqRelRole :: EqRel -> Role
isEqPrimPred :: PredType -> Bool
isNomEqPred :: PredType -> Bool
isReprEqPrimPred :: PredType -> Bool
isEqPred :: PredType -> Bool

-- | Does this type classify a core (unlifted) Coercion? At either role
--   nominal or representational (t1 ~# t2) or (t1 ~R# t2) See Note [Types
--   for coercions, predicates, and evidence] in <a>GHC.Core.TyCo.Rep</a>
isCoVarType :: Type -> Bool
getEqPredTys :: PredType -> (Type, Type)
getEqPredTys_maybe :: PredType -> Maybe (Role, Type, Type)
getEqPredRole :: PredType -> Role

-- | Get the equality relation relevant for a pred type Returns NomEq for
--   dictionary predicates, etc
predTypeEqRel :: PredType -> EqRel

-- | Creates a primitive nominal type equality predicate. t1 ~# t2
--   Invariant: the types are not Coercions
mkPrimEqPred :: Type -> Type -> Type

-- | Creates a primitive representational type equality predicate. t1 ~R#
--   t2 Invariant: the types are not Coercions
mkReprPrimEqPred :: Type -> Type -> Type

-- | Makes a lifted equality predicate at the given role
mkPrimEqPredRole :: Role -> Type -> Type -> PredType

-- | Creates a primitive nominal type equality predicate with an explicit
--   (but homogeneous) kind: (~#) k k ty1 ty2
mkNomPrimEqPred :: Kind -> Type -> Type -> Type
mkClassPred :: Class -> [Type] -> PredType
isDictTy :: Type -> Bool
typeDeterminesValue :: Type -> Bool
isClassPred :: PredType -> Bool
isEqualityClass :: Class -> Bool
isCTupleClass :: Class -> Bool
getClassPredTys :: HasDebugCallStack => PredType -> (Class, [Type])
getClassPredTys_maybe :: PredType -> Maybe (Class, [Type])
classMethodTy :: Id -> Type
classMethodInstTy :: Id -> [Type] -> Type
isIPLikePred :: Type -> Bool
mentionsIP :: Type -> Class -> [Type] -> Bool
isIPTyCon :: TyCon -> Bool
isIPClass :: Class -> Bool

-- | Is a type a <tt>CallStack</tt>?
isCallStackTy :: Type -> Bool

-- | Is a <a>PredType</a> a <tt>CallStack</tt> implicit parameter?
--   
--   If so, return the name of the parameter.
isCallStackPred :: Class -> [Type] -> Maybe FastString
isCallStackPredTy :: Type -> Bool

-- | Is a <a>PredType</a> an <tt>ExceptionContext</tt> implicit parameter?
--   
--   If so, return the name of the parameter.
isExceptionContextPred :: Class -> [Type] -> Maybe FastString

-- | Decomposes a predicate if it is an implicit parameter. Does not look
--   in superclasses. See also [Local implicit parameters].
isIPPred_maybe :: Class -> [Type] -> Maybe (Type, Type)

-- | Dictionary Identifier
type DictId = EvId
isEvVar :: Var -> Bool
isDictId :: Id -> Bool
instance GHC.Classes.Eq GHC.Core.Predicate.EqRel
instance GHC.Classes.Ord GHC.Core.Predicate.EqRel
instance GHC.Utils.Outputable.Outputable GHC.Core.Predicate.EqRel

module GHC.Core.Reduction

-- | A <a>Reduction</a> is the result of an operation that rewrites a type
--   <tt>ty_in</tt>. The <a>Reduction</a> includes the rewritten type
--   <tt>ty_out</tt> and a <a>Coercion</a> <tt>co</tt> such that <tt>co ::
--   ty_in ~ ty_out</tt>, where the role of the coercion is determined by
--   the context. That is, the LHS type of the coercion is the original
--   type <tt>ty_in</tt>, while its RHS type is the rewritten type
--   <tt>ty_out</tt>.
--   
--   A Reduction is always homogeneous, unless it is wrapped inside a
--   <a>HetReduction</a>, which separately stores the kind coercion.
--   
--   See Note [The Reduction type].
data Reduction
Reduction :: Coercion -> !Type -> Reduction
[reductionCoercion] :: Reduction -> Coercion
[reductionReducedType] :: Reduction -> !Type

-- | A <a>Reduction</a> in which the <a>Coercion</a> has <a>Nominal</a>
--   role.
type ReductionN = Reduction

-- | A <a>Reduction</a> in which the <a>Coercion</a> has
--   <a>Representational</a> role.
type ReductionR = Reduction

-- | Stores a heterogeneous reduction.
--   
--   The stored kind coercion must relate the kinds of the stored
--   reduction. That is, in <tt>HetReduction (Reduction co xi) kco</tt>, we
--   must have:
--   
--   <pre>
--    co :: ty ~ xi
--   kco :: typeKind ty ~ typeKind xi
--   </pre>
data HetReduction
HetReduction :: Reduction -> MCoercionN -> HetReduction

-- | A collection of <a>Reduction</a>s where the coercions and the types
--   are stored separately.
--   
--   Use <a>unzipRedns</a> to obtain <a>Reductions</a> from a list of
--   <a>Reduction</a>s.
--   
--   This datatype is used in <a>mkAppRedns</a>, <tt>mkClassPredRedns</tt>
--   and <a>mkTyConAppRedn</a>, which expect separate types and coercions.
--   
--   Invariant: the two stored lists are of the same length, and the RHS
--   type of each coercion is the corresponding type.
data Reductions
Reductions :: [Coercion] -> [Type] -> Reductions

-- | Create a <a>Reduction</a> from a pair of a <a>Coercion</a> and a
--   'Type.
--   
--   Pre-condition: the RHS type of the coercion matches the provided type
--   (perhaps up to zonking).
--   
--   Use <a>coercionRedn</a> when you only have the coercion.
mkReduction :: Coercion -> Type -> Reduction

-- | Create <a>Reductions</a> from individual lists of coercions and types.
--   
--   The lists should be of the same length, and the RHS type of each
--   coercion should match the specified type in the other list.
mkReductions :: [Coercion] -> [Type] -> Reductions

-- | Create a heterogeneous reduction.
--   
--   Pre-condition: the provided kind coercion (second argument) relates
--   the kinds of the stored reduction. That is, if the coercion stored in
--   the <a>Reduction</a> is of the form
--   
--   <pre>
--   co :: ty ~ xi
--   </pre>
--   
--   Then the kind coercion supplied must be of the form:
--   
--   <pre>
--   kco :: typeKind ty ~ typeKind xi
--   </pre>
mkHetReduction :: Reduction -> MCoercionN -> HetReduction

-- | Turn a <a>Coercion</a> into a <a>Reduction</a> by inspecting the RHS
--   type of the coercion.
--   
--   Prefer using <a>mkReduction</a> when you already know the RHS type of
--   the coercion, to avoid computing it anew.
coercionRedn :: Coercion -> Reduction

-- | Get the original, unreduced type corresponding to a <a>Reduction</a>.
--   
--   This is obtained by computing the LHS kind of the stored coercion,
--   which may be slow.
reductionOriginalType :: Reduction -> Type

-- | Downgrade the role of the coercion stored in the <a>Reduction</a>.
downgradeRedn :: Role -> Role -> Reduction -> Reduction

-- | Downgrade the role of the coercion stored in the <a>Reduction</a>,
--   from <a>Nominal</a> to <a>Representational</a>.
mkSubRedn :: Reduction -> Reduction

-- | Compose a reduction with a coercion on the left.
--   
--   Pre-condition: the provided coercion's RHS type must match the LHS
--   type of the coercion that is stored in the reduction.
mkTransRedn :: Coercion -> Reduction -> Reduction

-- | Apply a cast to the result of a <a>Reduction</a>.
--   
--   Given a <a>Reduction</a> <tt>ty1 ~co1~&gt; (ty2 :: k2)</tt> and a kind
--   coercion <tt>kco</tt> with LHS kind <tt>k2</tt>, produce a new
--   <a>Reduction</a> <tt>ty1 ~co2~&gt; ( ty2 |&gt; kco )</tt> of the given
--   <a>Role</a> (which must match the role of the coercion stored in the
--   <a>Reduction</a> argument).
mkCoherenceRightRedn :: Role -> Reduction -> CoercionN -> Reduction

-- | Apply a cast to the result of a <a>Reduction</a>, using an
--   <a>MCoercionN</a>.
--   
--   Given a <a>Reduction</a> <tt>ty1 ~co1~&gt; (ty2 :: k2)</tt> and a kind
--   coercion <tt>mco</tt> with LHS kind <tt>k2</tt>, produce a new
--   <a>Reduction</a> <tt>ty1 ~co2~&gt; ( ty2 |&gt; mco )</tt> of the given
--   <a>Role</a> (which must match the role of the coercion stored in the
--   <a>Reduction</a> argument).
mkCoherenceRightMRedn :: Role -> Reduction -> MCoercionN -> Reduction

-- | Apply a cast to a <a>Reduction</a>, casting both the original and the
--   reduced type.
--   
--   Given <tt>cast_co</tt> and <a>Reduction</a> <tt>ty ~co~&gt; xi</tt>,
--   this function returns the <a>Reduction</a> <tt>(ty |&gt; cast_co)
--   ~return_co~&gt; (xi |&gt; cast_co)</tt> of the given <a>Role</a>
--   (which must match the role of the coercion stored in the
--   <a>Reduction</a> argument).
--   
--   Pre-condition: the <a>Type</a> passed in is the same as the LHS type
--   of the coercion stored in the <a>Reduction</a>.
mkCastRedn1 :: Role -> Type -> CoercionN -> Reduction -> Reduction

-- | Apply casts on both sides of a <a>Reduction</a> (of the given
--   <a>Role</a>).
--   
--   Use <a>mkCastRedn1</a> when you want to cast both the original and
--   reduced types in a <a>Reduction</a> using the same coercion.
--   
--   Pre-condition: the <a>Type</a> passed in is the same as the LHS type
--   of the coercion stored in the <a>Reduction</a>.
mkCastRedn2 :: Role -> Type -> CoercionN -> Reduction -> CoercionN -> Reduction

-- | The reflexive reduction.
mkReflRedn :: Role -> Type -> Reduction

-- | Create a <a>Reduction</a> from a kind cast, in which the casted type
--   is the rewritten type.
--   
--   Given <tt>ty :: k1</tt>, <tt>mco :: k1 ~ k2</tt>, produces the
--   <a>Reduction</a> <tt>ty ~res_co~&gt; (ty |&gt; mco)</tt> at the given
--   <a>Role</a>.
mkGReflRightRedn :: Role -> Type -> CoercionN -> Reduction

-- | Create a <a>Reduction</a> from a kind cast, in which the casted type
--   is the rewritten type.
--   
--   Given <tt>ty :: k1</tt>, <tt>mco :: k1 ~ k2</tt>, produces the
--   <a>Reduction</a> <tt>ty ~res_co~&gt; (ty |&gt; mco)</tt> at the given
--   <a>Role</a>.
mkGReflRightMRedn :: Role -> Type -> MCoercionN -> Reduction

-- | Create a <a>Reduction</a> from a kind cast, in which the casted type
--   is the original (non-rewritten) type.
--   
--   Given <tt>ty :: k1</tt>, <tt>mco :: k1 ~ k2</tt>, produces the
--   <a>Reduction</a> <tt>(ty |&gt; mco) ~res_co~&gt; ty</tt> at the given
--   <a>Role</a>.
mkGReflLeftRedn :: Role -> Type -> CoercionN -> Reduction

-- | Create a <a>Reduction</a> from a kind cast, in which the casted type
--   is the original (non-rewritten) type.
--   
--   Given <tt>ty :: k1</tt>, <tt>mco :: k1 ~ k2</tt>, produces the
--   <a>Reduction</a> <tt>(ty |&gt; mco) ~res_co~&gt; ty</tt> at the given
--   <a>Role</a>.
mkGReflLeftMRedn :: Role -> Type -> MCoercionN -> Reduction

-- | Apply one <a>Reduction</a> to another.
--   
--   Combines <a>mkAppCo</a> and <tt>mkAppTy</tt>.
mkAppRedn :: Reduction -> Reduction -> Reduction

-- | Combines <a>mkAppCos</a> and <a>mkAppTys</a>.
mkAppRedns :: Reduction -> Reductions -> Reduction

-- | Create a function <a>Reduction</a>.
--   
--   Combines <a>mkFunCo</a> and <a>mkFunTy</a>.
mkFunRedn :: Role -> FunTyFlag -> ReductionN -> Reduction -> Reduction -> Reduction

-- | Create a <a>Reduction</a> associated to a Π type, from a kind
--   <a>Reduction</a> and a body <a>Reduction</a>.
--   
--   Combines <a>mkForAllCo</a> and <a>mkForAllTy</a>.
mkForAllRedn :: ForAllTyFlag -> TyVar -> ReductionN -> Reduction -> Reduction

-- | Create a <a>Reduction</a> of a quantified type from a <a>Reduction</a>
--   of the body.
--   
--   Combines <a>mkHomoForAllCos</a> and <a>mkForAllTys</a>.
mkHomoForAllRedn :: [TyVarBinder] -> Reduction -> Reduction

-- | <tt>TyConAppCo</tt> for <a>Reduction</a>s: combines
--   <a>mkTyConAppCo</a> and <a>mkTyConApp</a>.
mkTyConAppRedn :: Role -> TyCon -> Reductions -> Reduction

-- | Reduce the arguments of a <a>Class</a> <a>TyCon</a>.
mkClassPredRedn :: Class -> Reductions -> Reduction

-- | Create a <a>Reduction</a> from a coercion between coercions.
--   
--   Combines <a>mkProofIrrelCo</a> and <a>mkCoercionTy</a>.
mkProofIrrelRedn :: Role -> CoercionN -> Coercion -> Coercion -> Reduction

-- | Create a reflexive <a>Reduction</a> whose RHS is the given
--   <a>Coercion</a>, with the specified <a>Role</a>.
mkReflCoRedn :: Role -> Coercion -> Reduction

-- | Homogenise a heterogeneous reduction.
--   
--   Given <tt>HetReduction (Reduction co xi) kco</tt>, with
--   
--   <pre>
--    co :: ty ~ xi
--   kco :: typeKind(ty) ~ typeKind(xi)
--   </pre>
--   
--   this returns the homogeneous reduction:
--   
--   <pre>
--   hco :: ty ~ ( xi |&gt; sym kco )
--   </pre>
homogeniseHetRedn :: Role -> HetReduction -> Reduction

-- | Obtain <a>Reductions</a> from a list of <a>Reduction</a>s by
--   unzipping.
unzipRedns :: [Reduction] -> Reductions

-- | Stores <a>Reductions</a> as well as a kind coercion.
--   
--   Used when rewriting arguments to a type function <tt>f</tt>.
--   
--   Invariant: when the stored reductions are of the form co_i :: ty_i ~
--   xi_i, the kind coercion is of the form kco :: typeKind (f ty_1 ...
--   ty_n) ~ typeKind (f xi_1 ... xi_n)
--   
--   The type function <tt>f</tt> depends on context.
data ArgsReductions
ArgsReductions :: {-# UNPACK #-} !Reductions -> !MCoercionN -> ArgsReductions
simplifyArgsWorker :: HasDebugCallStack => [PiTyBinder] -> Kind -> TyCoVarSet -> Infinite Role -> [Reduction] -> ArgsReductions
instance GHC.Utils.Outputable.Outputable GHC.Core.Reduction.Reduction

module GHC.Core.Map.Type
class Functor m => TrieMap (m :: Type -> Type) where {
    type Key (m :: Type -> Type);
}
emptyTM :: TrieMap m => m a
lookupTM :: TrieMap m => Key m -> m b -> Maybe b
alterTM :: TrieMap m => Key m -> XT b -> m b -> m b
filterTM :: TrieMap m => (a -> Bool) -> m a -> m a
foldTM :: TrieMap m => (a -> b -> b) -> m a -> b -> b
type XT a = Maybe a -> Maybe a

-- | <tt>TypeMap a</tt> is a map from <a>Type</a> to <tt>a</tt>. If you are
--   a client, this is the type you want. The keys in this map may have
--   different kinds.
data TypeMap a
emptyTypeMap :: TypeMap a
extendTypeMap :: TypeMap a -> Type -> a -> TypeMap a
lookupTypeMap :: TypeMap a -> Type -> Maybe a
foldTypeMap :: (a -> b -> b) -> b -> TypeMap a -> b

-- | A <a>LooseTypeMap</a> doesn't do a kind-check. Thus, when lookup up (t
--   |&gt; g), you'll find entries inserted under (t), even if (g) is
--   non-reflexive.
data LooseTypeMap a
data CmEnv
lookupCME :: CmEnv -> Var -> Maybe BoundVar

-- | Extend a <a>TypeMap</a> with a type in the given context.
--   <tt>extendTypeMapWithScope m (mkDeBruijnContext [a,b,c]) t v</tt> is
--   equivalent to <tt>extendTypeMap m (forall a b c. t) v</tt>, but allows
--   reuse of the context over multiple insertions.
extendTypeMapWithScope :: TypeMap a -> CmEnv -> Type -> a -> TypeMap a
lookupTypeMapWithScope :: TypeMap a -> CmEnv -> Type -> Maybe a

-- | Construct a deBruijn environment with the given variables in scope.
--   e.g. <tt>mkDeBruijnEnv [a,b,c]</tt> constructs a context <tt>forall a
--   b c.</tt>
mkDeBruijnContext :: [Var] -> CmEnv
extendCME :: CmEnv -> Var -> CmEnv
extendCMEs :: CmEnv -> [Var] -> CmEnv
emptyCME :: CmEnv

-- | <tt>TypeMapG a</tt> is a map from <tt>DeBruijn Type</tt> to
--   <tt>a</tt>. The extended key makes it suitable for recursive
--   traversal, since it can track binders, but it is strictly internal to
--   this module. If you are including a <a>TypeMap</a> inside another
--   <a>TrieMap</a>, this is the type you want. Note that this lookup does
--   not do a kind-check. Thus, all keys in this map must have the same
--   kind. Also note that this map respects the distinction between
--   <tt>Type</tt> and <tt>Constraint</tt>, despite the fact that they are
--   equivalent type synonyms in Core.
type TypeMapG = GenMap TypeMapX
type CoercionMapG = GenMap CoercionMapX

-- | <tt>DeBruijn a</tt> represents <tt>a</tt> modulo alpha-renaming. This
--   is achieved by equipping the value with a <a>CmEnv</a>, which tracks
--   an on-the-fly deBruijn numbering. This allows us to define an
--   <a>Eq</a> instance for <tt>DeBruijn a</tt>, even if this was not
--   (easily) possible for <tt>a</tt>. Note: we purposely don't export the
--   constructor. Make a helper function if you find yourself needing it.
data DeBruijn a
D :: CmEnv -> a -> DeBruijn a

-- | Synthesizes a <tt>DeBruijn a</tt> from an <tt>a</tt>, by assuming that
--   there are no bound binders (an empty <a>CmEnv</a>). This is usually
--   what you want if there isn't already a <a>CmEnv</a> in scope.
deBruijnize :: a -> DeBruijn a
eqDeBruijnType :: DeBruijn Type -> DeBruijn Type -> Bool
eqDeBruijnVar :: DeBruijn Var -> DeBruijn Var -> Bool

-- | A <a>BndrMap</a> is a <a>TypeMapG</a> which allows us to distinguish
--   between binding forms whose binders have different types. For example,
--   if we are doing a <a>TrieMap</a> lookup on <tt>(x :: Int) -&gt;
--   ()</tt>, we should not pick up an entry in the <a>TrieMap</a> for
--   <tt>(x :: Bool) -&gt; ()</tt>: we can disambiguate this by matching on
--   the type (or kind, if this a binder in a type) of the binder.
--   
--   We also need to do the same for multiplicity! Which, since
--   multiplicities are encoded simply as a <a>Type</a>, amounts to have a
--   Trie for a pair of types. Tries of pairs are composition.
data BndrMap a
xtBndr :: CmEnv -> Var -> XT a -> BndrMap a -> BndrMap a
lkBndr :: CmEnv -> Var -> BndrMap a -> Maybe a
data VarMap a
xtVar :: CmEnv -> Var -> XT a -> VarMap a -> VarMap a
lkVar :: CmEnv -> Var -> VarMap a -> Maybe a
lkDFreeVar :: Var -> DVarEnv a -> Maybe a
xtDFreeVar :: Var -> XT a -> DVarEnv a -> DVarEnv a
xtDNamed :: NamedThing n => n -> XT a -> DNameEnv a -> DNameEnv a
lkDNamed :: NamedThing n => n -> DNameEnv a -> Maybe a
instance GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn GHC.Core.TyCo.Rep.Coercion)
instance GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn GHC.Core.TyCo.Rep.Type)
instance GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn GHC.Types.Var.Var)
instance GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn a) => GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn [a])
instance GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn a) => GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn (GHC.Internal.Maybe.Maybe a))
instance GHC.Internal.Base.Functor GHC.Core.Map.Type.BndrMap
instance GHC.Internal.Base.Functor GHC.Core.Map.Type.CoercionMap
instance GHC.Internal.Base.Functor GHC.Core.Map.Type.CoercionMapX
instance GHC.Internal.Base.Functor GHC.Core.Map.Type.LooseTypeMap
instance GHC.Internal.Base.Functor GHC.Core.Map.Type.TyLitMap
instance GHC.Internal.Base.Functor GHC.Core.Map.Type.TypeMap
instance GHC.Internal.Base.Functor GHC.Core.Map.Type.TypeMapX
instance GHC.Internal.Base.Functor GHC.Core.Map.Type.VarMap
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Core.Map.Type.TypeMapG a)
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.BndrMap
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.CoercionMap
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.CoercionMapX
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.LooseTypeMap
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.TyLitMap
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.TypeMap
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.TypeMapX
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.VarMap

module GHC.Core.Unify

-- | <tt>tcMatchTy t1 t2</tt> produces a substitution (over fvs(t1))
--   <tt>s</tt> such that <tt>s(t1)</tt> equals <tt>t2</tt>. The returned
--   substitution might bind coercion variables, if the variable is an
--   argument to a GADT constructor.
--   
--   Precondition: typeKind ty1 <a>eqType</a> typeKind ty2
--   
--   We don't pass in a set of "template variables" to be bound by the
--   match, because tcMatchTy (and similar functions) are always used on
--   top-level types, so we can bind any of the free variables of the LHS.
--   See also Note [tcMatchTy vs tcMatchTyKi]
tcMatchTy :: Type -> Type -> Maybe Subst

-- | Like <a>tcMatchTy</a>, but allows the kinds of the types to differ,
--   and thus matches them as well. See also Note [tcMatchTy vs
--   tcMatchTyKi]
tcMatchTyKi :: Type -> Type -> Maybe Subst

-- | Like <a>tcMatchTy</a> but over a list of types. See also Note
--   [tcMatchTy vs tcMatchTyKi]
tcMatchTys :: [Type] -> [Type] -> Maybe Subst

-- | Like <a>tcMatchTyKi</a> but over a list of types. See also Note
--   [tcMatchTy vs tcMatchTyKi]
tcMatchTyKis :: [Type] -> [Type] -> Maybe Subst

-- | This is similar to <a>tcMatchTy</a>, but extends a substitution See
--   also Note [tcMatchTy vs tcMatchTyKi]
tcMatchTyX :: Subst -> Type -> Type -> Maybe Subst

-- | Like <a>tcMatchTys</a>, but extending a substitution See also Note
--   [tcMatchTy vs tcMatchTyKi]
tcMatchTysX :: Subst -> [Type] -> [Type] -> Maybe Subst

-- | Like <a>tcMatchTyKis</a>, but extending a substitution See also Note
--   [tcMatchTy vs tcMatchTyKi]
tcMatchTyKisX :: Subst -> [Type] -> [Type] -> Maybe Subst
tcMatchTyX_BM :: BindFun -> Subst -> Type -> Type -> Maybe Subst

-- | This one is called from the expression matcher, which already has a
--   MatchEnv in hand
ruleMatchTyKiX :: TyCoVarSet -> RnEnv2 -> TvSubstEnv -> Type -> Type -> Maybe TvSubstEnv

-- | Simple unification of two types; all type variables are bindable
--   Precondition: the kinds are already equal
tcUnifyTy :: Type -> Type -> Maybe Subst

-- | Like <a>tcUnifyTy</a>, but also unifies the kinds
tcUnifyTyKi :: Type -> Type -> Maybe Subst
tcUnifyTys :: BindFun -> [Type] -> [Type] -> Maybe Subst

-- | Like <a>tcUnifyTys</a> but also unifies the kinds
tcUnifyTyKis :: BindFun -> [Type] -> [Type] -> Maybe Subst

-- | <tt>tcUnifyTysFG bind_tv tys1 tys2</tt> attempts to find a
--   substitution <tt>s</tt> (whose domain elements all respond
--   <a>BindMe</a> to <tt>bind_tv</tt>) such that <tt>s(tys1)</tt> and that
--   of <tt>s(tys2)</tt> are equal, as witnessed by the returned Coercions.
--   This version requires that the kinds of the types are the same, if you
--   unify left-to-right.
tcUnifyTysFG :: BindFun -> [Type] -> [Type] -> UnifyResult

-- | Unify two types, treating type family applications as possibly
--   unifying with anything and looking through injective type family
--   applications. Precondition: kinds are the same
tcUnifyTyWithTFs :: Bool -> InScopeSet -> Type -> Type -> Maybe Subst

-- | Some unification functions are parameterised by a <a>BindFun</a>,
--   which says whether or not to allow a certain unification to take
--   place. A <a>BindFun</a> takes the <a>TyVar</a> involved along with the
--   <a>Type</a> it will potentially be bound to.
--   
--   It is possible for the variable to actually be a coercion variable
--   (Note [Matching coercion variables]), but only when one-way matching.
--   In this case, the <a>Type</a> will be a <a>CoercionTy</a>.
type BindFun = TyCoVar -> Type -> BindFlag
data BindFlag

-- | A regular type variable
BindMe :: BindFlag

-- | Declare that this type variable is <i>apart</i> from the type
--   provided. That is, the type variable will never be instantiated to
--   that type. See also Note [Binding when looking up instances] in
--   GHC.Core.InstEnv.
Apart :: BindFlag

-- | Allow binding only for any variable in the set. Variables may be bound
--   to any type. Used when doing simple matching; e.g. can we find a
--   substitution
--   
--   <pre>
--   S = [a :-&gt; t1, b :-&gt; t2] such that
--       S( Maybe (a, b-&gt;Int )  =   Maybe (Bool, Char -&gt; Int)
--   </pre>
matchBindFun :: TyCoVarSet -> BindFun

-- | Allow the binding of any variable to any type
alwaysBindFun :: BindFun
type UnifyResult = UnifyResultM Subst

-- | See Note [Unification result]
data UnifyResultM a
Unifiable :: a -> UnifyResultM a
MaybeApart :: MaybeApartReason -> a -> UnifyResultM a
SurelyApart :: UnifyResultM a

-- | Why are two types <a>MaybeApart</a>? <a>MARInfinite</a> takes
--   precedence: This is used (only) in Note [Infinitary substitution in
--   lookup] in GHC.Core.InstEnv As of Feb 2022, we never differentiate
--   between MARTypeFamily and MARTypeVsConstraint; it's really only
--   MARInfinite that's interesting here.
data MaybeApartReason

-- | matching e.g. F Int ~? Bool
MARTypeFamily :: MaybeApartReason

-- | matching e.g. a ~? Maybe a
MARInfinite :: MaybeApartReason

-- | matching Type ~? Constraint or the arrow types See Note [Type and
--   Constraint are not apart] in GHC.Builtin.Types.Prim
MARTypeVsConstraint :: MaybeApartReason

-- | Given a list of pairs of types, are any two members of a pair surely
--   apart, even after arbitrary type function evaluation and substitution?
typesCantMatch :: [(Type, Type)] -> Bool
typesAreApart :: Type -> Type -> Bool

-- | <a>liftCoMatch</a> is sort of inverse to <a>liftCoSubst</a>. In
--   particular, if <tt>liftCoMatch vars ty co == Just s</tt>, then
--   <tt>liftCoSubst s ty == co</tt>, where <tt>==</tt> there means that
--   the result of <a>liftCoSubst</a> has the same type as the original co;
--   but may be different under the hood. That is, it matches a type
--   against a coercion of the same "shape", and returns a lifting
--   substitution which could have been used to produce the given coercion
--   from the given type. Note that this function is incomplete -- it might
--   return Nothing when there does indeed exist a possible lifting
--   context.
--   
--   This function is incomplete in that it doesn't respect the equality in
--   <a>eqType</a>. That is, it's possible that this will succeed for t1
--   and fail for t2, even when t1 <a>eqType</a> t2. That's because it
--   depends on there being a very similar structure between the type and
--   the coercion. This incompleteness shouldn't be all that surprising,
--   especially because it depends on the structure of the coercion, which
--   is a silly thing to do.
--   
--   The lifting context produced doesn't have to be exacting in the roles
--   of the mappings. This is because any use of the lifting context will
--   also require a desired role. Thus, this algorithm prefers mapping to
--   nominal coercions where it can do so.
liftCoMatch :: TyCoVarSet -> Type -> Coercion -> Maybe LiftingContext
flattenTys :: InScopeSet -> [Type] -> [Type]
flattenTysX :: InScopeSet -> [Type] -> ([Type], TyVarEnv (TyCon, [Type]))
instance GHC.Internal.Base.Applicative GHC.Core.Unify.UM
instance GHC.Internal.Base.Applicative GHC.Core.Unify.UnifyResultM
instance GHC.Classes.Eq GHC.Core.Unify.BindFlag
instance GHC.Internal.Base.Functor GHC.Core.Unify.UM
instance GHC.Internal.Base.Functor GHC.Core.Unify.UnifyResultM
instance GHC.Internal.Control.Monad.Fail.MonadFail GHC.Core.Unify.UM
instance GHC.Internal.Base.Monad GHC.Core.Unify.UM
instance GHC.Internal.Base.Monad GHC.Core.Unify.UnifyResultM
instance GHC.Utils.Outputable.Outputable GHC.Core.Unify.MaybeApartReason
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Core.Unify.UnifyResultM a)
instance GHC.Internal.Base.Semigroup GHC.Core.Unify.MaybeApartReason

module GHC.Core.DataCon

-- | A data constructor
data DataCon

-- | Data Constructor Representation See Note [Data constructor workers and
--   wrappers]
data DataConRep
NoDataConRep :: DataConRep
DCR :: Id -> DataConBoxer -> [Scaled Type] -> [StrictnessMark] -> [HsImplBang] -> DataConRep
[dcr_wrap_id] :: DataConRep -> Id
[dcr_boxer] :: DataConRep -> DataConBoxer
[dcr_arg_tys] :: DataConRep -> [Scaled Type]
[dcr_stricts] :: DataConRep -> [StrictnessMark]
[dcr_bangs] :: DataConRep -> [HsImplBang]

-- | Source Strictness
--   
--   What strictness annotation the user wrote
data SrcStrictness

-- | Lazy, ie <tt>~</tt>
SrcLazy :: SrcStrictness

-- | Strict, ie <tt>!</tt>
SrcStrict :: SrcStrictness

-- | no strictness annotation
NoSrcStrict :: SrcStrictness

-- | Source Unpackedness
--   
--   What unpackedness the user requested
data SrcUnpackedness

-- | {-# UNPACK #-} specified
SrcUnpack :: SrcUnpackedness

-- | {-# NOUNPACK #-} specified
SrcNoUnpack :: SrcUnpackedness

-- | no unpack pragma
NoSrcUnpack :: SrcUnpackedness

-- | Haskell Source Bang
--   
--   Bangs on data constructor arguments as written by the user, including
--   the source code for exact-printing.
--   
--   In the AST, the SourceText is deconstructed and hidden inside
--   <a>XBangTy</a> extension point.
data HsSrcBang
HsSrcBang :: SourceText -> HsBang -> HsSrcBang

-- | Haskell Bang
--   
--   Bangs on data constructor arguments written by the user.
--   
--   <tt>(HsBang SrcUnpack SrcLazy)</tt> and <tt>(HsBang SrcUnpack
--   NoSrcStrict)</tt> (without StrictData) makes no sense, we emit a
--   warning (in checkValidDataCon) and treat it like <tt>(HsBang
--   NoSrcUnpack SrcLazy)</tt>
--   
--   <a>HsSrcBang</a> is a wrapper around this, associating it with a
--   <a>SourceText</a> as written by the user. In the AST, the
--   <tt>SourceText</tt> is hidden inside the extension point
--   <a>XBangTy</a>.
data HsBang
HsBang :: SrcUnpackedness -> SrcStrictness -> HsBang

-- | Haskell Implementation Bang
--   
--   Bangs of data constructor arguments as generated by the compiler after
--   consulting HsSrcBang, flags, etc.
data HsImplBang

-- | Lazy field, or one with an unlifted type
HsLazy :: HsImplBang

-- | Strict but not unpacked field True <a>=</a> we could have unpacked,
--   but opted not to because of -O0. See Note [Detecting useless UNPACK
--   pragmas]
HsStrict :: Bool -> HsImplBang

-- | Strict and unpacked field co :: arg-ty ~ product-ty HsBang
HsUnpack :: Maybe Coercion -> HsImplBang
data StrictnessMark
MarkedStrict :: StrictnessMark
NotMarkedStrict :: StrictnessMark

-- | A *one-index* constructor tag
--   
--   Type of the tags associated with each constructor possibility or
--   superclass selector
type ConTag = Int
type DataConEnv a = UniqFM DataCon a

-- | An <a>EqSpec</a> is a tyvar/type pair representing an equality made in
--   rejigging a GADT constructor
data EqSpec

-- | Make a non-dependent <a>EqSpec</a>
mkEqSpec :: TyVar -> Type -> EqSpec
eqSpecTyVar :: EqSpec -> TyVar
eqSpecType :: EqSpec -> Type
eqSpecPair :: EqSpec -> (TyVar, Type)
eqSpecPreds :: [EqSpec] -> ThetaType

-- | Fields in an algebraic record type; see Note [FieldLabel].
data FieldLabel
FieldLabel :: DuplicateRecordFields -> FieldSelectors -> Name -> FieldLabel

-- | Was <tt>DuplicateRecordFields</tt> on in the defining module for this
--   datatype?
[flHasDuplicateRecordFields] :: FieldLabel -> DuplicateRecordFields

-- | Was <tt>FieldSelectors</tt> enabled in the defining module for this
--   datatype? See Note [NoFieldSelectors] in GHC.Rename.Env
[flHasFieldSelector] :: FieldLabel -> FieldSelectors

-- | The <a>Name</a> of the selector function, which uniquely identifies
--   the field label.
[flSelector] :: FieldLabel -> Name

-- | User-visible label of a field.
flLabel :: FieldLabel -> FieldLabelString

-- | Field labels are just represented as strings; they are not necessarily
--   unique (even within a module)
data FieldLabelString

-- | Make a <a>HsSrcBang</a> from all parts
mkHsSrcBang :: SourceText -> SrcUnpackedness -> SrcStrictness -> HsSrcBang

-- | Build a new data constructor
mkDataCon :: Name -> Bool -> TyConRepName -> [HsSrcBang] -> [FieldLabel] -> [TyVar] -> [TyCoVar] -> ConcreteTyVars -> [InvisTVBinder] -> [EqSpec] -> KnotTied ThetaType -> [KnotTied (Scaled Type)] -> KnotTied Type -> PromDataConInfo -> KnotTied TyCon -> ConTag -> ThetaType -> Id -> DataConRep -> DataCon

-- | Tags are allocated from here for real constructors or for superclass
--   selectors
fIRST_TAG :: ConTag

-- | The representation type of the data constructor, i.e. the sort type
--   that will represent values of this type at runtime
dataConRepType :: DataCon -> Type

-- | Instantiate the universal tyvars of a data con, returning (
--   instantiated existentials , instantiated constraints including
--   dependent GADT equalities which are *also* listed in the instantiated
--   existentials , instantiated args)
dataConInstSig :: DataCon -> [Type] -> ([TyCoVar], ThetaType, [Type])

-- | The "full signature" of the <a>DataCon</a> returns, in order:
--   
--   1) The result of <a>dataConUnivTyVars</a>
--   
--   2) The result of <a>dataConExTyCoVars</a>
--   
--   3) The non-dependent GADT equalities. Dependent GADT equalities are
--   implied by coercion variables in return value (2).
--   
--   4) The other constraints of the data constructor type, excluding GADT
--   equalities
--   
--   5) The original argument types to the <a>DataCon</a> (i.e. before any
--   change of the representation of the type) with linearity annotations
--   
--   6) The original result type of the <a>DataCon</a>
dataConFullSig :: DataCon -> ([TyVar], [TyCoVar], [EqSpec], ThetaType, [Scaled Type], Type)

-- | The <a>Name</a> of the <a>DataCon</a>, giving it a unique, rooted
--   identification
dataConName :: DataCon -> Name

-- | The string <tt>package:module.name</tt> identifying a constructor,
--   which is attached to its info table and used by the GHCi debugger and
--   the heap profiler
dataConIdentity :: DataCon -> ByteString

-- | The tag used for ordering <a>DataCon</a>s
dataConTag :: DataCon -> ConTag
dataConTagZ :: DataCon -> ConTagZ

-- | The type constructor that we are building via this data constructor
dataConTyCon :: DataCon -> TyCon

-- | The original type constructor used in the definition of this data
--   constructor. In case of a data family instance, that will be the
--   family type constructor.
dataConOrigTyCon :: DataCon -> TyCon

-- | The user-declared type of the data constructor in the nice-to-read
--   form:
--   
--   <pre>
--   T :: forall a b. a -&gt; b -&gt; T [a]
--   </pre>
--   
--   rather than:
--   
--   <pre>
--   T :: forall a c. forall b. (c~[a]) =&gt; a -&gt; b -&gt; T c
--   </pre>
--   
--   The type variables are quantified in the order that the user wrote
--   them. See <tt>Note [DataCon user type variable binders]</tt>.
--   
--   NB: If the constructor is part of a data instance, the result type
--   mentions the family tycon, not the internal one.
dataConWrapperType :: DataCon -> Type
dataConNonlinearType :: DataCon -> Type
dataConDisplayType :: Bool -> DataCon -> Type

-- | The universally-quantified type variables of the constructor
dataConUnivTyVars :: DataCon -> [TyVar]

-- | The existentially-quantified type/coercion variables of the
--   constructor including dependent (kind-) GADT equalities
dataConExTyCoVars :: DataCon -> [TyCoVar]

-- | Both the universal and existential type/coercion variables of the
--   constructor
dataConUnivAndExTyCoVars :: DataCon -> [TyCoVar]

-- | Which type variables of this data constructor that must be
--   instantiated to concrete types? For example: the RuntimeRep variables
--   of unboxed tuples and unboxed sums.
--   
--   See Note [Representation-polymorphism checking built-ins] in
--   GHC.Tc.Utils.Concrete
dataConConcreteTyVars :: DataCon -> ConcreteTyVars

-- | The type variables of the constructor, in the order the user wrote
--   them
dataConUserTyVars :: DataCon -> [TyVar]

-- | <a>InvisTVBinder</a>s for the type variables of the constructor, in
--   the order the user wrote them
dataConUserTyVarBinders :: DataCon -> [InvisTVBinder]

-- | The *full* constraints on the constructor type, including dependent
--   GADT equalities.
dataConTheta :: DataCon -> ThetaType

-- | The "stupid theta" of the <a>DataCon</a>, such as <tt>data Eq a</tt>
--   in:
--   
--   <pre>
--   data Eq a =&gt; T a = ...
--   </pre>
--   
--   See <tt>Note [The stupid context]</tt>.
dataConStupidTheta :: DataCon -> ThetaType

-- | Returns constraints in the wrapper type, other than those in the
--   dataConEqSpec
dataConOtherTheta :: DataCon -> ThetaType

-- | Finds the instantiated types of the arguments required to construct a
--   <a>DataCon</a> representation NB: these INCLUDE any dictionary args
--   but EXCLUDE the data-declaration context, which is discarded It's all
--   post-flattening etc; this is a representation type
dataConInstArgTys :: DataCon -> [Type] -> [Scaled Type]

-- | Returns the argument types of the wrapper, excluding all dictionary
--   arguments and without substituting for any type variables
dataConOrigArgTys :: DataCon -> [Scaled Type]
dataConOrigResTy :: DataCon -> Type

-- | Returns just the instantiated <i>value</i> argument types of a
--   <a>DataCon</a>, (excluding dictionary args)
dataConInstOrigArgTys :: DataCon -> [Type] -> [Scaled Type]

-- | Returns the arg types of the worker, including *all* non-dependent
--   evidence, after any flattening has been done and without substituting
--   for any type variables
dataConRepArgTys :: DataCon -> [Scaled Type]

-- | Were the type variables of the data con written in a different order
--   than the regular order (universal tyvars followed by existential
--   tyvars)?
--   
--   This is not a cheap test, so we minimize its use in GHC as much as
--   possible. Currently, its only call site in the GHC codebase is in
--   <tt>mkDataConRep</tt> in <a>MkId</a>, and so
--   <a>dataConUserTyVarsNeedWrapper</a> is only called at most once during
--   a data constructor's lifetime.
dataConResRepTyArgs :: DataCon -> [Type]

-- | Given a data constructor <tt>dc</tt> with <i>n</i> universally
--   quantified type variables <tt>a_{1}</tt>, <tt>a_{2}</tt>, ...,
--   <tt>a_{n}</tt>, and given a list of argument types <tt>dc_args</tt> of
--   length <i>m</i> where <i>m</i> &lt;= <i>n</i>, then:
--   
--   <pre>
--   dataConInstUnivs dc dc_args
--   </pre>
--   
--   Will return:
--   
--   <pre>
--   [dc_arg_{1}, dc_arg_{2}, ..., dc_arg_{m}, a_{m+1}, ..., a_{n}]
--   </pre>
--   
--   That is, return the list of universal type variables with
--   <tt>a_{1}</tt>, <tt>a_{2}</tt>, ..., <tt>a_{m}</tt> instantiated with
--   <tt>dc_arg_{1}</tt>, <tt>dc_arg_{2}</tt>, ..., <tt>dc_arg_{m}</tt>. It
--   is possible for <tt>m</tt> to be less than <tt>n</tt>, in which case
--   the remaining <tt>n - m</tt> elements will simply be universal type
--   variables (with their kinds possibly instantiated).
--   
--   Examples:
--   
--   <ul>
--   <li>Given the data constructor <tt>D :: forall a b. Foo a b</tt> and
--   <tt>dc_args</tt> <tt>[Int, Bool]</tt>, then <tt>dataConInstUnivs D
--   dc_args</tt> will return <tt>[Int, Bool]</tt>.</li>
--   <li>Given the data constructor <tt>D :: forall a b. Foo a b</tt> and
--   <tt>dc_args</tt> <tt>[Int]</tt>, then @<tt>dataConInstUnivs D
--   dc_args</tt> will return <tt>[Int, b]</tt>.</li>
--   <li>Given the data constructor <tt>E :: forall k (a :: k). Bar k
--   a</tt> and <tt>dc_args</tt> <tt>[Type]</tt>, then
--   @<tt>dataConInstUnivs D dc_args</tt> will return <tt>[Type, (a ::
--   Type)]</tt>.</li>
--   </ul>
--   
--   This is primarily used in <tt>GHC.Tc.Deriv.*</tt> in service of
--   instantiating data constructors' field types. See <tt>Note
--   [Instantiating field types in stock deriving]</tt> for a notable
--   example of this.
dataConInstUnivs :: DataCon -> [Type] -> [Type]

-- | The labels for the fields of this particular <a>DataCon</a>
dataConFieldLabels :: DataCon -> [FieldLabel]

-- | Extract the type for any given labelled field of the <a>DataCon</a>
dataConFieldType :: DataCon -> FieldLabelString -> Type

-- | Extract the label and type for any given labelled field of the
--   <a>DataCon</a>, or return <a>Nothing</a> if the field does not belong
--   to it
dataConFieldType_maybe :: DataCon -> FieldLabelString -> Maybe (FieldLabel, Type)

-- | Strictness/unpack annotations, from user; or, for imported DataCons,
--   from the interface file The list is in one-to-one correspondence with
--   the arity of the <a>DataCon</a>
dataConSrcBangs :: DataCon -> [HsSrcBang]

-- | Source-level arity of the data constructor
dataConSourceArity :: DataCon -> Arity

-- | Gives the number of value arguments (including zero-width coercions)
--   stored by the given <a>DataCon</a>'s worker in its Core
--   representation. This may differ from the number of arguments that
--   appear in the source code; see also Note [DataCon arities]
dataConRepArity :: DataCon -> Arity

-- | Should the <a>DataCon</a> be presented infix?
dataConIsInfix :: DataCon -> Bool

-- | Get the Id of the <a>DataCon</a> worker: a function that is the
--   "actual" constructor and has no top level binding in the program. The
--   type may be different from the obvious one written in the source
--   program. Panics if there is no such <a>Id</a> for this <a>DataCon</a>
dataConWorkId :: DataCon -> Id

-- | Returns an Id which looks like the Haskell-source constructor by using
--   the wrapper if it exists (see <a>dataConWrapId_maybe</a>) and failing
--   over to the worker (see <a>dataConWorkId</a>)
dataConWrapId :: DataCon -> Id

-- | Get the Id of the <a>DataCon</a> wrapper: a function that wraps the
--   "actual" constructor so it has the type visible in the source program:
--   c.f. <a>dataConWorkId</a>. Returns Nothing if there is no wrapper,
--   which occurs for an algebraic data constructor and also for a newtype
--   (whose constructor is inlined compulsorily)
dataConWrapId_maybe :: DataCon -> Maybe Id

-- | Find all the <a>Id</a>s implicitly brought into scope by the data
--   constructor. Currently, the union of the <a>dataConWorkId</a> and the
--   <a>dataConWrapId</a>
dataConImplicitTyThings :: DataCon -> [TyThing]

-- | Give the demands on the arguments of a Core constructor application
--   (Con dc args)
dataConRepStrictness :: DataCon -> [StrictnessMark]
dataConImplBangs :: DataCon -> [HsImplBang]
dataConBoxer :: DataCon -> Maybe DataConBoxer

-- | Extract the type constructor, type argument, data constructor and it's
--   <i>representation</i> argument types from a type if it is a product
--   type.
--   
--   Precisely, we return <tt>Just</tt> for any data type that is all of:
--   
--   <ul>
--   <li>Concrete (i.e. constructors visible)</li>
--   <li>Single-constructor</li>
--   <li>... which has no existentials</li>
--   </ul>
--   
--   Whether the type is a <tt>data</tt> type or a <tt>newtype</tt>.
splitDataProductType_maybe :: Type -> Maybe (TyCon, [Type], DataCon, [Scaled Type])

-- | Return whether there are any argument types for this <a>DataCon</a>s
--   original source type See Note [DataCon arities]
isNullarySrcDataCon :: DataCon -> Bool

-- | Return whether this <a>DataCon</a>'s worker, in its Core
--   representation, takes any value arguments.
--   
--   In particular, remember that we include coercion arguments in the
--   arity of the Core representation of the <a>DataCon</a> -- both lifted
--   and unlifted coercions, despite the latter having zero-width runtime
--   representation.
--   
--   See also Note [DataCon arities].
isNullaryRepDataCon :: DataCon -> Bool
isTupleDataCon :: DataCon -> Bool
isBoxedTupleDataCon :: DataCon -> Bool
isUnboxedTupleDataCon :: DataCon -> Bool
isUnboxedSumDataCon :: DataCon -> Bool
isCovertGadtDataCon :: DataCon -> Bool

-- | Vanilla <a>DataCon</a>s are those that are nice boring Haskell 98
--   constructors
isVanillaDataCon :: DataCon -> Bool

-- | Is this the <a>DataCon</a> of a newtype?
isNewDataCon :: DataCon -> Bool

-- | Is this data constructor in a "type data" declaration? See Note [Type
--   data declarations] in GHC.Rename.Module.
isTypeDataCon :: DataCon -> Bool
classDataCon :: Class -> DataCon
dataConCannotMatch :: [Type] -> DataCon -> Bool
dataConUserTyVarsNeedWrapper :: DataCon -> Bool
checkDataConTyVars :: DataCon -> Bool
isBanged :: HsImplBang -> Bool
isMarkedStrict :: StrictnessMark -> Bool
cbvFromStrictMark :: StrictnessMark -> CbvMark

-- | Compare strictness annotations
eqHsBang :: HsImplBang -> HsImplBang -> Bool
isSrcStrict :: SrcStrictness -> Bool
isSrcUnpacked :: SrcUnpackedness -> Bool

-- | Should this DataCon be allowed in a type even without -XDataKinds?
--   Currently, only Lifted &amp; Unlifted
specialPromotedDc :: DataCon -> Bool
promoteDataCon :: DataCon -> TyCon
instance GHC.Utils.Binary.Binary Language.Haskell.Syntax.Basic.SrcStrictness
instance GHC.Utils.Binary.Binary Language.Haskell.Syntax.Basic.SrcUnpackedness
instance GHC.Utils.Binary.Binary GHC.Core.DataCon.StrictnessMark
instance GHC.Internal.Data.Data.Data GHC.Core.DataCon.DataCon
instance GHC.Internal.Data.Data.Data GHC.Core.DataCon.HsImplBang
instance GHC.Classes.Eq GHC.Core.DataCon.DataCon
instance GHC.Classes.Eq GHC.Core.DataCon.StrictnessMark
instance GHC.Types.Name.NamedThing GHC.Core.DataCon.DataCon
instance GHC.Utils.Outputable.OutputableBndr GHC.Core.DataCon.DataCon
instance GHC.Utils.Outputable.Outputable GHC.Core.DataCon.DataCon
instance GHC.Utils.Outputable.Outputable GHC.Core.DataCon.EqSpec
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Basic.HsBang
instance GHC.Utils.Outputable.Outputable GHC.Core.DataCon.HsImplBang
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Basic.SrcStrictness
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Basic.SrcUnpackedness
instance GHC.Utils.Outputable.Outputable GHC.Core.DataCon.StrictnessMark
instance GHC.Types.Unique.Uniquable GHC.Core.DataCon.DataCon

module GHC.Types.RepType
type UnaryType = Type
type NvUnaryType = Type
isNvUnaryRep :: [PrimRep] -> Bool

-- | Gets rid of the stuff that prevents us from understanding the runtime
--   representation of a type. Including: 1. Casts 2. Newtypes 3. Foralls
--   4. Synonyms But not type/data families, because we don't have the envs
--   to hand.
unwrapType :: Type -> Type

-- | True if the type has zero width.
isZeroBitTy :: HasDebugCallStack => Type -> Bool

-- | Discovers the primitive representation of a <a>Type</a>. Returns a
--   list of <a>PrimRep</a>: it's a list because of the possibility of no
--   runtime representation (void) or multiple (unboxed tuple/sum) See also
--   Note [Getting from RuntimeRep to PrimRep]
typePrimRep :: HasDebugCallStack => Type -> [PrimRep]

-- | Like <a>typePrimRep</a>, but assumes that there is at most one
--   <a>PrimRep</a> output; an empty list of PrimReps becomes a VoidRep.
--   This assumption holds after unarise, see Note [Post-unarisation
--   invariants]. Before unarise it may or may not hold. See also Note
--   [RuntimeRep and PrimRep] and Note [VoidRep]
typePrimRep1 :: HasDebugCallStack => UnaryType -> PrimOrVoidRep
typePrimRepU :: HasDebugCallStack => NvUnaryType -> PrimRep

-- | Take a type of kind RuntimeRep and extract the list of <a>PrimRep</a>
--   that it encodes. See also Note [Getting from RuntimeRep to PrimRep].
--   The <tt>[PrimRep]</tt> is the final runtime representation
--   <i>after</i> unarisation.
runtimeRepPrimRep :: HasDebugCallStack => SDoc -> RuntimeRepType -> [PrimRep]

-- | A <a>PrimRep</a> is an abstraction of a <i>non-void</i> type. (Use
--   <tt>PrimRepOrVoidRep</tt> if you want void types too.) It contains
--   information that the code generator needs in order to pass arguments,
--   return results, and store values of this type. See also Note
--   [RuntimeRep and PrimRep] in <a>GHC.Types.RepType</a> and Note
--   [VoidRep] in <a>GHC.Types.RepType</a>.
data PrimRep

-- | Boxed, heap value
BoxedRep :: {-# UNPACK #-} !Maybe Levity -> PrimRep

-- | Signed, 8-bit value
Int8Rep :: PrimRep

-- | Signed, 16-bit value
Int16Rep :: PrimRep

-- | Signed, 32-bit value
Int32Rep :: PrimRep

-- | Signed, 64 bit value
Int64Rep :: PrimRep

-- | Signed, word-sized value
IntRep :: PrimRep

-- | Unsigned, 8 bit value
Word8Rep :: PrimRep

-- | Unsigned, 16 bit value
Word16Rep :: PrimRep

-- | Unsigned, 32 bit value
Word32Rep :: PrimRep

-- | Unsigned, 64 bit value
Word64Rep :: PrimRep

-- | Unsigned, word-sized value
WordRep :: PrimRep

-- | A pointer, but <i>not</i> to a Haskell value (use <a>BoxedRep</a>)
AddrRep :: PrimRep
FloatRep :: PrimRep
DoubleRep :: PrimRep

-- | A vector
VecRep :: Int -> PrimElemRep -> PrimRep

-- | Convert a <a>PrimRep</a> to a <a>Type</a> of kind RuntimeRep
primRepToRuntimeRep :: PrimRep -> RuntimeRepType

-- | Convert a PrimRep back to a Type. Used only in the unariser to give
--   types to fresh Ids. Really, only the type's representation matters.
--   See also Note [RuntimeRep and PrimRep]
primRepToType :: PrimRep -> Type

-- | Count the arity of a function post-unarisation, including zero-width
--   arguments.
--   
--   The post-unarisation arity may be larger than the arity of the
--   original function type. See Note [Unarisation].
countFunRepArgs :: Arity -> Type -> RepArity
countConRepArgs :: DataCon -> RepArity

-- | Give the demands on the arguments of a Core constructor application
--   (Con dc args) at runtime. Assumes the constructor is not levity
--   polymorphic. For example unboxed tuples won't work.
dataConRuntimeRepStrictness :: HasDebugCallStack => DataCon -> [StrictnessMark]

-- | Find the runtime representation of a <a>TyCon</a>. Defined here to
--   avoid module loops. Returns a list of the register shapes necessary.
--   See also Note [Getting from RuntimeRep to PrimRep]
tyConPrimRep :: HasDebugCallStack => TyCon -> [PrimRep]

-- | Take a type of kind RuntimeRep and extract the list of <a>PrimRep</a>
--   that it encodes. See also Note [Getting from RuntimeRep to PrimRep].
--   The <tt>[PrimRep]</tt> is the final runtime representation
--   <i>after</i> unarisation.
--   
--   Returns <tt>Nothing</tt> if rep can't be determined. Eg. levity
--   polymorphic types.
runtimeRepPrimRep_maybe :: Type -> Maybe [PrimRep]

-- | Take a kind (of shape `TYPE rr` or `CONSTRAINT rr`) and produce the
--   <a>PrimRep</a>s of values of types of this kind. See also Note
--   [Getting from RuntimeRep to PrimRep] Returns Nothing if rep can't be
--   determined. Eg. levity polymorphic types.
kindPrimRep_maybe :: HasDebugCallStack => Kind -> Maybe [PrimRep]

-- | Discovers the primitive representation of a <a>Type</a>. Returns a
--   list of <a>PrimRep</a>: it's a list because of the possibility of no
--   runtime representation (void) or multiple (unboxed tuple/sum) See also
--   Note [Getting from RuntimeRep to PrimRep] Returns Nothing if rep can't
--   be determined. Eg. levity polymorphic types.
typePrimRep_maybe :: Type -> Maybe [PrimRep]

-- | Given the arguments of a sum type constructor application, return the
--   unboxed sum rep type.
--   
--   E.g.
--   
--   (# Int# | Maybe Int | (# Int#, Float# #) #)
--   
--   We call `ubxSumRepType [ [IntRep], [LiftedRep], [IntRep, FloatRep] ]`,
--   which returns [WordSlot, PtrSlot, WordSlot, FloatSlot]
--   
--   INVARIANT: Result slots are sorted (via Ord SlotTy), except that at
--   the head of the list we have the slot for the tag.
ubxSumRepType :: [[PrimRep]] -> NonEmpty SlotTy
layoutUbxSum :: HasDebugCallStack => SortedSlotTys -> [SlotTy] -> [Int]
repSlotTy :: [PrimRep] -> Maybe SlotTy
data SlotTy
PtrLiftedSlot :: SlotTy
PtrUnliftedSlot :: SlotTy
WordSlot :: SlotTy
Word64Slot :: SlotTy
FloatSlot :: SlotTy
DoubleSlot :: SlotTy
VecSlot :: Int -> PrimElemRep -> SlotTy
slotPrimRep :: SlotTy -> PrimRep
primRepSlot :: PrimRep -> SlotTy
mightBeFunTy :: Type -> Bool
instance GHC.Classes.Eq GHC.Types.RepType.SlotTy
instance GHC.Classes.Ord GHC.Types.RepType.SlotTy
instance GHC.Utils.Outputable.Outputable GHC.Types.RepType.SlotTy


-- | A language to express the evaluation context of an expression as a
--   <a>Demand</a> and track how an expression evaluates free variables and
--   arguments in turn as a <a>DmdType</a>.
--   
--   Lays out the abstract domain for <a>GHC.Core.Opt.DmdAnal</a>.
module GHC.Types.Demand
data Boxity
Boxed :: Boxity
Unboxed :: Boxity

-- | Describes an interval of <i>evaluation cardinalities</i>. See Note
--   [Evaluation cardinalities] See Note [Bit vector representation for
--   Card]
data Card

-- | Absent, {0}. Pretty-printed as A.
pattern C_00 :: Card

-- | Used at most once, {0,1}. Pretty-printed as M.
pattern C_01 :: Card

-- | Every possible cardinality; the top element, {0,1,n}. Pretty-printed
--   as L.
pattern C_0N :: Card

-- | Bottom, {}. Pretty-printed as A.
pattern C_10 :: Card

-- | Strict and used once, {1}. Pretty-printed as 1.
pattern C_11 :: Card

-- | Strict and used (possibly) many times, {1,n}. Pretty-printed as S.
pattern C_1N :: Card

-- | A subtype of <a>Card</a> for which the upper bound is never 0 (no
--   <a>C_00</a> or <a>C_10</a>). The only four inhabitants are
--   <a>C_01</a>, <a>C_0N</a>, <a>C_11</a>, <a>C_1N</a>. Membership can be
--   tested with <a>isCardNonAbs</a>. See <a>D</a> and <a>Call</a> for use
--   sites and explanation.
type CardNonAbs = Card

-- | A subtype of <a>Card</a> for which the upper bound is never 1 (no
--   <a>C_01</a> or <a>C_11</a>). The only four inhabitants are
--   <a>C_00</a>, <a>C_0N</a>, <a>C_10</a>, <a>C_1N</a>. Membership can be
--   tested with <a>isCardNonOnce</a>. See <a>Poly</a> for use sites and
--   explanation.
type CardNonOnce = Card

-- | A demand describes
--   
--   <ul>
--   <li>How many times a variable is evaluated, via a <a>Card</a>inality,
--   and</li>
--   <li>How deep its value was evaluated in turn, via a
--   <a>SubDemand</a>.</li>
--   </ul>
--   
--   See also Note [Demand notation] and Note [Demand examples].
--   
--   This data type is quite similar to `<tt>Scaled</tt>
--   <tt>SubDemand'</tt>, but it's scaled by <a>Card</a>, which is an
--   <i>interval</i> on <tt>Multiplicity</tt>, the upper bound of which
--   could be used to infer uniqueness types. Also we treat <a>AbsDmd</a>
--   and <a>BotDmd</a> specially, as the concept of a <a>SubDemand</a>
--   doesn't apply when there isn't any evaluation at all. If you don't
--   care, simply use <a>(:*)</a>.
data Demand

-- | A bottoming demand, produced by a diverging function (<a>C_10</a>),
--   hence there is no <a>SubDemand</a> that describes how it was
--   evaluated.
BotDmd :: Demand

-- | An absent demand: Evaluated exactly 0 times (<a>C_00</a>), hence there
--   is no <a>SubDemand</a> that describes how it was evaluated.
AbsDmd :: Demand

-- | <tt>c :* sd</tt> is a demand that says "evaluated <tt>c</tt> times,
--   and any trace in which it is evaluated will evaluate at least as deep
--   as <tt>sd</tt>".
--   
--   Matching on this pattern synonym is a complete match. If the matched
--   demand was <a>AbsDmd</a>, it will match as <tt>C_00 :* seqSubDmd</tt>.
--   If the matched demand was <a>BotDmd</a>, it will match as <tt>C_10 :*
--   botSubDmd</tt>. The builder of this pattern synonym simply
--   <i>discards</i> the <a>SubDemand</a> if the <a>Card</a> was absent and
--   returns <a>AbsDmd</a> or <a>BotDmd</a> instead. It will assert that
--   the discarded sub-demand was <a>seqSubDmd</a> and <a>botSubDmd</a>,
--   respectively.
--   
--   Call sites should consider whether they really want to look at the
--   <a>SubDemand</a> of an absent demand and match on <a>AbsDmd</a> and/or
--   <a>BotDmd</a> otherwise. Really, any other <a>SubDemand</a> would be
--   allowed and might work better, depending on context.
pattern (:*) :: HasDebugCallStack => Card -> SubDemand -> Demand

-- | A sub-demand describes an <i>evaluation context</i> (in the sense of
--   an operational semantics), e.g. how deep the denoted thing is going to
--   be evaluated. See <a>Demand</a> for examples.
--   
--   See Note [SubDemand denotes at least one evaluation] for a more
--   detailed description of what a sub-demand means.
--   
--   See Note [Demand notation] for the extensively used short-hand
--   notation. See also Note [Why Boxity in SubDemand and not in Demand?].
data SubDemand

-- | Polymorphic demand, the denoted thing is evaluated arbitrarily deep,
--   with the specified cardinality at every level. The <a>Boxity</a>
--   applies only to the outer evaluation context as well as all inner
--   evaluation context. See Note [Boxity in Poly] for why we want it to
--   carry <a>Boxity</a>. Expands to <a>Call</a> via <a>viewCall</a> and to
--   <a>Prod</a> via <a>viewProd</a>.
--   
--   <tt>Poly b n</tt> is semantically equivalent to <tt>Prod b [n :* Poly
--   b n, ...] or </tt>Call n (Poly Boxed n)@. <a>viewCall</a> and
--   <a>viewProd</a> do these rewrites.
--   
--   In Note [Demand notation]: <tt>L === P(L,L,...)</tt> and <tt>L ===
--   C(L)</tt>, <tt>B === P(B,B,...)</tt> and <tt>B === C(B)</tt>, <tt>!A
--   === !P(A,A,...)</tt> and <tt>!A === C(A)</tt>, and so on.
--   
--   We'll only see <a>Poly</a> with <a>C_10</a> (B), <a>C_00</a> (A),
--   <a>C_0N</a> (L) and sometimes <a>C_1N</a> (S) through
--   <a>plusSubDmd</a>, never <a>C_01</a> (M) or <a>C_11</a> (1) (grep the
--   source code). Hence <a>CardNonOnce</a>, which is closed under
--   <tt>lub</tt> and <tt>plus</tt>.
--   
--   Why doesn't this constructor simply carry a <a>Demand</a> instead of
--   its fields? See Note [Call SubDemand vs. evaluation Demand].
Poly :: !Boxity -> !CardNonOnce -> SubDemand

-- | <tt>Prod b ds</tt> describes the evaluation context of a case
--   scrutinisation on an expression of product type, where the product
--   components are evaluated according to <tt>ds</tt>. The <a>Boxity</a>
--   <tt>b</tt> says whether or not the box of the product was used.
Prod :: !Boxity -> ![Demand] -> SubDemand

-- | A smart constructor for <a>Prod</a>, applying rewrite rules along the
--   semantic equality <tt>Prod b [n :* Poly Boxed n, ...] === Poly b
--   n</tt>, simplifying to <a>Poly</a> <a>SubDemand</a>s when possible.
--   Examples:
--   
--   <ul>
--   <li>Rewrites <tt>P(L,L)</tt> (e.g., arguments <tt>Boxed</tt>,
--   <tt>[L,L]</tt>) to <tt>L</tt></li>
--   <li>Rewrites <tt>!P(L!L,L!L)</tt> (e.g., arguments <tt>Unboxed</tt>,
--   <tt>[L!L,L!L]</tt>) to <tt>!L</tt></li>
--   <li>Does not rewrite <tt>P(1L)</tt>, <tt>P(L!L)</tt>, <tt>!P(L)</tt>
--   or <tt>P(L,A)</tt></li>
--   </ul>
mkProd :: Boxity -> [Demand] -> SubDemand

-- | <tt>viewProd n sd</tt> interprets <tt>sd</tt> as a <a>Prod</a> of
--   arity <tt>n</tt>, expanding <a>Poly</a> demands as necessary.
viewProd :: Arity -> SubDemand -> Maybe (Boxity, [Demand])
absDmd :: Demand
topDmd :: Demand
botDmd :: Demand
seqDmd :: Demand
topSubDmd :: SubDemand

-- | Denotes <tt>∪</tt> on <a>Card</a>.
lubCard :: Card -> Card -> Card

-- | Denotes <tt>∪</tt> on <a>Demand</a>.
lubDmd :: Demand -> Demand -> Demand
lubSubDmd :: SubDemand -> SubDemand -> SubDemand

-- | Denotes <tt>∩</tt> on <a>Card</a>.
glbCard :: Card -> Card -> Card

-- | Denotes <a>+</a> on lower and upper bounds of <a>Card</a>.
plusCard :: Card -> Card -> Card

-- | Denotes <a>+</a> on <a>Demand</a>.
plusDmd :: Demand -> Demand -> Demand
plusSubDmd :: SubDemand -> SubDemand -> SubDemand

-- | Denotes <a>*</a> on lower and upper bounds of <a>Card</a>.
multCard :: Card -> Card -> Card
multDmd :: Card -> Demand -> Demand
multSubDmd :: Card -> SubDemand -> SubDemand

-- | True <a>=</a> upper bound is 0.
isAbs :: Card -> Bool

-- | True <a>=</a> upper bound is 1.
isAtMostOnce :: Card -> Bool

-- | True <a>=</a> lower bound is 1.
isStrict :: Card -> Bool
isAbsDmd :: Demand -> Bool

-- | Is the value used at most once?
isAtMostOnceDmd :: Demand -> Bool

-- | Not absent and used strictly. See Note [Strict demands]
isStrUsedDmd :: Demand -> Bool

-- | Contrast with isStrictUsedDmd. See Note [Strict demands]
isStrictDmd :: Demand -> Bool

-- | Used to suppress pretty-printing of an uninformative demand
isTopDmd :: Demand -> Bool

-- | We try to avoid tracking weak free variable demands in strictness
--   signatures for analysis performance reasons. See Note [Lazy and
--   unleashable free variables] in <a>GHC.Core.Opt.DmdAnal</a>.
isWeakDmd :: Demand -> Bool

-- | True when the signature indicates all arguments are boxed
onlyBoxedArguments :: DmdSig -> Bool
evalDmd :: Demand

-- | First argument of catch#: <tt>MC(1,L)</tt>. Evaluates its arg lazily,
--   but then applies it exactly once to one argument.
lazyApply1Dmd :: Demand

-- | Second argument of catch#: <tt>MC(1,C(1,L))</tt>. Evaluates its arg
--   lazily, but then applies it exactly once to two arguments.
lazyApply2Dmd :: Demand

-- | First argument of 'GHC.Exts.maskAsyncExceptions#': <tt>1C(1,L)</tt>.
--   Called exactly once.
strictOnceApply1Dmd :: Demand

-- | First argument of 'GHC.Exts.atomically#': <tt>SC(S,L)</tt>. Called at
--   least once, possibly many times.
strictManyApply1Dmd :: Demand

-- | Intersect with [0,1].
oneifyCard :: Card -> Card

-- | Make a <a>Demand</a> evaluated at-most-once.
oneifyDmd :: Demand -> Demand

-- | Make a <a>Demand</a> evaluated at-least-once (e.g. strict).
strictifyDmd :: Demand -> Demand

-- | If the argument is a guaranteed-terminating type (i.e. a non-newtype
--   dictionary) give it strict demand. This is sound because terminating
--   types can't be bottom: See GHC.Core Note [NON-BOTTOM-DICTS invariant]
--   Also split the product type &amp; demand and recur in order to
--   similarly strictify the argument's contained used non-newtype
--   superclass dictionaries. We use the demand as our recursive measure to
--   guarantee termination.
strictifyDictDmd :: Type -> Demand -> Demand

-- | Make a <a>Demand</a> lazy.
lazifyDmd :: Demand -> Demand

-- | Adjust the demand on a binding that may float outwards See Note
--   [Floatifying demand info when floating]
floatifyDmd :: Demand -> Demand

-- | Peels one call level from the sub-demand, and also returns how many
--   times we entered the lambda body.
peelCallDmd :: SubDemand -> (Card, SubDemand)
peelManyCalls :: Arity -> SubDemand -> (Card, SubDemand)

-- | Wraps the <a>SubDemand</a> with a one-shot call demand: <tt>d</tt>
--   -&gt; <tt>C(1,d)</tt>.
mkCalledOnceDmd :: SubDemand -> SubDemand

-- | <tt>mkCalledOnceDmds n d</tt> returns <tt>C(1,C1...C(1,d))</tt> where
--   there are <tt>n</tt> <tt>C1</tt>'s.
mkCalledOnceDmds :: Arity -> SubDemand -> SubDemand
strictCallArity :: SubDemand -> Arity
mkWorkerDemand :: Int -> Demand

-- | Extract the <a>SubDemand</a> of a <a>Demand</a>. PRECONDITION: The
--   SubDemand must be used in a context where the expression denoted by
--   the Demand is under evaluation.
subDemandIfEvaluated :: Demand -> SubDemand

-- | See Note [Computing one-shot info]
callCards :: SubDemand -> [Card]

-- | See Note [Computing one-shot info]
argOneShots :: Demand -> [OneShotInfo]

-- | See Note [Computing one-shot info]
argsOneShots :: DmdSig -> Arity -> [[OneShotInfo]]

-- | <tt>saturatedByOneShots n C(M,C(M,...)) = True</tt> <a>=</a> There are
--   at least n nested C(M,..) calls. See Note [Demand on the worker] in
--   GHC.Core.Opt.WorkWrap
saturatedByOneShots :: Int -> Demand -> Bool

-- | Sets <a>Boxity</a> to <a>Unboxed</a> for the <a>Demand</a>, recursing
--   into <a>Prod</a>s. Don't recurse into lazy arguments; see
--   GHC.Core.Opt.DmdAnal Note [No lazy, Unboxed demands in demand
--   signature]
unboxDeeplyDmd :: Demand -> Demand

-- | <a>Divergence</a> characterises whether something surely diverges.
--   Models a subset lattice of the following exhaustive set of divergence
--   results:
--   
--   <ul>
--   <li><i>n</i> nontermination (e.g. loops)</li>
--   <li><i>i</i> throws imprecise exception</li>
--   <li><i>p</i> throws precise exception</li>
--   <li><i>c</i> converges (reduces to WHNF).</li>
--   </ul>
--   
--   The different lattice elements correspond to different subsets,
--   indicated by juxtaposition of indicators (e.g. <b>nc</b> definitely
--   doesn't throw an exception, and may or may not reduce to WHNF).
--   
--   <pre>
--    Dunno (nipc)
--         |
--   ExnOrDiv (nip)
--         |
--   Diverges (ni)
--   </pre>
--   
--   As you can see, we don't distinguish <b>n</b> and <b>i</b>. See Note
--   [Precise exceptions and strictness analysis] for why <b>p</b> is so
--   special compared to <b>i</b>.
data Divergence

-- | Definitely throws an imprecise exception or diverges.
Diverges :: Divergence

-- | Definitely throws a *precise* exception, an imprecise exception or
--   diverges. Never converges, hence <a>isDeadEndDiv</a>! See scenario 1
--   in Note [Precise exceptions and strictness analysis].
ExnOrDiv :: Divergence

-- | Might diverge, throw any kind of exception or converge.
Dunno :: Divergence
topDiv :: Divergence
botDiv :: Divergence
exnDiv :: Divergence
lubDivergence :: Divergence -> Divergence -> Divergence

-- | True if the <a>Divergence</a> indicates that evaluation will not
--   return. See Note [Dead ends].
isDeadEndDiv :: Divergence -> Bool

-- | Captures the result of an evaluation of an expression, by
--   
--   <ul>
--   <li>Listing how the free variables of that expression have been
--   evaluated (<a>de_fvs</a>)</li>
--   <li>Saying whether or not evaluation would surely diverge
--   (<a>de_div</a>)</li>
--   </ul>
--   
--   See Note [Demand env Equality].
data DmdEnv
DE :: !VarEnv Demand -> !Divergence -> DmdEnv
[de_fvs] :: DmdEnv -> !VarEnv Demand
[de_div] :: DmdEnv -> !Divergence
addVarDmdEnv :: DmdEnv -> Id -> Demand -> DmdEnv

-- | Build a potentially terminating <a>DmdEnv</a> from a finite map that
--   says what has been evaluated so far
mkTermDmdEnv :: VarEnv Demand -> DmdEnv
nopDmdEnv :: DmdEnv
plusDmdEnv :: DmdEnv -> DmdEnv -> DmdEnv

-- | <a>DmdEnv</a> is a monoid via <a>plusDmdEnv</a> and <a>nopDmdEnv</a>;
--   this is its <tt>msum</tt>
plusDmdEnvs :: [DmdEnv] -> DmdEnv
multDmdEnv :: Card -> DmdEnv -> DmdEnv
reuseEnv :: DmdEnv -> DmdEnv

-- | Characterises how an expression
--   
--   <ul>
--   <li>Evaluates its free variables (<a>dt_env</a>) including divergence
--   info</li>
--   <li>Evaluates its arguments (<a>dt_args</a>)</li>
--   </ul>
data DmdType
DmdType :: !DmdEnv -> ![Demand] -> DmdType

-- | Demands on free variables. See Note [Demand type Divergence]
[dt_env] :: DmdType -> !DmdEnv

-- | Demand on arguments
[dt_args] :: DmdType -> ![Demand]
dmdTypeDepth :: DmdType -> Arity

-- | The demand type of doing nothing (lazy, absent, no Divergence
--   information). Note that it is '<tt>not'</tt> the top of the lattice
--   (which would be "may use everything"), so it is (no longer) called
--   topDmdType.
nopDmdType :: DmdType
botDmdType :: DmdType

-- | Compute the least upper bound of two <a>DmdType</a>s elicited /by the
--   same incoming demand/!
lubDmdType :: DmdType -> DmdType -> DmdType
plusDmdType :: DmdType -> DmdEnv -> DmdType
multDmdType :: Card -> DmdType -> DmdType
discardArgDmds :: DmdType -> DmdEnv
peelFV :: DmdType -> Var -> (DmdType, Demand)
findIdDemand :: DmdType -> Var -> Demand
addDemand :: Demand -> DmdType -> DmdType
splitDmdTy :: DmdType -> (Demand, DmdType)

-- | When e is evaluated after executing an IO action that may throw a
--   precise exception, we act as if there is an additional control flow
--   path that is taken if e throws a precise exception. The demand type of
--   this control flow path * is lazy and absent (<a>topDmd</a>) and boxed
--   in all free variables and arguments * has <a>exnDiv</a>
--   <a>Divergence</a> result See Note [Precise exceptions and strictness
--   analysis]
--   
--   So we can simply take a variant of <a>nopDmdType</a>,
--   <a>exnDmdType</a>. Why not <a>nopDmdType</a>? Because then the result
--   of <tt>e</tt> can never be <a>exnDiv</a>! That means failure to drop
--   dead-ends, see #18086.
deferAfterPreciseException :: DmdType -> DmdType

-- | The depth of the wrapped <a>DmdType</a> encodes the arity at which it
--   is safe to unleash. Better construct this through
--   <a>mkDmdSigForArity</a>. See Note [Understanding DmdType and DmdSig]
newtype DmdSig
DmdSig :: DmdType -> DmdSig

-- | Turns a <a>DmdType</a> computed for the particular <a>Arity</a> into a
--   <a>DmdSig</a> unleashable at that arity. See Note [Understanding
--   DmdType and DmdSig].
mkDmdSigForArity :: Arity -> DmdType -> DmdSig
mkClosedDmdSig :: [Demand] -> Divergence -> DmdSig
mkVanillaDmdSig :: Arity -> Divergence -> DmdSig
splitDmdSig :: DmdSig -> ([Demand], Divergence)
dmdSigDmdEnv :: DmdSig -> DmdEnv
hasDemandEnvSig :: DmdSig -> Bool
nopSig :: DmdSig
botSig :: DmdSig
isNopSig :: DmdSig -> Bool

-- | True if the signature diverges or throws an imprecise exception in a
--   saturated call. NB: In constrast to <a>isDeadEndSig</a> this returns
--   False for <a>exnDiv</a>. See Note [Dead ends] and Note [Precise vs
--   imprecise exceptions].
isBottomingSig :: DmdSig -> Bool

-- | True if the signature diverges or throws an exception in a saturated
--   call. See Note [Dead ends].
isDeadEndSig :: DmdSig -> Bool

-- | Returns true if an application to n value args would diverge or throw
--   an exception.
--   
--   If a function having <a>botDiv</a> is applied to a less number of
--   arguments than its syntactic arity, we cannot say for sure that it is
--   going to diverge. Hence this function conservatively returns False in
--   that case. See Note [Dead ends].
isDeadEndAppSig :: DmdSig -> Int -> Bool
trimBoxityDmdSig :: DmdSig -> DmdSig
transferArgBoxityDmdSig :: DmdSig -> DmdSig -> DmdSig

-- | Add extra (<a>topDmd</a>) arguments to a strictness signature. In
--   contrast to <a>etaConvertDmdSig</a>, this <i>prepends</i> additional
--   argument demands. This is used by FloatOut.
prependArgsDmdSig :: Int -> DmdSig -> DmdSig

-- | We are expanding (x y. e) to (x y z. e z) or reducing from the latter
--   to the former (when the Simplifier identifies a new join points, for
--   example). In contrast to <a>prependArgsDmdSig</a>, this <i>appends</i>
--   extra arg demands if necessary. This works by looking at the
--   <a>DmdType</a> (which was produced under a call demand for the old
--   arity) and trying to transfer as many facts as we can to the call
--   demand of new arity. An arity increase (resulting in a stronger
--   incoming demand) can retain much of the info, while an arity decrease
--   (a weakening of the incoming demand) must fall back to a conservative
--   default.
etaConvertDmdSig :: Arity -> DmdSig -> DmdSig

-- | A <i>demand transformer</i> is a monotone function from an incoming
--   evaluation context (<a>SubDemand</a>) to a <a>DmdType</a>, describing
--   how the denoted thing (i.e. expression, function) uses its arguments
--   and free variables, and whether it diverges.
--   
--   See Note [Understanding DmdType and DmdSig] and Note [DmdSig: demand
--   signatures, and demand-sig arity]
type DmdTransformer = SubDemand -> DmdType

-- | Extrapolate a demand signature (<a>DmdSig</a>) into a
--   <a>DmdTransformer</a>.
--   
--   Given a function's <a>DmdSig</a> and a <a>SubDemand</a> for the
--   evaluation context, return how the function evaluates its free
--   variables and arguments.
dmdTransformSig :: DmdSig -> DmdTransformer

-- | A special <a>DmdTransformer</a> for data constructors that feeds
--   product demands into the constructor arguments.
dmdTransformDataConSig :: [StrictnessMark] -> DmdTransformer

-- | A special <a>DmdTransformer</a> for dictionary selectors that feeds
--   the demand on the result into the indicated dictionary component (if
--   saturated). See Note [Demand transformer for a dictionary selector].
dmdTransformDictSelSig :: DmdSig -> DmdTransformer
data TypeShape
TsFun :: TypeShape -> TypeShape
TsProd :: [TypeShape] -> TypeShape
TsUnk :: TypeShape
trimToType :: Demand -> TypeShape -> Demand

-- | Drop all boxity
trimBoxity :: Demand -> Demand
seqDemand :: Demand -> ()
seqDemandList :: [Demand] -> ()
seqDmdType :: DmdType -> ()
seqDmdSig :: DmdSig -> ()
zapUsageDemand :: Demand -> Demand

-- | Remove the demand environment from the signature.
zapDmdEnvSig :: DmdSig -> DmdSig

-- | Remove all `C_01 :*` info (but not <tt>CM</tt> sub-demands) from the
--   demand
zapUsedOnceDemand :: Demand -> Demand

-- | Remove all `C_01 :*` info (but not <tt>CM</tt> sub-demands) from the
--   strictness signature
zapUsedOnceSig :: DmdSig -> DmdSig
instance GHC.Utils.Binary.Binary GHC.Types.Demand.Card
instance GHC.Utils.Binary.Binary GHC.Types.Demand.Demand
instance GHC.Utils.Binary.Binary GHC.Types.Demand.Divergence
instance GHC.Utils.Binary.Binary GHC.Types.Demand.DmdEnv
instance GHC.Utils.Binary.Binary GHC.Types.Demand.DmdSig
instance GHC.Utils.Binary.Binary GHC.Types.Demand.DmdType
instance GHC.Utils.Binary.Binary GHC.Types.Demand.SubDemand
instance GHC.Classes.Eq GHC.Types.Demand.Card
instance GHC.Classes.Eq GHC.Types.Demand.Demand
instance GHC.Classes.Eq GHC.Types.Demand.Divergence
instance GHC.Classes.Eq GHC.Types.Demand.DmdEnv
instance GHC.Classes.Eq GHC.Types.Demand.DmdSig
instance GHC.Classes.Eq GHC.Types.Demand.DmdType
instance GHC.Classes.Eq GHC.Types.Demand.SubDemand
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.Card
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.Demand
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.Divergence
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.DmdEnv
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.DmdSig
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.DmdType
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.SubDemand
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.TypeShape
instance GHC.Internal.Show.Show GHC.Types.Demand.Card


-- | Types for the Constructed Product Result lattice.
--   <a>GHC.Core.Opt.CprAnal</a> and <a>GHC.Core.Opt.WorkWrap.Utils</a> are
--   its primary customers via <a>idCprSig</a>.
module GHC.Types.Cpr
data Cpr
pattern ConCpr :: ConTag -> [Cpr] -> Cpr
topCpr :: Cpr
botCpr :: Cpr
flatConCpr :: ConTag -> Cpr
asConCpr :: Cpr -> Maybe (ConTag, [Cpr])

-- | The abstract domain &lt;math&gt; from the original 'CPR for Haskell'
--   paper.
data CprType
CprType :: !Arity -> !Cpr -> CprType

-- | Number of value arguments the denoted expression eats before returning
--   the <a>ct_cpr</a>
[ct_arty] :: CprType -> !Arity

-- | <a>Cpr</a> eventually unleashed when applied to <a>ct_arty</a>
--   arguments
[ct_cpr] :: CprType -> !Cpr
topCprType :: CprType
botCprType :: CprType
flatConCprType :: ConTag -> CprType
lubCprType :: CprType -> CprType -> CprType
applyCprTy :: CprType -> Arity -> CprType
abstractCprTy :: CprType -> CprType
trimCprTy :: CprType -> CprType

-- | The result of <a>unpackConFieldsCpr</a>.
data UnpackConFieldsResult
AllFieldsSame :: !Cpr -> UnpackConFieldsResult
ForeachField :: ![Cpr] -> UnpackConFieldsResult

-- | Unpacks a <a>ConCpr</a>-shaped <a>Cpr</a> and returns the field
--   <a>Cpr</a>s wrapped in a <a>ForeachField</a>. Otherwise, it returns
--   <a>AllFieldsSame</a> with the appropriate <a>Cpr</a> to assume for
--   each field.
--   
--   The use of <a>UnpackConFieldsResult</a> allows O(1) space for the
--   common, non-<a>ConCpr</a> case.
unpackConFieldsCpr :: DataCon -> Cpr -> UnpackConFieldsResult

-- | The arity of the wrapped <a>CprType</a> is the arity at which it is
--   safe to unleash. See Note [Understanding DmdType and DmdSig] in
--   <a>GHC.Types.Demand</a>
newtype CprSig
CprSig :: CprType -> CprSig
[getCprSig] :: CprSig -> CprType
topCprSig :: CprSig
isTopCprSig :: CprSig -> Bool

-- | Turns a <a>CprType</a> computed for the particular <a>Arity</a> into a
--   <a>CprSig</a> unleashable at that arity. See Note [Understanding
--   DmdType and DmdSig] in <a>GHC.Types.Demand</a>
mkCprSigForArity :: Arity -> CprType -> CprSig
mkCprSig :: Arity -> Cpr -> CprSig
seqCprSig :: CprSig -> ()

-- | Add extra value args to CprSig
prependArgsCprSig :: Arity -> CprSig -> CprSig
instance GHC.Utils.Binary.Binary GHC.Types.Cpr.Cpr
instance GHC.Utils.Binary.Binary GHC.Types.Cpr.CprSig
instance GHC.Utils.Binary.Binary GHC.Types.Cpr.CprType
instance GHC.Classes.Eq GHC.Types.Cpr.Cpr
instance GHC.Classes.Eq GHC.Types.Cpr.CprSig
instance GHC.Classes.Eq GHC.Types.Cpr.CprType
instance GHC.Utils.Outputable.Outputable GHC.Types.Cpr.Cpr
instance GHC.Utils.Outputable.Outputable GHC.Types.Cpr.CprSig
instance GHC.Utils.Outputable.Outputable GHC.Types.Cpr.CprType

module GHC.StgToCmm.Types

-- | Codegen-generated Id infos, to be passed to downstream via interfaces.
--   
--   This stuff is for optimization purposes only, they're not compulsory.
--   
--   <ul>
--   <li>When CafInfo of an imported Id is not known it's safe to treat it
--   as CAFFY.</li>
--   <li>When LambdaFormInfo of an imported Id is not known it's safe to
--   treat it as `LFUnknown True` (which just says "it could be anything"
--   and we do slow entry).</li>
--   </ul>
--   
--   See also Note [Conveying CAF-info and LFInfo between modules] above.
data CmmCgInfos
CmmCgInfos :: !NonCaffySet -> !ModuleLFInfos -> !CStub -> CmmCgInfos

-- | Exported Non-CAFFY closures in the current module. Everything else is
--   either not exported of CAFFY.
[cgNonCafs] :: CmmCgInfos -> !NonCaffySet

-- | LambdaFormInfos of exported closures in the current module.
[cgLFInfos] :: CmmCgInfos -> !ModuleLFInfos

-- | The C stub which is used for IPE information
[cgIPEStub] :: CmmCgInfos -> !CStub

-- | Information about an identifier, from the code generator's point of
--   view. Every identifier is bound to a LambdaFormInfo in the
--   environment, which gives the code generator enough info to be able to
--   tail call or return that identifier.
data LambdaFormInfo
LFReEntrant :: !TopLevelFlag -> !RepArity -> !Bool -> !ArgDescr -> LambdaFormInfo
LFThunk :: !TopLevelFlag -> !Bool -> !Bool -> !StandardFormInfo -> !Bool -> LambdaFormInfo
LFCon :: !DataCon -> LambdaFormInfo
LFUnknown :: !Bool -> LambdaFormInfo
LFUnlifted :: LambdaFormInfo
LFLetNoEscape :: LambdaFormInfo

-- | Maps names in the current module to their LambdaFormInfos
type ModuleLFInfos = NameEnv LambdaFormInfo

-- | StandardFormInfo tells whether this thunk has one of a small number of
--   standard forms
data StandardFormInfo
NonStandardThunk :: StandardFormInfo
SelectorThunk :: !WordOff -> StandardFormInfo
ApThunk :: !RepArity -> StandardFormInfo
type DoSCCProfiling = Bool
type DoExtDynRefs = Bool
instance GHC.Classes.Eq GHC.StgToCmm.Types.StandardFormInfo
instance GHC.Utils.Outputable.Outputable GHC.StgToCmm.Types.LambdaFormInfo
instance GHC.Utils.Outputable.Outputable GHC.StgToCmm.Types.StandardFormInfo

module GHC.Core.ConLike

-- | A constructor-like thing
data ConLike
RealDataCon :: DataCon -> ConLike
PatSynCon :: PatSyn -> ConLike
conLikeConLikeName :: ConLike -> ConLikeName

-- | Is this a 'vanilla' constructor-like thing (no existentials, no
--   provided constraints)?
isVanillaConLike :: ConLike -> Bool

-- | Number of arguments
conLikeArity :: ConLike -> Arity

-- | Names of fields used for selectors
conLikeFieldLabels :: ConLike -> [FieldLabel]

-- | The <a>ConInfo</a> (arity and field labels) associated to a
--   <a>ConLike</a>.
conLikeConInfo :: ConLike -> ConInfo

-- | Returns just the instantiated <i>value</i> argument types of a
--   <a>ConLike</a>, (excluding dictionary args)
conLikeInstOrigArgTys :: ConLike -> [Type] -> [Scaled Type]

-- | <a>TyVarBinder</a>s for the type variables of the <a>ConLike</a>. For
--   pattern synonyms, this will always consist of the universally
--   quantified variables followed by the existentially quantified type
--   variables. For data constructors, the situation is slightly more
--   complicated—see <tt>Note [DataCon user type variable binders]</tt> in
--   <a>GHC.Core.DataCon</a>.
conLikeUserTyVarBinders :: ConLike -> [InvisTVBinder]

-- | Existentially quantified type/coercion variables
conLikeExTyCoVars :: ConLike -> [TyCoVar]
conLikeName :: ConLike -> Name

-- | The "stupid theta" of the <a>ConLike</a>, such as <tt>data Eq a</tt>
--   in:
--   
--   <pre>
--   data Eq a =&gt; T a = ...
--   </pre>
--   
--   It is empty for <a>PatSynCon</a> as they do not allow such contexts.
--   See <tt>Note [The stupid context]</tt> in <a>GHC.Core.DataCon</a>.
conLikeStupidTheta :: ConLike -> ThetaType

-- | Returns the strictness information for each constructor
conLikeImplBangs :: ConLike -> [HsImplBang]

-- | The "full signature" of the <a>ConLike</a> returns, in order:
--   
--   1) The universally quantified type variables
--   
--   2) The existentially quantified type/coercion variables
--   
--   3) The equality specification
--   
--   4) The provided theta (the constraints provided by a match)
--   
--   5) The required theta (the constraints required for a match)
--   
--   6) The original argument types (i.e. before any change of the
--   representation of the type)
--   
--   7) The original result type
conLikeFullSig :: ConLike -> ([TyVar], [TyCoVar], [EqSpec], ThetaType, ThetaType, [Scaled Type], Type)

-- | Returns the type of the whole pattern
conLikeResTy :: ConLike -> [Type] -> Type

-- | Extract the type for any given labelled field of the <a>ConLike</a>
conLikeFieldType :: ConLike -> FieldLabelString -> Type

-- | The ConLikes that have *all* the given fields
conLikesWithFields :: [ConLike] -> [FieldLabelString] -> ([ConLike], [ConLike])
conLikeIsInfix :: ConLike -> Bool

-- | <a>conLikeHasBuilder</a> returns True except for uni-directional
--   pattern synonyms, which have no builder
conLikeHasBuilder :: ConLike -> Bool
instance GHC.Internal.Data.Data.Data GHC.Core.ConLike.ConLike
instance GHC.Classes.Eq GHC.Core.ConLike.ConLike
instance GHC.Types.Name.NamedThing GHC.Core.ConLike.ConLike
instance GHC.Utils.Outputable.OutputableBndr GHC.Core.ConLike.ConLike
instance GHC.Utils.Outputable.Outputable GHC.Core.ConLike.ConLike
instance GHC.Types.Unique.Uniquable GHC.Core.ConLike.ConLike


-- | COMPLETE signature
module GHC.Types.CompleteMatch

-- | A list of conlikes which represents a complete pattern match. These
--   arise from <tt>COMPLETE</tt> signatures. See also Note [Implementation
--   of COMPLETE pragmas].
data CompleteMatchX con
CompleteMatch :: UniqDSet con -> Maybe Name -> CompleteMatchX con

-- | The set of constructor names
[cmConLikes] :: CompleteMatchX con -> UniqDSet con

-- | The optional, concrete result TyCon name the set applies to
[cmResultTyCon] :: CompleteMatchX con -> Maybe Name
type CompleteMatch = CompleteMatchX Name
type CompleteMatches = [CompleteMatch]
type DsCompleteMatch = CompleteMatchX ConLike
type DsCompleteMatches = [DsCompleteMatch]
mkCompleteMatch :: UniqDSet con -> Maybe Name -> CompleteMatchX con
vanillaCompleteMatch :: UniqDSet con -> CompleteMatchX con

-- | Does this <tt>COMPLETE</tt> set apply at this type?
--   
--   See the part about "result type constructors" in Note [Implementation
--   of COMPLETE pragmas] in GHC.HsToCore.Pmc.Solver.
completeMatchAppliesAtType :: Type -> CompleteMatchX con -> Bool
instance GHC.Classes.Eq (GHC.Types.CompleteMatch.CompleteMatchX con)
instance GHC.Utils.Outputable.Outputable con => GHC.Utils.Outputable.Outputable (GHC.Types.CompleteMatch.CompleteMatchX con)


-- | GHC.Core holds all the main data types for use by for the Glasgow
--   Haskell Compiler midsection
module GHC.Core

-- | This is the data type that represents GHCs core intermediate language.
--   Currently GHC uses System FC
--   <a>https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions/</a>
--   for this purpose, which is closely related to the simpler and better
--   known System F <a>http://en.wikipedia.org/wiki/System_F</a>.
--   
--   We get from Haskell source to this Core language in a number of
--   stages:
--   
--   <ol>
--   <li>The source code is parsed into an abstract syntax tree, which is
--   represented by the data type <a>HsExpr</a> with the names being
--   <a>RdrNames</a></li>
--   <li>This syntax tree is <i>renamed</i>, which attaches a <a>Unique</a>
--   to every <a>RdrName</a> (yielding a <a>Name</a>) to disambiguate
--   identifiers which are lexically identical. For example, this
--   program:</li>
--   </ol>
--   
--   <pre>
--   f x = let f x = x + 1
--         in f (x - 2)
--   </pre>
--   
--   Would be renamed by having <tt>Unique</tt>s attached so it looked
--   something like this:
--   
--   <pre>
--   f_1 x_2 = let f_3 x_4 = x_4 + 1
--             in f_3 (x_2 - 2)
--   </pre>
--   
--   But see Note [Shadowing in Core] below.
--   
--   <ol>
--   <li>The resulting syntax tree undergoes type checking (which also
--   deals with instantiating type class arguments) to yield a
--   <a>HsExpr</a> type that has <a>Id</a> as it's names.</li>
--   <li>Finally the syntax tree is <i>desugared</i> from the expressive
--   <a>HsExpr</a> type into this <a>Expr</a> type, which has far fewer
--   constructors and hence is easier to perform optimization, analysis and
--   code generation on.</li>
--   </ol>
--   
--   The type parameter <tt>b</tt> is for the type of binders in the
--   expression tree.
--   
--   The language consists of the following elements:
--   
--   <ul>
--   <li>Variables See Note [Variable occurrences in Core]</li>
--   <li>Primitive literals</li>
--   <li>Applications: note that the argument may be a <a>Type</a>. See
--   Note [Representation polymorphism invariants]</li>
--   <li>Lambda abstraction See Note [Representation polymorphism
--   invariants]</li>
--   <li>Recursive and non recursive <tt>let</tt>s. Operationally this
--   corresponds to allocating a thunk for the things bound and then
--   executing the sub-expression.</li>
--   </ul>
--   
--   See Note [Core letrec invariant] See Note [Core let-can-float
--   invariant] See Note [Representation polymorphism invariants] See Note
--   [Core type and coercion invariant]
--   
--   <ul>
--   <li>Case expression. Operationally this corresponds to evaluating the
--   scrutinee (expression examined) to weak head normal form and then
--   examining at most one level of resulting constructor (i.e. you cannot
--   do nested pattern matching directly with this).</li>
--   </ul>
--   
--   The binder gets bound to the value of the scrutinee, and the
--   <a>Type</a> must be that of all the case alternatives
--   
--   IMPORTANT: see Note [Case expression invariants]
--   
--   <ul>
--   <li>Cast an expression to a particular type. This is used to implement
--   <tt>newtype</tt>s (a <tt>newtype</tt> constructor or destructor just
--   becomes a <a>Cast</a> in Core) and GADTs.</li>
--   <li>Ticks. These are used to represent all the source annotation we
--   support: profiling SCCs, HPC ticks, and GHCi breakpoints.</li>
--   <li>A type: this should only show up at the top level of an Arg</li>
--   <li>A coercion</li>
--   </ul>
data Expr b
Var :: Id -> Expr b
Lit :: Literal -> Expr b
App :: Expr b -> Arg b -> Expr b
Lam :: b -> Expr b -> Expr b
Let :: Bind b -> Expr b -> Expr b
Case :: Expr b -> b -> Type -> [Alt b] -> Expr b
Cast :: Expr b -> CoercionR -> Expr b
Tick :: CoreTickish -> Expr b -> Expr b
Type :: Type -> Expr b
Coercion :: Coercion -> Expr b
infixl 4 `App`

-- | A case split alternative. Consists of the constructor leading to the
--   alternative, the variables bound from the constructor, and the
--   expression to be executed given that binding. The default alternative
--   is <tt>(DEFAULT, [], rhs)</tt>
data Alt b
Alt :: AltCon -> [b] -> Expr b -> Alt b

-- | Binding, used for top level bindings in a module and local bindings in
--   a <tt>let</tt>.
data Bind b
NonRec :: b -> Expr b -> Bind b
Rec :: [(b, Expr b)] -> Bind b

-- | A case alternative constructor (i.e. pattern match)
data AltCon
DataAlt :: DataCon -> AltCon

-- | A literal: <tt>case e of { 1 -&gt; ... }</tt> Invariant: always an
--   *unlifted* literal See Note [Literal alternatives]
LitAlt :: Literal -> AltCon

-- | Trivial alternative: <tt>case e of { _ -&gt; ... }</tt>
DEFAULT :: AltCon

-- | Type synonym for expressions that occur in function argument
--   positions. Only <a>Arg</a> should contain a <a>Type</a> at top level,
--   general <a>Expr</a> should not
type Arg b = Expr b
type CoreProgram = [CoreBind]

-- | Expressions where binders are <a>CoreBndr</a>s
type CoreExpr = Expr CoreBndr

-- | Case alternatives where binders are <a>CoreBndr</a>s
type CoreAlt = Alt CoreBndr

-- | Binding groups where binders are <a>CoreBndr</a>s
type CoreBind = Bind CoreBndr

-- | Argument expressions where binders are <a>CoreBndr</a>s
type CoreArg = Arg CoreBndr

-- | The common case for the type of binders and variables when we are
--   manipulating the Core language within GHC
type CoreBndr = Var
type TaggedExpr t = Expr TaggedBndr t
type TaggedAlt t = Alt TaggedBndr t
type TaggedBind t = Bind TaggedBndr t
type TaggedArg t = Arg TaggedBndr t

-- | Binders are <i>tagged</i> with a t
data TaggedBndr t
TB :: CoreBndr -> t -> TaggedBndr t
deTagExpr :: TaggedExpr t -> CoreExpr
type InId = Id
type InBind = CoreBind
type InExpr = CoreExpr
type InAlt = CoreAlt
type InArg = CoreArg
type InType = Type
type InKind = Kind
type InBndr = CoreBndr
type InVar = Var
type InCoercion = Coercion
type InTyVar = TyVar
type InCoVar = CoVar
type OutId = Id
type OutBind = CoreBind
type OutExpr = CoreExpr
type OutAlt = CoreAlt
type OutArg = CoreArg
type OutType = Type
type OutKind = Kind
type OutBndr = CoreBndr
type OutVar = Var
type OutCoercion = Coercion
type OutTyVar = TyVar
type OutCoVar = CoVar
type MOutCoercion = MCoercion
mkLet :: Bind b -> Expr b -> Expr b

-- | Bind all supplied binding groups over an expression in a nested let
--   expression. Assumes that the rhs satisfies the let-can-float
--   invariant. Prefer to use <a>mkCoreLets</a> if possible, which does
--   guarantee the invariant
mkLets :: [Bind b] -> Expr b -> Expr b

-- | <tt>mkLetNonRec bndr rhs body</tt> wraps <tt>body</tt> in a
--   <tt>let</tt> binding <tt>bndr</tt>.
mkLetNonRec :: b -> Expr b -> Expr b -> Expr b

-- | <tt>mkLetRec binds body</tt> wraps <tt>body</tt> in a <tt>let rec</tt>
--   with the given set of <tt>binds</tt> if binds is non-empty.
mkLetRec :: [(b, Expr b)] -> Expr b -> Expr b

-- | Bind all supplied binders over an expression in a nested lambda
--   expression. Prefer to use <a>mkCoreLams</a> if possible
mkLams :: [b] -> Expr b -> Expr b

-- | Apply a list of argument expressions to a function expression in a
--   nested fashion. Prefer to use <a>mkCoreApps</a> if possible
mkApps :: Expr b -> [Arg b] -> Expr b
infixl 4 `mkApps`

-- | Apply a list of type argument expressions to a function expression in
--   a nested fashion
mkTyApps :: Expr b -> [Type] -> Expr b
infixl 4 `mkTyApps`

-- | Apply a list of coercion argument expressions to a function expression
--   in a nested fashion
mkCoApps :: Expr b -> [Coercion] -> Expr b
infixl 4 `mkCoApps`

-- | Apply a list of type or value variables to a function expression in a
--   nested fashion
mkVarApps :: Expr b -> [Var] -> Expr b
infixl 4 `mkVarApps`
mkTyArg :: Type -> Expr b

-- | Create a machine integer literal expression of type <tt>Int#</tt> from
--   an <tt>Integer</tt>. If you want an expression of type <tt>Int</tt>
--   use <a>mkIntExpr</a>
mkIntLit :: Platform -> Integer -> Expr b

-- | Create a machine integer literal expression of type <tt>Int#</tt> from
--   an <tt>Integer</tt>, wrapping if necessary. If you want an expression
--   of type <tt>Int</tt> use <a>mkIntExpr</a>
mkIntLitWrap :: Platform -> Integer -> Expr b

-- | Create a machine word literal expression of type <tt>Word#</tt> from
--   an <tt>Integer</tt>. If you want an expression of type <tt>Word</tt>
--   use <a>mkWordExpr</a>
mkWordLit :: Platform -> Integer -> Expr b

-- | Create a machine word literal expression of type <tt>Word#</tt> from
--   an <tt>Integer</tt>, wrapping if necessary. If you want an expression
--   of type <tt>Word</tt> use <a>mkWordExpr</a>
mkWordLitWrap :: Platform -> Integer -> Expr b
mkWord8Lit :: Integer -> Expr b
mkWord32LitWord32 :: Word32 -> Expr b
mkWord64LitWord64 :: Word64 -> Expr b
mkInt64LitInt64 :: Int64 -> Expr b

-- | Create a machine character literal expression of type <tt>Char#</tt>.
--   If you want an expression of type <tt>Char</tt> use <a>mkCharExpr</a>
mkCharLit :: Char -> Expr b

-- | Create a machine string literal expression of type <tt>Addr#</tt>. If
--   you want an expression of type <tt>String</tt> use <a>mkStringExpr</a>
mkStringLit :: String -> Expr b

-- | Create a machine single precision literal expression of type
--   <tt>Float#</tt> from a <tt>Rational</tt>. If you want an expression of
--   type <tt>Float</tt> use <a>mkFloatExpr</a>
mkFloatLit :: Rational -> Expr b

-- | Create a machine single precision literal expression of type
--   <tt>Float#</tt> from a <tt>Float</tt>. If you want an expression of
--   type <tt>Float</tt> use <a>mkFloatExpr</a>
mkFloatLitFloat :: Float -> Expr b

-- | Create a machine double precision literal expression of type
--   <tt>Double#</tt> from a <tt>Rational</tt>. If you want an expression
--   of type <tt>Double</tt> use <a>mkDoubleExpr</a>
mkDoubleLit :: Rational -> Expr b

-- | Create a machine double precision literal expression of type
--   <tt>Double#</tt> from a <tt>Double</tt>. If you want an expression of
--   type <tt>Double</tt> use <a>mkDoubleExpr</a>
mkDoubleLitDouble :: Double -> Expr b

-- | Apply a list of argument expressions to a data constructor in a nested
--   fashion. Prefer to use <a>mkCoreConApps</a> if possible
mkConApp :: DataCon -> [Arg b] -> Expr b
mkConApp2 :: DataCon -> [Type] -> [Var] -> Expr b

-- | Create a binding group where a type variable is bound to a type. Per
--   Note [Core type and coercion invariant], this can only be used to bind
--   something in a non-recursive <tt>let</tt> expression
mkTyBind :: TyVar -> Type -> CoreBind

-- | Create a binding group where a type variable is bound to a type. Per
--   Note [Core type and coercion invariant], this can only be used to bind
--   something in a non-recursive <tt>let</tt> expression
mkCoBind :: CoVar -> Coercion -> CoreBind

-- | Convert a binder into either a <a>Var</a> or <a>Type</a> <a>Expr</a>
--   appropriately
varToCoreExpr :: CoreBndr -> Expr b
varsToCoreExprs :: [CoreBndr] -> [Expr b]

-- | Helper function. You can use the result of <a>mkBinds</a> with
--   <a>mkLets</a> for instance.
--   
--   <ul>
--   <li><tt><a>mkBinds</a> <a>Recursive</a> binds</tt> makes a single
--   mutually-recursive bindings with all the rhs/lhs pairs in
--   <tt>binds</tt></li>
--   <li><tt><a>mkBinds</a> <a>NonRecursive</a> binds</tt> makes one
--   non-recursive binding for each rhs/lhs pairs in <tt>binds</tt></li>
--   </ul>
mkBinds :: RecFlag -> [(b, Expr b)] -> [Bind b]

-- | Is this a value-level (i.e., computationally relevant)
--   <a>Id</a>entifier? Satisfies <tt>isId = not . isTyVar</tt>.
isId :: Var -> Bool

-- | Compares <a>AltCon</a>s within a single list of alternatives DEFAULT
--   comes out smallest, so that sorting by AltCon puts alternatives in the
--   order required: see Note [Case expression invariants]
cmpAltCon :: AltCon -> AltCon -> Ordering
cmpAlt :: Alt a -> Alt a -> Ordering
ltAlt :: Alt a -> Alt a -> Bool

-- | Extract every variable by this group
bindersOf :: Bind b -> [b]

-- | <a>bindersOf</a> applied to a list of binding groups
bindersOfBinds :: [Bind b] -> [b]
rhssOfBind :: Bind b -> [Expr b]
rhssOfAlts :: [Alt b] -> [Expr b]
foldBindersOfBindStrict :: (a -> b -> a) -> a -> Bind b -> a
foldBindersOfBindsStrict :: (a -> b -> a) -> a -> [Bind b] -> a

-- | We often want to strip off leading lambdas before getting down to
--   business. Variants are <a>collectTyBinders</a>,
--   <a>collectValBinders</a>, and <a>collectTyAndValBinders</a>
collectBinders :: Expr b -> ([b], Expr b)
collectTyBinders :: CoreExpr -> ([TyVar], CoreExpr)
collectTyAndValBinders :: CoreExpr -> ([TyVar], [Id], CoreExpr)

-- | Strip off exactly N leading lambdas (type or value). Good for use with
--   join points. Panic if there aren't enough
collectNBinders :: JoinArity -> Expr b -> ([b], Expr b)

-- | Strip off exactly N leading value lambdas returning all the binders
--   found up to that point Return Nothing if there aren't enough
collectNValBinders_maybe :: Arity -> CoreExpr -> Maybe ([Var], CoreExpr)

-- | Takes a nested application expression and returns the function being
--   applied and the arguments to which it is applied
collectArgs :: Expr b -> (Expr b, [Arg b])

-- | Attempt to remove the last N arguments of a function call. Strip off
--   any ticks or coercions encountered along the way and any at the end.
stripNArgs :: Word -> Expr a -> Maybe (Expr a)

-- | Like <tt>collectArgs</tt>, but also looks through floatable ticks if
--   it means that we can find more arguments.
collectArgsTicks :: (CoreTickish -> Bool) -> Expr b -> (Expr b, [Arg b], [CoreTickish])

-- | Collapse all the bindings in the supplied groups into a single list of
--   lhs/rhs pairs suitable for binding in a <a>Rec</a> binding group
flattenBinds :: [Bind b] -> [(b, Expr b)]

-- | Takes a nested application expression and returns the function being
--   applied. Looking through casts and ticks to find it.
collectFunSimple :: Expr b -> Expr b

-- | If the expression is a <a>Type</a>, converts. Otherwise, panics. NB:
--   This does <i>not</i> convert <a>Coercion</a> to <tt>CoercionTy</tt>.
exprToType :: CoreExpr -> Type

-- | fmap on the body of a lambda. wrapLamBody f (x -&gt; body) == (x -&gt;
--   f body)
wrapLamBody :: (CoreExpr -> CoreExpr) -> CoreExpr -> CoreExpr

-- | Returns <tt>True</tt> for value arguments, false for type args NB:
--   coercions are value arguments (zero width, to be sure, like State#,
--   but still value args).
isValArg :: Expr b -> Bool

-- | Returns <tt>True</tt> iff the expression is a <a>Type</a> expression
--   at its top level. Note this does NOT include <a>Coercion</a>s.
isTypeArg :: Expr b -> Bool

-- | Returns <tt>True</tt> iff the expression is a <a>Coercion</a>
--   expression at its top level
isCoArg :: Expr b -> Bool

-- | Returns <tt>True</tt> iff the expression is a <a>Type</a> or
--   <a>Coercion</a> expression at its top level
isTyCoArg :: Expr b -> Bool

-- | The number of argument expressions that are values rather than types
--   at their top level
valArgCount :: [Arg b] -> Int

-- | The number of binders that bind values rather than types
valBndrCount :: [CoreBndr] -> Int

-- | Will this argument expression exist at runtime?
isRuntimeArg :: CoreExpr -> Bool

-- | Will this variable exist at runtime?
isRuntimeVar :: Var -> Bool

-- | Records the <i>unfolding</i> of an identifier, which is approximately
--   the form the identifier would have if we substituted its definition in
--   for the identifier. This type should be treated as abstract everywhere
--   except in <a>GHC.Core.Unfold</a>
data Unfolding

-- | We have no information about the unfolding.
NoUnfolding :: Unfolding

-- | We have no information about the unfolding, because this <a>Id</a>
--   came from an <tt>hi-boot</tt> file. See Note [Inlining and hs-boot
--   files] in <a>GHC.CoreToIface</a> for what this is used for.
BootUnfolding :: Unfolding

-- | It ain't one of these constructors. <tt>OtherCon xs</tt> also
--   indicates that something has been evaluated and hence there's no point
--   in re-evaluating it. <tt>OtherCon []</tt> is used even for
--   non-data-type values to indicated evaluated-ness. Notably:
--   
--   <pre>
--   data C = C !(Int -&gt; Int)
--   case x of { C f -&gt; ... }
--   </pre>
--   
--   Here, <tt>f</tt> gets an <tt>OtherCon []</tt> unfolding.
OtherCon :: [AltCon] -> Unfolding
DFunUnfolding :: [Var] -> DataCon -> [CoreExpr] -> Unfolding
[df_bndrs] :: Unfolding -> [Var]
[df_con] :: Unfolding -> DataCon
[df_args] :: Unfolding -> [CoreExpr]

-- | An unfolding with redundant cached information. Parameters:
--   
--   uf_tmpl: Template used to perform unfolding; NB: Occurrence info is
--   guaranteed correct: see Note [OccInfo in unfoldings and rules]
--   
--   uf_is_top: Is this a top level binding?
--   
--   uf_is_value: <tt>exprIsHNF</tt> template (cached); it is ok to discard
--   a <a>seq</a> on this variable
--   
--   uf_is_work_free: Does this waste only a little work if we expand it
--   inside an inlining? Basically this is a cached version of
--   <tt>exprIsWorkFree</tt>
--   
--   uf_guidance: Tells us about the <i>size</i> of the unfolding template
CoreUnfolding :: CoreExpr -> UnfoldingSource -> Bool -> UnfoldingCache -> UnfoldingGuidance -> Unfolding
[uf_tmpl] :: Unfolding -> CoreExpr
[uf_src] :: Unfolding -> UnfoldingSource
[uf_is_top] :: Unfolding -> Bool
[uf_cache] :: Unfolding -> UnfoldingCache
[uf_guidance] :: Unfolding -> UnfoldingGuidance

-- | Properties of a <a>CoreUnfolding</a> that could be computed on-demand
--   from its template. See Note [UnfoldingCache]
data UnfoldingCache
UnfoldingCache :: !Bool -> !Bool -> !Bool -> !Bool -> UnfoldingCache
[uf_is_value] :: UnfoldingCache -> !Bool
[uf_is_conlike] :: UnfoldingCache -> !Bool
[uf_is_work_free] :: UnfoldingCache -> !Bool
[uf_expandable] :: UnfoldingCache -> !Bool

-- | <a>UnfoldingGuidance</a> says when unfolding should take place
data UnfoldingGuidance
UnfWhen :: Arity -> Bool -> Bool -> UnfoldingGuidance
[ug_arity] :: UnfoldingGuidance -> Arity
[ug_unsat_ok] :: UnfoldingGuidance -> Bool
[ug_boring_ok] :: UnfoldingGuidance -> Bool
UnfIfGoodArgs :: [Int] -> Int -> Int -> UnfoldingGuidance
[ug_args] :: UnfoldingGuidance -> [Int]
[ug_size] :: UnfoldingGuidance -> Int
[ug_res] :: UnfoldingGuidance -> Int
UnfNever :: UnfoldingGuidance
data UnfoldingSource
VanillaSrc :: UnfoldingSource
StableUserSrc :: UnfoldingSource
StableSystemSrc :: UnfoldingSource
CompulsorySrc :: UnfoldingSource

-- | There is no known <a>Unfolding</a>
noUnfolding :: Unfolding

-- | There is no known <a>Unfolding</a>, because this came from an hi-boot
--   file.
bootUnfolding :: Unfolding

-- | This unfolding marks the associated thing as being evaluated
evaldUnfolding :: Unfolding
mkOtherCon :: [AltCon] -> Unfolding
unSaturatedOk :: Bool
needSaturated :: Bool
boringCxtOk :: Bool
boringCxtNotOk :: Bool

-- | Retrieves the template of an unfolding: panics if none is known
unfoldingTemplate :: Unfolding -> CoreExpr
expandUnfolding_maybe :: Unfolding -> Maybe CoreExpr

-- | Retrieves the template of an unfolding if possible
--   maybeUnfoldingTemplate is used mainly when specialising, and we do
--   want to specialise DFuns, so it's important to return a template for
--   DFunUnfoldings
maybeUnfoldingTemplate :: Unfolding -> Maybe CoreExpr

-- | The constructors that the unfolding could never be: returns
--   <tt>[]</tt> if no information is available
otherCons :: Unfolding -> [AltCon]

-- | Determines if it is certainly the case that the unfolding will yield a
--   value (something in HNF): returns <tt>False</tt> if unsure
isValueUnfolding :: Unfolding -> Bool

-- | Determines if it possibly the case that the unfolding will yield a
--   value. Unlike <a>isValueUnfolding</a> it returns <tt>True</tt> for
--   <a>OtherCon</a>
isEvaldUnfolding :: Unfolding -> Bool

-- | Is the thing we will unfold into certainly cheap?
isCheapUnfolding :: Unfolding -> Bool
isExpandableUnfolding :: Unfolding -> Bool

-- | <tt>True</tt> if the unfolding is a constructor application, the
--   application of a CONLIKE function or <a>OtherCon</a>
isConLikeUnfolding :: Unfolding -> Bool
isCompulsoryUnfolding :: Unfolding -> Bool
isStableUnfolding :: Unfolding -> Bool
isStableUserUnfolding :: Unfolding -> Bool
isStableSystemUnfolding :: Unfolding -> Bool

-- | True of a <i>stable</i> unfolding that is (a) always inlined; that is,
--   with an <a>UnfWhen</a> guidance, or (b) a DFunUnfolding which never
--   needs to be inlined
isInlineUnfolding :: Unfolding -> Bool
isBootUnfolding :: Unfolding -> Bool
isBetterUnfoldingThan :: Unfolding -> Unfolding -> Bool
hasCoreUnfolding :: Unfolding -> Bool

-- | Only returns False if there is no unfolding information available at
--   all
hasSomeUnfolding :: Unfolding -> Bool
canUnfold :: Unfolding -> Bool
neverUnfoldGuidance :: UnfoldingGuidance -> Bool
isStableSource :: UnfoldingSource -> Bool

-- | Annotated core: allows annotation at every node in the tree
type AnnExpr bndr annot = (annot, AnnExpr' bndr annot)

-- | A clone of the <a>Expr</a> type but allowing annotation at every tree
--   node
data AnnExpr' bndr annot
AnnVar :: Id -> AnnExpr' bndr annot
AnnLit :: Literal -> AnnExpr' bndr annot
AnnLam :: bndr -> AnnExpr bndr annot -> AnnExpr' bndr annot
AnnApp :: AnnExpr bndr annot -> AnnExpr bndr annot -> AnnExpr' bndr annot
AnnCase :: AnnExpr bndr annot -> bndr -> Type -> [AnnAlt bndr annot] -> AnnExpr' bndr annot
AnnLet :: AnnBind bndr annot -> AnnExpr bndr annot -> AnnExpr' bndr annot
AnnCast :: AnnExpr bndr annot -> (annot, Coercion) -> AnnExpr' bndr annot
AnnTick :: CoreTickish -> AnnExpr bndr annot -> AnnExpr' bndr annot
AnnType :: Type -> AnnExpr' bndr annot
AnnCoercion :: Coercion -> AnnExpr' bndr annot

-- | A clone of the <a>Bind</a> type but allowing annotation at every tree
--   node
data AnnBind bndr annot
AnnNonRec :: bndr -> AnnExpr bndr annot -> AnnBind bndr annot
AnnRec :: [(bndr, AnnExpr bndr annot)] -> AnnBind bndr annot

-- | A clone of the <a>Alt</a> type but allowing annotation at every tree
--   node
data AnnAlt bndr annot
AnnAlt :: AltCon -> [bndr] -> AnnExpr bndr annot -> AnnAlt bndr annot

-- | Takes a nested application expression and returns the function being
--   applied and the arguments to which it is applied
collectAnnArgs :: AnnExpr b a -> (AnnExpr b a, [AnnExpr b a])
collectAnnArgsTicks :: (CoreTickish -> Bool) -> AnnExpr b a -> (AnnExpr b a, [AnnExpr b a], [CoreTickish])
deAnnotate :: AnnExpr bndr annot -> Expr bndr
deAnnotate' :: AnnExpr' bndr annot -> Expr bndr
deAnnAlt :: AnnAlt bndr annot -> Alt bndr
deAnnBind :: AnnBind b annot -> Bind b

-- | As <a>collectBinders</a> but for <a>AnnExpr</a> rather than
--   <a>Expr</a>
collectAnnBndrs :: AnnExpr bndr annot -> ([bndr], AnnExpr bndr annot)

-- | As <a>collectNBinders</a> but for <a>AnnExpr</a> rather than
--   <a>Expr</a>
collectNAnnBndrs :: Int -> AnnExpr bndr annot -> ([bndr], AnnExpr bndr annot)

-- | Is this instance an orphan? If it is not an orphan, contains an
--   <a>OccName</a> witnessing the instance's non-orphanhood. See Note
--   [Orphans]
data IsOrphan
IsOrphan :: IsOrphan
NotOrphan :: !OccName -> IsOrphan

-- | Returns true if <a>IsOrphan</a> is orphan.
isOrphan :: IsOrphan -> Bool

-- | Returns true if <a>IsOrphan</a> is not an orphan.
notOrphan :: IsOrphan -> Bool
chooseOrphanAnchor :: NameSet -> IsOrphan

-- | A <a>CoreRule</a> is:
--   
--   <ul>
--   <li>"Local" if the function it is a rule for is defined in the same
--   module as the rule itself.</li>
--   <li>"Orphan" if nothing on the LHS is defined in the same module as
--   the rule itself</li>
--   </ul>
data CoreRule
Rule :: RuleName -> Activation -> !Name -> [Maybe Name] -> [CoreBndr] -> [CoreExpr] -> CoreExpr -> Bool -> !Module -> !IsOrphan -> Bool -> CoreRule

-- | Name of the rule, for communication with the user
[ru_name] :: CoreRule -> RuleName

-- | When the rule is active
[ru_act] :: CoreRule -> Activation

-- | Name of the <a>Id</a> at the head of this rule
[ru_fn] :: CoreRule -> !Name

-- | Name at the head of each argument to the left hand side
[ru_rough] :: CoreRule -> [Maybe Name]

-- | Variables quantified over
[ru_bndrs] :: CoreRule -> [CoreBndr]

-- | Left hand side arguments
[ru_args] :: CoreRule -> [CoreExpr]

-- | Right hand side of the rule Occurrence info is guaranteed correct See
--   Note [OccInfo in unfoldings and rules]
[ru_rhs] :: CoreRule -> CoreExpr

-- | <tt>True</tt> <a>=</a> this rule is auto-generated (notably by
--   Specialise or SpecConstr) <tt>False</tt> <a>=</a> generated at the
--   user's behest See Note [Trimming auto-rules] in <a>GHC.Iface.Tidy</a>
--   for the sole purpose of this field.
[ru_auto] :: CoreRule -> Bool

-- | <a>Module</a> the rule was defined in, used to test if we should see
--   an orphan rule.
[ru_origin] :: CoreRule -> !Module

-- | Whether or not the rule is an orphan.
[ru_orphan] :: CoreRule -> !IsOrphan

-- | <tt>True</tt> iff the fn at the head of the rule is defined in the
--   same module as the rule and is not an implicit <a>Id</a> (like a
--   record selector, class operation, or data constructor). This is
--   different from <a>ru_orphan</a>, where a rule can avoid being an
--   orphan if *any* Name in LHS of the rule was defined in the same module
--   as the rule.
[ru_local] :: CoreRule -> Bool

-- | Built-in rules are used for constant folding and suchlike. They have
--   no free variables. A built-in rule is always visible (there is no such
--   thing as an orphan built-in rule.)
BuiltinRule :: RuleName -> Name -> Int -> RuleFun -> CoreRule

-- | Name of the rule, for communication with the user
[ru_name] :: CoreRule -> RuleName

-- | Name of the <a>Id</a> at the head of this rule
[ru_fn] :: CoreRule -> Name

-- | Number of arguments that <a>ru_try</a> consumes, if it fires,
--   including type arguments
[ru_nargs] :: CoreRule -> Int

-- | This function does the rewrite. It given too many arguments, it simply
--   discards them; the returned <a>CoreExpr</a> is just the rewrite of
--   <a>ru_fn</a> applied to the first <a>ru_nargs</a> args
[ru_try] :: CoreRule -> RuleFun
type RuleName = FastString
type RuleFun = RuleOpts -> InScopeEnv -> Id -> [CoreExpr] -> Maybe CoreExpr
type IdUnfoldingFun = Id -> Unfolding

-- | The <a>InScopeSet</a> in the <a>InScopeEnv</a> is a <i>superset</i> of
--   variables that are currently in scope. See Note [The InScopeSet
--   invariant].
data InScopeEnv
ISE :: InScopeSet -> IdUnfoldingFun -> InScopeEnv

-- | Rule options
data RuleOpts

-- | The number of arguments the <a>ru_fn</a> must be applied to before the
--   rule can match on it
ruleArity :: CoreRule -> Int
ruleName :: CoreRule -> RuleName

-- | The <a>Name</a> of the <a>Id</a> at the head of the rule left hand
--   side
ruleIdName :: CoreRule -> Name
ruleActivation :: CoreRule -> Activation

-- | Set the <a>Name</a> of the <a>Id</a> at the head of the rule left hand
--   side
setRuleIdName :: Name -> CoreRule -> CoreRule
ruleModule :: CoreRule -> Maybe Module
isBuiltinRule :: CoreRule -> Bool
isLocalRule :: CoreRule -> Bool
isAutoRule :: CoreRule -> Bool
instance GHC.Utils.Binary.Binary GHC.Core.IsOrphan
instance GHC.Internal.Data.Data.Data b => GHC.Internal.Data.Data.Data (GHC.Core.Alt b)
instance GHC.Internal.Data.Data.Data GHC.Core.AltCon
instance GHC.Internal.Data.Data.Data b => GHC.Internal.Data.Data.Data (GHC.Core.Bind b)
instance GHC.Internal.Data.Data.Data b => GHC.Internal.Data.Data.Data (GHC.Core.Expr b)
instance GHC.Internal.Data.Data.Data GHC.Core.IsOrphan
instance GHC.Classes.Eq GHC.Core.AltCon
instance GHC.Classes.Eq GHC.Core.UnfoldingCache
instance GHC.Classes.Eq GHC.Core.UnfoldingGuidance
instance GHC.Classes.Ord GHC.Core.AltCon
instance GHC.Utils.Outputable.Outputable GHC.Core.AltCon
instance GHC.Utils.Outputable.Outputable b => GHC.Utils.Outputable.Outputable (GHC.Core.TaggedBndr b)

module GHC.Types.Id.Info

-- | Identifier Details
--   
--   The <a>IdDetails</a> of an <tt>Id</tt> give stable, and necessary,
--   information about the Id.
data IdDetails
VanillaId :: IdDetails

-- | The <tt>Id</tt> for a record selector
RecSelId :: RecSelParent -> FieldLabel -> Bool -> ([ConLike], [ConLike]) -> IdDetails
[sel_tycon] :: IdDetails -> RecSelParent
[sel_fieldLabel] :: IdDetails -> FieldLabel
[sel_naughty] :: IdDetails -> Bool
[sel_cons] :: IdDetails -> ([ConLike], [ConLike])

-- | The <tt>Id</tt> is for a data constructor <i>worker</i>
DataConWorkId :: DataCon -> IdDetails

-- | The <tt>Id</tt> is for a data constructor <i>wrapper</i>
DataConWrapId :: DataCon -> IdDetails

-- | The <tt>Id</tt> is a superclass selector or class operation
ClassOpId :: Class -> Bool -> IdDetails

-- | A representation-polymorphic pseudo-op.
RepPolyId :: ConcreteTyVars -> IdDetails

-- | Which type variables of this representation-polymorphic 'Id should be
--   instantiated to concrete type variables?
--   
--   See Note [Representation-polymorphism checking built-ins] in
--   GHC.Tc.Utils.Concrete.
[id_concrete_tvs] :: IdDetails -> ConcreteTyVars

-- | The <tt>Id</tt> is for a primitive operator.
PrimOpId :: PrimOp -> ConcreteTyVars -> IdDetails
[id_primop] :: IdDetails -> PrimOp

-- | Which type variables of this representation-polymorphic 'Id should be
--   instantiated to concrete type variables?
--   
--   See Note [Representation-polymorphism checking built-ins] in
--   GHC.Tc.Utils.Concrete.
[id_concrete_tvs] :: IdDetails -> ConcreteTyVars

-- | The <tt>Id</tt> is for a foreign call. Type will be simple: no type
--   families, newtypes, etc
FCallId :: ForeignCall -> IdDetails

-- | The <tt>Id</tt> is for a HPC tick box (both traditional and binary)
TickBoxOpId :: TickBoxOp -> IdDetails

-- | A dictionary function. Bool = True <a>=</a> the class has only one
--   method, so may be implemented with a newtype, so it might be bad to be
--   strict on this dictionary
DFunId :: Bool -> IdDetails

-- | A coercion variable This only covers <i>un-lifted</i> coercions, of
--   type (t1 ~# t2) or (t1 ~R# t2), not their lifted variants
CoVarId :: IdDetails

-- | An <tt>Id</tt> for a join point taking n arguments Note [Join points]
--   in <a>GHC.Core</a> Can also work as a WorkerLikeId if given
--   <a>CbvMark</a>s. See Note [CBV Function Ids] The [CbvMark] is always
--   empty (and ignored) until after Tidy.
JoinId :: JoinArity -> Maybe [CbvMark] -> IdDetails

-- | An <tt>Id</tt> for a worker like function, which might expect some
--   arguments to be passed both evaluated and tagged. Worker like
--   functions are create by W/W and SpecConstr and we can expect that they
--   aren't used unapplied. See Note [CBV Function Ids] See Note [Tag
--   Inference] The [CbvMark] is always empty (and ignored) until after
--   Tidy for ids from the current module.
WorkerLikeId :: [CbvMark] -> IdDetails
pprIdDetails :: IdDetails -> SDoc

-- | Just a synonym for <a>CoVarId</a>. Written separately so it can be
--   exported in the hs-boot file.
coVarDetails :: IdDetails

-- | Check if an <a>IdDetails</a> says <a>CoVarId</a>.
isCoVarDetails :: IdDetails -> Bool

-- | The number of arguments that a join point takes. Unlike the arity of a
--   function, this is a purely syntactic property and is fixed when the
--   join point is created (or converted from a value). Both type and value
--   arguments are counted.
type JoinArity = Int
isJoinIdDetails_maybe :: IdDetails -> Maybe (JoinArity, Maybe [CbvMark])

-- | Parent of a record selector function.
--   
--   Either the parent <a>TyCon</a> or <a>PatSyn</a> depending on the
--   origin of the record selector.
--   
--   For a data family, this is the <i>instance</i> <a>TyCon</a>, **not**
--   the family <a>TyCon</a>.
data RecSelParent

-- | Parent of a data constructor record field.
--   
--   For a data family, this is the <i>instance</i> <a>TyCon</a>.
RecSelData :: TyCon -> RecSelParent

-- | Parent of a pattern synonym record field: the <a>PatSyn</a> itself.
RecSelPatSyn :: PatSyn -> RecSelParent
recSelParentName :: RecSelParent -> Name
recSelFirstConName :: RecSelParent -> Name
recSelParentCons :: RecSelParent -> [ConLike]
idDetailsConcreteTvs :: IdDetails -> ConcreteTyVars

-- | Identifier Information
--   
--   An <a>IdInfo</a> gives <i>optional</i> information about an
--   <tt>Id</tt>. If present it never lies, but it may not be present, in
--   which case there is always a conservative assumption which can be
--   made.
--   
--   Two <tt>Id</tt>s may have different info even though they have the
--   same <tt>Unique</tt> (and are hence the same <tt>Id</tt>); for
--   example, one might lack the properties attached to the other.
--   
--   Most of the <a>IdInfo</a> gives information about the value, or
--   definition, of the <tt>Id</tt>, independent of its usage. Exceptions
--   to this are <a>demandInfo</a>, <a>occInfo</a>, <a>oneShotInfo</a> and
--   <a>callArityInfo</a>.
--   
--   Performance note: when we update <a>IdInfo</a>, we have to reallocate
--   this entire record, so it is a good idea not to let this data
--   structure get too big.
data IdInfo

-- | Basic <a>IdInfo</a> that carries no useful information whatsoever
vanillaIdInfo :: IdInfo

-- | More informative <a>IdInfo</a> we can use when we know the <tt>Id</tt>
--   has no CAF references
noCafIdInfo :: IdInfo

-- | If the <tt>Id</tt> is a lambda-bound variable then it may have
--   lambda-bound variable info. Sometimes we know whether the lambda
--   binding this variable is a "one-shot" lambda; that is, whether it is
--   applied at most once.
--   
--   This information may be useful in optimisation, as computations may
--   safely be floated inside such a lambda without risk of duplicating
--   work.
--   
--   See also Note [OneShotInfo overview] above.
data OneShotInfo

-- | No information
NoOneShotInfo :: OneShotInfo

-- | The lambda is applied at most once.
OneShotLam :: OneShotInfo

-- | Info about a lambda-bound variable, if the <tt>Id</tt> is one
oneShotInfo :: IdInfo -> OneShotInfo

-- | It is always safe to assume that an <tt>Id</tt> has no lambda-bound
--   variable information
noOneShotInfo :: OneShotInfo
hasNoOneShotInfo :: OneShotInfo -> Bool
setOneShotInfo :: IdInfo -> OneShotInfo -> IdInfo
infixl 1 `setOneShotInfo`

-- | This is used to remove information on lambda binders that we have
--   setup as part of a lambda group, assuming they will be applied all at
--   once, but turn out to be part of an unsaturated lambda as in e.g:
--   
--   <pre>
--   (\x1. \x2. e) arg1
--   </pre>
zapLamInfo :: IdInfo -> Maybe IdInfo

-- | Zap info that depends on free variables
zapFragileInfo :: IdInfo -> Maybe IdInfo

-- | Lazify (remove the top-level demand, only) the demand in <a>IdInfo</a>
--   Keep nested demands; see Note [Floatifying demand info when floating]
--   in GHC.Core.Opt.SetLevels
lazifyDemandInfo :: IdInfo -> Maybe IdInfo

-- | Floatify the demand in <a>IdInfo</a> But keep <i>nested</i> demands;
--   see Note [Floatifying demand info when floating] in
--   GHC.Core.Opt.SetLevels
floatifyDemandInfo :: IdInfo -> Maybe IdInfo

-- | Remove usage (but not strictness) info on the <a>IdInfo</a>
zapUsageInfo :: IdInfo -> Maybe IdInfo

-- | Remove usage environment info from the strictness signature on the
--   <a>IdInfo</a>
zapUsageEnvInfo :: IdInfo -> Maybe IdInfo
zapUsedOnceInfo :: IdInfo -> Maybe IdInfo
zapTailCallInfo :: IdInfo -> Maybe IdInfo
zapCallArityInfo :: IdInfo -> IdInfo
trimUnfolding :: Unfolding -> Unfolding

-- | Arity Information
--   
--   An <a>ArityInfo</a> of <tt>n</tt> tells us that partial application of
--   this <tt>Id</tt> to up to <tt>n-1</tt> value arguments does
--   essentially no work.
--   
--   That is not necessarily the same as saying that it has <tt>n</tt>
--   leading lambdas, because coerces may get in the way.
--   
--   The arity might increase later in the compilation process, if an extra
--   lambda floats up to the binding site.
--   
--   <i>Invariant:</i> the <a>Arity</a> of an <tt>Id</tt> must never exceed
--   the number of value arguments that appear in the type of the
--   <tt>Id</tt>. See Note [Arity and function types].
type ArityInfo = Arity

-- | It is always safe to assume that an <tt>Id</tt> has an arity of 0
unknownArity :: Arity

-- | <tt>Id</tt> arity, as computed by <a>GHC.Core.Opt.Arity</a>. Specifies
--   how many arguments this <tt>Id</tt> has to be applied to before it
--   does any meaningful work.
arityInfo :: IdInfo -> ArityInfo
setArityInfo :: IdInfo -> ArityInfo -> IdInfo
infixl 1 `setArityInfo`
ppArityInfo :: Int -> SDoc

-- | How this is called. This is the number of arguments to which a binding
--   can be eta-expanded without losing any sharing. n <a>=</a> all calls
--   have at least n arguments
callArityInfo :: IdInfo -> ArityInfo
setCallArityInfo :: IdInfo -> ArityInfo -> IdInfo

-- | A strictness signature. Describes how a function uses its arguments
--   See Note [idArity varies independently of dmdTypeDepth] in
--   GHC.Core.Opt.DmdAnal
dmdSigInfo :: IdInfo -> DmdSig
setDmdSigInfo :: IdInfo -> DmdSig -> IdInfo
infixl 1 `setDmdSigInfo`

-- | Information on whether the function will ultimately return a freshly
--   allocated constructor.
cprSigInfo :: IdInfo -> CprSig
setCprSigInfo :: IdInfo -> CprSig -> IdInfo
infixl 1 `setCprSigInfo`

-- | ID demand information
demandInfo :: IdInfo -> Demand
setDemandInfo :: IdInfo -> Demand -> IdInfo
infixl 1 `setDemandInfo`
pprStrictness :: DmdSig -> SDoc

-- | The <tt>Id</tt>s unfolding
realUnfoldingInfo :: IdInfo -> Unfolding

-- | Essentially returns the <a>realUnfoldingInfo</a> field, but does not
--   expose the unfolding of a strong loop breaker.
--   
--   This is the right thing to call if you plan to decide whether an
--   unfolding will inline.
unfoldingInfo :: IdInfo -> Unfolding
setUnfoldingInfo :: IdInfo -> Unfolding -> IdInfo
infixl 1 `setUnfoldingInfo`

-- | True of a <i>non-loop-breaker</i> Id that has a <i>stable</i>
--   unfolding that is (a) always inlined; that is, with an <a>UnfWhen</a>
--   guidance, or (b) a DFunUnfolding which never needs to be inlined
hasInlineUnfolding :: IdInfo -> Bool

-- | Inline Pragma Information
--   
--   Tells when the inlining is active. When it is active the thing may be
--   inlined, depending on how big it is.
--   
--   If there was an <tt>INLINE</tt> pragma, then as a separate matter, the
--   RHS will have been made to look small with a Core inline <tt>Note</tt>
--   
--   The default <a>InlinePragInfo</a> is <a>AlwaysActive</a>, so the info
--   serves entirely as a way to inhibit inlining until we want it
type InlinePragInfo = InlinePragma

-- | Any inline pragma attached to the <tt>Id</tt>
inlinePragInfo :: IdInfo -> InlinePragma
setInlinePragInfo :: IdInfo -> InlinePragma -> IdInfo
infixl 1 `setInlinePragInfo`

-- | identifier Occurrence Information
data OccInfo

-- | There are many occurrences, or unknown occurrences
ManyOccs :: !TailCallInfo -> OccInfo
[occ_tail] :: OccInfo -> !TailCallInfo

-- | Marks unused variables. Sometimes useful for lambda and case-bound
--   variables.
IAmDead :: OccInfo

-- | Occurs exactly once (per branch), not inside a rule
OneOcc :: !InsideLam -> {-# UNPACK #-} !BranchCount -> !InterestingCxt -> !TailCallInfo -> OccInfo
[occ_in_lam] :: OccInfo -> !InsideLam
[occ_n_br] :: OccInfo -> {-# UNPACK #-} !BranchCount
[occ_int_cxt] :: OccInfo -> !InterestingCxt
[occ_tail] :: OccInfo -> !TailCallInfo

-- | This identifier breaks a loop of mutually recursive functions. The
--   field marks whether it is only a loop breaker due to a reference in a
--   rule
IAmALoopBreaker :: !RulesOnly -> !TailCallInfo -> OccInfo
[occ_rules_only] :: OccInfo -> !RulesOnly
[occ_tail] :: OccInfo -> !TailCallInfo
isDeadOcc :: OccInfo -> Bool
isStrongLoopBreaker :: OccInfo -> Bool
isWeakLoopBreaker :: OccInfo -> Bool

-- | How the <tt>Id</tt> occurs in the program
occInfo :: IdInfo -> OccInfo
setOccInfo :: IdInfo -> OccInfo -> IdInfo
infixl 1 `setOccInfo`

-- | Inside Lambda
data InsideLam

-- | Occurs inside a non-linear lambda Substituting a redex for this
--   occurrence is dangerous because it might duplicate work.
IsInsideLam :: InsideLam
NotInsideLam :: InsideLam
type BranchCount = Int
data TailCallInfo
AlwaysTailCalled :: {-# UNPACK #-} !JoinArity -> TailCallInfo
NoTailCallInfo :: TailCallInfo
tailCallInfo :: OccInfo -> TailCallInfo
isAlwaysTailCalled :: OccInfo -> Bool

-- | Rule Information
--   
--   Records the specializations of this <tt>Id</tt> that we know about in
--   the form of rewrite <a>CoreRule</a>s that target them
data RuleInfo
RuleInfo :: [CoreRule] -> DVarSet -> RuleInfo

-- | Assume that no specializations exist: always safe
emptyRuleInfo :: RuleInfo
isEmptyRuleInfo :: RuleInfo -> Bool

-- | Retrieve the locally-defined free variables of both the left and right
--   hand sides of the specialization rules
ruleInfoFreeVars :: RuleInfo -> DVarSet
ruleInfoRules :: RuleInfo -> [CoreRule]

-- | Change the name of the function the rule is keyed on all of the
--   <a>CoreRule</a>s
setRuleInfoHead :: Name -> RuleInfo -> RuleInfo

-- | Specialisations of the <tt>Id</tt>s function which exist. See Note
--   [Specialisations and RULES in IdInfo]
ruleInfo :: IdInfo -> RuleInfo
setRuleInfo :: IdInfo -> RuleInfo -> IdInfo
infixl 1 `setRuleInfo`
tagSigInfo :: IdInfo -> Maybe TagSig

-- | Constant applicative form Information
--   
--   Records whether an <tt>Id</tt> makes Constant Applicative Form
--   references
data CafInfo

-- | Indicates that the <tt>Id</tt> is for either:
--   
--   <ol>
--   <li>A function or static constructor that refers to one or more CAFs,
--   or</li>
--   <li>A real live CAF</li>
--   </ol>
MayHaveCafRefs :: CafInfo

-- | A function or static constructor that refers to no CAFs.
NoCafRefs :: CafInfo
ppCafInfo :: CafInfo -> SDoc
mayHaveCafRefs :: CafInfo -> Bool

-- | <tt>Id</tt> CAF info
cafInfo :: IdInfo -> CafInfo
setCafInfo :: IdInfo -> CafInfo -> IdInfo
infixl 1 `setCafInfo`

-- | Information about an identifier, from the code generator's point of
--   view. Every identifier is bound to a LambdaFormInfo in the
--   environment, which gives the code generator enough info to be able to
--   tail call or return that identifier.
data LambdaFormInfo

-- | If lfInfo = Just info, then the <tt>info</tt> is guaranteed
--   <i>correct</i>. If lfInfo = Nothing, then we do not have a
--   <a>LambdaFormInfo</a> for this Id, so (for imported Ids) we make a
--   conservative version. See Note [The LFInfo of Imported Ids] in
--   GHC.StgToCmm.Closure For locally-defined Ids other than DataCons, the
--   <a>lfInfo</a> field is always Nothing. See also Note [LFInfo of
--   DataCon workers and wrappers]
lfInfo :: IdInfo -> Maybe LambdaFormInfo
setLFInfo :: IdInfo -> LambdaFormInfo -> IdInfo
infixl 1 `setLFInfo`
setTagSig :: IdInfo -> TagSig -> IdInfo
tagSig :: IdInfo -> Maybe TagSig

-- | Tick box for Hpc-style coverage
data TickBoxOp
TickBox :: Module -> {-# UNPACK #-} !TickBoxId -> TickBoxOp
type TickBoxId = Int
instance GHC.Internal.Data.Data.Data GHC.Types.Id.Info.RecSelParent
instance GHC.Classes.Eq GHC.Types.Id.Info.CafInfo
instance GHC.Classes.Eq GHC.Types.Id.Info.RecSelParent
instance GHC.Classes.Ord GHC.Types.Id.Info.CafInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Id.Info.CafInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Id.Info.IdDetails
instance GHC.Utils.Outputable.Outputable GHC.Types.Id.Info.RecSelParent
instance GHC.Utils.Outputable.Outputable GHC.Types.Id.Info.TickBoxOp


-- | GHC uses several kinds of name internally:
--   
--   <ul>
--   <li><a>OccName</a>: see
--   <a>GHC.Types.Name.Occurrence#name_types</a></li>
--   <li><a>RdrName</a>: see <a>GHC.Types.Name.Reader#name_types</a></li>
--   <li><a>Name</a>: see <a>GHC.Types.Name#name_types</a></li>
--   <li><a>Id</a> represents names that not only have a <a>Name</a> but
--   also a <a>Type</a> and some additional details (a <a>IdInfo</a> and
--   one of LocalIdDetails or GlobalIdDetails) that are added, modified and
--   inspected by various compiler passes. These <a>Var</a> names may
--   either be global or local, see <a>GHC.Types.Var#globalvslocal</a></li>
--   <li><a>Var</a>: see <a>GHC.Types.Var#name_types</a></li>
--   </ul>
module GHC.Types.Id

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var

-- | Identifier
type Id = Var

-- | Is this a value-level (i.e., computationally relevant)
--   <a>Id</a>entifier? Satisfies <tt>isId = not . isTyVar</tt>.
isId :: Var -> Bool
type InVar = Var
type InId = Id
type OutVar = Var
type OutId = Id

-- | For an explanation of global vs. local <a>Id</a>s, see
--   <a>GHC.Types.Var.Var#globalvslocal</a>
mkGlobalId :: IdDetails -> Name -> Type -> IdInfo -> Id

-- | Make a global <a>Id</a> without any extra information at all
mkVanillaGlobal :: HasDebugCallStack => Name -> Type -> Id

-- | Make a global <a>Id</a> with no global information but some generic
--   <a>IdInfo</a>
mkVanillaGlobalWithInfo :: HasDebugCallStack => Name -> Type -> IdInfo -> Id

-- | For an explanation of global vs. local <a>Id</a>s, see
--   <a>GHC.Types.Var#globalvslocal</a>
mkLocalId :: HasDebugCallStack => Name -> Mult -> Type -> Id

-- | Make a local CoVar
mkLocalCoVar :: HasDebugCallStack => Name -> Type -> CoVar

-- | Like <a>mkLocalId</a>, but checks the type to see if it should make a
--   covar
mkLocalIdOrCoVar :: HasDebugCallStack => Name -> Mult -> Type -> Id
mkLocalIdWithInfo :: HasDebugCallStack => Name -> Mult -> Type -> IdInfo -> Id

-- | Create a local <a>Id</a> that is marked as exported. This prevents
--   things attached to it from being removed as dead code. See Note
--   [Exported LocalIds]
mkExportedLocalId :: IdDetails -> Name -> Type -> Id
mkExportedVanillaId :: Name -> Type -> Id

-- | Create a system local <a>Id</a>. These are local <a>Id</a>s (see
--   <a>Var#globalvslocal</a>) that are created by the compiler out of thin
--   air
mkSysLocal :: FastString -> Unique -> Mult -> Type -> Id
mkSysLocalM :: MonadUnique m => FastString -> Mult -> Type -> m Id

-- | Like <a>mkSysLocal</a>, but checks to see if we have a covar type
mkSysLocalOrCoVar :: FastString -> Unique -> Mult -> Type -> Id
mkSysLocalOrCoVarM :: MonadUnique m => FastString -> Mult -> Type -> m Id

-- | Create a user local <a>Id</a>. These are local <a>Id</a>s (see
--   <a>GHC.Types.Var#globalvslocal</a>) with a name and location that the
--   user might recognize
mkUserLocal :: OccName -> Unique -> Mult -> Type -> SrcSpan -> Id

-- | Like <a>mkUserLocal</a>, but checks if we have a coercion type
mkUserLocalOrCoVar :: OccName -> Unique -> Mult -> Type -> SrcSpan -> Id

-- | Create a template local for a series of types
mkTemplateLocals :: [Type] -> [Id]

-- | Create a template local for a series of type, but start from a
--   specified template local
mkTemplateLocalsNum :: Int -> [Type] -> [Id]

-- | Create a <i>template local</i>: a family of system local <a>Id</a>s in
--   bijection with <tt>Int</tt>s, typically used in unfoldings
mkTemplateLocal :: Int -> Type -> Id
mkScaledTemplateLocal :: Int -> Scaled Type -> Id

-- | Workers get local names. <a>CoreTidy</a> will externalise these if
--   necessary
mkWorkerId :: Unique -> Id -> Type -> Id
idName :: Id -> Name
idType :: Id -> Kind
idMult :: Id -> Mult
idScaledType :: Id -> Scaled Type
idUnique :: Id -> Unique
idInfo :: HasDebugCallStack => Id -> IdInfo
idDetails :: Id -> IdDetails

-- | If the <a>Id</a> is that for a record selector, extract the
--   <a>sel_tycon</a>. Panic otherwise.
recordSelectorTyCon :: Id -> RecSelParent
recordSelectorTyCon_maybe :: Id -> Maybe RecSelParent
setIdName :: Id -> Name -> Id
setIdUnique :: Id -> Unique -> Id

-- | Not only does this set the <a>Id</a> <a>Type</a>, it also evaluates
--   the type to try and reduce space usage
setIdType :: Id -> Type -> Id
setIdMult :: Id -> Mult -> Id
updateIdTypeButNotMult :: (Type -> Type) -> Id -> Id
updateIdTypeAndMult :: (Type -> Type) -> Id -> Id
updateIdTypeAndMultM :: Monad m => (Type -> m Type) -> Id -> m Id
setIdExported :: Id -> Id
setIdNotExported :: Id -> Id

-- | If it's a local, make it global
globaliseId :: Id -> Id
localiseId :: Id -> Id
setIdInfo :: Id -> IdInfo -> Id
lazySetIdInfo :: Id -> IdInfo -> Id
modifyIdInfo :: HasDebugCallStack => (IdInfo -> IdInfo) -> Id -> Id
maybeModifyIdInfo :: Maybe IdInfo -> Id -> Id
zapLamIdInfo :: Id -> Id
floatifyIdDemandInfo :: Id -> Id
zapIdUsageInfo :: Id -> Id
zapIdUsageEnvInfo :: Id -> Id
zapIdUsedOnceInfo :: Id -> Id
zapIdTailCallInfo :: Id -> Id
zapFragileIdInfo :: Id -> Id
zapIdDmdSig :: Id -> Id
zapStableUnfolding :: Id -> Id
transferPolyIdInfo :: Id -> [Var] -> Id -> Id
scaleIdBy :: Mult -> Id -> Id

-- | Like <a>scaleIdBy</a>, but skips non-Ids. Useful for scaling a mixed
--   list of ids and tyvars.
scaleVarBy :: Mult -> Var -> Var

-- | <a>isImplicitId</a> tells whether an <a>Id</a>s info is implied by
--   other declarations, so we don't need to put its signature in an
--   interface file, even if it's mentioned in some other interface
--   unfolding.
isImplicitId :: Id -> Bool
isDeadBinder :: Id -> Bool

-- | <a>isStrictId</a> says whether either (a) the <a>Id</a> has a strict
--   demand placed on it or (b) definitely has a "strict type", such that
--   it can always be evaluated strictly (i.e an unlifted type) We need to
--   check (b) as well as (a), because when the demand for the given
--   <a>id</a> hasn't been computed yet but <a>id</a> has a strict type, we
--   still want `isStrictId id` to be <a>True</a>. Returns False if the
--   type is levity polymorphic; False is always safe.
isStrictId :: Id -> Bool

-- | <tt>isExportedIdVar</tt> means "don't throw this away"
isExportedId :: Var -> Bool
isLocalId :: Var -> Bool
isGlobalId :: Var -> Bool
isRecordSelector :: Id -> Bool
isNaughtyRecordSelector :: Id -> Bool
isPatSynRecordSelector :: Id -> Bool
isDataConRecordSelector :: Id -> Bool
isClassOpId :: Id -> Bool
isClassOpId_maybe :: Id -> Maybe Class
isDFunId :: Id -> Bool
isPrimOpId :: Id -> Bool
isPrimOpId_maybe :: Id -> Maybe PrimOp
isFCallId :: Id -> Bool
isFCallId_maybe :: Id -> Maybe ForeignCall
isDataConWorkId :: Id -> Bool
isDataConWorkId_maybe :: Id -> Maybe DataCon
isDataConWrapId :: Id -> Bool
isDataConWrapId_maybe :: Id -> Maybe DataCon
isDataConId :: Id -> Bool
isDataConId_maybe :: Id -> Maybe DataCon

-- | Get from either the worker or the wrapper <a>Id</a> to the
--   <a>DataCon</a>. Currently used only in the desugarer.
--   
--   INVARIANT: <tt>idDataCon (dataConWrapId d) = d</tt>: remember,
--   <a>dataConWrapId</a> can return either the wrapper or the worker
idDataCon :: Id -> DataCon
isConLikeId :: Id -> Bool

-- | An Id for which we might require all callers to pass strict arguments
--   properly tagged + evaluated.
--   
--   See Note [CBV Function Ids]
isWorkerLikeId :: Id -> Bool

-- | Returns true if an application to n args diverges or throws an
--   exception See Note [Dead ends] in <a>GHC.Types.Demand</a>.
isDeadEndId :: Var -> Bool
idIsFrom :: Module -> Id -> Bool

-- | Returns <tt>True</tt> of an <a>Id</a> which may not have a binding,
--   even though it is defined in this module.
hasNoBinding :: Id -> Bool
type JoinId = Id
data JoinPointHood
isJoinId :: Var -> Bool

-- | Doesn't return strictness marks
idJoinPointHood :: Var -> JoinPointHood
idJoinArity :: JoinId -> JoinArity
asJoinId :: Id -> JoinArity -> JoinId
infixl 1 `asJoinId`
asJoinId_maybe :: Id -> JoinPointHood -> Id
infixl 1 `asJoinId_maybe`
zapJoinId :: Id -> Id
idInlinePragma :: Id -> InlinePragma
setInlinePragma :: Id -> InlinePragma -> Id
infixl 1 `setInlinePragma`
modifyInlinePragma :: Id -> (InlinePragma -> InlinePragma) -> Id
idInlineActivation :: Id -> Activation
setInlineActivation :: Id -> Activation -> Id
infixl 1 `setInlineActivation`
idRuleMatchInfo :: Id -> RuleMatchInfo
setOneShotLambda :: Id -> Id
clearOneShotLambda :: Id -> Id
updOneShotInfo :: Id -> OneShotInfo -> Id
setIdOneShotInfo :: Id -> OneShotInfo -> Id
infixl 1 `setIdOneShotInfo`
idArity :: Id -> Arity
idCallArity :: Id -> Arity

-- | This function counts all arguments post-unarisation, which includes
--   arguments with no runtime representation -- see Note [Unarisation and
--   arity]
idFunRepArity :: Id -> RepArity
idSpecialisation :: Id -> RuleInfo
idCoreRules :: Id -> [CoreRule]
idHasRules :: Id -> Bool
idCafInfo :: Id -> CafInfo
infixl 1 `idCafInfo`
idLFInfo_maybe :: Id -> Maybe LambdaFormInfo
idOneShotInfo :: Id -> OneShotInfo
idOccInfo :: Id -> OccInfo
type IdUnfoldingFun = Id -> Unfolding

-- | Returns the <a>Id</a>s unfolding, but does not expose the unfolding of
--   a strong loop breaker. See <a>unfoldingInfo</a>.
--   
--   If you really want the unfolding of a strong loopbreaker, call
--   <a>realIdUnfolding</a>.
idUnfolding :: IdUnfoldingFun

-- | Expose the unfolding if there is one, including for loop breakers
realIdUnfolding :: Id -> Unfolding

-- | Returns an unfolding only if (a) not a strong loop breaker and (b)
--   always active
alwaysActiveUnfoldingFun :: IdUnfoldingFun

-- | Returns an unfolding only if (a) not a strong loop breaker and (b)
--   active in according to is_active
whenActiveUnfoldingFun :: (Activation -> Bool) -> IdUnfoldingFun
noUnfoldingFun :: IdUnfoldingFun
setIdUnfolding :: Id -> Unfolding -> Id
infixl 1 `setIdUnfolding`

-- | Similar to trimUnfolding, but also removes evaldness info.
zapIdUnfolding :: Id -> Id
setCaseBndrEvald :: StrictnessMark -> Id -> Id
setIdArity :: Id -> Arity -> Id
infixl 1 `setIdArity`
setIdCallArity :: Id -> Arity -> Id
infixl 1 `setIdCallArity`
setIdSpecialisation :: Id -> RuleInfo -> Id
infixl 1 `setIdSpecialisation`
setIdCafInfo :: Id -> CafInfo -> Id
setIdOccInfo :: Id -> OccInfo -> Id
infixl 1 `setIdOccInfo`
zapIdOccInfo :: Id -> Id
setIdLFInfo :: Id -> LambdaFormInfo -> Id
setIdDemandInfo :: Id -> Demand -> Id
infixl 1 `setIdDemandInfo`
setIdDmdSig :: Id -> DmdSig -> Id
infixl 1 `setIdDmdSig`
setIdCprSig :: Id -> CprSig -> Id
infixl 1 `setIdCprSig`

-- | If all marks are NotMarkedStrict we just set nothing.
setIdCbvMarks :: Id -> [CbvMark] -> Id
infixl 1 `setIdCbvMarks`
idCbvMarks_maybe :: Id -> Maybe [CbvMark]
idCbvMarkArity :: Id -> Arity

-- | Turn this id into a WorkerLikeId if possible.
asWorkerLikeId :: Id -> Id

-- | Remove any cbv marks on arguments from a given Id.
asNonWorkerLikeId :: Id -> Id
idDemandInfo :: Id -> Demand

-- | Accesses the <tt>Id'</tt>s <a>dmdSigInfo</a>.
idDmdSig :: Id -> DmdSig
idCprSig :: Id -> CprSig
idTagSig_maybe :: Id -> Maybe TagSig
setIdTagSig :: Id -> TagSig -> Id


-- | A global typecheckable-thing, essentially anything that has a name.
module GHC.Types.TyThing

-- | A global typecheckable-thing, essentially anything that has a name.
--   Not to be confused with a <tt>TcTyThing</tt>, which is also a
--   typecheckable thing but in the *local* context. See
--   <a>GHC.Tc.Utils.Env</a> for how to retrieve a <a>TyThing</a> given a
--   <a>Name</a>.
data TyThing
AnId :: Id -> TyThing
AConLike :: ConLike -> TyThing
ATyCon :: TyCon -> TyThing
ACoAxiom :: CoAxiom Branched -> TyThing

-- | Class that abstracts out the common ability of the monads in GHC to
--   lookup a <a>TyThing</a> in the monadic environment by <a>Name</a>.
--   Provides a number of related convenience functions for accessing
--   particular kinds of <a>TyThing</a>
class Monad m => MonadThings (m :: Type -> Type)
lookupThing :: MonadThings m => Name -> m TyThing
lookupId :: MonadThings m => Name -> m Id
lookupDataCon :: MonadThings m => Name -> m DataCon
lookupTyCon :: MonadThings m => Name -> m TyCon
mkATyCon :: TyCon -> TyThing
mkAnId :: Id -> TyThing
pprShortTyThing :: TyThing -> SDoc
pprTyThingCategory :: TyThing -> SDoc
tyThingCategory :: TyThing -> String

-- | Determine the <a>TyThing</a>s brought into scope by another
--   <a>TyThing</a> <i>other</i> than itself. For example, Id's don't have
--   any implicit TyThings as they just bring themselves into scope, but
--   classes bring their dictionary datatype, type constructor and some
--   selector functions into scope, just for a start!
implicitTyThings :: TyThing -> [TyThing]
implicitConLikeThings :: ConLike -> [TyThing]
implicitClassThings :: Class -> [TyThing]
implicitTyConThings :: TyCon -> [TyThing]
implicitCoTyCon :: TyCon -> [TyThing]

-- | Returns <tt>True</tt> if there should be no interface-file declaration
--   for this thing on its own: either it is built-in, or it is part of
--   some other declaration, or it is generated implicitly by some other
--   declaration.
isImplicitTyThing :: TyThing -> Bool

-- | tyThingParent_maybe x returns (Just p) when pprTyThingInContext should
--   print a declaration for p (albeit with some "..." in it) when asked to
--   show x It returns the *immediate* parent. So a datacon returns its
--   tycon but the tycon could be the associated type of a class, so it in
--   turn might have a parent.
tyThingParent_maybe :: TyThing -> Maybe TyThing
tyThingsTyCoVars :: [TyThing] -> TyCoVarSet

-- | The <a>GlobalRdrElt</a>s that a <a>TyThing</a> should bring into
--   scope. Used to build the <a>GlobalRdrEnv</a> for the
--   InteractiveContext.
tyThingLocalGREs :: TyThing -> [GlobalRdrElt]

-- | Obtain information pertinent to the renamer about a particular
--   <a>TyThing</a>.
--   
--   This extracts out renamer information from typechecker information.
tyThingGREInfo :: TyThing -> GREInfo

-- | Get the <a>TyCon</a> from a <a>TyThing</a> if it is a type constructor
--   thing. Panics otherwise
tyThingTyCon :: HasDebugCallStack => TyThing -> TyCon

-- | Get the <a>CoAxiom</a> from a <a>TyThing</a> if it is a coercion axiom
--   thing. Panics otherwise
tyThingCoAxiom :: HasDebugCallStack => TyThing -> CoAxiom Branched

-- | Get the <a>DataCon</a> from a <a>TyThing</a> if it is a data
--   constructor thing. Panics otherwise
tyThingDataCon :: HasDebugCallStack => TyThing -> DataCon

-- | Get the <a>ConLike</a> from a <a>TyThing</a> if it is a data
--   constructor thing. Panics otherwise
tyThingConLike :: HasDebugCallStack => TyThing -> ConLike

-- | Get the <a>Id</a> from a <a>TyThing</a> if it is a id *or* data
--   constructor thing. Panics otherwise
tyThingId :: HasDebugCallStack => TyThing -> Id
instance GHC.Types.TyThing.MonadThings m => GHC.Types.TyThing.MonadThings (Control.Monad.Trans.Reader.ReaderT s m)
instance GHC.Types.Name.NamedThing GHC.Types.TyThing.TyThing
instance GHC.Utils.Outputable.Outputable GHC.Types.TyThing.TyThing

module GHC.Stg.Subst

-- | A renaming substitution from <a>Id</a>s to <a>Id</a>s. Like
--   <a>RnEnv2</a>, but not maintaining pairs of substitutions. Like
--   <a>Subst</a>, but with the domain being <a>Id</a>s instead of entire
--   <tt>CoreExpr</tt>.
data Subst
Subst :: InScopeSet -> IdSubstEnv -> Subst
type IdSubstEnv = IdEnv Id

-- | <pre>
--   emptySubst = <a>mkEmptySubst</a> <a>emptyInScopeSet</a>
--   </pre>
emptySubst :: Subst

-- | Constructs a new <a>Subst</a> assuming the variables in the given
--   <a>InScopeSet</a> are in scope.
mkEmptySubst :: InScopeSet -> Subst

-- | Substitutes an <a>Id</a> for another one according to the <a>Subst</a>
--   given in a way that avoids shadowing the <a>InScopeSet</a>, returning
--   the result and an updated <a>Subst</a> that should be used by
--   subsequent substitutions.
substBndr :: Id -> Subst -> (Id, Subst)

-- | <pre>
--   substBndrs = runState . traverse (state . substBndr)
--   </pre>
substBndrs :: Traversable f => f Id -> Subst -> (f Id, Subst)

-- | Substitutes an occurrence of an identifier for its counterpart
--   recorded in the <a>Subst</a>.
lookupIdSubst :: HasDebugCallStack => Id -> Subst -> Id

-- | Substitutes an occurrence of an identifier for its counterpart
--   recorded in the <a>Subst</a>. Does not generate a debug warning if the
--   identifier to to substitute wasn't in scope.
noWarnLookupIdSubst :: HasDebugCallStack => Id -> Subst -> Id

-- | Add the <a>Id</a> to the in-scope set and remove any existing
--   substitutions for it.
extendInScope :: Id -> Subst -> Subst

-- | Add a substitution for an <a>Id</a> to the <a>Subst</a>: you must
--   ensure that the in-scope set is such that TyCoSubst Note [The
--   substitution invariant] holds after extending the substitution like
--   this.
extendSubst :: Id -> Id -> Subst -> Subst

module GHC.Stg.Lift.Types

-- | Captures details of the syntax tree relevant to the cost model, such
--   as closures, multi-shot lambdas and case expressions.
data Skeleton
ClosureSk :: !Id -> !DIdSet -> !Skeleton -> Skeleton
RhsSk :: !Card -> !Skeleton -> Skeleton
AltSk :: !Skeleton -> !Skeleton -> Skeleton
BothSk :: !Skeleton -> !Skeleton -> Skeleton
NilSk :: Skeleton
bothSk :: Skeleton -> Skeleton -> Skeleton
altSk :: Skeleton -> Skeleton -> Skeleton
rhsSk :: Card -> Skeleton -> Skeleton

-- | The type used in binder positions in <tt>GenStgExpr</tt>s.
data BinderInfo

-- | Let(-no-escape)-bound thing with a flag indicating whether it occurs
--   as an argument or in a nullary application (see
--   <a>GHC.Stg.Lift.Analysis#arg_occs</a>).
BindsClosure :: !Id -> !Bool -> BinderInfo

-- | Every other kind of binder
BoringBinder :: !Id -> BinderInfo

-- | Gets the bound <a>Id</a> out a <a>BinderInfo</a>.
binderInfoBndr :: BinderInfo -> Id

-- | Returns <a>Nothing</a> for <a>BoringBinder</a>s and <a>Just</a> the
--   flag indicating occurrences as argument or in a nullary applications
--   otherwise.
binderInfoOccursAsArg :: BinderInfo -> Maybe Bool
instance GHC.Utils.Outputable.OutputableBndr GHC.Stg.Lift.Types.BinderInfo
instance GHC.Utils.Outputable.Outputable GHC.Stg.Lift.Types.BinderInfo
instance GHC.Utils.Outputable.Outputable GHC.Stg.Lift.Types.Skeleton

module GHC.Runtime.Eval.Types
data Resume
Resume :: String -> ForeignRef (ResumeContext [HValueRef]) -> ResumeBindings -> [Id] -> ForeignHValue -> Maybe InternalBreakpointId -> SrcSpan -> String -> RemotePtr CostCentreStack -> [History] -> Int -> Resume
[resumeStmt] :: Resume -> String
[resumeContext] :: Resume -> ForeignRef (ResumeContext [HValueRef])
[resumeBindings] :: Resume -> ResumeBindings
[resumeFinalIds] :: Resume -> [Id]
[resumeApStack] :: Resume -> ForeignHValue

-- | the breakpoint we stopped at (Nothing <a>=</a> exception)
[resumeBreakpointId] :: Resume -> Maybe InternalBreakpointId
[resumeSpan] :: Resume -> SrcSpan
[resumeDecl] :: Resume -> String
[resumeCCS] :: Resume -> RemotePtr CostCentreStack
[resumeHistory] :: Resume -> [History]
[resumeHistoryIx] :: Resume -> Int
type ResumeBindings = ([TyThing], IcGlobalRdrEnv)

-- | Essentially a GlobalRdrEnv, but with additional cached values to allow
--   efficient re-calculation when the imports change. Fields are strict to
--   avoid space leaks (see T4029) All operations are in
--   GHC.Runtime.Context. See Note [icReaderEnv recalculation]
data IcGlobalRdrEnv
IcGlobalRdrEnv :: !GlobalRdrEnv -> !GlobalRdrEnv -> IcGlobalRdrEnv

-- | The final environment
[igre_env] :: IcGlobalRdrEnv -> !GlobalRdrEnv

-- | Just the things defined at the prompt (excluding imports!)
[igre_prompt_env] :: IcGlobalRdrEnv -> !GlobalRdrEnv
data History
History :: ForeignHValue -> InternalBreakpointId -> [String] -> History
[historyApStack] :: History -> ForeignHValue

-- | breakpoint identifier
[historyBreakpointId] :: History -> InternalBreakpointId

-- | declarations enclosing the breakpoint
[historyEnclosingDecls] :: History -> [String]
data ExecResult
ExecComplete :: Either SomeException [Name] -> Word64 -> ExecResult
[execResult] :: ExecResult -> Either SomeException [Name]
[execAllocation] :: ExecResult -> Word64
ExecBreak :: [Name] -> Maybe InternalBreakpointId -> ExecResult
[breakNames] :: ExecResult -> [Name]
[breakPointId] :: ExecResult -> Maybe InternalBreakpointId
data SingleStep
RunToCompletion :: SingleStep
SingleStep :: SingleStep
RunAndLogSteps :: SingleStep
isStep :: SingleStep -> Bool
data ExecOptions
ExecOptions :: SingleStep -> String -> Int -> (ForeignHValue -> EvalExpr ForeignHValue) -> ExecOptions

-- | stepping mode
[execSingleStep] :: ExecOptions -> SingleStep

-- | filename (for errors)
[execSourceFile] :: ExecOptions -> String

-- | line number (for errors)
[execLineNumber] :: ExecOptions -> Int
[execWrap] :: ExecOptions -> ForeignHValue -> EvalExpr ForeignHValue


-- | Functions to computing the statistics reflective of the "size" of a
--   Core expression
module GHC.Core.Stats
coreBindsSize :: [CoreBind] -> Int

-- | A measure of the size of the expressions, strictly greater than 0
--   Counts *leaves*, not internal nodes. Types and coercions are not
--   counted.
exprSize :: CoreExpr -> Int
data CoreStats
CS :: !Int -> !Int -> !Int -> !Int -> !Int -> CoreStats
[cs_tm] :: CoreStats -> !Int
[cs_ty] :: CoreStats -> !Int
[cs_co] :: CoreStats -> !Int
[cs_vb] :: CoreStats -> !Int
[cs_jb] :: CoreStats -> !Int
coreBindsStats :: [CoreBind] -> CoreStats
exprStats :: CoreExpr -> CoreStats
instance GHC.Utils.Outputable.Outputable GHC.Core.Stats.CoreStats


-- | Various utilities for forcing Core structures
--   
--   It can often be useful to force various parts of the AST. This module
--   provides a number of <tt>seq</tt>-like functions to accomplish this.
module GHC.Core.Seq
seqExpr :: CoreExpr -> ()
seqExprs :: [CoreExpr] -> ()
seqUnfolding :: Unfolding -> ()
seqRules :: [CoreRule] -> ()

-- | Evaluate all the fields of the <a>IdInfo</a> that are generally
--   demanded by the compiler
megaSeqIdInfo :: IdInfo -> ()
seqRuleInfo :: RuleInfo -> ()
seqBinds :: [Bind CoreBndr] -> ()

module GHC.Core.Ppr
pprCoreExpr :: OutputableBndr b => Expr b -> SDoc
pprParendExpr :: OutputableBndr b => Expr b -> SDoc
pprCoreBinding :: OutputableBndr b => Bind b -> SDoc
pprCoreBindings :: OutputableBndr b => [Bind b] -> SDoc
pprCoreAlt :: OutputableBndr a => Alt a -> SDoc
pprCoreBindingWithSize :: CoreBind -> SDoc
pprCoreBindingsWithSize :: [CoreBind] -> SDoc
pprCoreBinder :: BindingSite -> Var -> SDoc
pprCoreBinders :: [Var] -> SDoc
pprId :: Id -> SDoc
pprIds :: [Id] -> SDoc
pprRule :: CoreRule -> SDoc
pprRules :: [CoreRule] -> SDoc
pprOptCo :: Coercion -> SDoc
pprOcc :: OutputableBndr a => LexicalFixity -> a -> SDoc
pprOccWithTick :: OutputableBndr a => LexicalFixity -> PromotionFlag -> a -> SDoc
instance GHC.Utils.Outputable.Outputable b => GHC.Utils.Outputable.OutputableBndr (GHC.Core.TaggedBndr b)
instance GHC.Utils.Outputable.OutputableBndr GHC.Types.Var.Var
instance GHC.Utils.Outputable.OutputableBndr b => GHC.Utils.Outputable.Outputable (GHC.Core.Alt b)
instance GHC.Utils.Outputable.OutputableBndr b => GHC.Utils.Outputable.Outputable (GHC.Core.Bind b)
instance GHC.Utils.Outputable.Outputable GHC.Core.CoreRule
instance GHC.Utils.Outputable.OutputableBndr b => GHC.Utils.Outputable.Outputable (GHC.Core.Expr b)
instance GHC.Utils.Outputable.Outputable (GHC.Types.Tickish.XTickishId pass) => GHC.Utils.Outputable.Outputable (GHC.Types.Tickish.GenTickish pass)
instance GHC.Utils.Outputable.Outputable GHC.Types.Id.Info.IdInfo
instance GHC.Utils.Outputable.Outputable GHC.Core.Unfolding
instance GHC.Utils.Outputable.Outputable GHC.Core.UnfoldingCache
instance GHC.Utils.Outputable.Outputable GHC.Core.UnfoldingGuidance


-- | Source-language literals
module GHC.Hs.Lit

-- | Convert a literal from one index type to another
convertLit :: forall (p1 :: Pass) (p2 :: Pass). HsLit (GhcPass p1) -> HsLit (GhcPass p2)

-- | <tt><a>hsLitNeedsParens</a> p l</tt> returns <a>True</a> if a literal
--   <tt>l</tt> needs to be parenthesized under precedence <tt>p</tt>.
--   
--   See Note [Printing of literals in Core] in GHC.Types.Literal for the
--   reasoning.
hsLitNeedsParens :: PprPrec -> HsLit x -> Bool

-- | <tt><a>hsOverLitNeedsParens</a> p ol</tt> returns <a>True</a> if an
--   overloaded literal <tt>ol</tt> needs to be parenthesized under
--   precedence <tt>p</tt>.
hsOverLitNeedsParens :: PprPrec -> HsOverLit x -> Bool
negateOverLitVal :: OverLitVal -> OverLitVal
overLitType :: HsOverLit GhcTc -> Type

-- | pmPprHsLit pretty prints literals and is used when pretty printing
--   pattern match warnings. All are printed the same (i.e., without hashes
--   if they are primitive and not wrapped in constructors if they are
--   boxed). This happens mainly for too reasons: * We do not want to
--   expose their internal representation * The warnings become too messy
pmPprHsLit :: forall (x :: Pass). HsLit (GhcPass x) -> SDoc
pprXOverLit :: forall (p :: Pass). GhcPass p -> XOverLit (GhcPass p) -> SDoc
data OverLitRn
OverLitRn :: Bool -> LIdP GhcRn -> OverLitRn
[ol_rebindable] :: OverLitRn -> Bool
[ol_from_fun] :: OverLitRn -> LIdP GhcRn
data OverLitTc
OverLitTc :: Bool -> HsExpr GhcTc -> Type -> OverLitTc
[ol_rebindable] :: OverLitTc -> Bool
[ol_witness] :: OverLitTc -> HsExpr GhcTc
[ol_type] :: OverLitTc -> Type
instance GHC.Classes.Eq (Language.Haskell.Syntax.Extension.XXOverLit p) => GHC.Classes.Eq (Language.Haskell.Syntax.Lit.HsOverLit p)
instance GHC.Classes.Ord (Language.Haskell.Syntax.Extension.XXOverLit p) => GHC.Classes.Ord (Language.Haskell.Syntax.Lit.HsOverLit p)
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Lit.HsLit (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Lit.HsOverLit (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Lit.OverLitVal

module GHC.Core.Map.Expr

-- | <tt>CoreMap a</tt> is a map from <a>CoreExpr</a> to <tt>a</tt>. If you
--   are a client, this is the type you want.
data CoreMap a
emptyCoreMap :: CoreMap a
extendCoreMap :: CoreMap a -> CoreExpr -> a -> CoreMap a
lookupCoreMap :: CoreMap a -> CoreExpr -> Maybe a
foldCoreMap :: (a -> b -> b) -> b -> CoreMap a -> b
eqDeBruijnExpr :: DeBruijn CoreExpr -> DeBruijn CoreExpr -> Bool
eqCoreExpr :: CoreExpr -> CoreExpr -> Bool
class Functor m => TrieMap (m :: Type -> Type) where {
    type Key (m :: Type -> Type);
}
emptyTM :: TrieMap m => m a
lookupTM :: TrieMap m => Key m -> m b -> Maybe b
alterTM :: TrieMap m => Key m -> XT b -> m b -> m b
filterTM :: TrieMap m => (a -> Bool) -> m a -> m a
foldTM :: TrieMap m => (a -> b -> b) -> m a -> b -> b
insertTM :: TrieMap m => Key m -> a -> m a -> m a
deleteTM :: TrieMap m => Key m -> m a -> m a
lkDFreeVar :: Var -> DVarEnv a -> Maybe a
xtDFreeVar :: Var -> XT a -> DVarEnv a -> DVarEnv a
lkDNamed :: NamedThing n => n -> DNameEnv a -> Maybe a
xtDNamed :: NamedThing n => n -> XT a -> DNameEnv a -> DNameEnv a
(>.>) :: (a -> b) -> (b -> c) -> a -> c
infixr 1 >.>
(|>) :: a -> (a -> b) -> b
infixr 1 |>
(|>>) :: TrieMap m2 => (XT (m2 a) -> m1 (m2 a) -> m1 (m2 a)) -> (m2 a -> m2 a) -> m1 (m2 a) -> m1 (m2 a)
infixr 1 |>>
instance GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn GHC.Core.CoreExpr)
instance GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn GHC.Core.CoreAlt)
instance GHC.Internal.Base.Functor GHC.Core.Map.Expr.AltMap
instance GHC.Internal.Base.Functor GHC.Core.Map.Expr.CoreMap
instance GHC.Internal.Base.Functor GHC.Core.Map.Expr.CoreMapX
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Core.Map.Expr.CoreMap a)
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Expr.AltMap
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Expr.CoreMap
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Expr.CoreMapX


-- | This module is about types that can be defined in Haskell, but which
--   must be wired into the compiler nonetheless. C.f module
--   <a>GHC.Builtin.Types.Prim</a>
module GHC.Builtin.Types
mkWiredInTyConName :: BuiltInSyntax -> Module -> FastString -> Unique -> TyCon -> Name
mkWiredInIdName :: Module -> FastString -> Unique -> Id -> Name
wiredInTyCons :: [TyCon]

-- | Built-in syntax isn't "in scope" so these OccNames map to wired-in
--   Names with BuiltInSyntax. However, this should only be necessary while
--   resolving names produced by Template Haskell splices since we take
--   care to encode built-in syntax names specially in interface files. See
--   Note [Symbol table representation of names] in GHC.Iface.Binary.
--   
--   Moreover, there is no need to include names of things that the user
--   can't write (e.g. type representation bindings like $tc(,,,)).
isBuiltInOcc_maybe :: OccName -> Maybe Name
isTupleTyOcc_maybe :: Module -> OccName -> Maybe Name
isSumTyOcc_maybe :: Module -> OccName -> Maybe Name
isPunOcc_maybe :: Module -> OccName -> Maybe Name
boolTy :: Type
boolTyCon :: TyCon
boolTyCon_RDR :: RdrName
boolTyConName :: Name
trueDataCon :: DataCon
trueDataConId :: Id
true_RDR :: RdrName
falseDataCon :: DataCon
falseDataConId :: Id
false_RDR :: RdrName
promotedFalseDataCon :: TyCon
promotedTrueDataCon :: TyCon
orderingTyCon :: TyCon
ordLTDataCon :: DataCon
ordLTDataConId :: Id
ordEQDataCon :: DataCon
ordEQDataConId :: Id
ordGTDataCon :: DataCon
ordGTDataConId :: Id
promotedLTDataCon :: TyCon
promotedEQDataCon :: TyCon
promotedGTDataCon :: TyCon

-- | Given a type <tt>ty</tt>, if <tt>ty</tt> is not of kind Type, return a
--   data constructor that will box it, and the type of the boxed thing,
--   which <i>does</i> now have kind Type. See Note [Boxing constructors]
boxingDataCon :: Type -> BoxingInfo b
data BoxingInfo b
BI_NoBoxNeeded :: BoxingInfo b
BI_NoBoxAvailable :: BoxingInfo b
BI_Box :: DataCon -> Expr b -> Type -> BoxingInfo b
[bi_data_con] :: BoxingInfo b -> DataCon
[bi_inst_con] :: BoxingInfo b -> Expr b
[bi_boxed_type] :: BoxingInfo b -> Type
charTyCon :: TyCon
charDataCon :: DataCon
charTyCon_RDR :: RdrName
charTy :: Type
stringTy :: Type
charTyConName :: Name
stringTyCon_RDR :: RdrName
doubleTyCon :: TyCon
doubleDataCon :: DataCon
doubleTy :: Type
doubleTyConName :: Name
floatTyCon :: TyCon
floatDataCon :: DataCon
floatTy :: Type
floatTyConName :: Name
intTyCon :: TyCon
intDataCon :: DataCon
intTyCon_RDR :: RdrName
intDataCon_RDR :: RdrName
intTyConName :: Name
intTy :: Type
wordTyCon :: TyCon
wordDataCon :: DataCon
wordTyConName :: Name
wordTy :: Type
word8TyCon :: TyCon
word8DataCon :: DataCon
word8Ty :: Type
listTyCon :: TyCon
listTyCon_RDR :: RdrName
listTyConName :: Name
listTyConKey :: Unique
nilDataCon :: DataCon
nilDataConName :: Name
nilDataConKey :: Unique
consDataCon_RDR :: RdrName
consDataCon :: DataCon
consDataConName :: Name
promotedNilDataCon :: TyCon
promotedConsDataCon :: TyCon
mkListTy :: Type -> Type

-- | Make a *promoted* list.
mkPromotedListTy :: Kind -> [Type] -> Type

-- | Extract the elements of a promoted list. Panics if the type is not a
--   promoted list
extractPromotedList :: Type -> [Type]
maybeTyCon :: TyCon
maybeTyConName :: Name
nothingDataCon :: DataCon
nothingDataConName :: Name
promotedNothingDataCon :: TyCon
justDataCon :: DataCon
justDataConName :: Name
promotedJustDataCon :: TyCon
mkPromotedMaybeTy :: Kind -> Maybe Type -> Type
mkMaybeTy :: Type -> Kind
isPromotedMaybeTy :: Type -> Maybe (Maybe Type)

-- | Make a tuple type. The list of types should <i>not</i> include any
--   RuntimeRep specifications. Boxed 1-tuples are flattened. See Note
--   [One-tuples]
mkTupleTy :: Boxity -> [Type] -> Type

-- | Make a tuple type. The list of types should <i>not</i> include any
--   RuntimeRep specifications. Boxed 1-tuples are *not* flattened. See
--   Note [One-tuples] and Note [Don't flatten tuples from HsSyn] in
--   <a>GHC.Core.Make</a>
mkTupleTy1 :: Boxity -> [Type] -> Type

-- | Build the type of a small tuple that holds the specified type of thing
--   Flattens 1-tuples. See Note [One-tuples].
mkBoxedTupleTy :: [Type] -> Type
mkTupleStr :: Boxity -> NameSpace -> Arity -> String
tupleTyCon :: Boxity -> Arity -> TyCon
tupleDataCon :: Boxity -> Arity -> DataCon
tupleTyConName :: TupleSort -> Arity -> Name
tupleDataConName :: Boxity -> Arity -> Name
promotedTupleDataCon :: Boxity -> Arity -> TyCon
unitTyCon :: TyCon
unitDataCon :: DataCon
unitDataConId :: Id
unitTy :: Type
unitTyConKey :: Unique
soloTyCon :: TyCon
pairTyCon :: TyCon
mkPromotedPairTy :: Kind -> Kind -> Type -> Type -> Type
isPromotedPairType :: Type -> Maybe (Type, Type)
unboxedUnitTy :: Type
unboxedUnitTyCon :: TyCon
unboxedUnitDataCon :: DataCon

-- | Specialization of <a>unboxedTupleSumKind</a> for tuples
unboxedTupleKind :: [Type] -> Kind

-- | Specialization of <a>unboxedTupleSumKind</a> for sums
unboxedSumKind :: [Type] -> Kind

-- | Replaces constraint tuple names with corresponding boxed ones.
filterCTuple :: RdrName -> RdrName
mkConstraintTupleTy :: [Type] -> Type
cTupleTyCon :: Arity -> TyCon
cTupleTyConName :: Arity -> Name
cTupleTyConNames :: [Name]
isCTupleTyConName :: Name -> Bool

-- | If the given name is that of a constraint tuple, return its arity.
cTupleTyConNameArity_maybe :: Name -> Maybe Arity
cTupleDataCon :: Arity -> DataCon
cTupleDataConName :: Arity -> Name
cTupleDataConNames :: [Name]
cTupleSelId :: ConTag -> Arity -> Id
cTupleSelIdName :: ConTag -> Arity -> Name
anyTyCon :: TyCon
anyTy :: Type
anyTypeOfKind :: Kind -> Type
zonkAnyTyCon :: TyCon

-- | Make a fake, recovery <a>TyCon</a> from an existing one. Used when
--   recovering from errors in type declarations
makeRecoveryTyCon :: TyCon -> TyCon
mkSumTy :: [Type] -> Type

-- | Type constructor for n-ary unboxed sum.
sumTyCon :: Arity -> TyCon

-- | Data constructor for i-th alternative of a n-ary unboxed sum.
sumDataCon :: ConTag -> Arity -> DataCon
typeSymbolKindCon :: TyCon
typeSymbolKind :: Kind
isLiftedTypeKindTyConName :: Name -> Bool
typeToTypeKind :: Type

-- | <pre>
--   type LiftedRep = 'BoxedRep 'Lifted
--   </pre>
liftedRepTyCon :: TyCon

-- | <pre>
--   type UnliftedRep = 'BoxedRep 'Unlifted
--   </pre>
unliftedRepTyCon :: TyCon
tYPETyCon :: TyCon
tYPETyConName :: Name
tYPEKind :: Type
cONSTRAINTTyCon :: TyCon
cONSTRAINTTyConName :: Name
cONSTRAINTKind :: Type
constraintKind :: Kind
liftedTypeKind :: Type
unliftedTypeKind :: Type
zeroBitTypeKind :: Type
constraintKindTyCon :: TyCon
liftedTypeKindTyCon :: TyCon
unliftedTypeKindTyCon :: TyCon
constraintKindTyConName :: Name
liftedTypeKindTyConName :: Name
unliftedTypeKindTyConName :: Name
liftedRepTyConName :: Name
unliftedRepTyConName :: Name
heqTyCon :: TyCon
heqTyConName :: Name
heqClass :: Class
heqDataCon :: DataCon
eqTyCon :: TyCon
eqTyConName :: Name
eqClass :: Class
eqDataCon :: DataCon
eqTyCon_RDR :: RdrName
coercibleTyCon :: TyCon
coercibleTyConName :: Name
coercibleDataCon :: DataCon
coercibleClass :: Class
runtimeRepTyCon :: TyCon
vecCountTyCon :: TyCon
vecElemTyCon :: TyCon
boxedRepDataConTyCon :: TyCon
runtimeRepTy :: Type
liftedRepTy :: RuntimeRepType
unliftedRepTy :: RuntimeRepType
zeroBitRepTy :: RuntimeRepType
vecRepDataConTyCon :: TyCon
tupleRepDataConTyCon :: TyCon
sumRepDataConTyCon :: TyCon
levityTyCon :: TyCon
levityTy :: Type
liftedDataConTyCon :: TyCon
unliftedDataConTyCon :: TyCon
liftedDataConTy :: Type
unliftedDataConTy :: Type
intRepDataConTy :: RuntimeRepType
int8RepDataConTy :: RuntimeRepType
int16RepDataConTy :: RuntimeRepType
int32RepDataConTy :: RuntimeRepType
int64RepDataConTy :: RuntimeRepType
wordRepDataConTy :: RuntimeRepType
word8RepDataConTy :: RuntimeRepType
word16RepDataConTy :: RuntimeRepType
word32RepDataConTy :: RuntimeRepType
word64RepDataConTy :: RuntimeRepType
addrRepDataConTy :: RuntimeRepType
floatRepDataConTy :: RuntimeRepType
doubleRepDataConTy :: RuntimeRepType
vec2DataConTy :: Type
vec4DataConTy :: Type
vec8DataConTy :: Type
vec16DataConTy :: Type
vec32DataConTy :: Type
vec64DataConTy :: Type
int8ElemRepDataConTy :: Type
int16ElemRepDataConTy :: Type
int32ElemRepDataConTy :: Type
int64ElemRepDataConTy :: Type
word8ElemRepDataConTy :: Type
word16ElemRepDataConTy :: Type
word32ElemRepDataConTy :: Type
word64ElemRepDataConTy :: Type
floatElemRepDataConTy :: Type
doubleElemRepDataConTy :: Type
multiplicityTyConName :: Name
oneDataConName :: Name
manyDataConName :: Name
multiplicityTy :: Type
multiplicityTyCon :: TyCon
oneDataCon :: DataCon
manyDataCon :: DataCon
oneDataConTy :: Type
manyDataConTy :: Type
oneDataConTyCon :: TyCon
manyDataConTyCon :: TyCon
multMulTyCon :: TyCon
unrestrictedFunTyCon :: TyCon
unrestrictedFunTyConName :: Name
integerTy :: Type
integerTyCon :: TyCon
integerTyConName :: Name
integerISDataCon :: DataCon
integerISDataConName :: Name
integerIPDataCon :: DataCon
integerIPDataConName :: Name
integerINDataCon :: DataCon
integerINDataConName :: Name
naturalTy :: Type
naturalTyCon :: TyCon
naturalTyConName :: Name
naturalNSDataCon :: DataCon
naturalNSDataConName :: Name
naturalNBDataCon :: DataCon
naturalNBDataConName :: Name

-- | Should this name be considered in-scope, even though it technically
--   isn't?
--   
--   This ensures that we don't filter out information because, e.g.,
--   Data.Kind.Type isn't imported.
--   
--   See Note [pretendNameIsInScope].
pretendNameIsInScope :: Name -> Bool


-- | The Name Cache
module GHC.Types.Name.Cache

-- | The NameCache makes sure that there is just one Unique assigned for
--   each original name; i.e. (module-name, occ-name) pair and provides
--   something of a lookup mechanism for those names.
data NameCache
NameCache :: {-# UNPACK #-} !Char -> {-# UNPACK #-} !MVar OrigNameCache -> NameCache
[nsUniqChar] :: NameCache -> {-# UNPACK #-} !Char
[nsNames] :: NameCache -> {-# UNPACK #-} !MVar OrigNameCache
initNameCache :: Char -> [Name] -> IO NameCache
takeUniqFromNameCache :: NameCache -> IO Unique

-- | Update the name cache with the given function
updateNameCache' :: NameCache -> (OrigNameCache -> IO (OrigNameCache, c)) -> IO c

-- | Update the name cache with the given function
--   
--   Additionally, it ensures that the given Module and OccName are
--   evaluated. If not, chaos can ensue: we read the name-cache then pull
--   on mod (say) which does some stuff that modifies the name cache This
--   did happen, with tycon_mod in GHC.IfaceToCore.tcIfaceAlt (DataAlt..)
updateNameCache :: NameCache -> Module -> OccName -> (OrigNameCache -> IO (OrigNameCache, c)) -> IO c

-- | Per-module cache of original <a>OccName</a>s given <a>Name</a>s
type OrigNameCache = ModuleEnv OccEnv Name
lookupOrigNameCache :: OrigNameCache -> Module -> OccName -> Maybe Name
extendOrigNameCache' :: OrigNameCache -> Name -> OrigNameCache
extendOrigNameCache :: OrigNameCache -> Module -> OccName -> Name -> OrigNameCache


-- | Types used in the typechecker
--   
--   This module provides the Type interface for front-end parts of the
--   compiler. These parts
--   
--   <ul>
--   <li>treat "source types" as opaque: newtypes, and predicates are
--   meaningful.</li>
--   <li>look through usage types</li>
--   </ul>
module GHC.Tc.Utils.TcType
type TcType = Type
type TcSigmaType = TcType

-- | A type which has a syntactically fixed RuntimeRep as per Note [Fixed
--   RuntimeRep] in GHC.Tc.Utils.Concrete.
type TcTypeFRR = TcType

-- | A <a>TcSigmaTypeFRR</a> is a <a>TcSigmaType</a> which has a
--   syntactically fixed <a>RuntimeRep</a> in the sense of Note [Fixed
--   RuntimeRep] in GHC.Tc.Utils.Concrete.
--   
--   In particular, this means that:
--   
--   <ul>
--   <li><a>typePrimRep</a> does not panic,</li>
--   <li><a>typeLevity_maybe</a> does not return <a>Nothing</a>.</li>
--   </ul>
--   
--   This property is important in functions such as
--   <tt>matchExpectedFunTys</tt>, where we want to provide argument types
--   which have a known runtime representation. See Note [Return arguments
--   with a fixed RuntimeRep.
type TcSigmaTypeFRR = TcSigmaType
type TcRhoType = TcType
type TcTauType = TcType
type TcPredType = PredType
type TcThetaType = ThetaType

-- | Type variable that might be a metavariable
type TcTyVar = Var
type TcTyVarSet = TyVarSet
type TcDTyVarSet = DTyVarSet
type TcTyCoVarSet = TyCoVarSet
type TcDTyCoVarSet = DTyCoVarSet
type TcKind = Kind
type TcCoVar = CoVar
type TcTyCoVar = Var
type TcTyVarBinder = TyVarBinder
type TcInvisTVBinder = InvisTVBinder
type TcReqTVBinder = ReqTVBinder
type TcTyCon = TyCon
type MonoTcTyCon = TcTyCon
type PolyTcTyCon = TcTyCon
type TcTyConBinder = TyConBinder

-- | A type labeled <a>KnotTied</a> might have knot-tied tycons in it. See
--   Note [Type checking recursive type and class declarations] in
--   <a>GHC.Tc.TyCl</a>
type KnotTied (ty :: k) = ty

-- | An expected type to check against during type-checking. See Note
--   [ExpType] in <a>GHC.Tc.Utils.TcMType</a>, where you'll also find
--   manipulators.
data ExpType
Check :: TcType -> ExpType
Infer :: !InferResult -> ExpType

-- | Like <a>ExpType</a>, but on kind level
type ExpKind = ExpType
data InferResult
IR :: Unique -> TcLevel -> Maybe FixedRuntimeRepContext -> IORef (Maybe TcType) -> InferResult

-- | This <a>Unique</a> is for debugging only
[ir_uniq] :: InferResult -> Unique

-- | See Note [TcLevel of ExpType] in GHC.Tc.Utils.TcMType
[ir_lvl] :: InferResult -> TcLevel

-- | See Note [FixedRuntimeRep context in ExpType] in GHC.Tc.Utils.TcMType
[ir_frr] :: InferResult -> Maybe FixedRuntimeRepContext

-- | The type that fills in this hole should be a <tt>Type</tt>, that is,
--   its kind should be <tt>TYPE rr</tt> for some <tt>rr ::
--   RuntimeRep</tt>.
--   
--   Additionally, if the <a>ir_frr</a> field is <tt>Just frr_orig</tt>
--   then <tt>rr</tt> must be concrete, in the sense of Note [Concrete
--   types] in GHC.Tc.Utils.Concrete.
[ir_ref] :: InferResult -> IORef (Maybe TcType)

-- | An <a>ExpType</a> which has a fixed RuntimeRep.
--   
--   For a <a>Check</a> <a>ExpType</a>, the stored <a>TcType</a> must have
--   a fixed RuntimeRep. For an <a>Infer</a> <a>ExpType</a>, the
--   <a>ir_frr</a> field must be of the form <tt>Just frr_orig</tt>.
type ExpTypeFRR = ExpType
type ExpSigmaType = ExpType

-- | Like <a>TcSigmaTypeFRR</a>, but for an expected type.
--   
--   See <a>ExpTypeFRR</a>.
type ExpSigmaTypeFRR = ExpTypeFRR
type ExpRhoType = ExpType

-- | Make an <a>ExpType</a> suitable for checking.
mkCheckExpType :: TcType -> ExpType

-- | Returns the expected type when in checking mode.
checkingExpType_maybe :: ExpType -> Maybe TcType

-- | Returns the expected type when in checking mode. Panics if in
--   inference mode.
checkingExpType :: ExpType -> TcType
data ExpPatType
ExpFunPatTy :: Scaled ExpSigmaTypeFRR -> ExpPatType
ExpForAllPatTy :: ForAllTyBinder -> ExpPatType
mkCheckExpFunPatTy :: Scaled TcType -> ExpPatType
mkInvisExpPatType :: InvisTyBinder -> ExpPatType
isVisibleExpPatType :: ExpPatType -> Bool
isExpFunPatType :: ExpPatType -> Bool

-- | What to expect for an argument to a rebindable-syntax operator. Quite
--   like <a>Type</a>, but allows for holes to be filled in by tcSyntaxOp.
--   The callback called from tcSyntaxOp gets a list of types; the meaning
--   of these types is determined by a left-to-right depth-first traversal
--   of the <a>SyntaxOpType</a> tree. So if you pass in
--   
--   <pre>
--   SynAny `SynFun` (SynList `SynFun` SynType Int) `SynFun` SynAny
--   </pre>
--   
--   you'll get three types back: one for the first <a>SynAny</a>, the
--   <i>element</i> type of the list, and one for the last <a>SynAny</a>.
--   You don't get anything for the <a>SynType</a>, because you've said
--   positively that it should be an Int, and so it shall be.
--   
--   You'll also get three multiplicities back: one for each function
--   arrow. See also Note [Linear types] in Multiplicity.
--   
--   This is defined here to avoid defining it in <a>GHC.Tc.Gen.Expr</a>
--   boot file.
data SyntaxOpType

-- | Any type
SynAny :: SyntaxOpType

-- | A rho type, skolemised or instantiated as appropriate
SynRho :: SyntaxOpType

-- | A list type. You get back the element type of the list
SynList :: SyntaxOpType

-- | A function.
SynFun :: SyntaxOpType -> SyntaxOpType -> SyntaxOpType

-- | A known type.
SynType :: ExpType -> SyntaxOpType
infixr 0 `SynFun`

-- | Like <a>SynType</a> but accepts a regular TcType
synKnownType :: TcType -> SyntaxOpType

-- | Like <tt>mkFunTys</tt> but for <a>SyntaxOpType</a>
mkSynFunTys :: [SyntaxOpType] -> ExpType -> SyntaxOpType
data TcLevel
TcLevel :: {-# UNPACK #-} !Int -> TcLevel
QLInstVar :: TcLevel
topTcLevel :: TcLevel
pushTcLevel :: TcLevel -> TcLevel
isTopTcLevel :: TcLevel -> Bool
strictlyDeeperThan :: TcLevel -> TcLevel -> Bool
deeperThanOrSame :: TcLevel -> TcLevel -> Bool
sameDepthAs :: TcLevel -> TcLevel -> Bool
tcTypeLevel :: TcType -> TcLevel
tcTyVarLevel :: TcTyVar -> TcLevel
maxTcLevel :: TcLevel -> TcLevel -> TcLevel
minTcLevel :: TcLevel -> TcLevel -> TcLevel
data TcTyVarDetails
SkolemTv :: SkolemInfo -> TcLevel -> Bool -> TcTyVarDetails
RuntimeUnk :: TcTyVarDetails
MetaTv :: MetaInfo -> IORef MetaDetails -> TcLevel -> TcTyVarDetails
[mtv_info] :: TcTyVarDetails -> MetaInfo
[mtv_ref] :: TcTyVarDetails -> IORef MetaDetails
[mtv_tclvl] :: TcTyVarDetails -> TcLevel
pprTcTyVarDetails :: TcTyVarDetails -> SDoc
vanillaSkolemTvUnk :: HasDebugCallStack => TcTyVarDetails
data MetaDetails
Flexi :: MetaDetails
Indirect :: TcType -> MetaDetails

-- | What restrictions are on this metavariable around unification? These
--   are checked in GHC.Tc.Utils.Unify.checkTopShape
data MetaInfo

-- | This MetaTv is an ordinary unification variable A TauTv is always
--   filled in with a tau-type, which never contains any ForAlls.
TauTv :: MetaInfo

-- | A variant of TauTv, except that it should not be unified with a type,
--   only with a type variable See Note [TyVarTv] in GHC.Tc.Utils.TcMType
TyVarTv :: MetaInfo

-- | A unification variable used in the GHCi debugger. It <i>is</i> allowed
--   to unify with a polytype, unlike TauTv
RuntimeUnkTv :: MetaInfo
CycleBreakerTv :: MetaInfo

-- | A unification variable that can only be unified with a concrete type,
--   in the sense of Note [Concrete types] in GHC.Tc.Utils.Concrete. See
--   Note [ConcreteTv] in GHC.Tc.Utils.Concrete. See also Note [The
--   Concrete mechanism] in GHC.Tc.Utils.Concrete for an overview of how
--   this works in context.
ConcreteTv :: ConcreteTvOrigin -> MetaInfo
skolemSkolInfo :: TcTyVar -> SkolemInfo
isImmutableTyVar :: TyVar -> Bool
isSkolemTyVar :: TcTyVar -> Bool
isMetaTyVar :: TcTyVar -> Bool
isMetaTyVarTy :: TcType -> Bool
isTyVarTy :: Type -> Bool
tcIsTcTyVar :: TcTyVar -> Bool
isTyVarTyVar :: Var -> Bool
isOverlappableTyVar :: TcTyVar -> Bool
isTyConableTyVar :: TcTyVar -> Bool

-- | What caused us to create a <a>ConcreteTv</a> metavariable? See Note
--   [ConcreteTv] in GHC.Tc.Utils.Concrete.
data ConcreteTvOrigin

-- | A <a>ConcreteTv</a> used to enforce the representation-polymorphism
--   invariants.
--   
--   See <a>FixedRuntimeRepOrigin</a> for more information.
ConcreteFRR :: FixedRuntimeRepOrigin -> ConcreteTvOrigin

-- | Is this type variable a concrete type variable, i.e. it is a
--   metavariable with <a>ConcreteTv</a> <a>MetaInfo</a>?
--   
--   Returns the <a>ConcreteTvOrigin</a> stored in the type variable if so,
--   or <a>Nothing</a> otherwise.
isConcreteTyVar_maybe :: TcTyVar -> Maybe ConcreteTvOrigin

-- | Is this type variable a concrete type variable, i.e. it is a
--   metavariable with <a>ConcreteTv</a> <a>MetaInfo</a>?
isConcreteTyVar :: TcTyVar -> Bool

-- | Is this type concrete type variable, i.e. a metavariable with
--   <a>ConcreteTv</a> <a>MetaInfo</a>?
isConcreteTyVarTy :: TcType -> Bool

-- | Is this type a concrete type variable? If so, return the associated
--   <a>TcTyVar</a> and <a>ConcreteTvOrigin</a>.
isConcreteTyVarTy_maybe :: TcType -> Maybe (TcTyVar, ConcreteTvOrigin)
isConcreteInfo :: MetaInfo -> Bool

-- | A mapping from skolem type variable <a>Name</a> to concreteness
--   information,
--   
--   See Note [Representation-polymorphism checking built-ins] in
--   GHC.Tc.Utils.Concrete.
type ConcreteTyVars = NameEnv ConcreteTvOrigin

-- | The <a>Id</a> has no outer forall'd type variables which must be
--   instantiated to concrete types.
noConcreteTyVars :: ConcreteTyVars
isAmbiguousTyVar :: TcTyVar -> Bool
isCycleBreakerTyVar :: TcTyVar -> Bool
metaTyVarRef :: TyVar -> IORef MetaDetails
metaTyVarInfo :: TcTyVar -> MetaInfo
isFlexi :: MetaDetails -> Bool
isIndirect :: MetaDetails -> Bool
isRuntimeUnkSkol :: TyVar -> Bool
isQLInstTyVar :: TcTyVar -> Bool
isRuntimeUnkTyVar :: TcTyVar -> Bool
metaTyVarTcLevel :: TcTyVar -> TcLevel
setMetaTyVarTcLevel :: TcTyVar -> TcLevel -> TcTyVar
metaTyVarTcLevel_maybe :: TcTyVar -> Maybe TcLevel
isTouchableMetaTyVar :: TcLevel -> TcTyVar -> Bool
isPromotableMetaTyVar :: TcTyVar -> Bool
findDupTyVarTvs :: [(Name, TcTyVar)] -> [(Name, Name)]
mkTyVarNamePairs :: [TyVar] -> [(Name, TyVar)]

-- | Make a sigma ty where all type variables are <a>Inferred</a>. That is,
--   they cannot be used with visible type application.
mkInfSigmaTy :: HasDebugCallStack => [TyCoVar] -> [PredType] -> Type -> Type

-- | Make a sigma ty where all type variables are "specified". That is,
--   they can be used with visible type application
mkSpecSigmaTy :: HasDebugCallStack => [TyVar] -> [PredType] -> Type -> Type
mkSigmaTy :: HasDebugCallStack => [ForAllTyBinder] -> [PredType] -> Type -> Type
mkPhiTy :: HasDebugCallStack => [PredType] -> Type -> Type
tcMkPhiTy :: HasDebugCallStack => [PredType] -> Type -> Type
tcMkDFunSigmaTy :: [TyVar] -> ThetaType -> Type -> Type
tcMkDFunPhiTy :: HasDebugCallStack => [PredType] -> Type -> Type

-- | Attempts to obtain the type variable underlying a <a>Type</a>, and
--   panics with the given message if this is not a type variable type. See
--   also <a>getTyVar_maybe</a>
getTyVar :: HasDebugCallStack => Type -> TyVar

-- | Attempts to obtain the type variable underlying a <a>Type</a>
getTyVar_maybe :: Type -> Maybe TyVar

-- | If the type is a tyvar, possibly under a cast, returns it, along with
--   the coercion. Thus, the co is :: kind tv ~N kind ty
getCastedTyVar_maybe :: Type -> Maybe (TyVar, CoercionN)
tcSplitForAllTyVarBinder_maybe :: Type -> Maybe (TyVarBinder, Type)
tcSplitForAllTyVarsReqTVBindersN :: Arity -> Type -> (Arity, [ForAllTyBinder], Type)

-- | Like <a>tcSplitPiTys</a>, but splits off only named binders, returning
--   just the tyvars.
tcSplitForAllTyVars :: Type -> ([TyVar], Type)

-- | Like <a>tcSplitForAllTyVars</a>, but only splits <a>ForAllTy</a>s with
--   <a>Invisible</a> type variable binders.
tcSplitForAllInvisTyVars :: Type -> ([TyVar], Type)

-- | Like <a>tcSplitForAllTyVars</a>, but only splits a <a>ForAllTy</a> if
--   <tt>argf_pred argf</tt> is <a>True</a>, where <tt>argf</tt> is the
--   visibility of the <tt>ForAllTy</tt>'s binder and <tt>argf_pred</tt> is
--   a predicate over visibilities provided as an argument to this
--   function.
tcSplitSomeForAllTyVars :: (ForAllTyFlag -> Bool) -> Type -> ([TyVar], Type)

-- | Like <a>tcSplitForAllTyVars</a>, but only splits <a>ForAllTy</a>s with
--   <a>Required</a> type variable binders. All split tyvars are annotated
--   with <tt>()</tt>.
tcSplitForAllReqTVBinders :: Type -> ([TcReqTVBinder], Type)

-- | Like <a>tcSplitForAllTyVars</a>, but only splits <a>ForAllTy</a>s with
--   <a>Invisible</a> type variable binders. All split tyvars are annotated
--   with their <a>Specificity</a>.
tcSplitForAllInvisTVBinders :: Type -> ([TcInvisTVBinder], Type)

-- | Splits a forall type into a list of <a>PiTyVarBinder</a>s and the
--   inner type. Always succeeds, even if it returns an empty list.
tcSplitPiTys :: Type -> ([PiTyVarBinder], Type)

-- | Splits a type into a PiTyVarBinder and a body, if possible.
tcSplitPiTy_maybe :: Type -> Maybe (PiTyVarBinder, Type)

-- | Like <a>tcSplitForAllTyVars</a>, but splits off only named binders.
tcSplitForAllTyVarBinders :: Type -> ([TyVarBinder], Type)
tcSplitPhiTy :: Type -> (ThetaType, Type)
tcSplitPredFunTy_maybe :: Type -> Maybe (PredType, Type)
tcSplitFunTy_maybe :: Type -> Maybe (Scaled Type, Type)
tcSplitFunTys :: Type -> ([Scaled Type], Type)
tcFunArgTy :: Type -> Scaled Type
tcFunResultTy :: Type -> Type

-- | Strips off n *visible* arguments and returns the resulting type
tcFunResultTyN :: HasDebugCallStack => Arity -> Type -> Type

-- | Split off exactly the specified number argument types Returns (Left m)
--   if there are <tt>m</tt> missing arrows in the type (Right (tys,res))
--   if the type looks like t1 -&gt; ... -&gt; tn -&gt; res
tcSplitFunTysN :: Arity -> TcRhoType -> Either Arity ([Scaled TcSigmaType], TcSigmaType)
tcSplitTyConApp :: Type -> (TyCon, [Type])

-- | tcSplitTyConApp_maybe splits a type constructor application into its
--   type constructor and applied types.
--   
--   Differs from splitTyConApp_maybe in that it does *not* split types
--   headed with (=&gt;), as that's not a TyCon in the type-checker.
--   
--   Note that this may fail (in funTyConAppTy_maybe) in the case of a
--   <a>FunTy</a> with an argument of unknown kind <a>FunTy</a> (e.g.
--   `FunTy (a :: k) Int`, since the kind of <tt>a</tt> isn't of the form
--   `TYPE rep`. This isn't usually a problem but may be temporarily the
--   case during canonicalization: see Note [Decomposing FunTy] in
--   GHC.Tc.Solver.Equality and Note [The Purely Kinded Type Invariant
--   (PKTI)] in GHC.Tc.Gen.HsType, Wrinkle around FunTy
--   
--   Consequently, you may need to zonk your type before using this
--   function.
tcSplitTyConApp_maybe :: HasDebugCallStack => Type -> Maybe (TyCon, [Type])
tcTyConAppTyCon :: Type -> TyCon

-- | Like <tt>tcRepSplitTyConApp_maybe</tt>, but only returns the
--   <a>TyCon</a>.
tcTyConAppTyCon_maybe :: Type -> Maybe TyCon
tcTyConAppArgs :: Type -> [Type]
tcSplitAppTy_maybe :: Type -> Maybe (Type, Type)
tcSplitAppTy :: Type -> (Type, Type)
tcSplitAppTys :: Type -> (Type, [Type])

-- | Just like splitAppTyNoView_maybe, but does not split (c =&gt; t) See
--   Note [Decomposing fat arrow c=&gt;t]
tcSplitAppTyNoView_maybe :: Type -> Maybe (Type, Type)

-- | Split a sigma type into its parts. This only splits <i>invisible</i>
--   type variable binders, as these are the only forms of binder that the
--   typechecker will implicitly instantiate.
tcSplitSigmaTy :: Type -> ([TyVar], ThetaType, Type)
tcSplitSigmaTyBndrs :: Type -> ([TcInvisTVBinder], ThetaType, Type)

-- | Split a sigma type into its parts, going underneath as many arrows and
--   foralls as possible. See Note [tcSplitNestedSigmaTys]
tcSplitNestedSigmaTys :: Type -> ([TyVar], ThetaType, Type)
tcSplitIOType_maybe :: Type -> Maybe (TyCon, Type)
isSigmaTy :: TcType -> Bool
isRhoTy :: TcType -> Bool

-- | Like <a>isRhoTy</a>, but also says <a>True</a> for <a>Infer</a> types
isRhoExpTy :: ExpType -> Bool
isOverloadedTy :: Type -> Bool

-- | Is the type inhabited by machine floating-point numbers?
--   
--   Used to check that we don't use floating-point literal patterns in
--   Core.
--   
--   See #9238 and Note [Rules for floating-point comparisons] in
--   GHC.Core.Opt.ConstantFold.
isFloatingPrimTy :: Type -> Bool
isDoubleTy :: Type -> Bool
isFloatTy :: Type -> Bool
isIntTy :: Type -> Bool
isWordTy :: Type -> Bool

-- | Is a type <a>String</a>?
isStringTy :: Type -> Bool
isIntegerTy :: Type -> Bool
isNaturalTy :: Type -> Bool
isBoolTy :: Type -> Bool
isUnitTy :: Type -> Bool
isCharTy :: Type -> Bool
isTauTy :: Type -> Bool
isTauTyCon :: TyCon -> Bool
tcIsTyVarTy :: Type -> Bool
isPredTy :: HasDebugCallStack => Type -> Bool
isTyVarClassPred :: PredType -> Bool
checkValidClsArgs :: Bool -> Class -> [KindOrType] -> Bool
hasTyVarHead :: Type -> Bool
isRigidTy :: TcType -> Bool

-- | Check whether the type is of the form <tt>Any :: k</tt>, returning the
--   kind <tt>k</tt>.
anyTy_maybe :: Type -> Maybe Kind

-- | Type equality comparing both visible and invisible arguments,
--   expanding synonyms and respecting multiplicities.
eqType :: HasCallStack => Type -> Type -> Bool

-- | Type equality on lists of types, looking through type synonyms
eqTypes :: [Type] -> [Type] -> Bool
nonDetCmpType :: Type -> Type -> Ordering

-- | Compare types with respect to a (presumably) non-empty <a>RnEnv2</a>.
eqTypeX :: HasCallStack => RnEnv2 -> Type -> Type -> Bool

-- | Like <tt>pickyEqTypeVis</tt>, but returns a Bool for convenience
pickyEqType :: Type -> Type -> Bool
tcEqType :: HasDebugCallStack => Type -> Type -> Bool
tcEqKind :: HasDebugCallStack => Kind -> Kind -> Bool

-- | Just like <a>tcEqType</a>, but will return True for types of different
--   kinds as long as their non-coercion structure is identical.
tcEqTypeNoKindCheck :: Type -> Type -> Bool

-- | Returns True if the <i>visible</i> part of the types might look equal,
--   even if they are really unequal (in the invisible bits)
--   
--   This function is very similar to tc_eq_type but it is much more
--   heuristic. Notably, it is always safe to return True, even with types
--   that might (in truth) be unequal -- this affects error messages only
--   (Originally this test was done by eqType with an extra flag, but the
--   result was hard to understand.)
mayLookIdentical :: Type -> Type -> Bool

-- | Check whether two TyConApps are the same; if the number of arguments
--   are different, just checks the common prefix of arguments.
tcEqTyConApps :: TyCon -> [Type] -> TyCon -> [Type] -> Bool

-- | Do these denote the same level of visibility? <a>Required</a>
--   arguments are visible, others are not. So this function equates
--   <a>Specified</a> and <a>Inferred</a>. Used for printing.
eqForAllVis :: ForAllTyFlag -> ForAllTyFlag -> Bool
eqVarBndrs :: HasCallStack => RnEnv2 -> [Var] -> [Var] -> Maybe RnEnv2
deNoteType :: Type -> Type
getDFunTyKey :: Type -> OccName
evVarPred :: EvVar -> PredType

-- | Returns the (kind, type) variables in a type that are as-yet-unknown:
--   metavariables and RuntimeUnks
ambigTkvsOfTy :: TcType -> ([Var], [Var])
mkMinimalBySCs :: (a -> PredType) -> [a] -> [a]
transSuperClasses :: PredType -> [PredType]
pickCapturedPreds :: TyVarSet -> TcThetaType -> TcThetaType
immSuperClasses :: Class -> [Type] -> [PredType]
boxEqPred :: EqRel -> Type -> Type -> Maybe (Class, [Type])
isImprovementPred :: PredType -> Bool

-- | Finds outermost type-family applications occurring in a type, after
--   expanding synonyms. In the list (F, tys) that is returned we guarantee
--   that tys matches F's arity. For example, given type family F a :: *
--   -&gt; * (arity 1) calling tcTyFamInsts on (Maybe (F Int Bool) will
--   return (F, [Int]), not (F, [Int,Bool])
--   
--   This is important for its use in deciding termination of type
--   instances (see #11581). E.g. type instance G [Int] = ...(F Int &lt;big
--   type&gt;)... we don't need to take &lt;big type&gt; into account when
--   asking if the calls on the RHS are smaller than the LHS
tcTyFamInsts :: Type -> [(TyCon, [Type])]

-- | Like <a>tcTyFamInsts</a>, except that the output records whether the
--   type family and its arguments occur as an <i>invisible</i> argument in
--   some type application. This information is useful because it helps GHC
--   know when to turn on <tt>-fprint-explicit-kinds</tt> during error
--   reporting so that users can actually see the type family being
--   mentioned.
--   
--   As an example, consider:
--   
--   <pre>
--   class C a
--   data T (a :: k)
--   type family F a :: k
--   instance C (T @(F Int) (F Bool))
--   </pre>
--   
--   There are two occurrences of the type family <tt>F</tt> in that
--   <tt>C</tt> instance, so <tt><a>tcTyFamInstsAndVis</a> (C (T @(F Int)
--   (F Bool)))</tt> will return:
--   
--   <pre>
--   [ (<a>True</a>,  F, [Int])
--   , (<a>False</a>, F, [Bool]) ]
--   </pre>
--   
--   <tt>F Int</tt> is paired with <a>True</a> since it appears as an
--   <i>invisible</i> argument to <tt>C</tt>, whereas <tt>F Bool</tt> is
--   paired with <a>False</a> since it appears an a <i>visible</i> argument
--   to <tt>C</tt>.
--   
--   See also Note [Showing invisible bits of types in error messages] in
--   <a>GHC.Tc.Errors.Ppr</a>.
tcTyFamInstsAndVis :: Type -> [(Bool, TyCon, [Type])]

-- | In an application of a <a>TyCon</a> to some arguments, find the
--   outermost occurrences of type family applications within the
--   arguments. This function will not consider the <a>TyCon</a> itself
--   when checking for type family applications.
--   
--   See <a>tcTyFamInstsAndVis</a> for more details on how this works (as
--   this function is called inside of <a>tcTyFamInstsAndVis</a>).
tcTyConAppTyFamInstsAndVis :: TyCon -> [Type] -> [(Bool, TyCon, [Type])]

-- | Check that a type does not contain any type family applications.
isTyFamFree :: Type -> Bool
exactTyCoVarsOfType :: Type -> TyCoVarSet
exactTyCoVarsOfTypes :: [Type] -> TyCoVarSet
anyRewritableTyVar :: EqRel -> (UnderFam -> EqRel -> TcTyVar -> Bool) -> TcType -> Bool
anyRewritableTyFamApp :: EqRel -> (UnderFam -> EqRel -> TyCon -> [TcType] -> Bool) -> TcType -> Bool
type UnderFam = Bool

-- | The Paterson size of a given type, in the sense of Note [Paterson
--   conditions] in GHC.Tc.Validity
--   
--   <ul>
--   <li>after expanding synonyms,</li>
--   <li>ignoring coercions (as they are not user written).</li>
--   </ul>
data PatersonSize

-- | The type mentions a type family, so the size could be anything.
PS_TyFam :: TyCon -> PatersonSize

-- | The type does not mention a type family.
PS_Vanilla :: [TyVar] -> Int -> PatersonSize

-- | free tyvars, including repetitions;
[ps_tvs] :: PatersonSize -> [TyVar]

-- | number of type constructors and variables
[ps_size] :: PatersonSize -> Int

-- | Why did the Paterson conditions fail; that is, why was the context P
--   not Paterson-smaller than the head H?
--   
--   See Note [Paterson conditions] in GHC.Tc.Validity.
data PatersonCondFailure

-- | Some type variables occur more often in P than in H. See (PC1) in Note
--   [Paterson conditions] in GHC.Tc.Validity.
PCF_TyVar :: [TyVar] -> PatersonCondFailure
PCF_Size :: PatersonCondFailure

-- | P contains a type family. See (PC3) in Note [Paterson conditions] in
--   GHC.Tc.Validity.
PCF_TyFam :: TyCon -> PatersonCondFailure

-- | Indicates whether a Paterson condition failure occurred in an instance
--   declaration or a type family equation. Useful for differentiating
--   context in error messages.
data PatersonCondFailureContext
InInstanceDecl :: PatersonCondFailureContext
InTyFamEquation :: PatersonCondFailureContext

-- | <tt>ltPatersonSize ps1 ps2</tt> returns:
--   
--   <ul>
--   <li><tt>Nothing</tt> iff <tt>ps1</tt> is definitely strictly smaller
--   than <tt>ps2</tt>,</li>
--   <li><tt>Just ps_fail</tt> otherwise; <tt>ps_fail</tt> says what went
--   wrong.</li>
--   </ul>
ltPatersonSize :: PatersonSize -> PatersonSize -> Maybe PatersonCondFailure
pSizeZero :: PatersonSize
pSizeOne :: PatersonSize
pSizeType :: Type -> PatersonSize
pSizeTypeX :: VarSet -> Type -> PatersonSize
pSizeTypes :: [Type] -> PatersonSize
pSizeClassPred :: Class -> [Type] -> PatersonSize
pSizeClassPredX :: VarSet -> Class -> [Type] -> PatersonSize
pSizeTyConApp :: TyCon -> [Type] -> PatersonSize
noMoreTyVars :: [TyVar] -> [TyVar] -> [TyVar]
allDistinctTyVars :: TyVarSet -> [KindOrType] -> Bool
type TypeSize = IntWithInf
sizeType :: Type -> TypeSize
sizeTypes :: [Type] -> TypeSize

-- | Do a topological sort on a list of tyvars, so that binders occur
--   before occurrences E.g. given [ a::k, k::*, b::k ] it'll return a
--   well-scoped list [ k::*, a::k, b::k ]
--   
--   This is a deterministic sorting operation (that is, doesn't depend on
--   Uniques).
--   
--   It is also meant to be stable: that is, variables should not be
--   reordered unnecessarily. This is specified in Note [ScopedSort] See
--   also Note [Ordering of implicit variables] in <a>GHC.Rename.HsType</a>
scopedSort :: [TyCoVar] -> [TyCoVar]

-- | When this says <a>True</a>, ignore this class constraint during a
--   termination check See (PS1) in Note [The PatersonSize of a type]
isTerminatingClass :: Class -> Bool
isStuckTypeFamily :: TyCon -> Bool

-- | The key type representing kinds in the compiler.
type Kind = Type
liftedTypeKind :: Type
constraintKind :: Kind

-- | Returns True if the argument is (lifted) Type or Constraint See Note
--   [TYPE and CONSTRAINT] in GHC.Builtin.Types.Prim
isLiftedTypeKind :: Kind -> Bool

-- | Returns True if the kind classifies unlifted types (like 'Int#') and
--   False otherwise. Note that this returns False for
--   representation-polymorphic kinds, which may be specialized to a kind
--   that classifies unlifted types.
isUnliftedTypeKind :: Kind -> Bool

-- | Does this classify a type allowed to have values? Responds True to
--   things like *, TYPE Lifted, TYPE IntRep, TYPE v, Constraint.
--   
--   True of a kind `TYPE _` or `CONSTRAINT _`
isTYPEorCONSTRAINT :: Kind -> Bool
data Type

-- | A type of the form <tt>p</tt> of constraint kind represents a value
--   whose type is the Haskell predicate <tt>p</tt>, where a predicate is
--   what occurs before the <tt>=&gt;</tt> in a Haskell type.
--   
--   We use <a>PredType</a> as documentation to mark those types that we
--   guarantee to have this kind.
--   
--   It can be expanded into its representation, but:
--   
--   <ul>
--   <li>The type checker must treat it as opaque</li>
--   <li>The rest of the compiler treats it as transparent</li>
--   </ul>
--   
--   Consider these examples:
--   
--   <pre>
--   f :: (Eq a) =&gt; a -&gt; Int
--   g :: (?x :: Int -&gt; Int) =&gt; a -&gt; Int
--   h :: (r\l) =&gt; {r} =&gt; {l::Int | r}
--   </pre>
--   
--   Here the <tt>Eq a</tt> and <tt>?x :: Int -&gt; Int</tt> and
--   <tt>rl</tt> are all called "predicates"
type PredType = Type

-- | A collection of <a>PredType</a>s
type ThetaType = [PredType]

-- | A <a>PiTyBinder</a> represents an argument to a function. PiTyBinders
--   can be dependent (<a>Named</a>) or nondependent (<a>Anon</a>). They
--   may also be visible or not. See Note [PiTyBinders]
data PiTyBinder

-- | ForAllTyFlag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, ForAllTyBinders, TyConBinders,
--   and visibility] in <a>GHC.Core.TyCo.Rep</a>
data ForAllTyFlag
Invisible :: !Specificity -> ForAllTyFlag
Required :: ForAllTyFlag
pattern Inferred :: ForAllTyFlag
pattern Specified :: ForAllTyFlag

-- | The non-dependent version of <a>ForAllTyFlag</a>. See Note [FunTyFlag]
--   Appears here partly so that it's together with its friends
--   ForAllTyFlag and ForallVisFlag, but also because it is used in
--   IfaceType, rather early in the compilation chain
data FunTyFlag
FTF_T_T :: FunTyFlag
FTF_T_C :: FunTyFlag
FTF_C_T :: FunTyFlag
FTF_C_C :: FunTyFlag

-- | Like <tt>mkTyCoForAllTy</tt>, but does not check the occurrence of the
--   binder See Note [Unused coercion variable in ForAllTy]
mkForAllTy :: ForAllTyBinder -> Type -> Type

-- | Wraps foralls over the type using the provided <a>TyCoVar</a>s from
--   left to right
mkForAllTys :: [ForAllTyBinder] -> Type -> Type

-- | Wraps foralls over the type using the provided <a>InvisTVBinder</a>s
--   from left to right
mkInvisForAllTys :: [InvisTVBinder] -> Type -> Type

-- | Like <a>mkForAllTys</a>, but assumes all variables are dependent and
--   <a>Inferred</a>, a common case
mkTyCoInvForAllTys :: [TyCoVar] -> Type -> Type

-- | Like <a>mkForAllTys</a>, but assumes all variables are dependent and
--   <a>Specified</a>, a common case
mkSpecForAllTys :: [TyVar] -> Type -> Type

-- | Make a dependent forall over an <a>Inferred</a> variable
mkTyCoInvForAllTy :: TyCoVar -> Type -> Type

-- | Like <a>mkTyCoInvForAllTy</a>, but tv should be a tyvar
mkInfForAllTy :: TyVar -> Type -> Type

-- | Like <a>mkTyCoInvForAllTys</a>, but tvs should be a list of tyvar
mkInfForAllTys :: [TyVar] -> Type -> Type
mkVisFunTy :: HasDebugCallStack => Mult -> Type -> Type -> Type

-- | Make nested arrow types | Special, common, case: Arrow type with mult
--   Many
mkVisFunTyMany :: HasDebugCallStack => Type -> Type -> Type
infixr 3 `mkVisFunTyMany`
mkVisFunTysMany :: [Type] -> Type -> Type
mkScaledFunTys :: HasDebugCallStack => [Scaled Type] -> Type -> Type
mkInvisFunTy :: HasDebugCallStack => Type -> Type -> Type
infixr 3 `mkInvisFunTy`
mkInvisFunTys :: HasDebugCallStack => [Type] -> Type -> Type

-- | A key function: builds a <a>TyConApp</a> or <a>FunTy</a> as
--   appropriate to its arguments. Applies its arguments to the constructor
--   from left to right.
mkTyConApp :: TyCon -> [Type] -> Type

-- | Applies a type to another, as in e.g. <tt>k a</tt>
mkAppTy :: Type -> Type -> Type
mkAppTys :: Type -> [Type] -> Type

-- | (mkTyConTy tc) returns (TyConApp tc []) but arranges to share that
--   TyConApp among all calls See Note [Sharing nullary TyConApps] So it's
--   just an alias for tyConNullaryTy!
mkTyConTy :: TyCon -> Type
mkTyVarTy :: TyVar -> Type
mkTyVarTys :: [TyVar] -> [Type]
mkTyCoVarTy :: TyCoVar -> Type
mkTyCoVarTys :: [TyCoVar] -> [Type]
isClassPred :: PredType -> Bool
isEqPrimPred :: PredType -> Bool
isIPLikePred :: Type -> Bool
isEqPred :: PredType -> Bool
isEqualityClass :: Class -> Bool
mkClassPred :: Class -> [Type] -> PredType
tcSplitQuantPredTy :: Type -> ([TyVar], [Type], PredType)
tcSplitDFunTy :: Type -> ([TyVar], [Type], Class, [Type])
tcSplitDFunHead :: Type -> (Class, [Type])
tcSplitMethodTy :: Type -> ([TyVar], PredType, Type)

-- | Is a tyvar of type <a>RuntimeRep</a>?
isRuntimeRepVar :: TyVar -> Bool

-- | Checks that a kind of the form <a>Type</a>, <tt>Constraint</tt> or
--   <tt>'TYPE r</tt> is concrete. See <a>isConcreteType</a>.
--   
--   <b>Precondition:</b> The type has kind `TYPE blah` or `CONSTRAINT
--   blah`
isFixedRuntimeRepKind :: HasDebugCallStack => Kind -> Bool

-- | Does this binder bind a visible argument?
isVisiblePiTyBinder :: PiTyBinder -> Bool

-- | Does this binder bind an invisible argument?
isInvisiblePiTyBinder :: PiTyBinder -> Bool

-- | Type &amp; coercion &amp; id substitution
--   
--   The <a>Subst</a> data type defined in this module contains
--   substitution for tyvar, covar and id. However, operations on
--   IdSubstEnv (mapping from <a>Id</a> to <a>CoreExpr</a>) that require
--   the definition of the <a>Expr</a> data type are defined in
--   GHC.Core.Subst to avoid circular module dependency.
data Subst
Subst :: InScopeSet -> IdSubstEnv -> TvSubstEnv -> CvSubstEnv -> Subst

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type
emptySubst :: Subst
mkEmptySubst :: InScopeSet -> Subst

-- | Generates the in-scope set for the <a>Subst</a> from the types in the
--   incoming environment. No CoVars or Ids, please!
zipTvSubst :: HasDebugCallStack => [TyVar] -> [Type] -> Subst

-- | Generates the in-scope set for the <tt>TCvSubst</tt> from the types in
--   the incoming environment. No CoVars, please! The InScopeSet is just a
--   thunk so with a bit of luck it'll never be evaluated
mkTvSubstPrs :: [(TyVar, Type)] -> Subst
notElemSubst :: Var -> Subst -> Bool
unionSubst :: Subst -> Subst -> Subst
getTvSubstEnv :: Subst -> TvSubstEnv

-- | Find the in-scope set: see Note [The substitution invariant]
getSubstInScope :: Subst -> InScopeSet

-- | Add the <a>Var</a> to the in-scope set
extendSubstInScope :: Subst -> Var -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeList :: Subst -> [Var] -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeSet :: Subst -> VarSet -> Subst
extendTvSubstAndInScope :: Subst -> TyVar -> Type -> Subst
lookupTyVar :: Subst -> TyVar -> Maybe Type
extendTCvSubst :: Subst -> TyCoVar -> Type -> Subst
substTyVarBndr :: HasDebugCallStack => Subst -> TyVar -> (Subst, TyVar)

-- | Add a substitution for a <a>TyVar</a> to the <a>Subst</a> The
--   <a>TyVar</a> *must* be a real TyVar, and not a CoVar You must ensure
--   that the in-scope set is such that Note [The substitution invariant]
--   holds after extending the substitution like this.
extendTvSubst :: Subst -> TyVar -> Type -> Subst
isInScope :: Var -> Subst -> Bool
mkTCvSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> Subst

-- | Make a TCvSubst with specified tyvar subst and empty covar subst
mkTvSubst :: InScopeSet -> TvSubstEnv -> Subst

-- | The InScopeSet is just a thunk so with a bit of luck it'll never be
--   evaluated
zipTyEnv :: HasDebugCallStack => [TyVar] -> [Type] -> TvSubstEnv
zipCoEnv :: HasDebugCallStack => [CoVar] -> [Coercion] -> CvSubstEnv

-- | Substitute within a <a>Type</a> The substitution has to satisfy the
--   invariants described in Note [The substitution invariant].
substTy :: HasDebugCallStack => Subst -> Type -> Type

-- | Substitute within several <a>Type</a>s The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTys :: HasDebugCallStack => Subst -> [Type] -> [Type]
substScaledTys :: HasDebugCallStack => Subst -> [Scaled Type] -> [Scaled Type]

-- | Type substitution, see <a>zipTvSubst</a>
substTyWith :: HasDebugCallStack => [TyVar] -> [Type] -> Type -> Type

-- | Substitute covars within a type
substTyWithCoVars :: [CoVar] -> [Coercion] -> Type -> Type

-- | Substitute within a <a>Type</a> after adding the free variables of the
--   type to the in-scope set. This is useful for the case when the free
--   variables aren't already in the in-scope set or easily available. See
--   also Note [The substitution invariant].
substTyAddInScope :: HasDebugCallStack => Subst -> Type -> Type

-- | Substitute within a <a>Type</a> disabling the sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyUnchecked :: Subst -> Type -> Type

-- | Substitute within several <a>Type</a>s disabling the sanity checks.
--   The problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substTysUnchecked to substTys and remove this
--   function. Please don't use in new code.
substTysUnchecked :: Subst -> [Type] -> [Type]
substScaledTyUnchecked :: HasDebugCallStack => Subst -> Scaled Type -> Scaled Type

-- | Substitute within a <a>ThetaType</a> disabling the sanity checks. The
--   problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substThetaUnchecked to substTheta and remove this
--   function. Please don't use in new code.
substThetaUnchecked :: Subst -> ThetaType -> ThetaType

-- | Type substitution, see <a>zipTvSubst</a>. Disables sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyWithUnchecked :: [TyVar] -> [Type] -> Type -> Type

-- | Substitute within a <a>Coercion</a> disabling sanity checks. The
--   problems that the sanity checks in substCo catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substCoUnchecked to substCo and remove this function. Please
--   don't use in new code.
substCoUnchecked :: Subst -> Coercion -> Coercion

-- | Coercion substitution, see <a>zipTvSubst</a>. Disables sanity checks.
--   The problems that the sanity checks in substCo catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substCoUnchecked to substCo and remove this function.
--   Please don't use in new code.
substCoWithUnchecked :: [TyVar] -> [Type] -> Coercion -> Coercion

-- | Substitute within a <a>ThetaType</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTheta :: HasDebugCallStack => Subst -> ThetaType -> ThetaType

-- | Is the given type definitely unlifted? See
--   <a>Type#type_classification</a> for what an unlifted type is.
--   
--   Panics on representation-polymorphic types; See
--   <a>mightBeUnliftedType</a> for a more approximate predicate that
--   behaves better in the presence of representation polymorphism.
isUnliftedType :: HasDebugCallStack => Type -> Bool
isUnboxedTupleType :: Type -> Bool

-- | Returns true of types that are opaque to Haskell.
isPrimitiveType :: Type -> Bool

-- | This function strips off the <i>top layer only</i> of a type synonym
--   application (if any) its underlying representation type. Returns
--   <a>Nothing</a> if there is nothing to look through.
--   
--   This function does not look through type family applications.
--   
--   By being non-recursive and inlined, this case analysis gets
--   efficiently joined onto the case analysis that the caller is already
--   doing
coreView :: Type -> Maybe Type
tyCoVarsOfType :: Type -> TyCoVarSet
tyCoVarsOfTypes :: [Type] -> TyCoVarSet
closeOverKinds :: TyCoVarSet -> TyCoVarSet

-- | The worker for <a>tyCoFVsOfType</a> and <tt>tyCoFVsOfTypeList</tt>.
--   The previous implementation used <a>unionVarSet</a> which is O(n+m)
--   and can make the function quadratic. It's exported, so that it can be
--   composed with other functions that compute free variables. See Note
--   [FV naming conventions] in <a>GHC.Utils.FV</a>.
--   
--   Eta-expanded because that makes it run faster (apparently) See Note
--   [FV eta expansion] in <a>GHC.Utils.FV</a> for explanation.
tyCoFVsOfType :: Type -> FV
tyCoFVsOfTypes :: [Type] -> FV

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in a
--   deterministic set. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfTypeDSet :: Type -> DTyCoVarSet

-- | Returns free variables of types, including kind variables as a
--   deterministic set. For type synonyms it does <i>not</i> expand the
--   synonym.
tyCoVarsOfTypesDSet :: [Type] -> DTyCoVarSet

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministic set.
closeOverKindsDSet :: DTyVarSet -> DTyVarSet

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in
--   deterministic order. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfTypeList :: Type -> [TyCoVar]

-- | Returns free variables of types, including kind variables as a
--   deterministically ordered list. For type synonyms it does <i>not</i>
--   expand the synonym.
tyCoVarsOfTypesList :: [Type] -> [TyCoVar]
noFreeVarsOfType :: Type -> Bool
pprKind :: Kind -> SDoc
pprParendKind :: Kind -> SDoc
pprSigmaType :: Type -> SDoc
pprType :: Type -> SDoc
pprParendType :: Type -> SDoc
pprTypeApp :: TyCon -> [Type] -> SDoc
pprTheta :: ThetaType -> SDoc
pprParendTheta :: ThetaType -> SDoc
pprThetaArrowTy :: ThetaType -> SDoc
pprClassPred :: Class -> [Type] -> SDoc
pprTCvBndr :: ForAllTyBinder -> SDoc
pprTCvBndrs :: [ForAllTyBinder] -> SDoc

-- | For every arg a tycon can take, the returned list says True if the
--   argument is taken visibly, and False otherwise. Ends with an infinite
--   tail of Trues to allow for oversaturation.
tyConVisibilities :: TyCon -> [Bool]

-- | If the tycon is applied to the types, is the next argument visible?
isNextTyConArgVisible :: TyCon -> [Type] -> Bool

-- | Should this type be applied to a visible argument? E.g. (s t): is
--   <tt>t</tt> a visible argument of <tt>s</tt>?
isNextArgVisible :: TcType -> Bool
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcType.ExpPatType
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcType.ExpType
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcType.InferResult
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcType.MetaDetails
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcType.MetaInfo
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcType.PatersonSize
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcType.TcLevel
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcType.TcTyVarDetails

module GHC.Types.DefaultEnv
data ClassDefaults
ClassDefaults :: !TyCon -> [Type] -> Maybe Module -> Maybe (WarningTxt GhcRn) -> ClassDefaults

-- | always a class constructor
[cd_class] :: ClassDefaults -> !TyCon
[cd_types] :: ClassDefaults -> [Type]

-- | <tt>Nothing</tt> for built-in, <tt>Just</tt> the current module or the
--   module whence the default was imported see Note [Default exports] in
--   GHC.Tc.Gen.Export
[cd_module] :: ClassDefaults -> Maybe Module

-- | Warning emitted when the default is used
[cd_warn] :: ClassDefaults -> Maybe (WarningTxt GhcRn)

-- | Default environment mapping class <tt>TyCon</tt>s to their default
--   type lists
type DefaultEnv = TyConEnv ClassDefaults
emptyDefaultEnv :: DefaultEnv
isEmptyDefaultEnv :: DefaultEnv -> Bool
defaultEnv :: [ClassDefaults] -> DefaultEnv
unitDefaultEnv :: ClassDefaults -> DefaultEnv
lookupDefaultEnv :: DefaultEnv -> Name -> Maybe ClassDefaults
filterDefaultEnv :: (ClassDefaults -> Bool) -> DefaultEnv -> DefaultEnv
defaultList :: DefaultEnv -> [ClassDefaults]
plusDefaultEnv :: DefaultEnv -> DefaultEnv -> DefaultEnv
instance GHC.Internal.Data.Data.Data GHC.Types.DefaultEnv.ClassDefaults
instance GHC.Utils.Outputable.Outputable GHC.Types.DefaultEnv.ClassDefaults

module GHC.Core.Coercion.Opt

-- | optCoercion applies a substitution to a coercion, *and* optimises it
--   to reduce its size
optCoercion :: OptCoercionOpts -> Subst -> Coercion -> NormalCo

-- | Coercion optimisation options
newtype OptCoercionOpts
OptCoercionOpts :: Bool -> OptCoercionOpts

-- | Enable coercion optimisation (reduce its size)
[optCoercionEnabled] :: OptCoercionOpts -> Bool

module GHC.Iface.Syntax
data IfaceDecl
IfaceId :: IfaceTopBndr -> IfaceType -> IfaceIdDetails -> IfaceIdInfo -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifType] :: IfaceDecl -> IfaceType
[ifIdDetails] :: IfaceDecl -> IfaceIdDetails
[ifIdInfo] :: IfaceDecl -> IfaceIdInfo
IfaceData :: IfaceTopBndr -> [IfaceTyConBinder] -> IfaceType -> Maybe CType -> [Role] -> IfaceContext -> IfaceConDecls -> Bool -> IfaceTyConParent -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifBinders] :: IfaceDecl -> [IfaceTyConBinder]
[ifResKind] :: IfaceDecl -> IfaceType
[ifCType] :: IfaceDecl -> Maybe CType
[ifRoles] :: IfaceDecl -> [Role]
[ifCtxt] :: IfaceDecl -> IfaceContext
[ifCons] :: IfaceDecl -> IfaceConDecls
[ifGadtSyntax] :: IfaceDecl -> Bool
[ifParent] :: IfaceDecl -> IfaceTyConParent
IfaceSynonym :: IfaceTopBndr -> [Role] -> [IfaceTyConBinder] -> IfaceKind -> IfaceType -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifRoles] :: IfaceDecl -> [Role]
[ifBinders] :: IfaceDecl -> [IfaceTyConBinder]
[ifResKind] :: IfaceDecl -> IfaceKind
[ifSynRhs] :: IfaceDecl -> IfaceType
IfaceFamily :: IfaceTopBndr -> Maybe IfLclName -> [IfaceTyConBinder] -> IfaceKind -> IfaceFamTyConFlav -> Injectivity -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifResVar] :: IfaceDecl -> Maybe IfLclName
[ifBinders] :: IfaceDecl -> [IfaceTyConBinder]
[ifResKind] :: IfaceDecl -> IfaceKind
[ifFamFlav] :: IfaceDecl -> IfaceFamTyConFlav
[ifFamInj] :: IfaceDecl -> Injectivity
IfaceClass :: IfaceTopBndr -> [Role] -> [IfaceTyConBinder] -> [FunDep IfLclName] -> IfaceClassBody -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifRoles] :: IfaceDecl -> [Role]
[ifBinders] :: IfaceDecl -> [IfaceTyConBinder]
[ifFDs] :: IfaceDecl -> [FunDep IfLclName]
[ifBody] :: IfaceDecl -> IfaceClassBody
IfaceAxiom :: IfaceTopBndr -> IfaceTyCon -> Role -> [IfaceAxBranch] -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifTyCon] :: IfaceDecl -> IfaceTyCon
[ifRole] :: IfaceDecl -> Role
[ifAxBranches] :: IfaceDecl -> [IfaceAxBranch]
IfacePatSyn :: IfaceTopBndr -> Bool -> (IfExtName, Bool) -> Maybe (IfExtName, Bool) -> [IfaceForAllSpecBndr] -> [IfaceForAllSpecBndr] -> IfaceContext -> IfaceContext -> [IfaceType] -> IfaceType -> [FieldLabel] -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifPatIsInfix] :: IfaceDecl -> Bool
[ifPatMatcher] :: IfaceDecl -> (IfExtName, Bool)
[ifPatBuilder] :: IfaceDecl -> Maybe (IfExtName, Bool)
[ifPatUnivBndrs] :: IfaceDecl -> [IfaceForAllSpecBndr]
[ifPatExBndrs] :: IfaceDecl -> [IfaceForAllSpecBndr]
[ifPatProvCtxt] :: IfaceDecl -> IfaceContext
[ifPatReqCtxt] :: IfaceDecl -> IfaceContext
[ifPatArgs] :: IfaceDecl -> [IfaceType]
[ifPatTy] :: IfaceDecl -> IfaceType
[ifFieldLabels] :: IfaceDecl -> [FieldLabel]
data IfaceFamTyConFlav
IfaceDataFamilyTyCon :: IfaceFamTyConFlav
IfaceOpenSynFamilyTyCon :: IfaceFamTyConFlav

-- | Name of associated axiom and branches for pretty printing purposes, or
--   <a>Nothing</a> for an empty closed family without an axiom See Note
--   [Pretty printing via Iface syntax] in <a>GHC.Types.TyThing.Ppr</a>
IfaceClosedSynFamilyTyCon :: Maybe (IfExtName, [IfaceAxBranch]) -> IfaceFamTyConFlav
IfaceAbstractClosedSynFamilyTyCon :: IfaceFamTyConFlav
IfaceBuiltInSynFamTyCon :: IfaceFamTyConFlav
data IfaceClassOp
IfaceClassOp :: IfaceTopBndr -> IfaceType -> Maybe (DefMethSpec IfaceType) -> IfaceClassOp
data IfaceAT
IfaceAT :: IfaceDecl -> Maybe IfaceType -> IfaceAT
data IfaceConDecl
IfCon :: IfaceTopBndr -> Bool -> Bool -> [IfaceBndr] -> [IfaceForAllSpecBndr] -> IfaceEqSpec -> IfaceContext -> [(IfaceMult, IfaceType)] -> [FieldLabel] -> [IfaceBang] -> [IfaceSrcBang] -> IfaceConDecl
[ifConName] :: IfaceConDecl -> IfaceTopBndr
[ifConWrapper] :: IfaceConDecl -> Bool
[ifConInfix] :: IfaceConDecl -> Bool
[ifConExTCvs] :: IfaceConDecl -> [IfaceBndr]
[ifConUserTvBinders] :: IfaceConDecl -> [IfaceForAllSpecBndr]
[ifConEqSpec] :: IfaceConDecl -> IfaceEqSpec
[ifConCtxt] :: IfaceConDecl -> IfaceContext
[ifConArgTys] :: IfaceConDecl -> [(IfaceMult, IfaceType)]
[ifConFields] :: IfaceConDecl -> [FieldLabel]
[ifConStricts] :: IfaceConDecl -> [IfaceBang]
[ifConSrcStricts] :: IfaceConDecl -> [IfaceSrcBang]
data IfaceConDecls
IfAbstractTyCon :: IfaceConDecls
IfDataTyCon :: !Bool -> [IfaceConDecl] -> IfaceConDecls
IfNewTyCon :: IfaceConDecl -> IfaceConDecls
type IfaceEqSpec = [(IfLclName, IfaceType)]
data IfaceExpr
IfaceLcl :: IfLclName -> IfaceExpr
IfaceExt :: IfExtName -> IfaceExpr
IfaceType :: IfaceType -> IfaceExpr
IfaceCo :: IfaceCoercion -> IfaceExpr
IfaceTuple :: TupleSort -> [IfaceExpr] -> IfaceExpr
IfaceLam :: IfaceLamBndr -> IfaceExpr -> IfaceExpr
IfaceApp :: IfaceExpr -> IfaceExpr -> IfaceExpr
IfaceCase :: IfaceExpr -> IfLclName -> [IfaceAlt] -> IfaceExpr
IfaceECase :: IfaceExpr -> IfaceType -> IfaceExpr
IfaceLet :: IfaceBinding IfaceLetBndr -> IfaceExpr -> IfaceExpr
IfaceCast :: IfaceExpr -> IfaceCoercion -> IfaceExpr
IfaceLit :: Literal -> IfaceExpr
IfaceLitRubbish :: TypeOrConstraint -> IfaceType -> IfaceExpr
IfaceFCall :: ForeignCall -> IfaceType -> IfaceExpr
IfaceTick :: IfaceTickish -> IfaceExpr -> IfaceExpr
data IfaceAlt
IfaceAlt :: IfaceConAlt -> [IfLclName] -> IfaceExpr -> IfaceAlt
data IfaceLetBndr
IfLetBndr :: IfLclName -> IfaceType -> IfaceIdInfo -> JoinPointHood -> IfaceLetBndr
type IfaceBinding b = IfaceBindingX IfaceExpr b
data IfaceBindingX r b
IfaceNonRec :: b -> r -> IfaceBindingX r b
IfaceRec :: [(b, r)] -> IfaceBindingX r b
data IfaceMaybeRhs
IfUseUnfoldingRhs :: IfaceMaybeRhs
IfRhs :: IfaceExpr -> IfaceMaybeRhs
data IfaceConAlt
IfaceDefaultAlt :: IfaceConAlt
IfaceDataAlt :: IfExtName -> IfaceConAlt
IfaceLitAlt :: Literal -> IfaceConAlt
type IfaceIdInfo = [IfaceInfoItem]
data IfaceIdDetails
IfVanillaId :: IfaceIdDetails
IfWorkerLikeId :: [CbvMark] -> IfaceIdDetails
IfRecSelId :: Either IfaceTyCon IfaceDecl -> IfaceTopBndr -> Bool -> FieldLabel -> IfaceIdDetails
[ifRecSelIdParent] :: IfaceIdDetails -> Either IfaceTyCon IfaceDecl
[ifRecSelFirstCon] :: IfaceIdDetails -> IfaceTopBndr
[ifRecSelIdIsNaughty] :: IfaceIdDetails -> Bool
[ifRecSelIdFieldLabel] :: IfaceIdDetails -> FieldLabel
IfDFunId :: IfaceIdDetails
data IfaceUnfolding
IfCoreUnfold :: UnfoldingSource -> IfUnfoldingCache -> IfGuidance -> IfaceExpr -> IfaceUnfolding
IfDFunUnfold :: [IfaceBndr] -> [IfaceExpr] -> IfaceUnfolding
data IfGuidance
IfNoGuidance :: IfGuidance
IfWhen :: Arity -> Bool -> Bool -> IfGuidance
data IfaceInfoItem
HsArity :: Arity -> IfaceInfoItem
HsDmdSig :: DmdSig -> IfaceInfoItem
HsCprSig :: CprSig -> IfaceInfoItem
HsInline :: InlinePragma -> IfaceInfoItem
HsUnfold :: Bool -> IfaceUnfolding -> IfaceInfoItem
HsNoCafRefs :: IfaceInfoItem
HsLFInfo :: IfaceLFInfo -> IfaceInfoItem
HsTagSig :: TagSig -> IfaceInfoItem
data IfaceRule
IfaceRule :: RuleName -> Activation -> [IfaceBndr] -> IfExtName -> [IfaceExpr] -> IfaceExpr -> Bool -> IsOrphan -> IfaceRule
[ifRuleName] :: IfaceRule -> RuleName
[ifActivation] :: IfaceRule -> Activation
[ifRuleBndrs] :: IfaceRule -> [IfaceBndr]
[ifRuleHead] :: IfaceRule -> IfExtName
[ifRuleArgs] :: IfaceRule -> [IfaceExpr]
[ifRuleRhs] :: IfaceRule -> IfaceExpr
[ifRuleAuto] :: IfaceRule -> Bool
[ifRuleOrph] :: IfaceRule -> IsOrphan
data IfaceAnnotation
IfaceAnnotation :: IfaceAnnTarget -> AnnPayload -> IfaceAnnotation
[ifAnnotatedTarget] :: IfaceAnnotation -> IfaceAnnTarget
[ifAnnotatedValue] :: IfaceAnnotation -> AnnPayload
type IfaceAnnTarget = AnnTarget OccName
data IfaceWarnings
IfWarnAll :: IfaceWarningTxt -> IfaceWarnings
IfWarnSome :: [(OccName, IfaceWarningTxt)] -> [(IfExtName, IfaceWarningTxt)] -> IfaceWarnings
data IfaceWarningTxt
IfWarningTxt :: Maybe WarningCategory -> SourceText -> [(IfaceStringLiteral, [IfExtName])] -> IfaceWarningTxt
IfDeprecatedTxt :: SourceText -> [(IfaceStringLiteral, [IfExtName])] -> IfaceWarningTxt
data IfaceStringLiteral
IfStringLiteral :: SourceText -> FastString -> IfaceStringLiteral

-- | Exported named defaults
data IfaceDefault
IfaceDefault :: IfaceTyCon -> [IfaceType] -> Maybe IfaceWarningTxt -> IfaceDefault
[ifDefaultCls] :: IfaceDefault -> IfaceTyCon
[ifDefaultTys] :: IfaceDefault -> [IfaceType]
[ifDefaultWarn] :: IfaceDefault -> Maybe IfaceWarningTxt
data IfaceClsInst
IfaceClsInst :: IfExtName -> [Maybe IfaceTyCon] -> IfExtName -> OverlapFlag -> IsOrphan -> Maybe IfaceWarningTxt -> IfaceClsInst
[ifInstCls] :: IfaceClsInst -> IfExtName
[ifInstTys] :: IfaceClsInst -> [Maybe IfaceTyCon]
[ifDFun] :: IfaceClsInst -> IfExtName
[ifOFlag] :: IfaceClsInst -> OverlapFlag
[ifInstOrph] :: IfaceClsInst -> IsOrphan
[ifInstWarn] :: IfaceClsInst -> Maybe IfaceWarningTxt
data IfaceFamInst
IfaceFamInst :: IfExtName -> [Maybe IfaceTyCon] -> IfExtName -> IsOrphan -> IfaceFamInst
[ifFamInstFam] :: IfaceFamInst -> IfExtName
[ifFamInstTys] :: IfaceFamInst -> [Maybe IfaceTyCon]
[ifFamInstAxiom] :: IfaceFamInst -> IfExtName
[ifFamInstOrph] :: IfaceFamInst -> IsOrphan
data IfaceTickish
IfaceHpcTick :: Module -> Int -> IfaceTickish
IfaceSCC :: CostCentre -> Bool -> Bool -> IfaceTickish
IfaceSource :: RealSrcSpan -> FastString -> IfaceTickish
IfaceBreakpoint :: Int -> [IfaceExpr] -> Module -> IfaceTickish
data IfaceClassBody
IfAbstractClass :: IfaceClassBody
IfConcreteClass :: IfaceContext -> [IfaceAT] -> [IfaceClassOp] -> IfaceBooleanFormula -> IfaceClassBody
[ifClassCtxt] :: IfaceClassBody -> IfaceContext
[ifATs] :: IfaceClassBody -> [IfaceAT]
[ifSigs] :: IfaceClassBody -> [IfaceClassOp]
[ifMinDef] :: IfaceClassBody -> IfaceBooleanFormula
data IfaceBooleanFormula
IfVar :: IfLclName -> IfaceBooleanFormula
IfAnd :: [IfaceBooleanFormula] -> IfaceBooleanFormula
IfOr :: [IfaceBooleanFormula] -> IfaceBooleanFormula
IfParens :: IfaceBooleanFormula -> IfaceBooleanFormula

-- | This corresponds to an HsImplBang; that is, the final implementation
--   decision about the data constructor arg
data IfaceBang
IfNoBang :: IfaceBang
IfStrict :: IfaceBang
IfUnpack :: IfaceBang
IfUnpackCo :: IfaceCoercion -> IfaceBang

-- | This corresponds to HsSrcBang
data IfaceSrcBang
IfSrcBang :: SrcUnpackedness -> SrcStrictness -> IfaceSrcBang

-- | Source Unpackedness
--   
--   What unpackedness the user requested
data SrcUnpackedness

-- | {-# UNPACK #-} specified
SrcUnpack :: SrcUnpackedness

-- | {-# NOUNPACK #-} specified
SrcNoUnpack :: SrcUnpackedness

-- | no unpack pragma
NoSrcUnpack :: SrcUnpackedness

-- | Source Strictness
--   
--   What strictness annotation the user wrote
data SrcStrictness

-- | Lazy, ie <tt>~</tt>
SrcLazy :: SrcStrictness

-- | Strict, ie <tt>!</tt>
SrcStrict :: SrcStrictness

-- | no strictness annotation
NoSrcStrict :: SrcStrictness
data IfaceAxBranch
IfaceAxBranch :: [IfaceTvBndr] -> [IfaceTvBndr] -> [IfaceIdBndr] -> IfaceAppArgs -> [Role] -> IfaceType -> [BranchIndex] -> IfaceAxBranch
[ifaxbTyVars] :: IfaceAxBranch -> [IfaceTvBndr]
[ifaxbEtaTyVars] :: IfaceAxBranch -> [IfaceTvBndr]
[ifaxbCoVars] :: IfaceAxBranch -> [IfaceIdBndr]
[ifaxbLHS] :: IfaceAxBranch -> IfaceAppArgs
[ifaxbRoles] :: IfaceAxBranch -> [Role]
[ifaxbRHS] :: IfaceAxBranch -> IfaceType
[ifaxbIncomps] :: IfaceAxBranch -> [BranchIndex]
data IfaceTyConParent
IfNoParent :: IfaceTyConParent
IfDataInstance :: IfExtName -> IfaceTyCon -> IfaceAppArgs -> IfaceTyConParent
data IfaceCompleteMatch
IfaceCompleteMatch :: [IfExtName] -> Maybe IfExtName -> IfaceCompleteMatch

-- | Iface type for LambdaFormInfo. Fields not relevant for imported Ids
--   are omitted in this type.
data IfaceLFInfo
IfLFReEntrant :: !RepArity -> IfaceLFInfo
IfLFThunk :: !Bool -> !Bool -> IfaceLFInfo
IfLFCon :: !Name -> IfaceLFInfo
IfLFUnknown :: !Bool -> IfaceLFInfo
IfLFUnlifted :: IfaceLFInfo
data IfaceTopBndrInfo
IfLclTopBndr :: IfLclName -> IfaceType -> IfaceIdInfo -> IfaceIdDetails -> IfaceTopBndrInfo
IfGblTopBndr :: IfaceTopBndr -> IfaceTopBndrInfo
data IfaceImport
IfaceImport :: ImpDeclSpec -> ImpIfaceList -> IfaceImport
data ImpIfaceList

-- | no user import list
ImpIfaceAll :: ImpIfaceList
ImpIfaceExplicit :: !IfGlobalRdrEnv -> ImpIfaceList
ImpIfaceEverythingBut :: !NameSet -> ImpIfaceList

-- | A binding top-level <a>Name</a> in an interface file (e.g. the name of
--   an <a>IfaceDecl</a>).
type IfaceTopBndr = Name
putIfaceTopBndr :: WriteBinHandle -> IfaceTopBndr -> IO ()
getIfaceTopBndr :: ReadBinHandle -> IO IfaceTopBndr
ifaceDeclImplicitBndrs :: IfaceDecl -> [OccName]
visibleIfConDecls :: IfaceConDecls -> [IfaceConDecl]
ifaceDeclFingerprints :: Fingerprint -> IfaceDecl -> [(OccName, Fingerprint)]
fromIfaceBooleanFormula :: IfaceBooleanFormula -> BooleanFormula IfLclName
fromIfaceWarnings :: IfaceWarnings -> Warnings GhcRn
fromIfaceWarningTxt :: IfaceWarningTxt -> WarningTxt GhcRn
freeNamesIfDecl :: IfaceDecl -> NameSet
freeNamesIfRule :: IfaceRule -> NameSet
freeNamesIfFamInst :: IfaceFamInst -> NameSet
freeNamesIfConDecls :: IfaceConDecls -> NameSet

-- | Pretty Print an IfaceExpr
--   
--   The first argument should be a function that adds parens in context
--   that need an atomic value (e.g. function args)
pprIfaceExpr :: (SDoc -> SDoc) -> IfaceExpr -> SDoc
pprIfaceDecl :: ShowSub -> IfaceDecl -> SDoc
newtype AltPpr
AltPpr :: Maybe (OccName -> SDoc) -> AltPpr
data ShowSub
ShowSub :: ShowHowMuch -> ShowForAllFlag -> ShowSub
[ss_how_much] :: ShowSub -> ShowHowMuch
[ss_forall] :: ShowSub -> ShowForAllFlag
data ShowHowMuch

-- | Header information only, not rhs
ShowHeader :: AltPpr -> ShowHowMuch

-- | Show the declaration and its RHS. The <tt>Maybe</tt> predicate allows
--   filtering of the sub-components which should be printing; any
--   sub-components filtered out will be elided with <tt>...</tt>.
ShowSome :: Maybe (OccName -> Bool) -> AltPpr -> ShowHowMuch

-- | Everything including GHC-internal information (used in --show-iface)
ShowIface :: ShowHowMuch

-- | Show declaration and its RHS, including GHc-internal information (e.g.
--   for <tt>--show-iface</tt>).
showToIface :: ShowSub

-- | Show a declaration but not its RHS.
showToHeader :: ShowSub
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfGuidance
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceAT
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceAlt
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceAnnotation
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceAxBranch
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceBang
instance (GHC.Utils.Binary.Binary r, GHC.Utils.Binary.Binary b) => GHC.Utils.Binary.Binary (GHC.Iface.Syntax.IfaceBindingX b r)
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceBooleanFormula
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceClassOp
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceClsInst
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceCompleteMatch
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceConAlt
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceConDecl
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceConDecls
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceDecl
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceDefault
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceExpr
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceFamInst
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceFamTyConFlav
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceIdDetails
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceInfoItem
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceLFInfo
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceLetBndr
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceMaybeRhs
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceRule
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceSrcBang
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceStringLiteral
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceTickish
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceTopBndrInfo
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceTyConParent
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceUnfolding
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceWarningTxt
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceWarnings
instance (GHC.Classes.Eq b, GHC.Classes.Eq r) => GHC.Classes.Eq (GHC.Iface.Syntax.IfaceBindingX r b)
instance GHC.Internal.Data.Foldable.Foldable (GHC.Iface.Syntax.IfaceBindingX r)
instance GHC.Internal.Base.Functor (GHC.Iface.Syntax.IfaceBindingX r)
instance GHC.Types.Name.Occurrence.HasOccName GHC.Iface.Syntax.IfaceClassOp
instance GHC.Types.Name.Occurrence.HasOccName GHC.Iface.Syntax.IfaceConDecl
instance GHC.Types.Name.Occurrence.HasOccName GHC.Iface.Syntax.IfaceDecl
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfGuidance
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceAT
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceAlt
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceAnnotation
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceAxBranch
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceBang
instance (Control.DeepSeq.NFData b, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (GHC.Iface.Syntax.IfaceBindingX a b)
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceBooleanFormula
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceClassBody
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceClassOp
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceClsInst
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceCompleteMatch
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceConAlt
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceConDecl
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceConDecls
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceDecl
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceDefault
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceExpr
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceFamInst
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceFamTyConFlav
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceIdDetails
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceImport
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceInfoItem
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceLetBndr
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceMaybeRhs
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceRule
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceSrcBang
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceStringLiteral
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceTickish
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceTopBndrInfo
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceTyConParent
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceUnfolding
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceWarningTxt
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceWarnings
instance Control.DeepSeq.NFData GHC.Iface.Syntax.ImpIfaceList
instance GHC.Types.Name.NamedThing GHC.Iface.Syntax.IfaceClassOp
instance GHC.Types.Name.NamedThing GHC.Iface.Syntax.IfaceConDecl
instance GHC.Types.Name.NamedThing GHC.Iface.Syntax.IfaceDecl
instance (GHC.Classes.Ord b, GHC.Classes.Ord r) => GHC.Classes.Ord (GHC.Iface.Syntax.IfaceBindingX r b)
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfGuidance
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceAT
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceAnnotation
instance (GHC.Utils.Outputable.Outputable r, GHC.Utils.Outputable.Outputable b) => GHC.Utils.Outputable.Outputable (GHC.Iface.Syntax.IfaceBindingX r b)
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceClassOp
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceClsInst
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceCompleteMatch
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceConAlt
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceDecl
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceDefault
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceExpr
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceFamInst
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceIdDetails
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceInfoItem
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceLFInfo
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceMaybeRhs
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceRule
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceStringLiteral
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceTopBndrInfo
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceTyConParent
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceUnfolding
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceWarningTxt
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceWarnings
instance GHC.Internal.Data.Traversable.Traversable (GHC.Iface.Syntax.IfaceBindingX r)

module GHC.HsToCore.Foreign.Utils
type Binding = (Id, CoreExpr)
getPrimTyOf :: Type -> UnaryType
primTyDescChar :: Platform -> Type -> Char

-- | Printed C Type to be used with CAPI calling convention
ppPrimTyConStgType :: TyCon -> Maybe String

module GHC.Hs.Type

-- | Mult is a type alias for Type.
--   
--   Mult must contain Type because multiplicity variables are mere type
--   variables (of kind Multiplicity) in Haskell. So the simplest
--   implementation is to make Mult be Type.
--   
--   Multiplicities can be formed with: - One: GHC.Types.One (= oneDataCon)
--   - Many: GHC.Types.Many (= manyDataCon) - Multiplication:
--   GHC.Types.MultMul (= multMulTyCon)
--   
--   So that Mult feels a bit more structured, we provide pattern synonyms
--   and smart constructors for these.
type Mult = Type

-- | This is used in the syntax. In constructor declaration. It must keep
--   the arrow representation.
data HsScaled pass a
HsScaled :: HsArrow pass -> a -> HsScaled pass a
hsMult :: HsScaled pass a -> HsArrow pass
hsScaledThing :: HsScaled pass a -> a
type HsArrow pass = HsArrowOf LHsType pass pass

-- | Denotes the type of arrows in the surface language
data HsArrowOf mult pass

-- | a -&gt; b or a → b
HsUnrestrictedArrow :: !XUnrestrictedArrow mult pass -> HsArrowOf mult pass

-- | a %1 -&gt; b or a %1 → b, or a ⊸ b
HsLinearArrow :: !XLinearArrow mult pass -> HsArrowOf mult pass

-- | a %m -&gt; b or a %m → b (very much including `a %Many -&gt; b`! This
--   is how the programmer wrote it). It is stored as an <a>HsType</a> so
--   as to preserve the syntax as written in the program.
HsExplicitMult :: !XExplicitMult mult pass -> !mult -> HsArrowOf mult pass
XArrow :: !XXArrow mult pass -> HsArrowOf mult pass
arrowToHsType :: HsArrow GhcRn -> LHsType GhcRn

-- | Convert an arrow into its corresponding multiplicity. In essence this
--   erases the information of whether the programmer wrote an explicit
--   multiplicity or a shorthand.
expandHsArrow :: (LocatedN Name -> t GhcRn) -> HsArrowOf (LocatedA (t GhcRn)) GhcRn -> LocatedA (t GhcRn)
data EpLinearArrow
EpPct1 :: !EpToken "%1" -> !TokRarrow -> EpLinearArrow
EpLolly :: !EpToken "\8888" -> EpLinearArrow
hsLinear :: forall (p :: Pass) a. IsPass p => a -> HsScaled (GhcPass p) a
hsUnrestricted :: forall (p :: Pass) a. IsPass p => a -> HsScaled (GhcPass p) a
isUnrestricted :: HsArrow GhcRn -> Bool
pprHsArrow :: forall mult (pass :: Pass). (Outputable mult, OutputableBndrId pass) => HsArrowOf mult (GhcPass pass) -> SDoc

-- | Haskell Type
data HsType pass
HsForAllTy :: XForAllTy pass -> HsForAllTelescope pass -> LHsType pass -> HsType pass
[hst_xforall] :: HsType pass -> XForAllTy pass
[hst_tele] :: HsType pass -> HsForAllTelescope pass
[hst_body] :: HsType pass -> LHsType pass
HsQualTy :: XQualTy pass -> LHsContext pass -> LHsType pass -> HsType pass
[hst_xqual] :: HsType pass -> XQualTy pass
[hst_ctxt] :: HsType pass -> LHsContext pass
[hst_body] :: HsType pass -> LHsType pass
HsTyVar :: XTyVar pass -> PromotionFlag -> LIdP pass -> HsType pass
HsAppTy :: XAppTy pass -> LHsType pass -> LHsType pass -> HsType pass
HsAppKindTy :: XAppKindTy pass -> LHsType pass -> LHsKind pass -> HsType pass
HsFunTy :: XFunTy pass -> HsArrow pass -> LHsType pass -> LHsType pass -> HsType pass
HsListTy :: XListTy pass -> LHsType pass -> HsType pass
HsTupleTy :: XTupleTy pass -> HsTupleSort -> [LHsType pass] -> HsType pass
HsSumTy :: XSumTy pass -> [LHsType pass] -> HsType pass
HsOpTy :: XOpTy pass -> PromotionFlag -> LHsType pass -> LIdP pass -> LHsType pass -> HsType pass
HsParTy :: XParTy pass -> LHsType pass -> HsType pass

-- | <pre>
--   (?x :: ty)
--   </pre>
HsIParamTy :: XIParamTy pass -> XRec pass HsIPName -> LHsType pass -> HsType pass
HsStarTy :: XStarTy pass -> Bool -> HsType pass

-- | <pre>
--   (ty :: kind)
--   </pre>
HsKindSig :: XKindSig pass -> LHsType pass -> LHsKind pass -> HsType pass
HsSpliceTy :: XSpliceTy pass -> HsUntypedSplice pass -> HsType pass
HsDocTy :: XDocTy pass -> LHsType pass -> LHsDoc pass -> HsType pass
HsBangTy :: XBangTy pass -> HsBang -> LHsType pass -> HsType pass
HsRecTy :: XRecTy pass -> [LConDeclField pass] -> HsType pass
HsExplicitListTy :: XExplicitListTy pass -> PromotionFlag -> [LHsType pass] -> HsType pass
HsExplicitTupleTy :: XExplicitTupleTy pass -> PromotionFlag -> [LHsType pass] -> HsType pass
HsTyLit :: XTyLit pass -> HsTyLit pass -> HsType pass
HsWildCardTy :: XWildCardTy pass -> HsType pass
XHsType :: !XXType pass -> HsType pass
type HsCoreTy = Type

-- | Located Haskell Type
type LHsType pass = XRec pass HsType pass

-- | Haskell Kind
type HsKind pass = HsType pass

-- | Located Haskell Kind
type LHsKind pass = XRec pass HsKind pass

-- | The type variable binders in an <a>HsForAllTy</a>. See also <tt>Note
--   [Variable Specificity and Forall Visibility]</tt> in
--   <a>GHC.Tc.Gen.HsType</a>.
data HsForAllTelescope pass

-- | A visible <tt>forall</tt> (e.g., <tt>forall a -&gt; {...}</tt>). These
--   do not have any notion of specificity, so we use <tt>()</tt> as a
--   placeholder value.
HsForAllVis :: XHsForAllVis pass -> [LHsTyVarBndr () pass] -> HsForAllTelescope pass
[hsf_xvis] :: HsForAllTelescope pass -> XHsForAllVis pass
[hsf_vis_bndrs] :: HsForAllTelescope pass -> [LHsTyVarBndr () pass]

-- | An invisible <tt>forall</tt> (e.g., <tt>forall a {b} c. {...}</tt>),
--   where each binder has a <a>Specificity</a>.
HsForAllInvis :: XHsForAllInvis pass -> [LHsTyVarBndr Specificity pass] -> HsForAllTelescope pass
[hsf_xinvis] :: HsForAllTelescope pass -> XHsForAllInvis pass
[hsf_invis_bndrs] :: HsForAllTelescope pass -> [LHsTyVarBndr Specificity pass]
XHsForAllTelescope :: !XXHsForAllTelescope pass -> HsForAllTelescope pass
type EpAnnForallVis = EpAnn (TokForall, TokRarrow)
type EpAnnForallInvis = EpAnn (TokForall, EpToken ".")

-- | Haskell Type Variable Binder See Note [Type variable binders]
data HsTyVarBndr flag pass
HsTvb :: XTyVarBndr pass -> flag -> HsBndrVar pass -> HsBndrKind pass -> HsTyVarBndr flag pass
[tvb_ext] :: HsTyVarBndr flag pass -> XTyVarBndr pass
[tvb_flag] :: HsTyVarBndr flag pass -> flag
[tvb_var] :: HsTyVarBndr flag pass -> HsBndrVar pass
[tvb_kind] :: HsTyVarBndr flag pass -> HsBndrKind pass
XTyVarBndr :: !XXTyVarBndr pass -> HsTyVarBndr flag pass

-- | Located Haskell Type Variable Binder
type LHsTyVarBndr flag pass = XRec pass HsTyVarBndr flag pass
data AnnTyVarBndr
AnnTyVarBndr :: [EpaLocation] -> [EpaLocation] -> EpToken "'" -> TokDcolon -> AnnTyVarBndr
[atv_opens] :: AnnTyVarBndr -> [EpaLocation]
[atv_closes] :: AnnTyVarBndr -> [EpaLocation]
[atv_tv] :: AnnTyVarBndr -> EpToken "'"
[atv_dcolon] :: AnnTyVarBndr -> TokDcolon
data HsBndrKind pass
HsBndrKind :: !XBndrKind pass -> LHsKind pass -> HsBndrKind pass
HsBndrNoKind :: !XBndrNoKind pass -> HsBndrKind pass
XBndrKind :: !XXBndrKind pass -> HsBndrKind pass
data HsBndrVar pass
HsBndrVar :: !XBndrVar pass -> !LIdP pass -> HsBndrVar pass
HsBndrWildCard :: !XBndrWildCard pass -> HsBndrVar pass
XBndrVar :: !XXBndrVar pass -> HsBndrVar pass
data HsBndrVis pass
HsBndrRequired :: !XBndrRequired pass -> HsBndrVis pass
HsBndrInvisible :: !XBndrInvisible pass -> HsBndrVis pass
XBndrVis :: !XXBndrVis pass -> HsBndrVis pass
isHsBndrInvisible :: HsBndrVis pass -> Bool

-- | Located Haskell Quantified Type Variables
data LHsQTyVars pass
HsQTvs :: XHsQTvs pass -> [LHsTyVarBndr (HsBndrVis pass) pass] -> LHsQTyVars pass
[hsq_ext] :: LHsQTyVars pass -> XHsQTvs pass
[hsq_explicit] :: LHsQTyVars pass -> [LHsTyVarBndr (HsBndrVis pass) pass]
XLHsQTyVars :: !XXLHsQTyVars pass -> LHsQTyVars pass

-- | The outermost type variables in a type that obeys the
--   <tt>forall</tt>-or-nothing rule. See <tt>Note [forall-or-nothing
--   rule]</tt>.
data HsOuterTyVarBndrs flag pass

-- | Implicit forall, e.g., <tt>f :: a -&gt; b -&gt; b</tt>
HsOuterImplicit :: XHsOuterImplicit pass -> HsOuterTyVarBndrs flag pass
[hso_ximplicit] :: HsOuterTyVarBndrs flag pass -> XHsOuterImplicit pass

-- | Explicit forall, e.g., <tt>f :: forall a b. a -&gt; b -&gt; b</tt>
HsOuterExplicit :: XHsOuterExplicit pass flag -> [LHsTyVarBndr flag (NoGhcTc pass)] -> HsOuterTyVarBndrs flag pass
[hso_xexplicit] :: HsOuterTyVarBndrs flag pass -> XHsOuterExplicit pass flag
[hso_bndrs] :: HsOuterTyVarBndrs flag pass -> [LHsTyVarBndr flag (NoGhcTc pass)]
XHsOuterTyVarBndrs :: !XXHsOuterTyVarBndrs pass -> HsOuterTyVarBndrs flag pass

-- | Used for type-family instance equations, e.g.,
--   
--   <pre>
--   type instance forall a. F [a] = Tree a
--   </pre>
--   
--   The notion of specificity is irrelevant in type family equations, so
--   we use <tt>()</tt> for the <a>HsOuterTyVarBndrs</a> <tt>flag</tt>.
type HsOuterFamEqnTyVarBndrs = HsOuterTyVarBndrs ()

-- | Used for signatures, e.g.,
--   
--   <pre>
--   f :: forall a {b}. blah
--   </pre>
--   
--   We use <a>Specificity</a> for the <a>HsOuterTyVarBndrs</a>
--   <tt>flag</tt> to allow distinguishing between specified and inferred
--   type variables.
type HsOuterSigTyVarBndrs = HsOuterTyVarBndrs Specificity

-- | Haskell Wildcard Binders
data HsWildCardBndrs pass thing
HsWC :: XHsWC pass thing -> thing -> HsWildCardBndrs pass thing
[hswc_ext] :: HsWildCardBndrs pass thing -> XHsWC pass thing
[hswc_body] :: HsWildCardBndrs pass thing -> thing
XHsWildCardBndrs :: !XXHsWildCardBndrs pass thing -> HsWildCardBndrs pass thing

-- | Types that can appear in pattern signatures, as well as the signatures
--   for term-level binders in RULES. See <tt>Note [Pattern signature
--   binders and scoping]</tt>.
--   
--   This is very similar to <tt>HsSigWcType</tt>, but with slightly
--   different semantics: see <tt>Note [HsType binders]</tt>. See also
--   <tt>Note [The wildcard story for types]</tt>.
data HsPatSigType pass
HsPS :: XHsPS pass -> LHsType pass -> HsPatSigType pass

-- | After renamer: <tt>HsPSRn</tt>
[hsps_ext] :: HsPatSigType pass -> XHsPS pass

-- | Main payload (the type itself)
[hsps_body] :: HsPatSigType pass -> LHsType pass
XHsPatSigType :: !XXHsPatSigType pass -> HsPatSigType pass

-- | The extension field for <a>HsPatSigType</a>, which is only used in the
--   renamer onwards. See <tt>Note [Pattern signature binders and
--   scoping]</tt>.
data HsPSRn
HsPSRn :: [Name] -> [Name] -> HsPSRn

-- | Wildcard names
[hsps_nwcs] :: HsPSRn -> [Name]

-- | Implicitly bound variable names
[hsps_imp_tvs] :: HsPSRn -> [Name]
data HsTyPat pass
HsTP :: XHsTP pass -> LHsType pass -> HsTyPat pass

-- | After renamer: <tt>HsTyPatRn</tt>
[hstp_ext] :: HsTyPat pass -> XHsTP pass

-- | Main payload (the type itself)
[hstp_body] :: HsTyPat pass -> LHsType pass
XHsTyPat :: !XXHsTyPat pass -> HsTyPat pass
data HsTyPatRn
HsTPRn :: [Name] -> [Name] -> [Name] -> HsTyPatRn

-- | Wildcard names
[hstp_nwcs] :: HsTyPatRn -> [Name]

-- | Implicitly bound variable names
[hstp_imp_tvs] :: HsTyPatRn -> [Name]

-- | Explicitly bound variable names
[hstp_exp_tvs] :: HsTyPatRn -> [Name]

-- | A variant of HsTyPatRn that uses Bags for efficient concatenation. See
--   Note [Implicit and explicit type variable binders] in GHC.Rename.Pat
data HsTyPatRnBuilder
HsTPRnB :: Bag Name -> Bag Name -> Bag Name -> HsTyPatRnBuilder
[hstpb_nwcs] :: HsTyPatRnBuilder -> Bag Name
[hstpb_imp_tvs] :: HsTyPatRnBuilder -> Bag Name
[hstpb_exp_tvs] :: HsTyPatRnBuilder -> Bag Name
tpBuilderExplicitTV :: Name -> HsTyPatRnBuilder
tpBuilderPatSig :: HsPSRn -> HsTyPatRnBuilder
buildHsTyPatRn :: HsTyPatRnBuilder -> HsTyPatRn
builderFromHsTyPatRn :: HsTyPatRn -> HsTyPatRnBuilder

-- | A type signature that obeys the <tt>forall</tt>-or-nothing rule. In
--   other words, an <a>LHsType</a> that uses an
--   <a>HsOuterSigTyVarBndrs</a> to represent its outermost type variable
--   quantification. See <tt>Note [Representing type signatures]</tt>.
data HsSigType pass
HsSig :: XHsSig pass -> HsOuterSigTyVarBndrs pass -> LHsType pass -> HsSigType pass
[sig_ext] :: HsSigType pass -> XHsSig pass
[sig_bndrs] :: HsSigType pass -> HsOuterSigTyVarBndrs pass
[sig_body] :: HsSigType pass -> LHsType pass
XHsSigType :: !XXHsSigType pass -> HsSigType pass

-- | Located Haskell Signature Type
type LHsSigType pass = XRec pass HsSigType pass

-- | Located Haskell Signature Wildcard Type
type LHsSigWcType pass = HsWildCardBndrs pass LHsSigType pass

-- | Located Haskell Wildcard Type
type LHsWcType pass = HsWildCardBndrs pass LHsType pass

-- | Haskell Tuple Sort
data HsTupleSort
HsUnboxedTuple :: HsTupleSort
HsBoxedOrConstraintTuple :: HsTupleSort

-- | Haskell Context
type HsContext pass = [LHsType pass]

-- | Located Haskell Context
type LHsContext pass = XRec pass HsContext pass
fromMaybeContext :: forall (p :: Pass). Maybe (LHsContext (GhcPass p)) -> HsContext (GhcPass p)

-- | Haskell Type Literal
data HsTyLit pass
HsNumTy :: XNumTy pass -> Integer -> HsTyLit pass
HsStrTy :: XStrTy pass -> FastString -> HsTyLit pass
HsCharTy :: XCharTy pass -> Char -> HsTyLit pass
XTyLit :: !XXTyLit pass -> HsTyLit pass

-- | These names are used early on to store the names of implicit
--   parameters. They completely disappear after type-checking.
newtype HsIPName
HsIPName :: FastString -> HsIPName
hsIPNameFS :: HsIPName -> FastString

-- | Arguments in an expression/type after splitting
data HsArg p tm ty
HsValArg :: !XValArg p -> tm -> HsArg p tm ty
HsTypeArg :: !XTypeArg p -> ty -> HsArg p tm ty
HsArgPar :: !XArgPar p -> HsArg p tm ty
XArg :: !XXArg p -> HsArg p tm ty
numVisibleArgs :: [HsArg p tm ty] -> Arity

-- | <tt><a>pprHsArgsApp</a> id fixity args</tt> pretty-prints an
--   application of <tt>id</tt> to <tt>args</tt>, using the <tt>fixity</tt>
--   to tell whether <tt>id</tt> should be printed prefix or infix.
--   Examples:
--   
--   <pre>
--   pprHsArgsApp T Prefix [HsTypeArg Bool, HsValArg Int]                        = T @Bool Int
--   pprHsArgsApp T Prefix [HsTypeArg Bool, HsArgPar, HsValArg Int]              = (T @Bool) Int
--   pprHsArgsApp (++) Infix [HsValArg Char, HsValArg Double]                    = Char ++ Double
--   pprHsArgsApp (++) Infix [HsValArg Char, HsValArg Double, HsVarArg Ordering] = (Char ++ Double) Ordering
--   </pre>
pprHsArgsApp :: forall id tm ty (p :: Pass). (OutputableBndr id, Outputable tm, Outputable ty) => id -> LexicalFixity -> [HsArg (GhcPass p) tm ty] -> SDoc
type LHsTypeArg p = HsArg p LHsType p LHsKind p

-- | Compute the <a>SrcSpan</a> associated with an <a>LHsTypeArg</a>.
lhsTypeArgSrcSpan :: LHsTypeArg GhcPs -> SrcSpan
class OutputableBndrFlag flag (p :: Pass)

-- | Located Bang Type
type LBangType pass = XRec pass BangType pass

-- | Bang Type
--   
--   In the parser, strictness and packedness annotations bind more tightly
--   than docstrings. This means that when consuming a <a>BangType</a> (and
--   looking for <a>HsBangTy</a>) we must be ready to peer behind a
--   potential layer of <a>HsDocTy</a>. See #15206 for motivation and
--   <tt>getBangType</tt> for an example.
type BangType pass = HsType pass

-- | Haskell Source Bang
--   
--   Bangs on data constructor arguments as written by the user, including
--   the source code for exact-printing.
--   
--   In the AST, the SourceText is deconstructed and hidden inside
--   <a>XBangTy</a> extension point.
data HsSrcBang
HsSrcBang :: SourceText -> HsBang -> HsSrcBang

-- | Haskell Implementation Bang
--   
--   Bangs of data constructor arguments as generated by the compiler after
--   consulting HsSrcBang, flags, etc.
data HsImplBang

-- | Lazy field, or one with an unlifted type
HsLazy :: HsImplBang

-- | Strict but not unpacked field True <a>=</a> we could have unpacked,
--   but opted not to because of -O0. See Note [Detecting useless UNPACK
--   pragmas]
HsStrict :: Bool -> HsImplBang

-- | Strict and unpacked field co :: arg-ty ~ product-ty HsBang
HsUnpack :: Maybe Coercion -> HsImplBang

-- | Source Strictness
--   
--   What strictness annotation the user wrote
data SrcStrictness

-- | Lazy, ie <tt>~</tt>
SrcLazy :: SrcStrictness

-- | Strict, ie <tt>!</tt>
SrcStrict :: SrcStrictness

-- | no strictness annotation
NoSrcStrict :: SrcStrictness

-- | Source Unpackedness
--   
--   What unpackedness the user requested
data SrcUnpackedness

-- | {-# UNPACK #-} specified
SrcUnpack :: SrcUnpackedness

-- | {-# NOUNPACK #-} specified
SrcNoUnpack :: SrcUnpackedness

-- | no unpack pragma
NoSrcUnpack :: SrcUnpackedness
getBangType :: forall (p :: Pass). LHsType (GhcPass p) -> LHsType (GhcPass p)
getBangStrictness :: forall (p :: Pass). LHsType (GhcPass p) -> HsSrcBang

-- | Constructor Declaration Field
data ConDeclField pass
ConDeclField :: XConDeclField pass -> [LFieldOcc pass] -> LBangType pass -> Maybe (LHsDoc pass) -> ConDeclField pass
[cd_fld_ext] :: ConDeclField pass -> XConDeclField pass

-- | See Note [ConDeclField pass]
[cd_fld_names] :: ConDeclField pass -> [LFieldOcc pass]
[cd_fld_type] :: ConDeclField pass -> LBangType pass
[cd_fld_doc] :: ConDeclField pass -> Maybe (LHsDoc pass)
XConDeclField :: !XXConDeclField pass -> ConDeclField pass

-- | Located Constructor Declaration Field
type LConDeclField pass = XRec pass ConDeclField pass
pprConDeclFields :: forall (p :: Pass). OutputableBndrId p => [LConDeclField (GhcPass p)] -> SDoc

-- | Describes the arguments to a data constructor. This is a common
--   representation for several constructor-related concepts, including:
--   
--   <ul>
--   <li>The arguments in a Haskell98-style constructor declaration (see
--   <tt>HsConDeclH98Details</tt> in <a>GHC.Hs.Decls</a>).</li>
--   <li>The arguments in constructor patterns in <tt>case</tt>/function
--   definitions (see <tt>HsConPatDetails</tt> in <a>GHC.Hs.Pat</a>).</li>
--   <li>The left-hand side arguments in a pattern synonym binding (see
--   <tt>HsPatSynDetails</tt> in <a>GHC.Hs.Binds</a>).</li>
--   </ul>
--   
--   One notable exception is the arguments in a GADT constructor, which
--   uses a separate data type entirely (see <tt>HsConDeclGADTDetails</tt>
--   in <a>GHC.Hs.Decls</a>). This is because GADT constructors cannot be
--   declared with infix syntax, unlike the concepts above (#18844).
data HsConDetails tyarg arg rec
PrefixCon :: [tyarg] -> [arg] -> HsConDetails tyarg arg rec
RecCon :: rec -> HsConDetails tyarg arg rec
InfixCon :: arg -> arg -> HsConDetails tyarg arg rec

-- | An empty list that can be used to indicate that there are no type
--   arguments allowed in cases where HsConDetails is applied to Void.
noTypeArgs :: [Void]

-- | Field Occurrence
--   
--   Represents an *occurrence* of a field. This may or may not be a
--   binding occurrence (e.g. this type is used in <a>ConDeclField</a> and
--   <tt>RecordPatSynField</tt> which bind their fields, but also in
--   <tt>HsRecField</tt> for record construction and patterns, which do
--   not).
--   
--   We store both the <tt>RdrName</tt> the user originally wrote, and
--   after the renamer we use the extension field to store the selector
--   function.
--   
--   There is a wrinkle in that update field occurances are sometimes
--   ambiguous during the rename stage. See note [Ambiguous FieldOcc in
--   record updates] to see how we currently handle this.
data FieldOcc pass
FieldOcc :: XCFieldOcc pass -> LIdP pass -> FieldOcc pass
[foExt] :: FieldOcc pass -> XCFieldOcc pass
[foLabel] :: FieldOcc pass -> LIdP pass
XFieldOcc :: !XXFieldOcc pass -> FieldOcc pass

-- | Located Field Occurrence
type LFieldOcc pass = XRec pass FieldOcc pass
mkFieldOcc :: LocatedN RdrName -> FieldOcc GhcPs
fieldOccRdrName :: forall (p :: Pass). IsPass p => FieldOcc (GhcPass p) -> RdrName
fieldOccLRdrName :: forall (p :: Pass). IsPass p => FieldOcc (GhcPass p) -> LocatedN RdrName

-- | Name of an operator in an operator application or section
data OpName

-- | A normal identifier
NormalOp :: Name -> OpName

-- | Prefix negation
NegateOp :: OpName

-- | An unbound identifier
UnboundOp :: RdrName -> OpName

-- | A record field occurrence
RecFldOp :: FieldOcc GhcRn -> OpName
mkAnonWildCardTy :: EpToken "_" -> HsType GhcPs
pprAnonWildCard :: SDoc
hsOuterTyVarNames :: HsOuterTyVarBndrs flag GhcRn -> [Name]
hsOuterExplicitBndrs :: forall flag (p :: Pass). HsOuterTyVarBndrs flag (GhcPass p) -> [LHsTyVarBndr flag (NoGhcTc (GhcPass p))]
mapHsOuterImplicit :: (XHsOuterImplicit pass -> XHsOuterImplicit pass) -> HsOuterTyVarBndrs flag pass -> HsOuterTyVarBndrs flag pass
mkHsOuterImplicit :: HsOuterTyVarBndrs flag GhcPs
mkHsOuterExplicit :: EpAnnForallInvis -> [LHsTyVarBndr flag GhcPs] -> HsOuterTyVarBndrs flag GhcPs
mkHsImplicitSigType :: LHsType GhcPs -> HsSigType GhcPs
mkHsExplicitSigType :: EpAnnForallInvis -> [LHsTyVarBndr Specificity GhcPs] -> LHsType GhcPs -> HsSigType GhcPs
mkHsWildCardBndrs :: thing -> HsWildCardBndrs GhcPs thing
mkHsPatSigType :: EpAnnCO -> LHsType GhcPs -> HsPatSigType GhcPs
mkHsTyPat :: LHsType GhcPs -> HsTyPat GhcPs
mkEmptyWildCardBndrs :: thing -> HsWildCardBndrs GhcRn thing
mkHsForAllVisTele :: forall (p :: Pass). EpAnnForallVis -> [LHsTyVarBndr () (GhcPass p)] -> HsForAllTelescope (GhcPass p)
mkHsForAllInvisTele :: forall (p :: Pass). EpAnnForallInvis -> [LHsTyVarBndr Specificity (GhcPass p)] -> HsForAllTelescope (GhcPass p)
mkHsQTvs :: [LHsTyVarBndr (HsBndrVis GhcPs) GhcPs] -> LHsQTyVars GhcPs
hsQTvExplicit :: LHsQTyVars pass -> [LHsTyVarBndr (HsBndrVis pass) pass]
emptyLHsQTvs :: LHsQTyVars GhcRn

-- | Does this <a>HsTyVarBndr</a> come with an explicit kind annotation?
isHsKindedTyVar :: HsTyVarBndr flag pass -> Bool

-- | Get the variable of the type variable binder
hsBndrVar :: forall flag (pass :: Pass). HsTyVarBndr flag (GhcPass pass) -> HsBndrVar (GhcPass pass)

-- | Get the kind of the type variable binder
hsBndrKind :: forall flag (pass :: Pass). HsTyVarBndr flag (GhcPass pass) -> HsBndrKind (GhcPass pass)

-- | Do all type variables in this <a>LHsQTyVars</a> come with kind
--   annotations?
hsTvbAllKinded :: forall (p :: Pass). LHsQTyVars (GhcPass p) -> Bool
hsScopedTvs :: LHsSigType GhcRn -> [Name]
hsScopedKvs :: LHsKind GhcRn -> [Name]
hsWcScopedTvs :: LHsSigWcType GhcRn -> [Name]
dropWildCards :: LHsSigWcType pass -> LHsSigType pass
hsTyVarLName :: forall flag (p :: Pass). HsTyVarBndr flag (GhcPass p) -> Maybe (LIdP (GhcPass p))
hsTyVarName :: forall flag (p :: Pass). HsTyVarBndr flag (GhcPass p) -> Maybe (IdP (GhcPass p))
hsAllLTyVarNames :: LHsQTyVars GhcRn -> [Name]
hsLTyVarLocNames :: forall (p :: Pass). Anno (IdGhcP p) ~ SrcSpanAnnN => LHsQTyVars (GhcPass p) -> [LocatedN (IdP (GhcPass p))]
hsLTyVarName :: forall flag (p :: Pass). LHsTyVarBndr flag (GhcPass p) -> Maybe (IdP (GhcPass p))
hsLTyVarNames :: forall flag (p :: Pass). [LHsTyVarBndr flag (GhcPass p)] -> [IdP (GhcPass p)]
hsForAllTelescopeNames :: forall (p :: Pass). HsForAllTelescope (GhcPass p) -> [IdP (GhcPass p)]
hsLTyVarLocName :: forall (p :: Pass) flag. Anno (IdGhcP p) ~ SrcSpanAnnN => LHsTyVarBndr flag (GhcPass p) -> Maybe (LocatedN (IdP (GhcPass p)))
hsExplicitLTyVarNames :: forall (p :: Pass). LHsQTyVars (GhcPass p) -> [IdP (GhcPass p)]

-- | Decompose a type class instance type (of the form <tt>forall
--   <a>tvs</a>. context =&gt; instance_head</tt>) into its constituent
--   parts. Note that the <tt>[Name]</tt>s returned correspond to either:
--   
--   <ul>
--   <li>The implicitly bound type variables (if the type lacks an
--   outermost <tt>forall</tt>), or</li>
--   <li>The explicitly bound type variables (if the type has an outermost
--   <tt>forall</tt>).</li>
--   </ul>
--   
--   This function is careful not to look through parentheses. See <tt>Note
--   [No nested foralls or contexts in instance types]</tt> for why this is
--   important.
splitLHsInstDeclTy :: LHsSigType GhcRn -> ([Name], Maybe (LHsContext GhcRn), LHsType GhcRn)

-- | Decompose a type class instance type (of the form <tt>forall
--   <a>tvs</a>. context =&gt; instance_head</tt>) into the
--   <tt>instance_head</tt>.
getLHsInstDeclHead :: forall (p :: Pass). LHsSigType (GhcPass p) -> LHsType (GhcPass p)

-- | Decompose a type class instance type (of the form <tt>forall
--   <a>tvs</a>. context =&gt; instance_head</tt>) into the
--   <tt>instance_head</tt> and retrieve the underlying class type
--   constructor (if it exists).
getLHsInstDeclClass_maybe :: forall (p :: Pass). Anno (IdGhcP p) ~ SrcSpanAnnN => LHsSigType (GhcPass p) -> Maybe (LocatedN (IdP (GhcPass p)))

-- | Decompose a pattern synonym type signature into its constituent parts.
--   
--   Note that this function looks through parentheses, so it will work on
--   types such as <tt>(forall a. <a>...</a>)</tt>. The downside to this is
--   that it is not generally possible to take the returned types and
--   reconstruct the original type (parentheses and all) from them.
splitLHsPatSynTy :: forall (p :: Pass). LHsSigType (GhcPass p) -> ([LHsTyVarBndr Specificity (GhcPass (NoGhcTcPass p))], Maybe (LHsContext (GhcPass p)), [LHsTyVarBndr Specificity (GhcPass p)], Maybe (LHsContext (GhcPass p)), LHsType (GhcPass p))

-- | Decompose a type of the form <tt>forall <a>tvs</a>. body</tt> into its
--   constituent parts. Only splits type variable binders that were
--   quantified invisibly (e.g., <tt>forall a.</tt>, with a dot).
--   
--   This function is used to split apart certain types, such as instance
--   declaration types, which disallow visible <tt>forall</tt>s. For
--   instance, if GHC split apart the <tt>forall</tt> in <tt>instance
--   forall a -&gt; Show (Blah a)</tt>, then that declaration would
--   mistakenly be accepted!
--   
--   Note that this function looks through parentheses, so it will work on
--   types such as <tt>(forall a. <a>...</a>)</tt>. The downside to this is
--   that it is not generally possible to take the returned types and
--   reconstruct the original type (parentheses and all) from them. Unlike
--   <a>splitLHsSigmaTyInvis</a>, this function does not look through
--   parentheses, hence the suffix <tt>_KP</tt> (short for "Keep
--   Parentheses").
splitLHsForAllTyInvis :: forall (pass :: Pass). LHsType (GhcPass pass) -> ([LHsTyVarBndr Specificity (GhcPass pass)], LHsType (GhcPass pass))

-- | Decompose a type of the form <tt>forall <a>tvs</a>. body</tt> into its
--   constituent parts. Only splits type variable binders that were
--   quantified invisibly (e.g., <tt>forall a.</tt>, with a dot).
--   
--   This function is used to split apart certain types, such as instance
--   declaration types, which disallow visible <tt>forall</tt>s. For
--   instance, if GHC split apart the <tt>forall</tt> in <tt>instance
--   forall a -&gt; Show (Blah a)</tt>, then that declaration would
--   mistakenly be accepted!
--   
--   Unlike <a>splitLHsForAllTyInvis</a>, this function does not look
--   through parentheses, hence the suffix <tt>_KP</tt> (short for "Keep
--   Parentheses").
splitLHsForAllTyInvis_KP :: forall (pass :: Pass). LHsType (GhcPass pass) -> (Maybe [LHsTyVarBndr Specificity (GhcPass pass)], LHsType (GhcPass pass))

-- | Decompose a type of the form <tt>context =&gt; body</tt> into its
--   constituent parts.
--   
--   Note that this function looks through parentheses, so it will work on
--   types such as <tt>(context =&gt; <a>...</a>)</tt>. The downside to
--   this is that it is not generally possible to take the returned types
--   and reconstruct the original type (parentheses and all) from them.
splitLHsQualTy :: forall (pass :: Pass). LHsType (GhcPass pass) -> (Maybe (LHsContext (GhcPass pass)), LHsType (GhcPass pass))

-- | Decompose a sigma type (of the form <tt>forall <a>tvs</a>. context
--   =&gt; body</tt>) into its constituent parts. Only splits type variable
--   binders that were quantified invisibly (e.g., <tt>forall a.</tt>, with
--   a dot).
--   
--   This function is used to split apart certain types, such as instance
--   declaration types, which disallow visible <tt>forall</tt>s. For
--   instance, if GHC split apart the <tt>forall</tt> in <tt>instance
--   forall a -&gt; Show (Blah a)</tt>, then that declaration would
--   mistakenly be accepted!
--   
--   Note that this function looks through parentheses, so it will work on
--   types such as <tt>(forall a. <a>...</a>)</tt>. The downside to this is
--   that it is not generally possible to take the returned types and
--   reconstruct the original type (parentheses and all) from them.
splitLHsSigmaTyInvis :: forall (p :: Pass). LHsType (GhcPass p) -> ([LHsTyVarBndr Specificity (GhcPass p)], Maybe (LHsContext (GhcPass p)), LHsType (GhcPass p))

-- | Decompose a GADT type into its constituent parts. Returns
--   <tt>(outer_bndrs, mb_ctxt, body)</tt>, where:
--   
--   <ul>
--   <li><tt>outer_bndrs</tt> are <a>HsOuterExplicit</a> if the type has
--   explicit, outermost type variable binders. Otherwise, they are
--   <a>HsOuterImplicit</a>.</li>
--   <li><tt>mb_ctxt</tt> is <tt>Just</tt> the context, if it is provided.
--   Otherwise, it is <tt>Nothing</tt>.</li>
--   <li><tt>body</tt> is the body of the type after the optional
--   <tt>forall</tt>s and context.</li>
--   </ul>
--   
--   This function is careful not to look through parentheses. See <tt>Note
--   [GADT abstract syntax] (Wrinkle: No nested foralls or contexts)</tt>
--   <a>GHC.Hs.Decls</a> for why this is important.
splitLHsGadtTy :: LHsSigType GhcPs -> (HsOuterSigTyVarBndrs GhcPs, Maybe (LHsContext GhcPs), LHsType GhcPs)
splitHsFunType :: forall (p :: Pass). LHsType (GhcPass p) -> (([EpToken "("], [EpToken ")"]), EpAnnComments, [HsScaled (GhcPass p) (LHsType (GhcPass p))], LHsType (GhcPass p))

-- | Retrieve the name of the "head" of a nested type application. This is
--   somewhat like <tt>GHC.Tc.Gen.HsType.splitHsAppTys</tt>, but a little
--   more thorough. The purpose of this function is to examine instance
--   heads, so it doesn't handle *all* cases (like lists, tuples,
--   <tt>(~)</tt>, etc.).
hsTyGetAppHead_maybe :: forall (p :: Pass). Anno (IdGhcP p) ~ SrcSpanAnnN => LHsType (GhcPass p) -> Maybe (LocatedN (IdP (GhcPass p)))
mkHsOpTy :: forall (p :: Pass). Anno (IdGhcP p) ~ SrcSpanAnnN => PromotionFlag -> LHsType (GhcPass p) -> LocatedN (IdP (GhcPass p)) -> LHsType (GhcPass p) -> HsType (GhcPass p)
mkHsAppTy :: forall (p :: Pass). LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)
mkHsAppTys :: forall (p :: Pass). LHsType (GhcPass p) -> [LHsType (GhcPass p)] -> LHsType (GhcPass p)
mkHsAppKindTy :: forall (p :: Pass). XAppKindTy (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)
ignoreParens :: forall (p :: Pass). LHsType (GhcPass p) -> LHsType (GhcPass p)
hsSigWcType :: UnXRec p => LHsSigWcType p -> LHsType p
hsPatSigType :: HsPatSigType pass -> LHsType pass

-- | Get the kind signature of a type, ignoring parentheses:
--   
--   hsTyKindSig `Maybe ` = Nothing hsTyKindSig `Maybe :: Type -&gt; Type `
--   = Just `Type -&gt; Type` hsTyKindSig `Maybe :: ((Type -&gt; Type))` =
--   Just `Type -&gt; Type`
--   
--   This is used to extract the result kind of type synonyms with a CUSK:
--   
--   type S = (F :: res_kind) ^^^^^^^^
hsTyKindSig :: forall (p :: Pass). LHsType (GhcPass p) -> Maybe (LHsKind (GhcPass p))

-- | Set the attached flag
setHsTyVarBndrFlag :: forall flag flag' (pass :: Pass). flag -> HsTyVarBndr flag' (GhcPass pass) -> HsTyVarBndr flag (GhcPass pass)

-- | Return the attached flag
hsTyVarBndrFlag :: forall flag (pass :: Pass). HsTyVarBndr flag (GhcPass pass) -> flag

-- | Update the attached flag
updateHsTyVarBndrFlag :: forall flag flag' (pass :: Pass). (flag -> flag') -> HsTyVarBndr flag (GhcPass pass) -> HsTyVarBndr flag' (GhcPass pass)
pprHsType :: forall (p :: Pass). OutputableBndrId p => HsType (GhcPass p) -> SDoc

-- | Prints a forall; When passed an empty list, prints <tt>forall
--   .</tt>/<tt>forall -&gt;</tt> only when <tt>-dppr-debug</tt> is
--   enabled.
pprHsForAll :: forall (p :: Pass). OutputableBndrId p => HsForAllTelescope (GhcPass p) -> Maybe (LHsContext (GhcPass p)) -> SDoc

-- | Prints the explicit <tt>forall</tt> in a type family equation if one
--   is written. If there is no explicit <tt>forall</tt>, nothing is
--   printed.
pprHsOuterFamEqnTyVarBndrs :: forall (p :: Pass). OutputableBndrId p => HsOuterFamEqnTyVarBndrs (GhcPass p) -> SDoc

-- | Prints the outermost <tt>forall</tt> in a type signature if one is
--   written. If there is no outermost <tt>forall</tt>, nothing is printed.
pprHsOuterSigTyVarBndrs :: forall (p :: Pass). OutputableBndrId p => HsOuterSigTyVarBndrs (GhcPass p) -> SDoc
pprLHsContext :: forall (p :: Pass). OutputableBndrId p => Maybe (LHsContext (GhcPass p)) -> SDoc

-- | <tt><a>hsTypeNeedsParens</a> p t</tt> returns <a>True</a> if the type
--   <tt>t</tt> needs parentheses under precedence <tt>p</tt>.
hsTypeNeedsParens :: forall (p :: Pass). PprPrec -> HsType (GhcPass p) -> Bool

-- | <tt><a>parenthesizeHsType</a> p ty</tt> checks if
--   <tt><a>hsTypeNeedsParens</a> p ty</tt> is true, and if so, surrounds
--   <tt>ty</tt> with an <a>HsParTy</a>. Otherwise, it simply returns
--   <tt>ty</tt>.
parenthesizeHsType :: forall (p :: Pass). PprPrec -> LHsType (GhcPass p) -> LHsType (GhcPass p)

-- | <tt><a>parenthesizeHsContext</a> p ctxt</tt> checks if <tt>ctxt</tt>
--   is a single constraint <tt>c</tt> such that
--   <tt><a>hsTypeNeedsParens</a> p c</tt> is true, and if so, surrounds
--   <tt>c</tt> with an <a>HsParTy</a> to form a parenthesized
--   <tt>ctxt</tt>. Otherwise, it simply returns <tt>ctxt</tt> unchanged.
parenthesizeHsContext :: forall (p :: Pass). PprPrec -> LHsContext (GhcPass p) -> LHsContext (GhcPass p)
instance GHC.Internal.Data.Data.Data GHC.Hs.Type.AnnTyVarBndr
instance GHC.Internal.Data.Data.Data GHC.Hs.Type.EpLinearArrow
instance GHC.Internal.Data.Data.Data GHC.Hs.Type.HsPSRn
instance GHC.Internal.Data.Data.Data GHC.Hs.Type.HsTyPatRn
instance GHC.Internal.Base.Monoid GHC.Hs.Type.HsTyPatRnBuilder
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Type.AnnTyVarBndr
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Type.EpLinearArrow
instance GHC.Hs.Type.OutputableBndrFlag (Language.Haskell.Syntax.Type.HsBndrVis (GHC.Hs.Extension.GhcPass p')) p
instance GHC.Hs.Type.OutputableBndrFlag Language.Haskell.Syntax.Specificity.Specificity p
instance GHC.Hs.Type.OutputableBndrFlag () p
instance GHC.Hs.Extension.OutputableBndrId pass => GHC.Utils.Outputable.OutputableBndr (Language.Haskell.Syntax.Type.FieldOcc (GHC.Hs.Extension.GhcPass pass))
instance GHC.Hs.Extension.OutputableBndrId pass => GHC.Utils.Outputable.OutputableBndr (GHC.Types.SrcLoc.GenLocated GHC.Types.SrcLoc.SrcSpan (Language.Haskell.Syntax.Type.FieldOcc (GHC.Hs.Extension.GhcPass pass)))
instance GHC.Utils.Outputable.OutputableBndr Language.Haskell.Syntax.Type.HsIPName
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.ConDeclField (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Extension.XRec pass (Language.Haskell.Syntax.Extension.IdP pass)) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.FieldOcc pass)
instance (GHC.Utils.Outputable.Outputable tm, GHC.Utils.Outputable.Outputable ty) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsArg (GHC.Hs.Extension.GhcPass p) tm ty)
instance (GHC.Utils.Outputable.Outputable mult, GHC.Hs.Extension.OutputableBndrId pass) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsArrowOf mult (GHC.Hs.Extension.GhcPass pass))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsBndrVar (GHC.Hs.Extension.GhcPass p))
instance (GHC.Utils.Outputable.Outputable tyarg, GHC.Utils.Outputable.Outputable arg, GHC.Utils.Outputable.Outputable rec) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsConDetails tyarg arg rec)
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsForAllTelescope (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Type.HsIPName
instance (GHC.Hs.Type.OutputableBndrFlag flag p, GHC.Hs.Type.OutputableBndrFlag flag (GHC.Hs.Extension.NoGhcTcPass p), GHC.Hs.Extension.OutputableBndrId p) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsOuterTyVarBndrs flag (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsPatSigType (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsSigType (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsTyLit (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsTyPat (GHC.Hs.Extension.GhcPass p))
instance (GHC.Hs.Extension.OutputableBndrId p, GHC.Hs.Type.OutputableBndrFlag flag p) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsTyVarBndr flag (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsType (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable thing => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsWildCardBndrs (GHC.Hs.Extension.GhcPass p) thing)
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.LHsQTyVars (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable GHC.Hs.Type.OpName
instance GHC.Internal.Base.Semigroup GHC.Hs.Type.HsTyPatRnBuilder


-- | A module concerned with finding the free variables of an expression.
module GHC.Core.FVs

-- | Find all locally-defined free Ids or type variables in an expression
--   returning a non-deterministic set.
exprFreeVars :: CoreExpr -> VarSet

-- | Find all locally-defined free Ids or type variables in several
--   expressions returning a non-deterministic set.
exprsFreeVars :: [CoreExpr] -> VarSet

-- | Find all locally-defined free Ids or type variables in an expression
--   returning a deterministic set.
exprFreeVarsDSet :: CoreExpr -> DVarSet

-- | Find all locally-defined free Ids or type variables in an expression
--   returning a deterministically ordered list.
exprFreeVarsList :: CoreExpr -> [Var]

-- | Find all locally-defined free Ids or type variables in several
--   expressions returning a deterministically ordered list.
exprsFreeVarsList :: [CoreExpr] -> [Var]

-- | Find all locally-defined free Ids in an expression
exprFreeIds :: CoreExpr -> IdSet
exprsFreeIds :: [CoreExpr] -> IdSet

-- | Find all locally-defined free Ids in an expression returning a
--   deterministic set.
exprFreeIdsDSet :: CoreExpr -> DIdSet

-- | Find all locally-defined free Ids in several expressions returning a
--   deterministic set.
exprsFreeIdsDSet :: [CoreExpr] -> DIdSet

-- | Find all locally-defined free Ids in an expression returning a
--   deterministically ordered list.
exprFreeIdsList :: CoreExpr -> [Id]

-- | Find all locally-defined free Ids in several expressions returning a
--   deterministically ordered list.
exprsFreeIdsList :: [CoreExpr] -> [Id]

-- | Find all locally defined free Ids in a binding group
bindFreeVars :: CoreBind -> VarSet

-- | Predicate on possible free variables: returns <tt>True</tt> iff the
--   variable is interesting
type InterestingVarFun = Var -> Bool

-- | Finds free variables in an expression selected by a predicate
exprSomeFreeVars :: InterestingVarFun -> CoreExpr -> VarSet

-- | Finds free variables in several expressions selected by a predicate
exprsSomeFreeVars :: InterestingVarFun -> [CoreExpr] -> VarSet

-- | Finds free variables in an expression selected by a predicate
--   returning a deterministically ordered list.
exprSomeFreeVarsList :: InterestingVarFun -> CoreExpr -> [Var]

-- | Finds free variables in several expressions selected by a predicate
--   returning a deterministically ordered list.
exprsSomeFreeVarsList :: InterestingVarFun -> [CoreExpr] -> [Var]
varTypeTyCoVars :: Var -> TyCoVarSet
varTypeTyCoFVs :: Var -> FV
idUnfoldingVars :: Id -> VarSet
idFreeVars :: Id -> VarSet
dIdFreeVars :: Id -> DVarSet
bndrRuleAndUnfoldingVarsDSet :: Id -> DVarSet
bndrRuleAndUnfoldingIds :: Id -> IdSet
idFVs :: Id -> FV
idRuleVars :: Id -> VarSet
stableUnfoldingVars :: Unfolding -> Maybe VarSet

-- | Those variables free in the both the left right hand sides of a rule
--   returned as a non-deterministic set
ruleFreeVars :: CoreRule -> VarSet

-- | Those variables free in both the left right hand sides of several
--   rules
rulesFreeVars :: [CoreRule] -> VarSet

-- | Those variables free in the both the left right hand sides of rules
--   returned as a deterministic set
rulesFreeVarsDSet :: [CoreRule] -> DVarSet

-- | Make a <a>RuleInfo</a> containing a number of <a>CoreRule</a>s,
--   suitable for putting into an <a>IdInfo</a>
mkRuleInfo :: [CoreRule] -> RuleInfo

-- | This finds all locally-defined free Ids on the left hand side of a
--   rule and returns them as a non-deterministic set
ruleLhsFreeIds :: CoreRule -> VarSet

-- | This finds all locally-defined free Ids on the left hand side of a
--   rule and returns them as a deterministically ordered list
ruleLhsFreeIdsList :: CoreRule -> [Var]

-- | Those variables free in the right hand side of a rule returned as a
--   non-deterministic set
ruleRhsFreeVars :: CoreRule -> VarSet

-- | Those locally-defined free <a>Id</a>s in the right hand side of
--   several rules returned as a non-deterministic set
rulesRhsFreeIds :: [CoreRule] -> VarSet

-- | Find all locally-defined free Ids or type variables in an expression
--   returning a composable FV computation. See Note [FV naming
--   conventions] in <a>GHC.Utils.FV</a> for why export it.
exprFVs :: CoreExpr -> FV
orphNamesOfType :: Type -> NameSet
orphNamesOfTypes :: [Type] -> NameSet

-- | <a>orphNamesOfAxiomLHS</a> collects the names of the concrete types
--   and type constructors that make up the LHS of a type family instance,
--   including the family name itself.
--   
--   For instance, given `type family Foo a b`: `type instance Foo (F (G (H
--   a))) b = ...` would yield [Foo,F,G,H]
--   
--   Used (via orphNamesOfFamInst) in the implementation of ":info" in
--   GHCi. and when determining orphan-hood for a FamInst or module
orphNamesOfAxiomLHS :: forall (br :: BranchFlag). CoAxiom br -> NameSet

-- | Finds the free <i>external</i> names of several expressions: see
--   <tt>exprOrphNames</tt> for details
orphNamesOfExprs :: [CoreExpr] -> NameSet
type FVAnn = DVarSet

-- | Every node in an expression annotated with its (non-global) free
--   variables, both Ids and TyVars, and type. NB: see Note [The FVAnn
--   invariant]
type CoreExprWithFVs = AnnExpr Id FVAnn
type CoreExprWithFVs' = AnnExpr' Id FVAnn

-- | Every node in a binding group annotated with its (non-global) free
--   variables, both Ids and TyVars, and type.
type CoreBindWithFVs = AnnBind Id FVAnn

-- | Every node in an expression annotated with its (non-global) free
--   variables, both Ids and TyVars, and type.
type CoreAltWithFVs = AnnAlt Id FVAnn

-- | Annotate a <a>CoreExpr</a> with its (non-global) free type and value
--   variables at every tree node.
freeVars :: CoreExpr -> CoreExprWithFVs
freeVarsBind :: CoreBind -> DVarSet -> (CoreBindWithFVs, DVarSet)

-- | Inverse function to <a>freeVars</a>
freeVarsOf :: CoreExprWithFVs -> DIdSet

-- | Extract the vars reported in a FVAnn
freeVarsOfAnn :: FVAnn -> DIdSet

module GHC.Core.InstEnv

-- | Dictionary Function Identifier
type DFunId = Id
type InstMatch = (ClsInst, [DFunInstType])
type ClsInstLookupResult = ([InstMatch], PotentialUnifiers, [InstMatch])

-- | <a>CanonicalEvidence</a> says whether a piece of evidence has a
--   singleton type; For example, given (d1 :: C Int), will any other (d2
--   :: C Int) do equally well? See Note [Coherence and specialisation:
--   overview] above, and Note [Desugaring non-canonical evidence] in
--   GHC.HsToCore.Binds
data CanonicalEvidence
EvCanonical :: CanonicalEvidence
EvNonCanonical :: CanonicalEvidence
data PotentialUnifiers
NoUnifiers :: CanonicalEvidence -> PotentialUnifiers
OneOrMoreUnifiers :: NonEmpty ClsInst -> PotentialUnifiers
getCoherentUnifiers :: PotentialUnifiers -> [ClsInst]
nullUnifiers :: PotentialUnifiers -> Bool

-- | The semantics allowed for overlapping instances for a particular
--   instance. See Note [Safe Haskell isSafeOverlap] in GHC.Core.InstEnv
--   for a explanation of the <a>isSafeOverlap</a> field.
data OverlapFlag
OverlapFlag :: OverlapMode -> Bool -> OverlapFlag
[overlapMode] :: OverlapFlag -> OverlapMode
[isSafeOverlap] :: OverlapFlag -> Bool
data OverlapMode

-- | This instance must not overlap another <a>NoOverlap</a> instance.
--   However, it may be overlapped by <a>Overlapping</a> instances, and it
--   may overlap <a>Overlappable</a> instances.
NoOverlap :: SourceText -> OverlapMode

-- | Silently ignore this instance if you find a more specific one that
--   matches the constraint you are trying to resolve
--   
--   Example: constraint (Foo [Int]) instance Foo [Int] instance {-#
--   OVERLAPPABLE #-} Foo [a]
--   
--   Since the second instance has the Overlappable flag, the first
--   instance will be chosen (otherwise its ambiguous which to choose)
Overlappable :: SourceText -> OverlapMode

-- | Silently ignore any more general instances that may be used to solve
--   the constraint.
--   
--   Example: constraint (Foo [Int]) instance {-# OVERLAPPING #-} Foo [Int]
--   instance Foo [a]
--   
--   Since the first instance has the Overlapping flag, the second---more
--   general---instance will be ignored (otherwise it is ambiguous which to
--   choose)
Overlapping :: SourceText -> OverlapMode

-- | Equivalent to having both <a>Overlapping</a> and <a>Overlappable</a>
--   flags.
Overlaps :: SourceText -> OverlapMode

-- | Behave like Overlappable and Overlapping, and in addition pick an
--   arbitrary one if there are multiple matching candidates, and don't
--   worry about later instantiation
--   
--   Example: constraint (Foo [b]) instance {-# INCOHERENT -} Foo [Int]
--   instance Foo [a] Without the Incoherent flag, we'd complain that
--   instantiating <tt>b</tt> would change which instance was chosen. See
--   also Note [Incoherent instances] in <a>GHC.Core.InstEnv</a>
Incoherent :: SourceText -> OverlapMode

-- | Behave like Incoherent, but the instance choice is observable by the
--   program behaviour. See Note [Coherence and specialisation: overview].
--   
--   We don't have surface syntax for the distinction between Incoherent
--   and NonCanonical instances; instead, the flag
--   `-f{no-}specialise-incoherents` (on by default) controls whether
--   <tt>INCOHERENT</tt> instances are regarded as Incoherent or
--   NonCanonical.
NonCanonical :: SourceText -> OverlapMode
setOverlapModeMaybe :: OverlapFlag -> Maybe OverlapMode -> OverlapFlag

-- | A type-class instance. Note that there is some tricky laziness at work
--   here. See Note [ClsInst laziness and the rough-match fields] for more
--   details.
data ClsInst
ClsInst :: Name -> [RoughMatchTc] -> Name -> [TyVar] -> Class -> [Type] -> DFunId -> OverlapFlag -> IsOrphan -> Maybe (WarningTxt GhcRn) -> ClsInst

-- | Class name
[is_cls_nm] :: ClsInst -> Name

-- | Top of type args The class itself is always the first element of this
--   list
[is_tcs] :: ClsInst -> [RoughMatchTc]

-- | <tt>is_dfun_name = idName . is_dfun</tt>.
--   
--   We use <a>is_dfun_name</a> for the visibility check,
--   <a>instIsVisible</a>, which needs to know the <a>Module</a> which the
--   dictionary is defined in. However, we cannot use the <a>Module</a>
--   attached to <a>is_dfun</a> since doing so would mean we would
--   potentially pull in an entire interface file unnecessarily. This was
--   the cause of #12367.
[is_dfun_name] :: ClsInst -> Name
[is_tvs] :: ClsInst -> [TyVar]
[is_cls] :: ClsInst -> Class
[is_tys] :: ClsInst -> [Type]
[is_dfun] :: ClsInst -> DFunId
[is_flag] :: ClsInst -> OverlapFlag
[is_orphan] :: ClsInst -> IsOrphan
[is_warn] :: ClsInst -> Maybe (WarningTxt GhcRn)
type DFunInstType = Maybe Type
pprInstance :: ClsInst -> SDoc
pprInstanceHdr :: ClsInst -> SDoc
pprDFunId :: DFunId -> SDoc
pprInstances :: [ClsInst] -> SDoc
instanceWarning :: ClsInst -> Maybe (WarningTxt GhcRn)
instanceHead :: ClsInst -> ([TyVar], Class, [Type])
instanceSig :: ClsInst -> ([TyVar], [Type], Class, [Type])
mkLocalClsInst :: DFunId -> OverlapFlag -> [TyVar] -> Class -> [Type] -> Maybe (WarningTxt GhcRn) -> ClsInst
mkImportedClsInst :: Name -> [RoughMatchTc] -> Name -> DFunId -> OverlapFlag -> IsOrphan -> Maybe (WarningTxt GhcRn) -> ClsInst
instanceDFunId :: ClsInst -> DFunId
updateClsInstDFuns :: (DFunId -> DFunId) -> InstEnv -> InstEnv
updateClsInstDFun :: (DFunId -> DFunId) -> ClsInst -> ClsInst

-- | A fuzzy comparison function for class instances, intended for sorting
--   instances before displaying them to the user.
fuzzyClsInstCmp :: ClsInst -> ClsInst -> Ordering

-- | Collects the names of concrete types and type constructors that make
--   up the head of a class instance. For instance, given `class Foo a b`:
--   
--   `instance Foo (Either (Maybe Int) a) Bool` would yield [Either, Maybe,
--   Int, Bool]
--   
--   Used in the implementation of ":info" in GHCi.
--   
--   The <a>tcSplitSigmaTy</a> is because of instance Foo a =&gt; Baz T
--   where ... The decl is an orphan if Baz and T are both not locally
--   defined, even if Foo *is* locally defined
orphNamesOfClsInst :: ClsInst -> NameSet

-- | <a>InstEnvs</a> represents the combination of the global type class
--   instance environment, the local type class instance environment, and
--   the set of transitively reachable orphan modules (according to what
--   modules have been directly imported) used to test orphan instance
--   visibility.
data InstEnvs
InstEnvs :: InstEnv -> InstEnv -> VisibleOrphanModules -> InstEnvs
[ie_global] :: InstEnvs -> InstEnv
[ie_local] :: InstEnvs -> InstEnv
[ie_visible] :: InstEnvs -> VisibleOrphanModules

-- | Set of visible orphan modules, according to what modules have been
--   directly imported. This is based off of the dep_orphs field, which
--   records transitively reachable orphan modules (modules that define
--   orphan instances).
type VisibleOrphanModules = ModuleSet
data InstEnv

-- | Why a particular typeclass application couldn't be looked up.
data LookupInstanceErrReason

-- | Tyvars aren't an exact match.
LookupInstErrNotExact :: LookupInstanceErrReason

-- | One of the tyvars is flexible.
LookupInstErrFlexiVar :: LookupInstanceErrReason

-- | No matching instance was found.
LookupInstErrNotFound :: LookupInstanceErrReason
mkInstEnv :: [ClsInst] -> InstEnv
emptyInstEnv :: InstEnv

-- | Makes no particular effort to detect conflicts.
unionInstEnv :: InstEnv -> InstEnv -> InstEnv
extendInstEnv :: InstEnv -> ClsInst -> InstEnv
filterInstEnv :: (ClsInst -> Bool) -> InstEnv -> InstEnv
deleteFromInstEnv :: InstEnv -> ClsInst -> InstEnv
deleteDFunFromInstEnv :: InstEnv -> DFunId -> InstEnv
anyInstEnv :: (ClsInst -> Bool) -> InstEnv -> Bool

-- | True when when the instance heads are the same e.g. both are Eq
--   [(a,b)] Used for overriding in GHCi Obviously should be insensitive to
--   alpha-renaming
identicalClsInstHead :: ClsInst -> ClsInst -> Bool
extendInstEnvList :: InstEnv -> [ClsInst] -> InstEnv

-- | Look up an instance in the given instance environment. The given class
--   application must match exactly one instance and the match may not
--   contain any flexi type variables. If the lookup is unsuccessful, yield
--   'Left errorMessage'.
lookupUniqueInstEnv :: InstEnvs -> Class -> [Type] -> Either LookupInstanceErrReason (ClsInst, [Type])

-- | See Note [Rules for instance lookup] ^ See Note [Safe Haskell
--   Overlapping Instances] in <a>GHC.Tc.Solver</a> ^ See Note [Safe
--   Haskell Overlapping Instances Implementation] in <a>GHC.Tc.Solver</a>
lookupInstEnv :: Bool -> InstEnvs -> Class -> [Type] -> ClsInstLookupResult
instEnvElts :: InstEnv -> [ClsInst]
instEnvClasses :: InstEnv -> UniqDSet Class
mapInstEnv :: (ClsInst -> ClsInst) -> InstEnv -> InstEnv

-- | Checks for an exact match of ClsInst in the instance environment. We
--   use this when we do signature checking in <a>GHC.Tc.Module</a>
memberInstEnv :: InstEnv -> ClsInst -> Bool

-- | Test if an instance is visible, by checking that its origin module is
--   in <a>VisibleOrphanModules</a>. See Note [Instance lookup and orphan
--   instances]
instIsVisible :: VisibleOrphanModules -> ClsInst -> Bool
classInstances :: InstEnvs -> Class -> [ClsInst]
instanceBindFun :: BindFun
classNameInstances :: InstEnvs -> Name -> [ClsInst]
instanceCantMatch :: [RoughMatchTc] -> [RoughMatchTc] -> Bool
roughMatchTcs :: [Type] -> [RoughMatchTc]
isOverlappable :: ClsInst -> Bool
isOverlapping :: ClsInst -> Bool
isIncoherent :: ClsInst -> Bool
instance GHC.Internal.Data.Data.Data GHC.Core.InstEnv.ClsInst
instance GHC.Internal.Generics.Generic GHC.Core.InstEnv.LookupInstanceErrReason
instance GHC.Types.Name.NamedThing GHC.Core.InstEnv.ClsInst
instance GHC.Utils.Outputable.Outputable GHC.Core.InstEnv.CanonicalEvidence
instance GHC.Utils.Outputable.Outputable GHC.Core.InstEnv.ClsInst
instance GHC.Utils.Outputable.Outputable GHC.Core.InstEnv.InstEnv
instance GHC.Utils.Outputable.Outputable GHC.Core.InstEnv.InstMatches
instance GHC.Utils.Outputable.Outputable GHC.Core.InstEnv.PotentialUnifiers
instance GHC.Internal.Base.Semigroup GHC.Core.InstEnv.PotentialUnifiers

module GHC.Tc.Types.Evidence
data HsWrapper
WpHole :: HsWrapper
WpCompose :: HsWrapper -> HsWrapper -> HsWrapper
WpFun :: HsWrapper -> HsWrapper -> Scaled TcTypeFRR -> HsWrapper
WpCast :: TcCoercionR -> HsWrapper
WpEvLam :: EvVar -> HsWrapper
WpEvApp :: EvTerm -> HsWrapper
WpTyLam :: TyVar -> HsWrapper
WpTyApp :: KindOrType -> HsWrapper
WpLet :: TcEvBinds -> HsWrapper
WpMultCoercion :: Coercion -> HsWrapper
(<.>) :: HsWrapper -> HsWrapper -> HsWrapper
mkWpTyApps :: [Type] -> HsWrapper
mkWpEvApps :: [EvTerm] -> HsWrapper
mkWpEvVarApps :: [EvVar] -> HsWrapper
mkWpTyLams :: [TyVar] -> HsWrapper
mkWpForAllCast :: [ForAllTyBinder] -> Type -> HsWrapper
mkWpEvLams :: [Var] -> HsWrapper
mkWpLet :: TcEvBinds -> HsWrapper

-- | Smart constructor to create a <a>WpFun</a> <a>HsWrapper</a>.
--   
--   PRECONDITION: the "from" type of the first wrapper must have a
--   syntactically fixed RuntimeRep (see Note [Fixed RuntimeRep] in
--   GHC.Tc.Utils.Concrete).
mkWpFun :: HsWrapper -> HsWrapper -> Scaled TcTypeFRR -> TcType -> HsWrapper
mkWpCastN :: TcCoercionN -> HsWrapper
mkWpCastR :: TcCoercionR -> HsWrapper
mkWpEta :: [Id] -> HsWrapper -> HsWrapper
collectHsWrapBinders :: HsWrapper -> ([Var], HsWrapper)
idHsWrapper :: HsWrapper
isIdHsWrapper :: HsWrapper -> Bool
pprHsWrapper :: HsWrapper -> (Bool -> SDoc) -> SDoc

-- | Identifies the <i>lambda-bound</i> dictionaries of an
--   <a>HsWrapper</a>. This is used (only) to allow the pattern-match
--   overlap checker to know what Given dictionaries are in scope.
--   
--   We specifically do not collect dictionaries bound in a <a>WpLet</a>.
--   These are either superclasses of lambda-bound ones, or (extremely
--   numerous) results of binding Wanted dictionaries. We definitely don't
--   want all those cluttering up the Given dictionaries for pattern-match
--   overlap checking!
hsWrapDictBinders :: HsWrapper -> Bag DictId
data TcEvBinds
TcEvBinds :: EvBindsVar -> TcEvBinds
EvBinds :: Bag EvBind -> TcEvBinds
data EvBindsVar
EvBindsVar :: Unique -> IORef EvBindMap -> IORef CoVarSet -> EvBindsVar
[ebv_uniq] :: EvBindsVar -> Unique
[ebv_binds] :: EvBindsVar -> IORef EvBindMap
[ebv_tcvs] :: EvBindsVar -> IORef CoVarSet
CoEvBindsVar :: Unique -> IORef CoVarSet -> EvBindsVar
[ebv_uniq] :: EvBindsVar -> Unique
[ebv_tcvs] :: EvBindsVar -> IORef CoVarSet
newtype EvBindMap
EvBindMap :: DVarEnv EvBind -> EvBindMap
[ev_bind_varenv] :: EvBindMap -> DVarEnv EvBind
emptyEvBindMap :: EvBindMap
extendEvBinds :: EvBindMap -> EvBind -> EvBindMap
lookupEvBind :: EvBindMap -> EvVar -> Maybe EvBind
evBindMapBinds :: EvBindMap -> Bag EvBind
foldEvBindMap :: (EvBind -> a -> a) -> a -> EvBindMap -> a
nonDetStrictFoldEvBindMap :: (EvBind -> a -> a) -> a -> EvBindMap -> a
filterEvBindMap :: (EvBind -> Bool) -> EvBindMap -> EvBindMap
isEmptyEvBindMap :: EvBindMap -> Bool
evBindMapToVarSet :: EvBindMap -> VarSet
varSetMinusEvBindMap :: VarSet -> EvBindMap -> VarSet
data EvBindInfo
EvBindGiven :: EvBindInfo
EvBindWanted :: CanonicalEvidence -> EvBindInfo
[ebi_canonical] :: EvBindInfo -> CanonicalEvidence
data EvBind
EvBind :: EvVar -> EvTerm -> EvBindInfo -> EvBind
[eb_lhs] :: EvBind -> EvVar
[eb_rhs] :: EvBind -> EvTerm
[eb_info] :: EvBind -> EvBindInfo
emptyTcEvBinds :: TcEvBinds
isEmptyTcEvBinds :: TcEvBinds -> Bool
mkGivenEvBind :: EvVar -> EvTerm -> EvBind
mkWantedEvBind :: EvVar -> CanonicalEvidence -> EvTerm -> EvBind
evBindVar :: EvBind -> EvVar
isCoEvBindsVar :: EvBindsVar -> Bool
data EvTerm
EvExpr :: EvExpr -> EvTerm
EvTypeable :: Type -> EvTypeable -> EvTerm
EvFun :: [TyVar] -> [EvVar] -> TcEvBinds -> EvVar -> EvTerm
[et_tvs] :: EvTerm -> [TyVar]
[et_given] :: EvTerm -> [EvVar]
[et_binds] :: EvTerm -> TcEvBinds
[et_body] :: EvTerm -> EvVar
type EvExpr = CoreExpr

-- | Any sort of evidence Id, including coercions
evId :: EvId -> EvExpr
evCoercion :: TcCoercion -> EvTerm

-- | d |&gt; co
evCast :: EvExpr -> TcCoercion -> EvTerm
evDFunApp :: DFunId -> [Type] -> [EvExpr] -> EvTerm
evDataConApp :: DataCon -> [Type] -> [EvExpr] -> EvTerm
evSelector :: Id -> [Type] -> [EvExpr] -> EvExpr
mkEvCast :: EvExpr -> TcCoercion -> EvTerm
evVarsOfTerm :: EvTerm -> VarSet
mkEvScSelectors :: Class -> [TcType] -> [(TcPredType, EvExpr)]
evTypeable :: Type -> EvTypeable -> EvTerm
findNeededEvVars :: EvBindMap -> VarSet -> VarSet
evTermCoercion :: EvTerm -> TcCoercion
evTermCoercion_maybe :: EvTerm -> Maybe TcCoercion

-- | Evidence for <tt>CallStack</tt> implicit parameters.
data EvCallStack
EvCsEmpty :: EvCallStack

-- | <tt>EvCsPushCall origin loc stk</tt> represents a call from
--   <tt>origin</tt>, occurring at <tt>loc</tt>, in a calling context
--   <tt>stk</tt>.
EvCsPushCall :: FastString -> RealSrcSpan -> EvExpr -> EvCallStack

-- | Instructions on how to make a <tt>Typeable</tt> dictionary. See Note
--   [Typeable evidence terms]
data EvTypeable

-- | Dictionary for <tt>Typeable T</tt> where <tt>T</tt> is a type
--   constructor with all of its kind variables saturated. The
--   <tt>[EvTerm]</tt> is <tt>Typeable</tt> evidence for the applied
--   kinds..
EvTypeableTyCon :: TyCon -> [EvTerm] -> EvTypeable

-- | Dictionary for <tt>Typeable (s t)</tt>, given a dictionaries for
--   <tt>s</tt> and <tt>t</tt>.
EvTypeableTyApp :: EvTerm -> EvTerm -> EvTypeable

-- | Dictionary for <tt>Typeable (s % w -&gt; t)</tt>, given a dictionaries
--   for <tt>w</tt>, <tt>s</tt>, and <tt>t</tt>.
EvTypeableTrFun :: EvTerm -> EvTerm -> EvTerm -> EvTypeable

-- | Dictionary for a type literal, e.g. <tt>Typeable "foo"</tt> or
--   <tt>Typeable 3</tt> The <a>EvTerm</a> is evidence of, e.g.,
--   <tt>KnownNat 3</tt> (see #10348)
EvTypeableTyLit :: EvTerm -> EvTypeable

-- | Where to store evidence for expression holes See Note [Holes] in
--   GHC.Tc.Types.Constraint
data HoleExprRef
HER :: IORef EvTerm -> TcType -> Unique -> HoleExprRef
type TcCoercion = Coercion
type TcCoercionR = CoercionR
type TcCoercionN = CoercionN
type TcCoercionP = CoercionP

-- | A coercion to be filled in by the type-checker. See Note [Coercion
--   holes]
data CoercionHole
type TcMCoercion = MCoercion
type TcMCoercionN = MCoercionN
type TcMCoercionR = MCoercionR
type MultiplicityCheckCoercions = [TcCoercion]

-- | See Note [Roles] in GHC.Core.Coercion
--   
--   Order of constructors matters: the Ord instance coincides with the
--   *super*typing relation on roles.
data Role
Nominal :: Role
Representational :: Role
Phantom :: Role
data LeftOrRight
CLeft :: LeftOrRight
CRight :: LeftOrRight
pickLR :: LeftOrRight -> (a, a) -> a

-- | If a <a>SwapFlag</a> is <a>IsSwapped</a>, flip the orientation of a
--   coercion
maybeSymCo :: SwapFlag -> TcCoercion -> TcCoercion

-- | Create a <a>Coercion</a> that unwraps an implicit-parameter dictionary
--   to expose the underlying value. We expect the <a>Type</a> to have the
--   form `IP sym ty`, and return a <a>Coercion</a> `co :: IP sym ty ~ ty`
unwrapIP :: Type -> CoercionR

-- | Create a <a>Coercion</a> that wraps a value in an implicit-parameter
--   dictionary. See <a>unwrapIP</a>.
wrapIP :: Type -> CoercionR
data QuoteWrapper
QuoteWrapper :: EvVar -> Type -> QuoteWrapper

-- | Convert the QuoteWrapper into a normal HsWrapper which can be used to
--   apply its contents.
applyQuoteWrapper :: QuoteWrapper -> HsWrapper
quoteWrapperTyVarTy :: QuoteWrapper -> Type
instance GHC.Internal.Data.Data.Data GHC.Tc.Types.Evidence.EvCallStack
instance GHC.Internal.Data.Data.Data GHC.Tc.Types.Evidence.EvTerm
instance GHC.Internal.Data.Data.Data GHC.Tc.Types.Evidence.EvTypeable
instance GHC.Internal.Data.Data.Data GHC.Tc.Types.Evidence.HoleExprRef
instance GHC.Internal.Data.Data.Data GHC.Tc.Types.Evidence.HsWrapper
instance GHC.Internal.Data.Data.Data GHC.Tc.Types.Evidence.QuoteWrapper
instance GHC.Internal.Data.Data.Data GHC.Tc.Types.Evidence.TcEvBinds
instance GHC.Internal.Base.Monoid GHC.Tc.Types.Evidence.HsWrapper
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.EvBind
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.EvBindMap
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.EvBindsVar
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.EvCallStack
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.EvTerm
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.EvTypeable
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.HoleExprRef
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.HsWrapper
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.TcEvBinds
instance GHC.Internal.Base.Semigroup GHC.Tc.Types.Evidence.HsWrapper
instance GHC.Types.Unique.Uniquable GHC.Tc.Types.Evidence.EvBindsVar

module GHC.Hs.Binds

-- | Check if namespace is covered by a namespace specifier: *
--   NoNamespaceSpecifier covers both namespaces * TypeNamespaceSpecifier
--   covers the type namespace only * DataNamespaceSpecifier covers the
--   data namespace only
coveredByNamespaceSpecifier :: NamespaceSpecifier -> NameSpace -> Bool
emptyLHsBinds :: forall (idL :: Pass) idR. LHsBindsLR (GhcPass idL) idR
emptyLocalBinds :: forall (a :: Pass) (b :: Pass). HsLocalBindsLR (GhcPass a) (GhcPass b)
emptyValBindsIn :: forall (a :: Pass) (b :: Pass). HsValBindsLR (GhcPass a) (GhcPass b)
emptyValBindsOut :: forall (a :: Pass) (b :: Pass). HsValBindsLR (GhcPass a) (GhcPass b)
eqEmptyLocalBinds :: HsLocalBindsLR a b -> Bool

-- | Extracts the name for a SPECIALIZE instance pragma. In
--   <a>hsSigDoc</a>, the src field of <a>SpecInstSig</a> signature
--   contains the SourceText for a SPECIALIZE instance pragma of the form:
--   "SourceText {-# SPECIALIZE"
--   
--   Extraction ensures that all variants of the pragma name (with a
--   <tt>Z</tt> or an <tt>S</tt>) are output exactly as used in the pragma.
extractSpecPragName :: SourceText -> String
getTcMultAnn :: HsMultAnn GhcTc -> Mult
hasSpecPrags :: TcSpecPrags -> Bool
hsSigDoc :: forall (p :: Pass). IsPass p => Sig (GhcPass p) -> SDoc
isDefaultMethod :: TcSpecPrags -> Bool
isEmptyIPBindsPR :: forall (p :: Pass). HsIPBinds (GhcPass p) -> Bool
isEmptyIPBindsTc :: HsIPBinds GhcTc -> Bool
isEmptyLHsBinds :: forall (idL :: Pass) idR. LHsBindsLR (GhcPass idL) idR -> Bool
isEmptyValBinds :: forall (a :: Pass) (b :: Pass). HsValBindsLR (GhcPass a) (GhcPass b) -> Bool
noSpecPrags :: TcSpecPrags

-- | Check if namespace specifiers overlap, i.e. if they are equal or if at
--   least one of them doesn't specify a namespace
overlappingNamespaceSpecifiers :: NamespaceSpecifier -> NamespaceSpecifier -> Bool
plusHsValBinds :: forall (a :: Pass). HsValBinds (GhcPass a) -> HsValBinds (GhcPass a) -> HsValBinds (GhcPass a)
pprDeclList :: [SDoc] -> SDoc
pprHsMultAnn :: forall (id :: Pass). OutputableBndrId id => HsMultAnn (GhcPass id) -> SDoc
pprLHsBinds :: forall (idL :: Pass) (idR :: Pass). (OutputableBndrId idL, OutputableBndrId idR) => LHsBindsLR (GhcPass idL) (GhcPass idR) -> SDoc
pprLHsBindsForUser :: forall (idL :: Pass) (idR :: Pass) (id2 :: Pass). (OutputableBndrId idL, OutputableBndrId idR, OutputableBndrId id2) => LHsBindsLR (GhcPass idL) (GhcPass idR) -> [LSig (GhcPass id2)] -> [SDoc]
pprMinimalSig :: OutputableBndr name => LBooleanFormula (GenLocated l name) -> SDoc
pprSpec :: OutputableBndr id => id -> SDoc -> InlinePragma -> SDoc
pprTcSpecPrags :: TcSpecPrags -> SDoc
pprTicks :: SDoc -> SDoc -> SDoc
pprVarSig :: OutputableBndr id => [id] -> SDoc -> SDoc
ppr_monobind :: forall (idL :: Pass) (idR :: Pass). (OutputableBndrId idL, OutputableBndrId idR) => HsBindLR (GhcPass idL) (GhcPass idR) -> SDoc
ppr_sig :: forall (p :: Pass). OutputableBndrId p => Sig (GhcPass p) -> SDoc
pragBrackets :: SDoc -> SDoc

-- | Using SourceText in case the pragma was spelled differently or used
--   mixed case
pragSrcBrackets :: SourceText -> String -> SDoc -> SDoc
setTcMultAnn :: Mult -> HsMultAnn GhcRn -> HsMultAnn GhcTc

-- | Abstraction Bindings Export
data ABExport
ABE :: Id -> Id -> HsWrapper -> TcSpecPrags -> ABExport

-- | Any INLINE pragma is attached to this Id
[abe_poly] :: ABExport -> Id
[abe_mono] :: ABExport -> Id

-- | See Note [ABExport wrapper] Shape: (forall abs_tvs. abs_ev_vars =&gt;
--   abe_mono) ~ abe_poly
[abe_wrap] :: ABExport -> HsWrapper

-- | SPECIALISE pragmas
[abe_prags] :: ABExport -> TcSpecPrags

-- | Typechecked, generalised bindings, used in the output to the type
--   checker. See Note [AbsBinds].
data AbsBinds
AbsBinds :: [TyVar] -> [EvVar] -> [ABExport] -> [TcEvBinds] -> LHsBinds GhcTc -> Bool -> AbsBinds
[abs_tvs] :: AbsBinds -> [TyVar]

-- | Includes equality constraints
[abs_ev_vars] :: AbsBinds -> [EvVar]

-- | AbsBinds only gets used when idL = idR after renaming, but these need
--   to be idL's for the collect... code in HsUtil to have the right type
[abs_exports] :: AbsBinds -> [ABExport]

-- | Evidence bindings Why a list? See <a>GHC.Tc.TyCl.Instance</a> Note
--   [Typechecking plan for instance declarations]
[abs_ev_binds] :: AbsBinds -> [TcEvBinds]

-- | Typechecked user bindings
[abs_binds] :: AbsBinds -> LHsBinds GhcTc
[abs_sig] :: AbsBinds -> Bool
data ActivationAnn
ActivationAnn :: EpToken "[" -> EpToken "]" -> Maybe (EpToken "~") -> Maybe EpaLocation -> ActivationAnn
[aa_openc] :: ActivationAnn -> EpToken "["
[aa_closec] :: ActivationAnn -> EpToken "]"
[aa_tilde] :: ActivationAnn -> Maybe (EpToken "~")
[aa_val] :: ActivationAnn -> Maybe EpaLocation
data AnnPSB
AnnPSB :: EpToken "pattern" -> Maybe (EpToken "{") -> Maybe (EpToken "}") -> Maybe (EpUniToken "<-" "\8592") -> Maybe (EpToken "=") -> AnnPSB
[ap_pattern] :: AnnPSB -> EpToken "pattern"
[ap_openc] :: AnnPSB -> Maybe (EpToken "{")
[ap_closec] :: AnnPSB -> Maybe (EpToken "}")
[ap_larrow] :: AnnPSB -> Maybe (EpUniToken "<-" "\8592")
[ap_equal] :: AnnPSB -> Maybe (EpToken "=")
data AnnSig
AnnSig :: EpUniToken "::" "\8759" -> Maybe (EpToken "pattern") -> Maybe (EpToken "default") -> AnnSig
[asDcolon] :: AnnSig -> EpUniToken "::" "\8759"
[asPattern] :: AnnSig -> Maybe (EpToken "pattern")
[asDefault] :: AnnSig -> Maybe (EpToken "default")
data AnnSpecSig
AnnSpecSig :: EpaLocation -> EpToken "#-}" -> TokDcolon -> ActivationAnn -> AnnSpecSig
[ass_open] :: AnnSpecSig -> EpaLocation
[ass_close] :: AnnSpecSig -> EpToken "#-}"
[ass_dcolon] :: AnnSpecSig -> TokDcolon
[ass_act] :: AnnSpecSig -> ActivationAnn

-- | A type signature in generated code, notably the code generated for
--   record selectors. We simply record the desired Id itself, replete with
--   its name, type and IdDetails. Otherwise it's just like a type
--   signature: there should be an accompanying binding
newtype IdSig
IdSig :: Id -> IdSig
[unIdSig] :: IdSig -> Id

-- | Located Type checker Specification Pragmas
type LTcSpecPrag = Located TcSpecPrag
data NHsValBindsLR idL
NValBinds :: [(RecFlag, LHsBinds idL)] -> [LSig GhcRn] -> NHsValBindsLR idL

-- | Optional namespace specifier for fixity signatures, WARNINIG and
--   DEPRECATED pragmas.
--   
--   Examples:
--   
--   {-# WARNING in "x-partial" data Head "don't use this pattern synonym"
--   #-} -- ↑ DataNamespaceSpecifier
--   
--   {-# DEPRECATED type D "This type was deprecated" #-} -- ↑
--   TypeNamespaceSpecifier
--   
--   infixr 6 data $ -- ↑ DataNamespaceSpecifier
data NamespaceSpecifier
NoNamespaceSpecifier :: NamespaceSpecifier
TypeNamespaceSpecifier :: EpToken "type" -> NamespaceSpecifier
DataNamespaceSpecifier :: EpToken "data" -> NamespaceSpecifier

-- | Type checker Specification Pragma
data TcSpecPrag

-- | The Id to be specialised, a wrapper that specialises the polymorphic
--   function, and inlining spec for the specialised function
SpecPrag :: Id -> HsWrapper -> InlinePragma -> TcSpecPrag

-- | Type checker Specialisation Pragmas
--   
--   <a>TcSpecPrags</a> conveys <tt>SPECIALISE</tt> pragmas from the type
--   checker to the desugarer
data TcSpecPrags

-- | Super-specialised: a default method should be macro-expanded at every
--   call site
IsDefaultMethod :: TcSpecPrags
SpecPrags :: [LTcSpecPrag] -> TcSpecPrags
type family XVarBindGhc (pL :: Pass) (pR :: Pass)
instance GHC.Internal.Data.Data.Data GHC.Hs.Binds.ActivationAnn
instance GHC.Internal.Data.Data.Data GHC.Hs.Binds.AnnPSB
instance GHC.Internal.Data.Data.Data GHC.Hs.Binds.AnnSig
instance GHC.Internal.Data.Data.Data GHC.Hs.Binds.AnnSpecSig
instance GHC.Internal.Data.Data.Data GHC.Hs.Binds.IdSig
instance GHC.Internal.Data.Data.Data GHC.Hs.Binds.NamespaceSpecifier
instance GHC.Internal.Data.Data.Data GHC.Hs.Binds.TcSpecPrag
instance GHC.Internal.Data.Data.Data GHC.Hs.Binds.TcSpecPrags
instance GHC.Classes.Eq GHC.Hs.Binds.ActivationAnn
instance GHC.Classes.Eq GHC.Hs.Binds.NamespaceSpecifier
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Binds.ActivationAnn
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Binds.AnnPSB
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Binds.AnnSig
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Binds.AnnSpecSig
instance GHC.Utils.Outputable.Outputable GHC.Hs.Binds.ABExport
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.FixitySig (GHC.Hs.Extension.GhcPass p))
instance (GHC.Hs.Extension.OutputableBndrId pl, GHC.Hs.Extension.OutputableBndrId pr) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.HsBindLR (GHC.Hs.Extension.GhcPass pl) (GHC.Hs.Extension.GhcPass pr))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.HsIPBinds (GHC.Hs.Extension.GhcPass p))
instance (GHC.Hs.Extension.OutputableBndrId pl, GHC.Hs.Extension.OutputableBndrId pr) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.HsLocalBindsLR (GHC.Hs.Extension.GhcPass pl) (GHC.Hs.Extension.GhcPass pr))
instance (GHC.Hs.Extension.OutputableBndrId pl, GHC.Hs.Extension.OutputableBndrId pr) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.HsValBindsLR (GHC.Hs.Extension.GhcPass pl) (GHC.Hs.Extension.GhcPass pr))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.IPBind (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable GHC.Hs.Binds.NamespaceSpecifier
instance (GHC.Hs.Extension.OutputableBndrId l, GHC.Hs.Extension.OutputableBndrId r) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.PatSynBind (GHC.Hs.Extension.GhcPass l) (GHC.Hs.Extension.GhcPass r))
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Extension.XRec pass (Language.Haskell.Syntax.Extension.IdP pass)) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.RecordPatSynField pass)
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.Sig (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable GHC.Hs.Binds.TcSpecPrag

module GHC.Hs.Pat

-- | Pattern
data Pat p

-- | Wildcard Pattern, i.e. <tt>_</tt>
WildPat :: XWildPat p -> Pat p

-- | Variable Pattern, e.g. <tt>x</tt>
VarPat :: XVarPat p -> LIdP p -> Pat p

-- | Lazy Pattern, e.g. <tt>~x</tt>
LazyPat :: XLazyPat p -> LPat p -> Pat p

-- | As pattern, e.g. <tt>x@pat</tt>
AsPat :: XAsPat p -> LIdP p -> LPat p -> Pat p

-- | Parenthesised pattern, e.g. <tt>(x)</tt>
ParPat :: XParPat p -> LPat p -> Pat p

-- | Bang pattern, e.g. <tt>!x</tt>
BangPat :: XBangPat p -> LPat p -> Pat p

-- | Syntactic List, e.g. <tt>[x]</tt> or <tt>[x,y]</tt>. Note that
--   <tt>[]</tt> and <tt>(x:xs)</tt> patterns are both represented using
--   <a>ConPat</a>.
ListPat :: XListPat p -> [LPat p] -> Pat p

-- | Tuple pattern, e.g. <tt>(x, y)</tt> (boxed tuples) or <tt>(# x, y
--   #)</tt> (requires <tt>-XUnboxedTuples</tt>)
TuplePat :: XTuplePat p -> [LPat p] -> Boxity -> Pat p

-- | Or Pattern, e.g. <tt>(pat_1; ...; pat_n)</tt>. Used by
--   <tt>-XOrPatterns</tt>
OrPat :: XOrPat p -> NonEmpty (LPat p) -> Pat p

-- | Anonymous sum pattern, e.g. <tt>(# x | #)</tt>. Used by
--   <tt>-XUnboxedSums</tt>
SumPat :: XSumPat p -> LPat p -> ConTag -> SumWidth -> Pat p

-- | Constructor Pattern, e.g. <tt>()</tt>, <tt>[]</tt> or <tt>Nothing</tt>
ConPat :: XConPat p -> XRec p (ConLikeP p) -> HsConPatDetails p -> Pat p
[pat_con_ext] :: Pat p -> XConPat p
[pat_con] :: Pat p -> XRec p (ConLikeP p)
[pat_args] :: Pat p -> HsConPatDetails p

-- | View Pattern, e.g. <tt>someFun -&gt; pat</tt>. Used by
--   <tt>-XViewPatterns</tt>
ViewPat :: XViewPat p -> LHsExpr p -> LPat p -> Pat p

-- | Splice Pattern, e.g. <tt>$(pat)</tt>
SplicePat :: XSplicePat p -> HsUntypedSplice p -> Pat p

-- | Literal Pattern
--   
--   Used for <b>non-overloaded</b> literal patterns: Int#, Char#, Int,
--   Char, String, etc.
LitPat :: XLitPat p -> HsLit p -> Pat p

-- | Natural Pattern, used for all overloaded literals, including
--   overloaded Strings with <tt>-XOverloadedStrings</tt>
NPat :: XNPat p -> XRec p (HsOverLit p) -> Maybe (SyntaxExpr p) -> SyntaxExpr p -> Pat p

-- | n+k pattern, e.g. <tt>n+1</tt>, used by <tt>-XNPlusKPatterns</tt>
NPlusKPat :: XNPlusKPat p -> LIdP p -> XRec p (HsOverLit p) -> HsOverLit p -> SyntaxExpr p -> SyntaxExpr p -> Pat p

-- | Pattern with a type signature, e.g. <tt>x :: Int</tt>
SigPat :: XSigPat p -> LPat p -> HsPatSigType (NoGhcTc p) -> Pat p

-- | Embed the syntax of types into patterns, e.g. <tt>fn (type t) =
--   rhs</tt>. Enabled by <tt>-XExplicitNamespaces</tt> in conjunction with
--   <tt>-XRequiredTypeArguments</tt>.
EmbTyPat :: XEmbTyPat p -> HsTyPat (NoGhcTc p) -> Pat p

-- | Type abstraction which brings into scope type variables associated
--   with invisible forall. E.g. <tt>fn @t ... = rhs</tt>. Used by
--   <tt>-XTypeAbstractions</tt>.
InvisPat :: XInvisPat p -> HsTyPat (NoGhcTc p) -> Pat p

-- | TTG Extension point; see Note [Trees That Grow] in
--   Language.Haskell.Syntax.Extension
XPat :: !XXPat p -> Pat p
type LPat p = XRec p Pat p
isInvisArgPat :: Pat p -> Bool
isVisArgPat :: Pat p -> Bool
data EpAnnSumPat
EpAnnSumPat :: (EpaLocation, EpaLocation) -> [EpToken "|"] -> [EpToken "|"] -> EpAnnSumPat
[sumPatParens] :: EpAnnSumPat -> (EpaLocation, EpaLocation)
[sumPatVbarsBefore] :: EpAnnSumPat -> [EpToken "|"]
[sumPatVbarsAfter] :: EpAnnSumPat -> [EpToken "|"]

-- | This is the extension field for ConPat, added after typechecking It
--   adds quite a few extra fields, to support elaboration of pattern
--   matching.
data ConPatTc
ConPatTc :: [Type] -> [TyVar] -> [EvVar] -> TcEvBinds -> HsWrapper -> ConPatTc

-- | The universal arg types 1-1 with the universal tyvars of the
--   constructor/pattern synonym Use (conLikeResTy pat_con cpt_arg_tys) to
--   get the type of the pattern
[cpt_arg_tys] :: ConPatTc -> [Type]

-- | Existentially bound type variables in correctly-scoped order e.g. [k:*
--   x:k]
[cpt_tvs] :: ConPatTc -> [TyVar]

-- | Ditto *coercion variables* and *dictionaries* One reason for putting
--   coercion variable here I think is to ensure their kinds are zonked
[cpt_dicts] :: ConPatTc -> [EvVar]

-- | Bindings involving those dictionaries
[cpt_binds] :: ConPatTc -> TcEvBinds

-- | Extra wrapper to pass to the matcher Only relevant for
--   pattern-synonyms; ignored for data cons
[cpt_wrap] :: ConPatTc -> HsWrapper
type family ConLikeP x
data HsPatExpansion a b
HsPatExpanded :: a -> b -> HsPatExpansion a b

-- | Extension constructor for Pat, added after typechecking.
data XXPatGhcTc

-- | Coercion Pattern (translation only)
--   
--   During desugaring a (CoPat co pat) turns into a cast with <tt>co</tt>
--   on the scrutinee, followed by a match on <tt>pat</tt>.
CoPat :: HsWrapper -> Pat GhcTc -> Type -> XXPatGhcTc

-- | Coercion Pattern If co :: t1 ~ t2, p :: t2, then (CoPat co p) :: t1
[co_cpt_wrap] :: XXPatGhcTc -> HsWrapper

-- | Why not LPat? Ans: existing locn will do
[co_pat_inner] :: XXPatGhcTc -> Pat GhcTc

-- | Type of whole pattern, t1
[co_pat_ty] :: XXPatGhcTc -> Type

-- | Pattern expansion: original pattern, and desugared pattern, for
--   RebindableSyntax and other overloaded syntax such as OverloadedLists.
--   See Note [Rebindable syntax and XXExprGhcRn].
ExpansionPat :: Pat GhcRn -> Pat GhcTc -> XXPatGhcTc

-- | Haskell Constructor Pattern Details
type HsConPatDetails p = HsConDetails HsConPatTyArg NoGhcTc p LPat p HsRecFields p LPat p
hsConPatArgs :: UnXRec p => HsConPatDetails p -> [LPat p]
hsConPatTyArgs :: HsConPatDetails p -> [HsConPatTyArg (NoGhcTc p)]

-- | Type argument in a data constructor pattern, e.g. the <tt>@a</tt> in
--   <tt>f (Just @a x) = ...</tt>.
data HsConPatTyArg p
HsConPatTyArg :: !XConPatTyArg p -> HsTyPat p -> HsConPatTyArg p

-- | Haskell Record Fields
--   
--   HsRecFields is used only for patterns and expressions (not data type
--   declarations)
data HsRecFields p arg
HsRecFields :: !XHsRecFields p -> [LHsRecField p arg] -> Maybe (XRec p RecFieldsDotDot) -> HsRecFields p arg
[rec_ext] :: HsRecFields p arg -> !XHsRecFields p
[rec_flds] :: HsRecFields p arg -> [LHsRecField p arg]
[rec_dotdot] :: HsRecFields p arg -> Maybe (XRec p RecFieldsDotDot)

-- | Haskell Field Binding
data HsFieldBind lhs rhs
HsFieldBind :: XHsFieldBind lhs -> lhs -> rhs -> Bool -> HsFieldBind lhs rhs
[hfbAnn] :: HsFieldBind lhs rhs -> XHsFieldBind lhs
[hfbLHS] :: HsFieldBind lhs rhs -> lhs

-- | Filled in by renamer when punning
[hfbRHS] :: HsFieldBind lhs rhs -> rhs

-- | Note [Punning]
[hfbPun] :: HsFieldBind lhs rhs -> Bool

-- | Located Haskell Record Field
type LHsFieldBind p id arg = XRec p HsFieldBind id arg

-- | Haskell Record Field
type HsRecField p arg = HsFieldBind LFieldOcc p arg

-- | Located Haskell Record Field
type LHsRecField p arg = XRec p HsRecField p arg

-- | Haskell Record Update Field
type HsRecUpdField p q = HsFieldBind LFieldOcc p LHsExpr q

-- | Located Haskell Record Update Field
type LHsRecUpdField p q = XRec p HsRecUpdField p q

-- | Newtype to be able to have a specific XRec instance for the Int in
--   <a>rec_dotdot</a>
newtype RecFieldsDotDot
RecFieldsDotDot :: Int -> RecFieldsDotDot
[unRecFieldsDotDot] :: RecFieldsDotDot -> Int
hsRecFields :: UnXRec p => HsRecFields p arg -> [IdP p]
hsRecFieldSel :: UnXRec p => HsRecField p arg -> IdP p
hsRecFieldId :: HsRecField GhcTc arg -> Id
hsRecFieldsArgs :: UnXRec p => HsRecFields p arg -> [arg]
mkPrefixConPat :: DataCon -> [LPat GhcTc] -> [Type] -> LPat GhcTc
mkCharLitPat :: SourceText -> Char -> LPat GhcTc
mkNilPat :: Type -> LPat GhcTc

-- | Is the pattern any of combination of:
--   
--   <ul>
--   <li>(pat)</li>
--   <li>pat :: Type</li>
--   <li>~pat</li>
--   <li>!pat</li>
--   <li>x (variable)</li>
--   </ul>
isSimplePat :: forall (x :: Pass). LPat (GhcPass x) -> Maybe (IdP (GhcPass x))
isPatSyn :: LPat GhcTc -> Bool
looksLazyPatBind :: HsBind GhcTc -> Bool
isBangedLPat :: forall (p :: Pass). LPat (GhcPass p) -> Bool

-- | Parenthesize a pattern without token information
gParPat :: forall (p :: Pass). IsPass p => LPat (GhcPass p) -> Pat (GhcPass p)

-- | <tt><a>patNeedsParens</a> p pat</tt> returns <a>True</a> if the
--   pattern <tt>pat</tt> needs parentheses under precedence <tt>p</tt>.
patNeedsParens :: forall (p :: Pass). IsPass p => PprPrec -> Pat (GhcPass p) -> Bool

-- | <tt><a>parenthesizePat</a> p pat</tt> checks if
--   <tt><a>patNeedsParens</a> p pat</tt> is true, and if so, surrounds
--   <tt>pat</tt> with a <a>ParPat</a>. Otherwise, it simply returns
--   <tt>pat</tt>.
parenthesizePat :: forall (p :: Pass). IsPass p => PprPrec -> LPat (GhcPass p) -> LPat (GhcPass p)

-- | <tt>isIrrefutableHsPat p</tt> is true if matching against <tt>p</tt>
--   cannot fail in the sense of falling through to the next pattern. (NB:
--   this is not quite the same as the (silly) defn in 3.17.2 of the
--   Haskell 98 report.)
--   
--   If isIrrefutableHsPat returns <a>True</a>, the pattern is definitely
--   irrefutable.
--   
--   However, isIrrefutableHsPat returns <a>False</a> if it's in doubt.
--   It's a best effort guess with the information we have available:
--   
--   <ul>
--   <li>we sometimes call <a>isIrrefutableHsPat</a> from the renamer, in
--   which case we don't have type information to hand. This means we can't
--   properly handle GADTs, nor the result TyCon of COMPLETE pragmas.</li>
--   <li>even when calling <a>isIrrefutableHsPat</a> in the typechecker, we
--   don't keep track of any long distance information like the
--   pattern-match checker does.</li>
--   </ul>
isIrrefutableHsPat :: forall (p :: Pass). IsPass p => Bool -> (ConLikeP (GhcPass p) -> Bool) -> LPat (GhcPass p) -> Bool

-- | Is this pattern boring from the perspective of pattern-match checking,
--   i.e. introduces no new pieces of long-distance information which could
--   influence pattern-match checking?
--   
--   See Note [Boring patterns].
isBoringHsPat :: forall (p :: Pass). OutputableBndrId p => LPat (GhcPass p) -> Bool
collectEvVarsPat :: Pat GhcTc -> Bag EvVar
collectEvVarsPats :: [Pat GhcTc] -> Bag EvVar
pprParendLPat :: forall (p :: Pass). OutputableBndrId p => PprPrec -> LPat (GhcPass p) -> SDoc
pprConArgs :: forall (p :: Pass). (OutputableBndrId p, Outputable (Anno (IdGhcP p))) => HsConPatDetails (GhcPass p) -> SDoc
pprLPat :: forall (p :: Pass). OutputableBndrId p => LPat (GhcPass p) -> SDoc
instance GHC.Internal.Data.Data.Data GHC.Hs.Pat.EpAnnSumPat
instance (GHC.Internal.Data.Data.Data a, GHC.Internal.Data.Data.Data b) => GHC.Internal.Data.Data.Data (GHC.Hs.Pat.HsPatExpansion a b)
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Pat.EpAnnSumPat
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsTyPat p) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Pat.HsConPatTyArg p)
instance (GHC.Utils.Outputable.Outputable p, GHC.Utils.Outputable.OutputableBndr p, GHC.Utils.Outputable.Outputable arg) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Pat.HsFieldBind p arg)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b) => GHC.Utils.Outputable.Outputable (GHC.Hs.Pat.HsPatExpansion a b)
instance (GHC.Utils.Outputable.Outputable arg, GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Extension.XRec p (Language.Haskell.Syntax.Pat.HsRecField p arg)), Language.Haskell.Syntax.Extension.XRec p Language.Haskell.Syntax.Pat.RecFieldsDotDot GHC.Types.~ GHC.Parser.Annotation.LocatedE Language.Haskell.Syntax.Pat.RecFieldsDotDot) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Pat.HsRecFields p arg)
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Pat.Pat (GHC.Hs.Extension.GhcPass p))

module GHC.Parser.Types
data SumOrTuple b

-- | Last two are the locations of the '|' before and after the payload
Sum :: ConTag -> Arity -> LocatedA b -> [EpToken "|"] -> [EpToken "|"] -> SumOrTuple b
Tuple :: [Either (EpAnn Bool) (LocatedA b)] -> SumOrTuple b
pprSumOrTuple :: Outputable b => Boxity -> SumOrTuple b -> SDoc

-- | See Note [Ambiguous syntactic categories] and Note [PatBuilder]
data PatBuilder p
PatBuilderPat :: Pat p -> PatBuilder p
PatBuilderPar :: EpToken "(" -> LocatedA (PatBuilder p) -> EpToken ")" -> PatBuilder p
PatBuilderApp :: LocatedA (PatBuilder p) -> LocatedA (PatBuilder p) -> PatBuilder p
PatBuilderAppType :: LocatedA (PatBuilder p) -> EpToken "@" -> HsTyPat GhcPs -> PatBuilder p
PatBuilderOpApp :: LocatedA (PatBuilder p) -> LocatedN RdrName -> LocatedA (PatBuilder p) -> ([EpToken "("], [EpToken ")"]) -> PatBuilder p
PatBuilderVar :: LocatedN RdrName -> PatBuilder p
PatBuilderOverLit :: HsOverLit GhcPs -> PatBuilder p

-- | An accumulator to build a prefix data constructor, e.g. when parsing
--   <tt>MkT A B C</tt>, the accumulator will evolve as follows:
--   
--   <pre>
--   1. PrefixDataConBuilder []        MkT
--   2. PrefixDataConBuilder [A]       MkT
--   3. PrefixDataConBuilder [A, B]    MkT
--   4. PrefixDataConBuilder [A, B, C] MkT
--   
--   </pre>
--   
--   There are two reasons we have a separate builder type instead of using
--   <tt>HsConDeclDetails GhcPs</tt> directly:
--   
--   <ol>
--   <li>It's faster, because <a>OrdList</a> gives us constant-time
--   snoc.</li>
--   <li>Having a separate type helps ensure that we don't forget to
--   finalize a <tt>RecTy</tt> into a <a>RecCon</a> (we do that in
--   <tt>dataConBuilderDetails</tt>).</li>
--   </ol>
--   
--   See Note [PatBuilder] for another builder type used in the parser.
--   Here the technique is similar, but the motivation is different.
data DataConBuilder
PrefixDataConBuilder :: OrdList (LHsType GhcPs) -> LocatedN RdrName -> DataConBuilder
InfixDataConBuilder :: LHsType GhcPs -> LocatedN RdrName -> LHsType GhcPs -> DataConBuilder
instance GHC.Utils.Outputable.Outputable GHC.Parser.Types.DataConBuilder
instance GHC.Utils.Outputable.Outputable (GHC.Parser.Types.PatBuilder GHC.Hs.Extension.GhcPs)


-- | Abstract syntax of global declarations.
--   
--   Definitions for: <tt>SynDecl</tt> and <tt>ConDecl</tt>,
--   <tt>ClassDecl</tt>, <tt>InstDecl</tt>, <tt>DefaultDecl</tt> and
--   <tt>ForeignDecl</tt>.
module GHC.Hs.Decls

-- | A Haskell Declaration
data HsDecl p

-- | Type or Class Declaration
TyClD :: XTyClD p -> TyClDecl p -> HsDecl p

-- | Instance declaration
InstD :: XInstD p -> InstDecl p -> HsDecl p

-- | Deriving declaration
DerivD :: XDerivD p -> DerivDecl p -> HsDecl p

-- | Value declaration
ValD :: XValD p -> HsBind p -> HsDecl p

-- | Signature declaration
SigD :: XSigD p -> Sig p -> HsDecl p

-- | Standalone kind signature
KindSigD :: XKindSigD p -> StandaloneKindSig p -> HsDecl p

-- | 'default' declaration
DefD :: XDefD p -> DefaultDecl p -> HsDecl p

-- | Foreign declaration
ForD :: XForD p -> ForeignDecl p -> HsDecl p

-- | Warning declaration
WarningD :: XWarningD p -> WarnDecls p -> HsDecl p

-- | Annotation declaration
AnnD :: XAnnD p -> AnnDecl p -> HsDecl p

-- | Rule declaration
RuleD :: XRuleD p -> RuleDecls p -> HsDecl p

-- | Splice declaration (Includes quasi-quotes)
SpliceD :: XSpliceD p -> SpliceDecl p -> HsDecl p

-- | Documentation comment declaration
DocD :: XDocD p -> DocDecl p -> HsDecl p

-- | Role annotation declaration
RoleAnnotD :: XRoleAnnotD p -> RoleAnnotDecl p -> HsDecl p
XHsDecl :: !XXHsDecl p -> HsDecl p
type LHsDecl p = XRec p HsDecl p

-- | Haskell Data type Definition
data HsDataDefn pass

-- | Declares a data type or newtype, giving its constructors <tt>
--   data/newtype T a = <a>constrs</a> data/newtype instance T [a] =
--   <a>constrs</a> </tt>
HsDataDefn :: XCHsDataDefn pass -> Maybe (LHsContext pass) -> Maybe (XRec pass CType) -> Maybe (LHsKind pass) -> DataDefnCons (LConDecl pass) -> HsDeriving pass -> HsDataDefn pass
[dd_ext] :: HsDataDefn pass -> XCHsDataDefn pass

-- | Context
[dd_ctxt] :: HsDataDefn pass -> Maybe (LHsContext pass)
[dd_cType] :: HsDataDefn pass -> Maybe (XRec pass CType)

-- | Optional kind signature.
--   
--   <tt>(Just k)</tt> for a GADT-style <tt>data</tt>, or <tt>data
--   instance</tt> decl, with explicit kind sig
--   
--   Always <tt>Nothing</tt> for H98-syntax decls
[dd_kindSig] :: HsDataDefn pass -> Maybe (LHsKind pass)

-- | Data constructors
--   
--   For <tt>data T a = T1 | T2 a</tt> the <a>LConDecl</a>s all have
--   <a>ConDeclH98</a>. For <tt>data T a where { T1 :: T a }</tt> the
--   <tt>LConDecls</tt> all have <a>ConDeclGADT</a>.
[dd_cons] :: HsDataDefn pass -> DataDefnCons (LConDecl pass)

-- | Optional 'deriving' clause
[dd_derivs] :: HsDataDefn pass -> HsDeriving pass
XHsDataDefn :: !XXHsDataDefn pass -> HsDataDefn pass

-- | Haskell Deriving clause
type HsDeriving pass = [LHsDerivingClause pass]
type LHsFunDep pass = XRec pass FunDep pass

-- | A single <tt>deriving</tt> clause of a data declaration.
data HsDerivingClause pass
HsDerivingClause :: XCHsDerivingClause pass -> Maybe (LDerivStrategy pass) -> LDerivClauseTys pass -> HsDerivingClause pass
[deriv_clause_ext] :: HsDerivingClause pass -> XCHsDerivingClause pass

-- | The user-specified strategy (if any) to use when deriving
--   <a>deriv_clause_tys</a>.
[deriv_clause_strategy] :: HsDerivingClause pass -> Maybe (LDerivStrategy pass)

-- | The types to derive.
[deriv_clause_tys] :: HsDerivingClause pass -> LDerivClauseTys pass
XHsDerivingClause :: !XXHsDerivingClause pass -> HsDerivingClause pass
type LHsDerivingClause pass = XRec pass HsDerivingClause pass

-- | The types mentioned in a single <tt>deriving</tt> clause. This can
--   come in two forms, <a>DctSingle</a> or <a>DctMulti</a>, depending on
--   whether the types are surrounded by enclosing parentheses or not.
--   These parentheses are semantically different than <a>HsParTy</a>. For
--   example, <tt>deriving ()</tt> means "derive zero classes" rather than
--   "derive an instance of the 0-tuple".
--   
--   <a>DerivClauseTys</a> use <a>LHsSigType</a> because <tt>deriving</tt>
--   clauses can mention type variables that aren't bound by the datatype,
--   e.g.
--   
--   <pre>
--   data T b = ... deriving (C [a])
--   </pre>
--   
--   should produce a derived instance for <tt>C [a] (T b)</tt>.
data DerivClauseTys pass

-- | A <tt>deriving</tt> clause with a single type. Moreover, that type can
--   only be a type constructor without any arguments.
--   
--   Example: <tt>deriving Eq</tt>
DctSingle :: XDctSingle pass -> LHsSigType pass -> DerivClauseTys pass

-- | A <tt>deriving</tt> clause with a comma-separated list of types,
--   surrounded by enclosing parentheses.
--   
--   Example: <tt>deriving (Eq, C a)</tt>
DctMulti :: XDctMulti pass -> [LHsSigType pass] -> DerivClauseTys pass
XDerivClauseTys :: !XXDerivClauseTys pass -> DerivClauseTys pass
type LDerivClauseTys pass = XRec pass DerivClauseTys pass

-- | When we only care whether a data-type declaration is `data` or
--   `newtype`, but not what constructors it has
data NewOrData

-- | Convert a <a>NewOrData</a> to a <a>TyConFlavour</a>
newOrDataToFlavour :: NewOrData -> TyConFlavour tc
anyLConIsGadt :: Foldable f => f (GenLocated l (ConDecl pass)) -> Bool
data StandaloneKindSig pass
StandaloneKindSig :: XStandaloneKindSig pass -> LIdP pass -> LHsSigType pass -> StandaloneKindSig pass
XStandaloneKindSig :: !XXStandaloneKindSig pass -> StandaloneKindSig pass

-- | Located Standalone Kind Signature
type LStandaloneKindSig pass = XRec pass StandaloneKindSig pass
standaloneKindSigName :: forall (p :: Pass). StandaloneKindSig (GhcPass p) -> IdP (GhcPass p)

-- | A type or class declaration.
data TyClDecl pass

-- | <pre>
--   type/data family T :: *-&gt;*
--   </pre>
FamDecl :: XFamDecl pass -> FamilyDecl pass -> TyClDecl pass
[tcdFExt] :: TyClDecl pass -> XFamDecl pass
[tcdFam] :: TyClDecl pass -> FamilyDecl pass

-- | <tt>type</tt> declaration
SynDecl :: XSynDecl pass -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> LHsType pass -> TyClDecl pass

-- | Post renamer, FVs
[tcdSExt] :: TyClDecl pass -> XSynDecl pass

-- | Type constructor
[tcdLName] :: TyClDecl pass -> LIdP pass

-- | Type variables; for an associated type these include outer binders
[tcdTyVars] :: TyClDecl pass -> LHsQTyVars pass

-- | Fixity used in the declaration
[tcdFixity] :: TyClDecl pass -> LexicalFixity

-- | RHS of type declaration
[tcdRhs] :: TyClDecl pass -> LHsType pass

-- | <tt>data</tt> declaration
DataDecl :: XDataDecl pass -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> HsDataDefn pass -> TyClDecl pass

-- | Post renamer, CUSK flag, FVs
[tcdDExt] :: TyClDecl pass -> XDataDecl pass

-- | Type constructor
[tcdLName] :: TyClDecl pass -> LIdP pass

-- | Type variables; for an associated type these include outer binders
[tcdTyVars] :: TyClDecl pass -> LHsQTyVars pass

-- | Fixity used in the declaration
[tcdFixity] :: TyClDecl pass -> LexicalFixity
[tcdDataDefn] :: TyClDecl pass -> HsDataDefn pass
ClassDecl :: XClassDecl pass -> Maybe (LHsContext pass) -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> [LHsFunDep pass] -> [LSig pass] -> LHsBinds pass -> [LFamilyDecl pass] -> [LTyFamDefltDecl pass] -> [LDocDecl pass] -> TyClDecl pass

-- | Post renamer, FVs
[tcdCExt] :: TyClDecl pass -> XClassDecl pass

-- | Context...
[tcdCtxt] :: TyClDecl pass -> Maybe (LHsContext pass)

-- | Type constructor
[tcdLName] :: TyClDecl pass -> LIdP pass

-- | Type variables; for an associated type these include outer binders
[tcdTyVars] :: TyClDecl pass -> LHsQTyVars pass

-- | Fixity used in the declaration
[tcdFixity] :: TyClDecl pass -> LexicalFixity

-- | Functional deps
[tcdFDs] :: TyClDecl pass -> [LHsFunDep pass]

-- | Methods' signatures
[tcdSigs] :: TyClDecl pass -> [LSig pass]

-- | Default methods
[tcdMeths] :: TyClDecl pass -> LHsBinds pass

-- | Associated types;
[tcdATs] :: TyClDecl pass -> [LFamilyDecl pass]

-- | Associated type defaults
[tcdATDefs] :: TyClDecl pass -> [LTyFamDefltDecl pass]

-- | Haddock docs
[tcdDocs] :: TyClDecl pass -> [LDocDecl pass]
XTyClDecl :: !XXTyClDecl pass -> TyClDecl pass

-- | Located Declaration of a Type or Class
type LTyClDecl pass = XRec pass TyClDecl pass
data DataDeclRn
DataDeclRn :: Bool -> NameSet -> DataDeclRn

-- | does this have a CUSK? See Note [CUSKs: complete user-supplied kind
--   signatures]
[tcdDataCusk] :: DataDeclRn -> Bool
[tcdFVs] :: DataDeclRn -> NameSet
data AnnDataDefn
AnnDataDefn :: [EpToken "("] -> [EpToken ")"] -> EpToken "type" -> EpToken "newtype" -> EpToken "data" -> EpToken "instance" -> TokDcolon -> EpToken "where" -> EpToken "{" -> EpToken "}" -> EpToken "=" -> AnnDataDefn
[andd_openp] :: AnnDataDefn -> [EpToken "("]
[andd_closep] :: AnnDataDefn -> [EpToken ")"]
[andd_type] :: AnnDataDefn -> EpToken "type"
[andd_newtype] :: AnnDataDefn -> EpToken "newtype"
[andd_data] :: AnnDataDefn -> EpToken "data"
[andd_instance] :: AnnDataDefn -> EpToken "instance"
[andd_dcolon] :: AnnDataDefn -> TokDcolon
[andd_where] :: AnnDataDefn -> EpToken "where"
[andd_openc] :: AnnDataDefn -> EpToken "{"
[andd_closec] :: AnnDataDefn -> EpToken "}"
[andd_equal] :: AnnDataDefn -> EpToken "="
data AnnClassDecl
AnnClassDecl :: EpToken "class" -> [EpToken "("] -> [EpToken ")"] -> EpToken "|" -> EpToken "where" -> EpToken "{" -> EpToken "}" -> [EpToken ";"] -> AnnClassDecl
[acd_class] :: AnnClassDecl -> EpToken "class"
[acd_openp] :: AnnClassDecl -> [EpToken "("]
[acd_closep] :: AnnClassDecl -> [EpToken ")"]
[acd_vbar] :: AnnClassDecl -> EpToken "|"
[acd_where] :: AnnClassDecl -> EpToken "where"
[acd_openc] :: AnnClassDecl -> EpToken "{"
[acd_closec] :: AnnClassDecl -> EpToken "}"
[acd_semis] :: AnnClassDecl -> [EpToken ";"]
data AnnSynDecl
AnnSynDecl :: [EpToken "("] -> [EpToken ")"] -> EpToken "type" -> EpToken "=" -> AnnSynDecl
[asd_opens] :: AnnSynDecl -> [EpToken "("]
[asd_closes] :: AnnSynDecl -> [EpToken ")"]
[asd_type] :: AnnSynDecl -> EpToken "type"
[asd_equal] :: AnnSynDecl -> EpToken "="
data AnnFamilyDecl
AnnFamilyDecl :: [EpToken "("] -> [EpToken ")"] -> EpToken "type" -> EpToken "data" -> EpToken "family" -> TokDcolon -> EpToken "=" -> EpToken "|" -> EpToken "where" -> EpToken "{" -> EpToken ".." -> EpToken "}" -> AnnFamilyDecl
[afd_openp] :: AnnFamilyDecl -> [EpToken "("]
[afd_closep] :: AnnFamilyDecl -> [EpToken ")"]
[afd_type] :: AnnFamilyDecl -> EpToken "type"
[afd_data] :: AnnFamilyDecl -> EpToken "data"
[afd_family] :: AnnFamilyDecl -> EpToken "family"
[afd_dcolon] :: AnnFamilyDecl -> TokDcolon
[afd_equal] :: AnnFamilyDecl -> EpToken "="
[afd_vbar] :: AnnFamilyDecl -> EpToken "|"
[afd_where] :: AnnFamilyDecl -> EpToken "where"
[afd_openc] :: AnnFamilyDecl -> EpToken "{"
[afd_dotdot] :: AnnFamilyDecl -> EpToken ".."
[afd_closec] :: AnnFamilyDecl -> EpToken "}"
data AnnClsInstDecl
AnnClsInstDecl :: EpToken "instance" -> EpToken "where" -> EpToken "{" -> [EpToken ";"] -> EpToken "}" -> AnnClsInstDecl
[acid_instance] :: AnnClsInstDecl -> EpToken "instance"
[acid_where] :: AnnClsInstDecl -> EpToken "where"
[acid_openc] :: AnnClsInstDecl -> EpToken "{"
[acid_semis] :: AnnClsInstDecl -> [EpToken ";"]
[acid_closec] :: AnnClsInstDecl -> EpToken "}"

-- | Type or Class Group
data TyClGroup pass
TyClGroup :: XCTyClGroup pass -> [LTyClDecl pass] -> [LRoleAnnotDecl pass] -> [LStandaloneKindSig pass] -> [LInstDecl pass] -> TyClGroup pass
[group_ext] :: TyClGroup pass -> XCTyClGroup pass
[group_tyclds] :: TyClGroup pass -> [LTyClDecl pass]
[group_roles] :: TyClGroup pass -> [LRoleAnnotDecl pass]
[group_kisigs] :: TyClGroup pass -> [LStandaloneKindSig pass]
[group_instds] :: TyClGroup pass -> [LInstDecl pass]
XTyClGroup :: !XXTyClGroup pass -> TyClGroup pass
tyClGroupTyClDecls :: [TyClGroup pass] -> [LTyClDecl pass]
tyClGroupInstDecls :: [TyClGroup pass] -> [LInstDecl pass]
tyClGroupRoleDecls :: [TyClGroup pass] -> [LRoleAnnotDecl pass]
tyClGroupKindSigs :: [TyClGroup pass] -> [LStandaloneKindSig pass]

-- | type class
isClassDecl :: TyClDecl pass -> Bool

-- | <tt>True</tt> <a>=</a> argument is a <tt>data</tt>/<tt>newtype</tt>
--   declaration.
isDataDecl :: TyClDecl pass -> Bool

-- | type or type instance declaration
isSynDecl :: TyClDecl pass -> Bool
tcdName :: forall (p :: Pass). Anno (IdGhcP p) ~ SrcSpanAnnN => TyClDecl (GhcPass p) -> IdP (GhcPass p)

-- | type/data family declaration
isFamilyDecl :: TyClDecl pass -> Bool

-- | type family declaration
isTypeFamilyDecl :: TyClDecl pass -> Bool

-- | data family declaration
isDataFamilyDecl :: TyClDecl pass -> Bool

-- | open type family info
isOpenTypeFamilyInfo :: FamilyInfo pass -> Bool

-- | closed type family info
isClosedTypeFamilyInfo :: FamilyInfo pass -> Bool
tyFamInstDeclName :: forall (p :: Pass). Anno (IdGhcP p) ~ SrcSpanAnnN => TyFamInstDecl (GhcPass p) -> IdP (GhcPass p)
tyFamInstDeclLName :: forall (p :: Pass). Anno (IdGhcP p) ~ SrcSpanAnnN => TyFamInstDecl (GhcPass p) -> LocatedN (IdP (GhcPass p))
countTyClDecls :: [TyClDecl pass] -> (Int, Int, Int, Int, Int)
pprTyClDeclFlavour :: forall (p :: Pass). TyClDecl (GhcPass p) -> SDoc
tyClDeclLName :: forall (p :: Pass). Anno (IdGhcP p) ~ SrcSpanAnnN => TyClDecl (GhcPass p) -> LocatedN (IdP (GhcPass p))
tyClDeclTyVars :: TyClDecl pass -> LHsQTyVars pass

-- | Does this declaration have a complete, user-supplied kind signature?
--   See Note [CUSKs: complete user-supplied kind signatures]
hsDeclHasCusk :: TyClDecl GhcRn -> Bool
famResultKindSignature :: forall (p :: Pass). FamilyResultSig (GhcPass p) -> Maybe (LHsKind (GhcPass p))

-- | type Family Declaration
data FamilyDecl pass
FamilyDecl :: XCFamilyDecl pass -> FamilyInfo pass -> TopLevelFlag -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> LFamilyResultSig pass -> Maybe (LInjectivityAnn pass) -> FamilyDecl pass
[fdExt] :: FamilyDecl pass -> XCFamilyDecl pass
[fdInfo] :: FamilyDecl pass -> FamilyInfo pass
[fdTopLevel] :: FamilyDecl pass -> TopLevelFlag
[fdLName] :: FamilyDecl pass -> LIdP pass
[fdTyVars] :: FamilyDecl pass -> LHsQTyVars pass
[fdFixity] :: FamilyDecl pass -> LexicalFixity
[fdResultSig] :: FamilyDecl pass -> LFamilyResultSig pass
[fdInjectivityAnn] :: FamilyDecl pass -> Maybe (LInjectivityAnn pass)
XFamilyDecl :: !XXFamilyDecl pass -> FamilyDecl pass

-- | Located type Family Declaration
type LFamilyDecl pass = XRec pass FamilyDecl pass
data FunDep pass
FunDep :: XCFunDep pass -> [LIdP pass] -> [LIdP pass] -> FunDep pass
XFunDep :: !XXFunDep pass -> FunDep pass
ppDataDefnHeader :: forall (p :: Pass). OutputableBndrId p => (Maybe (LHsContext (GhcPass p)) -> SDoc) -> HsDataDefn (GhcPass p) -> SDoc
pp_vanilla_decl_head :: forall (p :: Pass). OutputableBndrId p => XRec (GhcPass p) (IdP (GhcPass p)) -> LHsQTyVars (GhcPass p) -> LexicalFixity -> Maybe (LHsContext (GhcPass p)) -> SDoc

-- | Instance Declaration
data InstDecl pass
ClsInstD :: XClsInstD pass -> ClsInstDecl pass -> InstDecl pass
[cid_d_ext] :: InstDecl pass -> XClsInstD pass
[cid_inst] :: InstDecl pass -> ClsInstDecl pass
DataFamInstD :: XDataFamInstD pass -> DataFamInstDecl pass -> InstDecl pass
[dfid_ext] :: InstDecl pass -> XDataFamInstD pass
[dfid_inst] :: InstDecl pass -> DataFamInstDecl pass
TyFamInstD :: XTyFamInstD pass -> TyFamInstDecl pass -> InstDecl pass
[tfid_ext] :: InstDecl pass -> XTyFamInstD pass
[tfid_inst] :: InstDecl pass -> TyFamInstDecl pass
XInstDecl :: !XXInstDecl pass -> InstDecl pass

-- | Located Instance Declaration
type LInstDecl pass = XRec pass InstDecl pass
data FamilyInfo pass
DataFamily :: FamilyInfo pass
OpenTypeFamily :: FamilyInfo pass

-- | <a>Nothing</a> if we're in an hs-boot file and the user said "type
--   family Foo x where .."
ClosedTypeFamily :: Maybe [LTyFamInstEqn pass] -> FamilyInfo pass

-- | Type Family Instance Declaration
data TyFamInstDecl pass
TyFamInstDecl :: XCTyFamInstDecl pass -> TyFamInstEqn pass -> TyFamInstDecl pass
[tfid_xtn] :: TyFamInstDecl pass -> XCTyFamInstDecl pass
[tfid_eqn] :: TyFamInstDecl pass -> TyFamInstEqn pass
XTyFamInstDecl :: !XXTyFamInstDecl pass -> TyFamInstDecl pass

-- | Located Type Family Instance Declaration
type LTyFamInstDecl pass = XRec pass TyFamInstDecl pass
instDeclDataFamInsts :: forall (p :: Pass). [LInstDecl (GhcPass p)] -> [DataFamInstDecl (GhcPass p)]

-- | Type family default declarations. A convenient synonym for
--   <a>TyFamInstDecl</a>. See <tt>Note [Type family instance declarations
--   in HsSyn]</tt>.
type TyFamDefltDecl = TyFamInstDecl

-- | Located type family default declarations.
type LTyFamDefltDecl pass = XRec pass TyFamDefltDecl pass

-- | Data Family Instance Declaration
newtype DataFamInstDecl pass
DataFamInstDecl :: FamEqn pass (HsDataDefn pass) -> DataFamInstDecl pass
[dfid_eqn] :: DataFamInstDecl pass -> FamEqn pass (HsDataDefn pass)

-- | Located Data Family Instance Declaration
type LDataFamInstDecl pass = XRec pass DataFamInstDecl pass
pprDataFamInstFlavour :: forall (p :: Pass). DataFamInstDecl (GhcPass p) -> SDoc
pprTyFamInstDecl :: forall (p :: Pass). OutputableBndrId p => TopLevelFlag -> TyFamInstDecl (GhcPass p) -> SDoc
pprHsFamInstLHS :: forall (p :: Pass). OutputableBndrId p => IdP (GhcPass p) -> HsOuterFamEqnTyVarBndrs (GhcPass p) -> HsFamEqnPats (GhcPass p) -> LexicalFixity -> Maybe (LHsContext (GhcPass p)) -> SDoc

-- | Family Equation
--   
--   One equation in a type family instance declaration, data family
--   instance declaration, or type family default. See Note [Type family
--   instance declarations in HsSyn] See Note [Family instance declaration
--   binders]
data FamEqn pass rhs
FamEqn :: XCFamEqn pass rhs -> LIdP pass -> HsOuterFamEqnTyVarBndrs pass -> HsFamEqnPats pass -> LexicalFixity -> rhs -> FamEqn pass rhs
[feqn_ext] :: FamEqn pass rhs -> XCFamEqn pass rhs
[feqn_tycon] :: FamEqn pass rhs -> LIdP pass

-- | Optional quantified type vars
[feqn_bndrs] :: FamEqn pass rhs -> HsOuterFamEqnTyVarBndrs pass
[feqn_pats] :: FamEqn pass rhs -> HsFamEqnPats pass

-- | Fixity used in the declaration
[feqn_fixity] :: FamEqn pass rhs -> LexicalFixity
[feqn_rhs] :: FamEqn pass rhs -> rhs
XFamEqn :: !XXFamEqn pass rhs -> FamEqn pass rhs

-- | Type Family Instance Equation
type TyFamInstEqn pass = FamEqn pass LHsType pass

-- | Located Type Family Instance Equation
type LTyFamInstEqn pass = XRec pass TyFamInstEqn pass

-- | HsFamEqnPats represents patterns on the left-hand side of a type
--   instance, e.g. `type instance F <tt>k (a :: k) = a` has patterns
--   `</tt>k` and `(a :: k)`.
--   
--   HsFamEqnPats used to be called HsTyPats but it was renamed to avoid
--   confusion with a different notion of type patterns, see #23657.
type HsFamEqnPats pass = [LHsTypeArg pass]

-- | Located Class Instance Declaration
type LClsInstDecl pass = XRec pass ClsInstDecl pass

-- | Class Instance Declaration
data ClsInstDecl pass
ClsInstDecl :: XCClsInstDecl pass -> LHsSigType pass -> LHsBinds pass -> [LSig pass] -> [LTyFamInstDecl pass] -> [LDataFamInstDecl pass] -> Maybe (XRec pass OverlapMode) -> ClsInstDecl pass
[cid_ext] :: ClsInstDecl pass -> XCClsInstDecl pass
[cid_poly_ty] :: ClsInstDecl pass -> LHsSigType pass
[cid_binds] :: ClsInstDecl pass -> LHsBinds pass
[cid_sigs] :: ClsInstDecl pass -> [LSig pass]
[cid_tyfam_insts] :: ClsInstDecl pass -> [LTyFamInstDecl pass]
[cid_datafam_insts] :: ClsInstDecl pass -> [LDataFamInstDecl pass]
[cid_overlap_mode] :: ClsInstDecl pass -> Maybe (XRec pass OverlapMode)
XClsInstDecl :: !XXClsInstDecl pass -> ClsInstDecl pass

-- | Stand-alone 'deriving instance' declaration
data DerivDecl pass
DerivDecl :: XCDerivDecl pass -> LHsSigWcType pass -> Maybe (LDerivStrategy pass) -> Maybe (XRec pass OverlapMode) -> DerivDecl pass
[deriv_ext] :: DerivDecl pass -> XCDerivDecl pass

-- | The instance type to derive.
--   
--   It uses an <a>LHsSigWcType</a> because the context is allowed to be a
--   single wildcard:
--   
--   <pre>
--   deriving instance _ =&gt; Eq (Foo a)
--   </pre>
--   
--   Which signifies that the context should be inferred.
[deriv_type] :: DerivDecl pass -> LHsSigWcType pass
[deriv_strategy] :: DerivDecl pass -> Maybe (LDerivStrategy pass)
[deriv_overlap_mode] :: DerivDecl pass -> Maybe (XRec pass OverlapMode)
XDerivDecl :: !XXDerivDecl pass -> DerivDecl pass

-- | Located stand-alone 'deriving instance' declaration
type LDerivDecl pass = XRec pass DerivDecl pass
type AnnDerivDecl = (EpToken "deriving", EpToken "instance")

-- | Which technique the user explicitly requested when deriving an
--   instance.
data DerivStrategy pass

-- | GHC's "standard" strategy, which is to implement a custom instance for
--   the data type. This only works for certain types that GHC knows about
--   (e.g., <a>Eq</a>, <a>Show</a>, <a>Functor</a> when
--   <tt>-XDeriveFunctor</tt> is enabled, etc.)
StockStrategy :: XStockStrategy pass -> DerivStrategy pass

-- | <pre>
--   -XDeriveAnyClass
--   </pre>
AnyclassStrategy :: XAnyClassStrategy pass -> DerivStrategy pass

-- | <pre>
--   -XGeneralizedNewtypeDeriving
--   </pre>
NewtypeStrategy :: XNewtypeStrategy pass -> DerivStrategy pass

-- | <pre>
--   -XDerivingVia
--   </pre>
ViaStrategy :: XViaStrategy pass -> DerivStrategy pass

-- | A <tt>Located</tt> <a>DerivStrategy</a>.
type LDerivStrategy pass = XRec pass DerivStrategy pass

-- | A short description of a <tt>DerivStrategy'</tt>.
derivStrategyName :: DerivStrategy a -> SDoc

-- | Eliminate a <a>DerivStrategy</a>.
foldDerivStrategy :: forall p (pass :: Pass) r. p ~ GhcPass pass => r -> (XViaStrategy p -> r) -> DerivStrategy p -> r

-- | Map over the <tt>via</tt> type if dealing with <a>ViaStrategy</a>.
--   Otherwise, return the <a>DerivStrategy</a> unchanged.
mapDerivStrategy :: forall p (pass :: Pass). p ~ GhcPass pass => (XViaStrategy p -> XViaStrategy p) -> DerivStrategy p -> DerivStrategy p
data XViaStrategyPs
XViaStrategyPs :: EpToken "via" -> LHsSigType GhcPs -> XViaStrategyPs

-- | Located Rule Declarations
type LRuleDecls pass = XRec pass RuleDecls pass

-- | Rule Declarations
data RuleDecls pass
HsRules :: XCRuleDecls pass -> [LRuleDecl pass] -> RuleDecls pass
[rds_ext] :: RuleDecls pass -> XCRuleDecls pass
[rds_rules] :: RuleDecls pass -> [LRuleDecl pass]
XRuleDecls :: !XXRuleDecls pass -> RuleDecls pass

-- | Rule Declaration
data RuleDecl pass
HsRule :: XHsRule pass -> XRec pass RuleName -> Activation -> Maybe [LHsTyVarBndr () (NoGhcTc pass)] -> [LRuleBndr pass] -> XRec pass (HsExpr pass) -> XRec pass (HsExpr pass) -> RuleDecl pass

-- | After renamer, free-vars from the LHS and RHS
[rd_ext] :: RuleDecl pass -> XHsRule pass

-- | Note [Pragma source text] in <a>GHC.Types.SourceText</a>
[rd_name] :: RuleDecl pass -> XRec pass RuleName
[rd_act] :: RuleDecl pass -> Activation

-- | Forall'd type vars
[rd_tyvs] :: RuleDecl pass -> Maybe [LHsTyVarBndr () (NoGhcTc pass)]

-- | Forall'd term vars, before typechecking; after typechecking this
--   includes all forall'd vars
[rd_tmvs] :: RuleDecl pass -> [LRuleBndr pass]
[rd_lhs] :: RuleDecl pass -> XRec pass (HsExpr pass)
[rd_rhs] :: RuleDecl pass -> XRec pass (HsExpr pass)
XRuleDecl :: !XXRuleDecl pass -> RuleDecl pass

-- | Located Rule Declaration
type LRuleDecl pass = XRec pass RuleDecl pass
data HsRuleRn
HsRuleRn :: NameSet -> NameSet -> HsRuleRn
data HsRuleAnn
HsRuleAnn :: Maybe (TokForall, EpToken ".") -> Maybe (TokForall, EpToken ".") -> EpToken "=" -> ActivationAnn -> HsRuleAnn
[ra_tyanns] :: HsRuleAnn -> Maybe (TokForall, EpToken ".")
[ra_tmanns] :: HsRuleAnn -> Maybe (TokForall, EpToken ".")
[ra_equal] :: HsRuleAnn -> EpToken "="
[ra_rest] :: HsRuleAnn -> ActivationAnn
data ActivationAnn
ActivationAnn :: EpToken "[" -> EpToken "]" -> Maybe (EpToken "~") -> Maybe EpaLocation -> ActivationAnn
[aa_openc] :: ActivationAnn -> EpToken "["
[aa_closec] :: ActivationAnn -> EpToken "]"
[aa_tilde] :: ActivationAnn -> Maybe (EpToken "~")
[aa_val] :: ActivationAnn -> Maybe EpaLocation

-- | Rule Binder
data RuleBndr pass
RuleBndr :: XCRuleBndr pass -> LIdP pass -> RuleBndr pass
RuleBndrSig :: XRuleBndrSig pass -> LIdP pass -> HsPatSigType pass -> RuleBndr pass
XRuleBndr :: !XXRuleBndr pass -> RuleBndr pass

-- | Located Rule Binder
type LRuleBndr pass = XRec pass RuleBndr pass
collectRuleBndrSigTys :: [RuleBndr pass] -> [HsPatSigType pass]
flattenRuleDecls :: forall (p :: Pass). [LRuleDecls (GhcPass p)] -> [LRuleDecl (GhcPass p)]
pprFullRuleName :: SourceText -> GenLocated a RuleName -> SDoc

-- | Default Declaration
data DefaultDecl pass
DefaultDecl :: XCDefaultDecl pass -> Maybe (LIdP pass) -> [LHsType pass] -> DefaultDecl pass
[defd_ext] :: DefaultDecl pass -> XCDefaultDecl pass
[defd_class] :: DefaultDecl pass -> Maybe (LIdP pass)
[defd_defaults] :: DefaultDecl pass -> [LHsType pass]
XDefaultDecl :: !XXDefaultDecl pass -> DefaultDecl pass

-- | Located Default Declaration
type LDefaultDecl pass = XRec pass DefaultDecl pass

-- | A splice can appear with various decorations wrapped around it. This
--   data type captures explicitly how it was originally written, for use
--   in the pretty printer.
data SpliceDecoration

-- | $splice
DollarSplice :: SpliceDecoration

-- | bare splice
BareSplice :: SpliceDecoration

-- | Splice Declaration
data SpliceDecl p
SpliceDecl :: XSpliceDecl p -> XRec p (HsUntypedSplice p) -> SpliceDecoration -> SpliceDecl p
XSpliceDecl :: !XXSpliceDecl p -> SpliceDecl p

-- | Located Splice Declaration
type LSpliceDecl pass = XRec pass SpliceDecl pass

-- | Foreign Declaration
data ForeignDecl pass
ForeignImport :: XForeignImport pass -> LIdP pass -> LHsSigType pass -> ForeignImport pass -> ForeignDecl pass
[fd_i_ext] :: ForeignDecl pass -> XForeignImport pass
[fd_name] :: ForeignDecl pass -> LIdP pass
[fd_sig_ty] :: ForeignDecl pass -> LHsSigType pass
[fd_fi] :: ForeignDecl pass -> ForeignImport pass
ForeignExport :: XForeignExport pass -> LIdP pass -> LHsSigType pass -> ForeignExport pass -> ForeignDecl pass
[fd_e_ext] :: ForeignDecl pass -> XForeignExport pass
[fd_name] :: ForeignDecl pass -> LIdP pass
[fd_sig_ty] :: ForeignDecl pass -> LHsSigType pass
[fd_fe] :: ForeignDecl pass -> ForeignExport pass
XForeignDecl :: !XXForeignDecl pass -> ForeignDecl pass

-- | Located Foreign Declaration
type LForeignDecl pass = XRec pass ForeignDecl pass
data ForeignImport pass
CImport :: XCImport pass -> XRec pass CCallConv -> XRec pass Safety -> Maybe Header -> CImportSpec -> ForeignImport pass
XForeignImport :: !XXForeignImport pass -> ForeignImport pass
data ForeignExport pass
CExport :: XCExport pass -> XRec pass CExportSpec -> ForeignExport pass
XForeignExport :: !XXForeignExport pass -> ForeignExport pass
data CImportSpec
CLabel :: CLabelString -> CImportSpec
CFunction :: CCallTarget -> CImportSpec
CWrapper :: CImportSpec

-- | <pre>
--   data T b = forall a. Eq a =&gt; MkT a b
--     MkT :: forall b a. Eq a =&gt; MkT a b
--   
--   data T b where
--        MkT1 :: Int -&gt; T Int
--   
--   data T = Int <tt>MkT</tt> Int
--          | MkT2
--   
--   data T a where
--        Int <tt>MkT</tt> Int :: T Int
--   </pre>
--   
--   data Constructor Declaration
data ConDecl pass
ConDeclGADT :: XConDeclGADT pass -> NonEmpty (LIdP pass) -> XRec pass (HsOuterSigTyVarBndrs pass) -> Maybe (LHsContext pass) -> HsConDeclGADTDetails pass -> LHsType pass -> Maybe (LHsDoc pass) -> ConDecl pass
[con_g_ext] :: ConDecl pass -> XConDeclGADT pass
[con_names] :: ConDecl pass -> NonEmpty (LIdP pass)

-- | The outermost type variable binders, be they explicit or implicit. The
--   <a>XRec</a> is used to anchor exact print annotations, AnnForall and
--   AnnDot.
[con_bndrs] :: ConDecl pass -> XRec pass (HsOuterSigTyVarBndrs pass)

-- | User-written context (if any)
[con_mb_cxt] :: ConDecl pass -> Maybe (LHsContext pass)

-- | Arguments; never infix
[con_g_args] :: ConDecl pass -> HsConDeclGADTDetails pass

-- | Result type
[con_res_ty] :: ConDecl pass -> LHsType pass

-- | A possible Haddock comment.
[con_doc] :: ConDecl pass -> Maybe (LHsDoc pass)
ConDeclH98 :: XConDeclH98 pass -> LIdP pass -> Bool -> [LHsTyVarBndr Specificity pass] -> Maybe (LHsContext pass) -> HsConDeclH98Details pass -> Maybe (LHsDoc pass) -> ConDecl pass
[con_ext] :: ConDecl pass -> XConDeclH98 pass
[con_name] :: ConDecl pass -> LIdP pass

-- | True <a>=</a> explicit user-written forall e.g. data T a = forall b.
--   MkT b (b-&gt;a) con_ex_tvs = {b} False =&gt; con_ex_tvs is empty
[con_forall] :: ConDecl pass -> Bool

-- | Existentials only
[con_ex_tvs] :: ConDecl pass -> [LHsTyVarBndr Specificity pass]

-- | User-written context (if any)
[con_mb_cxt] :: ConDecl pass -> Maybe (LHsContext pass)

-- | Arguments; can be infix
[con_args] :: ConDecl pass -> HsConDeclH98Details pass

-- | A possible Haddock comment.
[con_doc] :: ConDecl pass -> Maybe (LHsDoc pass)
XConDecl :: !XXConDecl pass -> ConDecl pass

-- | Located data Constructor Declaration
type LConDecl pass = XRec pass ConDecl pass

-- | The arguments in a Haskell98-style data constructor.
type HsConDeclH98Details pass = HsConDetails Void HsScaled pass LBangType pass XRec pass [LConDeclField pass]

-- | The arguments in a GADT constructor. Unlike Haskell98-style
--   constructors, GADT constructors cannot be declared with infix syntax.
--   As a result, we do not use <a>HsConDetails</a> here, as
--   <a>InfixCon</a> would be an unrepresentable state. (There is a notion
--   of infix GADT constructors for the purposes of derived Show
--   instances—see Note [Infix GADT constructors] in GHC.Tc.TyCl—but that
--   is an orthogonal concern.)
data HsConDeclGADTDetails pass
PrefixConGADT :: !XPrefixConGADT pass -> [HsScaled pass (LBangType pass)] -> HsConDeclGADTDetails pass
RecConGADT :: !XRecConGADT pass -> XRec pass [LConDeclField pass] -> HsConDeclGADTDetails pass
XConDeclGADTDetails :: !XXConDeclGADTDetails pass -> HsConDeclGADTDetails pass
data AnnConDeclH98
AnnConDeclH98 :: TokForall -> EpToken "." -> TokDarrow -> AnnConDeclH98
[acdh_forall] :: AnnConDeclH98 -> TokForall
[acdh_dot] :: AnnConDeclH98 -> EpToken "."
[acdh_darrow] :: AnnConDeclH98 -> TokDarrow
data AnnConDeclGADT
AnnConDeclGADT :: [EpToken "("] -> [EpToken ")"] -> TokDcolon -> AnnConDeclGADT
[acdg_openp] :: AnnConDeclGADT -> [EpToken "("]
[acdg_closep] :: AnnConDeclGADT -> [EpToken ")"]
[acdg_dcolon] :: AnnConDeclGADT -> TokDcolon
hsConDeclTheta :: forall (p :: Pass). Maybe (LHsContext (GhcPass p)) -> [LHsType (GhcPass p)]
getConNames :: ConDecl GhcRn -> [LocatedN Name]

-- | Return <tt><a>Just</a> fields</tt> if a data constructor declaration
--   uses record syntax (i.e., <a>RecCon</a>), where <tt>fields</tt> are
--   the field selectors. Otherwise, return <a>Nothing</a>.
getRecConArgs_maybe :: ConDecl GhcRn -> Maybe (LocatedL [LConDeclField GhcRn])

-- | Documentation comment Declaration
data DocDecl pass
DocCommentNext :: LHsDoc pass -> DocDecl pass
DocCommentPrev :: LHsDoc pass -> DocDecl pass
DocCommentNamed :: String -> LHsDoc pass -> DocDecl pass
DocGroup :: Int -> LHsDoc pass -> DocDecl pass

-- | Located Documentation comment Declaration
type LDocDecl pass = XRec pass DocDecl pass
docDeclDoc :: DocDecl pass -> LHsDoc pass

-- | Warning pragma Declaration
data WarnDecl pass
Warning :: XWarning pass -> [LIdP pass] -> WarningTxt pass -> WarnDecl pass
XWarnDecl :: !XXWarnDecl pass -> WarnDecl pass

-- | Located Warning pragma Declaration
type LWarnDecl pass = XRec pass WarnDecl pass

-- | Warning pragma Declarations
data WarnDecls pass
Warnings :: XWarnings pass -> [LWarnDecl pass] -> WarnDecls pass
[wd_ext] :: WarnDecls pass -> XWarnings pass
[wd_warnings] :: WarnDecls pass -> [LWarnDecl pass]
XWarnDecls :: !XXWarnDecls pass -> WarnDecls pass

-- | Located Warning Declarations
type LWarnDecls pass = XRec pass WarnDecls pass

-- | Annotation Declaration
data AnnDecl pass
HsAnnotation :: XHsAnnotation pass -> AnnProvenance pass -> XRec pass (HsExpr pass) -> AnnDecl pass
XAnnDecl :: !XXAnnDecl pass -> AnnDecl pass

-- | Located Annotation Declaration
type LAnnDecl pass = XRec pass AnnDecl pass

-- | Annotation Provenance
data AnnProvenance pass
ValueAnnProvenance :: LIdP pass -> AnnProvenance pass
TypeAnnProvenance :: LIdP pass -> AnnProvenance pass
ModuleAnnProvenance :: AnnProvenance pass
annProvenanceName_maybe :: UnXRec p => AnnProvenance p -> Maybe (IdP p)

-- | Role Annotation Declaration
data RoleAnnotDecl pass
RoleAnnotDecl :: XCRoleAnnotDecl pass -> LIdP pass -> [XRec pass (Maybe Role)] -> RoleAnnotDecl pass
XRoleAnnotDecl :: !XXRoleAnnotDecl pass -> RoleAnnotDecl pass

-- | Located Role Annotation Declaration
type LRoleAnnotDecl pass = XRec pass RoleAnnotDecl pass
roleAnnotDeclName :: forall (p :: Pass). RoleAnnotDecl (GhcPass p) -> IdP (GhcPass p)

-- | type Family Result Signature
data FamilyResultSig pass
NoSig :: XNoSig pass -> FamilyResultSig pass
KindSig :: XCKindSig pass -> LHsKind pass -> FamilyResultSig pass
TyVarSig :: XTyVarSig pass -> LHsTyVarBndr () pass -> FamilyResultSig pass
XFamilyResultSig :: !XXFamilyResultSig pass -> FamilyResultSig pass

-- | Located type Family Result Signature
type LFamilyResultSig pass = XRec pass FamilyResultSig pass

-- | If the user supplied an injectivity annotation it is represented using
--   InjectivityAnn. At the moment this is a single injectivity condition -
--   see Note [Injectivity annotation]. `Located name` stores the LHS of
--   injectivity condition. `[Located name]` stores the RHS of injectivity
--   condition. Example:
--   
--   type family Foo a b c = r | r -&gt; a c where ...
--   
--   This will be represented as "InjectivityAnn <tt>r</tt> [<tt>a</tt>,
--   <tt>c</tt>]"
data InjectivityAnn pass
InjectivityAnn :: XCInjectivityAnn pass -> LIdP pass -> [LIdP pass] -> InjectivityAnn pass
XInjectivityAnn :: !XXInjectivityAnn pass -> InjectivityAnn pass

-- | Located Injectivity Annotation
type LInjectivityAnn pass = XRec pass InjectivityAnn pass

-- | Maybe return name of the result type variable
resultVariableName :: forall (a :: Pass). FamilyResultSig (GhcPass a) -> Maybe (IdP (GhcPass a))
familyDeclLName :: forall (p :: Pass). FamilyDecl (GhcPass p) -> XRec (GhcPass p) (IdP (GhcPass p))
familyDeclName :: forall (p :: Pass). FamilyDecl (GhcPass p) -> IdP (GhcPass p)

-- | Haskell Group
--   
--   A <a>HsDecl</a> is categorised into a <a>HsGroup</a> before being fed
--   to the renamer.
data HsGroup p
HsGroup :: XCHsGroup p -> HsValBinds p -> [LSpliceDecl p] -> [TyClGroup p] -> [LDerivDecl p] -> [LFixitySig p] -> [LDefaultDecl p] -> [LForeignDecl p] -> [LWarnDecls p] -> [LAnnDecl p] -> [LRuleDecls p] -> [LDocDecl p] -> HsGroup p
[hs_ext] :: HsGroup p -> XCHsGroup p
[hs_valds] :: HsGroup p -> HsValBinds p
[hs_splcds] :: HsGroup p -> [LSpliceDecl p]
[hs_tyclds] :: HsGroup p -> [TyClGroup p]
[hs_derivds] :: HsGroup p -> [LDerivDecl p]
[hs_fixds] :: HsGroup p -> [LFixitySig p]
[hs_defds] :: HsGroup p -> [LDefaultDecl p]
[hs_fords] :: HsGroup p -> [LForeignDecl p]
[hs_warnds] :: HsGroup p -> [LWarnDecls p]
[hs_annds] :: HsGroup p -> [LAnnDecl p]
[hs_ruleds] :: HsGroup p -> [LRuleDecls p]
[hs_docs] :: HsGroup p -> [LDocDecl p]
XHsGroup :: !XXHsGroup p -> HsGroup p
emptyRdrGroup :: forall (p :: Pass). HsGroup (GhcPass p)
emptyRnGroup :: forall (p :: Pass). HsGroup (GhcPass p)
appendGroups :: forall (p :: Pass). HsGroup (GhcPass p) -> HsGroup (GhcPass p) -> HsGroup (GhcPass p)
hsGroupInstDecls :: HsGroup id -> [LInstDecl id]

-- | The fixity signatures for each top-level declaration and class method
--   in an <a>HsGroup</a>. See Note [Top-level fixity signatures in an
--   HsGroup]
hsGroupTopLevelFixitySigs :: forall (p :: Pass). HsGroup (GhcPass p) -> [LFixitySig (GhcPass p)]

-- | Partition a list of HsDecls into function/pattern bindings,
--   signatures, type family declarations, type family instances, and
--   documentation comments.
--   
--   Panics when given a declaration that cannot be put into any of the
--   output groups.
--   
--   The primary use of this function is to implement
--   <a>cvBindsAndSigs</a>.
partitionBindsAndSigs :: [LHsDecl GhcPs] -> (LHsBinds GhcPs, [LSig GhcPs], [LFamilyDecl GhcPs], [LTyFamInstDecl GhcPs], [LDataFamInstDecl GhcPs], [LDocDecl GhcPs])
instance GHC.Internal.Data.Data.Data GHC.Hs.Decls.AnnClassDecl
instance GHC.Internal.Data.Data.Data GHC.Hs.Decls.AnnClsInstDecl
instance GHC.Internal.Data.Data.Data GHC.Hs.Decls.AnnConDeclGADT
instance GHC.Internal.Data.Data.Data GHC.Hs.Decls.AnnConDeclH98
instance GHC.Internal.Data.Data.Data GHC.Hs.Decls.AnnDataDefn
instance GHC.Internal.Data.Data.Data GHC.Hs.Decls.AnnFamilyDecl
instance GHC.Internal.Data.Data.Data GHC.Hs.Decls.AnnSynDecl
instance GHC.Internal.Data.Data.Data GHC.Hs.Decls.DataDeclRn
instance GHC.Internal.Data.Data.Data GHC.Hs.Decls.HsRuleAnn
instance GHC.Internal.Data.Data.Data GHC.Hs.Decls.HsRuleRn
instance GHC.Classes.Eq GHC.Hs.Decls.HsRuleAnn
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Decls.AnnClassDecl
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Decls.AnnClsInstDecl
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Decls.AnnConDeclGADT
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Decls.AnnConDeclH98
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Decls.AnnDataDefn
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Decls.AnnFamilyDecl
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Decls.AnnSynDecl
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Decls.HsRuleAnn
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.AnnDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.ClsInstDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.ConDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.DataFamInstDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.DefaultDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.DerivClauseTys (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.DerivDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.DerivStrategy (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.DocDecl name)
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.FamilyDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.FamilyInfo pass)
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.ForeignDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.ForeignExport (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.ForeignImport (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.FunDep (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.HsDataDefn (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.HsDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.HsDerivingClause (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.HsGroup (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.InstDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Decls.NewOrData
instance GHC.Utils.Outputable.OutputableBndr (Language.Haskell.Syntax.Extension.IdP (GHC.Hs.Extension.GhcPass p)) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.RoleAnnotDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.RuleBndr (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.RuleDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.RuleDecls (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.SpliceDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Decls.SpliceDecoration
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.StandaloneKindSig (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.TyClDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.TyClGroup (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.TyFamInstDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.WarnDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.WarnDecls (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable GHC.Hs.Decls.XViaStrategyPs


-- | Abstract Haskell syntax for expressions.
module GHC.Hs.Expr
arrowToHsExpr :: HsArrowOf (LocatedA (HsExpr GhcRn)) GhcRn -> LocatedA (HsExpr GhcRn)

-- | Parenthesize an expression without token information
gHsPar :: forall (p :: Pass). IsPass p => LHsExpr (GhcPass p) -> HsExpr (GhcPass p)

-- | <tt><a>hsExprNeedsParens</a> p e</tt> returns <a>True</a> if the
--   expression <tt>e</tt> needs parentheses under precedence <tt>p</tt>.
hsExprNeedsParens :: forall (p :: Pass). IsPass p => PprPrec -> HsExpr (GhcPass p) -> Bool
hsLMatchPats :: forall (id :: Pass) body. LMatch (GhcPass id) body -> [LPat (GhcPass id)]
isAtomicHsExpr :: forall (p :: Pass). IsPass p => HsExpr (GhcPass p) -> Bool
isEmptyMatchGroup :: forall (p :: Pass) body. MatchGroup (GhcPass p) body -> Bool
isHsThingRnExpr :: HsThingRn -> Bool
isHsThingRnPat :: HsThingRn -> Bool
isHsThingRnStmt :: HsThingRn -> Bool
isQuietHsCmd :: HsCmd id -> Bool
isQuietHsExpr :: HsExpr id -> Bool

-- | Is there only one RHS in this list of matches?
isSingletonMatchGroup :: forall (p :: Pass) body. [LMatch (GhcPass p) body] -> Bool
lamCaseKeyword :: HsLamVariant -> SDoc
matchArrowContextErrString :: HsArrowMatchContext -> SDoc
matchContextErrString :: Outputable fn => HsMatchContext fn -> SDoc
matchDoContextErrString :: HsDoFlavour -> SDoc
matchGroupArity :: forall (id :: Pass) body. MatchGroup (GhcPass id) body -> Arity
matchSeparator :: HsMatchContext fn -> SDoc

-- | Build an expression using the extension constructor <a>XExpr</a>, and
--   the two components of the expansion: original expression and expanded
--   expressions.
mkExpandedExpr :: HsExpr GhcRn -> HsExpr GhcRn -> HsExpr GhcRn

-- | Build a <a>XXExprGhcRn</a> out of an extension constructor, and the
--   two components of the expansion: original and expanded typechecked
--   expressions.
mkExpandedExprTc :: HsExpr GhcRn -> HsExpr GhcTc -> HsExpr GhcTc
mkExpandedPatRn :: LPat GhcRn -> HsExpr GhcRn -> HsExpr GhcRn

-- | Build an expression using the extension constructor <a>XExpr</a>, and
--   the two components of the expansion: original do stmt and expanded
--   expression
mkExpandedStmt :: ExprLStmt GhcRn -> HsExpr GhcRn -> HsExpr GhcRn

-- | Build an expression using the extension constructor <a>XExpr</a>, and
--   the two components of the expansion: original do stmt and expanded
--   expression an associate with a provided location
mkExpandedStmtAt :: SrcSpanAnnA -> ExprLStmt GhcRn -> HsExpr GhcRn -> LHsExpr GhcRn

-- | Wrap the expanded version of the expression with a pop.
mkExpandedStmtPopAt :: SrcSpanAnnA -> ExprLStmt GhcRn -> HsExpr GhcRn -> LHsExpr GhcRn

-- | Build a <a>XXExprGhcRn</a> out of an extension constructor. The two
--   components of the expansion are: original statement and expanded
--   typechecked expression.
mkExpandedStmtTc :: ExprLStmt GhcRn -> HsExpr GhcTc -> HsExpr GhcTc

-- | Wrap a located expression with a <a>PopErrCtxt</a>
mkPopErrCtxtExpr :: LHsExpr GhcRn -> HsExpr GhcRn

-- | Wrap a located expression with a PopSrcExpr with an appropriate
--   location
mkPopErrCtxtExprAt :: SrcSpanAnnA -> LHsExpr GhcRn -> LHsExpr GhcRn

-- | Make a <a>SyntaxExpr</a> from a <a>Name</a> (the "rn" is because this
--   is used in the renamer).
mkRnSyntaxExpr :: Name -> SyntaxExprRn

-- | Make a 'SyntaxExpr GhcRn' from an expression Used only in
--   getMonadFailOp. See Note [Monad fail : Rebindable syntax, overloaded
--   strings] in <a>GHC.Rename.Expr</a>
mkSyntaxExpr :: HsExpr GhcRn -> SyntaxExprRn

-- | This is used for rebindable-syntax pieces that are too polymorphic for
--   tcSyntaxOp (trS_fmap and the mzip in ParStmt)
noExpr :: forall (p :: Pass). HsExpr (GhcPass p)
noSyntaxExpr :: forall (p :: Pass). IsPass p => SyntaxExpr (GhcPass p)

-- | <tt><a>parenthesizeHsExpr</a> p e</tt> checks if
--   <tt><a>hsExprNeedsParens</a> p e</tt> is true, and if so, surrounds
--   <tt>e</tt> with an <a>HsPar</a>. Otherwise, it simply returns
--   <tt>e</tt>.
parenthesizeHsExpr :: forall (p :: Pass). IsPass p => PprPrec -> LHsExpr (GhcPass p) -> LHsExpr (GhcPass p)
pp_dotdot :: SDoc
pp_rhs :: Outputable body => HsMatchContext fn -> body -> SDoc
pprAHsDoFlavour :: HsDoFlavour -> SDoc
pprAStmtContext :: Outputable fn => HsStmtContext fn -> SDoc
pprArg :: forall (idL :: Pass). OutputableBndrId idL => ApplicativeArg (GhcPass idL) -> SDoc
pprArrowExpr :: forall (p :: Pass) body. (OutputableBndrId p, Outputable body, Anno (StmtLR (GhcPass p) (GhcPass p) body) ~ SrcSpanAnnA) => [LStmt (GhcPass p) body] -> SDoc
pprArrowMatchContextNoun :: HsArrowMatchContext -> SDoc
pprArrowMatchContextNouns :: HsArrowMatchContext -> SDoc
pprBindStmt :: (Outputable pat, Outputable expr) => pat -> expr -> SDoc
pprBinds :: forall (idL :: Pass) (idR :: Pass). (OutputableBndrId idL, OutputableBndrId idR) => HsLocalBindsLR (GhcPass idL) (GhcPass idR) -> SDoc
pprBy :: Outputable body => Maybe body -> SDoc
pprCmd :: forall (p :: Pass). OutputableBndrId p => HsCmd (GhcPass p) -> SDoc
pprCmdArg :: forall (p :: Pass). OutputableBndrId p => HsCmdTop (GhcPass p) -> SDoc
pprComp :: forall (p :: Pass) body. (OutputableBndrId p, Outputable body, Anno (StmtLR (GhcPass p) (GhcPass p) body) ~ SrcSpanAnnA) => [LStmt (GhcPass p) body] -> SDoc
pprDebugParendExpr :: forall (p :: Pass). OutputableBndrId p => PprPrec -> LHsExpr (GhcPass p) -> SDoc
pprDo :: forall (p :: Pass) body. (OutputableBndrId p, Outputable body, Anno (StmtLR (GhcPass p) (GhcPass p) body) ~ SrcSpanAnnA) => HsDoFlavour -> [LStmt (GhcPass p) body] -> SDoc
pprExpr :: forall (p :: Pass). OutputableBndrId p => HsExpr (GhcPass p) -> SDoc
pprExternalSrcLoc :: (StringLiteral, (Int, Int), (Int, Int)) -> SDoc
pprFieldLabelStrings :: (UnXRec p, Outputable (XRec p FieldLabelString)) => FieldLabelStrings p -> SDoc
pprFunBind :: forall (idR :: Pass). OutputableBndrId idR => MatchGroup (GhcPass idR) (LHsExpr (GhcPass idR)) -> SDoc
pprGRHS :: forall (idR :: Pass) body fn. (OutputableBndrId idR, Outputable body) => HsMatchContext fn -> GRHS (GhcPass idR) body -> SDoc
pprGRHSs :: forall (idR :: Pass) body fn. (OutputableBndrId idR, Outputable body) => HsMatchContext fn -> GRHSs (GhcPass idR) body -> SDoc
pprHsArrType :: HsArrAppType -> SDoc
pprHsDoFlavour :: HsDoFlavour -> SDoc
pprLCmd :: forall (p :: Pass). OutputableBndrId p => LHsCmd (GhcPass p) -> SDoc
pprLExpr :: forall (p :: Pass). OutputableBndrId p => LHsExpr (GhcPass p) -> SDoc
pprMatch :: forall (idR :: Pass) body. (OutputableBndrId idR, Outputable body) => Match (GhcPass idR) body -> SDoc
pprMatchContext :: Outputable fn => HsMatchContext fn -> SDoc
pprMatchContextNoun :: Outputable fn => HsMatchContext fn -> SDoc
pprMatchContextNouns :: Outputable fn => HsMatchContext fn -> SDoc
pprMatchInCtxt :: forall (idR :: Pass) body. (OutputableBndrId idR, Outputable body) => Match (GhcPass idR) body -> SDoc
pprMatches :: forall (idR :: Pass) body. (OutputableBndrId idR, Outputable body) => MatchGroup (GhcPass idR) body -> SDoc
pprParendExpr :: forall (p :: Pass). OutputableBndrId p => PprPrec -> HsExpr (GhcPass p) -> SDoc
pprParendLExpr :: forall (p :: Pass). OutputableBndrId p => PprPrec -> LHsExpr (GhcPass p) -> SDoc
pprPatBind :: forall (bndr :: Pass) (p :: Pass). (OutputableBndrId bndr, OutputableBndrId p) => LPat (GhcPass bndr) -> GRHSs (GhcPass p) (LHsExpr (GhcPass p)) -> SDoc
pprPendingSplice :: forall (p :: Pass). OutputableBndrId p => SplicePointName -> LHsExpr (GhcPass p) -> SDoc
pprPrefixFastString :: FastString -> SDoc
pprQuals :: forall (p :: Pass) body. (OutputableBndrId p, Outputable body, Anno (StmtLR (GhcPass p) (GhcPass p) body) ~ SrcSpanAnnA) => [LStmt (GhcPass p) body] -> SDoc
pprStmt :: forall (idL :: Pass) (idR :: Pass) body. (OutputableBndrId idL, OutputableBndrId idR, Anno (StmtLR (GhcPass idL) (GhcPass idR) body) ~ SrcSpanAnnA, Outputable body) => StmtLR (GhcPass idL) (GhcPass idR) body -> SDoc
pprStmtCat :: forall (p :: Pass) body. IsPass p => Stmt (GhcPass p) body -> SDoc
pprStmtContext :: Outputable fn => HsStmtContext fn -> SDoc
pprStmtInCtxt :: forall (idL :: Pass) (idR :: Pass) fn body. (OutputableBndrId idL, OutputableBndrId idR, Outputable fn, Outputable body, Anno (StmtLR (GhcPass idL) (GhcPass idR) body) ~ SrcSpanAnnA) => HsStmtContext fn -> StmtLR (GhcPass idL) (GhcPass idR) body -> SDoc
pprTransStmt :: Outputable body => Maybe body -> body -> TransForm -> SDoc
pprTransformStmt :: forall (p :: Pass). OutputableBndrId p => [IdP (GhcPass p)] -> LHsExpr (GhcPass p) -> Maybe (LHsExpr (GhcPass p)) -> SDoc
pprTypedSplice :: forall (p :: Pass). OutputableBndrId p => Maybe SplicePointName -> LHsExpr (GhcPass p) -> SDoc
pprUntypedSplice :: forall (p :: Pass). OutputableBndrId p => Bool -> Maybe SplicePointName -> HsUntypedSplice (GhcPass p) -> SDoc
ppr_apps :: forall (p :: Pass). OutputableBndrId p => HsExpr (GhcPass p) -> [Either (LHsExpr (GhcPass p)) (LHsWcType (NoGhcTc (GhcPass p)))] -> SDoc
ppr_cmd :: forall (p :: Pass). OutputableBndrId p => HsCmd (GhcPass p) -> SDoc
ppr_do_stmts :: forall (idL :: Pass) (idR :: Pass) body. (OutputableBndrId idL, OutputableBndrId idR, Anno (StmtLR (GhcPass idL) (GhcPass idR) body) ~ SrcSpanAnnA, Outputable body) => [LStmtLR (GhcPass idL) (GhcPass idR) body] -> SDoc
ppr_expr :: forall (p :: Pass). OutputableBndrId p => HsExpr (GhcPass p) -> SDoc
ppr_infix_expr :: forall (p :: Pass). OutputableBndrId p => HsExpr (GhcPass p) -> Maybe SDoc
ppr_infix_expr_rn :: XXExprGhcRn -> Maybe SDoc
ppr_infix_expr_tc :: XXExprGhcTc -> Maybe SDoc
ppr_infix_hs_expansion :: HsThingRn -> Maybe SDoc
ppr_lcmd :: forall (p :: Pass). OutputableBndrId p => LHsCmd (GhcPass p) -> SDoc
ppr_lexpr :: forall (p :: Pass). OutputableBndrId p => LHsExpr (GhcPass p) -> SDoc
ppr_module_name_prefix :: Maybe ModuleName -> SDoc
ppr_quasi :: OutputableBndr p => p -> FastString -> SDoc
ppr_splice :: forall (p :: Pass). OutputableBndrId p => SDoc -> Maybe SplicePointName -> LHsExpr (GhcPass p) -> SDoc
ppr_with_pending_tc_splices :: SDoc -> [PendingTcSplice] -> SDoc
prependQualified :: Maybe ModuleName -> SDoc -> SDoc
stripParensHsExpr :: forall (p :: Pass). HsExpr (GhcPass p) -> HsExpr (GhcPass p)
stripParensLHsExpr :: forall (p :: Pass). LHsExpr (GhcPass p) -> LHsExpr (GhcPass p)
thBrackets :: SDoc -> SDoc -> SDoc
thTyBrackets :: SDoc -> SDoc
tupArgPresent :: forall (p :: Pass). HsTupArg (GhcPass p) -> Bool
tupArgPresent_maybe :: forall (p :: Pass). HsTupArg (GhcPass p) -> Maybe (LHsExpr (GhcPass p))
tupArgsPresent_maybe :: forall (p :: Pass). [HsTupArg (GhcPass p)] -> Maybe [LHsExpr (GhcPass p)]
data AnnArithSeq
AnnArithSeq :: EpToken "[" -> Maybe (EpToken ",") -> EpToken ".." -> EpToken "]" -> AnnArithSeq
[aas_open] :: AnnArithSeq -> EpToken "["
[aas_comma] :: AnnArithSeq -> Maybe (EpToken ",")
[aas_dotdot] :: AnnArithSeq -> EpToken ".."
[aas_close] :: AnnArithSeq -> EpToken "]"
data AnnExplicitSum
AnnExplicitSum :: EpaLocation -> [EpToken "|"] -> [EpToken "|"] -> EpaLocation -> AnnExplicitSum
[aesOpen] :: AnnExplicitSum -> EpaLocation
[aesBarsBefore] :: AnnExplicitSum -> [EpToken "|"]
[aesBarsAfter] :: AnnExplicitSum -> [EpToken "|"]
[aesClose] :: AnnExplicitSum -> EpaLocation
data AnnFieldLabel
AnnFieldLabel :: Maybe (EpToken ".") -> AnnFieldLabel
[afDot] :: AnnFieldLabel -> Maybe (EpToken ".")
data AnnFunRhs
AnnFunRhs :: EpToken "!" -> [EpToken "("] -> [EpToken ")"] -> AnnFunRhs
[afr_strict] :: AnnFunRhs -> EpToken "!"
[afr_opens] :: AnnFunRhs -> [EpToken "("]
[afr_closes] :: AnnFunRhs -> [EpToken ")"]
data AnnProjection
AnnProjection :: EpToken "(" -> EpToken ")" -> AnnProjection
[apOpen] :: AnnProjection -> EpToken "("
[apClose] :: AnnProjection -> EpToken ")"
data AnnTransStmt
AnnTransStmt :: EpToken "then" -> Maybe (EpToken "group") -> Maybe (EpToken "by") -> Maybe (EpToken "using") -> AnnTransStmt
[ats_then] :: AnnTransStmt -> EpToken "then"
[ats_group] :: AnnTransStmt -> Maybe (EpToken "group")
[ats_by] :: AnnTransStmt -> Maybe (EpToken "by")
[ats_using] :: AnnTransStmt -> Maybe (EpToken "using")
data AnnsIf
AnnsIf :: EpToken "if" -> EpToken "then" -> EpToken "else" -> Maybe (EpToken ";") -> Maybe (EpToken ";") -> AnnsIf
[aiIf] :: AnnsIf -> EpToken "if"
[aiThen] :: AnnsIf -> EpToken "then"
[aiElse] :: AnnsIf -> EpToken "else"
[aiThenSemi] :: AnnsIf -> Maybe (EpToken ";")
[aiElseSemi] :: AnnsIf -> Maybe (EpToken ";")

-- | Applicative Argument
data ApplicativeArg idL
ApplicativeArgOne :: XApplicativeArgOne idL -> LPat idL -> LHsExpr idL -> Bool -> ApplicativeArg idL

-- | The fail operator, after renaming
--   
--   The fail operator is needed if this is a BindStmt where the pattern
--   can fail. E.g.: (Just a) &lt;- stmt The fail operator will be invoked
--   if the pattern match fails. It is also used for guards in
--   MonadComprehensions. The fail operator is Nothing if the pattern match
--   can't fail
[xarg_app_arg_one] :: ApplicativeArg idL -> XApplicativeArgOne idL
[app_arg_pattern] :: ApplicativeArg idL -> LPat idL
[arg_expr] :: ApplicativeArg idL -> LHsExpr idL

-- | True <a>=</a> was a BodyStmt, False <a>=</a> was a BindStmt. See Note
--   [Applicative BodyStmt]
[is_body_stmt] :: ApplicativeArg idL -> Bool
ApplicativeArgMany :: XApplicativeArgMany idL -> [ExprLStmt idL] -> HsExpr idL -> LPat idL -> HsDoFlavour -> ApplicativeArg idL
[xarg_app_arg_many] :: ApplicativeArg idL -> XApplicativeArgMany idL
[app_stmts] :: ApplicativeArg idL -> [ExprLStmt idL]
[final_expr] :: ApplicativeArg idL -> HsExpr idL
[bv_pattern] :: ApplicativeArg idL -> LPat idL

-- | context of the do expression, used in pprArg
[stmt_context] :: ApplicativeArg idL -> HsDoFlavour
XApplicativeArg :: !XXApplicativeArg idL -> ApplicativeArg idL

-- | <a>ApplicativeStmt</a> represents an applicative expression built with
--   <a>&lt;$&gt;</a> and <a>&lt;*&gt;</a>. It is generated by the renamer,
--   and is desugared into the appropriate applicative expression by the
--   desugarer, but it is intended to be invisible in error messages.
--   
--   For full details, see Note [ApplicativeDo] in <a>GHC.Rename.Expr</a>
data ApplicativeStmt idL idR
ApplicativeStmt :: XApplicativeStmt idL idR -> [(SyntaxExpr idR, ApplicativeArg idL)] -> Maybe (SyntaxExpr idR) -> ApplicativeStmt idL idR
data BracketAnn noE hasE
BracketNoE :: noE -> BracketAnn noE hasE
BracketHasE :: hasE -> BracketAnn noE hasE

-- | Command Syntax Table (for Arrow syntax)
type CmdSyntaxTable p = [(Name, HsExpr p)]
data CmdTopTc
CmdTopTc :: Type -> Type -> CmdSyntaxTable GhcTc -> CmdTopTc
data DelayedSplice
DelayedSplice :: TcLclEnv -> LHsExpr GhcRn -> TcType -> LHsExpr GhcTc -> DelayedSplice
data EpAnnHsCase
EpAnnHsCase :: EpToken "case" -> EpToken "of" -> EpAnnHsCase
[hsCaseAnnCase] :: EpAnnHsCase -> EpToken "case"
[hsCaseAnnOf] :: EpAnnHsCase -> EpToken "of"
data EpAnnLam
EpAnnLam :: EpToken "\\" -> Maybe EpaLocation -> EpAnnLam

-- | Location of '\' keyword
[epl_lambda] :: EpAnnLam -> EpToken "\\"

-- | Location of 'case' or <tt>cases</tt> keyword, depending on related
--   <a>HsLamVariant</a>.
[epl_case] :: EpAnnLam -> Maybe EpaLocation
data EpAnnUnboundVar
EpAnnUnboundVar :: (EpToken "`", EpToken "`") -> EpToken "_" -> EpAnnUnboundVar
[hsUnboundBackquotes] :: EpAnnUnboundVar -> (EpToken "`", EpToken "`")
[hsUnboundHole] :: EpAnnUnboundVar -> EpToken "_"
data GrhsAnn
GrhsAnn :: Maybe (EpToken "|") -> Either (EpToken "=") TokRarrow -> GrhsAnn
[ga_vbar] :: GrhsAnn -> Maybe (EpToken "|")

-- | Match separator location, `=` or <tt>-&gt;</tt>
[ga_sep] :: GrhsAnn -> Either (EpToken "=") TokRarrow
data HsBracketTc
HsBracketTc :: HsQuote GhcRn -> Type -> Maybe QuoteWrapper -> [PendingTcSplice] -> HsBracketTc
[hsb_quote] :: HsBracketTc -> HsQuote GhcRn
[hsb_ty] :: HsBracketTc -> Type
[hsb_wrap] :: HsBracketTc -> Maybe QuoteWrapper
[hsb_splices] :: HsBracketTc -> [PendingTcSplice]
type HsMatchContextPs = HsMatchContext LIdP GhcPs
type HsMatchContextRn = HsMatchContext LIdP GhcRn

-- | Information about the parent of a record update:
--   
--   <ul>
--   <li>the parent type constructor or pattern synonym,</li>
--   <li>the relevant con-likes,</li>
--   <li>the field labels.</li>
--   </ul>
data family HsRecUpdParent x
type HsStmtContextRn = HsStmtContext LIdP GhcRn

-- | The different source constructs that we use to instantiate the
--   "original" field in an `XXExprGhcRn original expansion`
data HsThingRn
OrigExpr :: HsExpr GhcRn -> HsThingRn
OrigStmt :: ExprLStmt GhcRn -> HsThingRn
OrigPat :: LPat GhcRn -> HsThingRn
data HsUntypedSpliceResult thing
HsUntypedSpliceTop :: ThModFinalizers -> thing -> HsUntypedSpliceResult thing

-- | TH finalizers produced by the splice.
[utsplice_result_finalizers] :: HsUntypedSpliceResult thing -> ThModFinalizers

-- | The result of splicing; See Note [Lifecycle of a splice]
[utsplice_result] :: HsUntypedSpliceResult thing -> thing
HsUntypedSpliceNested :: SplicePointName -> HsUntypedSpliceResult thing

-- | HsWrap appears only in typechecker output
data HsWrap (hs_syn :: Type -> Type)
HsWrap :: HsWrapper -> hs_syn GhcTc -> HsWrap (hs_syn :: Type -> Type)
data MatchGroupTc
MatchGroupTc :: [Scaled Type] -> Type -> Origin -> MatchGroupTc
[mg_arg_tys] :: MatchGroupTc -> [Scaled Type]
[mg_res_ty] :: MatchGroupTc -> Type
[mg_origin] :: MatchGroupTc -> Origin

-- | Pending Renamer Splice
data PendingRnSplice
PendingRnSplice :: UntypedSpliceFlavour -> SplicePointName -> LHsExpr GhcRn -> PendingRnSplice

-- | Pending Type-checker Splice
data PendingTcSplice
PendingTcSplice :: SplicePointName -> LHsExpr GhcTc -> PendingTcSplice

-- | Post-Type checking Expression
--   
--   PostTcExpr is an evidence expression attached to the syntax tree by
--   the type checker (c.f. postTcType).
type PostTcExpr = HsExpr GhcTc

-- | Post-Type checking Table
--   
--   We use a PostTcTable where there are a bunch of pieces of evidence,
--   more than is convenient to keep individually.
type PostTcTable = [(Name, PostTcExpr)]
data RecStmtTc
RecStmtTc :: Type -> [PostTcExpr] -> [PostTcExpr] -> Type -> RecStmtTc
[recS_bind_ty] :: RecStmtTc -> Type
[recS_later_rets] :: RecStmtTc -> [PostTcExpr]
[recS_rec_rets] :: RecStmtTc -> [PostTcExpr]
[recS_ret_ty] :: RecStmtTc -> Type
type SplicePointName = Name
type family SyntaxExprGhc (p :: Pass) = (r :: Type) | r -> p

-- | The function to use in rebindable syntax. See Note [NoSyntaxExpr].
data SyntaxExprRn
SyntaxExprRn :: HsExpr GhcRn -> SyntaxExprRn
NoSyntaxExprRn :: SyntaxExprRn

-- | An expression with wrappers, used for rebindable syntax
--   
--   This should desugar to
--   
--   <pre>
--   syn_res_wrap $ syn_expr (syn_arg_wraps[0] arg0)
--                           (syn_arg_wraps[1] arg1) ...
--   </pre>
--   
--   where the actual arguments come from elsewhere in the AST.
data SyntaxExprTc
SyntaxExprTc :: HsExpr GhcTc -> [HsWrapper] -> HsWrapper -> SyntaxExprTc
[syn_expr] :: SyntaxExprTc -> HsExpr GhcTc
[syn_arg_wraps] :: SyntaxExprTc -> [HsWrapper]
[syn_res_wrap] :: SyntaxExprTc -> HsWrapper
NoSyntaxExprTc :: SyntaxExprTc

-- | Finalizers produced by a splice with <a>addModFinalizer</a>
--   
--   See Note [Delaying modFinalizers in untyped splices] in
--   GHC.Rename.Splice. For how this is used.
newtype ThModFinalizers
ThModFinalizers :: [ForeignRef (Q ())] -> ThModFinalizers
data UntypedSpliceFlavour
UntypedExpSplice :: UntypedSpliceFlavour
UntypedPatSplice :: UntypedSpliceFlavour
UntypedTypeSplice :: UntypedSpliceFlavour
UntypedDeclSplice :: UntypedSpliceFlavour
type family XApplicativeArgMany x
type family XApplicativeArgOne x
type family XApplicativeStmt x x'
data XBindStmtRn
XBindStmtRn :: SyntaxExpr GhcRn -> FailOperator GhcRn -> XBindStmtRn
[xbsrn_bindOp] :: XBindStmtRn -> SyntaxExpr GhcRn
[xbsrn_failOp] :: XBindStmtRn -> FailOperator GhcRn
data XBindStmtTc
XBindStmtTc :: SyntaxExpr GhcTc -> Type -> Mult -> FailOperator GhcTc -> XBindStmtTc
[xbstc_bindOp] :: XBindStmtTc -> SyntaxExpr GhcTc
[xbstc_boundResultType] :: XBindStmtTc -> Type
[xbstc_boundResultMult] :: XBindStmtTc -> Mult
[xbstc_failOp] :: XBindStmtTc -> FailOperator GhcTc
type family XXApplicativeArg x
data XXExprGhcRn
ExpandedThingRn :: HsThingRn -> HsExpr GhcRn -> XXExprGhcRn
[xrn_orig] :: XXExprGhcRn -> HsThingRn
[xrn_expanded] :: XXExprGhcRn -> HsExpr GhcRn
PopErrCtxt :: {-# UNPACK #-} !LHsExpr GhcRn -> XXExprGhcRn

-- | Variable pointing to record selector See Note [Non-overloaded record
--   field selectors] and Note [Record selectors in the AST]
HsRecSelRn :: FieldOcc GhcRn -> XXExprGhcRn
data XXExprGhcTc
WrapExpr :: HsWrapper -> HsExpr GhcTc -> XXExprGhcTc
ExpandedThingTc :: HsThingRn -> HsExpr GhcTc -> XXExprGhcTc
[xtc_orig] :: XXExprGhcTc -> HsThingRn
[xtc_expanded] :: XXExprGhcTc -> HsExpr GhcTc
ConLikeTc :: ConLike -> [TcTyVar] -> [Scaled TcType] -> XXExprGhcTc
HsTick :: CoreTickish -> LHsExpr GhcTc -> XXExprGhcTc
HsBinTick :: Int -> Int -> LHsExpr GhcTc -> XXExprGhcTc

-- | Variable pointing to record selector See Note [Non-overloaded record
--   field selectors] and Note [Record selectors in the AST]
HsRecSelTc :: FieldOcc GhcTc -> XXExprGhcTc
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.AnnArithSeq
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.AnnExplicitSum
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.AnnFieldLabel
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.AnnFunRhs
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.AnnProjection
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.AnnTransStmt
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.AnnsIf
instance (GHC.Internal.Data.Data.Data noE, GHC.Internal.Data.Data.Data hasE) => GHC.Internal.Data.Data.Data (GHC.Hs.Expr.BracketAnn noE hasE)
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.DelayedSplice
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.EpAnnHsCase
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.EpAnnLam
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.EpAnnUnboundVar
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.GrhsAnn
instance (GHC.Internal.Data.Data.Data (hs_syn GHC.Hs.Extension.GhcTc), GHC.Internal.Data.Typeable.Internal.Typeable hs_syn) => GHC.Internal.Data.Data.Data (GHC.Hs.Expr.HsWrap hs_syn)
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.MatchGroupTc
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.ThModFinalizers
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.UntypedSpliceFlavour
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Expr.AnnArithSeq
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Expr.AnnExplicitSum
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Expr.AnnFieldLabel
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Expr.AnnFunRhs
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Expr.AnnProjection
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Expr.AnnTransStmt
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Expr.AnnsIf
instance (GHC.Parser.Annotation.NoAnn n, GHC.Parser.Annotation.NoAnn h) => GHC.Parser.Annotation.NoAnn (GHC.Hs.Expr.BracketAnn n h)
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Expr.EpAnnHsCase
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Expr.EpAnnLam
instance GHC.Parser.Annotation.NoAnn GHC.Hs.Expr.GrhsAnn
instance (Language.Haskell.Syntax.Extension.UnXRec p, GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Extension.XRec p Language.Haskell.Syntax.Basic.FieldLabelString)) => GHC.Utils.Outputable.OutputableBndr (Language.Haskell.Syntax.Expr.FieldLabelStrings p)
instance (Language.Haskell.Syntax.Extension.UnXRec p, GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Extension.XRec p Language.Haskell.Syntax.Basic.FieldLabelString)) => GHC.Utils.Outputable.OutputableBndr (GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.Expr.FieldLabelStrings p))
instance GHC.Hs.Extension.OutputableBndrId idL => GHC.Utils.Outputable.Outputable (GHC.Hs.Expr.ApplicativeArg (GHC.Hs.Extension.GhcPass idL))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.ArithSeqInfo (GHC.Hs.Extension.GhcPass p))
instance Language.Haskell.Syntax.Extension.UnXRec p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.DotFieldOcc p)
instance (Language.Haskell.Syntax.Extension.UnXRec p, GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Extension.XRec p Language.Haskell.Syntax.Basic.FieldLabelString)) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.FieldLabelStrings p)
instance GHC.Utils.Outputable.Outputable GHC.Hs.Expr.GrhsAnn
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Expr.HsArrowMatchContext
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsCmd (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsCmdTop (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsExpr (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Expr.HsLamVariant
instance GHC.Utils.Outputable.Outputable fn => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsMatchContext fn)
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsPragE (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsQuote (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable fn => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsStmtContext fn)
instance GHC.Utils.Outputable.Outputable GHC.Hs.Expr.HsThingRn
instance (GHC.Hs.Extension.OutputableBndrId pr, GHC.Utils.Outputable.Outputable body) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.Match (GHC.Hs.Extension.GhcPass pr) body)
instance (GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.StmtLR (GHC.Hs.Extension.GhcPass idL) (GHC.Hs.Extension.GhcPass idL) (Language.Haskell.Syntax.Expr.LHsExpr (GHC.Hs.Extension.GhcPass idL))), GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Extension.XXParStmtBlock (GHC.Hs.Extension.GhcPass idL) (GHC.Hs.Extension.GhcPass idR))) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.ParStmtBlock (GHC.Hs.Extension.GhcPass idL) (GHC.Hs.Extension.GhcPass idR))
instance GHC.Utils.Outputable.Outputable GHC.Hs.Expr.PendingRnSplice
instance GHC.Utils.Outputable.Outputable GHC.Hs.Expr.PendingTcSplice
instance (GHC.Hs.Extension.OutputableBndrId pl, GHC.Hs.Extension.OutputableBndrId pr, Language.Haskell.Syntax.Extension.Anno (Language.Haskell.Syntax.Expr.StmtLR (GHC.Hs.Extension.GhcPass pl) (GHC.Hs.Extension.GhcPass pr) body) GHC.Types.~ GHC.Parser.Annotation.SrcSpanAnnA, GHC.Utils.Outputable.Outputable body) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.StmtLR (GHC.Hs.Extension.GhcPass pl) (GHC.Hs.Extension.GhcPass pr) body)
instance GHC.Utils.Outputable.Outputable GHC.Hs.Expr.SyntaxExprRn
instance GHC.Utils.Outputable.Outputable GHC.Hs.Expr.SyntaxExprTc
instance GHC.Utils.Outputable.Outputable GHC.Hs.Expr.XXExprGhcRn
instance GHC.Utils.Outputable.Outputable GHC.Hs.Expr.XXExprGhcTc
instance GHC.Parser.Annotation.HasAnnotation (Language.Haskell.Syntax.Extension.Anno a) => Language.Haskell.Syntax.Extension.WrapXRec (GHC.Hs.Extension.GhcPass p) a

module GHC.Hs.Instances
instance GHC.Internal.Data.Data.Data GHC.Hs.Binds.ABExport
instance GHC.Internal.Data.Data.Data GHC.Hs.Binds.AbsBinds
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.AnnDecl GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.AnnDecl GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.AnnDecl GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.AnnProvenance GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.AnnProvenance GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.AnnProvenance GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (GHC.Hs.Expr.ApplicativeArg GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (GHC.Hs.Expr.ApplicativeArg GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (GHC.Hs.Expr.ApplicativeArg GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (GHC.Hs.Expr.ApplicativeStmt GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (GHC.Hs.Expr.ApplicativeStmt GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (GHC.Hs.Expr.ApplicativeStmt GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (GHC.Hs.Expr.ApplicativeStmt GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (GHC.Hs.Expr.ApplicativeStmt GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (GHC.Hs.Expr.ApplicativeStmt GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (GHC.Hs.Expr.ApplicativeStmt GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (GHC.Hs.Expr.ApplicativeStmt GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (GHC.Hs.Expr.ApplicativeStmt GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.ArithSeqInfo GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.ArithSeqInfo GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.ArithSeqInfo GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.ClsInstDecl GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.ClsInstDecl GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.ClsInstDecl GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.CmdTopTc
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.ConDecl GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.ConDecl GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.ConDecl GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.ConDeclField GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.ConDeclField GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.ConDeclField GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data GHC.Hs.Pat.ConPatTc
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.DataFamInstDecl GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.DataFamInstDecl GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.DataFamInstDecl GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.DefaultDecl GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.DefaultDecl GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.DefaultDecl GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.DerivClauseTys GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.DerivClauseTys GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.DerivClauseTys GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.DerivDecl GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.DerivDecl GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.DerivDecl GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.DerivStrategy GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.DerivStrategy GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.DerivStrategy GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.DotFieldOcc GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.DotFieldOcc GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.DotFieldOcc GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data rhs => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.FamEqn GHC.Hs.Extension.GhcPs rhs)
instance GHC.Internal.Data.Data.Data rhs => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.FamEqn GHC.Hs.Extension.GhcRn rhs)
instance GHC.Internal.Data.Data.Data rhs => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.FamEqn GHC.Hs.Extension.GhcTc rhs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyDecl GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyDecl GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyDecl GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyInfo GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyInfo GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyInfo GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyResultSig GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyResultSig GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyResultSig GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.FieldLabelStrings GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.FieldLabelStrings GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.FieldLabelStrings GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.FieldOcc GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.FieldOcc GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.FieldOcc GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.FixitySig GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.FixitySig GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.FixitySig GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.ForeignDecl GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.ForeignDecl GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.ForeignDecl GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.ForeignExport GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.ForeignExport GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.ForeignExport GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.ForeignImport GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.ForeignImport GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.ForeignImport GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.FunDep GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.FunDep GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.FunDep GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.GRHS GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.GRHS GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.GRHS GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcTc)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.GRHS GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcPs)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.GRHS GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcRn)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.GRHS GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcTc)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.GRHSs GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.GRHSs GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.GRHSs GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcTc)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.GRHSs GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcPs)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.GRHSs GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcRn)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.GRHSs GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcTc)))
instance (GHC.Internal.Data.Data.Data a, GHC.Internal.Data.Data.Data b) => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsArg GHC.Hs.Extension.GhcPs a b)
instance (GHC.Internal.Data.Data.Data a, GHC.Internal.Data.Data.Data b) => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsArg GHC.Hs.Extension.GhcRn a b)
instance (GHC.Internal.Data.Data.Data a, GHC.Internal.Data.Data.Data b) => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsArg GHC.Hs.Extension.GhcTc a b)
instance GHC.Internal.Data.Data.Data Language.Haskell.Syntax.Expr.HsArrowMatchContext
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsArrowOf (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcPs)) GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsArrowOf (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcRn)) GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsArrowOf (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcTc)) GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsArrowOf (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)) GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsArrowOf (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)) GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsArrowOf (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcTc)) GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.HsBindLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.HsBindLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.HsBindLR GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.HsBindLR GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsBndrKind GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsBndrKind GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsBndrKind GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsBndrVar GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsBndrVar GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsBndrVar GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsBndrVis GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsBndrVis GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsBndrVis GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.HsBracketTc
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsCmdTop GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsCmdTop GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsCmdTop GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.HsConDeclGADTDetails GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.HsConDeclGADTDetails GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.HsConDeclGADTDetails GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Pat.HsConPatTyArg GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Pat.HsConPatTyArg GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Pat.HsConPatTyArg GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.HsDataDefn GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.HsDataDefn GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.HsDataDefn GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.HsDecl GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.HsDecl GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.HsDecl GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.HsDerivingClause GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.HsDerivingClause GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.HsDerivingClause GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcTc)
instance (GHC.Internal.Data.Data.Data a, GHC.Internal.Data.Data.Data b) => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Pat.HsFieldBind a b)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsForAllTelescope GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsForAllTelescope GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsForAllTelescope GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.HsGroup GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.HsGroup GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.HsGroup GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.HsIPBinds GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.HsIPBinds GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.HsIPBinds GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Lit.HsLit GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Lit.HsLit GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Lit.HsLit GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.HsLocalBindsLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.HsLocalBindsLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.HsLocalBindsLR GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.HsLocalBindsLR GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data fn => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsMatchContext fn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.HsMultAnn GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.HsMultAnn GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.HsMultAnn GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data flag => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsOuterTyVarBndrs flag GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data flag => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsOuterTyVarBndrs flag GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data flag => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsOuterTyVarBndrs flag GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Lit.HsOverLit GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Lit.HsOverLit GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Lit.HsOverLit GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsPatSigType GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsPatSigType GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsPatSigType GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.HsPatSynDir GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.HsPatSynDir GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.HsPatSynDir GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsPragE GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsPragE GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsPragE GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsQuote GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsQuote GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsQuote GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data body => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Pat.HsRecFields GHC.Hs.Extension.GhcPs body)
instance GHC.Internal.Data.Data.Data body => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Pat.HsRecFields GHC.Hs.Extension.GhcRn body)
instance GHC.Internal.Data.Data.Data body => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Pat.HsRecFields GHC.Hs.Extension.GhcTc body)
instance GHC.Internal.Data.Data.Data (GHC.Hs.Expr.HsRecUpdParent GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (GHC.Hs.Expr.HsRecUpdParent GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (GHC.Hs.Expr.HsRecUpdParent GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data thing => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsScaled GHC.Hs.Extension.GhcPs thing)
instance GHC.Internal.Data.Data.Data thing => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsScaled GHC.Hs.Extension.GhcRn thing)
instance GHC.Internal.Data.Data.Data thing => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsScaled GHC.Hs.Extension.GhcTc thing)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsSigType GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsSigType GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsSigType GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data fn => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsStmtContext fn)
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.HsThingRn
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsTupArg GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsTupArg GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsTupArg GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsTyLit GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsTyLit GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsTyLit GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsTyPat GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsTyPat GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsTyPat GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data flag => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsTyVarBndr flag GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data flag => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsTyVarBndr flag GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data flag => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsTyVarBndr flag GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsUntypedSplice GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsUntypedSplice GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.HsUntypedSplice GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Hs.Expr.HsUntypedSpliceResult a)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.HsValBindsLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.HsValBindsLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.HsValBindsLR GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.HsValBindsLR GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data thing => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsWildCardBndrs GHC.Hs.Extension.GhcPs thing)
instance GHC.Internal.Data.Data.Data thing => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsWildCardBndrs GHC.Hs.Extension.GhcRn thing)
instance GHC.Internal.Data.Data.Data thing => GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.HsWildCardBndrs GHC.Hs.Extension.GhcTc thing)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.ImpExp.IE GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.ImpExp.IE GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.ImpExp.IE GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.IPBind GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.IPBind GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.IPBind GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.ImpExp.ImportDecl GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.ImpExp.ImportDecl GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.ImpExp.ImportDecl GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.InjectivityAnn GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.InjectivityAnn GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.InjectivityAnn GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.InstDecl GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.InstDecl GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.InstDecl GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.LHsQTyVars GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.LHsQTyVars GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Type.LHsQTyVars GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.LHsRecUpdFields GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.LHsRecUpdFields GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.LHsRecUpdFields GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.Match GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.Match GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.Match GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcTc)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.Match GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcPs)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.Match GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcRn)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.Match GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcTc)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.MatchGroup GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.MatchGroup GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.MatchGroup GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcTc)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.MatchGroup GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcPs)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.MatchGroup GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcRn)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.MatchGroup GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcTc)))
instance GHC.Internal.Data.Data.Data (GHC.Hs.Binds.NHsValBindsLR GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (GHC.Hs.Binds.NHsValBindsLR GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (GHC.Hs.Binds.NHsValBindsLR GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data GHC.Hs.Lit.OverLitRn
instance GHC.Internal.Data.Data.Data GHC.Hs.Lit.OverLitTc
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.ParStmtBlock GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.ParStmtBlock GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.ParStmtBlock GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.ParStmtBlock GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Pat.Pat GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Pat.Pat GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Pat.Pat GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.PatSynBind GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.PatSynBind GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.PatSynBind GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.PatSynBind GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.PendingRnSplice
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.PendingTcSplice
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.RecStmtTc
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.RecordPatSynField GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.RecordPatSynField GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.RecordPatSynField GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.RoleAnnotDecl GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.RoleAnnotDecl GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.RoleAnnotDecl GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.RuleBndr GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.RuleBndr GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.RuleBndr GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.RuleDecl GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.RuleDecl GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.RuleDecl GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.RuleDecls GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.RuleDecls GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.RuleDecls GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.Sig GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.Sig GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Binds.Sig GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.SpliceDecl GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.SpliceDecl GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.SpliceDecl GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.StandaloneKindSig GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.StandaloneKindSig GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.StandaloneKindSig GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcTc)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcPs)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcRn)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcRn)))
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcTc)))
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.SyntaxExprRn
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.SyntaxExprTc
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.TyClDecl GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.TyClDecl GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.TyClDecl GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.TyClGroup GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.TyClGroup GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.TyClGroup GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.TyFamInstDecl GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.TyFamInstDecl GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.TyFamInstDecl GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.WarnDecl GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.WarnDecl GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.WarnDecl GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.WarnDecls GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.WarnDecls GHC.Hs.Extension.GhcRn)
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.Decls.WarnDecls GHC.Hs.Extension.GhcTc)
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.XBindStmtRn
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.XBindStmtTc
instance GHC.Internal.Data.Data.Data GHC.Hs.Decls.XViaStrategyPs
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.XXExprGhcRn
instance GHC.Internal.Data.Data.Data GHC.Hs.Expr.XXExprGhcTc
instance GHC.Internal.Data.Data.Data GHC.Hs.Pat.XXPatGhcTc
instance GHC.Classes.Eq (Language.Haskell.Syntax.ImpExp.IE GHC.Hs.Extension.GhcPs)
instance GHC.Classes.Eq (Language.Haskell.Syntax.ImpExp.IE GHC.Hs.Extension.GhcRn)
instance GHC.Classes.Eq (Language.Haskell.Syntax.ImpExp.IE GHC.Hs.Extension.GhcTc)

module GHC.Builtin.Types.Literals
tryInteractInertFam :: BuiltInSynFamily -> TyCon -> [Type] -> [Type] -> [(CoAxiomRule, TypeEqn)]
tryInteractTopFam :: BuiltInSynFamily -> TyCon -> [Type] -> Type -> [(CoAxiomRule, TypeEqn)]
tryMatchFam :: BuiltInSynFamily -> [Type] -> Maybe (CoAxiomRule, [Type], Type)
typeNatTyCons :: [TyCon]
typeNatCoAxiomRules :: UniqFM FastString CoAxiomRule
data BuiltInSynFamily
BuiltInSynFamily :: [BuiltInFamRewrite] -> [BuiltInFamInjectivity] -> BuiltInSynFamily
[sfMatchFam] :: BuiltInSynFamily -> [BuiltInFamRewrite]
[sfInteract] :: BuiltInSynFamily -> [BuiltInFamInjectivity]
typeNatAddTyCon :: TyCon
typeNatMulTyCon :: TyCon
typeNatExpTyCon :: TyCon
typeNatSubTyCon :: TyCon
typeNatDivTyCon :: TyCon
typeNatModTyCon :: TyCon
typeNatLogTyCon :: TyCon
typeNatCmpTyCon :: TyCon
typeSymbolCmpTyCon :: TyCon
typeSymbolAppendTyCon :: TyCon
typeCharCmpTyCon :: TyCon
typeConsSymbolTyCon :: TyCon
typeUnconsSymbolTyCon :: TyCon
typeCharToNatTyCon :: TyCon
typeNatToCharTyCon :: TyCon

module GHC.Core.FamInstEnv
data FamInst
FamInst :: CoAxiom Unbranched -> FamFlavor -> Name -> [RoughMatchTc] -> [TyVar] -> [CoVar] -> [Type] -> Type -> IsOrphan -> FamInst
[fi_axiom] :: FamInst -> CoAxiom Unbranched
[fi_flavor] :: FamInst -> FamFlavor
[fi_fam] :: FamInst -> Name
[fi_tcs] :: FamInst -> [RoughMatchTc]
[fi_tvs] :: FamInst -> [TyVar]
[fi_cvs] :: FamInst -> [CoVar]
[fi_tys] :: FamInst -> [Type]
[fi_rhs] :: FamInst -> Type
[fi_orphan] :: FamInst -> IsOrphan
data FamFlavor
SynFamilyInst :: FamFlavor
DataFamilyInst :: TyCon -> FamFlavor
famInstAxiom :: FamInst -> CoAxiom Unbranched
famInstTyCon :: FamInst -> TyCon
famInstRHS :: FamInst -> Type
famInstsRepTyCons :: [FamInst] -> [TyCon]
famInstRepTyCon_maybe :: FamInst -> Maybe TyCon
dataFamInstRepTyCon :: FamInst -> TyCon
pprFamInst :: FamInst -> SDoc
pprFamInsts :: [FamInst] -> SDoc
orphNamesOfFamInst :: FamInst -> NameSet
mkImportedFamInst :: Name -> [RoughMatchTc] -> CoAxiom Unbranched -> IsOrphan -> FamInst
mkLocalFamInst :: FamFlavor -> CoAxiom Unbranched -> [TyVar] -> [CoVar] -> [Type] -> Type -> FamInst
type FamInstEnvs = (FamInstEnv, FamInstEnv)
data FamInstEnv
emptyFamInstEnv :: FamInstEnv

-- | Create a <a>FamInstEnv</a> from <a>Name</a> indices. INVARIANTS: * The
--   fs_tvs are distinct in each FamInst of a range value of the map (so we
--   can safely unify them)
emptyFamInstEnvs :: (FamInstEnv, FamInstEnv)

-- | Makes no particular effort to detect conflicts.
unionFamInstEnv :: FamInstEnv -> FamInstEnv -> FamInstEnv
extendFamInstEnv :: FamInstEnv -> FamInst -> FamInstEnv
extendFamInstEnvList :: FamInstEnv -> [FamInst] -> FamInstEnv
famInstEnvElts :: FamInstEnv -> [FamInst]
famInstEnvSize :: FamInstEnv -> Int
familyInstances :: (FamInstEnv, FamInstEnv) -> TyCon -> [FamInst]
familyNameInstances :: (FamInstEnv, FamInstEnv) -> Name -> [FamInst]
mkCoAxBranch :: [TyVar] -> [TyVar] -> [CoVar] -> [Type] -> Type -> [Role] -> SrcSpan -> CoAxBranch
mkBranchedCoAxiom :: Name -> TyCon -> [CoAxBranch] -> CoAxiom Branched
mkUnbranchedCoAxiom :: Name -> TyCon -> CoAxBranch -> CoAxiom Unbranched
mkSingleCoAxiom :: Role -> Name -> [TyVar] -> [TyVar] -> [CoVar] -> TyCon -> [Type] -> Type -> CoAxiom Unbranched

-- | Create a coercion constructor (axiom) suitable for the given newtype
--   <a>TyCon</a>. The <a>Name</a> should be that of a new coercion
--   <a>CoAxiom</a>, the <a>TyVar</a>s the arguments expected by the
--   <tt>newtype</tt> and the type the appropriate right hand side of the
--   <tt>newtype</tt>, with the free variables a subset of those
--   <a>TyVar</a>s.
mkNewTypeCoAxiom :: Name -> TyCon -> [TyVar] -> [Role] -> Type -> CoAxiom Unbranched
data FamInstMatch
FamInstMatch :: FamInst -> [Type] -> [Coercion] -> FamInstMatch
[fim_instance] :: FamInstMatch -> FamInst
[fim_tys] :: FamInstMatch -> [Type]
[fim_cos] :: FamInstMatch -> [Coercion]
lookupFamInstEnv :: FamInstEnvs -> TyCon -> [Type] -> [FamInstMatch]
lookupFamInstEnvConflicts :: FamInstEnvs -> FamInst -> [FamInst]
lookupFamInstEnvByTyCon :: FamInstEnvs -> TyCon -> [FamInst]
isDominatedBy :: CoAxBranch -> [CoAxBranch] -> Bool

-- | Do an apartness check, as described in the "Closed Type Families"
--   paper (POPL '14). This should be used when determining if an equation
--   (<a>CoAxBranch</a>) of a closed type family can be used to reduce a
--   certain target type family application.
apartnessCheck :: [Type] -> CoAxBranch -> Bool
compatibleBranches :: CoAxBranch -> CoAxBranch -> Bool

-- | Result of testing two type family equations for injectiviy.
data InjectivityCheckResult

-- | Either RHSs are distinct or unification of RHSs leads to unification
--   of LHSs
InjectivityAccepted :: InjectivityCheckResult

-- | RHSs unify but LHSs don't unify under that substitution. Relevant for
--   closed type families where equation after unification might be
--   overlapped (in which case it is OK if they don't unify). Constructor
--   stores axioms after unification.
InjectivityUnified :: CoAxBranch -> CoAxBranch -> InjectivityCheckResult

-- | Check whether an open type family equation can be added to already
--   existing instance environment without causing conflicts with supplied
--   injectivity annotations. Returns list of conflicting axioms (type
--   instance declarations).
lookupFamInstEnvInjectivityConflicts :: [Bool] -> FamInstEnvs -> FamInst -> [CoAxBranch]

-- | Check whether two type family axioms don't violate injectivity
--   annotation.
injectiveBranches :: [Bool] -> CoAxBranch -> CoAxBranch -> InjectivityCheckResult
topNormaliseType :: FamInstEnvs -> Type -> Type

-- | Get rid of *outermost* (or toplevel) * type function redex * data
--   family redex * newtypes returning an appropriate Representational
--   coercion. Specifically, if topNormaliseType_maybe env ty = Just (co,
--   ty') then (a) co :: ty ~R ty' (b) ty' is not a newtype, and is not a
--   type-family or data-family redex
--   
--   However, ty' can be something like (Maybe (F ty)), where (F ty) is a
--   redex.
--   
--   Always operates homogeneously: the returned type has the same kind as
--   the original type, and the returned coercion is always homogeneous.
topNormaliseType_maybe :: FamInstEnvs -> Type -> Maybe Reduction
normaliseType :: FamInstEnvs -> Role -> Type -> Reduction
normaliseTcApp :: FamInstEnvs -> Role -> TyCon -> [Type] -> Reduction

-- | Try to simplify a type-family application, by *one* step If
--   topReduceTyFamApp_maybe env r F tys = Just (HetReduction (Reduction co
--   rhs) res_co) then co :: F tys ~R# rhs res_co :: typeKind(F tys) ~
--   typeKind(rhs) Type families and data families; always Representational
--   role
topReduceTyFamApp_maybe :: FamInstEnvs -> TyCon -> [Type] -> Maybe HetReduction
reduceTyFamApp_maybe :: FamInstEnvs -> Role -> TyCon -> [Type] -> Maybe Reduction
instance GHC.Internal.Base.Applicative GHC.Core.FamInstEnv.NormM
instance GHC.Internal.Base.Functor GHC.Core.FamInstEnv.NormM
instance GHC.Internal.Base.Monad GHC.Core.FamInstEnv.NormM
instance GHC.Types.Name.NamedThing GHC.Core.FamInstEnv.FamInst
instance GHC.Utils.Outputable.Outputable GHC.Core.FamInstEnv.FamInst
instance GHC.Utils.Outputable.Outputable GHC.Core.FamInstEnv.FamInstEnv
instance GHC.Utils.Outputable.Outputable GHC.Core.FamInstEnv.FamInstMatch

module GHC.Types.TypeEnv

-- | A map from <a>Name</a>s to <a>TyThing</a>s, constructed by
--   typechecking local declarations or interface files
type TypeEnv = NameEnv TyThing
emptyTypeEnv :: TypeEnv
lookupTypeEnv :: TypeEnv -> Name -> Maybe TyThing
mkTypeEnv :: [TyThing] -> TypeEnv
typeEnvFromEntities :: [Id] -> [TyCon] -> [PatSyn] -> [FamInst] -> TypeEnv
mkTypeEnvWithImplicits :: [TyThing] -> TypeEnv
extendTypeEnv :: TypeEnv -> TyThing -> TypeEnv
extendTypeEnvList :: TypeEnv -> [TyThing] -> TypeEnv
extendTypeEnvWithIds :: TypeEnv -> [Id] -> TypeEnv
plusTypeEnv :: TypeEnv -> TypeEnv -> TypeEnv
typeEnvElts :: TypeEnv -> [TyThing]
typeEnvTyCons :: TypeEnv -> [TyCon]
typeEnvIds :: TypeEnv -> [Id]
typeEnvPatSyns :: TypeEnv -> [PatSyn]
typeEnvDataCons :: TypeEnv -> [DataCon]
typeEnvCoAxioms :: TypeEnv -> [CoAxiom Branched]
typeEnvClasses :: TypeEnv -> [Class]

module GHC.Unit.Module.ModDetails

-- | The <a>ModDetails</a> is essentially a cache for information in the
--   <tt>ModIface</tt> for home modules only. Information relating to
--   packages will be loaded into global environments in
--   <tt>ExternalPackageState</tt>.
data ModDetails
ModDetails :: [AvailInfo] -> !TypeEnv -> !DefaultEnv -> InstEnv -> ![FamInst] -> ![CoreRule] -> ![Annotation] -> CompleteMatches -> ModDetails
[md_exports] :: ModDetails -> [AvailInfo]

-- | Local type environment for this particular module Includes Ids,
--   TyCons, PatSyns
[md_types] :: ModDetails -> !TypeEnv

-- | default declarations exported by this module
[md_defaults] :: ModDetails -> !DefaultEnv

-- | <tt>DFunId</tt>s for the instances in this module
[md_insts] :: ModDetails -> InstEnv
[md_fam_insts] :: ModDetails -> ![FamInst]

-- | Domain may include <tt>Id</tt>s from other modules
[md_rules] :: ModDetails -> ![CoreRule]

-- | Annotations present in this module: currently they only annotate
--   things also declared in this module
[md_anns] :: ModDetails -> ![Annotation]

-- | Complete match pragmas for this module
[md_complete_matches] :: ModDetails -> CompleteMatches

-- | Constructs an empty ModDetails
emptyModDetails :: ModDetails

module GHC.Types.Hint

-- | A type for hints emitted by GHC. A <i>hint</i> suggests a possible way
--   to deal with a particular warning or error.
data GhcHint

-- | An "unknown" hint. This type constructor allows arbitrary -- hints to
--   be embedded. The typical use case would be GHC plugins -- willing to
--   emit hints alongside their custom diagnostics.
UnknownHint :: a -> GhcHint

-- | Suggests adding a particular language extension. GHC will do its best
--   trying to guess when the user is using the syntax of a particular
--   language extension without having the relevant extension enabled.
--   
--   Example: If the user uses the keyword "mdo" (and we are in a monadic
--   block), but the relevant extension is not enabled, GHC will emit a
--   'SuggestExtension RecursiveDo'.
--   
--   Test case(s): parser<i>should_fail</i>T12429,
--   parser<i>should_fail</i>T8501c, parser<i>should_fail</i>T18251e, ...
--   (and many more)
SuggestExtension :: !LanguageExtensionHint -> GhcHint

-- | Suggests possible corrections of a misspelled pragma. Its argument
--   represents all applicable suggestions.
--   
--   Example: {-# LNGUAGE BangPatterns #-}
--   
--   Test case(s): parser<i>should_compile</i>T21589
SuggestCorrectPragmaName :: ![String] -> GhcHint

-- | Suggests that a monadic code block is probably missing a "do" keyword.
--   
--   Example: main = putStrLn "hello" putStrLn "world"
--   
--   Test case(s): parser<i>should_fail</i>T8501a,
--   parser<i>should_fail</i>readFail007,
--   parser<i>should_fail</i>InfixAppPatErr, parser<i>should_fail</i>T984
SuggestMissingDo :: GhcHint

-- | Suggests that a "let" expression is needed in a "do" block.
--   
--   Test cases: None (that explicitly test this particular hint is
--   emitted).
SuggestLetInDo :: GhcHint

-- | Suggests to add an ".hsig" signature file to the Cabal manifest.
--   
--   Triggered by: <a>DriverUnexpectedSignature</a>, if Cabal is being
--   used.
--   
--   Example: See comment of <tt>DriverUnexpectedSignature</tt>.
--   
--   Test case(s): driver/T12955
SuggestAddSignatureCabalFile :: !ModuleName -> GhcHint

-- | Suggests to explicitly list the instantiations for the signatures in
--   the GHC invocation command.
--   
--   Triggered by: <a>DriverUnexpectedSignature</a>, if Cabal is <i>not</i>
--   being used.
--   
--   Example: See comment of <tt>DriverUnexpectedSignature</tt>.
--   
--   Test case(s): driver/T12955
SuggestSignatureInstantiations :: !ModuleName -> [InstantiationSuggestion] -> GhcHint

-- | Suggests to use spaces instead of tabs.
--   
--   Triggered by: <a>PsWarnTab</a>.
--   
--   Examples: None Test Case(s): None
SuggestUseSpaces :: GhcHint

-- | Suggests adding a whitespace after the given symbol.
--   
--   Examples: None Test Case(s): parser<i>should_compile</i>T18834a.hs
SuggestUseWhitespaceAfter :: !OperatorWhitespaceSymbol -> GhcHint

-- | Suggests adding a whitespace around the given operator symbol, as it
--   might be repurposed as special syntax by a future language extension.
--   The second parameter is how such operator occurred, if in a prefix,
--   suffix or tight infix position.
--   
--   Triggered by: <a>PsWarnOperatorWhitespace</a>.
--   
--   Example: h a b = a+b -- not OK, no spaces around <a>+</a>.
--   
--   Test Case(s): parser<i>should_compile</i>T18834b.hs
SuggestUseWhitespaceAround :: !String -> !OperatorWhitespaceOccurrence -> GhcHint

-- | Suggests wrapping an expression in parentheses
--   
--   Examples: None Test Case(s): None
SuggestParentheses :: GhcHint

-- | Suggests to increase the -fmax-pmcheck-models limit for the pattern
--   match checker.
--   
--   Triggered by: <a>DsMaxPmCheckModelsReached</a>
--   
--   Test case(s): pmcheck<i>should_compile</i>TooManyDeltas
--   pmcheck<i>should_compile</i>TooManyDeltas
--   pmcheck<i>should_compile</i>T11822
SuggestIncreaseMaxPmCheckModels :: GhcHint

-- | Suggests adding a type signature, typically to resolve ambiguity or
--   help GHC inferring types.
SuggestAddTypeSignatures :: AvailableBindings -> GhcHint

-- | Suggests to explicitly discard the result of a monadic action by
--   binding the result to the '_' wilcard.
--   
--   Example: main = do _ &lt;- getCurrentTime
SuggestBindToWildcard :: !LHsExpr GhcTc -> GhcHint
SuggestAddInlineOrNoInlinePragma :: !Var -> !Activation -> GhcHint
SuggestAddPhaseToCompetingRule :: !RuleName -> GhcHint

-- | Suggests adding an identifier to the export list of a signature.
SuggestAddToHSigExportList :: !Name -> !Maybe Module -> GhcHint

-- | Suggests increasing the limit for the number of iterations in the
--   simplifier.
SuggestIncreaseSimplifierIterations :: GhcHint

-- | Suggests to explicitly import <a>Type</a> from the <a>Kind</a> module,
--   because using "*" to mean <a>Type</a> relies on the StarIsType
--   extension, which will become deprecated in the future.
--   
--   Triggered by: <a>PsWarnStarIsType</a> Example: None Test case(s):
--   wcompat-warnings/WCompatWarningsOn.hs
SuggestUseTypeFromDataKind :: Maybe RdrName -> GhcHint

-- | Suggests placing the <tt>qualified</tt> keyword <i>after</i> the
--   module name.
--   
--   Triggered by: <a>PsWarnImportPreQualified</a> Example: None Test
--   case(s): module/mod184.hs
SuggestQualifiedAfterModuleName :: GhcHint

-- | Suggests using TemplateHaskell quotation syntax.
--   
--   Triggered by: <a>PsErrEmptyDoubleQuotes</a> only if TemplateHaskell is
--   enabled. Example: None Test case(s):
--   parser<i>should_fail</i>T13450TH.hs
SuggestThQuotationSyntax :: GhcHint

-- | Suggests alternative roles in case we found an illegal one.
--   
--   Triggered by: <a>PsErrIllegalRoleName</a> Example: None Test case(s):
--   roles<i>should_fail</i>Roles7.hs
SuggestRoles :: [Role] -> GhcHint

-- | Suggests qualifying the <a>*</a> operator in modules where StarIsType
--   is enabled.
--   
--   Triggered by: <a>PsWarnStarBinder</a> Test case(s):
--   warnings<i>should_compile</i>StarBinder.hs
SuggestQualifyStarOperator :: GhcHint

-- | Suggests that for a type signature 'M.x :: ...' the qualifier should
--   be omitted in order to be accepted by GHC.
--   
--   Triggered by: <a>PsErrInvalidTypeSignature</a> Test case(s):
--   module/mod98
SuggestTypeSignatureRemoveQualifier :: GhcHint

-- | Suggests to move an orphan instance (for a typeclass or a type or data
--   family), or to newtype-wrap it.
--   
--   Triggered by: <a>TcRnOrphanInstance</a> Test cases(s):
--   warnings<i>should_compile</i>T9178 typecheck<i>should_compile</i>T4912
--   indexed-types<i>should_compile</i>T22717_fam_orph
SuggestFixOrphanInst :: Maybe FamFlavor -> GhcHint

-- | Whether this is a family instance (of the given <a>FamFlavor</a>), or
--   a class instance (<a>Nothing</a>).
[isFamilyInstance] :: GhcHint -> Maybe FamFlavor

-- | Suggests to use a standalone deriving declaration when GHC can't
--   derive a typeclass instance in a trivial way.
--   
--   Triggered by: <a>DerivBadErrConstructor</a> Test cases(s):
--   typecheck<i>should_fail</i>tcfail086
SuggestAddStandaloneDerivation :: GhcHint

-- | Suggests to add a standalone kind signature when GHC can't perform
--   kind inference.
--   
--   Triggered by: <a>TcRnInvisBndrWithoutSig</a> Test case(s):
--   typecheck<i>should_fail</i>T22560_fail_d
SuggestAddStandaloneKindSignature :: Name -> GhcHint

-- | Suggests the user to fill in the wildcard constraint to disambiguate
--   which constraint that is.
--   
--   Example: deriving instance _ =&gt; Eq (Foo f a)
--   
--   Triggered by: <a>DerivBadErrConstructor</a> Test cases(s):
--   partial-sigs<i>should_fail</i>T13324_fail2
SuggestFillInWildcardConstraint :: GhcHint

-- | Suggests to use the appropriate Template Haskell tick: a single tick
--   for a term-level <a>NameSpace</a>, or a double tick for a type-level
--   <a>NameSpace</a>.
--   
--   Triggered by: <a>TcRnIncorrectNameSpace</a>.
SuggestAppropriateTHTick :: NameSpace -> GhcHint

-- | Suggests enabling -ddump-splices to help debug an issue when a
--   <a>Name</a> is not in scope or is used in multiple different
--   namespaces (e.g. both as a data constructor and a type constructor).
--   
--   Concomitant with <tt>NoExactName</tt> or <tt>SameName</tt> errors, see
--   e.g. "GHC.Rename.Env.lookupExactOcc_either". Test cases: T5971, T7241,
--   T13937.
SuggestDumpSlices :: GhcHint

-- | Suggests adding a tick to refer to something which has been promoted
--   to the type level, e.g. a data constructor.
--   
--   Test cases: T9778, T19984.
SuggestAddTick :: UntickedPromotedThing -> GhcHint

-- | Something is split off from its corresponding declaration. For
--   example, a datatype is given a role declaration in a different module.
--   
--   Test cases: T495, T8485, T2713, T5533.
SuggestMoveToDeclarationSite :: SDoc -> RdrName -> GhcHint

-- | Suggest a similar name that the user might have meant, e.g. suggest
--   <a>traverse</a> when the user has written <tt>travrese</tt>.
--   
--   Test case: mod73.
SuggestSimilarNames :: RdrName -> NonEmpty SimilarName -> GhcHint

-- | Remind the user that the field selector has been suppressed because of
--   -XNoFieldSelectors.
--   
--   Test cases: NFSSuppressed, records-nofieldselectors.
RemindFieldSelectorSuppressed :: RdrName -> [Name] -> GhcHint
[suppressed_selector] :: GhcHint -> RdrName
[suppressed_parents] :: GhcHint -> [Name]

-- | Suggest importing from a module, removing a <tt>hiding</tt> clause, or
--   explain to the user that we couldn't find a module with the given
--   <a>ModuleName</a>.
--   
--   Test cases: mod28, mod36, mod87, mod114, ...
ImportSuggestion :: OccName -> ImportSuggestion -> GhcHint

-- | Found a pragma in the body of a module, suggest placing it in the
--   header.
SuggestPlacePragmaInHeader :: GhcHint

-- | Suggest using pattern matching syntax for a non-bidirectional pattern
--   synonym
--   
--   Test cases: patsyn<i>should_fail</i>record-exquant
--   typecheck<i>should_fail</i>T3176
SuggestPatternMatchingSyntax :: GhcHint

-- | Suggest tips for making a definition visible for the purpose of
--   writing a SPECIALISE pragma for it in a different module.
--   
--   Test cases: none
SuggestSpecialiseVisibilityHints :: Name -> GhcHint

-- | Suggest renaming implicitly quantified type variable in case it
--   captures a term's name.
SuggestRenameTypeVariable :: GhcHint
SuggestExplicitBidiPatSyn :: Name -> LPat GhcRn -> [LIdP GhcRn] -> GhcHint

-- | Suggest enabling one of the SafeHaskell modes Safe, Unsafe or
--   Trustworthy.
SuggestSafeHaskell :: GhcHint

-- | Suggest removing a record wildcard from a pattern when it doesn't bind
--   anything useful.
SuggestRemoveRecordWildcard :: GhcHint

-- | Suggest moving a method implementation to a different instance to its
--   superclass that defines the canonical version of the method.
SuggestMoveNonCanonicalDefinition :: Name -> Name -> String -> GhcHint

-- | Suggest to increase the solver maximum reduction depth
SuggestIncreaseReductionDepth :: GhcHint

-- | Suggest removing a method implementation when a superclass defines the
--   canonical version of that method.
SuggestRemoveNonCanonicalDefinition :: Name -> Name -> String -> GhcHint

-- | Suggest eta-reducing a type synonym used in the implementation of
--   abstract data.
SuggestEtaReduceAbsDataTySyn :: TyCon -> GhcHint

-- | Remind the user that there is no field of a type and name in the
--   record, constructors are in the usual order $x$, $r$, $a$
RemindRecordMissingField :: FastString -> Type -> Type -> GhcHint

-- | Suggest binding the type variable on the LHS of the type declaration
SuggestBindTyVarOnLhs :: RdrName -> GhcHint

-- | Suggest using an anonymous wildcard instead of a named wildcard
SuggestAnonymousWildcard :: GhcHint

-- | Suggest explicitly quantifying a type variable instead of relying on
--   implicit quantification
SuggestExplicitQuantification :: RdrName -> GhcHint

-- | Suggest binding explicitly; e.g data T @k (a :: F k) = ....
SuggestBindTyVarExplicitly :: Name -> GhcHint

-- | Suggest a default declaration; e.g <tt>default Cls (Ty1, Ty2)</tt>
SuggestDefaultDeclaration :: TyCon -> [Type] -> GhcHint

-- | Suggest using explicit deriving strategies for a deriving clause.
--   
--   Triggered by: <a>TcRnNoDerivingClauseStrategySpecified</a>.
--   
--   See comment of <tt>TcRnNoDerivingClauseStrategySpecified</tt> for
--   context.
SuggestExplicitDerivingClauseStrategies :: Map AssumedDerivingStrategy [LHsSigType GhcRn] -> GhcHint

-- | Suggest using an explicit deriving strategy for a standalone deriving
--   instance.
--   
--   Triggered by: <a>TcRnNoStandaloneDerivingStrategySpecified</a>.
--   
--   See comment of <tt>TcRnNoStandaloneDerivingStrategySpecified</tt> for
--   context.
SuggestExplicitStandaloneDerivingStrategy :: AssumedDerivingStrategy -> LHsSigWcType GhcRn -> GhcHint

-- | Suggest add parens to pattern `e -&gt; p :: t`
SuggestParenthesizePatternRHS :: GhcHint

-- | The bindings we have available in scope when suggesting an explicit
--   type signature.
data AvailableBindings
NamedBindings :: NonEmpty Name -> AvailableBindings

-- | An unknown binding (i.e. too complicated to turn into a <a>Name</a>)
UnnamedBinding :: AvailableBindings

-- | An <a>InstantiationSuggestion</a> for a '.hsig' file. This is
--   generated by GHC in case of a <tt>DriverUnexpectedSignature</tt> and
--   suggests a way to instantiate a particular signature, where the first
--   argument is the signature name and the second is the module where the
--   signature was defined. Example:
--   
--   src/MyStr.hsig:2:11: error: Unexpected signature: ‘MyStr’ (Try passing
--   -instantiated-with="MyStr=<a>MyStr</a>" replacing <a>MyStr</a> as
--   necessary.)
data InstantiationSuggestion
InstantiationSuggestion :: !ModuleName -> !Module -> InstantiationSuggestion
data LanguageExtensionHint

-- | Suggest to enable the input extension. This is the hint that GHC emits
--   if this is not a "known" fix, i.e. this is GHC giving its best guess
--   on what extension might be necessary to make a certain program
--   compile. For example, GHC might suggests to enable
--   <tt>BlockArguments</tt> when the user simply formatted incorrectly the
--   input program, so GHC here is trying to be as helpful as possible. If
--   the input <a>SDoc</a> is not empty, it will contain some extra
--   information about the why the extension is required, but it's totally
--   irrelevant/redundant for IDEs and other tools.
SuggestSingleExtension :: !SDoc -> !Extension -> LanguageExtensionHint

-- | Suggest to enable the input extensions. The list is to be intended as
--   <i>disjunctive</i> i.e. the user is suggested to enable <i>any</i> of
--   the extensions listed. If the input <a>SDoc</a> is not empty, it will
--   contain some extra information about the why the extensions are
--   required, but it's totally irrelevant/redundant for IDEs and other
--   tools.
SuggestAnyExtension :: !SDoc -> [Extension] -> LanguageExtensionHint

-- | Suggest to enable the input extensions. The list is to be intended as
--   <i>conjunctive</i> i.e. the user is suggested to enable <i>all</i> the
--   extensions listed. If the input <a>SDoc</a> is not empty, it will
--   contain some extra information about the why the extensions are
--   required, but it's totally irrelevant/redundant for IDEs and other
--   tools.
SuggestExtensions :: !SDoc -> [Extension] -> LanguageExtensionHint

-- | Suggest to enable the input extension in order to fix a certain
--   problem. This is the suggestion that GHC emits when is more-or-less
--   clear "what's going on". For example, if both <tt>DeriveAnyClass</tt>
--   and <tt>GeneralizedNewtypeDeriving</tt> are turned on, the right thing
--   to do is to enabled <tt>DerivingStrategies</tt>, so in contrast to
--   <a>SuggestSingleExtension</a> GHC will be a bit more "imperative"
--   (i.e. "Use X Y Z in order to ... "). If the input <a>SDoc</a> is not
--   empty, it will contain some extra information about the why the
--   extensions are required, but it's totally irrelevant/redundant for
--   IDEs and other tools.
SuggestExtensionInOrderTo :: !SDoc -> !Extension -> LanguageExtensionHint

-- | Suggest how to fix an import.
data ImportSuggestion

-- | Some module exports what we want, but we aren't explicitly importing
--   it.
CouldImportFrom :: NonEmpty (Module, ImportedModsVal) -> ImportSuggestion

-- | Some module exports what we want, but we are explicitly hiding it.
CouldUnhideFrom :: NonEmpty (Module, ImportedModsVal) -> ImportSuggestion

-- | The module exports what we want, but it isn't a type.
CouldRemoveTypeKeyword :: ModuleName -> ImportSuggestion

-- | The module exports what we want, but it's a type and we have
--   <tt>ExplicitNamespaces</tt> on.
CouldAddTypeKeyword :: ModuleName -> ImportSuggestion

-- | Suggest importing a data constructor to bring it into scope
ImportDataCon :: Maybe (ModuleName, Bool) -> OccName -> ImportSuggestion

-- | Where to suggest importing the <tt>DataCon</tt> from.
--   
--   The <a>Bool</a> tracks whether to suggest using an import of the form
--   <tt>import (pattern Foo)</tt>, depending on whether
--   <tt>-XPatternSynonyms</tt> was enabled.
[ies_suggest_import_from] :: ImportSuggestion -> Maybe (ModuleName, Bool)

-- | The <a>OccName</a> of the parent of the data constructor.
[ies_parent] :: ImportSuggestion -> OccName

-- | Explain how something is in scope.
data HowInScope

-- | It was locally bound at this particular source location.
LocallyBoundAt :: SrcSpan -> HowInScope

-- | It was imported by this particular import declaration.
ImportedBy :: ImpDeclSpec -> HowInScope
data SimilarName
SimilarName :: Name -> SimilarName
SimilarRdrName :: RdrName -> Maybe HowInScope -> SimilarName

-- | Whether <a>*</a> is a synonym for <a>Type</a>.
data StarIsType
StarIsNotType :: StarIsType
StarIsType :: StarIsType

-- | Something is promoted to the type-level without a promotion tick.
data UntickedPromotedThing
UntickedConstructor :: LexicalFixity -> Name -> UntickedPromotedThing
UntickedExplicitList :: UntickedPromotedThing

-- | The deriving strategy that was assumed when not explicitly listed in
--   the source. This is used solely by the missing-deriving-strategies
--   warning. There's no <tt>Via</tt> case because we never assume that.
data AssumedDerivingStrategy
AssumedStockStrategy :: AssumedDerivingStrategy
AssumedAnyclassStrategy :: AssumedDerivingStrategy
AssumedNewtypeStrategy :: AssumedDerivingStrategy
pprUntickedConstructor :: LexicalFixity -> Name -> SDoc

-- | Whether a constructor name is printed out as a bare symbol, e.g.
--   <tt>:</tt>.
--   
--   True for symbolic names in infix position.
--   
--   Used for pretty-printing.
isBareSymbol :: LexicalFixity -> Name -> Bool

-- | Suggests a single extension without extra user info.
suggestExtension :: Extension -> GhcHint

-- | Like <a>suggestExtension</a> but allows supplying extra info for the
--   user.
suggestExtensionWithInfo :: SDoc -> Extension -> GhcHint

-- | Suggests to enable <i>every</i> extension in the list.
suggestExtensions :: [Extension] -> GhcHint

-- | Like <a>suggestExtensions</a> but allows supplying extra info for the
--   user.
suggestExtensionsWithInfo :: SDoc -> [Extension] -> GhcHint

-- | Suggests to enable <i>any</i> extension in the list.
suggestAnyExtension :: [Extension] -> GhcHint

-- | Like <a>suggestAnyExtension</a> but allows supplying extra info for
--   the user.
suggestAnyExtensionWithInfo :: SDoc -> [Extension] -> GhcHint
useExtensionInOrderTo :: SDoc -> Extension -> GhcHint

-- | Display info about the treatment of <a>*</a> under NoStarIsType.
--   
--   With StarIsType, three properties of <a>*</a> hold:
--   
--   (a) it is not an infix operator (b) it is always in scope (c) it is a
--   synonym for Data.Kind.Type
--   
--   However, the user might not know that they are working on a module
--   with NoStarIsType and write code that still assumes (a), (b), and (c),
--   which actually do not hold in that module.
--   
--   Violation of (a) shows up in the parser. For instance, in the
--   following examples, we have <a>*</a> not applied to enough arguments:
--   
--   data A :: * data F :: * -&gt; *
--   
--   Violation of (b) or (c) show up in the renamer and the typechecker
--   respectively. For instance:
--   
--   type K = Either * Bool
--   
--   This will parse differently depending on whether StarIsType is
--   enabled, but it will parse nonetheless. With NoStarIsType it is parsed
--   as a type operator, thus we have ((*) Either Bool). Now there are two
--   cases to consider:
--   
--   <ol>
--   <li>There is no definition of (*) in scope. In this case the renamer
--   will fail to look it up. This is a violation of assumption (b).</li>
--   <li>There is a definition of the (*) type operator in scope (for
--   example coming from GHC.TypeNats). In this case the user will get a
--   kind mismatch error. This is a violation of assumption (c).</li>
--   </ol>
--   
--   The user might unknowingly be working on a module with NoStarIsType or
--   use <a>*</a> as <a>Type</a> out of habit. So it is important to give a
--   hint whenever an assumption about <a>*</a> is violated. Unfortunately,
--   it is somewhat difficult to deal with (c), so we limit ourselves to
--   (a) and (b).
--   
--   <a>noStarIsTypeHints</a> returns appropriate hints to the user
--   depending on the extensions enabled in the module and the name that
--   triggered the error. That is, if we have NoStarIsType and the error is
--   related to <a>*</a> or its Unicode variant, we will suggest using
--   <a>Type</a>; otherwise we won't suggest anything.
noStarIsTypeHints :: StarIsType -> RdrName -> [GhcHint]
instance GHC.Classes.Eq GHC.Types.Hint.AssumedDerivingStrategy
instance GHC.Classes.Ord GHC.Types.Hint.AssumedDerivingStrategy
instance GHC.Utils.Outputable.Outputable GHC.Types.Hint.AssumedDerivingStrategy

module GHC.Types.Hint.Ppr
perhapsAsPat :: SDoc
instance GHC.Utils.Outputable.Outputable GHC.Types.Hint.GhcHint

module GHC.Types.Error

-- | A collection of messages emitted by GHC during error reporting. A
--   diagnostic message is typically a warning or an error. See Note
--   [Messages].
--   
--   <i>INVARIANT</i>: All the messages in this collection must be
--   relevant, i.e. their <a>Severity</a> should <i>not</i> be
--   <a>SevIgnore</a>. The smart constructor <a>mkMessages</a> will filter
--   out any message which <a>Severity</a> is <a>SevIgnore</a>.
data Messages e
mkMessages :: Bag (MsgEnvelope e) -> Messages e
getMessages :: Messages e -> Bag (MsgEnvelope e)
emptyMessages :: Messages e
isEmptyMessages :: Messages e -> Bool
singleMessage :: MsgEnvelope e -> Messages e

-- | Adds a <tt>Message</tt> to the input collection of messages. See Note
--   [Discarding Messages].
addMessage :: MsgEnvelope e -> Messages e -> Messages e

-- | Joins two collections of messages together. See Note [Discarding
--   Messages].
unionMessages :: Messages e -> Messages e -> Messages e

-- | Joins many <a>Messages</a>s together
unionManyMessages :: Foldable f => f (Messages e) -> Messages e
filterMessages :: (MsgEnvelope e -> Bool) -> Messages e -> Messages e

-- | An envelope for GHC's facts about a running program, parameterised
--   over the <i>domain-specific</i> (i.e. parsing, typecheck-renaming,
--   etc) diagnostics.
--   
--   To say things differently, GHC emits <i>diagnostics</i> about the
--   running program, each of which is wrapped into a <a>MsgEnvelope</a>
--   that carries specific information like where the error happened, etc.
--   Finally, multiple <a>MsgEnvelope</a>s are aggregated into
--   <a>Messages</a> that are returned to the user.
data MsgEnvelope e
MsgEnvelope :: SrcSpan -> NamePprCtx -> e -> Severity -> ResolvedDiagnosticReason -> MsgEnvelope e

-- | The SrcSpan is used for sorting errors into line-number order
[errMsgSpan] :: MsgEnvelope e -> SrcSpan
[errMsgContext] :: MsgEnvelope e -> NamePprCtx
[errMsgDiagnostic] :: MsgEnvelope e -> e
[errMsgSeverity] :: MsgEnvelope e -> Severity

-- | The actual reason caused this message
--   
--   See Note [Warnings controlled by multiple flags]
[errMsgReason] :: MsgEnvelope e -> ResolvedDiagnosticReason

-- | The class for a diagnostic message. The main purpose is to classify a
--   message within GHC, to distinguish it from a debug/dump message vs a
--   proper diagnostic, for which we include a <a>DiagnosticReason</a>.
data MessageClass
MCOutput :: MessageClass
MCFatal :: MessageClass
MCInteractive :: MessageClass

-- | Log message intended for compiler developers No file/line/column stuff
MCDump :: MessageClass

-- | Log messages intended for end users. No file/line/column stuff.
MCInfo :: MessageClass

-- | Diagnostics from the compiler. This constructor is very powerful as it
--   allows the construction of a <a>MessageClass</a> with a completely
--   arbitrary permutation of <a>Severity</a> and <a>DiagnosticReason</a>.
--   As such, users are encouraged to use the <tt>mkMCDiagnostic</tt> smart
--   constructor instead. Use this constructor directly only if you need to
--   construct and manipulate diagnostic messages directly, for example
--   inside <a>Error</a>. In all the other circumstances, <i>especially</i>
--   when emitting compiler diagnostics, use the smart constructor.
--   
--   The <tt>Maybe <a>DiagnosticCode</a></tt> field carries a code (if
--   available) for this diagnostic. If you are creating a message not tied
--   to any error-message type, then use Nothing. In the long run, this
--   really should always have a <a>DiagnosticCode</a>. See Note
--   [Diagnostic codes].
MCDiagnostic :: Severity -> ResolvedDiagnosticReason -> Maybe DiagnosticCode -> MessageClass

-- | Used to describe warnings and errors o The message has a
--   file/line/column heading, plus "warning:" or "error:", added by
--   mkLocMessage o With <a>SevIgnore</a> the message is suppressed o
--   Output is intended for end users
data Severity

-- | Ignore this message, for example in case of suppression of warnings
--   users don't want to see. See Note [Suppressing Messages]
SevIgnore :: Severity
SevWarning :: Severity
SevError :: Severity

-- | A class identifying a diagnostic. Dictionary.com defines a diagnostic
--   as:
--   
--   "a message output by a computer diagnosing an error in a computer
--   program, computer system, or component device".
--   
--   A <a>Diagnostic</a> carries the <i>actual</i> description of the
--   message (which, in GHC's case, it can be an error or a warning) and
--   the <i>reason</i> why such message was generated in the first place.
class HasDefaultDiagnosticOpts DiagnosticOpts a => Diagnostic a where {
    
    -- | Type of configuration options for the diagnostic.
    type DiagnosticOpts a;
}

-- | Extract the error message text from a <a>Diagnostic</a>.
diagnosticMessage :: Diagnostic a => DiagnosticOpts a -> a -> DecoratedSDoc

-- | Extract the reason for this diagnostic. For warnings, a
--   <a>DiagnosticReason</a> includes the warning flag.
diagnosticReason :: Diagnostic a => a -> DiagnosticReason

-- | Extract any hints a user might use to repair their code to avoid this
--   diagnostic.
diagnosticHints :: Diagnostic a => a -> [GhcHint]

-- | Get the <a>DiagnosticCode</a> associated with this <a>Diagnostic</a>.
--   This can return <a>Nothing</a> for at least two reasons:
--   
--   <ol>
--   <li>The message might be from a plugin that does not supply
--   codes.</li>
--   <li>The message might not yet have been assigned a code. See the
--   <a>Diagnostic</a> instance for <a>DiagnosticMessage</a>.</li>
--   </ol>
--   
--   Ideally, case (2) would not happen, but because some errors in GHC
--   still use the old system of just writing the error message in-place
--   (instead of using a dedicated error type and constructor), we do not
--   have error codes for all errors. #18516 tracks our progress toward
--   this goal.
diagnosticCode :: Diagnostic a => a -> Maybe DiagnosticCode

-- | An existential wrapper around an unknown diagnostic.
data UnknownDiagnostic opts
[UnknownDiagnostic] :: forall a opts. (Diagnostic a, Typeable a) => (opts -> DiagnosticOpts a) -> a -> UnknownDiagnostic opts

-- | Make a "simple" unknown diagnostic which doesn't have any
--   configuration options.
mkSimpleUnknownDiagnostic :: (Diagnostic a, Typeable a, DiagnosticOpts a ~ NoDiagnosticOpts) => a -> UnknownDiagnostic b

-- | Make an unknown diagnostic which uses the same options as the context
--   it will be embedded into.
mkUnknownDiagnostic :: (Typeable a, Diagnostic a) => a -> UnknownDiagnostic (DiagnosticOpts a)

-- | Embed a more complicated diagnostic which requires a potentially
--   different options type.
embedUnknownDiagnostic :: (Diagnostic a, Typeable a) => (opts -> DiagnosticOpts a) -> a -> UnknownDiagnostic opts

-- | A generic <a>Diagnostic</a> message, without any further
--   classification or provenance: By looking at a <a>DiagnosticMessage</a>
--   we don't know neither <i>where</i> it was generated nor how to
--   interpret its payload (as it's just a structured document). All we can
--   do is to print it out and look at its <a>DiagnosticReason</a>.
data DiagnosticMessage
DiagnosticMessage :: !DecoratedSDoc -> !DiagnosticReason -> [GhcHint] -> DiagnosticMessage
[diagMessage] :: DiagnosticMessage -> !DecoratedSDoc
[diagReason] :: DiagnosticMessage -> !DiagnosticReason
[diagHints] :: DiagnosticMessage -> [GhcHint]

-- | The reason <i>why</i> a <a>Diagnostic</a> was emitted in the first
--   place. Diagnostic messages are born within GHC with a very precise
--   reason, which can be completely statically-computed (i.e. this is an
--   error or a warning no matter what), or influenced by the specific
--   state of the <tt>DynFlags</tt> at the moment of the creation of a new
--   <a>Diagnostic</a>. For example, a parsing error is <i>always</i> going
--   to be an error, whereas a 'WarningWithoutFlag Opt_WarnUnusedImports'
--   might turn into an error due to '-Werror' or
--   '-Werror=warn-unused-imports'. Interpreting a <a>DiagnosticReason</a>
--   together with its associated <a>Severity</a> gives us the full
--   picture.
data DiagnosticReason

-- | Born as a warning.
WarningWithoutFlag :: DiagnosticReason

-- | Warning was enabled with the flag.
WarningWithFlags :: !NonEmpty WarningFlag -> DiagnosticReason

-- | Warning was enabled with a custom category.
WarningWithCategory :: !WarningCategory -> DiagnosticReason

-- | Born as an error.
ErrorWithoutFlag :: DiagnosticReason

-- | The single warning case <a>DiagnosticReason</a> is very common.
pattern WarningWithFlag :: WarningFlag -> DiagnosticReason

-- | Like a <a>DiagnosticReason</a>, but resolved against a specific set of
--   <tt>DynFlags</tt> to work out which warning flag actually enabled this
--   warning.
newtype ResolvedDiagnosticReason
ResolvedDiagnosticReason :: DiagnosticReason -> ResolvedDiagnosticReason
[resolvedDiagnosticReason] :: ResolvedDiagnosticReason -> DiagnosticReason

-- | A generic <tt>Hint</tt> message, to be used with
--   <a>DiagnosticMessage</a>.
data DiagnosticHint
DiagnosticHint :: !SDoc -> DiagnosticHint
mkPlainDiagnostic :: DiagnosticReason -> [GhcHint] -> SDoc -> DiagnosticMessage

-- | Create an error <a>DiagnosticMessage</a> holding just a single
--   <a>SDoc</a>
mkPlainError :: [GhcHint] -> SDoc -> DiagnosticMessage

-- | Create a <a>DiagnosticMessage</a> from a list of bulleted SDocs and a
--   <a>DiagnosticReason</a>
mkDecoratedDiagnostic :: DiagnosticReason -> [GhcHint] -> [SDoc] -> DiagnosticMessage

-- | Create an error <a>DiagnosticMessage</a> from a list of bulleted SDocs
mkDecoratedError :: [GhcHint] -> [SDoc] -> DiagnosticMessage
pprDiagnostic :: Diagnostic e => e -> SDoc
class HasDefaultDiagnosticOpts opts
defaultOpts :: HasDefaultDiagnosticOpts opts => opts
defaultDiagnosticOpts :: HasDefaultDiagnosticOpts (DiagnosticOpts opts) => DiagnosticOpts opts
data NoDiagnosticOpts
NoDiagnosticOpts :: NoDiagnosticOpts

-- | A type for hints emitted by GHC. A <i>hint</i> suggests a possible way
--   to deal with a particular warning or error.
data GhcHint

-- | An "unknown" hint. This type constructor allows arbitrary -- hints to
--   be embedded. The typical use case would be GHC plugins -- willing to
--   emit hints alongside their custom diagnostics.
UnknownHint :: a -> GhcHint

-- | Suggests adding a particular language extension. GHC will do its best
--   trying to guess when the user is using the syntax of a particular
--   language extension without having the relevant extension enabled.
--   
--   Example: If the user uses the keyword "mdo" (and we are in a monadic
--   block), but the relevant extension is not enabled, GHC will emit a
--   'SuggestExtension RecursiveDo'.
--   
--   Test case(s): parser<i>should_fail</i>T12429,
--   parser<i>should_fail</i>T8501c, parser<i>should_fail</i>T18251e, ...
--   (and many more)
SuggestExtension :: !LanguageExtensionHint -> GhcHint

-- | Suggests possible corrections of a misspelled pragma. Its argument
--   represents all applicable suggestions.
--   
--   Example: {-# LNGUAGE BangPatterns #-}
--   
--   Test case(s): parser<i>should_compile</i>T21589
SuggestCorrectPragmaName :: ![String] -> GhcHint

-- | Suggests that a monadic code block is probably missing a "do" keyword.
--   
--   Example: main = putStrLn "hello" putStrLn "world"
--   
--   Test case(s): parser<i>should_fail</i>T8501a,
--   parser<i>should_fail</i>readFail007,
--   parser<i>should_fail</i>InfixAppPatErr, parser<i>should_fail</i>T984
SuggestMissingDo :: GhcHint

-- | Suggests that a "let" expression is needed in a "do" block.
--   
--   Test cases: None (that explicitly test this particular hint is
--   emitted).
SuggestLetInDo :: GhcHint

-- | Suggests to add an ".hsig" signature file to the Cabal manifest.
--   
--   Triggered by: <a>DriverUnexpectedSignature</a>, if Cabal is being
--   used.
--   
--   Example: See comment of <tt>DriverUnexpectedSignature</tt>.
--   
--   Test case(s): driver/T12955
SuggestAddSignatureCabalFile :: !ModuleName -> GhcHint

-- | Suggests to explicitly list the instantiations for the signatures in
--   the GHC invocation command.
--   
--   Triggered by: <a>DriverUnexpectedSignature</a>, if Cabal is <i>not</i>
--   being used.
--   
--   Example: See comment of <tt>DriverUnexpectedSignature</tt>.
--   
--   Test case(s): driver/T12955
SuggestSignatureInstantiations :: !ModuleName -> [InstantiationSuggestion] -> GhcHint

-- | Suggests to use spaces instead of tabs.
--   
--   Triggered by: <a>PsWarnTab</a>.
--   
--   Examples: None Test Case(s): None
SuggestUseSpaces :: GhcHint

-- | Suggests adding a whitespace after the given symbol.
--   
--   Examples: None Test Case(s): parser<i>should_compile</i>T18834a.hs
SuggestUseWhitespaceAfter :: !OperatorWhitespaceSymbol -> GhcHint

-- | Suggests adding a whitespace around the given operator symbol, as it
--   might be repurposed as special syntax by a future language extension.
--   The second parameter is how such operator occurred, if in a prefix,
--   suffix or tight infix position.
--   
--   Triggered by: <a>PsWarnOperatorWhitespace</a>.
--   
--   Example: h a b = a+b -- not OK, no spaces around <a>+</a>.
--   
--   Test Case(s): parser<i>should_compile</i>T18834b.hs
SuggestUseWhitespaceAround :: !String -> !OperatorWhitespaceOccurrence -> GhcHint

-- | Suggests wrapping an expression in parentheses
--   
--   Examples: None Test Case(s): None
SuggestParentheses :: GhcHint

-- | Suggests to increase the -fmax-pmcheck-models limit for the pattern
--   match checker.
--   
--   Triggered by: <a>DsMaxPmCheckModelsReached</a>
--   
--   Test case(s): pmcheck<i>should_compile</i>TooManyDeltas
--   pmcheck<i>should_compile</i>TooManyDeltas
--   pmcheck<i>should_compile</i>T11822
SuggestIncreaseMaxPmCheckModels :: GhcHint

-- | Suggests adding a type signature, typically to resolve ambiguity or
--   help GHC inferring types.
SuggestAddTypeSignatures :: AvailableBindings -> GhcHint

-- | Suggests to explicitly discard the result of a monadic action by
--   binding the result to the '_' wilcard.
--   
--   Example: main = do _ &lt;- getCurrentTime
SuggestBindToWildcard :: !LHsExpr GhcTc -> GhcHint
SuggestAddInlineOrNoInlinePragma :: !Var -> !Activation -> GhcHint
SuggestAddPhaseToCompetingRule :: !RuleName -> GhcHint

-- | Suggests adding an identifier to the export list of a signature.
SuggestAddToHSigExportList :: !Name -> !Maybe Module -> GhcHint

-- | Suggests increasing the limit for the number of iterations in the
--   simplifier.
SuggestIncreaseSimplifierIterations :: GhcHint

-- | Suggests to explicitly import <a>Type</a> from the <a>Kind</a> module,
--   because using "*" to mean <a>Type</a> relies on the StarIsType
--   extension, which will become deprecated in the future.
--   
--   Triggered by: <a>PsWarnStarIsType</a> Example: None Test case(s):
--   wcompat-warnings/WCompatWarningsOn.hs
SuggestUseTypeFromDataKind :: Maybe RdrName -> GhcHint

-- | Suggests placing the <tt>qualified</tt> keyword <i>after</i> the
--   module name.
--   
--   Triggered by: <a>PsWarnImportPreQualified</a> Example: None Test
--   case(s): module/mod184.hs
SuggestQualifiedAfterModuleName :: GhcHint

-- | Suggests using TemplateHaskell quotation syntax.
--   
--   Triggered by: <a>PsErrEmptyDoubleQuotes</a> only if TemplateHaskell is
--   enabled. Example: None Test case(s):
--   parser<i>should_fail</i>T13450TH.hs
SuggestThQuotationSyntax :: GhcHint

-- | Suggests alternative roles in case we found an illegal one.
--   
--   Triggered by: <a>PsErrIllegalRoleName</a> Example: None Test case(s):
--   roles<i>should_fail</i>Roles7.hs
SuggestRoles :: [Role] -> GhcHint

-- | Suggests qualifying the <a>*</a> operator in modules where StarIsType
--   is enabled.
--   
--   Triggered by: <a>PsWarnStarBinder</a> Test case(s):
--   warnings<i>should_compile</i>StarBinder.hs
SuggestQualifyStarOperator :: GhcHint

-- | Suggests that for a type signature 'M.x :: ...' the qualifier should
--   be omitted in order to be accepted by GHC.
--   
--   Triggered by: <a>PsErrInvalidTypeSignature</a> Test case(s):
--   module/mod98
SuggestTypeSignatureRemoveQualifier :: GhcHint

-- | Suggests to move an orphan instance (for a typeclass or a type or data
--   family), or to newtype-wrap it.
--   
--   Triggered by: <a>TcRnOrphanInstance</a> Test cases(s):
--   warnings<i>should_compile</i>T9178 typecheck<i>should_compile</i>T4912
--   indexed-types<i>should_compile</i>T22717_fam_orph
SuggestFixOrphanInst :: Maybe FamFlavor -> GhcHint

-- | Whether this is a family instance (of the given <a>FamFlavor</a>), or
--   a class instance (<a>Nothing</a>).
[isFamilyInstance] :: GhcHint -> Maybe FamFlavor

-- | Suggests to use a standalone deriving declaration when GHC can't
--   derive a typeclass instance in a trivial way.
--   
--   Triggered by: <a>DerivBadErrConstructor</a> Test cases(s):
--   typecheck<i>should_fail</i>tcfail086
SuggestAddStandaloneDerivation :: GhcHint

-- | Suggests to add a standalone kind signature when GHC can't perform
--   kind inference.
--   
--   Triggered by: <a>TcRnInvisBndrWithoutSig</a> Test case(s):
--   typecheck<i>should_fail</i>T22560_fail_d
SuggestAddStandaloneKindSignature :: Name -> GhcHint

-- | Suggests the user to fill in the wildcard constraint to disambiguate
--   which constraint that is.
--   
--   Example: deriving instance _ =&gt; Eq (Foo f a)
--   
--   Triggered by: <a>DerivBadErrConstructor</a> Test cases(s):
--   partial-sigs<i>should_fail</i>T13324_fail2
SuggestFillInWildcardConstraint :: GhcHint

-- | Suggests to use the appropriate Template Haskell tick: a single tick
--   for a term-level <a>NameSpace</a>, or a double tick for a type-level
--   <a>NameSpace</a>.
--   
--   Triggered by: <a>TcRnIncorrectNameSpace</a>.
SuggestAppropriateTHTick :: NameSpace -> GhcHint

-- | Suggests enabling -ddump-splices to help debug an issue when a
--   <a>Name</a> is not in scope or is used in multiple different
--   namespaces (e.g. both as a data constructor and a type constructor).
--   
--   Concomitant with <tt>NoExactName</tt> or <tt>SameName</tt> errors, see
--   e.g. "GHC.Rename.Env.lookupExactOcc_either". Test cases: T5971, T7241,
--   T13937.
SuggestDumpSlices :: GhcHint

-- | Suggests adding a tick to refer to something which has been promoted
--   to the type level, e.g. a data constructor.
--   
--   Test cases: T9778, T19984.
SuggestAddTick :: UntickedPromotedThing -> GhcHint

-- | Something is split off from its corresponding declaration. For
--   example, a datatype is given a role declaration in a different module.
--   
--   Test cases: T495, T8485, T2713, T5533.
SuggestMoveToDeclarationSite :: SDoc -> RdrName -> GhcHint

-- | Suggest a similar name that the user might have meant, e.g. suggest
--   <a>traverse</a> when the user has written <tt>travrese</tt>.
--   
--   Test case: mod73.
SuggestSimilarNames :: RdrName -> NonEmpty SimilarName -> GhcHint

-- | Remind the user that the field selector has been suppressed because of
--   -XNoFieldSelectors.
--   
--   Test cases: NFSSuppressed, records-nofieldselectors.
RemindFieldSelectorSuppressed :: RdrName -> [Name] -> GhcHint
[suppressed_selector] :: GhcHint -> RdrName
[suppressed_parents] :: GhcHint -> [Name]

-- | Suggest importing from a module, removing a <tt>hiding</tt> clause, or
--   explain to the user that we couldn't find a module with the given
--   <a>ModuleName</a>.
--   
--   Test cases: mod28, mod36, mod87, mod114, ...
ImportSuggestion :: OccName -> ImportSuggestion -> GhcHint

-- | Found a pragma in the body of a module, suggest placing it in the
--   header.
SuggestPlacePragmaInHeader :: GhcHint

-- | Suggest using pattern matching syntax for a non-bidirectional pattern
--   synonym
--   
--   Test cases: patsyn<i>should_fail</i>record-exquant
--   typecheck<i>should_fail</i>T3176
SuggestPatternMatchingSyntax :: GhcHint

-- | Suggest tips for making a definition visible for the purpose of
--   writing a SPECIALISE pragma for it in a different module.
--   
--   Test cases: none
SuggestSpecialiseVisibilityHints :: Name -> GhcHint

-- | Suggest renaming implicitly quantified type variable in case it
--   captures a term's name.
SuggestRenameTypeVariable :: GhcHint
SuggestExplicitBidiPatSyn :: Name -> LPat GhcRn -> [LIdP GhcRn] -> GhcHint

-- | Suggest enabling one of the SafeHaskell modes Safe, Unsafe or
--   Trustworthy.
SuggestSafeHaskell :: GhcHint

-- | Suggest removing a record wildcard from a pattern when it doesn't bind
--   anything useful.
SuggestRemoveRecordWildcard :: GhcHint

-- | Suggest moving a method implementation to a different instance to its
--   superclass that defines the canonical version of the method.
SuggestMoveNonCanonicalDefinition :: Name -> Name -> String -> GhcHint

-- | Suggest to increase the solver maximum reduction depth
SuggestIncreaseReductionDepth :: GhcHint

-- | Suggest removing a method implementation when a superclass defines the
--   canonical version of that method.
SuggestRemoveNonCanonicalDefinition :: Name -> Name -> String -> GhcHint

-- | Suggest eta-reducing a type synonym used in the implementation of
--   abstract data.
SuggestEtaReduceAbsDataTySyn :: TyCon -> GhcHint

-- | Remind the user that there is no field of a type and name in the
--   record, constructors are in the usual order $x$, $r$, $a$
RemindRecordMissingField :: FastString -> Type -> Type -> GhcHint

-- | Suggest binding the type variable on the LHS of the type declaration
SuggestBindTyVarOnLhs :: RdrName -> GhcHint

-- | Suggest using an anonymous wildcard instead of a named wildcard
SuggestAnonymousWildcard :: GhcHint

-- | Suggest explicitly quantifying a type variable instead of relying on
--   implicit quantification
SuggestExplicitQuantification :: RdrName -> GhcHint

-- | Suggest binding explicitly; e.g data T @k (a :: F k) = ....
SuggestBindTyVarExplicitly :: Name -> GhcHint

-- | Suggest a default declaration; e.g <tt>default Cls (Ty1, Ty2)</tt>
SuggestDefaultDeclaration :: TyCon -> [Type] -> GhcHint

-- | Suggest using explicit deriving strategies for a deriving clause.
--   
--   Triggered by: <a>TcRnNoDerivingClauseStrategySpecified</a>.
--   
--   See comment of <tt>TcRnNoDerivingClauseStrategySpecified</tt> for
--   context.
SuggestExplicitDerivingClauseStrategies :: Map AssumedDerivingStrategy [LHsSigType GhcRn] -> GhcHint

-- | Suggest using an explicit deriving strategy for a standalone deriving
--   instance.
--   
--   Triggered by: <a>TcRnNoStandaloneDerivingStrategySpecified</a>.
--   
--   See comment of <tt>TcRnNoStandaloneDerivingStrategySpecified</tt> for
--   context.
SuggestExplicitStandaloneDerivingStrategy :: AssumedDerivingStrategy -> LHsSigWcType GhcRn -> GhcHint

-- | Suggest add parens to pattern `e -&gt; p :: t`
SuggestParenthesizePatternRHS :: GhcHint

-- | The bindings we have available in scope when suggesting an explicit
--   type signature.
data AvailableBindings
NamedBindings :: NonEmpty Name -> AvailableBindings

-- | An unknown binding (i.e. too complicated to turn into a <a>Name</a>)
UnnamedBinding :: AvailableBindings
data LanguageExtensionHint

-- | Suggest to enable the input extension. This is the hint that GHC emits
--   if this is not a "known" fix, i.e. this is GHC giving its best guess
--   on what extension might be necessary to make a certain program
--   compile. For example, GHC might suggests to enable
--   <tt>BlockArguments</tt> when the user simply formatted incorrectly the
--   input program, so GHC here is trying to be as helpful as possible. If
--   the input <a>SDoc</a> is not empty, it will contain some extra
--   information about the why the extension is required, but it's totally
--   irrelevant/redundant for IDEs and other tools.
SuggestSingleExtension :: !SDoc -> !Extension -> LanguageExtensionHint

-- | Suggest to enable the input extensions. The list is to be intended as
--   <i>disjunctive</i> i.e. the user is suggested to enable <i>any</i> of
--   the extensions listed. If the input <a>SDoc</a> is not empty, it will
--   contain some extra information about the why the extensions are
--   required, but it's totally irrelevant/redundant for IDEs and other
--   tools.
SuggestAnyExtension :: !SDoc -> [Extension] -> LanguageExtensionHint

-- | Suggest to enable the input extensions. The list is to be intended as
--   <i>conjunctive</i> i.e. the user is suggested to enable <i>all</i> the
--   extensions listed. If the input <a>SDoc</a> is not empty, it will
--   contain some extra information about the why the extensions are
--   required, but it's totally irrelevant/redundant for IDEs and other
--   tools.
SuggestExtensions :: !SDoc -> [Extension] -> LanguageExtensionHint

-- | Suggest to enable the input extension in order to fix a certain
--   problem. This is the suggestion that GHC emits when is more-or-less
--   clear "what's going on". For example, if both <tt>DeriveAnyClass</tt>
--   and <tt>GeneralizedNewtypeDeriving</tt> are turned on, the right thing
--   to do is to enabled <tt>DerivingStrategies</tt>, so in contrast to
--   <a>SuggestSingleExtension</a> GHC will be a bit more "imperative"
--   (i.e. "Use X Y Z in order to ... "). If the input <a>SDoc</a> is not
--   empty, it will contain some extra information about the why the
--   extensions are required, but it's totally irrelevant/redundant for
--   IDEs and other tools.
SuggestExtensionInOrderTo :: !SDoc -> !Extension -> LanguageExtensionHint

-- | Suggests a single extension without extra user info.
suggestExtension :: Extension -> GhcHint

-- | Like <a>suggestExtension</a> but allows supplying extra info for the
--   user.
suggestExtensionWithInfo :: SDoc -> Extension -> GhcHint

-- | Suggests to enable <i>every</i> extension in the list.
suggestExtensions :: [Extension] -> GhcHint

-- | Like <a>suggestExtensions</a> but allows supplying extra info for the
--   user.
suggestExtensionsWithInfo :: SDoc -> [Extension] -> GhcHint

-- | Suggests to enable <i>any</i> extension in the list.
suggestAnyExtension :: [Extension] -> GhcHint

-- | Like <a>suggestAnyExtension</a> but allows supplying extra info for
--   the user.
suggestAnyExtensionWithInfo :: SDoc -> [Extension] -> GhcHint
useExtensionInOrderTo :: SDoc -> Extension -> GhcHint

-- | Helper function to use when no hints can be provided. Currently this
--   function can be used to construct plain <a>DiagnosticMessage</a> and
--   add hints to them, but once #18516 will be fully executed, the main
--   usage of this function would be in the implementation of the
--   <a>diagnosticHints</a> typeclass method, to report the fact that a
--   particular <a>Diagnostic</a> has no hints.
noHints :: [GhcHint]

-- | Represents a pretty-printable document.
--   
--   To display an <a>SDoc</a>, use <a>printSDoc</a>, <a>printSDocLn</a>,
--   <a>bufLeftRenderSDoc</a>, or <a>renderWithContext</a>. Avoid calling
--   <a>runSDoc</a> directly as it breaks the abstraction layer.
data SDoc

-- | A <a>DecoratedSDoc</a> is isomorphic to a '[SDoc]' but it carries the
--   invariant that the input '[SDoc]' needs to be rendered
--   <i>decorated</i> into its final form, where the typical case would be
--   adding bullets between each elements of the list. The type of
--   decoration depends on the formatting function used, but in practice
--   GHC uses the <tt>formatBulleted</tt>.
data DecoratedSDoc

-- | Creates a new <a>DecoratedSDoc</a> out of a list of <a>SDoc</a>.
mkDecorated :: [SDoc] -> DecoratedSDoc

-- | Creates a new <a>DecoratedSDoc</a> out of a single <a>SDoc</a>
mkSimpleDecorated :: SDoc -> DecoratedSDoc

-- | Joins two <a>DecoratedSDoc</a> together. The resulting
--   <a>DecoratedSDoc</a> will have a number of entries which is the sum of
--   the lengths of the input.
unionDecoratedSDoc :: DecoratedSDoc -> DecoratedSDoc -> DecoratedSDoc

-- | Apply a transformation function to all elements of a
--   <a>DecoratedSDoc</a>.
mapDecoratedSDoc :: (SDoc -> SDoc) -> DecoratedSDoc -> DecoratedSDoc
pprMessageBag :: Bag SDoc -> SDoc
mkLocMessage :: MessageClass -> SrcSpan -> SDoc -> SDoc

-- | Make an error message with location info, specifying whether to show
--   warning groups (if applicable).
mkLocMessageWarningGroups :: Bool -> MessageClass -> SrcSpan -> SDoc -> SDoc
getCaretDiagnostic :: MessageClass -> SrcSpan -> IO SDoc

-- | Returns <a>True</a> if this is, intrinsically, a failure. See Note
--   [Intrinsic And Extrinsic Failures].
isIntrinsicErrorMessage :: Diagnostic e => MsgEnvelope e -> Bool

-- | Returns <a>True</a> if the envelope contains a message that will stop
--   compilation: either an intrinsic error or a fatal (-Werror) warning
isExtrinsicErrorMessage :: MsgEnvelope e -> Bool
isWarningMessage :: Diagnostic e => MsgEnvelope e -> Bool
getErrorMessages :: Diagnostic e => Messages e -> Bag (MsgEnvelope e)
getWarningMessages :: Diagnostic e => Messages e -> Bag (MsgEnvelope e)

-- | Partitions the <a>Messages</a> and returns a tuple which first element
--   are the warnings, and the second the errors.
partitionMessages :: Diagnostic e => Messages e -> (Messages e, Messages e)

-- | Are there any hard errors here? -Werror warnings are <i>not</i>
--   detected. If you want to check for -Werror warnings, use
--   <a>errorsOrFatalWarningsFound</a>.
errorsFound :: Diagnostic e => Messages e -> Bool

-- | Are there any errors or -Werror warnings here?
errorsOrFatalWarningsFound :: Messages e -> Bool

-- | A diagnostic code is a namespaced numeric identifier unique to the
--   given diagnostic (error or warning).
--   
--   All diagnostic codes defined within GHC are given the GHC namespace.
--   
--   See Note [Diagnostic codes] in GHC.Types.Error.Codes.
data DiagnosticCode
DiagnosticCode :: String -> Natural -> DiagnosticCode

-- | diagnostic code prefix (e.g. <a>GHC</a>)
[diagnosticCodeNameSpace] :: DiagnosticCode -> String

-- | the actual diagnostic code
[diagnosticCodeNumber] :: DiagnosticCode -> Natural
instance GHC.Types.Error.Diagnostic GHC.Types.Error.DiagnosticMessage
instance GHC.Types.Error.HasDefaultDiagnosticOpts opts => GHC.Types.Error.Diagnostic (GHC.Types.Error.UnknownDiagnostic opts)
instance GHC.Classes.Eq GHC.Types.Error.DiagnosticCode
instance GHC.Classes.Eq GHC.Types.Error.DiagnosticReason
instance GHC.Classes.Eq GHC.Types.Error.Severity
instance GHC.Internal.Data.Foldable.Foldable GHC.Types.Error.Messages
instance GHC.Internal.Data.Foldable.Foldable GHC.Types.Error.MsgEnvelope
instance GHC.Internal.Base.Functor GHC.Types.Error.Messages
instance GHC.Internal.Base.Functor GHC.Types.Error.MsgEnvelope
instance GHC.Types.Error.HasDefaultDiagnosticOpts GHC.Types.Error.NoDiagnosticOpts
instance GHC.Internal.Base.Monoid (GHC.Types.Error.Messages e)
instance GHC.Classes.Ord GHC.Types.Error.DiagnosticCode
instance GHC.Classes.Ord GHC.Types.Error.Severity
instance GHC.Utils.Outputable.Outputable GHC.Types.Error.DiagnosticCode
instance GHC.Utils.Outputable.Outputable GHC.Types.Error.DiagnosticHint
instance GHC.Utils.Outputable.Outputable GHC.Types.Error.DiagnosticReason
instance GHC.Utils.Outputable.Outputable GHC.Types.Error.LinkedDiagCode
instance GHC.Types.Error.Diagnostic e => GHC.Utils.Outputable.Outputable (GHC.Types.Error.Messages e)
instance GHC.Utils.Outputable.Outputable GHC.Types.Error.ResolvedDiagnosticReason
instance GHC.Utils.Outputable.Outputable GHC.Types.Error.Severity
instance GHC.Internal.Base.Semigroup (GHC.Types.Error.Messages e)
instance GHC.Internal.Show.Show GHC.Types.Error.DiagnosticCode
instance GHC.Internal.Show.Show GHC.Types.Error.DiagnosticReason
instance GHC.Internal.Show.Show (GHC.Types.Error.MsgEnvelope GHC.Types.Error.DiagnosticMessage)
instance GHC.Internal.Show.Show GHC.Types.Error.Severity
instance GHC.Utils.Json.ToJson GHC.Types.Error.DiagnosticCode
instance GHC.Utils.Json.ToJson GHC.Types.Error.MessageClass
instance GHC.Types.Error.Diagnostic e => GHC.Utils.Json.ToJson (GHC.Types.Error.Messages e)
instance GHC.Types.Error.Diagnostic e => GHC.Utils.Json.ToJson (GHC.Types.Error.MsgEnvelope e)
instance GHC.Utils.Json.ToJson GHC.Types.Error.Severity
instance GHC.Internal.Data.Traversable.Traversable GHC.Types.Error.Messages
instance GHC.Internal.Data.Traversable.Traversable GHC.Types.Error.MsgEnvelope


-- | Logger
--   
--   The Logger is an configurable entity that is used by the compiler to
--   output messages on the console (stdout, stderr) and in dump files.
--   
--   The behaviour of default Logger returned by <a>initLogger</a> can be
--   modified with hooks. The compiler itself uses hooks in multithreaded
--   code (--make) and it is also probably used by ghc-api users (IDEs,
--   etc.).
--   
--   In addition to hooks, the Logger supports LogFlags: basically a subset
--   of the command-line flags that control the logger behaviour at a
--   higher level than hooks.
--   
--   <ol>
--   <li>Hooks are used to define how to generate a
--   info<i>warning</i>error/dump messages</li>
--   <li>LogFlags are used to decide when and how to generate messages</li>
--   </ol>
module GHC.Utils.Logger
data Logger
class HasLogger (m :: Type -> Type)
getLogger :: HasLogger m => m Logger
class ContainsLogger t
extractLogger :: ContainsLogger t => t -> Logger
initLogger :: IO Logger
type LogAction = LogFlags -> MessageClass -> SrcSpan -> SDoc -> IO ()
type LogJsonAction = LogFlags -> MessageClass -> JsonDoc -> IO ()
type DumpAction = LogFlags -> PprStyle -> DumpFlag -> String -> DumpFormat -> SDoc -> IO ()
type TraceAction a = LogFlags -> String -> SDoc -> a -> a

-- | Format of a dump
--   
--   Dump formats are loosely defined: dumps may contain various additional
--   headers and annotations and they may be partial. <a>DumpFormat</a> is
--   mainly a hint (e.g. for syntax highlighters).
data DumpFormat

-- | Haskell
FormatHaskell :: DumpFormat

-- | Core
FormatCore :: DumpFormat

-- | STG
FormatSTG :: DumpFormat

-- | ByteCode
FormatByteCode :: DumpFormat

-- | Cmm
FormatCMM :: DumpFormat

-- | Assembly code
FormatASM :: DumpFormat

-- | C code/header
FormatC :: DumpFormat

-- | LLVM bytecode
FormatLLVM :: DumpFormat

-- | JavaScript code
FormatJS :: DumpFormat

-- | Unstructured dump
FormatText :: DumpFormat

-- | Pop a log hook
popLogHook :: Logger -> Logger

-- | Push a log hook
pushLogHook :: (LogAction -> LogAction) -> Logger -> Logger
popJsonLogHook :: Logger -> Logger

-- | Push a json log hook
pushJsonLogHook :: (LogJsonAction -> LogJsonAction) -> Logger -> Logger

-- | Pop a dump hook
popDumpHook :: Logger -> Logger

-- | Push a dump hook
pushDumpHook :: (DumpAction -> DumpAction) -> Logger -> Logger

-- | Pop a trace hook
popTraceHook :: Logger -> Logger

-- | Push a trace hook
pushTraceHook :: (forall a. () => TraceAction a -> TraceAction a) -> Logger -> Logger

-- | Make the logger thread-safe
makeThreadSafe :: Logger -> IO Logger

-- | Logger flags
data LogFlags
LogFlags :: SDocContext -> SDocContext -> !EnumSet DumpFlag -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Maybe FilePath -> !FilePath -> !Maybe FilePath -> !Bool -> !Bool -> !Int -> !Maybe Ways -> LogFlags
[log_default_user_context] :: LogFlags -> SDocContext
[log_default_dump_context] :: LogFlags -> SDocContext

-- | Dump flags
[log_dump_flags] :: LogFlags -> !EnumSet DumpFlag

-- | Show caret in diagnostics
[log_show_caret] :: LogFlags -> !Bool

-- | Format diagnostics as JSON
[log_diagnostics_as_json] :: LogFlags -> !Bool

-- | Show warning flag groups
[log_show_warn_groups] :: LogFlags -> !Bool

-- | Enable timestamps
[log_enable_timestamps] :: LogFlags -> !Bool

-- | Enable dump to file
[log_dump_to_file] :: LogFlags -> !Bool

-- | Dump directory
[log_dump_dir] :: LogFlags -> !Maybe FilePath

-- | Normal dump path ("basename.")
[log_dump_prefix] :: LogFlags -> !FilePath

-- | Overriden dump path
[log_dump_prefix_override] :: LogFlags -> !Maybe FilePath

-- | Use different dump files names for different ways
[log_with_ways] :: LogFlags -> !Bool

-- | Enable debug output
[log_enable_debug] :: LogFlags -> !Bool

-- | Verbosity level
[log_verbosity] :: LogFlags -> !Int

-- | Current ways (to name dump files)
[log_ways] :: LogFlags -> !Maybe Ways

-- | Default LogFlags
defaultLogFlags :: LogFlags

-- | Test if a DumpFlag is enabled
log_dopt :: DumpFlag -> LogFlags -> Bool

-- | Enable a DumpFlag
log_set_dopt :: DumpFlag -> LogFlags -> LogFlags

-- | Set LogFlags
setLogFlags :: Logger -> LogFlags -> Logger

-- | Update LogFlags
updateLogFlags :: Logger -> (LogFlags -> LogFlags) -> Logger

-- | Logger flags
logFlags :: Logger -> LogFlags

-- | Test if a DumpFlag is set
logHasDumpFlag :: Logger -> DumpFlag -> Bool

-- | Test if verbosity is &gt;= to the given value
logVerbAtLeast :: Logger -> Int -> Bool

-- | Log something
putLogMsg :: Logger -> LogAction
defaultLogAction :: LogAction
defaultLogJsonAction :: LogJsonAction

-- | Like <a>defaultLogActionHPutStrDoc</a> but appends an extra newline.
defaultLogActionHPrintDoc :: LogFlags -> Bool -> Handle -> SDoc -> IO ()

-- | The boolean arguments let's the pretty printer know if it can optimize
--   indent by writing ascii ' ' characters without going through decoding.
defaultLogActionHPutStrDoc :: LogFlags -> Bool -> Handle -> SDoc -> IO ()

-- | Log something
logMsg :: Logger -> MessageClass -> SrcSpan -> SDoc -> IO ()
logJsonMsg :: ToJson a => Logger -> MessageClass -> a -> IO ()

-- | Log a dump message (not a dump file)
logDumpMsg :: Logger -> String -> SDoc -> IO ()

-- | Default action for <tt>dumpAction</tt> hook
defaultDumpAction :: DumpCache -> LogAction -> DumpAction

-- | Dump something
putDumpFile :: Logger -> DumpAction

-- | Dump if the given DumpFlag is set
putDumpFileMaybe :: Logger -> DumpFlag -> String -> DumpFormat -> SDoc -> IO ()

-- | Dump if the given DumpFlag is set
--   
--   Unlike <a>putDumpFileMaybe</a>, has a NamePprCtx argument
putDumpFileMaybe' :: Logger -> NamePprCtx -> DumpFlag -> String -> DumpFormat -> SDoc -> IO ()

-- | Run an action with the handle of a <a>DumpFlag</a> if we are
--   outputting to a file, otherwise <a>Nothing</a>.
withDumpFileHandle :: DumpCache -> LogFlags -> DumpFlag -> (Maybe Handle -> IO ()) -> IO ()

-- | Ensure that a dump file is created even if it stays empty
touchDumpFile :: Logger -> DumpFlag -> IO ()

-- | Dump something
logDumpFile :: Logger -> PprStyle -> DumpFlag -> String -> DumpFormat -> SDoc -> IO ()

-- | Default action for <tt>traceAction</tt> hook
defaultTraceAction :: TraceAction a

-- | Trace something
putTraceMsg :: Logger -> TraceAction a

-- | Set the trace flushing function
--   
--   The currently set trace flushing function is passed to the updating
--   function
loggerTraceFlushUpdate :: Logger -> (IO () -> IO ()) -> Logger

-- | Calls the trace flushing function
loggerTraceFlush :: Logger -> IO ()

-- | Log a trace message
logTraceMsg :: Logger -> String -> SDoc -> a -> a
instance GHC.Classes.Eq GHC.Utils.Logger.DumpFormat
instance GHC.Internal.Show.Show GHC.Utils.Logger.DumpFormat

module GHC.Utils.Error
data Validity' a

-- | Everything is fine
IsValid :: Validity' a

-- | A problem, and some indication of why
NotValid :: a -> Validity' a

-- | Monomorphic version of <tt>Validity'</tt> specialised for
--   <a>SDoc</a>s.
type Validity = Validity' SDoc
andValid :: Validity' a -> Validity' a -> Validity' a

-- | If they aren't all valid, return the first
allValid :: [Validity' a] -> Validity' a
getInvalids :: [Validity' a] -> [a]

-- | Used to describe warnings and errors o The message has a
--   file/line/column heading, plus "warning:" or "error:", added by
--   mkLocMessage o With <a>SevIgnore</a> the message is suppressed o
--   Output is intended for end users
data Severity

-- | Ignore this message, for example in case of suppression of warnings
--   users don't want to see. See Note [Suppressing Messages]
SevIgnore :: Severity
SevWarning :: Severity
SevError :: Severity

-- | A class identifying a diagnostic. Dictionary.com defines a diagnostic
--   as:
--   
--   "a message output by a computer diagnosing an error in a computer
--   program, computer system, or component device".
--   
--   A <a>Diagnostic</a> carries the <i>actual</i> description of the
--   message (which, in GHC's case, it can be an error or a warning) and
--   the <i>reason</i> why such message was generated in the first place.
class HasDefaultDiagnosticOpts DiagnosticOpts a => Diagnostic a where {
    
    -- | Type of configuration options for the diagnostic.
    type DiagnosticOpts a;
}

-- | Extract the error message text from a <a>Diagnostic</a>.
diagnosticMessage :: Diagnostic a => DiagnosticOpts a -> a -> DecoratedSDoc

-- | Extract the reason for this diagnostic. For warnings, a
--   <a>DiagnosticReason</a> includes the warning flag.
diagnosticReason :: Diagnostic a => a -> DiagnosticReason

-- | Extract any hints a user might use to repair their code to avoid this
--   diagnostic.
diagnosticHints :: Diagnostic a => a -> [GhcHint]

-- | Get the <a>DiagnosticCode</a> associated with this <a>Diagnostic</a>.
--   This can return <a>Nothing</a> for at least two reasons:
--   
--   <ol>
--   <li>The message might be from a plugin that does not supply
--   codes.</li>
--   <li>The message might not yet have been assigned a code. See the
--   <a>Diagnostic</a> instance for <a>DiagnosticMessage</a>.</li>
--   </ol>
--   
--   Ideally, case (2) would not happen, but because some errors in GHC
--   still use the old system of just writing the error message in-place
--   (instead of using a dedicated error type and constructor), we do not
--   have error codes for all errors. #18516 tracks our progress toward
--   this goal.
diagnosticCode :: Diagnostic a => a -> Maybe DiagnosticCode

-- | An envelope for GHC's facts about a running program, parameterised
--   over the <i>domain-specific</i> (i.e. parsing, typecheck-renaming,
--   etc) diagnostics.
--   
--   To say things differently, GHC emits <i>diagnostics</i> about the
--   running program, each of which is wrapped into a <a>MsgEnvelope</a>
--   that carries specific information like where the error happened, etc.
--   Finally, multiple <a>MsgEnvelope</a>s are aggregated into
--   <a>Messages</a> that are returned to the user.
data MsgEnvelope e
MsgEnvelope :: SrcSpan -> NamePprCtx -> e -> Severity -> ResolvedDiagnosticReason -> MsgEnvelope e

-- | The SrcSpan is used for sorting errors into line-number order
[errMsgSpan] :: MsgEnvelope e -> SrcSpan
[errMsgContext] :: MsgEnvelope e -> NamePprCtx
[errMsgDiagnostic] :: MsgEnvelope e -> e
[errMsgSeverity] :: MsgEnvelope e -> Severity

-- | The actual reason caused this message
--   
--   See Note [Warnings controlled by multiple flags]
[errMsgReason] :: MsgEnvelope e -> ResolvedDiagnosticReason

-- | The class for a diagnostic message. The main purpose is to classify a
--   message within GHC, to distinguish it from a debug/dump message vs a
--   proper diagnostic, for which we include a <a>DiagnosticReason</a>.
data MessageClass
MCOutput :: MessageClass
MCFatal :: MessageClass
MCInteractive :: MessageClass

-- | Log message intended for compiler developers No file/line/column stuff
MCDump :: MessageClass

-- | Log messages intended for end users. No file/line/column stuff.
MCInfo :: MessageClass

-- | Diagnostics from the compiler. This constructor is very powerful as it
--   allows the construction of a <a>MessageClass</a> with a completely
--   arbitrary permutation of <a>Severity</a> and <a>DiagnosticReason</a>.
--   As such, users are encouraged to use the <tt>mkMCDiagnostic</tt> smart
--   constructor instead. Use this constructor directly only if you need to
--   construct and manipulate diagnostic messages directly, for example
--   inside <a>Error</a>. In all the other circumstances, <i>especially</i>
--   when emitting compiler diagnostics, use the smart constructor.
--   
--   The <tt>Maybe <a>DiagnosticCode</a></tt> field carries a code (if
--   available) for this diagnostic. If you are creating a message not tied
--   to any error-message type, then use Nothing. In the long run, this
--   really should always have a <a>DiagnosticCode</a>. See Note
--   [Diagnostic codes].
MCDiagnostic :: Severity -> ResolvedDiagnosticReason -> Maybe DiagnosticCode -> MessageClass

-- | Represents a pretty-printable document.
--   
--   To display an <a>SDoc</a>, use <a>printSDoc</a>, <a>printSDocLn</a>,
--   <a>bufLeftRenderSDoc</a>, or <a>renderWithContext</a>. Avoid calling
--   <a>runSDoc</a> directly as it breaks the abstraction layer.
data SDoc

-- | A <a>DecoratedSDoc</a> is isomorphic to a '[SDoc]' but it carries the
--   invariant that the input '[SDoc]' needs to be rendered
--   <i>decorated</i> into its final form, where the typical case would be
--   adding bullets between each elements of the list. The type of
--   decoration depends on the formatting function used, but in practice
--   GHC uses the <tt>formatBulleted</tt>.
data DecoratedSDoc

-- | A collection of messages emitted by GHC during error reporting. A
--   diagnostic message is typically a warning or an error. See Note
--   [Messages].
--   
--   <i>INVARIANT</i>: All the messages in this collection must be
--   relevant, i.e. their <a>Severity</a> should <i>not</i> be
--   <a>SevIgnore</a>. The smart constructor <a>mkMessages</a> will filter
--   out any message which <a>Severity</a> is <a>SevIgnore</a>.
data Messages e
mkMessages :: Bag (MsgEnvelope e) -> Messages e

-- | Joins two collections of messages together. See Note [Discarding
--   Messages].
unionMessages :: Messages e -> Messages e -> Messages e

-- | Are there any hard errors here? -Werror warnings are <i>not</i>
--   detected. If you want to check for -Werror warnings, use
--   <a>errorsOrFatalWarningsFound</a>.
errorsFound :: Diagnostic e => Messages e -> Bool
isEmptyMessages :: Messages e -> Bool
pprMessageBag :: Bag SDoc -> SDoc
pprMsgEnvelopeBagWithLoc :: Diagnostic e => DiagnosticOpts e -> Bag (MsgEnvelope e) -> [SDoc]

-- | Print the messages with the suitable default configuration, usually
--   not what you want but sometimes you don't really care about what the
--   configuration is (for example, if the message is in a panic).
pprMsgEnvelopeBagWithLocDefault :: Diagnostic e => Bag (MsgEnvelope e) -> [SDoc]
pprMessages :: Diagnostic e => DiagnosticOpts e -> Messages e -> SDoc
pprLocMsgEnvelope :: Diagnostic e => DiagnosticOpts e -> MsgEnvelope e -> SDoc
pprLocMsgEnvelopeDefault :: Diagnostic e => MsgEnvelope e -> SDoc

-- | Formats the input list of structured document, where each element of
--   the list gets a bullet.
formatBulleted :: DecoratedSDoc -> SDoc
data DiagOpts
DiagOpts :: !EnumSet WarningFlag -> !EnumSet WarningFlag -> !WarningCategorySet -> !WarningCategorySet -> !Bool -> !Bool -> !Maybe Int -> !SDocContext -> DiagOpts

-- | Enabled warnings
[diag_warning_flags] :: DiagOpts -> !EnumSet WarningFlag

-- | Fatal warnings
[diag_fatal_warning_flags] :: DiagOpts -> !EnumSet WarningFlag

-- | Enabled custom warning categories
[diag_custom_warning_categories] :: DiagOpts -> !WarningCategorySet

-- | Fatal custom warning categories
[diag_fatal_custom_warning_categories] :: DiagOpts -> !WarningCategorySet

-- | Treat warnings as errors
[diag_warn_is_error] :: DiagOpts -> !Bool

-- | Reverse error reporting order
[diag_reverse_errors] :: DiagOpts -> !Bool

-- | Max reported error count
[diag_max_errors] :: DiagOpts -> !Maybe Int

-- | Error printing context
[diag_ppr_ctx] :: DiagOpts -> !SDocContext
emptyDiagOpts :: DiagOpts
diag_wopt :: WarningFlag -> DiagOpts -> Bool
diag_fatal_wopt :: WarningFlag -> DiagOpts -> Bool
emptyMessages :: Messages e

-- | Creates a new <a>DecoratedSDoc</a> out of a list of <a>SDoc</a>.
mkDecorated :: [SDoc] -> DecoratedSDoc
mkLocMessage :: MessageClass -> SrcSpan -> SDoc -> SDoc

-- | Wrap a <a>Diagnostic</a> in a <a>MsgEnvelope</a>, recording its
--   location. If you know your <a>Diagnostic</a> is an error, consider
--   using <a>mkErrorMsgEnvelope</a>, which does not require looking at the
--   <a>DiagOpts</a>
mkMsgEnvelope :: Diagnostic e => DiagOpts -> SrcSpan -> NamePprCtx -> e -> MsgEnvelope e

-- | Variant that doesn't care about qualified/unqualified names.
mkPlainMsgEnvelope :: Diagnostic e => DiagOpts -> SrcSpan -> e -> MsgEnvelope e

-- | Variant of <a>mkPlainMsgEnvelope</a> which can be used when we are
--   <i>sure</i> we are constructing a diagnostic with a
--   <a>ErrorWithoutFlag</a> reason.
mkPlainErrorMsgEnvelope :: Diagnostic e => SrcSpan -> e -> MsgEnvelope e

-- | Wrap a <a>Diagnostic</a> in a <a>MsgEnvelope</a>, recording its
--   location. Precondition: the diagnostic is, in fact, an error. That is,
--   <tt>diagnosticReason msg == ErrorWithoutFlag</tt>.
mkErrorMsgEnvelope :: Diagnostic e => SrcSpan -> NamePprCtx -> e -> MsgEnvelope e

-- | Make a <a>MessageClass</a> for a given <a>DiagnosticReason</a>,
--   consulting the <a>DiagOpts</a>.
mkMCDiagnostic :: DiagOpts -> DiagnosticReason -> Maybe DiagnosticCode -> MessageClass

-- | Varation of <a>mkMCDiagnostic</a> which can be used when we are
--   <i>sure</i> the input <a>DiagnosticReason</a> <i>is</i>
--   <a>ErrorWithoutFlag</a> and there is no diagnostic code.
errorDiagnostic :: MessageClass

-- | Computes the <i>right</i> <a>Severity</a> for the input
--   <a>DiagnosticReason</a> out of the 'DiagOpts. This function <i>has</i>
--   to be called when a diagnostic is constructed, i.e. with a 'DiagOpts
--   "snapshot" taken as close as possible to where a particular diagnostic
--   message is built, otherwise the computed <a>Severity</a> might not be
--   correct, due to the mutable nature of the <tt>DynFlags</tt> in GHC.
diagReasonSeverity :: DiagOpts -> DiagnosticReason -> Severity

-- | Create an error <a>DiagnosticMessage</a> holding just a single
--   <a>SDoc</a>
mkPlainError :: [GhcHint] -> SDoc -> DiagnosticMessage
mkPlainDiagnostic :: DiagnosticReason -> [GhcHint] -> SDoc -> DiagnosticMessage

-- | Create an error <a>DiagnosticMessage</a> from a list of bulleted SDocs
mkDecoratedError :: [GhcHint] -> [SDoc] -> DiagnosticMessage

-- | Create a <a>DiagnosticMessage</a> from a list of bulleted SDocs and a
--   <a>DiagnosticReason</a>
mkDecoratedDiagnostic :: DiagnosticReason -> [GhcHint] -> [SDoc] -> DiagnosticMessage

-- | Helper function to use when no hints can be provided. Currently this
--   function can be used to construct plain <a>DiagnosticMessage</a> and
--   add hints to them, but once #18516 will be fully executed, the main
--   usage of this function would be in the implementation of the
--   <a>diagnosticHints</a> typeclass method, to report the fact that a
--   particular <a>Diagnostic</a> has no hints.
noHints :: [GhcHint]
getCaretDiagnostic :: MessageClass -> SrcSpan -> IO SDoc
putMsg :: Logger -> SDoc -> IO ()
printInfoForUser :: Logger -> NamePprCtx -> SDoc -> IO ()
printOutputForUser :: Logger -> NamePprCtx -> SDoc -> IO ()
logInfo :: Logger -> SDoc -> IO ()

-- | Like <a>logInfo</a> but with <tt>SevOutput</tt> rather then
--   <tt>SevInfo</tt>
logOutput :: Logger -> SDoc -> IO ()
errorMsg :: Logger -> SDoc -> IO ()
fatalErrorMsg :: Logger -> SDoc -> IO ()
compilationProgressMsg :: Logger -> SDoc -> IO ()
showPass :: Logger -> String -> IO ()

-- | Time a compilation phase.
--   
--   When timings are enabled (e.g. with the <tt>-v2</tt> flag), the
--   allocations and CPU time used by the phase will be reported to stderr.
--   Consider a typical usage: <tt>withTiming getDynFlags (text "simplify")
--   force PrintTimings pass</tt>. When timings are enabled the following
--   costs are included in the produced accounting,
--   
--   <ul>
--   <li>The cost of executing <tt>pass</tt> to a result <tt>r</tt> in
--   WHNF</li>
--   <li>The cost of evaluating <tt>force r</tt> to WHNF (e.g.
--   <tt>()</tt>)</li>
--   </ul>
--   
--   The choice of the <tt>force</tt> function depends upon the amount of
--   forcing desired; the goal here is to ensure that the cost of
--   evaluating the result is, to the greatest extent possible, included in
--   the accounting provided by <a>withTiming</a>. Often the pass already
--   sufficiently forces its result during construction; in this case
--   <tt>const ()</tt> is a reasonable choice. In other cases, it is
--   necessary to evaluate the result to normal form, in which case
--   something like <tt>Control.DeepSeq.rnf</tt> is appropriate.
--   
--   To avoid adversely affecting compiler performance when timings are not
--   requested, the result is only forced when timings are enabled.
--   
--   See Note [withTiming] for more.
withTiming :: MonadIO m => Logger -> SDoc -> (a -> ()) -> m a -> m a

-- | Same as <a>withTiming</a>, but doesn't print timings in the console
--   (when given <tt>-vN</tt>, <tt>N &gt;= 2</tt> or
--   <tt>-ddump-timings</tt>).
--   
--   See Note [withTiming] for more.
withTimingSilent :: MonadIO m => Logger -> SDoc -> (a -> ()) -> m a -> m a
debugTraceMsg :: Logger -> Int -> SDoc -> IO ()
ghcExit :: Logger -> Int -> IO ()
prettyPrintGhcErrors :: ExceptionMonad m => Logger -> m a -> m a

-- | Trace a command (when verbosity level &gt;= 3)
traceCmd :: Logger -> String -> String -> IO a -> IO a

-- | Record in the eventlog when the given tool command starts and
--   finishes, prepending the given <a>String</a> with "systool:", to
--   easily be able to collect and process all the systool events.
--   
--   For those events to show up in the eventlog, you need to run GHC with
--   <tt>-v2</tt> or <tt>-ddump-timings</tt>.
traceSystoolCommand :: Logger -> String -> IO a -> IO a
sortMsgBag :: Maybe DiagOpts -> Bag (MsgEnvelope e) -> [MsgEnvelope e]
instance GHC.Classes.Eq GHC.Utils.Error.PrintTimings
instance GHC.Internal.Base.Functor GHC.Utils.Error.Validity'
instance GHC.Internal.Show.Show GHC.Utils.Error.PrintTimings


-- | Temporary file-system management
module GHC.Utils.TmpFs

-- | Temporary file-system
data TmpFs

-- | Initialise an empty TmpFs
initTmpFs :: IO TmpFs

-- | Initialise an empty TmpFs sharing unique numbers and per-process
--   temporary directories with the given TmpFs
--   
--   It's not safe to use the subdirs created by the original TmpFs with
--   the forked one. Use <tt>newTempSubDir</tt> to create new subdirs
--   instead.
forkTmpFsFrom :: TmpFs -> IO TmpFs

-- | Merge the first TmpFs into the second.
--   
--   The first TmpFs is returned emptied.
mergeTmpFsInto :: TmpFs -> TmpFs -> IO ()

-- | A collection of paths that must be deleted before ghc exits.
data PathsToClean
PathsToClean :: !Set FilePath -> !Set FilePath -> PathsToClean

-- | Paths that will be deleted at the end of runGhc(T)
[ptcGhcSession] :: PathsToClean -> !Set FilePath

-- | Paths that will be deleted the next time
--   <a>cleanCurrentModuleTempFiles</a> is called, or otherwise at the end
--   of the session.
[ptcCurrentModule] :: PathsToClean -> !Set FilePath

-- | An empty PathsToClean
emptyPathsToClean :: PathsToClean

-- | Used when a temp file is created. This determines which component Set
--   of PathsToClean will get the temp file
data TempFileLifetime

-- | A file with lifetime TFL_CurrentModule will be cleaned up at the end
--   of upweep_mod
TFL_CurrentModule :: TempFileLifetime

-- | A file with lifetime TFL_GhcSession will be cleaned up at the end of
--   runGhc(T)
TFL_GhcSession :: TempFileLifetime
newtype TempDir
TempDir :: FilePath -> TempDir
cleanTempDirs :: Logger -> TmpFs -> IO ()

-- | Delete all paths in <tt>tmp_files_to_clean</tt> and
--   <tt>tmp_subdirs_to_clean</tt>.
cleanTempFiles :: Logger -> TmpFs -> IO ()

-- | Delete all paths in <tt>tmp_files_to_clean</tt> and
--   <tt>tmp_subdirs_to_clean</tt> That have lifetime TFL_CurrentModule. If
--   a file must be cleaned eventually, but must survive a
--   cleanCurrentModuleTempFiles, ensure it has lifetime TFL_GhcSession.
cleanCurrentModuleTempFiles :: Logger -> TmpFs -> IO ()

-- | Keep all the paths in <tt>tmp_files_to_clean</tt> and
--   <tt>tmp_subdirs_to_clean</tt> that have lifetime TFL_CurrentModule.
--   This function is used when `-keep-tmp-files` is used in an OPTIONS_GHC
--   pragma. This function removes the temporary file from the TmpFs so we
--   no longer remove it at the env when cleanTempFiles is called.
keepCurrentModuleTempFiles :: HasCallStack => Logger -> TmpFs -> IO ()

-- | Ensure that new_files are cleaned on the next call of
--   <a>cleanTempFiles</a> or <a>cleanCurrentModuleTempFiles</a>, depending
--   on lifetime. If any of new_files are already tracked, they will have
--   their lifetime updated.
addFilesToClean :: TmpFs -> TempFileLifetime -> [FilePath] -> IO ()

-- | Update the lifetime of files already being tracked. If any files are
--   not being tracked they will be discarded.
changeTempFilesLifetime :: TmpFs -> TempFileLifetime -> [FilePath] -> IO ()
newTempName :: Logger -> TmpFs -> TempDir -> TempFileLifetime -> Suffix -> IO FilePath
newTempLibName :: Logger -> TmpFs -> TempDir -> TempFileLifetime -> Suffix -> IO (FilePath, FilePath, String)

-- | Create a new temporary subdirectory that doesn't already exist The
--   temporary subdirectory is automatically removed at the end of the GHC
--   session, but its contents aren't. Make sure to leave the directory
--   empty before the end of the session, either by removing content
--   directly or by using <tt>addFilesToClean</tt>.
--   
--   If the created subdirectory is not empty, it will not be removed
--   (along with its parent temporary directory) and a warning message will
--   be printed at verbosity 2 and higher.
newTempSubDir :: Logger -> TmpFs -> TempDir -> IO FilePath

-- | Create and use a temporary directory in the system standard temporary
--   directory.
--   
--   Behaves exactly the same as <a>withTempDirectory</a>, except that the
--   parent temporary directory will be that returned by
--   <a>getTemporaryDirectory</a>.
withSystemTempDirectory :: String -> (FilePath -> IO a) -> IO a

-- | Create and use a temporary directory.
--   
--   Creates a new temporary directory inside the given directory, making
--   use of the template. The temp directory is deleted after use. For
--   example:
--   
--   <pre>
--   withTempDirectory "src" "sdist." $ \tmpDir -&gt; do ...
--   </pre>
--   
--   The <tt>tmpDir</tt> will be a new subdirectory of the given directory,
--   e.g. <tt>src/sdist.342</tt>.
withTempDirectory :: FilePath -> String -> (FilePath -> IO a) -> IO a
instance GHC.Internal.Show.Show GHC.Utils.TmpFs.TempFileLifetime


-- | The stg to cmm code generator configuration
module GHC.StgToCmm.Config
data StgToCmmConfig
StgToCmmConfig :: !Profile -> Module -> !TempDir -> !SDocContext -> !Bool -> !Maybe Word -> !Int -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> (FMASign -> Bool) -> !Bool -> !Bool -> Maybe String -> !Bool -> !Bool -> !Bool -> StgToCmmConfig

-- | Current profile
[stgToCmmProfile] :: StgToCmmConfig -> !Profile

-- | The module being compiled. This field kept lazy for Cmm/Parser.y which
--   preloads it with a panic
[stgToCmmThisModule] :: StgToCmmConfig -> Module

-- | Temp Dir for files used in compilation
[stgToCmmTmpDir] :: StgToCmmConfig -> !TempDir

-- | Context for StgToCmm phase
[stgToCmmContext] :: StgToCmmConfig -> !SDocContext

-- | Whether we wish to output debug information
[stgToCmmEmitDebugInfo] :: StgToCmmConfig -> !Bool

-- | Threshold at which Binary literals (e.g. strings) are either dumped to
--   a file and a CmmFileEmbed literal is emitted (over threshold), or
--   become a CmmString Literal (under or at threshold). CmmFileEmbed is
--   only supported with the NCG, thus a Just means two things: We have a
--   threshold, and will be using the NCG. Conversely, a Nothing implies we
--   are not using NCG and disables CmmFileEmbed. See Note [Embedding large
--   binary blobs] in GHC.CmmToAsm.Ppr, and <tt>cgTopBinding</tt> in
--   GHC.StgToCmm.
[stgToCmmBinBlobThresh] :: StgToCmmConfig -> !Maybe Word

-- | Max size, in bytes, of inline array allocations.
[stgToCmmMaxInlAllocSize] :: StgToCmmConfig -> !Int

-- | Ticky profiling enabled (cf <tt>-ticky</tt>)
[stgToCmmDoTicky] :: StgToCmmConfig -> !Bool

-- | True indicates ticky prof traces allocs of each named thing in
--   addition to allocs _by_ that thing
[stgToCmmTickyAllocd] :: StgToCmmConfig -> !Bool

-- | True indicates ticky uses name-specific counters for join-points
--   (let-no-escape)
[stgToCmmTickyLNE] :: StgToCmmConfig -> !Bool

-- | True indicates ticky uses name-specific counters for dynamic thunks
[stgToCmmTickyDynThunk] :: StgToCmmConfig -> !Bool

-- | True indicates ticky will count number of avoided tag checks by tag
--   inference.
[stgToCmmTickyTag] :: StgToCmmConfig -> !Bool

-- | Loopification enabled (cf <tt>-floopification</tt>)
[stgToCmmLoopification] :: StgToCmmConfig -> !Bool

-- | Insert alignment check (cf <tt>-falignment-sanitisation</tt>)
[stgToCmmAlignCheck] :: StgToCmmConfig -> !Bool
[stgToCmmFastPAPCalls] :: StgToCmmConfig -> !Bool

-- | Check if cost-centre profiling is enabled
[stgToCmmSCCProfiling] :: StgToCmmConfig -> !Bool
[stgToCmmEagerBlackHole] :: StgToCmmConfig -> !Bool

-- | Push <tt>stg_orig_thunk_info</tt> frames during thunk update.
[stgToCmmOrigThunkInfo] :: StgToCmmConfig -> !Bool

-- | true means generate C Stub for IPE map, See Note [Mapping Info Tables
--   to Source Positions]
[stgToCmmInfoTableMap] :: StgToCmmConfig -> !Bool

-- | Include info tables with fallback source locations in the info table
--   map
[stgToCmmInfoTableMapWithFallback] :: StgToCmmConfig -> !Bool

-- | Include info tables for STACK closures in the info table map
[stgToCmmInfoTableMapWithStack] :: StgToCmmConfig -> !Bool

-- | true means omit heap checks when no allocation is performed
[stgToCmmOmitYields] :: StgToCmmConfig -> !Bool

-- | true means don't generate interface programs (implied by -O0)
[stgToCmmOmitIfPragmas] :: StgToCmmConfig -> !Bool

-- | true if <tt>-fPIC</tt>
[stgToCmmPIC] :: StgToCmmConfig -> !Bool

-- | true if <tt>-fPIE</tt>
[stgToCmmPIE] :: StgToCmmConfig -> !Bool

-- | true if <tt>-fexternal-dynamic-refs</tt>, meaning generate code for
--   linking against dynamic libraries
[stgToCmmExtDynRefs] :: StgToCmmConfig -> !Bool

-- | decides whether to check array bounds in StgToCmm.Prim or not
[stgToCmmDoBoundsCheck] :: StgToCmmConfig -> !Bool

-- | Verify tag inference predictions.
[stgToCmmDoTagCheck] :: StgToCmmConfig -> !Bool

-- | Enable deterministic code generation (more precisely, the
--   deterministic unique-renaming pass in StgToCmm)
[stgToCmmObjectDeterminism] :: StgToCmmConfig -> !Bool

-- | Allowed to emit 64-bit arithmetic operations
[stgToCmmAllowArith64] :: StgToCmmConfig -> !Bool

-- | Allowed to emit 64-bit division operations
[stgToCmmAllowQuot64] :: StgToCmmConfig -> !Bool

-- | Allowed to generate QuotRem instructions
[stgToCmmAllowQuotRemInstr] :: StgToCmmConfig -> !Bool

-- | Allowed to generate QuotRem
[stgToCmmAllowQuotRem2] :: StgToCmmConfig -> !Bool

-- | Allowed to generate AddWordC, SubWordC, Add2, etc.
[stgToCmmAllowExtendedAddSubInstrs] :: StgToCmmConfig -> !Bool

-- | Allowed to generate IntMul2 instruction
[stgToCmmAllowIntMul2Instr] :: StgToCmmConfig -> !Bool

-- | Allowed to generate WordMul2 instruction
[stgToCmmAllowWordMul2Instr] :: StgToCmmConfig -> !Bool

-- | Allowed to generate FMA instruction
[stgToCmmAllowFMAInstr] :: StgToCmmConfig -> FMASign -> Bool

-- | Disable use of precomputed standard thunks.
[stgToCmmTickyAP] :: StgToCmmConfig -> !Bool

-- | Save a foreign call target to a Cmm local, see Note [Saving foreign
--   call target to local] for details
[stgToCmmSaveFCallTargetToLocal] :: StgToCmmConfig -> !Bool

-- | Error (if any) to raise when vector instructions are used, see
--   <tt>StgToCmm.Prim.checkVecCompatibility</tt>
[stgToCmmVecInstrsErr] :: StgToCmmConfig -> Maybe String

-- | check for Advanced Vector Extensions
[stgToCmmAvx] :: StgToCmmConfig -> !Bool

-- | check for Advanced Vector Extensions 2
[stgToCmmAvx2] :: StgToCmmConfig -> !Bool

-- | check for Advanced Vector 512-bit Extensions
[stgToCmmAvx512f] :: StgToCmmConfig -> !Bool
stgToCmmPlatform :: StgToCmmConfig -> Platform


-- | Linker configuration
module GHC.Linker.Config
data FrameworkOpts
FrameworkOpts :: [String] -> [String] -> FrameworkOpts
[foFrameworkPaths] :: FrameworkOpts -> [String]
[foCmdlineFrameworks] :: FrameworkOpts -> [String]

-- | External linker configuration
data LinkerConfig
LinkerConfig :: String -> [Option] -> [Option] -> TempDir -> (String -> String) -> LinkerConfig

-- | Linker program
[linkerProgram] :: LinkerConfig -> String

-- | Linker options (before user options)
[linkerOptionsPre] :: LinkerConfig -> [Option]

-- | Linker options (after user options)
[linkerOptionsPost] :: LinkerConfig -> [Option]

-- | Temporary directory to use
[linkerTempDir] :: LinkerConfig -> TempDir

-- | Output filter
[linkerFilter] :: LinkerConfig -> String -> String


-- | The <a>TPipelineClass</a> and <a>MonadUse</a> classes and associated
--   types
module GHC.Driver.Pipeline.Monad
type TPipelineClass (f :: Type -> Type) (m :: Type -> Type) = (Functor m, MonadIO m, Applicative m, Monad m, MonadUse f m)

-- | Lift a <tt>f</tt> action into an <tt>m</tt> action.
class MonadUse (f :: k -> Type) (m :: k -> Type)
use :: forall (a :: k). MonadUse f m => f a -> m a
data PipeEnv
PipeEnv :: StopPhase -> String -> String -> String -> Phase -> PipelineOutput -> PipeEnv

-- | Stop just after this phase
[stop_phase] :: PipeEnv -> StopPhase

-- | basename of original input source
[src_filename] :: PipeEnv -> String

-- | basename of original input source
[src_basename] :: PipeEnv -> String

-- | its extension
[src_suffix] :: PipeEnv -> String
[start_phase] :: PipeEnv -> Phase

-- | says where to put the pipeline output
[output_spec] :: PipeEnv -> PipelineOutput
data PipelineOutput

-- | Output should be to a temporary file: we're going to run more
--   compilation steps on this output later.
Temporary :: TempFileLifetime -> PipelineOutput

-- | We want a persistent file, i.e. a file in the current directory
--   derived from the input filename, but with the appropriate extension.
--   eg. in "ghc -c Foo.hs" the output goes into ./Foo.o.
Persistent :: PipelineOutput

-- | The output must go into the specific outputFile in DynFlags. We don't
--   store the filename in the constructor as it changes when doing
--   -dynamic-too.
SpecificFile :: PipelineOutput

-- | No output should be created, like in Interpreter or NoBackend.
NoOutputFile :: PipelineOutput
instance GHC.Internal.Show.Show GHC.Driver.Pipeline.Monad.PipelineOutput

module GHC.SysTools.Process

-- | Enable process jobs support on Windows if it can be expected to work
--   (e.g. <tt>process &gt;= 1.6.9.0</tt>).
enableProcessJobs :: CreateProcess -> CreateProcess
readCreateProcessWithExitCode' :: CreateProcess -> IO (ExitCode, String)
replaceVar :: (String, String) -> [(String, String)] -> [(String, String)]

-- | Version of <tt>System.Process.readProcessWithExitCode</tt> that takes
--   a key-value tuple to insert into the environment.
readProcessEnvWithExitCode :: String -> [String] -> (String, String) -> IO (ExitCode, String, String)
c_locale_env :: (String, String)
getGccEnv :: [Option] -> IO (Maybe [(String, String)])
runSomething :: Logger -> String -> String -> [Option] -> IO ()

-- | Run a command, placing the arguments in an external response file.
--   
--   This command is used in order to avoid overlong command line arguments
--   on Windows. The command line arguments are first written to an
--   external, temporary response file, and then passed to the linker via
--   @filepath. response files for passing them in. See:
--   
--   <a>https://gcc.gnu.org/wiki/Response_Files</a>
--   <a>https://gitlab.haskell.org/ghc/ghc/issues/10777</a>
runSomethingResponseFile :: Logger -> TmpFs -> TempDir -> (String -> String) -> String -> String -> [Option] -> Maybe [(String, String)] -> IO ()
runSomethingFiltered :: Logger -> (String -> String) -> String -> String -> [Option] -> Maybe FilePath -> Maybe [(String, String)] -> IO ()
runSomethingWith :: Logger -> String -> String -> [Option] -> ([String] -> IO (ExitCode, a)) -> IO a
handleProc :: String -> String -> IO (ExitCode, r) -> IO r
builderMainLoop :: Logger -> (String -> String) -> FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO ExitCode
readerProc :: Chan BuildMessage -> Handle -> (String -> String) -> IO ()
parseError :: String -> Maybe (String, Int, Int, String)

-- | Break a line of an error message into a filename and the rest of the
--   line, taking care to ignore colons in Windows drive letters (as noted
--   in #17786). For instance,
--   
--   <ul>
--   <li><tt>"hi.c: ABCD"</tt> is mapped to <tt>Just ("hi.c",
--   "ABCD")</tt></li>
--   <li><tt>"C:\hi.c: ABCD"</tt> is mapped to <tt>Just ("C:\hi.c",
--   "ABCD")</tt></li>
--   </ul>
breakColon :: String -> Maybe (String, String)
breakIntColon :: String -> Maybe (Int, String)
data BuildMessage
BuildMsg :: !SDoc -> BuildMessage
BuildError :: !SrcLoc -> !SDoc -> BuildMessage
EOF :: BuildMessage
linesPlatform :: String -> [String]

module GHC.SysTools.Elf

-- | Given a section name, read its contents as a ByteString.
--   
--   If the section isn't found or if there is any parsing error, we return
--   Nothing
readElfSectionByName :: Logger -> ByteString -> String -> IO (Maybe ByteString)

-- | read a Note as a String
--   
--   If you try to read a note from a section which does not support the
--   Note format, the parsing is likely to fail and Nothing will be
--   returned
readElfNoteAsString :: Logger -> FilePath -> String -> String -> IO (Maybe String)

-- | Generate the GAS code to create a Note section
--   
--   Header fields for notes are 32-bit long (see Note [ELF
--   specification]).
makeElfNote :: Platform -> String -> String -> Word32 -> String -> SDoc


-- | External ("system") linker
module GHC.Linker.External

-- | External linker configuration
data LinkerConfig
LinkerConfig :: String -> [Option] -> [Option] -> TempDir -> (String -> String) -> LinkerConfig

-- | Linker program
[linkerProgram] :: LinkerConfig -> String

-- | Linker options (before user options)
[linkerOptionsPre] :: LinkerConfig -> [Option]

-- | Linker options (after user options)
[linkerOptionsPost] :: LinkerConfig -> [Option]

-- | Temporary directory to use
[linkerTempDir] :: LinkerConfig -> TempDir

-- | Output filter
[linkerFilter] :: LinkerConfig -> String -> String

-- | Run the external linker
runLink :: Logger -> TmpFs -> LinkerConfig -> [Option] -> IO ()


-- | This module exports the <a>Backend</a> type and all the available
--   values of that type. The type is abstract, and GHC assumes a "closed
--   world": all the back ends are known and are known here. The compiler
--   driver chooses a <a>Backend</a> value based on how it is asked to
--   generate code.
--   
--   A <a>Backend</a> value encapsulates the knowledge needed to take Cmm,
--   STG, or Core and write assembly language to a file. A back end also
--   provides a function that enables the compiler driver to run an
--   assembler on the code that is written, if any (the "post-backend
--   pipeline"). Finally, a back end has myriad <i>properties</i>.
--   Properties mediate interactions between a back end and the rest of the
--   compiler, especially the driver. Examples include the following:
--   
--   <ul>
--   <li>Property <a>backendValidityOfCImport</a> says whether the back end
--   can import foreign C functions.</li>
--   <li>Property <a>backendForcesOptimization0</a> says whether the back
--   end can be used with optimization levels higher than `-O0`.</li>
--   <li>Property <a>backendCDefs</a> tells the compiler driver, "if you're
--   using this back end, then these are the command-line flags you should
--   add to any invocation of the C compiler."</li>
--   </ul>
--   
--   These properties are used elsewhere in GHC, primarily in the driver,
--   to fine-tune operations according to the capabilities of the chosen
--   back end. You might use a property to make GHC aware of a potential
--   limitation of certain back ends, or a special feature available only
--   in certain back ends. If your client code needs to know a fact that is
--   not exposed in an existing property, you would define and export a new
--   property. Conditioning client code on the <i>identity</i> or
--   <i>name</i> of a back end is Not Done.
--   
--   For full details, see the documentation of each property.
module GHC.Driver.Backend

-- | A value of type <tt>Backend</tt> represents one of GHC's back ends.
--   The set of back ends cannot be extended except by modifying the
--   definition of <tt>Backend</tt> in this module.
--   
--   The <tt>Backend</tt> type is abstract; that is, its value constructors
--   are not exported. It's crucial that they not be exported, because a
--   value of type <tt>Backend</tt> carries only the back end's
--   <i>name</i>, not its behavior or properties. If <tt>Backend</tt> were
--   not abstract, then code elsewhere in the compiler could depend
--   directly on the name, not on the semantics, which would make it
--   challenging to create a new back end. Because <tt>Backend</tt>
--   <i>is</i> abstract, all the obligations of a new back end are
--   enumerated in this module, in the form of functions that take
--   <tt>Backend</tt> as an argument.
--   
--   The issue of abstraction is discussed at great length in #20927 and
--   !7442.
data Backend

-- | The native code generator. Compiles Cmm code into textual assembler,
--   then relies on an external assembler toolchain to produce machine
--   code.
--   
--   Only supports a few platforms (X86, PowerPC, SPARC).
--   
--   See <a>GHC.CmmToAsm</a>.
ncgBackend :: Backend

-- | The LLVM backend.
--   
--   Compiles Cmm code into LLVM textual IR, then relies on LLVM toolchain
--   to produce machine code.
--   
--   It relies on LLVM support for the calling convention used by the NCG
--   backend to produce code objects ABI compatible with it (see "cc 10" or
--   "ghccc" calling convention in
--   <a>https://llvm.org/docs/LangRef.html#calling-conventions)</a>.
--   
--   Supports a few platforms (X86, AArch64, s390x, ARM).
--   
--   See <a>GHC.CmmToLlvm</a>
llvmBackend :: Backend

-- | The JavaScript Backend
--   
--   See documentation in GHC.StgToJS
jsBackend :: Backend

-- | Via-C ("unregisterised") backend.
--   
--   Compiles Cmm code into C code, then relies on a C compiler to produce
--   machine code.
--   
--   It produces code objects that are <i>not</i> ABI compatible with those
--   produced by NCG and LLVM backends.
--   
--   Produced code is expected to be less efficient than the one produced
--   by NCG and LLVM backends because STG registers are not pinned into
--   real registers. On the other hand, it supports more target platforms
--   (those having a valid C toolchain).
--   
--   See <a>GHC.CmmToC</a>
viaCBackend :: Backend

-- | The ByteCode interpreter.
--   
--   Produce ByteCode objects (BCO, see <a>GHC.ByteCode</a>) that can be
--   interpreted. It is used by GHCi.
--   
--   Currently some extensions are not supported (foreign primops).
--   
--   See <a>GHC.StgToByteCode</a>
interpreterBackend :: Backend

-- | A dummy back end that generates no code.
--   
--   Use this back end to disable code generation. It is particularly
--   useful when GHC is used as a library for other purpose than generating
--   code (e.g. to generate documentation with Haddock) or when the user
--   requested it (via `-fno-code`) for some reason.
noBackend :: Backend

-- | A list of all back ends. They are ordered as we wish them to appear
--   when they are enumerated in error messages.
allBackends :: [Backend]

-- | This enumeration type specifies how the back end wishes GHC's
--   primitives to be implemented. (Module <a>GHC.StgToCmm.Prim</a>
--   provides a generic implementation of every primitive, but some
--   primitives, like <tt>IntQuotRemOp</tt>, can be implemented more
--   efficiently by certain back ends on certain platforms. For example, by
--   using a machine instruction that simultaneously computes quotient and
--   remainder.)
--   
--   For the meaning of each alternative, consult
--   <a>GHC.StgToCmm.Config</a>. (In a perfect world, type
--   <a>PrimitiveImplementation</a> would be defined there, in the module
--   that determines its meaning. But I could not figure out how to do it
--   without mutual recursion across module boundaries.)
data PrimitiveImplementation

-- | Primitives supported by LLVM
LlvmPrimitives :: PrimitiveImplementation

-- | Primitives supported by the native code generator
NcgPrimitives :: PrimitiveImplementation

-- | Primitives supported by JS backend
JSPrimitives :: PrimitiveImplementation

-- | Primitives supported by all back ends
GenericPrimitives :: PrimitiveImplementation

-- | Names a function that generates code and writes the results to a file,
--   of this type:
--   
--   <pre>
--      Logger
--   -&gt; DynFlags
--   -&gt; Module -- ^ module being compiled
--   -&gt; ModLocation
--   -&gt; FilePath -- ^ Where to write output
--   -&gt; Set UnitId -- ^ dependencies
--   -&gt; Stream IO RawCmmGroup a -- results from `StgToCmm`
--   -&gt; IO a
--   </pre>
--   
--   The functions so named are defined in <a>GHC.Driver.CodeOutput</a>.
--   
--   We expect one function per back end—or more precisely, one function
--   for each back end that writes code to a file. (The interpreter does
--   not write to files; its output lives only in memory.)
data DefunctionalizedCodeOutput
NcgCodeOutput :: DefunctionalizedCodeOutput
ViaCCodeOutput :: DefunctionalizedCodeOutput
LlvmCodeOutput :: DefunctionalizedCodeOutput
JSCodeOutput :: DefunctionalizedCodeOutput

-- | Names a function that tells the driver what should happen after
--   assembly code is written. This might include running a C compiler,
--   running LLVM, running an assembler, or various similar activities. The
--   function named normally has this type:
--   
--   <pre>
--      TPipelineClass TPhase m
--   =&gt; PipeEnv
--   -&gt; HscEnv
--   -&gt; Maybe ModLocation
--   -&gt; FilePath
--   -&gt; m (Maybe FilePath)
--   </pre>
--   
--   The functions so named are defined in <a>GHC.Driver.Pipeline</a>.
data DefunctionalizedPostHscPipeline
NcgPostHscPipeline :: DefunctionalizedPostHscPipeline
ViaCPostHscPipeline :: DefunctionalizedPostHscPipeline
LlvmPostHscPipeline :: DefunctionalizedPostHscPipeline
JSPostHscPipeline :: DefunctionalizedPostHscPipeline

-- | After code generation, nothing else need happen.
NoPostHscPipeline :: DefunctionalizedPostHscPipeline

-- | Names a function that tells the driver what command-line options to
--   include when invoking a C compiler. It's meant for <tt>-D</tt> options
--   that define symbols for the C preprocessor. Because the exact symbols
--   defined might depend on versions of tools located in the file system
--   (<i>cough</i> LLVM <i>cough</i>), the function requires an <a>IO</a>
--   action. The function named has this type:
--   
--   <pre>
--   Logger -&gt; DynFlags -&gt; IO [String]
--   </pre>
data DefunctionalizedCDefs

-- | No additional command-line options are needed
NoCDefs :: DefunctionalizedCDefs

-- | Return command-line options that tell GHC about the LLVM version.
LlvmCDefs :: DefunctionalizedCDefs
data BackendName

-- | An informal description of the back end, for use in issuing warning
--   messages <i>only</i>. If code depends on what's in the string, you
--   deserve what happens to you.
backendDescription :: Backend -> String

-- | This flag tells the compiler driver whether the back end will write
--   files: interface files and object files. It is typically true for
--   "real" back ends that generate code into the filesystem. (That means,
--   not the interpreter.)
backendWritesFiles :: Backend -> Bool

-- | When the back end does write files, this value tells the compiler in
--   what manner of file the output should go: temporary, persistent, or
--   specific.
backendPipelineOutput :: Backend -> PipelineOutput

-- | This flag tells the driver whether the back end can reuse code
--   (bytecode or object code) that has been loaded dynamically. Likely
--   true only of the interpreter.
backendCanReuseLoadedCode :: Backend -> Bool

-- | It is is true of every back end except <tt>-fno-code</tt> that it
--   "generates code." Surprisingly, this property influences the driver in
--   a ton of ways. Some examples:
--   
--   <ul>
--   <li>If the back end does not generate code, then the driver needs to
--   turn on code generation for Template Haskell (because that code needs
--   to be generated and run at compile time).</li>
--   <li>If the back end does not generate code, then the driver does not
--   need to deal with an output file.</li>
--   <li>If the back end <i>does</i> generated code, then the driver
--   supports <tt>HscRecomp</tt>. If not, recompilation does not need a
--   linkable (and is automatically up to date).</li>
--   </ul>
backendGeneratesCode :: Backend -> Bool
backendGeneratesCodeForHsBoot :: Backend -> Bool

-- | When set, this flag turns on interface writing for Backpack. It should
--   probably be the same as <a>backendGeneratesCode</a>, but it is kept
--   distinct for reasons described in Note [-fno-code mode].
backendSupportsInterfaceWriting :: Backend -> Bool

-- | When preparing code for this back end, the type checker should pay
--   attention to SPECIALISE pragmas. If this flag is <a>False</a>, then
--   the type checker ignores SPECIALISE pragmas (for imported things?).
backendRespectsSpecialise :: Backend -> Bool

-- | This back end wants the <tt>mi_top_env</tt> field of a
--   <tt>ModIface</tt> to be populated (with the top-level bindings of the
--   original source). Only true for the interpreter.
backendWantsGlobalBindings :: Backend -> Bool

-- | The back end targets a technology that implements <tt>switch</tt>
--   natively. (For example, LLVM or C.) Therefore it is not necessary for
--   GHC to ccompile a Cmm <tt>Switch</tt> form into a decision tree with
--   jump tables at the leaves.
backendHasNativeSwitch :: Backend -> Bool

-- | As noted in the documentation for <a>PrimitiveImplementation</a>,
--   certain primitives have multiple implementations, depending on the
--   capabilities of the back end. This field signals to module
--   <a>GHC.StgToCmm.Prim</a> what implementations to use with this back
--   end.
backendPrimitiveImplementation :: Backend -> PrimitiveImplementation

-- | When this value is <a>IsValid</a>, the back end is compatible with
--   vector instructions. When it is <a>NotValid</a>, it carries a message
--   that is shown to users.
backendSimdValidity :: Backend -> Validity' String

-- | This flag says whether the back end supports large binary blobs. See
--   Note [Embedding large binary blobs] in <a>GHC.CmmToAsm.Ppr</a>.
backendSupportsEmbeddedBlobs :: Backend -> Bool

-- | This flag tells the compiler driver that the back end does not support
--   every target platform; it supports only platforms that claim NCG
--   support. (It's set only for the native code generator.) Crufty. If the
--   driver tries to use the native code generator <i>without</i> platform
--   support, the driver fails over to the LLVM back end.
backendNeedsPlatformNcgSupport :: Backend -> Bool

-- | This flag is set if the back end can generate code for proc points. If
--   the flag is not set, then a Cmm pass needs to split proc points (that
--   is, turn each proc point into a standalone procedure).
backendSupportsUnsplitProcPoints :: Backend -> Bool

-- | This flag guides the driver in resolving issues about API support on
--   the target platform. If the flag is set, then these things are true:
--   
--   <ul>
--   <li>When the target platform supports <i>only</i> an unregisterised
--   API, this backend can be replaced with compilation via C.</li>
--   <li>When the target does <i>not</i> support an unregisterised API,
--   this back end can replace compilation via C.</li>
--   </ul>
backendSwappableWithViaC :: Backend -> Bool

-- | This flag is true if the back end works *only* with the unregisterised
--   ABI.
backendUnregisterisedAbiOnly :: Backend -> Bool

-- | This flag is set if the back end generates C code in a <tt>.hc</tt>
--   file. The flag lets the compiler driver know if the command-line flag
--   <tt>-C</tt> is meaningful.
backendGeneratesHc :: Backend -> Bool

-- | This flag says whether SPT (static pointer table) entries will be
--   inserted dynamically if needed. If this flag is <a>False</a>, then
--   <a>GHC.Iface.Tidy</a> should emit C stubs that initialize the SPT
--   entries.
backendSptIsDynamic :: Backend -> Bool

-- | If this flag is unset, then the driver ignores the flag
--   <tt>-fbreak-points</tt>, since backends other than the interpreter
--   tend to panic on breakpoints.
backendSupportsBreakpoints :: Backend -> Bool

-- | If this flag is set, then the driver forces the optimization level to
--   0, issuing a warning message if the command line requested a higher
--   optimization level.
backendForcesOptimization0 :: Backend -> Bool

-- | I don't understand exactly how this works. But if this flag is set
--   *and* another condition is met, then <tt>ghc/Main.hs</tt> will alter
--   the <tt>DynFlags</tt> so that all the <tt>hostFullWays</tt> are asked
--   for. It is set only for the interpreter.
backendNeedsFullWays :: Backend -> Bool

-- | This flag is also special for the interpreter: if a message about a
--   module needs to be shown, do we know anything special about where the
--   module came from? The Boolean argument is a <tt>recomp</tt> flag.
backendSpecialModuleSource :: Backend -> Bool -> Maybe String

-- | This flag says whether the back end supports Haskell Program Coverage
--   (HPC). If not, the compiler driver will ignore the `-fhpc` option (and
--   will issue a warning message if it is used).
backendSupportsHpc :: Backend -> Bool

-- | This flag says whether the back end supports foreign import of C
--   functions. (<a>Supports</a> means "does not barf on," so
--   <tt>-fno-code</tt> supports foreign C imports.)
backendSupportsCImport :: Backend -> Bool

-- | This flag says whether the back end supports foreign export of Haskell
--   functions to C.
backendSupportsCExport :: Backend -> Bool

-- | When using this back end, it may be necessary or advisable to pass
--   some `-D` options to a C compiler. This (defunctionalized) function
--   produces those options, if any. An IO action may be necessary in order
--   to interrogate external tools about what version they are, for
--   example.
--   
--   The function's type is <tt> Logger -&gt; DynFlags -&gt; IO [String]
--   </tt>
--   
--   This field is usually defaulted.
backendCDefs :: Backend -> DefunctionalizedCDefs

-- | This (defunctionalized) function generates code and writes it to a
--   file. The type of the function is
--   
--   <pre>
--      Logger
--   -&gt; DynFlags
--   -&gt; Module -- ^ module being compiled
--   -&gt; ModLocation
--   -&gt; FilePath -- ^ Where to write output
--   -&gt; Set UnitId -- ^ dependencies
--   -&gt; Stream IO RawCmmGroup a -- results from `StgToCmm`
--   -&gt; IO a
--   </pre>
backendCodeOutput :: Backend -> DefunctionalizedCodeOutput
backendUseJSLinker :: Backend -> Bool

-- | This (defunctionalized) function tells the compiler driver what else
--   has to be run after code output. The type of the function is
--   
--   <pre>
--      TPipelineClass TPhase m
--   =&gt; PipeEnv
--   -&gt; HscEnv
--   -&gt; Maybe ModLocation
--   -&gt; FilePath
--   -&gt; m (Maybe FilePath)
--   </pre>
backendPostHscPipeline :: Backend -> DefunctionalizedPostHscPipeline

-- | Somewhere in the compiler driver, when compiling Haskell source (as
--   opposed to a boot file or a sig file), it needs to know what to do
--   with the code that the <a>backendCodeOutput</a> writes to a file. This
--   <a>Phase</a> value gives instructions like "run the C compiler", "run
--   the assembler," or "run the LLVM Optimizer."
backendNormalSuccessorPhase :: Backend -> Phase

-- | Name of the back end, if any. Used to migrate legacy clients of the
--   GHC API. Code within the GHC source tree should not refer to a back
--   end's name.
backendName :: Backend -> BackendName

-- | When foreign C import or export is invalid, the carried value
--   enumerates the <i>valid</i> back ends.
backendValidityOfCImport :: Backend -> Validity' [Backend]

-- | When foreign C import or export is invalid, the carried value
--   enumerates the <i>valid</i> back ends.
backendValidityOfCExport :: Backend -> Validity' [Backend]
platformDefaultBackend :: Platform -> Backend

-- | Is the platform supported by the Native Code Generator?
platformNcgSupported :: Platform -> Bool
instance GHC.Internal.Show.Show GHC.Driver.Backend.Backend
instance GHC.Internal.Show.Show GHC.Driver.Backend.PrimitiveImplementation

module GHC.Cmm.Switch

-- | A value of type SwitchTargets contains the alternatives for a
--   <tt>CmmSwitch</tt> value, and knows whether the value is signed, the
--   possible range, an optional default value and a map from values to
--   jump labels.
data SwitchTargets

-- | The smart constructor mkSwitchTargets normalises the map a bit: * No
--   entries outside the range * No entries equal to the default * No
--   default if all elements have explicit values
mkSwitchTargets :: Bool -> (Integer, Integer) -> Maybe Label -> Map Integer Label -> SwitchTargets

-- | Returns the list of non-default branches of the SwitchTargets value
switchTargetsCases :: SwitchTargets -> [(Integer, Label)]

-- | Return the default label of the SwitchTargets value
switchTargetsDefault :: SwitchTargets -> Maybe Label

-- | Return the range of the SwitchTargets value
switchTargetsRange :: SwitchTargets -> (Integer, Integer)

-- | Return whether this is used for a signed value
switchTargetsSigned :: SwitchTargets -> Bool

-- | Changes all labels mentioned in the SwitchTargets value
mapSwitchTargets :: (Label -> Label) -> SwitchTargets -> SwitchTargets

-- | Changes all labels mentioned in the SwitchTargets value
mapSwitchTargetsA :: Applicative m => (Label -> m Label) -> SwitchTargets -> m SwitchTargets

-- | switchTargetsToTable creates a dense jump table, usable for code
--   generation.
--   
--   Also returns an offset to add to the value; the list is 0-based on the
--   result of that addition.
--   
--   The conversion from Integer to Int is a bit of a wart, as the actual
--   scrutinee might be an unsigned word, but it just works, due to
--   wrap-around arithmetic (as verified by the CmmSwitchTest test case).
switchTargetsToTable :: SwitchTargets -> (Int, [Maybe Label])

-- | Groups cases with equal targets, suitable for pretty-printing to a
--   c-like switch statement with fall-through semantics.
switchTargetsFallThrough :: SwitchTargets -> ([(NonEmpty Integer, Label)], Maybe Label)

-- | The list of all labels occurring in the SwitchTargets value.
switchTargetsToList :: SwitchTargets -> [Label]

-- | Custom equality helper, needed for <a>GHC.Cmm.CommonBlockElim</a>
eqSwitchTargetWith :: (Label -> Label -> Bool) -> SwitchTargets -> SwitchTargets -> Bool

-- | A SwitchPlan abstractly describes how a Switch statement ought to be
--   implemented. See Note [createSwitchPlan]
data SwitchPlan
Unconditionally :: Label -> SwitchPlan
IfEqual :: Integer -> Label -> SwitchPlan -> SwitchPlan
IfLT :: Bool -> Integer -> SwitchPlan -> SwitchPlan -> SwitchPlan
JumpTable :: SwitchTargets -> SwitchPlan

-- | The back end targets a technology that implements <tt>switch</tt>
--   natively. (For example, LLVM or C.) Therefore it is not necessary for
--   GHC to ccompile a Cmm <tt>Switch</tt> form into a decision tree with
--   jump tables at the leaves.
backendHasNativeSwitch :: Backend -> Bool

-- | This function creates a SwitchPlan from a SwitchTargets value,
--   breaking it down into smaller pieces suitable for code generation.
createSwitchPlan :: SwitchTargets -> SwitchPlan
instance GHC.Classes.Eq GHC.Cmm.Switch.SwitchTargets
instance GHC.Internal.Show.Show GHC.Cmm.Switch.SwitchPlan
instance GHC.Internal.Show.Show GHC.Cmm.Switch.SwitchTargets

module GHC.Driver.Pipeline.LogQueue

-- | Each module is given a unique <a>LogQueue</a> to redirect compilation
--   messages to. A <a>Nothing</a> value contains the result of
--   compilation, and denotes the end of the message queue.
data LogQueue
LogQueue :: !Int -> !IORef [Maybe (MessageClass, SrcSpan, SDoc, LogFlags)] -> !MVar () -> LogQueue
[logQueueId] :: LogQueue -> !Int
[logQueueMessages] :: LogQueue -> !IORef [Maybe (MessageClass, SrcSpan, SDoc, LogFlags)]
[logQueueSemaphore] :: LogQueue -> !MVar ()
newLogQueue :: Int -> IO LogQueue
finishLogQueue :: LogQueue -> IO ()
writeLogQueue :: LogQueue -> (MessageClass, SrcSpan, SDoc, LogFlags) -> IO ()
parLogAction :: LogQueue -> LogAction
data LogQueueQueue
LogQueueQueue :: Int -> IntMap LogQueue -> LogQueueQueue
initLogQueue :: TVar LogQueueQueue -> LogQueue -> STM ()

-- | Return all items in the queue in ascending order
allLogQueues :: LogQueueQueue -> [LogQueue]
newLogQueueQueue :: LogQueueQueue
logThread :: Logger -> TVar Bool -> TVar LogQueueQueue -> IO (IO ())

module GHC.Core.Opt.Stats
data SimplCount
doSimplTick :: Int -> Tick -> SimplCount -> SimplCount
doFreeSimplTick :: Tick -> SimplCount -> SimplCount
simplCountN :: SimplCount -> Int
pprSimplCount :: SimplCount -> SDoc
plusSimplCount :: SimplCount -> SimplCount -> SimplCount
zeroSimplCount :: Bool -> SimplCount
isZeroSimplCount :: SimplCount -> Bool
hasDetailedCounts :: SimplCount -> Bool
data Tick
PreInlineUnconditionally :: Id -> Tick
PostInlineUnconditionally :: Id -> Tick
UnfoldingDone :: Id -> Tick
RuleFired :: FastString -> Tick
LetFloatFromLet :: Tick
EtaExpansion :: Id -> Tick
EtaReduction :: Id -> Tick
BetaReduction :: Id -> Tick
CaseOfCase :: Id -> Tick
KnownBranch :: Id -> Tick
CaseMerge :: Id -> Tick
AltMerge :: Id -> Tick
CaseElim :: Id -> Tick
CaseIdentity :: Id -> Tick
FillInCaseDefault :: Id -> Tick
SimplifierDone :: Tick
instance GHC.Classes.Eq GHC.Core.Opt.Stats.Tick
instance GHC.Classes.Ord GHC.Core.Opt.Stats.Tick
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Stats.Tick

module GHC.Builtin.PrimOps
data PrimOp
CharGtOp :: PrimOp
CharGeOp :: PrimOp
CharEqOp :: PrimOp
CharNeOp :: PrimOp
CharLtOp :: PrimOp
CharLeOp :: PrimOp
OrdOp :: PrimOp
Int8ToIntOp :: PrimOp
IntToInt8Op :: PrimOp
Int8NegOp :: PrimOp
Int8AddOp :: PrimOp
Int8SubOp :: PrimOp
Int8MulOp :: PrimOp
Int8QuotOp :: PrimOp
Int8RemOp :: PrimOp
Int8QuotRemOp :: PrimOp
Int8SllOp :: PrimOp
Int8SraOp :: PrimOp
Int8SrlOp :: PrimOp
Int8ToWord8Op :: PrimOp
Int8EqOp :: PrimOp
Int8GeOp :: PrimOp
Int8GtOp :: PrimOp
Int8LeOp :: PrimOp
Int8LtOp :: PrimOp
Int8NeOp :: PrimOp
Word8ToWordOp :: PrimOp
WordToWord8Op :: PrimOp
Word8AddOp :: PrimOp
Word8SubOp :: PrimOp
Word8MulOp :: PrimOp
Word8QuotOp :: PrimOp
Word8RemOp :: PrimOp
Word8QuotRemOp :: PrimOp
Word8AndOp :: PrimOp
Word8OrOp :: PrimOp
Word8XorOp :: PrimOp
Word8NotOp :: PrimOp
Word8SllOp :: PrimOp
Word8SrlOp :: PrimOp
Word8ToInt8Op :: PrimOp
Word8EqOp :: PrimOp
Word8GeOp :: PrimOp
Word8GtOp :: PrimOp
Word8LeOp :: PrimOp
Word8LtOp :: PrimOp
Word8NeOp :: PrimOp
Int16ToIntOp :: PrimOp
IntToInt16Op :: PrimOp
Int16NegOp :: PrimOp
Int16AddOp :: PrimOp
Int16SubOp :: PrimOp
Int16MulOp :: PrimOp
Int16QuotOp :: PrimOp
Int16RemOp :: PrimOp
Int16QuotRemOp :: PrimOp
Int16SllOp :: PrimOp
Int16SraOp :: PrimOp
Int16SrlOp :: PrimOp
Int16ToWord16Op :: PrimOp
Int16EqOp :: PrimOp
Int16GeOp :: PrimOp
Int16GtOp :: PrimOp
Int16LeOp :: PrimOp
Int16LtOp :: PrimOp
Int16NeOp :: PrimOp
Word16ToWordOp :: PrimOp
WordToWord16Op :: PrimOp
Word16AddOp :: PrimOp
Word16SubOp :: PrimOp
Word16MulOp :: PrimOp
Word16QuotOp :: PrimOp
Word16RemOp :: PrimOp
Word16QuotRemOp :: PrimOp
Word16AndOp :: PrimOp
Word16OrOp :: PrimOp
Word16XorOp :: PrimOp
Word16NotOp :: PrimOp
Word16SllOp :: PrimOp
Word16SrlOp :: PrimOp
Word16ToInt16Op :: PrimOp
Word16EqOp :: PrimOp
Word16GeOp :: PrimOp
Word16GtOp :: PrimOp
Word16LeOp :: PrimOp
Word16LtOp :: PrimOp
Word16NeOp :: PrimOp
Int32ToIntOp :: PrimOp
IntToInt32Op :: PrimOp
Int32NegOp :: PrimOp
Int32AddOp :: PrimOp
Int32SubOp :: PrimOp
Int32MulOp :: PrimOp
Int32QuotOp :: PrimOp
Int32RemOp :: PrimOp
Int32QuotRemOp :: PrimOp
Int32SllOp :: PrimOp
Int32SraOp :: PrimOp
Int32SrlOp :: PrimOp
Int32ToWord32Op :: PrimOp
Int32EqOp :: PrimOp
Int32GeOp :: PrimOp
Int32GtOp :: PrimOp
Int32LeOp :: PrimOp
Int32LtOp :: PrimOp
Int32NeOp :: PrimOp
Word32ToWordOp :: PrimOp
WordToWord32Op :: PrimOp
Word32AddOp :: PrimOp
Word32SubOp :: PrimOp
Word32MulOp :: PrimOp
Word32QuotOp :: PrimOp
Word32RemOp :: PrimOp
Word32QuotRemOp :: PrimOp
Word32AndOp :: PrimOp
Word32OrOp :: PrimOp
Word32XorOp :: PrimOp
Word32NotOp :: PrimOp
Word32SllOp :: PrimOp
Word32SrlOp :: PrimOp
Word32ToInt32Op :: PrimOp
Word32EqOp :: PrimOp
Word32GeOp :: PrimOp
Word32GtOp :: PrimOp
Word32LeOp :: PrimOp
Word32LtOp :: PrimOp
Word32NeOp :: PrimOp
Int64ToIntOp :: PrimOp
IntToInt64Op :: PrimOp
Int64NegOp :: PrimOp
Int64AddOp :: PrimOp
Int64SubOp :: PrimOp
Int64MulOp :: PrimOp
Int64QuotOp :: PrimOp
Int64RemOp :: PrimOp
Int64SllOp :: PrimOp
Int64SraOp :: PrimOp
Int64SrlOp :: PrimOp
Int64ToWord64Op :: PrimOp
Int64EqOp :: PrimOp
Int64GeOp :: PrimOp
Int64GtOp :: PrimOp
Int64LeOp :: PrimOp
Int64LtOp :: PrimOp
Int64NeOp :: PrimOp
Word64ToWordOp :: PrimOp
WordToWord64Op :: PrimOp
Word64AddOp :: PrimOp
Word64SubOp :: PrimOp
Word64MulOp :: PrimOp
Word64QuotOp :: PrimOp
Word64RemOp :: PrimOp
Word64AndOp :: PrimOp
Word64OrOp :: PrimOp
Word64XorOp :: PrimOp
Word64NotOp :: PrimOp
Word64SllOp :: PrimOp
Word64SrlOp :: PrimOp
Word64ToInt64Op :: PrimOp
Word64EqOp :: PrimOp
Word64GeOp :: PrimOp
Word64GtOp :: PrimOp
Word64LeOp :: PrimOp
Word64LtOp :: PrimOp
Word64NeOp :: PrimOp
IntAddOp :: PrimOp
IntSubOp :: PrimOp
IntMulOp :: PrimOp
IntMul2Op :: PrimOp
IntMulMayOfloOp :: PrimOp
IntQuotOp :: PrimOp
IntRemOp :: PrimOp
IntQuotRemOp :: PrimOp
IntAndOp :: PrimOp
IntOrOp :: PrimOp
IntXorOp :: PrimOp
IntNotOp :: PrimOp
IntNegOp :: PrimOp
IntAddCOp :: PrimOp
IntSubCOp :: PrimOp
IntGtOp :: PrimOp
IntGeOp :: PrimOp
IntEqOp :: PrimOp
IntNeOp :: PrimOp
IntLtOp :: PrimOp
IntLeOp :: PrimOp
ChrOp :: PrimOp
IntToWordOp :: PrimOp
IntToFloatOp :: PrimOp
IntToDoubleOp :: PrimOp
WordToFloatOp :: PrimOp
WordToDoubleOp :: PrimOp
IntSllOp :: PrimOp
IntSraOp :: PrimOp
IntSrlOp :: PrimOp
WordAddOp :: PrimOp
WordAddCOp :: PrimOp
WordSubCOp :: PrimOp
WordAdd2Op :: PrimOp
WordSubOp :: PrimOp
WordMulOp :: PrimOp
WordMul2Op :: PrimOp
WordQuotOp :: PrimOp
WordRemOp :: PrimOp
WordQuotRemOp :: PrimOp
WordQuotRem2Op :: PrimOp
WordAndOp :: PrimOp
WordOrOp :: PrimOp
WordXorOp :: PrimOp
WordNotOp :: PrimOp
WordSllOp :: PrimOp
WordSrlOp :: PrimOp
WordToIntOp :: PrimOp
WordGtOp :: PrimOp
WordGeOp :: PrimOp
WordEqOp :: PrimOp
WordNeOp :: PrimOp
WordLtOp :: PrimOp
WordLeOp :: PrimOp
PopCnt8Op :: PrimOp
PopCnt16Op :: PrimOp
PopCnt32Op :: PrimOp
PopCnt64Op :: PrimOp
PopCntOp :: PrimOp
Pdep8Op :: PrimOp
Pdep16Op :: PrimOp
Pdep32Op :: PrimOp
Pdep64Op :: PrimOp
PdepOp :: PrimOp
Pext8Op :: PrimOp
Pext16Op :: PrimOp
Pext32Op :: PrimOp
Pext64Op :: PrimOp
PextOp :: PrimOp
Clz8Op :: PrimOp
Clz16Op :: PrimOp
Clz32Op :: PrimOp
Clz64Op :: PrimOp
ClzOp :: PrimOp
Ctz8Op :: PrimOp
Ctz16Op :: PrimOp
Ctz32Op :: PrimOp
Ctz64Op :: PrimOp
CtzOp :: PrimOp
BSwap16Op :: PrimOp
BSwap32Op :: PrimOp
BSwap64Op :: PrimOp
BSwapOp :: PrimOp
BRev8Op :: PrimOp
BRev16Op :: PrimOp
BRev32Op :: PrimOp
BRev64Op :: PrimOp
BRevOp :: PrimOp
Narrow8IntOp :: PrimOp
Narrow16IntOp :: PrimOp
Narrow32IntOp :: PrimOp
Narrow8WordOp :: PrimOp
Narrow16WordOp :: PrimOp
Narrow32WordOp :: PrimOp
DoubleGtOp :: PrimOp
DoubleGeOp :: PrimOp
DoubleEqOp :: PrimOp
DoubleNeOp :: PrimOp
DoubleLtOp :: PrimOp
DoubleLeOp :: PrimOp
DoubleMinOp :: PrimOp
DoubleMaxOp :: PrimOp
DoubleAddOp :: PrimOp
DoubleSubOp :: PrimOp
DoubleMulOp :: PrimOp
DoubleDivOp :: PrimOp
DoubleNegOp :: PrimOp
DoubleFabsOp :: PrimOp
DoubleToIntOp :: PrimOp
DoubleToFloatOp :: PrimOp
DoubleExpOp :: PrimOp
DoubleExpM1Op :: PrimOp
DoubleLogOp :: PrimOp
DoubleLog1POp :: PrimOp
DoubleSqrtOp :: PrimOp
DoubleSinOp :: PrimOp
DoubleCosOp :: PrimOp
DoubleTanOp :: PrimOp
DoubleAsinOp :: PrimOp
DoubleAcosOp :: PrimOp
DoubleAtanOp :: PrimOp
DoubleSinhOp :: PrimOp
DoubleCoshOp :: PrimOp
DoubleTanhOp :: PrimOp
DoubleAsinhOp :: PrimOp
DoubleAcoshOp :: PrimOp
DoubleAtanhOp :: PrimOp
DoublePowerOp :: PrimOp
DoubleDecode_2IntOp :: PrimOp
DoubleDecode_Int64Op :: PrimOp
CastDoubleToWord64Op :: PrimOp
CastWord64ToDoubleOp :: PrimOp
FloatGtOp :: PrimOp
FloatGeOp :: PrimOp
FloatEqOp :: PrimOp
FloatNeOp :: PrimOp
FloatLtOp :: PrimOp
FloatLeOp :: PrimOp
FloatMinOp :: PrimOp
FloatMaxOp :: PrimOp
FloatAddOp :: PrimOp
FloatSubOp :: PrimOp
FloatMulOp :: PrimOp
FloatDivOp :: PrimOp
FloatNegOp :: PrimOp
FloatFabsOp :: PrimOp
FloatToIntOp :: PrimOp
FloatExpOp :: PrimOp
FloatExpM1Op :: PrimOp
FloatLogOp :: PrimOp
FloatLog1POp :: PrimOp
FloatSqrtOp :: PrimOp
FloatSinOp :: PrimOp
FloatCosOp :: PrimOp
FloatTanOp :: PrimOp
FloatAsinOp :: PrimOp
FloatAcosOp :: PrimOp
FloatAtanOp :: PrimOp
FloatSinhOp :: PrimOp
FloatCoshOp :: PrimOp
FloatTanhOp :: PrimOp
FloatAsinhOp :: PrimOp
FloatAcoshOp :: PrimOp
FloatAtanhOp :: PrimOp
FloatPowerOp :: PrimOp
FloatToDoubleOp :: PrimOp
FloatDecode_IntOp :: PrimOp
CastFloatToWord32Op :: PrimOp
CastWord32ToFloatOp :: PrimOp
FloatFMAdd :: PrimOp
FloatFMSub :: PrimOp
FloatFNMAdd :: PrimOp
FloatFNMSub :: PrimOp
DoubleFMAdd :: PrimOp
DoubleFMSub :: PrimOp
DoubleFNMAdd :: PrimOp
DoubleFNMSub :: PrimOp
NewArrayOp :: PrimOp
ReadArrayOp :: PrimOp
WriteArrayOp :: PrimOp
SizeofArrayOp :: PrimOp
SizeofMutableArrayOp :: PrimOp
IndexArrayOp :: PrimOp
UnsafeFreezeArrayOp :: PrimOp
UnsafeThawArrayOp :: PrimOp
CopyArrayOp :: PrimOp
CopyMutableArrayOp :: PrimOp
CloneArrayOp :: PrimOp
CloneMutableArrayOp :: PrimOp
FreezeArrayOp :: PrimOp
ThawArrayOp :: PrimOp
CasArrayOp :: PrimOp
NewSmallArrayOp :: PrimOp
ShrinkSmallMutableArrayOp_Char :: PrimOp
ReadSmallArrayOp :: PrimOp
WriteSmallArrayOp :: PrimOp
SizeofSmallArrayOp :: PrimOp
SizeofSmallMutableArrayOp :: PrimOp
GetSizeofSmallMutableArrayOp :: PrimOp
IndexSmallArrayOp :: PrimOp
UnsafeFreezeSmallArrayOp :: PrimOp
UnsafeThawSmallArrayOp :: PrimOp
CopySmallArrayOp :: PrimOp
CopySmallMutableArrayOp :: PrimOp
CloneSmallArrayOp :: PrimOp
CloneSmallMutableArrayOp :: PrimOp
FreezeSmallArrayOp :: PrimOp
ThawSmallArrayOp :: PrimOp
CasSmallArrayOp :: PrimOp
NewByteArrayOp_Char :: PrimOp
NewPinnedByteArrayOp_Char :: PrimOp
NewAlignedPinnedByteArrayOp_Char :: PrimOp
MutableByteArrayIsPinnedOp :: PrimOp
ByteArrayIsPinnedOp :: PrimOp
ByteArrayIsWeaklyPinnedOp :: PrimOp
MutableByteArrayIsWeaklyPinnedOp :: PrimOp
ByteArrayContents_Char :: PrimOp
MutableByteArrayContents_Char :: PrimOp
ShrinkMutableByteArrayOp_Char :: PrimOp
ResizeMutableByteArrayOp_Char :: PrimOp
UnsafeFreezeByteArrayOp :: PrimOp
UnsafeThawByteArrayOp :: PrimOp
SizeofByteArrayOp :: PrimOp
SizeofMutableByteArrayOp :: PrimOp
GetSizeofMutableByteArrayOp :: PrimOp
IndexByteArrayOp_Char :: PrimOp
IndexByteArrayOp_WideChar :: PrimOp
IndexByteArrayOp_Int :: PrimOp
IndexByteArrayOp_Word :: PrimOp
IndexByteArrayOp_Addr :: PrimOp
IndexByteArrayOp_Float :: PrimOp
IndexByteArrayOp_Double :: PrimOp
IndexByteArrayOp_StablePtr :: PrimOp
IndexByteArrayOp_Int8 :: PrimOp
IndexByteArrayOp_Word8 :: PrimOp
IndexByteArrayOp_Int16 :: PrimOp
IndexByteArrayOp_Word16 :: PrimOp
IndexByteArrayOp_Int32 :: PrimOp
IndexByteArrayOp_Word32 :: PrimOp
IndexByteArrayOp_Int64 :: PrimOp
IndexByteArrayOp_Word64 :: PrimOp
IndexByteArrayOp_Word8AsChar :: PrimOp
IndexByteArrayOp_Word8AsWideChar :: PrimOp
IndexByteArrayOp_Word8AsInt :: PrimOp
IndexByteArrayOp_Word8AsWord :: PrimOp
IndexByteArrayOp_Word8AsAddr :: PrimOp
IndexByteArrayOp_Word8AsFloat :: PrimOp
IndexByteArrayOp_Word8AsDouble :: PrimOp
IndexByteArrayOp_Word8AsStablePtr :: PrimOp
IndexByteArrayOp_Word8AsInt16 :: PrimOp
IndexByteArrayOp_Word8AsWord16 :: PrimOp
IndexByteArrayOp_Word8AsInt32 :: PrimOp
IndexByteArrayOp_Word8AsWord32 :: PrimOp
IndexByteArrayOp_Word8AsInt64 :: PrimOp
IndexByteArrayOp_Word8AsWord64 :: PrimOp
ReadByteArrayOp_Char :: PrimOp
ReadByteArrayOp_WideChar :: PrimOp
ReadByteArrayOp_Int :: PrimOp
ReadByteArrayOp_Word :: PrimOp
ReadByteArrayOp_Addr :: PrimOp
ReadByteArrayOp_Float :: PrimOp
ReadByteArrayOp_Double :: PrimOp
ReadByteArrayOp_StablePtr :: PrimOp
ReadByteArrayOp_Int8 :: PrimOp
ReadByteArrayOp_Word8 :: PrimOp
ReadByteArrayOp_Int16 :: PrimOp
ReadByteArrayOp_Word16 :: PrimOp
ReadByteArrayOp_Int32 :: PrimOp
ReadByteArrayOp_Word32 :: PrimOp
ReadByteArrayOp_Int64 :: PrimOp
ReadByteArrayOp_Word64 :: PrimOp
ReadByteArrayOp_Word8AsChar :: PrimOp
ReadByteArrayOp_Word8AsWideChar :: PrimOp
ReadByteArrayOp_Word8AsInt :: PrimOp
ReadByteArrayOp_Word8AsWord :: PrimOp
ReadByteArrayOp_Word8AsAddr :: PrimOp
ReadByteArrayOp_Word8AsFloat :: PrimOp
ReadByteArrayOp_Word8AsDouble :: PrimOp
ReadByteArrayOp_Word8AsStablePtr :: PrimOp
ReadByteArrayOp_Word8AsInt16 :: PrimOp
ReadByteArrayOp_Word8AsWord16 :: PrimOp
ReadByteArrayOp_Word8AsInt32 :: PrimOp
ReadByteArrayOp_Word8AsWord32 :: PrimOp
ReadByteArrayOp_Word8AsInt64 :: PrimOp
ReadByteArrayOp_Word8AsWord64 :: PrimOp
WriteByteArrayOp_Char :: PrimOp
WriteByteArrayOp_WideChar :: PrimOp
WriteByteArrayOp_Int :: PrimOp
WriteByteArrayOp_Word :: PrimOp
WriteByteArrayOp_Addr :: PrimOp
WriteByteArrayOp_Float :: PrimOp
WriteByteArrayOp_Double :: PrimOp
WriteByteArrayOp_StablePtr :: PrimOp
WriteByteArrayOp_Int8 :: PrimOp
WriteByteArrayOp_Word8 :: PrimOp
WriteByteArrayOp_Int16 :: PrimOp
WriteByteArrayOp_Word16 :: PrimOp
WriteByteArrayOp_Int32 :: PrimOp
WriteByteArrayOp_Word32 :: PrimOp
WriteByteArrayOp_Int64 :: PrimOp
WriteByteArrayOp_Word64 :: PrimOp
WriteByteArrayOp_Word8AsChar :: PrimOp
WriteByteArrayOp_Word8AsWideChar :: PrimOp
WriteByteArrayOp_Word8AsInt :: PrimOp
WriteByteArrayOp_Word8AsWord :: PrimOp
WriteByteArrayOp_Word8AsAddr :: PrimOp
WriteByteArrayOp_Word8AsFloat :: PrimOp
WriteByteArrayOp_Word8AsDouble :: PrimOp
WriteByteArrayOp_Word8AsStablePtr :: PrimOp
WriteByteArrayOp_Word8AsInt16 :: PrimOp
WriteByteArrayOp_Word8AsWord16 :: PrimOp
WriteByteArrayOp_Word8AsInt32 :: PrimOp
WriteByteArrayOp_Word8AsWord32 :: PrimOp
WriteByteArrayOp_Word8AsInt64 :: PrimOp
WriteByteArrayOp_Word8AsWord64 :: PrimOp
CompareByteArraysOp :: PrimOp
CopyByteArrayOp :: PrimOp
CopyMutableByteArrayOp :: PrimOp
CopyMutableByteArrayNonOverlappingOp :: PrimOp
CopyByteArrayToAddrOp :: PrimOp
CopyMutableByteArrayToAddrOp :: PrimOp
CopyAddrToByteArrayOp :: PrimOp
CopyAddrToAddrOp :: PrimOp
CopyAddrToAddrNonOverlappingOp :: PrimOp
SetByteArrayOp :: PrimOp
SetAddrRangeOp :: PrimOp
AtomicReadByteArrayOp_Int :: PrimOp
AtomicWriteByteArrayOp_Int :: PrimOp
CasByteArrayOp_Int :: PrimOp
CasByteArrayOp_Int8 :: PrimOp
CasByteArrayOp_Int16 :: PrimOp
CasByteArrayOp_Int32 :: PrimOp
CasByteArrayOp_Int64 :: PrimOp
FetchAddByteArrayOp_Int :: PrimOp
FetchSubByteArrayOp_Int :: PrimOp
FetchAndByteArrayOp_Int :: PrimOp
FetchNandByteArrayOp_Int :: PrimOp
FetchOrByteArrayOp_Int :: PrimOp
FetchXorByteArrayOp_Int :: PrimOp
AddrAddOp :: PrimOp
AddrSubOp :: PrimOp
AddrRemOp :: PrimOp
AddrToIntOp :: PrimOp
IntToAddrOp :: PrimOp
AddrGtOp :: PrimOp
AddrGeOp :: PrimOp
AddrEqOp :: PrimOp
AddrNeOp :: PrimOp
AddrLtOp :: PrimOp
AddrLeOp :: PrimOp
IndexOffAddrOp_Char :: PrimOp
IndexOffAddrOp_WideChar :: PrimOp
IndexOffAddrOp_Int :: PrimOp
IndexOffAddrOp_Word :: PrimOp
IndexOffAddrOp_Addr :: PrimOp
IndexOffAddrOp_Float :: PrimOp
IndexOffAddrOp_Double :: PrimOp
IndexOffAddrOp_StablePtr :: PrimOp
IndexOffAddrOp_Int8 :: PrimOp
IndexOffAddrOp_Word8 :: PrimOp
IndexOffAddrOp_Int16 :: PrimOp
IndexOffAddrOp_Word16 :: PrimOp
IndexOffAddrOp_Int32 :: PrimOp
IndexOffAddrOp_Word32 :: PrimOp
IndexOffAddrOp_Int64 :: PrimOp
IndexOffAddrOp_Word64 :: PrimOp
IndexOffAddrOp_Word8AsChar :: PrimOp
IndexOffAddrOp_Word8AsWideChar :: PrimOp
IndexOffAddrOp_Word8AsInt :: PrimOp
IndexOffAddrOp_Word8AsWord :: PrimOp
IndexOffAddrOp_Word8AsAddr :: PrimOp
IndexOffAddrOp_Word8AsFloat :: PrimOp
IndexOffAddrOp_Word8AsDouble :: PrimOp
IndexOffAddrOp_Word8AsStablePtr :: PrimOp
IndexOffAddrOp_Word8AsInt16 :: PrimOp
IndexOffAddrOp_Word8AsWord16 :: PrimOp
IndexOffAddrOp_Word8AsInt32 :: PrimOp
IndexOffAddrOp_Word8AsWord32 :: PrimOp
IndexOffAddrOp_Word8AsInt64 :: PrimOp
IndexOffAddrOp_Word8AsWord64 :: PrimOp
ReadOffAddrOp_Char :: PrimOp
ReadOffAddrOp_WideChar :: PrimOp
ReadOffAddrOp_Int :: PrimOp
ReadOffAddrOp_Word :: PrimOp
ReadOffAddrOp_Addr :: PrimOp
ReadOffAddrOp_Float :: PrimOp
ReadOffAddrOp_Double :: PrimOp
ReadOffAddrOp_StablePtr :: PrimOp
ReadOffAddrOp_Int8 :: PrimOp
ReadOffAddrOp_Word8 :: PrimOp
ReadOffAddrOp_Int16 :: PrimOp
ReadOffAddrOp_Word16 :: PrimOp
ReadOffAddrOp_Int32 :: PrimOp
ReadOffAddrOp_Word32 :: PrimOp
ReadOffAddrOp_Int64 :: PrimOp
ReadOffAddrOp_Word64 :: PrimOp
ReadOffAddrOp_Word8AsChar :: PrimOp
ReadOffAddrOp_Word8AsWideChar :: PrimOp
ReadOffAddrOp_Word8AsInt :: PrimOp
ReadOffAddrOp_Word8AsWord :: PrimOp
ReadOffAddrOp_Word8AsAddr :: PrimOp
ReadOffAddrOp_Word8AsFloat :: PrimOp
ReadOffAddrOp_Word8AsDouble :: PrimOp
ReadOffAddrOp_Word8AsStablePtr :: PrimOp
ReadOffAddrOp_Word8AsInt16 :: PrimOp
ReadOffAddrOp_Word8AsWord16 :: PrimOp
ReadOffAddrOp_Word8AsInt32 :: PrimOp
ReadOffAddrOp_Word8AsWord32 :: PrimOp
ReadOffAddrOp_Word8AsInt64 :: PrimOp
ReadOffAddrOp_Word8AsWord64 :: PrimOp
WriteOffAddrOp_Char :: PrimOp
WriteOffAddrOp_WideChar :: PrimOp
WriteOffAddrOp_Int :: PrimOp
WriteOffAddrOp_Word :: PrimOp
WriteOffAddrOp_Addr :: PrimOp
WriteOffAddrOp_Float :: PrimOp
WriteOffAddrOp_Double :: PrimOp
WriteOffAddrOp_StablePtr :: PrimOp
WriteOffAddrOp_Int8 :: PrimOp
WriteOffAddrOp_Word8 :: PrimOp
WriteOffAddrOp_Int16 :: PrimOp
WriteOffAddrOp_Word16 :: PrimOp
WriteOffAddrOp_Int32 :: PrimOp
WriteOffAddrOp_Word32 :: PrimOp
WriteOffAddrOp_Int64 :: PrimOp
WriteOffAddrOp_Word64 :: PrimOp
WriteOffAddrOp_Word8AsChar :: PrimOp
WriteOffAddrOp_Word8AsWideChar :: PrimOp
WriteOffAddrOp_Word8AsInt :: PrimOp
WriteOffAddrOp_Word8AsWord :: PrimOp
WriteOffAddrOp_Word8AsAddr :: PrimOp
WriteOffAddrOp_Word8AsFloat :: PrimOp
WriteOffAddrOp_Word8AsDouble :: PrimOp
WriteOffAddrOp_Word8AsStablePtr :: PrimOp
WriteOffAddrOp_Word8AsInt16 :: PrimOp
WriteOffAddrOp_Word8AsWord16 :: PrimOp
WriteOffAddrOp_Word8AsInt32 :: PrimOp
WriteOffAddrOp_Word8AsWord32 :: PrimOp
WriteOffAddrOp_Word8AsInt64 :: PrimOp
WriteOffAddrOp_Word8AsWord64 :: PrimOp
InterlockedExchange_Addr :: PrimOp
InterlockedExchange_Word :: PrimOp
CasAddrOp_Addr :: PrimOp
CasAddrOp_Word :: PrimOp
CasAddrOp_Word8 :: PrimOp
CasAddrOp_Word16 :: PrimOp
CasAddrOp_Word32 :: PrimOp
CasAddrOp_Word64 :: PrimOp
FetchAddAddrOp_Word :: PrimOp
FetchSubAddrOp_Word :: PrimOp
FetchAndAddrOp_Word :: PrimOp
FetchNandAddrOp_Word :: PrimOp
FetchOrAddrOp_Word :: PrimOp
FetchXorAddrOp_Word :: PrimOp
AtomicReadAddrOp_Word :: PrimOp
AtomicWriteAddrOp_Word :: PrimOp
NewMutVarOp :: PrimOp
ReadMutVarOp :: PrimOp
WriteMutVarOp :: PrimOp
AtomicSwapMutVarOp :: PrimOp
AtomicModifyMutVar2Op :: PrimOp
AtomicModifyMutVar_Op :: PrimOp
CasMutVarOp :: PrimOp
CatchOp :: PrimOp
RaiseOp :: PrimOp
RaiseUnderflowOp :: PrimOp
RaiseOverflowOp :: PrimOp
RaiseDivZeroOp :: PrimOp
RaiseIOOp :: PrimOp
MaskAsyncExceptionsOp :: PrimOp
MaskUninterruptibleOp :: PrimOp
UnmaskAsyncExceptionsOp :: PrimOp
MaskStatus :: PrimOp
NewPromptTagOp :: PrimOp
PromptOp :: PrimOp
Control0Op :: PrimOp
AtomicallyOp :: PrimOp
RetryOp :: PrimOp
CatchRetryOp :: PrimOp
CatchSTMOp :: PrimOp
NewTVarOp :: PrimOp
ReadTVarOp :: PrimOp
ReadTVarIOOp :: PrimOp
WriteTVarOp :: PrimOp
NewMVarOp :: PrimOp
TakeMVarOp :: PrimOp
TryTakeMVarOp :: PrimOp
PutMVarOp :: PrimOp
TryPutMVarOp :: PrimOp
ReadMVarOp :: PrimOp
TryReadMVarOp :: PrimOp
IsEmptyMVarOp :: PrimOp
NewIOPortOp :: PrimOp
ReadIOPortOp :: PrimOp
WriteIOPortOp :: PrimOp
DelayOp :: PrimOp
WaitReadOp :: PrimOp
WaitWriteOp :: PrimOp
ForkOp :: PrimOp
ForkOnOp :: PrimOp
KillThreadOp :: PrimOp
YieldOp :: PrimOp
MyThreadIdOp :: PrimOp
LabelThreadOp :: PrimOp
IsCurrentThreadBoundOp :: PrimOp
NoDuplicateOp :: PrimOp
GetThreadLabelOp :: PrimOp
ThreadStatusOp :: PrimOp
ListThreadsOp :: PrimOp
MkWeakOp :: PrimOp
MkWeakNoFinalizerOp :: PrimOp
AddCFinalizerToWeakOp :: PrimOp
DeRefWeakOp :: PrimOp
FinalizeWeakOp :: PrimOp
TouchOp :: PrimOp
MakeStablePtrOp :: PrimOp
DeRefStablePtrOp :: PrimOp
EqStablePtrOp :: PrimOp
MakeStableNameOp :: PrimOp
StableNameToIntOp :: PrimOp
CompactNewOp :: PrimOp
CompactResizeOp :: PrimOp
CompactContainsOp :: PrimOp
CompactContainsAnyOp :: PrimOp
CompactGetFirstBlockOp :: PrimOp
CompactGetNextBlockOp :: PrimOp
CompactAllocateBlockOp :: PrimOp
CompactFixupPointersOp :: PrimOp
CompactAdd :: PrimOp
CompactAddWithSharing :: PrimOp
CompactSize :: PrimOp
ReallyUnsafePtrEqualityOp :: PrimOp
ParOp :: PrimOp
SparkOp :: PrimOp
GetSparkOp :: PrimOp
NumSparks :: PrimOp
KeepAliveOp :: PrimOp
DataToTagSmallOp :: PrimOp
DataToTagLargeOp :: PrimOp
TagToEnumOp :: PrimOp
AddrToAnyOp :: PrimOp
AnyToAddrOp :: PrimOp
MkApUpd0_Op :: PrimOp
NewBCOOp :: PrimOp
UnpackClosureOp :: PrimOp
ClosureSizeOp :: PrimOp
GetApStackValOp :: PrimOp
GetCCSOfOp :: PrimOp
GetCurrentCCSOp :: PrimOp
ClearCCSOp :: PrimOp
WhereFromOp :: PrimOp
TraceEventOp :: PrimOp
TraceEventBinaryOp :: PrimOp
TraceMarkerOp :: PrimOp
SetThreadAllocationCounter :: PrimOp
VecBroadcastOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecPackOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecUnpackOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecInsertOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecAddOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecSubOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecMulOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecDivOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecQuotOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecRemOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecNegOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecIndexByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecReadByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecWriteByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecIndexOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecReadOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecWriteOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecIndexScalarByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecReadScalarByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecWriteScalarByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecIndexScalarOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecReadScalarOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecWriteScalarOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecFMAdd :: PrimOpVecCat -> Length -> Width -> PrimOp
VecFMSub :: PrimOpVecCat -> Length -> Width -> PrimOp
VecFNMAdd :: PrimOpVecCat -> Length -> Width -> PrimOp
VecFNMSub :: PrimOpVecCat -> Length -> Width -> PrimOp
VecShuffleOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecMinOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecMaxOp :: PrimOpVecCat -> Length -> Width -> PrimOp
PrefetchByteArrayOp3 :: PrimOp
PrefetchMutableByteArrayOp3 :: PrimOp
PrefetchAddrOp3 :: PrimOp
PrefetchValueOp3 :: PrimOp
PrefetchByteArrayOp2 :: PrimOp
PrefetchMutableByteArrayOp2 :: PrimOp
PrefetchAddrOp2 :: PrimOp
PrefetchValueOp2 :: PrimOp
PrefetchByteArrayOp1 :: PrimOp
PrefetchMutableByteArrayOp1 :: PrimOp
PrefetchAddrOp1 :: PrimOp
PrefetchValueOp1 :: PrimOp
PrefetchByteArrayOp0 :: PrimOp
PrefetchMutableByteArrayOp0 :: PrimOp
PrefetchAddrOp0 :: PrimOp
PrefetchValueOp0 :: PrimOp
data PrimOpVecCat
IntVec :: PrimOpVecCat
WordVec :: PrimOpVecCat
FloatVec :: PrimOpVecCat
allThePrimOps :: [PrimOp]
primOpType :: PrimOp -> Type
primOpSig :: PrimOp -> ([TyVarBinder], [Type], Type, Arity, DmdSig)
primOpResultType :: PrimOp -> Type
primOpTag :: PrimOp -> Int
maxPrimOpTag :: Int
primOpOcc :: PrimOp -> OccName

-- | Returns the <a>Id</a> of the wrapper associated with the given
--   <a>PrimOp</a>. See Note [Primop wrappers].
primOpWrapperId :: PrimOp -> Id
pprPrimOp :: IsLine doc => PrimOp -> doc
tagToEnumKey :: Unique
primOpOutOfLine :: PrimOp -> Bool
primOpCodeSize :: PrimOp -> Int
primOpOkForSpeculation :: PrimOp -> Bool
primOpOkToDiscard :: PrimOp -> Bool
primOpIsWorkFree :: PrimOp -> Bool
primOpIsCheap :: PrimOp -> Bool
primOpFixity :: PrimOp -> Maybe Fixity
primOpDocs :: [(FastString, String)]
primOpDeprecations :: [(OccName, FastString)]

-- | True of dyadic operators that can fail only if the second arg is zero!
--   
--   This function probably belongs in an automagically generated file..
--   but it's such a special case I thought I'd leave it here for now.
primOpIsDiv :: PrimOp -> Bool

-- | Indicate if a primop is really inline: that is, it isn't out-of-line
--   and it isn't DataToTagOp which are two primops that evaluate their
--   argument hence induce thread<i>stack</i>heap changes.
primOpIsReallyInline :: PrimOp -> Bool
data PrimOpEffect
NoEffect :: PrimOpEffect
CanFail :: PrimOpEffect
ThrowsException :: PrimOpEffect
ReadWriteEffect :: PrimOpEffect
primOpEffect :: PrimOp -> PrimOpEffect
getPrimOpResultInfo :: PrimOp -> PrimOpResultInfo
isComparisonPrimOp :: PrimOp -> Bool
data PrimOpResultInfo
ReturnsVoid :: PrimOpResultInfo
ReturnsPrim :: PrimRep -> PrimOpResultInfo
ReturnsTuple :: PrimOpResultInfo
data PrimCall
PrimCall :: CLabelString -> Unit -> PrimCall
instance GHC.Classes.Eq GHC.Builtin.PrimOps.PrimOp
instance GHC.Classes.Eq GHC.Builtin.PrimOps.PrimOpEffect
instance GHC.Classes.Ord GHC.Builtin.PrimOps.PrimOp
instance GHC.Classes.Ord GHC.Builtin.PrimOps.PrimOpEffect
instance GHC.Utils.Outputable.Outputable GHC.Builtin.PrimOps.PrimCall
instance GHC.Utils.Outputable.Outputable GHC.Builtin.PrimOps.PrimOp

module GHC.Stg.Syntax
data StgArg
StgVarArg :: Id -> StgArg
StgLitArg :: Literal -> StgArg

-- | A top-level binding.
data GenStgTopBinding (pass :: StgPass)
StgTopLifted :: GenStgBinding pass -> GenStgTopBinding (pass :: StgPass)
StgTopStringLit :: Id -> ByteString -> GenStgTopBinding (pass :: StgPass)
data GenStgBinding (pass :: StgPass)
StgNonRec :: BinderP pass -> GenStgRhs pass -> GenStgBinding (pass :: StgPass)
StgRec :: [(BinderP pass, GenStgRhs pass)] -> GenStgBinding (pass :: StgPass)
data GenStgExpr (pass :: StgPass)
StgApp :: Id -> [StgArg] -> GenStgExpr (pass :: StgPass)
StgLit :: Literal -> GenStgExpr (pass :: StgPass)
StgConApp :: DataCon -> ConstructorNumber -> [StgArg] -> [[PrimRep]] -> GenStgExpr (pass :: StgPass)
StgOpApp :: StgOp -> [StgArg] -> Type -> GenStgExpr (pass :: StgPass)
StgCase :: GenStgExpr pass -> BinderP pass -> AltType -> [GenStgAlt pass] -> GenStgExpr (pass :: StgPass)
StgLet :: XLet pass -> GenStgBinding pass -> GenStgExpr pass -> GenStgExpr (pass :: StgPass)
StgLetNoEscape :: XLetNoEscape pass -> GenStgBinding pass -> GenStgExpr pass -> GenStgExpr (pass :: StgPass)
StgTick :: StgTickish -> GenStgExpr pass -> GenStgExpr (pass :: StgPass)
data GenStgRhs (pass :: StgPass)
StgRhsClosure :: XRhsClosure pass -> CostCentreStack -> !UpdateFlag -> [BinderP pass] -> GenStgExpr pass -> Type -> GenStgRhs (pass :: StgPass)
StgRhsCon :: CostCentreStack -> DataCon -> ConstructorNumber -> [StgTickish] -> [StgArg] -> Type -> GenStgRhs (pass :: StgPass)
data GenStgAlt (pass :: StgPass)
GenStgAlt :: !AltCon -> ![BinderP pass] -> !GenStgExpr pass -> GenStgAlt (pass :: StgPass)
[alt_con] :: GenStgAlt (pass :: StgPass) -> !AltCon
[alt_bndrs] :: GenStgAlt (pass :: StgPass) -> ![BinderP pass]
[alt_rhs] :: GenStgAlt (pass :: StgPass) -> !GenStgExpr pass
data AltType
PolyAlt :: AltType
MultiValAlt :: Int -> AltType
AlgAlt :: TyCon -> AltType
PrimAlt :: PrimRep -> AltType

-- | Used as a data type index for the stgSyn AST
data StgPass
Vanilla :: StgPass

-- | Use internally by the lambda lifting pass
LiftLams :: StgPass

-- | Tag inference information on binders. See Note [Tag inference passes]
--   in GHC.Stg.InferTags
InferTaggedBinders :: StgPass

-- | Tag inference information put on relevant StgApp nodes See Note [Tag
--   inference passes] in GHC.Stg.InferTags
InferTagged :: StgPass
CodeGen :: StgPass
type family BinderP (pass :: StgPass)
type family XRhsClosure (pass :: StgPass)
type family XLet (pass :: StgPass)
type family XLetNoEscape (pass :: StgPass)

-- | Like <a>NoExtField</a>, but with an <a>Outputable</a> instance that
--   returns <a>empty</a>.
data NoExtFieldSilent

-- | Used when constructing a term with an unused extension point that
--   should not appear in pretty-printed output at all.
noExtFieldSilent :: NoExtFieldSilent
type OutputablePass (pass :: StgPass) = (Outputable XLet pass, Outputable XLetNoEscape pass, Outputable XRhsClosure pass, OutputableBndr BinderP pass)
data UpdateFlag

-- | A <tt>ReEntrant</tt> closure may be entered multiple times, but should
--   not be updated or blackholed.
ReEntrant :: UpdateFlag

-- | An <tt>Updatable</tt> closure should be updated after evaluation (and
--   may be blackholed during evaluation).
Updatable :: UpdateFlag

-- | A <tt>SingleEntry</tt> closure will only be entered once, and so need
--   not be updated but may safely be blackholed.
SingleEntry :: UpdateFlag

-- | A <tt>JumpedTo</tt> (join-point) closure is entered once or multiple
--   times but has no heap-allocated associated closure.
JumpedTo :: UpdateFlag
isUpdatable :: UpdateFlag -> Bool

-- | When `-fdistinct-constructor-tables` is turned on then each usage of a
--   constructor is given an unique number and an info table is generated
--   for each different constructor.
data ConstructorNumber
NoNumber :: ConstructorNumber
Numbered :: Int -> ConstructorNumber
type StgTopBinding = GenStgTopBinding 'Vanilla
type StgBinding = GenStgBinding 'Vanilla
type StgExpr = GenStgExpr 'Vanilla
type StgRhs = GenStgRhs 'Vanilla
type StgAlt = GenStgAlt 'Vanilla
type CgStgTopBinding = GenStgTopBinding 'CodeGen
type CgStgBinding = GenStgBinding 'CodeGen
type CgStgExpr = GenStgExpr 'CodeGen
type CgStgRhs = GenStgRhs 'CodeGen
type CgStgAlt = GenStgAlt 'CodeGen
type TgStgTopBinding = GenStgTopBinding 'CodeGen
type TgStgBinding = GenStgBinding 'CodeGen
type TgStgExpr = GenStgExpr 'CodeGen
type TgStgRhs = GenStgRhs 'CodeGen
type TgStgAlt = GenStgAlt 'CodeGen
type LlStgTopBinding = GenStgTopBinding 'LiftLams
type LlStgBinding = GenStgBinding 'LiftLams
type LlStgExpr = GenStgExpr 'LiftLams
type LlStgRhs = GenStgRhs 'LiftLams
type LlStgAlt = GenStgAlt 'LiftLams
type InStgArg = StgArg
type InStgTopBinding = StgTopBinding
type InStgBinding = StgBinding
type InStgExpr = StgExpr
type InStgRhs = StgRhs
type InStgAlt = StgAlt
type OutStgArg = StgArg
type OutStgTopBinding = StgTopBinding
type OutStgBinding = StgBinding
type OutStgExpr = StgExpr
type OutStgRhs = StgRhs
type OutStgAlt = StgAlt
data StgOp
StgPrimOp :: PrimOp -> StgOp
StgPrimCallOp :: PrimCall -> StgOp
StgFCallOp :: ForeignCall -> Type -> StgOp
stgRhsArity :: StgRhs -> Int
freeVarsOfRhs :: forall (pass :: StgPass). XRhsClosure pass ~ DIdSet => GenStgRhs pass -> DIdSet

-- | Type of an <tt>StgArg</tt>
--   
--   Very half baked because we have lost the type arguments.
--   
--   This function should be avoided: in STG we aren't supposed to look at
--   types, but only PrimReps. Use <a>stgArgRep</a>,
--   <a>stgArgRep_maybe</a>, <a>stgArgRep1</a> instaed.
stgArgType :: StgArg -> Type
stgArgRep :: StgArg -> [PrimRep]

-- | Assumes that the argument has at most one PrimRep, which holds after
--   unarisation. See Note [Post-unarisation invariants] in
--   GHC.Stg.Unarise. See Note [VoidRep] in GHC.Types.RepType.
stgArgRep1 :: StgArg -> PrimOrVoidRep

-- | Assumes that the argument has exactly one PrimRep. See Note [VoidRep]
--   in GHC.Types.RepType.
stgArgRepU :: StgArg -> PrimRep
stgArgRep_maybe :: StgArg -> Maybe [PrimRep]

-- | Given an alt type and whether the program is unarised, return whether
--   the case binder is in scope.
--   
--   Case binders of unboxed tuple or unboxed sum type always dead after
--   the unariser has run. See Note [Post-unarisation invariants] in
--   GHC.Stg.Unarise.
stgCaseBndrInScope :: AltType -> Bool -> Bool

-- | STG pretty-printing options
data StgPprOpts
StgPprOpts :: !Bool -> StgPprOpts

-- | Enable cost-centres
[stgSccEnabled] :: StgPprOpts -> !Bool

-- | STG pretty-printing options used for panic messages
panicStgPprOpts :: StgPprOpts

-- | STG pretty-printing options used for short messages
shortStgPprOpts :: StgPprOpts
pprStgArg :: StgArg -> SDoc
pprStgExpr :: forall (pass :: StgPass). OutputablePass pass => StgPprOpts -> GenStgExpr pass -> SDoc
pprStgRhs :: forall (pass :: StgPass). OutputablePass pass => StgPprOpts -> GenStgRhs pass -> SDoc
pprStgBinding :: forall (pass :: StgPass). OutputablePass pass => StgPprOpts -> GenStgBinding pass -> SDoc
pprStgAlt :: forall (pass :: StgPass). OutputablePass pass => StgPprOpts -> Bool -> GenStgAlt pass -> SDoc
pprGenStgTopBinding :: forall (pass :: StgPass). OutputablePass pass => StgPprOpts -> GenStgTopBinding pass -> SDoc
pprStgTopBinding :: forall (pass :: StgPass). OutputablePass pass => StgPprOpts -> GenStgTopBinding pass -> SDoc
pprGenStgTopBindings :: forall (pass :: StgPass). OutputablePass pass => StgPprOpts -> [GenStgTopBinding pass] -> SDoc
pprStgTopBindings :: forall (pass :: StgPass). OutputablePass pass => StgPprOpts -> [GenStgTopBinding pass] -> SDoc
instance GHC.Internal.Data.Data.Data GHC.Stg.Syntax.NoExtFieldSilent
instance GHC.Classes.Eq GHC.Stg.Syntax.NoExtFieldSilent
instance GHC.Classes.Eq GHC.Stg.Syntax.UpdateFlag
instance GHC.Classes.Ord GHC.Stg.Syntax.NoExtFieldSilent
instance GHC.Utils.Outputable.Outputable GHC.Stg.Syntax.AltType
instance GHC.Utils.Outputable.Outputable GHC.Stg.Syntax.ConstructorNumber
instance GHC.Stg.Syntax.OutputablePass pass => GHC.Utils.Outputable.Outputable (GHC.Stg.Syntax.GenStgBinding pass)
instance GHC.Stg.Syntax.OutputablePass pass => GHC.Utils.Outputable.Outputable (GHC.Stg.Syntax.GenStgExpr pass)
instance GHC.Stg.Syntax.OutputablePass pass => GHC.Utils.Outputable.Outputable (GHC.Stg.Syntax.GenStgRhs pass)
instance GHC.Utils.Outputable.Outputable GHC.Stg.Syntax.NoExtFieldSilent
instance GHC.Utils.Outputable.Outputable GHC.Stg.Syntax.StgArg
instance GHC.Utils.Outputable.Outputable GHC.Stg.Syntax.StgOp
instance GHC.Utils.Outputable.Outputable GHC.Stg.Syntax.UpdateFlag
instance GHC.Internal.Show.Show GHC.Stg.Syntax.UpdateFlag


-- | Module that holds the Types required for the StgToJS pass
module GHC.StgToJS.Types

-- | A State monad over IO holding the generator state.
type G = StateT GenState IO

-- | The JS code generator state
data GenState
GenState :: !StgToJSConfig -> !Module -> {-# UNPACK #-} !FastMutInt -> !IdCache -> !UniqFM Id CgStgExpr -> GenGroupState -> [JStgStat] -> GenState

-- | codegen settings, read-only
[gsSettings] :: GenState -> !StgToJSConfig

-- | current module
[gsModule] :: GenState -> !Module

-- | unique number for the id generator
[gsId] :: GenState -> {-# UNPACK #-} !FastMutInt

-- | hash consing for identifiers from a Unique
[gsIdents] :: GenState -> !IdCache

-- | unfloated arguments
[gsUnfloated] :: GenState -> !UniqFM Id CgStgExpr

-- | state for the current binding group
[gsGroup] :: GenState -> GenGroupState

-- | global (per module) statements (gets included when anything else from
--   the module is used)
[gsGlobal] :: GenState -> [JStgStat]

-- | The JS code generator state relevant for the current binding group
data GenGroupState
GenGroupState :: [JStgStat] -> [ClosureInfo] -> [StaticInfo] -> [StackSlot] -> Int -> Set OtherSymb -> GlobalIdCache -> [ForeignJSRef] -> GenGroupState

-- | extra toplevel statements for the binding group
[ggsToplevelStats] :: GenGroupState -> [JStgStat]

-- | closure metadata (info tables) for the binding group
[ggsClosureInfo] :: GenGroupState -> [ClosureInfo]

-- | static (CAF) data in our binding group
[ggsStatic] :: GenGroupState -> [StaticInfo]

-- | stack info for the current expression
[ggsStack] :: GenGroupState -> [StackSlot]

-- | current stack depth
[ggsStackDepth] :: GenGroupState -> Int

-- | extra dependencies for the linkable unit that contains this group
[ggsExtraDeps] :: GenGroupState -> Set OtherSymb
[ggsGlobalIdCache] :: GenGroupState -> GlobalIdCache
[ggsForeignRefs] :: GenGroupState -> [ForeignJSRef]

-- | The Configuration record for the StgToJS pass
data StgToJSConfig
StgToJSConfig :: !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !SDocContext -> !LinkerConfig -> StgToJSConfig
[csInlinePush] :: StgToJSConfig -> !Bool
[csInlineBlackhole] :: StgToJSConfig -> !Bool
[csInlineLoadRegs] :: StgToJSConfig -> !Bool
[csInlineEnter] :: StgToJSConfig -> !Bool
[csInlineAlloc] :: StgToJSConfig -> !Bool
[csPrettyRender] :: StgToJSConfig -> !Bool
[csTraceRts] :: StgToJSConfig -> !Bool
[csAssertRts] :: StgToJSConfig -> !Bool
[csBoundsCheck] :: StgToJSConfig -> !Bool
[csDebugAlloc] :: StgToJSConfig -> !Bool
[csTraceForeign] :: StgToJSConfig -> !Bool

-- | Profiling enabled
[csProf] :: StgToJSConfig -> !Bool

-- | Enable runtime assertions settings
[csRuntimeAssert] :: StgToJSConfig -> !Bool
[csContext] :: StgToJSConfig -> !SDocContext

-- | Emscripten linker
[csLinkerConfig] :: StgToJSConfig -> !LinkerConfig

-- | Closure info table
data ClosureInfo
ClosureInfo :: Ident -> CIRegs -> FastString -> CILayout -> CIType -> CIStatic -> ClosureInfo

-- | entry code identifier: infotable fields are stored as properties of
--   this function
[ciVar] :: ClosureInfo -> Ident

-- | size of the payload (in number of JS values)
[ciRegs] :: ClosureInfo -> CIRegs

-- | friendly name for printing
[ciName] :: ClosureInfo -> FastString

-- | heap/stack layout of the object
[ciLayout] :: ClosureInfo -> CILayout

-- | type of the object, with extra info where required
[ciType] :: ClosureInfo -> CIType

-- | static references of this object
[ciStatic] :: ClosureInfo -> CIStatic

-- | Closure information, <a>ClosureInfo</a>, registers
data CIRegs

-- | A value witnessing a state of unknown registers
CIRegsUnknown :: CIRegs
CIRegs :: Int -> [JSRep] -> CIRegs

-- | unused registers before actual args start
[ciRegsSkip] :: CIRegs -> Int

-- | args
[ciRegsTypes] :: CIRegs -> [JSRep]

-- | Closure Information, <a>ClosureInfo</a>, layout
data CILayout

-- | layout stored in object itself, first position from the start
CILayoutVariable :: CILayout

-- | fixed size, but content unknown (for example stack apply frame)
CILayoutUnknown :: !Int -> CILayout

-- | closure size in array positions, including entry
[layoutSize] :: CILayout -> !Int

-- | whole layout known
CILayoutFixed :: !Int -> [JSRep] -> CILayout

-- | closure size in array positions, including entry
[layoutSize] :: CILayout -> !Int

-- | The list of JSReps to layout
[layout] :: CILayout -> [JSRep]

-- | The type of <a>ClosureInfo</a>
data CIType
CIFun :: !Int -> !Int -> CIType

-- | function arity
[citArity] :: CIType -> !Int

-- | number of registers for the args
[citRegs] :: CIType -> !Int

-- | The closure is a THUNK
CIThunk :: CIType

-- | The closure is a Constructor
CICon :: !Int -> CIType
[citConstructor] :: CIType -> !Int

-- | The closure is a Partial Application
CIPap :: CIType

-- | The closure is a black hole
CIBlackhole :: CIType

-- | The closure is a stack frame
CIStackFrame :: CIType

-- | Static references that must be kept alive
newtype CIStatic
CIStaticRefs :: [FastString] -> CIStatic
[staticRefs] :: CIStatic -> [FastString]

-- | JS primitive representations
data JSRep

-- | pointer = reference to heap object (closure object), lifted or not.
--   Can also be some RTS object (e.g. TVar#, MVar#, MutVar#, Weak#)
PtrV :: JSRep

-- | no fields
VoidV :: JSRep

-- | A Double: one field
DoubleV :: JSRep

-- | An Int (32bit because JS): one field
IntV :: JSRep

-- | A Long: two fields one for the upper 32bits, one for the lower (NB: JS
--   is little endian)
LongV :: JSRep

-- | a pointer not to the heap: two fields, array + index
AddrV :: JSRep

-- | some JS object, user supplied, be careful around these, can be
--   anything
ObjV :: JSRep

-- | boxed array
ArrV :: JSRep

-- | The type of identifiers. These determine the suffix of generated
--   functions in JS Land. For example, the entry function for the
--   <a>Just</a> constructor is a <a>IdConEntry</a> which compiles to: <tt>
--   function h$ghczminternalZCGHCziInternalziMaybeziJust_con_e() { return
--   h$rs() }; </tt> which just returns whatever the stack point is
--   pointing to. Whereas the entry function to <a>Just</a> is an
--   <a>IdEntry</a> and does the work. It compiles to: <tt> function
--   h$ghczminternalZCGHCziInternalziMaybeziJust_e() { var
--   h$$baseZCGHCziMaybezieta_8KXnScrCjF5 = h$r2; h$r1 =
--   h$c1(h$ghczminternalZCGHCziInternalziMaybeziJust_con_e,
--   h$$ghczminternalZCGHCziInternalziMaybezieta_8KXnScrCjF5); return
--   h$rs(); }; </tt> Which loads some payload from register 2, and applies
--   the Constructor Entry function for the Just to the payload, returns
--   the result in register 1 and returns whatever is on top of the stack
data IdType

-- | A plain identifier for values, no suffix added
IdPlain :: IdType

-- | An entry function, suffix = "_e" in <a>makeIdentForId</a>
IdEntry :: IdType

-- | A Constructor entry function, suffix = "_con_e" in
--   <a>makeIdentForId</a>
IdConEntry :: IdType

-- | Keys to differentiate Ident's in the ID Cache
data IdKey
IdKey :: !Word64 -> !Int -> !IdType -> IdKey

-- | Some other symbol
data OtherSymb
OtherSymb :: !Module -> !FastString -> OtherSymb

-- | The identifier cache indexed on <a>IdKey</a> local to a module
newtype IdCache
IdCache :: Map IdKey Ident -> IdCache

-- | The global Identifier Cache
newtype GlobalIdCache
GlobalIdCache :: UniqFM Ident (IdKey, Id) -> GlobalIdCache

-- | A Stack Slot is either known or unknown. We avoid maybe here for more
--   strictness.
data StackSlot
SlotId :: !Id -> !Int -> StackSlot
SlotUnknown :: StackSlot
data StaticInfo
StaticInfo :: !FastString -> !StaticVal -> !Maybe Ident -> StaticInfo

-- | global object
[siVar] :: StaticInfo -> !FastString

-- | static initialization
[siVal] :: StaticInfo -> !StaticVal

-- | optional CCS name
[siCC] :: StaticInfo -> !Maybe Ident
data StaticVal

-- | heap object for function
StaticFun :: !FastString -> [StaticArg] -> StaticVal

-- | heap object for CAF (field is Nothing when thunk is initialized in an
--   alternative way, like string thunks through h$str)
StaticThunk :: !Maybe (FastString, [StaticArg]) -> StaticVal

-- | unboxed constructor (Bool, Int, Double etc)
StaticUnboxed :: !StaticUnboxed -> StaticVal

-- | regular datacon app
StaticData :: !FastString -> [StaticArg] -> StaticVal

-- | list initializer (with optional tail)
StaticList :: [StaticArg] -> Maybe FastString -> StaticVal
data StaticUnboxed
StaticUnboxedBool :: !Bool -> StaticUnboxed
StaticUnboxedInt :: !Integer -> StaticUnboxed
StaticUnboxedDouble :: !SaneDouble -> StaticUnboxed
StaticUnboxedString :: !ByteString -> StaticUnboxed
StaticUnboxedStringOffset :: !ByteString -> StaticUnboxed

-- | Static Arguments. Static Arguments are things that are statically
--   allocated, i.e., they exist at program startup. These are static heap
--   objects or literals or things that have been floated to the top level
--   binding by ghc.
data StaticArg

-- | reference to a heap object
StaticObjArg :: !FastString -> StaticArg

-- | literal
StaticLitArg :: !StaticLit -> StaticArg

-- | unfloated constructor
StaticConArg :: !FastString -> [StaticArg] -> StaticArg

-- | A Static literal value
data StaticLit
BoolLit :: !Bool -> StaticLit
IntLit :: !Integer -> StaticLit
NullLit :: StaticLit
DoubleLit :: !SaneDouble -> StaticLit
StringLit :: !FastString -> StaticLit
BinLit :: !ByteString -> StaticLit

-- | is function pointer, label (also used for string / binary init)
LabelLit :: !Bool -> !FastString -> StaticLit

-- | A foreign reference to some JS code
data ForeignJSRef
ForeignJSRef :: !FastString -> !FastString -> !Safety -> !CCallConv -> ![FastString] -> !FastString -> ForeignJSRef
[foreignRefSrcSpan] :: ForeignJSRef -> !FastString
[foreignRefPattern] :: ForeignJSRef -> !FastString
[foreignRefSafety] :: ForeignJSRef -> !Safety
[foreignRefCConv] :: ForeignJSRef -> !CCallConv
[foreignRefArgs] :: ForeignJSRef -> ![FastString]
[foreignRefResult] :: ForeignJSRef -> !FastString

-- | data used to generate one ObjBlock in our object file
data LinkableUnit
LinkableUnit :: ObjBlock -> [Id] -> [FastString] -> [Id] -> [Unique] -> [OtherSymb] -> Bool -> [ForeignJSRef] -> LinkableUnit

-- | serializable unit info
[luObjBlock] :: LinkableUnit -> ObjBlock

-- | exported names from haskell identifiers
[luIdExports] :: LinkableUnit -> [Id]

-- | other exports
[luOtherExports] :: LinkableUnit -> [FastString]

-- | identifiers this unit depends on
[luIdDeps] :: LinkableUnit -> [Id]

-- | pseudo-id identifiers this unit depends on (fixme)
[luPseudoIdDeps] :: LinkableUnit -> [Unique]

-- | symbols not from a haskell id that this unit depends on
[luOtherDeps] :: LinkableUnit -> [OtherSymb]

-- | always link this unit
[luRequired] :: LinkableUnit -> Bool
[luForeignRefs] :: LinkableUnit -> [ForeignJSRef]

-- | one toplevel block in the object file
data ObjBlock
ObjBlock :: ![FastString] -> ![ClosureInfo] -> ![StaticInfo] -> JStat -> !ByteString -> ![ExpFun] -> ![ForeignJSRef] -> ObjBlock

-- | toplevel symbols (stored in index)
[oiSymbols] :: ObjBlock -> ![FastString]

-- | closure information of all closures in block
[oiClInfo] :: ObjBlock -> ![ClosureInfo]

-- | static closure data
[oiStatic] :: ObjBlock -> ![StaticInfo]

-- | the code
[oiStat] :: ObjBlock -> JStat

-- | raw JS code
[oiRaw] :: ObjBlock -> !ByteString
[oiFExports] :: ObjBlock -> ![ExpFun]
[oiFImports] :: ObjBlock -> ![ForeignJSRef]
data ExpFun
ExpFun :: !Bool -> [JSFFIType] -> !JSFFIType -> ExpFun
[isIO] :: ExpFun -> !Bool
[args] :: ExpFun -> [JSFFIType]
[result] :: ExpFun -> !JSFFIType

-- | Types of FFI values
data JSFFIType
Int8Type :: JSFFIType
Int16Type :: JSFFIType
Int32Type :: JSFFIType
Int64Type :: JSFFIType
Word8Type :: JSFFIType
Word16Type :: JSFFIType
Word32Type :: JSFFIType
Word64Type :: JSFFIType
DoubleType :: JSFFIType
ByteArrayType :: JSFFIType
PtrType :: JSFFIType
RefType :: JSFFIType

-- | Typed expression
data TypedExpr
TypedExpr :: !PrimRep -> [JStgExpr] -> TypedExpr
[typex_typ] :: TypedExpr -> !PrimRep
[typex_expr] :: TypedExpr -> [JStgExpr]

-- | A Primop result is either an inlining of some JS payload, or a
--   primitive call to a JS function defined in Shim files in base.
data PrimRes

-- | primop is inline, result is assigned directly
PrimInline :: JStgStat -> PrimRes

-- | primop is async call, primop returns the next function to run. result
--   returned to stack top in registers
PRPrimCall :: JStgStat -> PrimRes
data ExprResult
ExprCont :: ExprResult
ExprInline :: ExprResult
newtype ExprValData
ExprValData :: [JStgExpr] -> ExprValData

-- | A Closure is one of six types
data ClosureType

-- | The closure is a THUNK
Thunk :: ClosureType

-- | The closure is a Function
Fun :: ClosureType

-- | The closure is a Partial Application
Pap :: ClosureType

-- | The closure is a Constructor
Con :: ClosureType

-- | The closure is a Blackhole
Blackhole :: ClosureType

-- | The closure is a stack frame
StackFrame :: ClosureType

-- | Convert <a>ClosureType</a> to an Int
ctNum :: ClosureType -> Int
closureB :: ByteString
closureNames :: Array ClosureType Ident

-- | Convert <a>ClosureType</a> to a String
ctJsName :: ClosureType -> String

-- | A thread is in one of 4 states
data ThreadStatus

-- | The thread is running
Running :: ThreadStatus

-- | The thread is blocked
Blocked :: ThreadStatus

-- | The thread is done
Finished :: ThreadStatus

-- | The thread has died
Died :: ThreadStatus

-- | Convert the status of a thread in JS land to an Int
threadStatusNum :: ThreadStatus -> Int

-- | convert the status of a thread in JS land to a string
threadStatusJsName :: ThreadStatus -> String
instance GHC.Internal.Enum.Bounded GHC.StgToJS.Types.ClosureType
instance GHC.Internal.Enum.Bounded GHC.StgToJS.Types.JSRep
instance GHC.Internal.Enum.Bounded GHC.StgToJS.Types.ThreadStatus
instance GHC.Internal.Enum.Enum GHC.StgToJS.Types.ClosureType
instance GHC.Internal.Enum.Enum GHC.StgToJS.Types.IdType
instance GHC.Internal.Enum.Enum GHC.StgToJS.Types.JSFFIType
instance GHC.Internal.Enum.Enum GHC.StgToJS.Types.JSRep
instance GHC.Internal.Enum.Enum GHC.StgToJS.Types.ThreadStatus
instance GHC.Classes.Eq GHC.StgToJS.Types.CILayout
instance GHC.Classes.Eq GHC.StgToJS.Types.CIRegs
instance GHC.Classes.Eq GHC.StgToJS.Types.CIStatic
instance GHC.Classes.Eq GHC.StgToJS.Types.CIType
instance GHC.Classes.Eq GHC.StgToJS.Types.ClosureInfo
instance GHC.Classes.Eq GHC.StgToJS.Types.ClosureType
instance GHC.Classes.Eq GHC.StgToJS.Types.ExpFun
instance GHC.Classes.Eq GHC.StgToJS.Types.ExprResult
instance GHC.Classes.Eq GHC.StgToJS.Types.ExprValData
instance GHC.Classes.Eq GHC.StgToJS.Types.IdKey
instance GHC.Classes.Eq GHC.StgToJS.Types.IdType
instance GHC.Classes.Eq GHC.StgToJS.Types.JSFFIType
instance GHC.Classes.Eq GHC.StgToJS.Types.JSRep
instance GHC.Classes.Eq GHC.StgToJS.Types.OtherSymb
instance GHC.Classes.Eq GHC.StgToJS.Types.StackSlot
instance GHC.Classes.Eq GHC.StgToJS.Types.StaticArg
instance GHC.Classes.Eq GHC.StgToJS.Types.StaticInfo
instance GHC.Classes.Eq GHC.StgToJS.Types.StaticLit
instance GHC.Classes.Eq GHC.StgToJS.Types.StaticUnboxed
instance GHC.Classes.Eq GHC.StgToJS.Types.StaticVal
instance GHC.Classes.Eq GHC.StgToJS.Types.ThreadStatus
instance GHC.Internal.Ix.Ix GHC.StgToJS.Types.ClosureType
instance GHC.Internal.Base.Monoid GHC.StgToJS.Types.CIStatic
instance GHC.Classes.Ord GHC.StgToJS.Types.CILayout
instance GHC.Classes.Ord GHC.StgToJS.Types.CIRegs
instance GHC.Classes.Ord GHC.StgToJS.Types.CIType
instance GHC.Classes.Ord GHC.StgToJS.Types.ClosureType
instance GHC.Classes.Ord GHC.StgToJS.Types.ExpFun
instance GHC.Classes.Ord GHC.StgToJS.Types.IdKey
instance GHC.Classes.Ord GHC.StgToJS.Types.IdType
instance GHC.Classes.Ord GHC.StgToJS.Types.JSFFIType
instance GHC.Classes.Ord GHC.StgToJS.Types.JSRep
instance GHC.Classes.Ord GHC.StgToJS.Types.OtherSymb
instance GHC.Classes.Ord GHC.StgToJS.Types.StackSlot
instance GHC.Classes.Ord GHC.StgToJS.Types.StaticUnboxed
instance GHC.Classes.Ord GHC.StgToJS.Types.ThreadStatus
instance GHC.Utils.Outputable.Outputable GHC.StgToJS.Types.StaticArg
instance GHC.Utils.Outputable.Outputable GHC.StgToJS.Types.StaticLit
instance GHC.Utils.Outputable.Outputable GHC.StgToJS.Types.TypedExpr
instance GHC.Internal.Base.Semigroup GHC.StgToJS.Types.CIStatic
instance GHC.Internal.Show.Show GHC.StgToJS.Types.CILayout
instance GHC.Internal.Show.Show GHC.StgToJS.Types.CIRegs
instance GHC.Internal.Show.Show GHC.StgToJS.Types.CIStatic
instance GHC.Internal.Show.Show GHC.StgToJS.Types.CIType
instance GHC.Internal.Show.Show GHC.StgToJS.Types.ClosureInfo
instance GHC.Internal.Show.Show GHC.StgToJS.Types.ClosureType
instance GHC.Internal.Show.Show GHC.StgToJS.Types.ExpFun
instance GHC.Internal.Show.Show GHC.StgToJS.Types.JSFFIType
instance GHC.Internal.Show.Show GHC.StgToJS.Types.JSRep
instance GHC.Internal.Show.Show GHC.StgToJS.Types.StaticArg
instance GHC.Internal.Show.Show GHC.StgToJS.Types.StaticInfo
instance GHC.Internal.Show.Show GHC.StgToJS.Types.StaticLit
instance GHC.Internal.Show.Show GHC.StgToJS.Types.StaticUnboxed
instance GHC.Internal.Show.Show GHC.StgToJS.Types.StaticVal
instance GHC.Internal.Show.Show GHC.StgToJS.Types.ThreadStatus
instance GHC.JS.Make.ToJExpr GHC.StgToJS.Types.CIStatic
instance GHC.JS.Make.ToJExpr GHC.StgToJS.Types.ClosureType
instance GHC.JS.Make.ToJExpr GHC.StgToJS.Types.JSRep
instance GHC.JS.Make.ToJExpr GHC.StgToJS.Types.StaticLit


-- | Types and utility functions used in the JS RTS.
module GHC.StgToJS.Rts.Types

-- | Given a <tt>JStgExpr</tt>, <tt>ex</tt>, inject a trace statement on
--   <tt>ex</tt> in the compiled JS program
traceRts :: StgToJSConfig -> JStgExpr -> JStgStat

-- | Syntactic sugar. Given a <tt>JStgExpr</tt>, <tt>ex</tt> which is
--   assumed to be a predicate, and a message <tt>m</tt>, assert that 'not
--   ex' is True, if not throw an exception in JS land with message
--   <tt>m</tt>.
assertRts :: ToJExpr a => StgToJSConfig -> JStgExpr -> a -> JStgStat

-- | name of the closure <tt>c</tt>
clName :: JStgExpr -> JStgExpr

-- | Type name of the closure <tt>c</tt>
clTypeName :: JStgExpr -> JStgExpr
stackFrameSize :: JStgExpr -> JStgExpr -> JSM JStgStat

-- | Perform the computation <a>f</a>, on the range of registers bounded by
--   <tt>start</tt> and <tt>end</tt>.
withRegs :: StgReg -> StgReg -> (StgReg -> JStgStat) -> JStgStat


module GHC.StgToJS.Object

-- | Different kinds of object (.o) supported by the JS backend
data ObjectKind

-- | JavaScript source embedded in a .o
ObjJs :: ObjectKind

-- | JS backend object for Haskell code
ObjHs :: ObjectKind

-- | Wasm module object as produced by emcc
ObjCc :: ObjectKind

-- | Get the kind of a file object, if any
getObjectKind :: FilePath -> IO (Maybe ObjectKind)

-- | Get the kind of an object stored in a bytestring, if any
getObjectKindBS :: ByteString -> Maybe ObjectKind

-- | Options obtained from pragmas in JS files
data JSOptions
JSOptions :: !Bool -> ![String] -> ![String] -> ![String] -> JSOptions

-- | Enable CPP on the JS file
[enableCPP] :: JSOptions -> !Bool

-- | Pass additional options to emcc at link time
[emccExtraOptions] :: JSOptions -> ![String]

-- | Arguments for `-sEXPORTED_FUNCTIONS`
[emccExportedFunctions] :: JSOptions -> ![String]

-- | Arguments for `-sEXPORTED_RUNTIME_METHODS`
[emccExportedRuntimeMethods] :: JSOptions -> ![String]
defaultJSOptions :: JSOptions

-- | Parse option pragma in JS file
getOptionsFromJsFile :: FilePath -> IO JSOptions

-- | Write a JS object (embed some handwritten JS code)
writeJSObject :: JSOptions -> ByteString -> FilePath -> IO ()

-- | Read a JS object from file
readJSObject :: FilePath -> IO (JSOptions, ByteString)

-- | Read a JS object from BinHandle
parseJSObject :: ReadBinHandle -> IO (JSOptions, ByteString)

-- | Read a JS object from ByteString
parseJSObjectBS :: ByteString -> IO (JSOptions, ByteString)

-- | Given a handle to a Binary payload, add the module, <tt>mod_name</tt>,
--   its dependencies, <tt>deps</tt>, and its linkable units to the
--   payload.
putObject :: WriteBinHandle -> ModuleName -> BlockInfo -> [ObjBlock] -> IO ()

-- | Parse object header
getObjectHeader :: ReadBinHandle -> IO (Either String ModuleName)

-- | Parse object body. Must be called after a successful getObjectHeader
getObjectBody :: ReadBinHandle -> ModuleName -> IO Object

-- | Parse object
getObject :: ReadBinHandle -> IO (Maybe Object)

-- | Read object from file
--   
--   The object is still in memory after this (see objHandle).
readObject :: FilePath -> IO (Maybe Object)

-- | Get blocks in the object file, using the given filtering function
getObjectBlocks :: Object -> BlockIds -> IO [ObjBlock]

-- | Read blocks in the object file, using the given filtering function
readObjectBlocks :: FilePath -> BlockIds -> IO [ObjBlock]

-- | Reads only the part necessary to get the block info
readObjectBlockInfo :: FilePath -> IO (Maybe BlockInfo)

-- | we use the convention that the first block (0) is a module-global
--   block that's always included when something from the module is loaded.
--   everything in a module implicitly depends on the global block. The
--   global block itself can't have dependencies
isGlobalBlock :: BlockId -> Bool

-- | A HS object file
data Object
Object :: !ModuleName -> !ReadBinHandle -> !Bin ObjBlock -> !BlockInfo -> !Index -> Object

-- | name of the module
[objModuleName] :: Object -> !ModuleName

-- | BinHandle that can be used to read the ObjBlocks
[objHandle] :: Object -> !ReadBinHandle

-- | Offset of the payload (units)
[objPayloadOffset] :: Object -> !Bin ObjBlock

-- | Information about blocks
[objBlockInfo] :: Object -> !BlockInfo

-- | Block index: symbols per block and block offset in the object file
[objIndex] :: Object -> !Index
data IndexEntry
IndexEntry :: ![FastString] -> !Bin ObjBlock -> IndexEntry

-- | Symbols exported by a block
[idxSymbols] :: IndexEntry -> ![FastString]

-- | Offset of the block in the object file
[idxOffset] :: IndexEntry -> !Bin ObjBlock
data LocatedBlockInfo
LocatedBlockInfo :: !BlockLocation -> !BlockInfo -> LocatedBlockInfo

-- | Where to find the blocks
[lbi_loc] :: LocatedBlockInfo -> !BlockLocation

-- | Block information
[lbi_info] :: LocatedBlockInfo -> !BlockInfo

-- | Information about blocks (linkable units)
data BlockInfo
BlockInfo :: !Module -> !BlockIds -> !Map ExportedFun BlockId -> !Array BlockId BlockDeps -> BlockInfo

-- | Module they were generated from
[bi_module] :: BlockInfo -> !Module

-- | blocks that always need to be linked when this object is loaded (e.g.
--   everything that contains initializer code or foreign exports)
[bi_must_link] :: BlockInfo -> !BlockIds

-- | exported Haskell functions -&gt; block
[bi_exports] :: BlockInfo -> !Map ExportedFun BlockId

-- | dependencies of each block
[bi_block_deps] :: BlockInfo -> !Array BlockId BlockDeps
data BlockDeps
BlockDeps :: [BlockId] -> [ExportedFun] -> BlockDeps

-- | dependencies on blocks in this object
[blockBlockDeps] :: BlockDeps -> [BlockId]

-- | dependencies on exported symbols in other objects ,
--   blockForeignExported :: [ExpFun] , blockForeignImported ::
--   [ForeignRef]
[blockFunDeps] :: BlockDeps -> [ExportedFun]

-- | Where are the blocks
data BlockLocation

-- | In an object file at path
ObjectFile :: FilePath -> BlockLocation

-- | In a Ar file at path
ArchiveFile :: FilePath -> BlockLocation

-- | In memory
InMemory :: String -> Object -> BlockLocation
type BlockId = Int
type BlockIds = IntSet

-- | A <tt>BlockRef</tt> is a pair of a module and the index of the block
--   in the object file
data BlockRef
BlockRef :: !Module -> !BlockId -> BlockRef

-- | Module
[block_ref_mod] :: BlockRef -> !Module

-- | Block index in the object file
[block_ref_idx] :: BlockRef -> !BlockId

-- | Exported Functions
data ExportedFun
ExportedFun :: !Module -> !LexicalFastString -> ExportedFun

-- | The module containing the function
[funModule] :: ExportedFun -> !Module

-- | The function
[funSymbol] :: ExportedFun -> !LexicalFastString
instance GHC.Utils.Binary.Binary GHC.JS.Syntax.AOp
instance GHC.Utils.Binary.Binary GHC.StgToJS.Object.BlockDeps
instance GHC.Utils.Binary.Binary GHC.StgToJS.Object.BlockInfo
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.CILayout
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.CIRegs
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.CIStatic
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.CIType
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.ClosureInfo
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.ExpFun
instance GHC.Utils.Binary.Binary GHC.StgToJS.Object.ExportedFun
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.ForeignJSRef
instance GHC.Utils.Binary.Binary GHC.JS.Ident.Ident
instance GHC.Utils.Binary.Binary GHC.StgToJS.Object.IndexEntry
instance GHC.Utils.Binary.Binary GHC.JS.Syntax.JExpr
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.JSFFIType
instance GHC.Utils.Binary.Binary GHC.StgToJS.Object.JSOptions
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.JSRep
instance GHC.Utils.Binary.Binary GHC.JS.Syntax.JStat
instance GHC.Utils.Binary.Binary GHC.JS.Syntax.JVal
instance GHC.Utils.Binary.Binary GHC.JS.Syntax.Op
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.StaticArg
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.StaticInfo
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.StaticLit
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.StaticUnboxed
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.StaticVal
instance GHC.Utils.Binary.Binary GHC.JS.Syntax.UOp
instance GHC.Classes.Eq GHC.StgToJS.Object.BlockRef
instance GHC.Classes.Eq GHC.StgToJS.Object.ExportedFun
instance GHC.Classes.Eq GHC.StgToJS.Object.JSOptions
instance GHC.Classes.Eq GHC.StgToJS.Object.ObjectKind
instance GHC.Classes.Ord GHC.StgToJS.Object.BlockRef
instance GHC.Classes.Ord GHC.StgToJS.Object.ExportedFun
instance GHC.Classes.Ord GHC.StgToJS.Object.JSOptions
instance GHC.Classes.Ord GHC.StgToJS.Object.ObjectKind
instance GHC.Utils.Outputable.Outputable GHC.StgToJS.Object.BlockInfo
instance GHC.Utils.Outputable.Outputable GHC.StgToJS.Object.BlockLocation
instance GHC.Utils.Outputable.Outputable GHC.StgToJS.Object.ExportedFun
instance GHC.Internal.Base.Semigroup GHC.StgToJS.Object.JSOptions
instance GHC.Internal.Show.Show GHC.StgToJS.Object.ObjectKind


module GHC.StgToJS.Linker.Types
data JSLinkConfig
JSLinkConfig :: !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> JSLinkConfig

-- | Dont' build JS executables
[lcNoJSExecutables] :: JSLinkConfig -> !Bool

-- | Don't generate Haskell main entry
[lcNoHsMain] :: JSLinkConfig -> !Bool

-- | Don't dump the generated RTS
[lcNoRts] :: JSLinkConfig -> !Bool

-- | Disable .stats file generation
[lcNoStats] :: JSLinkConfig -> !Bool

-- | Dump .frefs (foreign references) files
[lcForeignRefs] :: JSLinkConfig -> !Bool

-- | Generate all.js (combined js) + wrappers
[lcCombineAll] :: JSLinkConfig -> !Bool

-- | Force the link with the emcc rts. Use this if you plan to dynamically
--   load wasm modules made from C files (e.g. in iserv).
[lcForceEmccRts] :: JSLinkConfig -> !Bool

-- | Link C sources (compiled to JS/Wasm) with Haskell code compiled to JS.
--   This implies the use of the Emscripten RTS to load this code.
[lcLinkCsources] :: JSLinkConfig -> !Bool
data LinkPlan
LinkPlan :: Map Module LocatedBlockInfo -> Set BlockRef -> !Set FilePath -> !Set FilePath -> !Set FilePath -> LinkPlan

-- | Block information
[lkp_block_info] :: LinkPlan -> Map Module LocatedBlockInfo

-- | Blocks to link
[lkp_dep_blocks] :: LinkPlan -> Set BlockRef

-- | Archives to load JS and Cc sources from (JS code corresponding to
--   Haskell code is handled with blocks above)
[lkp_archives] :: LinkPlan -> !Set FilePath

-- | JS objects to link
[lkp_objs_js] :: LinkPlan -> !Set FilePath

-- | Cc objects to link
[lkp_objs_cc] :: LinkPlan -> !Set FilePath
instance GHC.Utils.Outputable.Outputable GHC.StgToJS.Linker.Types.LinkPlan

module GHC.StgToJS.Heap
closureType :: JStgExpr -> JStgExpr

-- | Closure type from infotable
infoClosureType :: JStgExpr -> JStgExpr

-- | Function arity from infotable
infoFunArity :: JStgExpr -> JStgExpr
isObject :: JStgExpr -> JStgExpr
isThunk :: JStgExpr -> JStgExpr
isThunk' :: JStgExpr -> JStgExpr
isBlackhole :: JStgExpr -> JStgExpr
isFun :: JStgExpr -> JStgExpr
isFun' :: JStgExpr -> JStgExpr
isPap :: JStgExpr -> JStgExpr
isPap' :: JStgExpr -> JStgExpr
isCon :: JStgExpr -> JStgExpr
isCon' :: JStgExpr -> JStgExpr
conTag :: JStgExpr -> JStgExpr
conTag' :: JStgExpr -> JStgExpr

-- | Get closure infotable
closureInfo :: JStgExpr -> JStgExpr

-- | Get closure metadata
closureMeta :: JStgExpr -> JStgExpr

-- | Get closure extra field 1
closureField1 :: JStgExpr -> JStgExpr

-- | Get closure extra field 2
closureField2 :: JStgExpr -> JStgExpr

-- | Get closure cost-center
closureCC :: JStgExpr -> JStgExpr

-- | Number of arguments (arity &amp; 0xff = arguments, arity &gt;&gt; 8 =
--   number of registers)
funArity :: JStgExpr -> JStgExpr
papArity :: JStgExpr -> JStgExpr
funOrPapArity :: JStgExpr -> Maybe JStgExpr -> JStgExpr

-- | Closure infotable field name
closureInfo_ :: FastString

-- | Closure meta field name
closureMeta_ :: FastString

-- | Closure cost-center field name
closureCC_ :: FastString

-- | Closure first payload field name
closureField1_ :: FastString

-- | Closure second payload field name
closureField2_ :: FastString
jTyObject :: JStgExpr


module GHC.StgToJS.ExprCtx

-- | Context into which an expression is evaluated
data ExprCtx

-- | Initialize an expression context in the context of the given top-level
--   binding Id
initExprCtx :: Id -> ExprCtx

-- | Predicate: do we know for sure that the given Id is evaluated?
ctxIsEvaluated :: Id -> Bool

-- | Set source location
ctxSetSrcSpan :: RealSrcSpan -> ExprCtx -> ExprCtx

-- | Source location
ctxSrcSpan :: ExprCtx -> Maybe RealSrcSpan

-- | Set top-level binding Id
ctxSetTop :: Id -> ExprCtx -> ExprCtx

-- | Target variables for the evaluated expression
ctxTarget :: ExprCtx -> [TypedExpr]

-- | Set target
ctxSetTarget :: [TypedExpr] -> ExprCtx -> ExprCtx

-- | Remove information about the current LNE frame
ctxClearLneFrame :: ExprCtx -> ExprCtx

-- | Update let-no-escape frame
ctxUpdateLneFrame :: [(Id, Int)] -> [Id] -> ExprCtx -> ExprCtx

-- | Contents of current LNE frame
--   
--   Variables and their index on the stack
ctxLneFrameVars :: ExprCtx -> [(Id, Int)]

-- | Cache the length of <a>ctxLneFrameVars</a>
ctxLneFrameSize :: ExprCtx -> Int

-- | Does the given Id correspond to a LNE binding
ctxIsLneBinding :: ExprCtx -> Id -> Bool

-- | Does the given Id correspond to a LNE live var on the stack
ctxIsLneLiveVar :: ExprCtx -> Id -> Bool

-- | Return the LNE stack size associated to the given Id. Return Nothing
--   when the Id doesn't correspond to a LNE binding.
ctxLneBindingStackSize :: ExprCtx -> Id -> Maybe Int

-- | Shrink the LNE stack to the given size
ctxLneShrinkStack :: ExprCtx -> Int -> ExprCtx

module GHC.StgToJS.Utils

-- | Assign first expr only (if it exists), performing coercions between
--   some PrimReps (e.g. StablePtr# and Addr#).
assignCoerce1 :: [TypedExpr] -> [TypedExpr] -> JStgStat
assignToExprCtx :: ExprCtx -> [JStgExpr] -> JStgStat
fixedLayout :: [JSRep] -> CILayout

-- | Associate the given JExpr to the Id's PrimReps, taking into account
--   the number of slots per PrimRep
assocIdExprs :: Id -> [JStgExpr] -> [TypedExpr]

-- | can we unbox C x to x, only if x is represented as a Number
isUnboxableCon :: DataCon -> Bool

-- | one-constructor types with one primitive field represented as a JS
--   Number can be unboxed
isUnboxable :: JSRep -> Bool
isBoolDataCon :: DataCon -> Bool

-- | Return SlotCount as an Int
slotCount :: SlotCount -> Int

-- | Number of slots occupied by a value with the given JSRep
varSize :: JSRep -> Int
typeSize :: Type -> Int
isVoid :: JSRep -> Bool
isMultiVar :: JSRep -> Bool
idJSRep :: HasDebugCallStack => Id -> [JSRep]
typeJSRep :: HasDebugCallStack => Type -> [JSRep]
unaryTypeJSRep :: HasDebugCallStack => UnaryType -> JSRep
primRepToJSRep :: HasDebugCallStack => PrimRep -> JSRep
primOrVoidRepToJSRep :: HasDebugCallStack => PrimOrVoidRep -> JSRep
stackSlotType :: Id -> JSRep
primRepSize :: PrimRep -> SlotCount
mkArityTag :: Int -> Int -> Int
exprRefs :: UniqFM Id CgStgExpr -> CgStgExpr -> Set Id
hasExport :: CgStgBinding -> Bool
collectTopIds :: CgStgBinding -> [Id]
collectIds :: UniqFM Id CgStgExpr -> CgStgBinding -> [Id]
type LiveVars = DVarSet
liveStatic :: LiveVars -> LiveVars
liveVars :: LiveVars -> LiveVars
stgRhsLive :: CgStgRhs -> LiveVars
stgExprLive :: Bool -> CgStgExpr -> LiveVars
isUpdatableRhs :: CgStgRhs -> Bool
stgLneLive' :: CgStgBinding -> [Id]
stgLneLiveExpr :: CgStgRhs -> [Id]

-- | returns True if the expression is definitely inline
isInlineExpr :: CgStgExpr -> Bool
instance GHC.Classes.Eq GHC.StgToJS.Utils.SlotCount
instance GHC.Classes.Ord GHC.StgToJS.Utils.SlotCount
instance GHC.Utils.Outputable.Outputable GHC.StgToJS.Utils.SlotCount
instance GHC.Internal.Show.Show GHC.StgToJS.Utils.SlotCount

module GHC.StgToJS.Closure

-- | Generate statements to set infotable field values for the given
--   ClosureInfo
--   
--   Depending on debug flag, it generates h$setObjInfo(...) or h$o(...).
--   The latter form doesn't store the pretty-printed name in the closure
--   to save space.
closureInfoStat :: Bool -> ClosureInfo -> JStgStat

-- | Special case of closures that do not need to generate any
--   <tt>fresh</tt> names
closure :: ClosureInfo -> JSM JStgStat -> JSM JStgStat
conClosure :: Ident -> FastString -> CILayout -> Int -> JSM JStgStat

-- | Used to pass arguments to newClosure with some safety
data Closure
Closure :: JStgExpr -> JStgExpr -> JStgExpr -> JStgExpr -> Maybe JStgExpr -> Closure

-- | InfoTable object
[clInfo] :: Closure -> JStgExpr

-- | Payload field 1
[clField1] :: Closure -> JStgExpr

-- | Payload field 2
[clField2] :: Closure -> JStgExpr
[clMeta] :: Closure -> JStgExpr
[clCC] :: Closure -> Maybe JStgExpr
newClosure :: Closure -> JStgExpr
assignClosure :: JStgExpr -> Closure -> JStgStat
data CopyCC
CopyCC :: CopyCC
DontCopyCC :: CopyCC
copyClosure :: CopyCC -> JStgExpr -> JStgExpr -> JStgStat
mkClosure :: JStgExpr -> [JStgExpr] -> JStgExpr -> Maybe JStgExpr -> Closure
allocData :: Int -> JStgExpr
allocClsA :: Int -> JStgExpr
dataName :: Int -> FastString
clsName :: Int -> FastString
dataFieldName :: Int -> FastString
varName :: Int -> Ident

-- | We use this in the RTS to determine the number of generated closures.
--   These closures use the names cached here, so we bind them to the same
--   number.
jsClosureCount :: Int

module GHC.StgToJS.Sinker

-- | Unfloat some top-level unexported things
--   
--   GHC floats constants to the top level. This is fine in native code,
--   but with JS they occupy some global variable name. We can unfloat some
--   unexported things:
--   
--   <ul>
--   <li>global constructors, as long as they're referenced only once by
--   another global constructor and are not in a recursive binding
--   group</li>
--   <li>literals (small literals may also be sunk if they are used more
--   than once)</li>
--   </ul>
sinkPgm :: Module -> [CgStgTopBinding] -> (UniqFM Id CgStgExpr, [CgStgTopBinding])


-- | JS codegen state monad
module GHC.StgToJS.Monad
runG :: StgToJSConfig -> Module -> UniqFM Id CgStgExpr -> G a -> IO a

-- | emit a global (for the current module) toplevel statement
emitGlobal :: JStgStat -> G ()

-- | add a dependency on a particular symbol to the current group
addDependency :: OtherSymb -> G ()

-- | emit a top-level statement for the current binding group
emitToplevel :: JStgStat -> G ()

-- | emit static data for the binding group
emitStatic :: FastString -> StaticVal -> Maybe Ident -> G ()

-- | add closure info in our binding group. all heap objects must have
--   closure info
emitClosureInfo :: ClosureInfo -> G ()
emitForeign :: Maybe RealSrcSpan -> FastString -> Safety -> CCallConv -> [FastString] -> FastString -> G ()
assertRtsStat :: G JStgStat -> G JStgStat
getSettings :: G StgToJSConfig

-- | Return number of occurrences of every global id used in the given
--   JStgStat. Sort by increasing occurrence count.
globalOccs :: JStgStat -> G [GlobalOcc]
setGlobalIdCache :: GlobalIdCache -> G ()
getGlobalIdCache :: G GlobalIdCache
data GlobalOcc
GlobalOcc :: !Ident -> !Id -> !Word -> GlobalOcc
[global_ident] :: GlobalOcc -> !Ident
[global_id] :: GlobalOcc -> !Id
[global_count] :: GlobalOcc -> !Word
modifyGroup :: (GenGroupState -> GenGroupState) -> G ()

-- | start with a new binding group
resetGroup :: G ()

module GHC.StgToJS.Profiling
initCostCentres :: CollectedCCs -> G ()
emitCostCentreDecl :: CostCentre -> G ()
emitCostCentreStackDecl :: CostCentreStack -> G ()
enterCostCentreFun :: CostCentreStack -> JStgStat
enterCostCentreThunk :: JStgStat
setCC :: CostCentre -> Bool -> Bool -> G JStgStat
pushRestoreCCS :: JStgStat
jCurrentCCS :: JStgExpr
jCafCCS :: JStgExpr
jSystemCCS :: JStgExpr
costCentreLbl :: CostCentre -> G Ident
costCentreStackLbl :: CostCentreStack -> G (Maybe Ident)
singletonCCSLbl :: CostCentre -> G Ident
ccsVarJ :: CostCentreStack -> G (Maybe JStgExpr)
profiling :: G Bool
ifProfiling :: Monoid m => m -> G m
ifProfilingM :: Monoid m => G m -> G m

-- | If profiling is enabled, then use input JStgStat, else ignore
profStat :: StgToJSConfig -> JStgStat -> JStgStat

module GHC.StgToJS.Prim
genPrim :: Bool -> Bool -> Type -> PrimOp -> [JStgExpr] -> [JStgExpr] -> JSM PrimRes


module GHC.StgToJS.Ids

-- | Get fresh unique number
freshUnique :: G Int

-- | Get fresh module-local Ident of the form: h$$unit:module_uniq
freshIdent :: G Ident

-- | Generate unique Ident for the given ID (uncached!)
--   
--   The ident has the following forms:
--   
--   global Id: h$unit:module.name[_num][_type_suffix] local Id:
--   h$$unit:module.name[_num][_type_suffix]_uniq
--   
--   Note that the string is z-encoded except for "_" delimiters.
--   
--   Optional "_type_suffix" can be: - "_e" for IdEntry - "_con_e" for
--   IdConEntry
--   
--   Optional "_num" is passed as an argument to this function. It is used
--   for Haskell Ids that require several JS variables: e.g. 64-bit numbers
--   (Word64#, Int64#), Addr#, StablePtr#, unboxed tuples, etc.
makeIdentForId :: Id -> Maybe Int -> IdType -> Module -> Ident

-- | Retrieve the cached Ident for the given Id if there is one. Otherwise
--   make a new one with <a>makeIdentForId</a> and cache it.
cachedIdentForId :: Id -> Maybe Int -> IdType -> G Ident

-- | Retrieve default Ident for the given Id
identForId :: Id -> G Ident

-- | Retrieve default Ident for the given Id with sub index
--   
--   Some types, Word64, Addr#, unboxed tuple have more than one
--   corresponding JS var, hence we use the sub index to identify each
--   subpart / JS variable.
identForIdN :: Id -> Int -> G Ident

-- | Retrieve all the idents for the given Id.
identsForId :: Id -> G [Ident]

-- | Retrieve entry Ident for the given Id
identForEntryId :: Id -> G Ident

-- | Retrieve datacon entry Ident for the given Id
--   
--   Different name than the datacon wrapper.
identForDataConEntryId :: Id -> G Ident

-- | Retrieve datacon worker entry variable name for the given datacon
identForDataConWorker :: DataCon -> G Ident

-- | Retrieve default variable name for the given Id
varForId :: Id -> G JStgExpr

-- | Retrieve default variable name for the given Id with sub index
varForIdN :: Id -> Int -> G JStgExpr

-- | Retrieve all the JS vars for the given Id
varsForId :: Id -> G [JStgExpr]

-- | Retrieve entry variable name for the given Id
varForEntryId :: Id -> G JStgExpr

-- | Retrieve datacon entry variable name for the given Id
varForDataConEntryId :: Id -> G JStgExpr

-- | Retrieve datacon worker entry variable name for the given datacon
varForDataConWorker :: DataCon -> G JStgExpr

-- | Declare all js vars for the id
declVarsForId :: Id -> G JStgStat


-- | Utilities and wrappers for Stack manipulation in JS Land.
--   
--   In general, functions suffixed with a tick do the actual work,
--   functions suffixed with an <a>I</a> are identical to the non-I
--   versions but work on <a>Ident</a>s
--   
--   The stack in JS land is held in the special JS array 'h$stack' and the
--   stack pointer is held in 'h$sp'. The top of the stack thus exists at
--   'h$stack[h$sp]'. h$stack[h$sp + i] where i &gt; 0, moves deeper into
--   the stack into older entries, whereas h$stack[h$sp - i] moves towards
--   the top of the stack.
--   
--   The stack layout algorithm is slightly peculiar. It makes an effort to
--   remember recently popped things so that if these values need to be
--   pushed then they can be quickly. The implementation for this is
--   storing these values above the stack pointer, and the pushing will
--   skip slots that we know we will use and fill in slots marked as
--   unknown. Thus, you may find that our push and pop functions do some
--   non-traditional stack manipulation such as adding slots in pop or
--   removing slots in push.
module GHC.StgToJS.Stack

-- | Run the action, <tt>m</tt>, with no stack info
resetSlots :: G a -> G a

-- | run the action, <tt>m</tt>, with current stack info, but don't let
--   modifications propagate
isolateSlots :: G a -> G a

-- | overwrite our stack knowledge
setSlots :: [StackSlot] -> G ()

-- | retrieve our current stack knowledge
getSlots :: G [StackSlot]

-- | add knowledge about the stack slots
addSlots :: [StackSlot] -> G ()

-- | drop <a>n</a> slots from our stack knowledge
dropSlots :: Int -> G ()

-- | add <a>n</a> unknown slots to our stack knowledge
addUnknownSlots :: Int -> G ()
push :: [JStgExpr] -> G JStgStat
push' :: StgToJSConfig -> [JStgExpr] -> JStgStat

-- | Shrink the stack and stack pointer. NB: This function is unsafe when
--   the input <a>n</a>, is negative. This function wraps around
--   <a>adjSpN</a> which actually performs the work.
adjSpN :: Int -> G JStgStat

-- | Shrink the stack pointer by <a>n</a>. The stack grows downward so
--   substract
adjSpN' :: Int -> JStgStat

-- | Grow the stack pointer by <a>n</a> without modifying the stack depth.
--   The stack is just a JS array so we add to grow (instead of the
--   traditional subtract)
adjSp' :: Int -> JStgStat

-- | Wrapper which adjusts the stack pointer <i>and</i> modifies the stack
--   depth tracked in <a>G</a>. See also <a>adjSp'</a> which actually does
--   the stack pointer manipulation.
adjSp :: Int -> G JStgStat

-- | Partial Push functions. Like <a>pushN</a> except these push functions
--   skip slots. For example, <tt> function h$pp33(x1, x2) { h$sp += 6;
--   h$stack[(h$sp - 5)] = x1; h$stack[(h$sp - 0)] = x2; }; </tt>
--   
--   The 33rd entry skips slots 1-4 to bind the top of the stack and the
--   6th slot. See <a>pushOptimized</a> and <a>pushOptimized'</a> for use
--   cases.
pushNN :: Array Integer Ident

-- | Like <a>pushN'</a> but for the partial push functions
pushNN' :: Array Integer JStgExpr

-- | Convert all function symbols in <a>pushN</a> to global top-level
--   functions. This is a hack which converts the function symbols to
--   variables. This hack is caught in <a>prettyBlock'</a> to turn these
--   into global functions.
pushN' :: Array Int JStgExpr

-- | A constant array that holds global function symbols which do N pushes
--   onto the stack. For example: <tt> function h$p1(x1) { ++h$sp;
--   h$stack[(h$sp - 0)] = x1; }; function h$p2(x1, x2) { h$sp += 2;
--   h$stack[(h$sp - 1)] = x1; h$stack[(h$sp - 0)] = x2; }; </tt>
--   
--   and so on up to 32.
pushN :: Array Int Ident
pushOptimized' :: [(Id, Int)] -> G JStgStat

-- | optimized push that reuses existing values on stack automatically
--   chooses an optimized partial push (h$ppN) function when possible.
pushOptimized :: [(JStgExpr, Bool)] -> G JStgStat

-- | push a let-no-escape frame onto the stack
pushLneFrame :: HasDebugCallStack => Int -> ExprCtx -> G JStgStat

-- | Blindly pop N slots
popN :: Int -> G JStgStat

-- | Pop things, don't update the stack knowledge in <a>G</a>
popSkip :: Int -> [JStgExpr] -> JStgStat

-- | Pop but preserve the first N slots
popSkipI :: Int -> [(Ident, StackSlot)] -> G JStgStat

-- | Load 'length (xs :: [JStgExpr])' things from the stack at offset 'n ::
--   Int'. This function does no stack pointer manipulation, it merely
--   indexes into the stack and loads payloads into <tt>xs</tt>.
loadSkip :: Int -> [JStgExpr] -> JStgStat

-- | Wrapper around <a>updateThunk'</a>, performs the stack manipulation
--   before updating the Thunk.
updateThunk :: G JStgStat

-- | Update a thunk by checking <a>StgToJSConfig</a>. If the config inlines
--   black holes then update inline, else make an explicit call to the
--   black hole handler.
updateThunk' :: StgToJSConfig -> JStgStat

-- | Generate statements to update the current node with a blackhole
bhStats :: StgToJSConfig -> Bool -> JStgStat

module GHC.StgToJS.Literal

-- | Generate JS expressions for a Literal
--   
--   Literals represented with 2 values: * Addr# (Null and Strings): array
--   and offset * 64-bit values: high 32-bit, low 32-bit * labels: call to
--   h$mkFunctionPtr and 0, or function name and 0
genLit :: HasDebugCallStack => Literal -> G [JStgExpr]

-- | generate a literal for the static init tables
genStaticLit :: Literal -> G [StaticLit]


-- | Module to calculate the transitive dependencies of a module
module GHC.StgToJS.Deps

-- | Generate module dependency data
--   
--   Generate the object's dependency data, taking care that package and
--   module names are only stored once
genDependencyData :: HasDebugCallStack => Module -> [LinkableUnit] -> G BlockInfo


module GHC.StgToJS.DataCon

-- | Generate a data constructor. Special handling for unboxed tuples
genCon :: ExprCtx -> DataCon -> [JStgExpr] -> G JStgStat

-- | Allocate a data constructor. Allocate in this context means bind the
--   data constructor to <tt>to</tt>
allocCon :: Ident -> DataCon -> CostCentreStack -> [JStgExpr] -> G JStgStat

-- | Allocate an unboxed data constructor. If we have a bool we calculate
--   the right value. If not then we expect a singleton list and unbox by
--   converting ''C x' to <tt>x</tt>. NB. This function may panic.
allocUnboxedCon :: DataCon -> [JStgExpr] -> JStgExpr

-- | Allocate an entry function. See <a>hs</a> for the object layout.
allocDynamicE :: Bool -> JStgExpr -> [JStgExpr] -> Maybe JStgExpr -> JStgExpr

-- | Allocate a dynamic object
allocDynamic :: StgToJSConfig -> Bool -> Ident -> JStgExpr -> [JStgExpr] -> Maybe JStgExpr -> JStgStat


module GHC.StgToJS.Arg

-- | Generate JS code for an StgArg
genArg :: HasDebugCallStack => StgArg -> G [JStgExpr]

-- | Generate a Var as JStgExpr
genIdArg :: HasDebugCallStack => Id -> G [JStgExpr]

-- | Generate an Id as an Ident
genIdArgI :: HasDebugCallStack => Id -> G [Ident]

-- | Generate IDs for stack arguments. See <a>loadRetArgs</a> for use case
genIdStackArgI :: HasDebugCallStack => Id -> G [(Ident, StackSlot)]

-- | Allocate Static Constructors
allocConStatic :: HasDebugCallStack => Ident -> CostCentreStack -> DataCon -> [StgArg] -> G ()

-- | Allocate unboxed constructors
allocUnboxedConStatic :: DataCon -> [StaticArg] -> StaticArg

-- | Allocate Static list
allocateStaticList :: [StgArg] -> StgArg -> G StaticVal

-- | Generate JS code corresponding to a static arg
jsStaticArg :: StaticArg -> JStgExpr

-- | Generate JS code corresponding to a list of static args
jsStaticArgs :: [StaticArg] -> JStgExpr

module GHC.StgToJS.FFI
genPrimCall :: ExprCtx -> PrimCall -> [StgArg] -> Type -> G (JStgStat, ExprResult)
genForeignCall :: HasDebugCallStack => ExprCtx -> ForeignCall -> Type -> [JStgExpr] -> [StgArg] -> G (JStgStat, ExprResult)


-- | Module that deals with expression application in JavaScript. In some
--   cases we rely on pre-generated functions that are bundled with the RTS
--   (see rtsApply).
module GHC.StgToJS.Apply

-- | Generate an application of some args to an Id.
--   
--   The case where args is null is common as it's used to generate the
--   evaluation code for an Id.
genApp :: HasDebugCallStack => ExprCtx -> Id -> [StgArg] -> G (JStgStat, ExprResult)

-- | Pre-generated functions for fast Apply. These are bundled with the
--   RTS.
rtsApply :: StgToJSConfig -> JSM JStgStat
instance GHC.Classes.Eq GHC.StgToJS.Apply.ApplyConv
instance GHC.Classes.Eq GHC.StgToJS.Apply.ApplySpec
instance GHC.Classes.Ord GHC.StgToJS.Apply.ApplyConv
instance GHC.Classes.Ord GHC.StgToJS.Apply.ApplySpec
instance GHC.Internal.Show.Show GHC.StgToJS.Apply.ApplyConv
instance GHC.Internal.Show.Show GHC.StgToJS.Apply.ApplySpec


-- | Top level driver of the JavaScript Backend RTS. This file is an
--   implementation of the JS RTS for the JS backend written as an EDSL in
--   Haskell. It assumes the existence of pre-generated JS functions,
--   included as js-sources in base. These functions are similarly assumed
--   for non-inline Primops, See <a>Prim</a>. Most of the elements in this
--   module are constants in Haskell Land which define pieces of the JS
--   RTS.
module GHC.StgToJS.Rts.Rts

-- | Generated RTS code
rts :: StgToJSConfig -> JSM JStgStat

-- | Assign registers R1 ... Rn in descending order, that is assign Rn
--   first. This function uses the <a>hdLoads</a> array to construct
--   functions which set the registers.
--   
--   JS payload which defines an array of function symbols that set N
--   registers from M parameters. For example, h$l4 compiles to: <tt>
--   function h$l4(x1, x2, x3, x4) { h$r4 = x1; h$r3 = x2; h$r2 = x3; h$r1
--   = x4; }; </tt>
assignRegs :: StgToJSConfig -> [JStgExpr] -> JStgStat

module GHC.Stg.Utils
mkStgAltTypeFromStgAlts :: forall (p :: StgPass). Id -> [GenStgAlt p] -> AltType
bindersOf :: forall (a :: StgPass). BinderP a ~ Id => GenStgBinding a -> [Id]
bindersOfX :: forall (a :: StgPass). GenStgBinding a -> [BinderP a]
bindersOfTop :: forall (a :: StgPass). BinderP a ~ Id => GenStgTopBinding a -> [Id]
bindersOfTopBinds :: forall (a :: StgPass). BinderP a ~ Id => [GenStgTopBinding a] -> [Id]

-- | Strip ticks of a given type from an STG expression.
stripStgTicksTop :: forall (p :: StgPass). (StgTickish -> Bool) -> GenStgExpr p -> ([StgTickish], GenStgExpr p)

-- | Strip ticks of a given type from an STG expression returning only the
--   expression.
stripStgTicksTopE :: forall (p :: StgPass). (StgTickish -> Bool) -> GenStgExpr p -> GenStgExpr p
idArgs :: [StgArg] -> [Id]
mkUnarisedId :: MonadUnique m => FastString -> NvUnaryType -> m Id
mkUnarisedIds :: MonadUnique m => FastString -> [NvUnaryType] -> m [Id]

-- | Do we allow the given top-level (static) ConApp?
allowTopLevelConApp :: Platform -> Bool -> Module -> DataCon -> [StgArg] -> Bool

module GHC.Stg.Stats
showStgStats :: [StgTopBinding] -> String
instance GHC.Classes.Eq GHC.Stg.Stats.CounterType
instance GHC.Classes.Ord GHC.Stg.Stats.CounterType

module GHC.Stg.Make
data MkStgRhs
MkStgRhs :: [Id] -> StgExpr -> Type -> !Bool -> MkStgRhs

-- | Empty for thunks
[rhs_args] :: MkStgRhs -> [Id]

-- | RHS expression
[rhs_expr] :: MkStgRhs -> StgExpr

-- | RHS type (only used in the JS backend: layering violation)
[rhs_type] :: MkStgRhs -> Type

-- | Is it a RHS for a join-point?
[rhs_is_join] :: MkStgRhs -> !Bool
mkTopStgRhs :: (Module -> DataCon -> [StgArg] -> Bool) -> Bool -> Module -> CollectedCCs -> Id -> MkStgRhs -> (StgRhs, CollectedCCs)
mkStgRhs :: Id -> MkStgRhs -> StgRhs

-- | Try to make a non top-level StgRhsCon if appropriate
mkStgRhsCon_maybe :: MkStgRhs -> Maybe StgRhs

-- | Try to make a top-level StgRhsCon if appropriate
mkTopStgRhsCon_maybe :: (DataCon -> [StgArg] -> Bool) -> MkStgRhs -> Maybe StgRhs


-- | (c) The GRASP/AQUA Project, Glasgow University, 1993-1998
--   
--   A lint pass to check basic STG invariants:
--   
--   <ul>
--   <li>Variables should be defined before used.</li>
--   <li>Let bindings should not have unboxed types (unboxed bindings
--   should only appear in case), except when they're join points (see Note
--   [Core let-can-float invariant] and #14117).</li>
--   <li>If linting after unarisation, invariants listed in Note
--   [Post-unarisation invariants].</li>
--   </ul>
--   
--   Because we don't have types and coercions in STG we can't really check
--   types here.
--   
--   Some history:
--   
--   StgLint used to check types, but it never worked and so it was
--   disabled in 2000 with this note:
--   
--   WARNING: ~~~~~~~~
--   
--   This module has suffered bit-rot; it is likely to yield lint errors
--   for Stg code that is currently perfectly acceptable for code
--   generation. Solution: don't use it! (KSW 2000-05).
--   
--   Since then there were some attempts at enabling it again, as
--   summarised in #14787. It's finally decided that we remove all type
--   checking and only look for basic properties listed above.
--   
--   Note [Linting StgApp] ~~~~~~~~~~~~~~~~~~~~~ To lint an application of
--   the form `f a_1 ... a_n`, we check that the representations of the
--   arguments <tt>a_1</tt>, ..., <tt>a_n</tt> match those that the
--   function expects.
--   
--   More precisely, suppose the types in the application `f a_1 ... a_n`
--   are as follows:
--   
--   f :: t_1 -&gt; ... -&gt; t_n -&gt; res a_1 :: s_1, ..., a_n :: s_n
--   
--   t_1 :: TYPE r_1, ..., t_n :: TYPE r_n s_1 :: TYPE p_1, ..., a_n ::
--   TYPE p_n
--   
--   Before unarisation, we must check that each r_i is compatible with
--   s_i. Compatibility is weaker than on-the-nose equality: for example,
--   IntRep and WordRep are compatible. See Note [Bad unsafe coercion] in
--   GHC.Core.Lint.
--   
--   After unarisation, a single type might correspond to multiple
--   arguments, e.g.
--   
--   (# Int# | Bool #) :: TYPE (SumRep '[ IntRep, LiftedRep ])
--   
--   will result in two arguments: [Int# :: TYPE 'IntRep, Bool :: TYPE
--   LiftedRep] This means post unarise we potentially have to match up
--   multiple arguments with the reps of a single argument in the type's
--   definition, because the type of the function is *not* in unarised
--   form.
--   
--   Wrinkle: it can sometimes happen that an argument type in the type of
--   the function does not have a fixed runtime representation, i.e. there
--   is an r_i such that runtimeRepPrimRep r_i crashes. See
--   <a>https://gitlab.haskell.org/ghc/ghc/-/issues/21399</a> for an
--   example. Fixing this issue would require significant changes to the
--   type system of STG, so for now we simply skip the Lint check when we
--   detect such representation-polymorphic situations.
--   
--   Note [Typing the STG language] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ In Core,
--   programs must be <i>well-typed</i>. So if f :: ty1 -&gt; ty2, then in
--   the application (f e), we must have e :: ty1
--   
--   STG is still a statically typed language, but the type system is much
--   coarser. In particular, STG programs must be <i>well-kinded</i>. More
--   precisely, if f :: ty1 -&gt; ty2, then in the application (f e) where
--   e :: ty1', we must have kind(ty1) = kind(ty1').
--   
--   So the STG type system does not distinguish between Int and Bool, but
--   it <i>does</i> distinguish between Int and Int#, because they have
--   different kinds. Actually, since all terms have kind (TYPE rep), we
--   might say that the STG language is well-runtime-rep'd.
--   
--   This coarser type system makes fewer distinctions, and that allows
--   many nonsensical programs (such as (<tt>x</tt> &amp;&amp; "foo")) --
--   but all type systems accept buggy programs! But the coarseness also
--   permits some optimisations that are ill-typed in Core. For example,
--   see the module STG.CSE, which is all about doing CSE in STG that would
--   be ill-typed in Core. But it must still be well-kinded!
module GHC.Stg.Lint
lintStgTopBindings :: forall (a :: StgPass). (OutputablePass a, BinderP a ~ Id) => Platform -> Logger -> DiagOpts -> StgPprOpts -> [Var] -> Module -> Bool -> String -> [GenStgTopBinding a] -> IO ()
instance GHC.Internal.Base.Applicative GHC.Stg.Lint.LintM
instance GHC.Internal.Base.Functor GHC.Stg.Lint.LintM
instance GHC.Internal.Base.Monad GHC.Stg.Lint.LintM

module GHC.Stg.InferTags.Types
combineAltInfo :: TagInfo -> TagInfo -> TagInfo
extendSigEnv :: forall (p :: StgPass). TagEnv p -> [(Id, TagSig)] -> TagEnv p
getBinderId :: forall (p :: StgPass). TagEnv p -> BinderP p -> Id
initEnv :: Bool -> TagEnv 'CodeGen
isDunnoSig :: TagSig -> Bool
isTaggedInfo :: TagInfo -> Bool

-- | Look up a sig in the env or derive it from information in the arg
--   itself.
lookupInfo :: forall (p :: StgPass). TagEnv p -> StgArg -> TagInfo

-- | Look up a sig in the given env
lookupSig :: forall (p :: StgPass). TagEnv p -> Id -> Maybe TagSig

-- | Simple convert env to a env of the 'InferTaggedBinders pass with no
--   other changes.
makeTagged :: forall (p :: StgPass). TagEnv p -> TagEnv 'InferTaggedBinders
noSig :: forall (p :: StgPass). TagEnv p -> BinderP p -> (Id, TagSig)
type InferStgAlt = GenStgAlt 'InferTaggedBinders
type InferStgBinding = GenStgBinding 'InferTaggedBinders
type InferStgExpr = GenStgExpr 'InferTaggedBinders
type InferStgRhs = GenStgRhs 'InferTaggedBinders
type InferStgTopBinding = GenStgTopBinding 'InferTaggedBinders
data TagEnv (p :: StgPass)
TE :: TagSigEnv -> (BinderP p -> Id) -> !Bool -> TagEnv (p :: StgPass)
[te_env] :: TagEnv (p :: StgPass) -> TagSigEnv
[te_get] :: TagEnv (p :: StgPass) -> BinderP p -> Id
[te_bytecode] :: TagEnv (p :: StgPass) -> !Bool
type TagSigEnv = IdEnv TagSig
instance GHC.Utils.Outputable.Outputable (GHC.Stg.InferTags.Types.TagEnv p)


-- | Non-global free variable analysis on STG terms. This pass annotates
--   non-top-level closure bindings with captured variables. Global
--   variables are not captured. For example, in a top-level binding like
--   (pseudo-STG)
--   
--   f = [x,y] . let g = [p] . reverse (x ++ p) in g y
--   
--   In g, <a>reverse</a> and <a>(++)</a> are global variables so they're
--   not considered free. <tt>p</tt> is an argument, so <tt>x</tt> is the
--   only actual free variable here. The annotated version is thus:
--   
--   f = [x,y] . let g = [x] [p] . reverse (x ++ p) in g y
--   
--   Note that non-top-level recursive bindings are also considered free
--   within the group:
--   
--   map = {} r [f xs0] let { Rec { go = {f, go} r [xs1] case xs1 of { []
--   -&gt; [] []; : x xs2 -&gt; let { xs' = {go, xs2} u [] go xs2; } in let
--   { x' = {f, x} u [] f x; } in : [x' xs']; }; end Rec } } in go xs0;
--   
--   Here go is free in its RHS.
--   
--   Top-level closure bindings never capture variables as all of their
--   free variables are global.
module GHC.Stg.FVs

-- | Dependency sort a STG program, and annotate it with free variables The
--   returned bindings: * Are in dependency order * Each StgRhsClosure is
--   correctly annotated (in its extension field) with the free variables
--   needed in the closure * Each StgCase is correctly annotated (in its
--   extension field) with the variables that must be saved across the case
depSortWithAnnotStgPgm :: Module -> [StgTopBinding] -> [(CgStgTopBinding, ImpFVs)]

-- | Dependency analysis on STG terms.
--   
--   Dependencies of a binding are just free variables in the binding. This
--   includes imported ids and ids in the current module. For recursive
--   groups we just return one set of free variables which is just the
--   union of dependencies of all bindings in the group.
--   
--   Implementation: pass bound variables (NestedIds) to recursive calls,
--   get free variables (TopFVs) back. We ignore imported TopFVs as they do
--   not change the ordering but it improves performance (see
--   <tt>nameIsExternalFrom</tt> call in <tt>vars_fvs</tt>).
annBindingFreeVars :: Module -> StgBinding -> CgStgBinding


-- | Note [CSE for Stg] ~~~~~~~~~~~~~~~~~~
--   
--   This module implements a simple common subexpression elimination pass
--   for STG. This is useful because there are expressions that we want to
--   common up (because they are operationally equivalent), but that we
--   cannot common up in Core, because their types differ. This was
--   originally reported as #9291.
--   
--   There are two types of common code occurrences that we aim for, see
--   Note [Case 1: CSEing allocated closures] and Note [Case 2: CSEing case
--   binders] below.
--   
--   Note [Case 1: CSEing allocated closures]
--   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--   
--   The first kind of CSE opportunity we aim for is generated by this
--   Haskell code:
--   
--   bar :: a -&gt; (Either Int a, Either Bool a) bar x = (Right x, Right
--   x)
--   
--   which produces this Core:
--   
--   bar :: forall a. a -&gt; (Either Int a, Either Bool a) bar <tt>a x =
--   (Right </tt>Int <tt>a x, Right </tt>Bool @a x)
--   
--   where the two components of the tuple are different terms, and cannot
--   be commoned up (easily). On the STG level we have
--   
--   bar [x] = let c1 = Right [x] c2 = Right [x] in (c1,c2)
--   
--   and now it is obvious that we can write
--   
--   bar [x] = let c1 = Right [x] in (c1,c1)
--   
--   instead.
--   
--   Note [Case 2: CSEing case binders] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--   
--   The second kind of CSE opportunity we aim for is more interesting, and
--   came up in #9291 and #5344: The Haskell code
--   
--   foo :: Either Int a -&gt; Either Bool a foo (Right x) = Right x foo _
--   = Left False
--   
--   produces this Core
--   
--   foo :: forall a. Either Int a -&gt; Either Bool a foo <tt>a e = case e
--   of b { Left n -&gt; … , Right x -&gt; Right </tt>Bool @a x }
--   
--   where we cannot CSE `Right <tt>Bool </tt>a x` with the case binder
--   <tt>b</tt> as they have different types. But in STG we have
--   
--   foo [e] = case e of b { Left [n] -&gt; … , Right [x] -&gt; Right [x] }
--   
--   and nothing stops us from transforming that to
--   
--   foo [e] = case e of b { Left [n] -&gt; … , Right [x] -&gt; b}
--   
--   Note that this can revive dead case binders (e.g. "b" above), hence we
--   zap occurrence information on all case binders during STG CSE. See
--   Note [Dead-binder optimisation] in GHC.StgToCmm.Expr.
--   
--   Note [StgCse after unarisation] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--   
--   Consider two unboxed sum terms:
--   
--   (# 1 | #) :: (# Int | Int# #) (# 1 | #) :: (# Int | Int #)
--   
--   These two terms are not equal as they unarise to different unboxed
--   tuples. However if we run StgCse before Unarise, it'll think the two
--   terms (# 1 | #) are equal, and replace one of these with a binder to
--   the other. That's bad -- #15300.
--   
--   Solution: do unarise first.
module GHC.Stg.CSE
stgCse :: [InStgTopBinding] -> [OutStgTopBinding]
instance GHC.Internal.Base.Functor GHC.Stg.CSE.ConAppMap
instance GHC.Internal.Base.Functor GHC.Stg.CSE.StgArgMap
instance GHC.Data.TrieMap.TrieMap GHC.Stg.CSE.ConAppMap
instance GHC.Data.TrieMap.TrieMap GHC.Stg.CSE.StgArgMap


-- | Commonly useful utilities for manipulating the Core language
module GHC.Core.Utils

-- | Wrap the given expression in the coercion safely, dropping identity
--   coercions and coalescing nested coercions
mkCast :: HasDebugCallStack => CoreExpr -> CoercionR -> CoreExpr
mkCastMCo :: CoreExpr -> MCoercionR -> CoreExpr
mkPiMCo :: Var -> MCoercionR -> MCoercionR

-- | Wraps the given expression in the source annotation, dropping the
--   annotation if possible.
mkTick :: CoreTickish -> CoreExpr -> CoreExpr
mkTicks :: [CoreTickish] -> CoreExpr -> CoreExpr
mkTickNoHNF :: CoreTickish -> CoreExpr -> CoreExpr
tickHNFArgs :: CoreTickish -> CoreExpr -> CoreExpr

-- | <tt>bindNonRec x r b</tt> produces either:
--   
--   <pre>
--   let x = r in b
--   </pre>
--   
--   or:
--   
--   <pre>
--   case r of x { _DEFAULT_ -&gt; b }
--   </pre>
--   
--   depending on whether we have to use a <tt>case</tt> or <tt>let</tt>
--   binding for the expression (see <a>needsCaseBinding</a>). It's used by
--   the desugarer to avoid building bindings that give Core Lint a heart
--   attack, although actually the simplifier deals with them perfectly
--   well. See also <a>mkCoreLet</a>
bindNonRec :: HasDebugCallStack => Id -> CoreExpr -> CoreExpr -> CoreExpr

-- | <a>needsCaseBinding</a> tests whether we have to use a <tt>case</tt>
--   rather than <tt>let</tt> binding for this expression as per the
--   invariants of <a>CoreExpr</a>: see
--   <a>GHC.Core#let_can_float_invariant</a> (needsCaseBinding ty rhs)
--   requires that <tt>ty</tt> has a well-defined levity, else `typeLevity
--   ty` will fail; but that should be the case because
--   <a>needsCaseBinding</a> is only called once typechecking is complete
needsCaseBinding :: HasDebugCallStack => Type -> CoreExpr -> Bool
needsCaseBindingL :: Levity -> CoreExpr -> Bool

-- | This guy constructs the value that the scrutinee must have given that
--   you are in one particular branch of a case
mkAltExpr :: AltCon -> [CoreBndr] -> [Type] -> CoreExpr
mkDefaultCase :: CoreExpr -> Id -> CoreExpr -> CoreExpr
mkSingleAltCase :: CoreExpr -> Id -> AltCon -> [Var] -> CoreExpr -> CoreExpr

-- | Extract the default case alternative
findDefault :: [Alt b] -> ([Alt b], Maybe (Expr b))
addDefault :: [Alt b] -> Maybe (Expr b) -> [Alt b]

-- | Find the case alternative corresponding to a particular constructor:
--   panics if no such constructor exists
findAlt :: AltCon -> [Alt b] -> Maybe (Alt b)
isDefaultAlt :: Alt b -> Bool

-- | Merge alternatives preserving order; alternatives in the first
--   argument shadow ones in the second
mergeAlts :: [Alt a] -> [Alt a] -> [Alt a]
mergeCaseAlts :: Id -> [CoreAlt] -> Maybe ([CoreBind], [CoreAlt])

-- | Given:
--   
--   <pre>
--   case (C a b x y) of
--          C b x y -&gt; ...
--   </pre>
--   
--   We want to drop the leading type argument of the scrutinee leaving the
--   arguments to match against the pattern
trimConArgs :: AltCon -> [CoreArg] -> [CoreArg]
filterAlts :: TyCon -> [Type] -> [AltCon] -> [Alt b] -> ([AltCon], [Alt b])
combineIdenticalAlts :: [AltCon] -> [CoreAlt] -> (Bool, [AltCon], [CoreAlt])

-- | Refine the default alternative to a <a>DataAlt</a>, if there is a
--   unique way to do so. See Note [Refine DEFAULT case alternatives]
refineDefaultAlt :: [Unique] -> Mult -> TyCon -> [Type] -> [AltCon] -> [CoreAlt] -> (Bool, [CoreAlt])
scaleAltsBy :: Mult -> [CoreAlt] -> [CoreAlt]

-- | Recover the type of a well-typed Core expression. Fails when applied
--   to the actual <a>Type</a> expression as it cannot really be said to
--   have a type
exprType :: HasDebugCallStack => CoreExpr -> Type

-- | Returns the type of the alternatives right hand side
coreAltType :: CoreAlt -> Type

-- | Returns the type of the first alternative, which should be the same as
--   for all alternatives
coreAltsType :: [CoreAlt] -> Type

-- | Makes a <tt>(-&gt;)</tt> type or an implicit forall type, depending on
--   whether it is given a type variable or a term variable. This is used,
--   for example, when producing the type of a lambda.
mkLamType :: HasDebugCallStack => Var -> Type -> Type

-- | <a>mkLamType</a> for multiple type or value arguments
mkLamTypes :: [Var] -> Type -> Type

-- | This one works out the FunTyFlag from the argument type See
--   GHC.Types.Var Note [FunTyFlag]
mkFunctionType :: HasDebugCallStack => Mult -> Type -> Type -> Type
exprIsTrivial :: CoreExpr -> Bool
getIdFromTrivialExpr :: HasDebugCallStack => CoreExpr -> Id
getIdFromTrivialExpr_maybe :: CoreExpr -> Maybe Id

-- | The worker function for Note [exprIsTrivial] and Note
--   [getIdFromTrivialExpr] This is meant to have the code of both
--   functions in one place and make it easy to derive custom predicates.
--   
--   (trivial_expr_fold k_id k_triv k_not_triv e) * returns (k_id x) if
--   <tt>e</tt> is a variable <tt>x</tt> (with trivial wrapping) * returns
--   (k_lit x) if <tt>e</tt> is a trivial literal <tt>l</tt> (with trivial
--   wrapping) * returns k_triv if <tt>e</tt> is a literal, type, or
--   coercion (with trivial wrapping) * returns k_not_triv otherwise
--   
--   where "trivial wrapping" is * Type application or abstraction * Ticks
--   other than <a>tickishIsCode</a> * `case e of {}` an empty case
trivial_expr_fold :: (Id -> r) -> (Literal -> r) -> r -> r -> CoreExpr -> r
exprIsDupable :: Platform -> CoreExpr -> Bool
exprIsCheap :: CoreExpr -> Bool
exprIsExpandable :: CoreExpr -> Bool
exprIsCheapX :: CheapAppFun -> CoreExpr -> Bool
type CheapAppFun = Id -> Arity -> Bool

-- | exprIsHNF returns true for expressions that are certainly
--   <i>already</i> evaluated to <i>head</i> normal form. This is used to
--   decide whether it's ok to perform case-to-let for lifted expressions,
--   which changes:
--   
--   <pre>
--   case x of x' { _ -&gt; e }
--   </pre>
--   
--   into:
--   
--   <pre>
--   let x' = x in e
--   </pre>
--   
--   and in so doing makes the binding lazy.
--   
--   So, it does <i>not</i> treat variables as evaluated, unless they say
--   they are. However, it <i>does</i> treat partial applications and
--   constructor applications as values, even if their arguments are
--   non-trivial, provided the argument type is lifted. For example, both
--   of these are values:
--   
--   <pre>
--   (:) (f x) (map f xs)
--   map (...redex...)
--   </pre>
--   
--   because <a>seq</a> on such things completes immediately.
--   
--   For unlifted argument types, we have to be careful:
--   
--   <pre>
--   C (f x :: Int#)
--   </pre>
--   
--   Suppose <tt>f x</tt> diverges; then <tt>C (f x)</tt> is not a value.
--   We check for this using needsCaseBinding below
exprIsHNF :: CoreExpr -> Bool

-- | To a first approximation, <a>exprOkForSpeculation</a> returns True of
--   an expression that is:
--   
--   <ul>
--   <li>Safe to evaluate even if normal order eval might not evaluate the
--   expression at all, and</li>
--   <li>Safe <i>not</i> to evaluate even if normal order would do so</li>
--   </ul>
--   
--   More specifically, this means that: * A: Evaluation of the expression
--   reaches weak-head-normal-form, * B: soon, * C: without causing a write
--   side effect (e.g. writing a mutable variable).
--   
--   In particular, an expression that may * throw a synchronous Haskell
--   exception, or * risk an unchecked runtime exception (e.g. array out of
--   bounds, divide by zero) is <i>not</i> considered OK-for-speculation,
--   as these violate condition A.
--   
--   For <a>exprOkToDiscard</a>, condition A is weakened to allow
--   expressions that might risk an unchecked runtime exception but must
--   otherwise reach weak-head-normal-form. (Note that
--   <a>exprOkForSpeculation</a> implies <a>exprOkToDiscard</a>)
--   
--   But in fact both functions are a bit more conservative than the above,
--   in at least the following ways:
--   
--   <ul>
--   <li>W1: We do not take advantage of already-evaluated lifted
--   variables. As a result, <a>exprIsHNF</a> DOES NOT imply
--   <a>exprOkForSpeculation</a>; if <tt>y</tt> is a case-binder of lifted
--   type, then <tt>exprIsHNF y</tt> is <a>True</a>, while
--   <tt>exprOkForSpeculation y</tt> is <a>False</a>. See Note
--   [exprOkForSpeculation and evaluated variables] for why.</li>
--   <li>W2: Read-effects on mutable variables are currently also included.
--   See Note [Classifying primop effects] <a>GHC.Builtin.PrimOps</a>.</li>
--   <li>W3: Currently, <a>exprOkForSpeculation</a> always returns
--   <a>False</a> for let-expressions. Lets can be stacked deeply, so we
--   just give up. In any case, the argument of <a>exprOkForSpeculation</a>
--   is usually in a strict context, so any lets will have been floated
--   away.</li>
--   </ul>
--   
--   As an example of the considerations in this test, consider:
--   
--   <pre>
--   let x = case y# +# 1# of { r# -&gt; I# r# }
--   in E
--   </pre>
--   
--   being translated to:
--   
--   <pre>
--   case y# +# 1# of { r# -&gt;
--      let x = I# r#
--      in E
--   }
--   </pre>
--   
--   We can only do this if the <tt>y# +# 1#</tt> is ok for speculation: it
--   has no side effects, and can't diverge or raise an exception.
--   
--   See also Note [Classifying primop effects] in
--   <a>GHC.Builtin.PrimOps</a> and Note [Transformations affected by
--   primop effects].
--   
--   <a>exprOkForSpeculation</a> is used to define Core's let-can-float
--   invariant. (See Note [Core let-can-float invariant] in
--   <a>GHC.Core</a>.) It is therefore frequently called on arguments of
--   unlifted type, especially via <a>needsCaseBinding</a>. But it is
--   sometimes called on expressions of lifted type as well. For example,
--   see Note [Speculative evaluation] in <a>GHC.CoreToStg.Prep</a>.
exprOkForSpeculation :: CoreExpr -> Bool

-- | To a first approximation, <a>exprOkForSpeculation</a> returns True of
--   an expression that is:
--   
--   <ul>
--   <li>Safe to evaluate even if normal order eval might not evaluate the
--   expression at all, and</li>
--   <li>Safe <i>not</i> to evaluate even if normal order would do so</li>
--   </ul>
--   
--   More specifically, this means that: * A: Evaluation of the expression
--   reaches weak-head-normal-form, * B: soon, * C: without causing a write
--   side effect (e.g. writing a mutable variable).
--   
--   In particular, an expression that may * throw a synchronous Haskell
--   exception, or * risk an unchecked runtime exception (e.g. array out of
--   bounds, divide by zero) is <i>not</i> considered OK-for-speculation,
--   as these violate condition A.
--   
--   For <a>exprOkToDiscard</a>, condition A is weakened to allow
--   expressions that might risk an unchecked runtime exception but must
--   otherwise reach weak-head-normal-form. (Note that
--   <a>exprOkForSpeculation</a> implies <a>exprOkToDiscard</a>)
--   
--   But in fact both functions are a bit more conservative than the above,
--   in at least the following ways:
--   
--   <ul>
--   <li>W1: We do not take advantage of already-evaluated lifted
--   variables. As a result, <a>exprIsHNF</a> DOES NOT imply
--   <a>exprOkForSpeculation</a>; if <tt>y</tt> is a case-binder of lifted
--   type, then <tt>exprIsHNF y</tt> is <a>True</a>, while
--   <tt>exprOkForSpeculation y</tt> is <a>False</a>. See Note
--   [exprOkForSpeculation and evaluated variables] for why.</li>
--   <li>W2: Read-effects on mutable variables are currently also included.
--   See Note [Classifying primop effects] <a>GHC.Builtin.PrimOps</a>.</li>
--   <li>W3: Currently, <a>exprOkForSpeculation</a> always returns
--   <a>False</a> for let-expressions. Lets can be stacked deeply, so we
--   just give up. In any case, the argument of <a>exprOkForSpeculation</a>
--   is usually in a strict context, so any lets will have been floated
--   away.</li>
--   </ul>
--   
--   As an example of the considerations in this test, consider:
--   
--   <pre>
--   let x = case y# +# 1# of { r# -&gt; I# r# }
--   in E
--   </pre>
--   
--   being translated to:
--   
--   <pre>
--   case y# +# 1# of { r# -&gt;
--      let x = I# r#
--      in E
--   }
--   </pre>
--   
--   We can only do this if the <tt>y# +# 1#</tt> is ok for speculation: it
--   has no side effects, and can't diverge or raise an exception.
--   
--   See also Note [Classifying primop effects] in
--   <a>GHC.Builtin.PrimOps</a> and Note [Transformations affected by
--   primop effects].
--   
--   <a>exprOkForSpeculation</a> is used to define Core's let-can-float
--   invariant. (See Note [Core let-can-float invariant] in
--   <a>GHC.Core</a>.) It is therefore frequently called on arguments of
--   unlifted type, especially via <a>needsCaseBinding</a>. But it is
--   sometimes called on expressions of lifted type as well. For example,
--   see Note [Speculative evaluation] in <a>GHC.CoreToStg.Prep</a>.
exprOkToDiscard :: CoreExpr -> Bool

-- | A special version of <a>exprOkForSpeculation</a> used during Note
--   [Speculative evaluation]. When the predicate arg <tt>fun_ok</tt>
--   returns False for <tt>b</tt>, then <tt>b</tt> is never considered
--   ok-for-spec.
exprOkForSpecEval :: (Id -> Bool) -> CoreExpr -> Bool
exprIsWorkFree :: CoreExpr -> Bool

-- | Similar to <a>exprIsHNF</a> but includes CONLIKE functions as well as
--   data constructors. Conlike arguments are considered interesting by the
--   inliner.
exprIsConLike :: CoreExpr -> Bool
isCheapApp :: CheapAppFun
isExpandableApp :: CheapAppFun
isSaturatedConApp :: CoreExpr -> Bool

-- | Check if the expression is zero or more Ticks wrapped around a literal
--   string.
exprIsTickedString :: CoreExpr -> Bool

-- | Extract a literal string from an expression that is zero or more Ticks
--   wrapped around a literal string. Returns Nothing if the expression has
--   a different shape. Used to "look through" Ticks in places that need to
--   handle literal strings.
exprIsTickedString_maybe :: CoreExpr -> Maybe ByteString

-- | Can we bind this <a>CoreExpr</a> at the top level?
exprIsTopLevelBindable :: CoreExpr -> Type -> Bool
altsAreExhaustive :: [Alt b] -> Bool

-- | Should we look past this tick when eta-expanding the given function?
--   
--   See Note [Ticks and mandatory eta expansion] Takes the function we are
--   applying as argument.
etaExpansionTick :: forall (pass :: TickishPass). Id -> GenTickish pass -> Bool

-- | A cheap equality test which bales out fast! If it returns
--   <tt>True</tt> the arguments are definitely equal, otherwise, they may
--   or may not be equal.
cheapEqExpr :: Expr b -> Expr b -> Bool

-- | Cheap expression equality test, can ignore ticks by type.
cheapEqExpr' :: (CoreTickish -> Bool) -> Expr b -> Expr b -> Bool

-- | Finds differences between core bindings, see <tt>diffExpr</tt>.
--   
--   The main problem here is that while we expect the binds to have the
--   same order in both lists, this is not guaranteed. To do this properly
--   we'd either have to do some sort of unification or check all possible
--   mappings, which would be seriously expensive. So instead we simply
--   match single bindings as far as we can. This leaves us just with
--   mutually recursive and/or mismatching bindings, which we then
--   speculatively match by ordering them. It's by no means perfect, but
--   gets the job done well enough.
--   
--   Only used in GHC.Core.Lint.lintAnnots
diffBinds :: Bool -> RnEnv2 -> [(Var, CoreExpr)] -> [(Var, CoreExpr)] -> ([SDoc], RnEnv2)

-- | If the expression is a <a>Type</a>, converts. Otherwise, panics. NB:
--   This does <i>not</i> convert <a>Coercion</a> to <tt>CoercionTy</tt>.
exprToType :: CoreExpr -> Type

-- | Determines the type resulting from applying an expression with given
--   type
applyTypeToArgs :: HasDebugCallStack => SDoc -> Type -> [CoreExpr] -> Type
dataConRepInstPat :: [Unique] -> Mult -> DataCon -> [Type] -> ([TyCoVar], [Id])
dataConRepFSInstPat :: [FastString] -> [Unique] -> Mult -> DataCon -> [Type] -> ([TyCoVar], [Id])

-- | True if the type has no non-bottom elements, e.g. when it is an empty
--   datatype, or a GADT with non-satisfiable type parameters, e.g. Int :~:
--   Bool. See Note [Bottoming expressions]
--   
--   See Note [No alternatives lint check] for another use of this
--   function.
isEmptyTy :: Type -> Bool

-- | If <tt>normSplitTyConApp_maybe _ ty = Just (tc, tys, co)</tt> then
--   <tt>ty |&gt; co = tc tys</tt>. It's <a>splitTyConApp_maybe</a>, but
--   looks through coercions via <a>topNormaliseType_maybe</a>. Hence the
--   "norm" prefix.
normSplitTyConApp_maybe :: FamInstEnvs -> Type -> Maybe (TyCon, [Type], Coercion)

-- | Strip ticks satisfying a predicate from top of an expression
stripTicksTop :: (CoreTickish -> Bool) -> Expr b -> ([CoreTickish], Expr b)

-- | Strip ticks satisfying a predicate from top of an expression,
--   returning the remaining expression
stripTicksTopE :: (CoreTickish -> Bool) -> Expr b -> Expr b

-- | Strip ticks satisfying a predicate from top of an expression,
--   returning the ticks
stripTicksTopT :: (CoreTickish -> Bool) -> Expr b -> [CoreTickish]

-- | Completely strip ticks satisfying a predicate from an expression. Note
--   this is O(n) in the size of the expression!
stripTicksE :: (CoreTickish -> Bool) -> Expr b -> Expr b
stripTicksT :: (CoreTickish -> Bool) -> Expr b -> [CoreTickish]
mkInScopeSetBndrs :: [CoreBind] -> InScopeSet
extendInScopeSetBind :: InScopeSet -> CoreBind -> InScopeSet
extendInScopeSetBndrs :: InScopeSet -> [CoreBind] -> InScopeSet

-- | <tt>collectMakeStaticArgs (makeStatic t srcLoc e)</tt> yields <tt>Just
--   (makeStatic, t, srcLoc, e)</tt>.
--   
--   Returns <tt>Nothing</tt> for every other expression.
collectMakeStaticArgs :: CoreExpr -> Maybe (CoreExpr, Type, CoreExpr, CoreExpr)

-- | Does this binding bind a join point (or a recursive group of join
--   points)?
isJoinBind :: CoreBind -> Bool
mkStrictFieldSeqs :: [(Id, StrictnessMark)] -> CoreExpr -> CoreExpr

-- | Do we expect there to be any benefit if we make this var strict in
--   order for it to get treated as as cbv argument? See Note [Which Ids
--   should be strictified] See Note [CBV Function Ids] for more
--   background.
shouldStrictifyIdForCbv :: Var -> Bool
shouldUseCbvForId :: Var -> Bool
isUnsafeEqualityCase :: CoreExpr -> Id -> [CoreAlt] -> Maybe CoreExpr
dumpIdInfoOfProgram :: Bool -> (IdInfo -> SDoc) -> CoreProgram -> SDoc


-- | Hides away distracting bookkeeping while lambda lifting into a
--   <a>LiftM</a> monad.
module GHC.Stg.Lift.Monad

-- | <pre>
--   uncurry <a>mkStgBinding</a> . <a>decomposeStgBinding</a> = id
--   </pre>
decomposeStgBinding :: forall (pass :: StgPass). GenStgBinding pass -> (RecFlag, [(BinderP pass, GenStgRhs pass)])
mkStgBinding :: forall (pass :: StgPass). RecFlag -> [(BinderP pass, GenStgRhs pass)] -> GenStgBinding pass

-- | Environment threaded around in a scoped, <tt>Reader</tt>-like fashion.
data Env
Env :: StgLiftConfig -> !Subst -> !IdEnv DIdSet -> Env

-- | Read-only.
[e_config] :: Env -> StgLiftConfig

-- | We need to track the renamings of local <a>InId</a>s to their lifted
--   <a>OutId</a>, because shadowing might make a closure's free variables
--   unavailable at its call sites. Consider: <tt> let f y = x + y in let x
--   = 4 in f x </tt> Here, <tt>f</tt> can't be lifted to top-level,
--   because its free variable <tt>x</tt> isn't available at its call site.
[e_subst] :: Env -> !Subst

-- | Lifted <a>Id</a>s don't occur as free variables in any closure
--   anymore, because they are bound at the top-level. Every occurrence
--   must supply the formerly free variables of the lifted <a>Id</a>, so
--   they in turn become free variables of the call sites. This environment
--   tracks this expansion from lifted <a>Id</a>s to their free variables.
--   
--   <a>InId</a>s to <a>OutId</a>s.
--   
--   Invariant: <a>Id</a>s not present in this map won't be substituted.
[e_expansions] :: Env -> !IdEnv DIdSet

-- | We need to detect when we are lifting something out of the RHS of a
--   recursive binding (c.f. <a>GHC.Stg.Lift.Monad#floats</a>), in which
--   case that binding needs to be added to the same top-level recursive
--   group. This requires we detect a certain nesting structure, which is
--   encoded by <a>StartBindingGroup</a> and <a>EndBindingGroup</a>.
--   
--   Although <a>collectFloats</a> will only ever care if the current
--   binding to be lifted (through <a>LiftedBinding</a>) will occur inside
--   such a binding group or not, e.g. doesn't care about the nesting level
--   as long as its greater than 0.
data FloatLang
StartBindingGroup :: FloatLang
EndBindingGroup :: FloatLang
PlainTopBinding :: OutStgTopBinding -> FloatLang
LiftedBinding :: OutStgBinding -> FloatLang

-- | Flattens an expression in <tt>[<a>FloatLang</a>]</tt> into an STG
--   program, see <a>GHC.Stg.Lift.Monad#floats</a>. Important
--   pre-conditions: The nesting of opening <tt>StartBindinGroup</tt>s and
--   closing <tt>EndBindinGroup</tt>s is balanced. Also, it is crucial that
--   every binding group has at least one recursive binding inside.
--   Otherwise there's no point in announcing the binding group in the
--   first place and an <tt>ASSERT</tt> will trigger.
collectFloats :: [FloatLang] -> [OutStgTopBinding]

-- | The analysis monad consists of the following <a>RWST</a> components:
--   
--   <ul>
--   <li><a>Env</a>: Reader-like context. Contains a substitution, info
--   about how how lifted identifiers are to be expanded into applications
--   and configuration options.</li>
--   <li><tt><a>OrdList</a> <a>FloatLang</a></tt>: Writer output for the
--   resulting STG program.</li>
--   <li>No pure state component</li>
--   <li>But wrapping around <a>UniqSM</a> for generating fresh lifted
--   binders. (The <tt>uniqAway</tt> approach could give the same name to
--   two different lifted binders, so this is necessary.)</li>
--   </ul>
data LiftM a
runLiftM :: StgLiftConfig -> UniqSupply -> LiftM () -> [OutStgTopBinding]
getConfig :: LiftM StgLiftConfig

-- | Starts a recursive binding group. See <a>GHC.Stg.Lift.Monad#floats</a>
--   and <a>collectFloats</a>.
startBindingGroup :: LiftM ()

-- | Ends a recursive binding group. See <a>GHC.Stg.Lift.Monad#floats</a>
--   and <a>collectFloats</a>.
endBindingGroup :: LiftM ()

-- | Writes a plain <a>StgTopStringLit</a> to the output.
addTopStringLit :: OutId -> ByteString -> LiftM ()

-- | Lifts a binding to top-level. Depending on whether it's declared
--   inside a recursive RHS (see <a>GHC.Stg.Lift.Monad#floats</a> and
--   <a>collectFloats</a>), this might be added to an existing recursive
--   top-level binding group.
addLiftedBinding :: OutStgBinding -> LiftM ()

-- | Takes a binder and a continuation which is called with the substituted
--   binder. The continuation will be evaluated in a <a>LiftM</a> context
--   in which that binder is deemed in scope. Think of it as a <a>local</a>
--   computation: After the continuation finishes, the new binding won't be
--   in scope anymore.
withSubstBndr :: Id -> (Id -> LiftM a) -> LiftM a

-- | See <a>withSubstBndr</a>.
withSubstBndrs :: Traversable f => f Id -> (f Id -> LiftM a) -> LiftM a

-- | Similarly to <a>withSubstBndr</a>, this function takes a set of
--   variables to abstract over, the binder to lift (and generate a fresh,
--   substituted name for) and a continuation in which that fresh, lifted
--   binder is in scope.
--   
--   It takes care of all the details involved with copying and adjusting
--   the binder and fresh name generation.
withLiftedBndr :: DIdSet -> Id -> (Id -> LiftM a) -> LiftM a

-- | See <a>withLiftedBndr</a>.
withLiftedBndrs :: Traversable f => DIdSet -> f Id -> (f Id -> LiftM a) -> LiftM a

-- | Substitutes a binder <i>occurrence</i>, which was brought in scope
--   earlier by <a>withSubstBndr</a> / <a>withLiftedBndr</a>.
substOcc :: Id -> LiftM Id

-- | Whether the given binding was decided to be lambda lifted.
isLifted :: InId -> LiftM Bool

-- | Returns an empty list for a binding that was not lifted and the list
--   of all local variables the binding abstracts over (so, exactly the
--   additional arguments at adjusted call sites) otherwise.
formerFreeVars :: InId -> LiftM [OutId]

-- | Creates an <i>expander function</i> for the current set of lifted
--   binders. This expander function will replace any <a>InId</a> by their
--   corresponding <a>OutId</a> and, in addition, will expand any lifted
--   binders by the former free variables it abstracts over.
liftedIdsExpander :: LiftM (DIdSet -> DIdSet)
instance GHC.Internal.Base.Applicative GHC.Stg.Lift.Monad.LiftM
instance GHC.Internal.Base.Functor GHC.Stg.Lift.Monad.LiftM
instance GHC.Internal.Base.Monad GHC.Stg.Lift.Monad.LiftM
instance GHC.Types.Unique.Supply.MonadUnique GHC.Stg.Lift.Monad.LiftM
instance GHC.Utils.Outputable.Outputable GHC.Stg.Lift.Monad.FloatLang

module GHC.Core.Tidy
tidyExpr :: TidyEnv -> CoreExpr -> CoreExpr
tidyRules :: TidyEnv -> [CoreRule] -> [CoreRule]
tidyCbvInfoTop :: HasDebugCallStack => NameSet -> Id -> CoreExpr -> Id
tidyBndrs :: TidyEnv -> [Var] -> (TidyEnv, [Var])

module GHC.Core.Subst

-- | Type &amp; coercion &amp; id substitution
--   
--   The <a>Subst</a> data type defined in this module contains
--   substitution for tyvar, covar and id. However, operations on
--   IdSubstEnv (mapping from <a>Id</a> to <a>CoreExpr</a>) that require
--   the definition of the <a>Expr</a> data type are defined in
--   GHC.Core.Subst to avoid circular module dependency.
data Subst
Subst :: InScopeSet -> IdSubstEnv -> TvSubstEnv -> CvSubstEnv -> Subst

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type

-- | A substitution of <tt>Expr</tt>s for non-coercion <a>Id</a>s
type IdSubstEnv = IdEnv CoreExpr

-- | A set of variables that are in scope at some point.
--   
--   Note that this is a <i>superset</i> of the variables that are
--   currently in scope. See Note [The InScopeSet invariant].
--   
--   "Secrets of the Glasgow Haskell Compiler inliner" Section 3.2 provides
--   the motivation for this abstraction.
data InScopeSet

-- | De-shadowing the program is sometimes a useful pre-pass. It can be
--   done simply by running over the bindings with an empty substitution,
--   because substitution returns a result that has no-shadowing
--   guaranteed.
--   
--   (Actually, within a single <i>type</i> there might still be shadowing,
--   because <tt>substTy</tt> is a no-op for the empty substitution, but
--   that's probably OK.)
--   
--   <ul>
--   <li><i>Aug 09</i> This function is not used in GHC at the moment, but
--   seems so short and simple that I'm going to leave it here</li>
--   </ul>
deShadowBinds :: CoreProgram -> CoreProgram

-- | Substitutes for the <a>Id</a>s within the <a>RuleInfo</a> given the
--   new function <a>Id</a>
substRuleInfo :: Subst -> Id -> RuleInfo -> RuleInfo
substRulesForImportedIds :: Subst -> [CoreRule] -> [CoreRule]

-- | Substitute within a <a>Type</a> disabling the sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyUnchecked :: Subst -> Type -> Type

-- | Substitute within a <a>Coercion</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substCo :: HasDebugCallStack => Subst -> Coercion -> Coercion

-- | substExpr applies a substitution to an entire <a>CoreExpr</a>.
--   Remember, you may only apply the substitution <i>once</i>: See Note
--   [Substitutions apply only once] in <a>GHC.Core.TyCo.Subst</a>
--   
--   Do *not* attempt to short-cut in the case of an empty substitution!
--   See Note [Extending the IdSubstEnv]
substExpr :: HasDebugCallStack => Subst -> CoreExpr -> CoreExpr
substExprSC :: HasDebugCallStack => Subst -> CoreExpr -> CoreExpr

-- | Apply a substitution to an entire <a>CoreBind</a>, additionally
--   returning an updated <a>Subst</a> that should be used by subsequent
--   substitutions.
substBind :: HasDebugCallStack => Subst -> CoreBind -> (Subst, CoreBind)

-- | Apply a substitution to an entire <a>CoreBind</a>, additionally
--   returning an updated <a>Subst</a> that should be used by subsequent
--   substitutions.
substBindSC :: HasDebugCallStack => Subst -> CoreBind -> (Subst, CoreBind)

-- | Substitutes for the <a>Id</a>s within an unfolding NB: substUnfolding
--   <i>discards</i> any unfolding without without a Stable source. This is
--   usually what we want, but it may be a bit unexpected
substUnfolding :: Subst -> Unfolding -> Unfolding

-- | Substitutes for the <a>Id</a>s within an unfolding NB: substUnfolding
--   <i>discards</i> any unfolding without without a Stable source. This is
--   usually what we want, but it may be a bit unexpected
substUnfoldingSC :: Subst -> Unfolding -> Unfolding

-- | Find the substitution for an <a>Id</a> in the <a>Subst</a> The Id
--   should not be a CoVar
lookupIdSubst :: HasDebugCallStack => Subst -> Id -> CoreExpr
lookupIdSubst_maybe :: HasDebugCallStack => Subst -> Id -> Maybe CoreExpr
substIdType :: Subst -> Id -> Id
substIdOcc :: Subst -> Id -> Id

-- | Drop free vars from the breakpoint if they have a non-variable
--   substitution.
substTickish :: Subst -> CoreTickish -> CoreTickish
substDVarSet :: HasDebugCallStack => Subst -> DVarSet -> DVarSet

-- | Substitute into some <a>IdInfo</a> with regard to the supplied new
--   <a>Id</a>. Discards unfoldings, unless they are Stable
substIdInfo :: Subst -> Id -> IdInfo -> Maybe IdInfo
emptySubst :: Subst
mkEmptySubst :: InScopeSet -> Subst
mkTCvSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> Subst

-- | Simultaneously substitute for a bunch of variables No left-right
--   shadowing ie the substitution for (x y. e) a1 a2 so neither x nor y
--   scope over a1 a2
mkOpenSubst :: InScopeSet -> [(Var, CoreArg)] -> Subst
isEmptySubst :: Subst -> Bool

-- | Add a substitution for an <a>Id</a> to the <a>Subst</a>: you must
--   ensure that the in-scope set is such that TyCoSubst Note [The
--   substitution invariant] holds after extending the substitution like
--   this
extendIdSubst :: Subst -> Id -> CoreExpr -> Subst

-- | Adds multiple <a>Id</a> substitutions to the <a>Subst</a>: see also
--   <a>extendIdSubst</a>
extendIdSubstList :: Subst -> [(Id, CoreExpr)] -> Subst
extendTCvSubst :: Subst -> TyCoVar -> Type -> Subst

-- | Adds multiple <a>TyVar</a> substitutions to the <a>Subst</a>: see also
--   <a>extendTvSubst</a>
extendTvSubstList :: Subst -> [(TyVar, Type)] -> Subst
extendIdSubstWithClone :: Subst -> Id -> Id -> Subst

-- | Add a substitution appropriate to the thing being substituted (whether
--   an expression, type, or coercion). See also <a>extendIdSubst</a>,
--   <a>extendTvSubst</a>, <a>extendCvSubst</a>
extendSubst :: Subst -> Var -> CoreArg -> Subst

-- | Add a substitution as appropriate to each of the terms being
--   substituted (whether expressions, types, or coercions). See also
--   <a>extendSubst</a>.
extendSubstList :: Subst -> [(Var, CoreArg)] -> Subst
extendSubstWithVar :: Subst -> Var -> Var -> Subst

-- | Add the <a>Var</a> to the in-scope set
extendSubstInScope :: Subst -> Var -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeList :: Subst -> [Var] -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeSet :: Subst -> VarSet -> Subst
isInScope :: Var -> Subst -> Bool
setInScope :: Subst -> InScopeSet -> Subst

-- | Find the in-scope set: see Note [The substitution invariant]
getSubstInScope :: Subst -> InScopeSet

-- | Add a substitution for a <a>TyVar</a> to the <a>Subst</a> The
--   <a>TyVar</a> *must* be a real TyVar, and not a CoVar You must ensure
--   that the in-scope set is such that Note [The substitution invariant]
--   holds after extending the substitution like this.
extendTvSubst :: Subst -> TyVar -> Type -> Subst

-- | Add a substitution from a <a>CoVar</a> to a <a>Coercion</a> to the
--   <a>Subst</a>: you must ensure that the in-scope set satisfies Note
--   [The substitution invariant] after extending the substitution like
--   this
extendCvSubst :: Subst -> CoVar -> Coercion -> Subst
delBndr :: Subst -> Var -> Subst
delBndrs :: Subst -> [Var] -> Subst

-- | Remove all substitutions that might have been built up while
--   preserving the in-scope set originally called zapSubstEnv
zapSubst :: Subst -> Subst

-- | Substitutes a <a>Var</a> for another one according to the <a>Subst</a>
--   given, returning the result and an updated <a>Subst</a> that should be
--   used by subsequent substitutions. <a>IdInfo</a> is preserved by this
--   process, although it is substituted into appropriately.
substBndr :: Subst -> Var -> (Subst, Var)

-- | Applies <a>substBndr</a> to a number of <a>Var</a>s, accumulating a
--   new <a>Subst</a> left-to-right
substBndrs :: Traversable f => Subst -> f Var -> (Subst, f Var)

-- | Substitute in a mutually recursive group of <a>Id</a>s
substRecBndrs :: Traversable f => Subst -> f Id -> (Subst, f Id)
substTyVarBndr :: HasDebugCallStack => Subst -> TyVar -> (Subst, TyVar)
substCoVarBndr :: HasDebugCallStack => Subst -> CoVar -> (Subst, CoVar)
cloneBndr :: Subst -> Unique -> Var -> (Subst, Var)
cloneBndrs :: MonadUnique m => Subst -> [Var] -> m (Subst, [Var])

-- | Very similar to <a>substBndr</a>, but it always allocates a new
--   <a>Unique</a> for each variable in its output. It substitutes the
--   IdInfo though. Discards non-Stable unfoldings
cloneIdBndr :: Subst -> UniqSupply -> Id -> (Subst, Id)

-- | Applies <a>cloneIdBndr</a> to a number of <a>Id</a>s, accumulating a
--   final substitution from left to right Discards non-Stable unfoldings
cloneIdBndrs :: Subst -> UniqSupply -> [Id] -> (Subst, [Id])

-- | Clone a mutually recursive group of <a>Id</a>s
cloneRecIdBndrs :: MonadUnique m => Subst -> [Id] -> m (Subst, [Id])

module GHC.Core.Opt.StaticArgs
doStaticArgs :: UniqSupply -> CoreProgram -> CoreProgram

module GHC.Core.Opt.Exitify

-- | Traverses the AST, simply to find all joinrecs and call
--   <tt>exitify</tt> on them. The really interesting function is
--   exitifyRec
exitifyProgram :: CoreProgram -> CoreProgram

module GHC.Core.Opt.CSE
cseProgram :: CoreProgram -> CoreProgram

-- | Runs CSE on a single expression.
--   
--   This entry point is not used in the compiler itself, but is provided
--   as a convenient entry point for users of the GHC API.
cseOneExpr :: InExpr -> OutExpr


-- | Arity and eta expansion
module GHC.Core.Opt.Arity

-- | manifestArity sees how many leading value lambdas there are, after
--   looking through casts
manifestArity :: CoreExpr -> Arity
joinRhsArity :: CoreExpr -> JoinArity

-- | An approximate, even faster, version of <a>cheapArityType</a> Roughly
--   exprArity e = arityTypeArity (cheapArityType e) But it's a bit less
--   clever about bottoms
--   
--   We do <i>not</i> guarantee that exprArity e &lt;= typeArity e You may
--   need to do arity trimming after calling exprArity See Note [Arity
--   trimming] Reason: if we do arity trimming here we have take exprType
--   and that can be expensive if there is a large cast
exprArity :: CoreExpr -> Arity
findRhsArity :: ArityOpts -> RecFlag -> Id -> CoreExpr -> (Bool, SafeArityType)
cheapArityType :: HasDebugCallStack => CoreExpr -> ArityType
data ArityOpts
ArityOpts :: !Bool -> !Bool -> ArityOpts
[ao_ped_bot] :: ArityOpts -> !Bool
[ao_dicts_cheap] :: ArityOpts -> !Bool

-- | The Arity returned is the number of value args the expression can be
--   applied to without doing much work
exprEtaExpandArity :: HasDebugCallStack => ArityOpts -> CoreExpr -> Maybe SafeArityType

-- | <tt>etaExpand n e</tt> returns an expression with the same meaning as
--   <tt>e</tt>, but with arity <tt>n</tt>.
--   
--   Given:
--   
--   <pre>
--   e' = etaExpand n e
--   </pre>
--   
--   We should have that:
--   
--   <pre>
--   ty = exprType e = exprType e'
--   </pre>
etaExpand :: Arity -> CoreExpr -> CoreExpr
etaExpandAT :: InScopeSet -> SafeArityType -> CoreExpr -> CoreExpr

-- | `tryEtaReduce [x,y,z] e sd` returns `Just e'` if `x y z -&gt; e` is
--   evaluated according to <tt>sd</tt> and can soundly and gainfully be
--   eta-reduced to <tt>e'</tt>. See Note [Eta reduction soundness] and
--   Note [Eta reduction makes sense] when that is the case.
tryEtaReduce :: UnVarSet -> [Var] -> CoreExpr -> SubDemand -> Maybe CoreExpr

-- | The analysis lattice of arity analysis. It is isomorphic to
--   
--   <pre>
--   data ArityType'
--     = AEnd Divergence
--     | ALam OneShotInfo ArityType'
--   </pre>
--   
--   Which is easier to display the Hasse diagram for:
--   
--   <pre>
--   ALam OneShotLam at
--           |
--       AEnd topDiv
--           |
--   ALam NoOneShotInfo at
--           |
--       AEnd exnDiv
--           |
--       AEnd botDiv
--   </pre>
--   
--   where the <tt>at</tt> fields of <tt>ALam</tt> are inductively subject
--   to the same order. That is, <tt>ALam os at1 &lt; ALam os at2</tt> iff
--   <tt>at1 &lt; at2</tt>.
--   
--   Why the strange Top element? See Note [Combining case branches:
--   optimistic one-shot-ness]
--   
--   We rely on this lattice structure for fixed-point iteration in
--   <a>findRhsArity</a>. For the semantics of <a>ArityType</a>, see Note
--   [ArityType].
data ArityType
mkBotArityType :: [OneShotInfo] -> ArityType

-- | The number of value args for the arity type
arityTypeArity :: SafeArityType -> Arity
idArityType :: Id -> ArityType
exprIsDeadEnd :: CoreExpr -> Bool
exprBotStrictness_maybe :: CoreExpr -> Maybe (Arity, DmdSig, CprSig)
arityTypeBotSigs_maybe :: ArityType -> Maybe (Arity, DmdSig, CprSig)

-- | (typeArity ty) says how many arrows GHC can expose in <tt>ty</tt>,
--   after looking through newtypes. More generally, (typeOneShots ty)
--   returns ty's [OneShotInfo], based only on the type itself, using
--   typeOneShot on the argument type to access the "state hack".
typeArity :: Type -> Arity
typeOneShots :: Type -> [OneShotInfo]
typeOneShot :: Type -> OneShotInfo

-- | Returns whether the lambda associated with the <a>Id</a> is certainly
--   applied at most once This one is the "business end", called
--   externally. It works on type variables as well as Ids, returning True
--   Its main purpose is to encapsulate the Horrible State Hack See Note
--   [The state-transformer hack] in <a>GHC.Core.Opt.Arity</a>
isOneShotBndr :: Var -> Bool
isStateHackType :: Type -> Bool
zapLamBndrs :: FullArgCount -> [Var] -> [Var]

-- | Split an expression into the given number of binders and a body,
--   eta-expanding if necessary. Counts value *and* type binders.
etaExpandToJoinPoint :: JoinArity -> CoreExpr -> ([CoreBndr], CoreExpr)
etaExpandToJoinPointRule :: JoinArity -> CoreRule -> CoreRule
pushCoArg :: CoercionR -> CoreArg -> Maybe (CoreArg, MCoercion)
pushCoArgs :: CoercionR -> [CoreArg] -> Maybe ([CoreArg], MCoercion)

-- | If <tt>pushCoValArg co = Just (co_arg, co_res)</tt>, then
--   
--   <pre>
--   (\x.body) |&gt; co  =  (\y. let { x = y |&gt; co_arg } in body) |&gt; co_res)
--   </pre>
--   
--   or, equivalently
--   
--   <pre>
--   (fun |&gt; co) arg  =  (fun (arg |&gt; co_arg)) |&gt; co_res
--   </pre>
--   
--   If the LHS is well-typed, then so is the RHS. In particular, the
--   argument <tt>arg |&gt; co_arg</tt> is guaranteed to have a fixed
--   <tt>RuntimeRep</tt>, in the sense of Note [Fixed RuntimeRep] in
--   GHC.Tc.Utils.Concrete.
pushCoValArg :: CoercionR -> Maybe (MCoercionR, MCoercionR)
pushCoTyArg :: CoercionR -> Type -> Maybe (Type, MCoercionR)
pushCoercionIntoLambda :: HasDebugCallStack => InScopeSet -> Var -> CoreExpr -> CoercionR -> Maybe (Var, CoreExpr)
pushCoDataCon :: DataCon -> [CoreExpr] -> MCoercion -> Maybe (DataCon, [Type], [CoreExpr])
collectBindersPushingCo :: CoreExpr -> ([Var], CoreExpr)
instance GHC.Classes.Eq GHC.Core.Opt.Arity.ArityType
instance GHC.Classes.Eq GHC.Core.Opt.Arity.Cost
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Arity.ArityEnv
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Arity.ArityType
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Arity.EtaInfo


module GHC.StgToJS.Expr

-- | Evaluate an expression in the given expression context (continuation)
genExpr :: HasDebugCallStack => ExprCtx -> CgStgExpr -> G (JStgStat, ExprResult)

-- | Generate the entry function types for identifiers. Note that this only
--   returns either <a>CIThunk</a> or <a>CIFun</a>.
genEntryType :: HasDebugCallStack => [Id] -> G CIType

-- | Given a set of <a>Id</a>s, bind each <a>Id</a> to the appropriate data
--   fields in N registers. This assumes these data fields have already
--   been populated in the registers. For the empty, singleton, and binary
--   case use register 1, for any more use as many registers as necessary.
loadLiveFun :: [Id] -> G JStgStat
genStaticRefsRhs :: CgStgRhs -> G CIStatic
genStaticRefs :: LiveVars -> G CIStatic

-- | Generate the body of an object
genBody :: HasDebugCallStack => ExprCtx -> StgReg -> [Id] -> CgStgExpr -> Type -> G JStgStat
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.StgToJS.Expr.Branch a)
instance GHC.Internal.Base.Functor GHC.StgToJS.Expr.Branch

module GHC.Core.Opt.OccurAnal
occurAnalysePgm :: Module -> (Id -> Bool) -> (Activation -> Bool) -> [CoreRule] -> CoreProgram -> CoreProgram

-- | Do occurrence analysis, and discard occurrence info returned
occurAnalyseExpr :: CoreExpr -> CoreExpr
zapLambdaBndrs :: CoreExpr -> FullArgCount -> CoreExpr

-- | See bBinderSwaOk.
data BinderSwapDecision
NoBinderSwap :: BinderSwapDecision
DoBinderSwap :: OutVar -> MCoercion -> BinderSwapDecision
scrutOkForBinderSwap :: OutExpr -> BinderSwapDecision
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.OccurAnal.LocalOcc
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.OccurAnal.NodeDetails
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.OccurAnal.OccEncl
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.OccurAnal.SimpleNodeDetails
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.OccurAnal.TailUsageDetails
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.OccurAnal.UsageDetails

module GHC.Core.Opt.CallArity
callArityAnalProgram :: CoreProgram -> CoreProgram
callArityRHS :: CoreExpr -> CoreExpr


-- | Handy functions for creating much Core syntax
module GHC.Core.Make

-- | Bind a binding group over an expression, using a <tt>let</tt> or
--   <tt>case</tt> as appropriate (see
--   <a>GHC.Core#let_can_float_invariant</a>)
mkCoreLet :: CoreBind -> CoreExpr -> CoreExpr

-- | Bind a list of binding groups over an expression. The leftmost binding
--   group becomes the outermost group in the resulting expression
mkCoreLets :: [CoreBind] -> CoreExpr -> CoreExpr

-- | Construct an expression which represents the application of one
--   expression to the other
mkCoreApp :: SDoc -> CoreExpr -> CoreExpr -> CoreExpr
infixl 4 `mkCoreApp`

-- | Construct an expression which represents the application of a number
--   of expressions to another. The leftmost expression in the list is
--   applied first
mkCoreApps :: CoreExpr -> [CoreExpr] -> CoreExpr
infixl 4 `mkCoreApps`

-- | Construct an expression which represents the application of a number
--   of expressions to that of a data constructor expression. The leftmost
--   expression in the list is applied first
mkCoreConApps :: DataCon -> [CoreExpr] -> CoreExpr

-- | Create a lambda where the given expression has a number of variables
--   bound over it. The leftmost binder is that bound by the outermost
--   lambda in the result
mkCoreLams :: [CoreBndr] -> CoreExpr -> CoreExpr

-- | Make a case expression whose case binder is unused The alts and res_ty
--   should not have any occurrences of WildId
mkWildCase :: CoreExpr -> Scaled Type -> Type -> [CoreAlt] -> CoreExpr
mkIfThenElse :: CoreExpr -> CoreExpr -> CoreExpr -> CoreExpr

-- | Make a <i>wildcard binder</i>. This is typically used when you need a
--   binder that you expect to use only at a *binding* site. Do not use it
--   at occurrence sites because it has a single, fixed unique, and it's
--   very easy to get into difficulties with shadowing. That's why it is
--   used so little.
--   
--   See Note [WildCard binders] in <a>GHC.Core.Opt.Simplify.Env</a>
mkWildValBinder :: Mult -> Type -> Id
mkSingleAltCase :: CoreExpr -> Id -> AltCon -> [Var] -> CoreExpr -> CoreExpr

-- | Sort the variables, putting type and covars first, in scoped order,
--   and then other Ids
--   
--   It is a deterministic sort, meaning it doesn't look at the values of
--   Uniques. For explanation why it's important See Note [Unique
--   Determinism] in GHC.Types.Unique.
sortQuantVars :: [Var] -> [Var]
castBottomExpr :: CoreExpr -> Type -> CoreExpr
mkLitRubbish :: Type -> Maybe CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to a <tt>Word</tt> with
--   the given value
mkWordExpr :: Platform -> Integer -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given <tt>Int</tt>
mkIntExpr :: Platform -> Integer -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given <tt>Int</tt>
mkIntExprInt :: Platform -> Int -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Int</tt>. Don't check that the number is in the range of the
--   target platform <tt>Int</tt>
mkUncheckedIntExpr :: Integer -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Integer</tt>
mkIntegerExpr :: Platform -> Integer -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Natural</tt>
mkNaturalExpr :: Platform -> Integer -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Float</tt>
mkFloatExpr :: Float -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Double</tt>
mkDoubleExpr :: Double -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Char</tt>
mkCharExpr :: Char -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>String</tt>
mkStringExpr :: MonadThings m => String -> m CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to a string morally
--   equivalent to the given <tt>FastString</tt>
mkStringExprFS :: MonadThings m => FastString -> m CoreExpr
mkStringExprFSWith :: MkStringIds -> FastString -> CoreExpr
data MkStringIds
MkStringIds :: !Id -> !Id -> MkStringIds
[unpackCStringId] :: MkStringIds -> !Id
[unpackCStringUtf8Id] :: MkStringIds -> !Id
getMkStringIds :: Applicative m => (Name -> m Id) -> m MkStringIds
data FloatBind
FloatLet :: CoreBind -> FloatBind
FloatCase :: CoreExpr -> Id -> AltCon -> [Var] -> FloatBind
wrapFloat :: FloatBind -> CoreExpr -> CoreExpr

-- | Applies the floats from right to left. That is <tt>wrapFloats [b1, b2,
--   …, bn] u = let b1 in let b2 in … in let bn in u</tt>
wrapFloats :: [FloatBind] -> CoreExpr -> CoreExpr
floatBindings :: FloatBind -> [Var]

-- | Build the type of a small tuple that holds the specified variables
--   One-tuples are flattened; see Note [Flattening one-tuples]
mkCoreVarTupTy :: [Id] -> Type

-- | Build a small tuple holding the specified expressions One-tuples are
--   flattened; see Note [Flattening one-tuples]
mkCoreTup :: [CoreExpr] -> CoreExpr

-- | Build a small unboxed tuple holding the specified expressions. Do not
--   include the RuntimeRep specifiers; this function calculates them for
--   you. Does <i>not</i> flatten one-tuples; see Note [Flattening
--   one-tuples]
mkCoreUnboxedTuple :: [CoreExpr] -> CoreExpr

-- | Build an unboxed sum.
--   
--   Alternative number ("alt") starts from 1.
mkCoreUnboxedSum :: Int -> Int -> [Type] -> CoreExpr -> CoreExpr

-- | Make a core tuple of the given boxity; don't flatten 1-tuples
mkCoreTupBoxity :: Boxity -> [CoreExpr] -> CoreExpr

-- | The unit expression
unitExpr :: CoreExpr

-- | Lifts a "small" constructor into a "big" constructor by recursive
--   decomposition
mkChunkified :: ([a] -> a) -> [a] -> a

-- | Split a list into lists that are small enough to have a corresponding
--   tuple arity. The sub-lists of the result all have length &lt;=
--   <a>mAX_TUPLE_SIZE</a> But there may be more than <a>mAX_TUPLE_SIZE</a>
--   sub-lists
chunkify :: [a] -> [[a]]

-- | Build a big tuple holding the specified variables One-tuples are
--   flattened; see Note [Flattening one-tuples] Arguments don't have to
--   have kind Type
mkBigCoreVarTup :: [Id] -> CoreExpr
mkBigCoreVarTupSolo :: [Id] -> CoreExpr

-- | Build the type of a big tuple that holds the specified variables
--   One-tuples are flattened; see Note [Flattening one-tuples]
mkBigCoreVarTupTy :: HasDebugCallStack => [Id] -> Type

-- | Build the type of a big tuple that holds the specified type of thing
--   One-tuples are flattened; see Note [Flattening one-tuples]
mkBigCoreTupTy :: HasDebugCallStack => [Type] -> Type

-- | Build a "big" tuple holding the specified expressions One-tuples are
--   flattened; see Note [Flattening one-tuples] Arguments don't have to
--   have kind Type; ones that do not are boxed This function crashes (in
--   wrapBox) if given a non-Type argument that it doesn't know how to box.
mkBigCoreTup :: [CoreExpr] -> CoreExpr

-- | Builds a selector which scrutinises the given expression and extracts
--   the one name from the list given. If you want the no-shadowing rule to
--   apply, the caller is responsible for making sure that none of these
--   names are in scope.
--   
--   If there is just one <a>Id</a> in the tuple, then the selector is just
--   the identity.
--   
--   If necessary, we pattern match on a "big" tuple.
--   
--   A tuple selector is not linear in its argument. Consequently, the case
--   expression built by <a>mkBigTupleSelector</a> must consume its
--   scrutinee <tt>Many</tt> times. And all the argument variables must
--   have multiplicity <tt>Many</tt>.
--   
--   <a>mkBigTupleSelectorSolo</a> is like <a>mkBigTupleSelector</a> but
--   one-tuples are NOT flattened (see Note [Flattening one-tuples])
mkBigTupleSelector :: [Id] -> Id -> Id -> CoreExpr -> CoreExpr

-- | Builds a selector which scrutinises the given expression and extracts
--   the one name from the list given. If you want the no-shadowing rule to
--   apply, the caller is responsible for making sure that none of these
--   names are in scope.
--   
--   If there is just one <a>Id</a> in the tuple, then the selector is just
--   the identity.
--   
--   If necessary, we pattern match on a "big" tuple.
--   
--   A tuple selector is not linear in its argument. Consequently, the case
--   expression built by <a>mkBigTupleSelector</a> must consume its
--   scrutinee <tt>Many</tt> times. And all the argument variables must
--   have multiplicity <tt>Many</tt>.
mkBigTupleSelectorSolo :: [Id] -> Id -> Id -> CoreExpr -> CoreExpr

-- | A generalization of <a>mkBigTupleSelector</a>, allowing the body of
--   the case to be an arbitrary expression.
--   
--   To avoid shadowing, we use uniques to invent new variables.
--   
--   If necessary we pattern match on a "big" tuple.
mkBigTupleCase :: MonadUnique m => [Id] -> CoreExpr -> CoreExpr -> m CoreExpr

-- | Makes a list <tt>[]</tt> for lists of the specified type
mkNilExpr :: Type -> CoreExpr

-- | Makes a list <tt>(:)</tt> for lists of the specified type
mkConsExpr :: Type -> CoreExpr -> CoreExpr -> CoreExpr

-- | Make a list containing the given expressions, where the list has the
--   given type
mkListExpr :: Type -> [CoreExpr] -> CoreExpr

-- | Make a fully applied <a>foldr</a> expression
mkFoldrExpr :: MonadThings m => Type -> Type -> CoreExpr -> CoreExpr -> CoreExpr -> m CoreExpr

-- | Make a <tt>build</tt> expression applied to a locally-bound worker
--   function
mkBuildExpr :: (MonadFail m, MonadThings m, MonadUnique m) => Type -> ((Id, Type) -> (Id, Type) -> m CoreExpr) -> m CoreExpr

-- | Makes a Nothing for the specified type
mkNothingExpr :: Type -> CoreExpr

-- | Makes a Just from a value of the specified type
mkJustExpr :: Type -> CoreExpr -> CoreExpr
mkRuntimeErrorApp :: Id -> Type -> String -> CoreExpr
mkImpossibleExpr :: Type -> String -> CoreExpr
mkAbsentErrorApp :: Type -> String -> CoreExpr
errorIds :: [Id]
rEC_CON_ERROR_ID :: Id
nON_EXHAUSTIVE_GUARDS_ERROR_ID :: Id
nO_METHOD_BINDING_ERROR_ID :: Id
pAT_ERROR_ID :: Id
rEC_SEL_ERROR_ID :: Id
tYPE_ERROR_ID :: Id
aBSENT_SUM_FIELD_ERROR_ID :: Id
instance GHC.Utils.Outputable.Outputable GHC.Core.Make.FloatBind


-- | Here we collect a variety of helper functions that construct or
--   analyse HsSyn. All these functions deal with generic HsSyn; functions
--   which deal with the instantiated versions are located elsewhere:
--   
--   Parameterised by Module ---------------- ------------- GhcPs/RdrName
--   GHC.Parser.PostProcess GhcRn/Name GHC.Rename.* GhcTc/Id
--   GHC.Tc.Zonk.Type
--   
--   The <tt>mk*</tt> functions attempt to construct a
--   not-completely-useless SrcSpan from their components, compared with
--   the <tt>nl*</tt> functions which just attach noSrcSpan to everything.
module GHC.Hs.Utils

-- | <pre>
--   e =&gt; (e)
--   </pre>
mkHsPar :: forall (p :: Pass). IsPass p => LHsExpr (GhcPass p) -> LHsExpr (GhcPass p)
mkHsApp :: forall (id :: Pass). LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
mkHsAppWith :: forall (id :: Pass). (LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> HsExpr (GhcPass id) -> LHsExpr (GhcPass id)) -> LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
mkHsApps :: forall (id :: Pass). LHsExpr (GhcPass id) -> [LHsExpr (GhcPass id)] -> LHsExpr (GhcPass id)
mkHsAppsWith :: forall (id :: Pass). (LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> HsExpr (GhcPass id) -> LHsExpr (GhcPass id)) -> LHsExpr (GhcPass id) -> [LHsExpr (GhcPass id)] -> LHsExpr (GhcPass id)
mkHsSyntaxApps :: SrcSpanAnnA -> SyntaxExprTc -> [LHsExpr GhcTc] -> LHsExpr GhcTc
mkHsAppType :: LHsExpr GhcRn -> LHsWcType GhcRn -> LHsExpr GhcRn
mkHsAppTypes :: LHsExpr GhcRn -> [LHsWcType GhcRn] -> LHsExpr GhcRn

-- | A simple case alternative with a single pattern, no binds, no guards;
--   pre-typechecking
mkHsCaseAlt :: forall (p :: Pass) body. (Anno (GRHS (GhcPass p) (LocatedA (body (GhcPass p)))) ~ EpAnn NoEpAnns, Anno (Match (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcSpanAnnA) => LPat (GhcPass p) -> LocatedA (body (GhcPass p)) -> LMatch (GhcPass p) (LocatedA (body (GhcPass p)))
mkSimpleMatch :: forall (p :: Pass) body. (Anno (Match (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcSpanAnnA, Anno (GRHS (GhcPass p) (LocatedA (body (GhcPass p)))) ~ EpAnn NoEpAnns) => HsMatchContext (LIdP (NoGhcTc (GhcPass p))) -> LocatedE [LPat (GhcPass p)] -> LocatedA (body (GhcPass p)) -> LMatch (GhcPass p) (LocatedA (body (GhcPass p)))
unguardedGRHSs :: forall (p :: Pass) body. Anno (GRHS (GhcPass p) (LocatedA (body (GhcPass p)))) ~ EpAnn NoEpAnns => SrcSpan -> LocatedA (body (GhcPass p)) -> EpAnn GrhsAnn -> GRHSs (GhcPass p) (LocatedA (body (GhcPass p)))
unguardedRHS :: forall (p :: Pass) body. Anno (GRHS (GhcPass p) (LocatedA (body (GhcPass p)))) ~ EpAnn NoEpAnns => EpAnn GrhsAnn -> SrcSpan -> LocatedA (body (GhcPass p)) -> [LGRHS (GhcPass p) (LocatedA (body (GhcPass p)))]
mkMatchGroup :: forall (p :: Pass) body. AnnoBody p body => Origin -> LocatedLW [LocatedA (Match (GhcPass p) (LocatedA (body (GhcPass p))))] -> MatchGroup (GhcPass p) (LocatedA (body (GhcPass p)))
mkLamCaseMatchGroup :: forall (p :: Pass) body. AnnoBody p body => Origin -> HsLamVariant -> LocatedLW [LocatedA (Match (GhcPass p) (LocatedA (body (GhcPass p))))] -> MatchGroup (GhcPass p) (LocatedA (body (GhcPass p)))
mkMatch :: forall (p :: Pass). IsPass p => HsMatchContext (LIdP (NoGhcTc (GhcPass p))) -> LocatedE [LPat (GhcPass p)] -> LHsExpr (GhcPass p) -> HsLocalBinds (GhcPass p) -> LMatch (GhcPass p) (LHsExpr (GhcPass p))

-- | Make a prefix, non-strict function <a>HsMatchContext</a>
mkPrefixFunRhs :: fn -> AnnFunRhs -> HsMatchContext fn
mkHsLam :: forall (p :: Pass). (IsPass p, XMG (GhcPass p) (LHsExpr (GhcPass p)) ~ Origin) => LocatedE [LPat (GhcPass p)] -> LHsExpr (GhcPass p) -> LHsExpr (GhcPass p)
mkHsIf :: LHsExpr GhcPs -> LHsExpr GhcPs -> LHsExpr GhcPs -> AnnsIf -> HsExpr GhcPs
mkHsWrap :: HsWrapper -> HsExpr GhcTc -> HsExpr GhcTc
mkLHsWrap :: HsWrapper -> LHsExpr GhcTc -> LHsExpr GhcTc
mkHsWrapCo :: TcCoercionN -> HsExpr GhcTc -> HsExpr GhcTc
mkHsWrapCoR :: TcCoercionR -> HsExpr GhcTc -> HsExpr GhcTc
mkLHsWrapCo :: TcCoercionN -> LHsExpr GhcTc -> LHsExpr GhcTc
mkHsDictLet :: TcEvBinds -> LHsExpr GhcTc -> LHsExpr GhcTc
mkHsLams :: [TyVar] -> [EvVar] -> LHsExpr GhcTc -> LHsExpr GhcTc

-- | A useful function for building <tt>OpApps</tt>. The operator is always
--   a variable, and we don't know the fixity yet.
mkHsOpApp :: LHsExpr GhcPs -> IdP GhcPs -> LHsExpr GhcPs -> HsExpr GhcPs
mkHsDo :: HsDoFlavour -> LocatedLW [ExprLStmt GhcPs] -> HsExpr GhcPs
mkHsDoAnns :: HsDoFlavour -> LocatedLW [ExprLStmt GhcPs] -> AnnList EpaLocation -> HsExpr GhcPs
mkHsComp :: HsDoFlavour -> [ExprLStmt GhcPs] -> LHsExpr GhcPs -> HsExpr GhcPs
mkHsCompAnns :: HsDoFlavour -> [ExprLStmt GhcPs] -> LHsExpr GhcPs -> AnnList EpaLocation -> HsExpr GhcPs
mkHsWrapPat :: HsWrapper -> Pat GhcTc -> Type -> Pat GhcTc
mkLHsWrapPat :: HsWrapper -> LPat GhcTc -> Type -> LPat GhcTc
mkHsWrapPatCo :: TcCoercionN -> Pat GhcTc -> Type -> Pat GhcTc

-- | Wrap in parens if <tt><a>hsExprNeedsParens</a> appPrec</tt> says it
--   needs them So <tt>f x</tt> becomes <tt>(f x)</tt>, but <tt>3</tt>
--   stays as <tt>3</tt>.
mkLHsPar :: forall (id :: Pass). IsPass id => LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
mkHsCmdWrap :: HsWrapper -> HsCmd GhcTc -> HsCmd GhcTc
mkLHsCmdWrap :: HsWrapper -> LHsCmd GhcTc -> LHsCmd GhcTc
mkHsCmdIf :: LHsExpr GhcPs -> LHsCmd GhcPs -> LHsCmd GhcPs -> AnnsIf -> HsCmd GhcPs
mkConLikeTc :: ConLike -> HsExpr GhcTc
nlHsTyApp :: Id -> [Type] -> LHsExpr GhcTc
nlHsTyApps :: Id -> [Type] -> [LHsExpr GhcTc] -> LHsExpr GhcTc
nlHsVar :: forall (p :: Pass) a. IsSrcSpanAnn p a => IdP (GhcPass p) -> LHsExpr (GhcPass p)
nl_HsVar :: forall (p :: Pass) a. IsSrcSpanAnn p a => IdP (GhcPass p) -> HsExpr (GhcPass p)

-- | NB: Only for <a>LHsExpr</a> <a>Id</a>.
nlHsDataCon :: DataCon -> LHsExpr GhcTc
nlHsLit :: forall (p :: Pass). HsLit (GhcPass p) -> LHsExpr (GhcPass p)
nlHsApp :: forall (id :: Pass). IsPass id => LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
nlHsApps :: forall (p :: Pass) a. IsSrcSpanAnn p a => IdP (GhcPass p) -> [LHsExpr (GhcPass p)] -> LHsExpr (GhcPass p)
nlHsSyntaxApps :: SyntaxExprTc -> [LHsExpr GhcTc] -> LHsExpr GhcTc
nlHsIntLit :: forall (p :: Pass). Integer -> LHsExpr (GhcPass p)
nlHsVarApps :: forall (p :: Pass) a. IsSrcSpanAnn p a => IdP (GhcPass p) -> [IdP (GhcPass p)] -> LHsExpr (GhcPass p)
nlHsDo :: HsDoFlavour -> [LStmt GhcPs (LHsExpr GhcPs)] -> LHsExpr GhcPs
nlHsOpApp :: LHsExpr GhcPs -> IdP GhcPs -> LHsExpr GhcPs -> LHsExpr GhcPs
nlHsLam :: LMatch GhcPs (LHsExpr GhcPs) -> LHsExpr GhcPs
nlHsPar :: forall (p :: Pass). IsPass p => LHsExpr (GhcPass p) -> LHsExpr (GhcPass p)
nlHsIf :: LHsExpr GhcPs -> LHsExpr GhcPs -> LHsExpr GhcPs -> LHsExpr GhcPs
nlHsCase :: LHsExpr GhcPs -> [LMatch GhcPs (LHsExpr GhcPs)] -> LHsExpr GhcPs
nlList :: [LHsExpr GhcPs] -> LHsExpr GhcPs
mkLHsTupleExpr :: forall (p :: Pass). [LHsExpr (GhcPass p)] -> XExplicitTuple (GhcPass p) -> LHsExpr (GhcPass p)
mkLHsVarTuple :: forall (p :: Pass) a. IsSrcSpanAnn p a => [IdP (GhcPass p)] -> XExplicitTuple (GhcPass p) -> LHsExpr (GhcPass p)
missingTupArg :: EpAnn Bool -> HsTupArg GhcPs
mkLocatedList :: (Semigroup a, NoAnn an) => [GenLocated (EpAnn a) e2] -> LocatedAn an [GenLocated (EpAnn a) e2]

-- | Type ascription: (e :: ty)
nlAscribe :: RdrName -> LHsExpr GhcPs -> LHsExpr GhcPs

-- | Not infix, with place holders for coercion and free vars
mkFunBind :: Origin -> LocatedN RdrName -> [LMatch GhcPs (LHsExpr GhcPs)] -> HsBind GhcPs
mkVarBind :: IdP GhcTc -> LHsExpr GhcTc -> LHsBind GhcTc
mkHsVarBind :: SrcSpan -> RdrName -> LHsExpr GhcPs -> LHsBind GhcPs

-- | Convenience function using <a>mkFunBind</a>. This is for generated
--   bindings only, do not use for user-written code.
mkSimpleGeneratedFunBind :: SrcSpan -> RdrName -> LocatedE [LPat GhcPs] -> LHsExpr GhcPs -> LHsBind GhcPs

-- | In Name-land, with empty bind_fvs
mkTopFunBind :: Origin -> LocatedN Name -> [LMatch GhcRn (LHsExpr GhcRn)] -> HsBind GhcRn
mkPatSynBind :: LocatedN RdrName -> HsPatSynDetails GhcPs -> LPat GhcPs -> HsPatSynDir GhcPs -> AnnPSB -> HsBind GhcPs

-- | If any of the matches in the <a>FunBind</a> are infix, the
--   <a>FunBind</a> is considered infix.
isInfixFunBind :: forall id1 id2. UnXRec id2 => HsBindLR id1 id2 -> Bool

-- | Return the <a>SrcSpan</a> encompassing the contents of any enclosed
--   binds
spanHsLocaLBinds :: forall (p :: Pass). HsLocalBinds (GhcPass p) -> SrcSpan
mkHsIntegral :: IntegralLit -> HsOverLit GhcPs
mkHsFractional :: FractionalLit -> HsOverLit GhcPs
mkHsIsString :: SourceText -> FastString -> HsOverLit GhcPs
mkHsString :: forall (p :: Pass). String -> HsLit (GhcPass p)
mkHsStringFS :: forall (p :: Pass). FastString -> HsLit (GhcPass p)
mkHsStringPrimLit :: forall (p :: Pass). FastString -> HsLit (GhcPass p)
mkHsCharPrimLit :: forall (p :: Pass). Char -> HsLit (GhcPass p)
mkNPat :: LocatedAn NoEpAnns (HsOverLit GhcPs) -> Maybe (SyntaxExpr GhcPs) -> EpToken "-" -> Pat GhcPs
mkNPlusKPat :: LocatedN RdrName -> LocatedAn NoEpAnns (HsOverLit GhcPs) -> EpToken "+" -> Pat GhcPs
nlVarPat :: forall (p :: Pass) a. IsSrcSpanAnn p a => IdP (GhcPass p) -> LPat (GhcPass p)
nlLitPat :: HsLit GhcPs -> LPat GhcPs
nlConVarPat :: RdrName -> [RdrName] -> LPat GhcPs
nlConVarPatName :: Name -> [Name] -> LPat GhcRn
nlConPat :: RdrName -> [LPat GhcPs] -> LPat GhcPs
nlConPatName :: Name -> [LPat GhcRn] -> LPat GhcRn
nlInfixConPat :: RdrName -> LPat GhcPs -> LPat GhcPs -> LPat GhcPs
nlNullaryConPat :: RdrName -> LPat GhcPs
nlWildConPat :: DataCon -> LPat GhcPs

-- | Wildcard pattern - after parsing
nlWildPat :: LPat GhcPs

-- | Wildcard pattern - after renaming
nlWildPatName :: LPat GhcRn
nlTuplePat :: [LPat GhcPs] -> Boxity -> LPat GhcPs
mkParPat :: forall (p :: Pass). IsPass p => LPat (GhcPass p) -> LPat (GhcPass p)
nlParPat :: forall (p :: Pass). IsPass p => LPat (GhcPass p) -> LPat (GhcPass p)

-- | The Big equivalents for the source tuple expressions
mkBigLHsVarTup :: forall (p :: Pass) a. IsSrcSpanAnn p a => [IdP (GhcPass p)] -> XExplicitTuple (GhcPass p) -> LHsExpr (GhcPass p)
mkBigLHsTup :: forall (id :: Pass). [LHsExpr (GhcPass id)] -> XExplicitTuple (GhcPass id) -> LHsExpr (GhcPass id)

-- | The Big equivalents for the source tuple patterns
mkBigLHsVarPatTup :: [IdP GhcRn] -> LPat GhcRn
mkBigLHsPatTup :: [LPat GhcRn] -> LPat GhcRn
mkHsAppTy :: forall (p :: Pass). LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)
mkHsAppKindTy :: forall (p :: Pass). XAppKindTy (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)

-- | Convert an <a>LHsType</a> to an <a>LHsSigType</a>.
hsTypeToHsSigType :: LHsType GhcPs -> LHsSigType GhcPs

-- | Convert an <a>LHsType</a> to an <a>LHsSigWcType</a>.
hsTypeToHsSigWcType :: LHsType GhcPs -> LHsSigWcType GhcPs

-- | Convert <a>TypeSig</a> to <a>ClassOpSig</a>. The former is what is
--   parsed, but the latter is what we need in class/instance declarations
mkClassOpSigs :: [LSig GhcPs] -> [LSig GhcPs]
mkHsSigEnv :: (LSig GhcRn -> Maybe ([LocatedN Name], a)) -> [LSig GhcRn] -> NameEnv a
nlHsAppTy :: forall (p :: Pass). LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)
nlHsAppKindTy :: forall (p :: Pass). IsPass p => LHsType (GhcPass p) -> LHsKind (GhcPass p) -> LHsType (GhcPass p)
nlHsTyVar :: forall (p :: Pass) a. IsSrcSpanAnn p a => PromotionFlag -> IdP (GhcPass p) -> LHsType (GhcPass p)
nlHsFunTy :: forall (p :: Pass). IsPass p => LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)
nlHsParTy :: forall (p :: Pass). LHsType (GhcPass p) -> LHsType (GhcPass p)
nlHsTyConApp :: forall (p :: Pass) a. IsSrcSpanAnn p a => PromotionFlag -> LexicalFixity -> IdP (GhcPass p) -> [LHsTypeArg (GhcPass p)] -> LHsType (GhcPass p)
mkTransformStmt :: AnnTransStmt -> [ExprLStmt GhcPs] -> LHsExpr GhcPs -> StmtLR GhcPs GhcPs (LHsExpr GhcPs)
mkTransformByStmt :: AnnTransStmt -> [ExprLStmt GhcPs] -> LHsExpr GhcPs -> LHsExpr GhcPs -> StmtLR GhcPs GhcPs (LHsExpr GhcPs)
mkBodyStmt :: forall bodyR (idL :: Pass). LocatedA (bodyR GhcPs) -> StmtLR (GhcPass idL) GhcPs (LocatedA (bodyR GhcPs))
mkPsBindStmt :: EpUniToken "<-" "\8592" -> LPat GhcPs -> LocatedA (bodyR GhcPs) -> StmtLR GhcPs GhcPs (LocatedA (bodyR GhcPs))
mkRnBindStmt :: LPat GhcRn -> LocatedA (bodyR GhcRn) -> StmtLR GhcRn GhcRn (LocatedA (bodyR GhcRn))
mkTcBindStmt :: LPat GhcTc -> LocatedA (bodyR GhcTc) -> StmtLR GhcTc GhcTc (LocatedA (bodyR GhcTc))
mkLastStmt :: forall (idR :: Pass) bodyR (idL :: Pass). IsPass idR => LocatedA (bodyR (GhcPass idR)) -> StmtLR (GhcPass idL) (GhcPass idR) (LocatedA (bodyR (GhcPass idR)))
emptyTransStmt :: AnnTransStmt -> StmtLR GhcPs GhcPs (LHsExpr GhcPs)
mkGroupUsingStmt :: AnnTransStmt -> [ExprLStmt GhcPs] -> LHsExpr GhcPs -> StmtLR GhcPs GhcPs (LHsExpr GhcPs)
mkGroupByUsingStmt :: AnnTransStmt -> [ExprLStmt GhcPs] -> LHsExpr GhcPs -> LHsExpr GhcPs -> StmtLR GhcPs GhcPs (LHsExpr GhcPs)
emptyRecStmt :: forall (idL :: Pass) bodyR. Anno [GenLocated (Anno (StmtLR (GhcPass idL) GhcPs bodyR)) (StmtLR (GhcPass idL) GhcPs bodyR)] ~ SrcSpanAnnLW => StmtLR (GhcPass idL) GhcPs bodyR
emptyRecStmtName :: Anno [GenLocated (Anno (StmtLR GhcRn GhcRn bodyR)) (StmtLR GhcRn GhcRn bodyR)] ~ SrcSpanAnnLW => StmtLR GhcRn GhcRn bodyR
emptyRecStmtId :: Stmt GhcTc (LocatedA (HsCmd GhcTc))
mkRecStmt :: forall (idL :: Pass) bodyR. Anno [GenLocated (Anno (StmtLR (GhcPass idL) GhcPs bodyR)) (StmtLR (GhcPass idL) GhcPs bodyR)] ~ SrcSpanAnnLW => AnnList (EpToken "rec") -> LocatedLW [LStmtLR (GhcPass idL) GhcPs bodyR] -> StmtLR (GhcPass idL) GhcPs bodyR
unitRecStmtTc :: RecStmtTc
mkLetStmt :: EpToken "let" -> HsLocalBinds GhcPs -> StmtLR GhcPs GhcPs (LocatedA b)

-- | Should we treat this as an unlifted bind? This will be true for any
--   bind that binds an unlifted variable, but we must be careful around
--   AbsBinds. See Note [isUnliftedHsBind]. For usage information, see Note
--   [Strict binds checks] is GHC.HsToCore.Binds.
isUnliftedHsBind :: HsBind GhcTc -> Bool
isUnliftedHsBinds :: LHsBinds GhcTc -> Bool

-- | Is a binding a strict variable or pattern bind (e.g. <tt>!x =
--   ...</tt>)?
isBangedHsBind :: HsBind GhcTc -> Bool
collectLocalBinders :: forall (idL :: Pass) (idR :: Pass). CollectPass (GhcPass idL) => CollectFlag (GhcPass idL) -> HsLocalBindsLR (GhcPass idL) (GhcPass idR) -> [IdP (GhcPass idL)]
collectHsValBinders :: forall (idL :: Pass) idR. CollectPass (GhcPass idL) => CollectFlag (GhcPass idL) -> HsValBindsLR (GhcPass idL) idR -> [IdP (GhcPass idL)]

-- | Same as <a>collectHsBindsBinders</a>, but works over a list of
--   bindings
collectHsBindListBinders :: CollectPass p => CollectFlag p -> [LHsBindLR p idR] -> [IdP p]

-- | Collect <a>Id</a> binders only, or <a>Id</a>s + pattern synonyms,
--   respectively
collectHsIdBinders :: forall (idL :: Pass) (idR :: Pass). CollectPass (GhcPass idL) => CollectFlag (GhcPass idL) -> HsValBindsLR (GhcPass idL) (GhcPass idR) -> [IdP (GhcPass idL)]
collectHsBindsBinders :: CollectPass p => CollectFlag p -> LHsBindsLR p idR -> [IdP p]

-- | Collect both <a>Id</a>s and pattern-synonym binders
collectHsBindBinders :: CollectPass p => CollectFlag p -> HsBindLR p idR -> [IdP p]

-- | Used exclusively for the bindings of an instance decl which are all
--   <tt>FunBinds</tt>
collectMethodBinders :: UnXRec idL => LHsBindsLR idL idR -> [LIdP idL]
collectPatBinders :: CollectPass p => CollectFlag p -> LPat p -> [IdP p]
collectPatsBinders :: CollectPass p => CollectFlag p -> [LPat p] -> [IdP p]
collectLStmtsBinders :: forall (idL :: Pass) (idR :: Pass) body. (IsPass idL, IsPass idR, CollectPass (GhcPass idL)) => CollectFlag (GhcPass idL) -> [LStmtLR (GhcPass idL) (GhcPass idR) body] -> [IdP (GhcPass idL)]
collectStmtsBinders :: forall (idL :: Pass) (idR :: Pass) body. (IsPass idL, IsPass idR, CollectPass (GhcPass idL)) => CollectFlag (GhcPass idL) -> [StmtLR (GhcPass idL) (GhcPass idR) body] -> [IdP (GhcPass idL)]
collectLStmtBinders :: forall (idL :: Pass) (idR :: Pass) body. (IsPass idL, IsPass idR, CollectPass (GhcPass idL)) => CollectFlag (GhcPass idL) -> LStmtLR (GhcPass idL) (GhcPass idR) body -> [IdP (GhcPass idL)]
collectStmtBinders :: forall (idL :: Pass) (idR :: Pass) body. (IsPass idL, IsPass idR, CollectPass (GhcPass idL)) => CollectFlag (GhcPass idL) -> StmtLR (GhcPass idL) (GhcPass idR) body -> [IdP (GhcPass idL)]

-- | This class specifies how to collect variable identifiers from
--   extension patterns in the given pass. Consumers of the GHC API that
--   define their own passes should feel free to implement instances in
--   order to make use of functions which depend on it.
--   
--   In particular, Haddock already makes use of this, with an instance for
--   its <tt>DocNameI</tt> pass so that it can reuse the code in GHC for
--   collecting binders.
class UnXRec p => CollectPass p
collectXXPat :: CollectPass p => CollectFlag p -> XXPat p -> [IdP p] -> [IdP p]
collectXXHsBindsLR :: CollectPass p => XXHsBindsLR p pR -> [IdP p] -> [IdP p]
collectXSplicePat :: CollectPass p => CollectFlag p -> XSplicePat p -> [IdP p] -> [IdP p]

-- | Indicate if evidence binders and type variable binders have to be
--   collected.
--   
--   This type enumerates the modes of collecting bound variables |
--   evidence | type | term | ghc | | binders | variables | variables |
--   pass | -------------------------------------------- CollNoDictBinders
--   | no | no | yes | any | CollWithDictBinders | yes | no | yes | GhcTc |
--   CollVarTyVarBinders | no | yes | yes | GhcRn |
--   
--   See Note [Dictionary binders in ConPatOut]
data CollectFlag p

-- | Don't collect evidence binders
[CollNoDictBinders] :: forall p. CollectFlag p

-- | Collect evidence binders
[CollWithDictBinders] :: CollectFlag (GhcPass 'Typechecked)

-- | Collect variable and type variable binders, but no evidence binders
[CollVarTyVarBinders] :: CollectFlag (GhcPass 'Renamed)
data TyDeclBinders (p :: Pass)
TyDeclBinders :: !(LocatedA (IdP (GhcPass p)), TyConFlavour ()) -> ![(LocatedA (IdP (GhcPass p)), TyConFlavour ())] -> ![LocatedA (IdP (GhcPass p))] -> !LConsWithFields p -> TyDeclBinders (p :: Pass)
[tyDeclMainBinder] :: TyDeclBinders (p :: Pass) -> !(LocatedA (IdP (GhcPass p)), TyConFlavour ())
[tyDeclATs] :: TyDeclBinders (p :: Pass) -> ![(LocatedA (IdP (GhcPass p)), TyConFlavour ())]
[tyDeclOpSigs] :: TyDeclBinders (p :: Pass) -> ![LocatedA (IdP (GhcPass p))]
[tyDeclConsWithFields] :: TyDeclBinders (p :: Pass) -> !LConsWithFields p

-- | A mapping from constructors to all of their fields.
--   
--   See Note [Collecting record fields in data declarations].
data LConsWithFields (p :: Pass)
LConsWithFields :: [(LocatedA (IdP (GhcPass p)), Maybe [Located Int])] -> IntMap (LFieldOcc (GhcPass p)) -> LConsWithFields (p :: Pass)
[consWithFieldIndices] :: LConsWithFields (p :: Pass) -> [(LocatedA (IdP (GhcPass p)), Maybe [Located Int])]
[consFields] :: LConsWithFields (p :: Pass) -> IntMap (LFieldOcc (GhcPass p))

-- | Returns all the <i>binding</i> names of the decl. The first one is
--   guaranteed to be the name of the decl. The first component represents
--   all binding names except record fields; the second represents field
--   occurrences. For record fields mentioned in multiple constructors, the
--   SrcLoc will be from the first occurrence.
--   
--   Each returned (Located name) has a SrcSpan for the <i>whole</i>
--   declaration. See Note [SrcSpan for binders]
hsLTyClDeclBinders :: forall (p :: Pass). (IsPass p, OutputableBndrId p) => LocatedA (TyClDecl (GhcPass p)) -> TyDeclBinders p
hsTyClForeignBinders :: [TyClGroup GhcRn] -> [LForeignDecl GhcRn] -> [Name]

-- | Collects record pattern-synonym selectors only; the pattern synonym
--   names are collected by <a>collectHsValBinders</a>.
hsPatSynSelectors :: forall (p :: Pass). IsPass p => HsValBinds (GhcPass p) -> [FieldOcc (GhcPass p)]
getPatSynBinds :: UnXRec id => [(RecFlag, LHsBinds id)] -> [PatSynBind id id]

-- | See Note [SrcSpan for binders]
hsForeignDeclsBinders :: forall (p :: Pass) a. (UnXRec (GhcPass p), IsSrcSpanAnn p a) => [LForeignDecl (GhcPass p)] -> [LIdP (GhcPass p)]
hsGroupBinders :: HsGroup GhcRn -> [Name]

-- | the <a>SrcLoc</a> returned are for the whole declarations, not just
--   the names
hsDataFamInstBinders :: forall (p :: Pass). (IsPass p, OutputableBndrId p) => DataFamInstDecl (GhcPass p) -> LConsWithFields p

-- | All binders corresponding to a single implicit record field pattern.
--   
--   See Note [Collecting implicit binders].
data ImplicitFieldBinders
ImplicitFieldBinders :: Name -> [Name] -> ImplicitFieldBinders

-- | The <a>Name</a> of the record field
[implFlBndr_field] :: ImplicitFieldBinders -> Name

-- | The binders of the RHS of the record field pattern (in practice,
--   always a singleton: see Note [Collecting implicit binders])
[implFlBndr_binders] :: ImplicitFieldBinders -> [Name]
lStmtsImplicits :: forall (idR :: Pass) (body :: Type -> Type). IsPass idR => [LStmtLR GhcRn (GhcPass idR) (LocatedA (body (GhcPass idR)))] -> [(SrcSpan, [ImplicitFieldBinders])]
hsValBindsImplicits :: forall (idR :: Pass). HsValBindsLR GhcRn (GhcPass idR) -> [(SrcSpan, [ImplicitFieldBinders])]

-- | Collect all record wild card binders in the given pattern.
--   
--   These are all the variables bound in all (possibly nested) record
--   wildcard patterns appearing inside the pattern.
--   
--   See Note [Collecting implicit binders].
lPatImplicits :: LPat GhcRn -> [(SrcSpan, [ImplicitFieldBinders])]
lHsRecFieldsImplicits :: [LHsRecField GhcRn (LPat GhcRn)] -> RecFieldsDotDot -> [ImplicitFieldBinders]
instance GHC.Hs.Extension.IsPass p => GHC.Hs.Utils.CollectPass (GHC.Hs.Extension.GhcPass p)

module GHC.Hs
data Fixity

-- | Haskell Module
--   
--   All we actually declare here is the top-level structure for a module.
data HsModule p
HsModule :: XCModule p -> Maybe (XRec p ModuleName) -> Maybe (XRec p [LIE p]) -> [LImportDecl p] -> [LHsDecl p] -> HsModule p

-- | HsModule extension point
[hsmodExt] :: HsModule p -> XCModule p

-- | <tt>Nothing</tt>: "module X where" is omitted (in which case the next
--   field is Nothing too)
[hsmodName] :: HsModule p -> Maybe (XRec p ModuleName)

-- | Export list
--   
--   <ul>
--   <li><tt>Nothing</tt>: export list omitted, so export everything</li>
--   <li><tt>Just []</tt>: export <i>nothing</i></li>
--   <li><tt>Just [...]</tt>: as you would expect...</li>
--   </ul>
[hsmodExports] :: HsModule p -> Maybe (XRec p [LIE p])
[hsmodImports] :: HsModule p -> [LImportDecl p]

-- | Type, class, value, and interface signature decls
[hsmodDecls] :: HsModule p -> [LHsDecl p]
XModule :: !XXModule p -> HsModule p
data AnnsModule
AnnsModule :: EpToken "signature" -> EpToken "module" -> EpToken "where" -> [TrailingAnn] -> [LEpaComment] -> Maybe (RealSrcSpan, RealSrcSpan) -> AnnsModule
[am_sig] :: AnnsModule -> EpToken "signature"
[am_mod] :: AnnsModule -> EpToken "module"
[am_where] :: AnnsModule -> EpToken "where"

-- | Semis before the start of top decls
[am_decls] :: AnnsModule -> [TrailingAnn]

-- | Comments before start of top decl, used in exact printing only
[am_cs] :: AnnsModule -> [LEpaComment]

-- | End of file and end of prior token
[am_eof] :: AnnsModule -> Maybe (RealSrcSpan, RealSrcSpan)
data HsParsedModule
HsParsedModule :: Located (HsModule GhcPs) -> [FilePath] -> HsParsedModule
[hpm_module] :: HsParsedModule -> Located (HsModule GhcPs)

-- | extra source files (e.g. from #includes). The lexer collects these
--   from '# <a>file</a> <a>line</a>' pragmas, which the C preprocessor
--   leaves behind. These files and their timestamps are stored in the .hi
--   file, so that we can force recompilation if any of them change (#3589)
[hpm_src_files] :: HsParsedModule -> [FilePath]

-- | Haskell Module extension point: GHC specific
data XModulePs
XModulePs :: EpAnn AnnsModule -> EpLayout -> Maybe (LWarningTxt GhcPs) -> Maybe (LHsDoc GhcPs) -> XModulePs
[hsmodAnn] :: XModulePs -> EpAnn AnnsModule

-- | Layout info for the module. For incomplete modules (e.g. the output of
--   parseHeader), it is EpNoLayout.
[hsmodLayout] :: XModulePs -> EpLayout

-- | reason/explanation for warning/deprecation of this module
[hsmodDeprecMessage] :: XModulePs -> Maybe (LWarningTxt GhcPs)

-- | Haddock module info and description, unparsed
[hsmodHaddockModHeader] :: XModulePs -> Maybe (LHsDoc GhcPs)
instance GHC.Internal.Data.Data.Data GHC.Hs.AnnsModule
instance GHC.Internal.Data.Data.Data (Language.Haskell.Syntax.HsModule GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Data.Data GHC.Hs.XModulePs
instance GHC.Classes.Eq GHC.Hs.AnnsModule
instance GHC.Parser.Annotation.NoAnn GHC.Hs.AnnsModule
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.HsModule GHC.Hs.Extension.GhcPs)


-- | Metaprogramming types
module GHC.Types.Meta

-- | The supported metaprogramming result types
data MetaRequest
MetaE :: (LHsExpr GhcPs -> MetaResult) -> MetaRequest
MetaP :: (LPat GhcPs -> MetaResult) -> MetaRequest
MetaT :: (LHsType GhcPs -> MetaResult) -> MetaRequest
MetaD :: ([LHsDecl GhcPs] -> MetaResult) -> MetaRequest
MetaAW :: (Serialized -> MetaResult) -> MetaRequest
type MetaHook (f :: Type -> Type) = MetaRequest -> LHsExpr GhcTc -> f MetaResult

-- | data constructors not exported to ensure correct result type
data MetaResult
metaRequestE :: Functor f => MetaHook f -> LHsExpr GhcTc -> f (LHsExpr GhcPs)
metaRequestP :: Functor f => MetaHook f -> LHsExpr GhcTc -> f (LPat GhcPs)
metaRequestT :: Functor f => MetaHook f -> LHsExpr GhcTc -> f (LHsType GhcPs)
metaRequestD :: Functor f => MetaHook f -> LHsExpr GhcTc -> f [LHsDecl GhcPs]
metaRequestAW :: Functor f => MetaHook f -> LHsExpr GhcTc -> f Serialized


-- | Describes the provenance of types as they flow through the
--   type-checker. The datatypes here are mainly used for error message
--   generation.
module GHC.Tc.Types.Origin

-- | UserTypeCtxt describes the origin of the polymorphic type in the
--   places where we need an expression to have that type
data UserTypeCtxt
FunSigCtxt :: Name -> ReportRedundantConstraints -> UserTypeCtxt
InfSigCtxt :: Name -> UserTypeCtxt
ExprSigCtxt :: ReportRedundantConstraints -> UserTypeCtxt
KindSigCtxt :: UserTypeCtxt
StandaloneKindSigCtxt :: Name -> UserTypeCtxt
TypeAppCtxt :: UserTypeCtxt
ConArgCtxt :: Name -> UserTypeCtxt
TySynCtxt :: Name -> UserTypeCtxt
PatSynCtxt :: Name -> UserTypeCtxt
PatSigCtxt :: UserTypeCtxt
RuleSigCtxt :: FastString -> Name -> UserTypeCtxt
ForSigCtxt :: Name -> UserTypeCtxt
DefaultDeclCtxt :: UserTypeCtxt
InstDeclCtxt :: Bool -> UserTypeCtxt
SpecInstCtxt :: UserTypeCtxt
GenSigCtxt :: UserTypeCtxt
GhciCtxt :: Bool -> UserTypeCtxt
ClassSCCtxt :: Name -> UserTypeCtxt
SigmaCtxt :: UserTypeCtxt
DataTyCtxt :: Name -> UserTypeCtxt
DerivClauseCtxt :: UserTypeCtxt
TyVarBndrKindCtxt :: Name -> UserTypeCtxt
DataKindCtxt :: Name -> UserTypeCtxt
TySynKindCtxt :: Name -> UserTypeCtxt
TyFamResKindCtxt :: Name -> UserTypeCtxt
pprUserTypeCtxt :: UserTypeCtxt -> SDoc
isSigMaybe :: UserTypeCtxt -> Maybe Name

-- | Report Redundant Constraints.
data ReportRedundantConstraints

-- | Don't report redundant constraints
NoRRC :: ReportRedundantConstraints

-- | Report redundant constraints The SrcSpan is for the constraints E.g. f
--   :: (Eq a, Ord b) =&gt; blah The span is for the (Eq a, Ord b) We need
--   to record the span here because we have long since discarded the
--   HsType in favour of a Type
WantRRC :: SrcSpan -> ReportRedundantConstraints
reportRedundantConstraints :: ReportRedundantConstraints -> Bool
redundantConstraintsSpan :: UserTypeCtxt -> SrcSpan

-- | <a>SkolemInfo</a> stores the origin of a skolem type variable, so that
--   we can display this information to the user in case of a type error.
--   
--   The <a>Unique</a> field allows us to report all skolem type variables
--   bound in the same place in a single report.
data SkolemInfo
SkolemInfo :: Unique -> SkolemInfoAnon -> SkolemInfo

-- | <a>SkolemInfoAnon</a> stores the origin of a skolem type variable
--   (e.g. bound by a user-written forall, the header of a data
--   declaration, a deriving clause, ...).
--   
--   This information is displayed when reporting an error message, such as
--   
--   <pre>
--   "Couldn't match <tt>k</tt> with <tt>l</tt>"
--   </pre>
--   
--   This allows us to explain where the type variable came from.
--   
--   When several skolem type variables are bound at once, prefer using
--   <a>SkolemInfo</a>, which stores a <a>Unique</a> which allows these
--   type variables to be reported
data SkolemInfoAnon
SigSkol :: UserTypeCtxt -> TcType -> [(Name, TcTyVar)] -> SkolemInfoAnon
SigTypeSkol :: UserTypeCtxt -> SkolemInfoAnon
ForAllSkol :: TyVarBndrs -> SkolemInfoAnon
DerivSkol :: Type -> SkolemInfoAnon
InstSkol :: ClsInstOrQC -> PatersonSize -> SkolemInfoAnon
FamInstSkol :: SkolemInfoAnon
PatSkol :: ConLike -> HsMatchContextRn -> SkolemInfoAnon
IPSkol :: [HsIPName] -> SkolemInfoAnon
RuleSkol :: RuleName -> SkolemInfoAnon
InferSkol :: [(Name, TcType)] -> SkolemInfoAnon
BracketSkol :: SkolemInfoAnon
UnifyForAllSkol :: TcType -> SkolemInfoAnon
TyConSkol :: TyConFlavour TyCon -> Name -> SkolemInfoAnon
DataConSkol :: Name -> SkolemInfoAnon
ReifySkol :: SkolemInfoAnon
RuntimeUnkSkol :: SkolemInfoAnon
ArrowReboundIfSkol :: SkolemInfoAnon
UnkSkol :: CallStack -> SkolemInfoAnon

-- | Wrap up the origin of a skolem type variable with a new <a>Unique</a>,
--   so that we can common up skolem type variables whose <a>SkolemInfo</a>
--   shares a certain <a>Unique</a>.
mkSkolemInfo :: MonadIO m => SkolemInfoAnon -> m SkolemInfo
getSkolemInfo :: SkolemInfo -> SkolemInfoAnon
pprSigSkolInfo :: UserTypeCtxt -> TcType -> SDoc
pprSkolInfo :: SkolemInfoAnon -> SDoc

-- | Use this when you can't specify a helpful origin for some skolem type
--   variable.
--   
--   We're hoping to be able to get rid of this entirely, but for the
--   moment it's still needed.
unkSkol :: HasDebugCallStack => SkolemInfo
unkSkolAnon :: HasDebugCallStack => SkolemInfoAnon
mkClsInstSkol :: Class -> [Type] -> SkolemInfoAnon
data CtOrigin

-- | A given constraint from a user-written type signature. The
--   <a>SkolemInfo</a> inside gives more information.
GivenOrigin :: SkolemInfoAnon -> CtOrigin

-- | <a>GivenSCOrigin</a> is used for a Given constraint obtained by
--   superclass selection from the context of an instance declaration. E.g.
--   instance <tt>(Foo a, Bar a) =&gt; C [a]</tt> where ... When
--   typechecking the instance decl itself, including producing evidence
--   for the superclasses of <tt>C</tt>, the superclasses of <tt>(Foo
--   a)</tt> and <tt>(Bar a)</tt> will have <a>GivenSCOrigin</a> origin.
GivenSCOrigin :: SkolemInfoAnon -> ScDepth -> Bool -> CtOrigin
OccurrenceOf :: Name -> CtOrigin
OccurrenceOfRecSel :: RdrName -> CtOrigin
AppOrigin :: CtOrigin
SpecPragOrigin :: UserTypeCtxt -> CtOrigin
TypeEqOrigin :: TcType -> TcType -> Maybe TypedThing -> Bool -> CtOrigin
[uo_actual] :: CtOrigin -> TcType
[uo_expected] :: CtOrigin -> TcType

-- | The thing that has type "actual"
[uo_thing] :: CtOrigin -> Maybe TypedThing

-- | Is at least one of the three elements above visible? (Errors from the
--   polymorphic subsumption check are considered visible.) Only used for
--   prioritizing error messages.
[uo_visible] :: CtOrigin -> Bool
KindEqOrigin :: TcType -> TcType -> CtOrigin -> Maybe TypeOrKind -> CtOrigin
IPOccOrigin :: HsIPName -> CtOrigin
OverLabelOrigin :: FastString -> CtOrigin
LiteralOrigin :: HsOverLit GhcRn -> CtOrigin
NegateOrigin :: CtOrigin
ArithSeqOrigin :: ArithSeqInfo GhcRn -> CtOrigin
AssocFamPatOrigin :: CtOrigin
SectionOrigin :: CtOrigin
HasFieldOrigin :: FastString -> CtOrigin
TupleOrigin :: CtOrigin
ExprSigOrigin :: CtOrigin
PatSigOrigin :: CtOrigin
PatOrigin :: CtOrigin
ProvCtxtOrigin :: PatSynBind GhcRn GhcRn -> CtOrigin
RecordUpdOrigin :: CtOrigin
ViewPatOrigin :: CtOrigin

-- | <a>ScOrigin</a> is used only for the Wanted constraints for the
--   superclasses of an instance declaration.
ScOrigin :: ClsInstOrQC -> NakedScFlag -> CtOrigin
DerivClauseOrigin :: CtOrigin
DerivOriginDC :: DataCon -> Int -> Bool -> CtOrigin
DerivOriginCoerce :: Id -> Type -> Type -> Bool -> CtOrigin
StandAloneDerivOrigin :: CtOrigin
DefaultOrigin :: CtOrigin
DoOrigin :: CtOrigin
DoPatOrigin :: LPat GhcRn -> CtOrigin
MCompOrigin :: CtOrigin
MCompPatOrigin :: LPat GhcRn -> CtOrigin
ProcOrigin :: CtOrigin
ArrowCmdOrigin :: CtOrigin
AnnOrigin :: CtOrigin
FunDepOrigin1 :: PredType -> CtOrigin -> RealSrcSpan -> PredType -> CtOrigin -> RealSrcSpan -> CtOrigin
FunDepOrigin2 :: PredType -> CtOrigin -> PredType -> SrcSpan -> CtOrigin
InjTFOrigin1 :: PredType -> CtOrigin -> RealSrcSpan -> PredType -> CtOrigin -> RealSrcSpan -> CtOrigin
ExprHoleOrigin :: Maybe RdrName -> CtOrigin
TypeHoleOrigin :: OccName -> CtOrigin
PatCheckOrigin :: CtOrigin
ListOrigin :: CtOrigin
IfThenElseOrigin :: CtOrigin
BracketOrigin :: CtOrigin
StaticOrigin :: CtOrigin
ImpedanceMatching :: Id -> CtOrigin
Shouldn'tHappenOrigin :: String -> CtOrigin

-- | Testing whether the constraint associated with an instance declaration
--   in a signature file is satisfied upon instantiation.
--   
--   Test cases: backpack<i>should_fail</i>bkpfail{11,43}.bkp
InstProvidedOrigin :: Module -> ClsInst -> CtOrigin
NonLinearPatternOrigin :: NonLinearPatternReason -> LPat GhcRn -> CtOrigin
OmittedFieldOrigin :: Maybe FieldLabel -> CtOrigin
UsageEnvironmentOf :: Name -> CtOrigin
CycleBreakerOrigin :: CtOrigin -> CtOrigin
FRROrigin :: FixedRuntimeRepOrigin -> CtOrigin
WantedSuperclassOrigin :: PredType -> CtOrigin -> CtOrigin
InstanceSigOrigin :: Name -> Type -> Type -> CtOrigin
AmbiguityCheckOrigin :: UserTypeCtxt -> CtOrigin
exprCtOrigin :: HsExpr GhcRn -> CtOrigin

-- | Extract a suitable CtOrigin from a HsExpr
lexprCtOrigin :: LHsExpr GhcRn -> CtOrigin

-- | Extract a suitable CtOrigin from a MatchGroup
matchesCtOrigin :: MatchGroup GhcRn (LHsExpr GhcRn) -> CtOrigin

-- | Extract a suitable CtOrigin from guarded RHSs
grhssCtOrigin :: GRHSs GhcRn (LHsExpr GhcRn) -> CtOrigin
isVisibleOrigin :: CtOrigin -> Bool
toInvisibleOrigin :: CtOrigin -> CtOrigin
pprCtOrigin :: CtOrigin -> SDoc
isGivenOrigin :: CtOrigin -> Bool
isWantedWantedFunDepOrigin :: CtOrigin -> Bool

-- | Did a constraint arise from expanding a Wanted constraint to look at
--   superclasses?
isWantedSuperclassOrigin :: CtOrigin -> Bool
data ClsInstOrQC
IsClsInst :: ClsInstOrQC
IsQC :: CtOrigin -> ClsInstOrQC
data NakedScFlag
NakedSc :: NakedScFlag
NotNakedSc :: NakedScFlag
data NonLinearPatternReason
LazyPatternReason :: NonLinearPatternReason
GeneralisedPatternReason :: NonLinearPatternReason
PatternSynonymReason :: NonLinearPatternReason
ViewPatternReason :: NonLinearPatternReason
OtherPatternReason :: NonLinearPatternReason

-- | Some thing which has a type.
--   
--   This datatype is used when we want to report to the user that
--   something has an unexpected type.
data TypedThing
HsTypeRnThing :: HsType GhcRn -> TypedThing
TypeThing :: Type -> TypedThing
HsExprRnThing :: HsExpr GhcRn -> TypedThing
HsExprTcThing :: HsExpr GhcTc -> TypedThing
NameThing :: Name -> TypedThing

-- | Some kind of type variable binder.
--   
--   Used for reporting errors, in <a>SkolemInfo</a> and
--   <tt>TcSolverReportMsg</tt>.
data TyVarBndrs
HsTyVarBndrsRn :: [HsTyVarBndr flag GhcRn] -> TyVarBndrs
isPushCallStackOrigin :: CtOrigin -> Bool
callStackOriginFS :: CtOrigin -> FastString

-- | The context for a representation-polymorphism check.
--   
--   For example, when typechecking <tt> (a :: k) -&gt; ...</tt>, we are
--   checking the type <tt>a</tt> because it's the type of a term variable
--   bound in a lambda, so we use <a>FRRBinder</a>.
data FixedRuntimeRepOrigin
FixedRuntimeRepOrigin :: Type -> FixedRuntimeRepContext -> FixedRuntimeRepOrigin

-- | What type are we checking? For example, <tt>a[tau]</tt> in <tt>a[tau]
--   :: TYPE rr[tau]</tt>.
[frr_type] :: FixedRuntimeRepOrigin -> Type

-- | What context requires a fixed runtime representation?
[frr_context] :: FixedRuntimeRepOrigin -> FixedRuntimeRepContext

-- | The context in which a representation-polymorphism check was
--   performed.
--   
--   Does not include the type on which the check was performed; see
--   <a>FixedRuntimeRepOrigin</a> for that.
data FixedRuntimeRepContext

-- | Record fields in record construction must have a fixed runtime
--   representation.
FRRRecordCon :: !RdrName -> !HsExpr GhcTc -> FixedRuntimeRepContext

-- | Record fields in record updates must have a fixed runtime
--   representation.
--   
--   Test case: RepPolyRecordUpdate.
FRRRecordUpdate :: !Name -> !HsExpr GhcRn -> FixedRuntimeRepContext

-- | Variable binders must have a fixed runtime representation.
--   
--   Test cases: LevPolyLet, RepPolyPatBind.
FRRBinder :: !Name -> FixedRuntimeRepContext

-- | Types appearing in negative position in the type of a
--   representation-polymorphic <a>Id</a> must have a fixed runtime
--   representation.
--   
--   This includes:
--   
--   <ul>
--   <li>arguments,</li>
--   </ul>
--   
--   Test cases: RepPolyMagic, RepPolyRightSection, RepPolyWrappedVar,
--   T14561b, T17817.
--   
--   <ul>
--   <li>continuation result types, such as in 'catch#', 'keepAlive#' and
--   'control0#'.</li>
--   </ul>
--   
--   Test case: T21906.
FRRRepPolyId :: !Name -> !RepPolyId -> !Position 'Neg -> FixedRuntimeRepContext

-- | A partial application of the constructor of a
--   representation-polymorphic unlifted newtype in which the argument type
--   does not have a fixed runtime representation.
--   
--   Test cases: UnliftedNewtypesLevityBinder, UnliftedNewtypesCoerceFail.
FRRRepPolyUnliftedNewtype :: !DataCon -> FixedRuntimeRepContext

-- | Pattern binds must have a fixed runtime representation.
--   
--   Test case: RepPolyInferPatBind.
FRRPatBind :: FixedRuntimeRepContext

-- | Pattern synonym arguments must have a fixed runtime representation.
--   
--   Test case: RepPolyInferPatSyn.
FRRPatSynArg :: FixedRuntimeRepContext

-- | The type of the scrutinee in a case statement must have a fixed
--   runtime representation.
--   
--   Test cases: RepPolyCase{1,2}.
FRRCase :: FixedRuntimeRepContext

-- | An instantiation of a newtype/data constructor pattern in which an
--   argument type does not have a fixed runtime representation.
--   
--   Test case: T20363.
FRRDataConPatArg :: !DataCon -> !Int -> FixedRuntimeRepContext

-- | The <a>RuntimeRep</a> arguments to unboxed tuples must be concrete
--   <a>RuntimeRep</a>s.
--   
--   Test case: RepPolyTuple.
FRRUnboxedTuple :: !Int -> FixedRuntimeRepContext

-- | Tuple sections must have a fixed runtime representation.
--   
--   Test case: RepPolyTupleSection.
FRRUnboxedTupleSection :: !Int -> FixedRuntimeRepContext

-- | The <a>RuntimeRep</a> arguments to unboxed sums must be concrete
--   <a>RuntimeRep</a>s.
--   
--   Test cases: RepPolySum.
FRRUnboxedSum :: !Maybe Int -> FixedRuntimeRepContext

-- | The body of a <tt>do</tt> expression or a monad comprehension must
--   have a fixed runtime representation.
--   
--   Test cases: RepPolyDoBody{1,2}, RepPolyMcBody.
FRRBodyStmt :: !StmtOrigin -> !Int -> FixedRuntimeRepContext

-- | Arguments to a guard in a monad comprehension must have a fixed
--   runtime representation.
--   
--   Test case: RepPolyMcGuard.
FRRBodyStmtGuard :: FixedRuntimeRepContext

-- | Arguments to <a>(&gt;&gt;=)</a> arising from a <tt>do</tt> expression
--   or a monad comprehension must have a fixed runtime representation.
--   
--   Test cases: RepPolyDoBind, RepPolyMcBind.
FRRBindStmt :: !StmtOrigin -> FixedRuntimeRepContext

-- | A value bound by a pattern guard must have a fixed runtime
--   representation.
--   
--   Test cases: none.
FRRBindStmtGuard :: FixedRuntimeRepContext

-- | A representation-polymorphism check arising from arrow notation.
--   
--   See <a>FRRArrowContext</a> for more details.
FRRArrow :: !FRRArrowContext -> FixedRuntimeRepContext

-- | A representation-polymorphic check arising from a call to
--   <tt>matchExpectedFunTys</tt> or <tt>matchActualFunTy</tt>.
--   
--   See <a>ExpectedFunTyOrigin</a> for more details.
FRRExpectedFunTy :: !ExpectedFunTyOrigin -> !Int -> FixedRuntimeRepContext

-- | Print the context for a <tt>FixedRuntimeRep</tt>
--   representation-polymorphism check.
--   
--   Note that this function does not include the specific
--   <a>RuntimeRep</a> which is not fixed. That information is stored in
--   <a>FixedRuntimeRepOrigin</a> and is reported separately.
pprFixedRuntimeRepContext :: FixedRuntimeRepContext -> SDoc

-- | Are we in a <tt>do</tt> expression or a monad comprehension?
--   
--   This datatype is only used to report this context to the user in error
--   messages.
data StmtOrigin
MonadComprehension :: StmtOrigin
DoNotation :: StmtOrigin

-- | The position of an argument (to be reported in an error message).
data ArgPos

-- | Invisible argument: don't report its position to the user.
ArgPosInvis :: ArgPos

-- | Visible argument in i-th position.
ArgPosVis :: !Int -> ArgPos

-- | A synonym for <a>FRRUnboxedTuple</a> exposed in the hs-boot file for
--   <a>GHC.Tc.Types.Origin</a>.
mkFRRUnboxedTuple :: Int -> FixedRuntimeRepContext

-- | A synonym for <a>FRRUnboxedSum</a> exposed in the hs-boot file for
--   <a>GHC.Tc.Types.Origin</a>.
mkFRRUnboxedSum :: Maybe Int -> FixedRuntimeRepContext

-- | The description of a representation-polymorphic <a>Id</a>.
data RepPolyId

-- | A representation-polymorphic <tt>PrimOp</tt>.
RepPolyPrimOp :: RepPolyId

-- | An unboxed tuple constructor.
RepPolyTuple :: RepPolyId

-- | An unboxed sum constructor.
RepPolySum :: RepPolyId

-- | An unspecified representation-polymorphic function, e.g. a pseudo-op
--   such as <tt>coerce</tt>.
RepPolyFunction :: RepPolyId
data Polarity
Pos :: Polarity
Neg :: Polarity

-- | A position in which a type variable appears in a type; in particular,
--   whether it appears in a positive or a negative position.
data Position (p :: Polarity)

-- | In the <tt>i</tt>-th argument of a function arrow
[Argument] :: forall (p :: Polarity). Int -> Position (FlipPolarity p) -> Position p

-- | In the result of a function arrow
[Result] :: forall (p :: Polarity). Position p -> Position p

-- | At the top level of a type
[Top] :: Position 'Pos

-- | While typechecking arrow notation, in which context did a
--   representation polymorphism check arise?
--   
--   See <a>FixedRuntimeRepContext</a> for more general origins of
--   representation polymorphism checks.
data FRRArrowContext

-- | The result of an arrow command does not have a fixed runtime
--   representation.
--   
--   Test case: RepPolyArrowCmd.
ArrowCmdResTy :: !HsCmd GhcRn -> FRRArrowContext

-- | The argument to an arrow in an arrow command application does not have
--   a fixed runtime representation.
--   
--   Test cases: none.
ArrowCmdApp :: !HsCmd GhcRn -> !HsExpr GhcRn -> FRRArrowContext

-- | A function in an arrow application does not have a fixed runtime
--   representation.
--   
--   Test cases: none.
ArrowCmdArrApp :: !HsExpr GhcRn -> !HsExpr GhcRn -> !HsArrAppType -> FRRArrowContext

-- | The scrutinee type in an arrow command case statement does not have a
--   fixed runtime representation.
--   
--   Test cases: none.
ArrowCmdCase :: FRRArrowContext

-- | The overall type of an arrow proc expression does not have a fixed
--   runtime representation.
--   
--   Test case: RepPolyArrowFun.
ArrowFun :: !HsExpr GhcRn -> FRRArrowContext
pprFRRArrowContext :: FRRArrowContext -> SDoc

-- | In what context are we calling <tt>matchExpectedFunTys</tt> or
--   <tt>matchActualFunTy</tt>?
--   
--   Used for two things:
--   
--   <ol>
--   <li>Reporting error messages which explain that a function has been
--   given an unexpected number of arguments. Uses
--   <a>pprExpectedFunTyHerald</a>. See Note [Herald for
--   matchExpectedFunTys] in GHC.Tc.Utils.Unify.</li>
--   <li>Reporting representation-polymorphism errors when a function
--   argument doesn't have a fixed RuntimeRep as per Note [Fixed
--   RuntimeRep] in GHC.Tc.Utils.Concrete. Uses
--   <a>pprExpectedFunTyOrigin</a>. See <a>FixedRuntimeRepContext</a> for
--   the situations in which representation-polymorphism checks are
--   performed.</li>
--   </ol>
data ExpectedFunTyOrigin

-- | A rebindable syntax operator is expected to have a function type.
--   
--   Test cases for representation-polymorphism checks: RepPolyDoBind,
--   RepPolyDoBody{1,2}, RepPolyMc{Bind,Body,Guard}, RepPolyNPlusK
ExpectedFunTySyntaxOp :: !CtOrigin -> !HsExpr (GhcPass p) -> ExpectedFunTyOrigin

-- | A view pattern must have a function type.
--   
--   Test cases for representation-polymorphism checks: RepPolyBinder
ExpectedFunTyViewPat :: !HsExpr GhcRn -> ExpectedFunTyOrigin

-- | Need to be able to extract an argument type from a function type.
--   
--   Test cases for representation-polymorphism checks: RepPolyApp
ExpectedFunTyArg :: !TypedThing -> !HsExpr (GhcPass p) -> ExpectedFunTyOrigin

-- | Ensure that a function defined by equations indeed has a function type
--   with the appropriate number of arguments.
--   
--   Test cases for representation-polymorphism checks: RepPolyBinder,
--   RepPolyRecordPattern, RepPolyWildcardPattern
ExpectedFunTyMatches :: !TypedThing -> !MatchGroup GhcRn (LHsExpr GhcRn) -> ExpectedFunTyOrigin

-- | Ensure that a lambda abstraction has a function type.
--   
--   Test cases for representation-polymorphism checks: RepPolyLambda,
--   RepPolyMatch
ExpectedFunTyLam :: HsLamVariant -> !HsExpr GhcRn -> ExpectedFunTyOrigin
pprExpectedFunTyOrigin :: ExpectedFunTyOrigin -> Int -> SDoc
pprExpectedFunTyHerald :: ExpectedFunTyOrigin -> SDoc
data InstanceWhat
BuiltinEqInstance :: InstanceWhat
BuiltinTypeableInstance :: TyCon -> InstanceWhat
BuiltinInstance :: InstanceWhat
LocalInstance :: InstanceWhat
TopLevInstance :: DFunId -> SafeOverlapping -> Maybe (WarningTxt GhcRn) -> InstanceWhat
[iw_dfun_id] :: InstanceWhat -> DFunId
[iw_safe_over] :: InstanceWhat -> SafeOverlapping
[iw_warn] :: InstanceWhat -> Maybe (WarningTxt GhcRn)

-- | Indicates if Instance met the Safe Haskell overlapping instances
--   safety check.
--   
--   See Note [Safe Haskell Overlapping Instances] in GHC.Tc.Solver See
--   Note [Safe Haskell Overlapping Instances Implementation] in
--   GHC.Tc.Solver
type SafeOverlapping = Bool
instance GHC.Classes.Eq GHC.Tc.Types.Origin.ReportRedundantConstraints
instance GHC.Classes.Eq GHC.Tc.Types.Origin.UserTypeCtxt
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.CtOrigin
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.FRRArrowContext
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.FixedRuntimeRepContext
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.FixedRuntimeRepOrigin
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.InstanceWhat
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.NakedScFlag
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.SkolemInfo
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.SkolemInfoAnon
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.StmtOrigin
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.TyVarBndrs
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.TypedThing
instance GHC.Types.Unique.Uniquable GHC.Tc.Types.Origin.SkolemInfo

module GHC.Tc.Types.BasicTypes
type TcBinderStack = [TcBinder]
type TcId = Id
data TcBinder
TcIdBndr :: TcId -> TopLevelFlag -> TcBinder
TcIdBndr_ExpType :: Name -> ExpType -> TopLevelFlag -> TcBinder
TcTvBndr :: Name -> TyVar -> TcBinder
type TcSigFun = Name -> Maybe TcSigInfo
data TcSigInfo
TcIdSig :: TcIdSig -> TcSigInfo
TcPatSynSig :: TcPatSynSig -> TcSigInfo
data TcIdSig
TcCompleteSig :: TcCompleteSig -> TcIdSig
TcPartialSig :: TcPartialSig -> TcIdSig
data TcCompleteSig
CSig :: TcId -> UserTypeCtxt -> SrcSpan -> TcCompleteSig
[sig_bndr] :: TcCompleteSig -> TcId
[sig_ctxt] :: TcCompleteSig -> UserTypeCtxt
[sig_loc] :: TcCompleteSig -> SrcSpan
data TcPartialSig
PSig :: Name -> LHsSigWcType GhcRn -> UserTypeCtxt -> SrcSpan -> TcPartialSig
[psig_name] :: TcPartialSig -> Name
[psig_hs_ty] :: TcPartialSig -> LHsSigWcType GhcRn
[psig_ctxt] :: TcPartialSig -> UserTypeCtxt
[psig_loc] :: TcPartialSig -> SrcSpan
data TcPatSynSig
PatSig :: Name -> [InvisTVBinder] -> [InvisTVBinder] -> TcThetaType -> [InvisTVBinder] -> TcThetaType -> TcSigmaType -> TcPatSynSig
[patsig_name] :: TcPatSynSig -> Name
[patsig_implicit_bndrs] :: TcPatSynSig -> [InvisTVBinder]
[patsig_univ_bndrs] :: TcPatSynSig -> [InvisTVBinder]
[patsig_req] :: TcPatSynSig -> TcThetaType
[patsig_ex_bndrs] :: TcPatSynSig -> [InvisTVBinder]
[patsig_prov] :: TcPatSynSig -> TcThetaType
[patsig_body_ty] :: TcPatSynSig -> TcSigmaType
data TcIdSigInst
TISI :: TcIdSig -> [(Name, InvisTVBinder)] -> TcThetaType -> TcSigmaType -> [(Name, TcTyVar)] -> Maybe TcType -> TcIdSigInst
[sig_inst_sig] :: TcIdSigInst -> TcIdSig
[sig_inst_skols] :: TcIdSigInst -> [(Name, InvisTVBinder)]
[sig_inst_theta] :: TcIdSigInst -> TcThetaType
[sig_inst_tau] :: TcIdSigInst -> TcSigmaType
[sig_inst_wcs] :: TcIdSigInst -> [(Name, TcTyVar)]
[sig_inst_wcx] :: TcIdSigInst -> Maybe TcType
isPartialSig :: TcIdSigInst -> Bool

-- | No signature or a partial signature
hasCompleteSig :: TcSigFun -> Name -> Bool
tcSigInfoName :: TcSigInfo -> Name
tcIdSigLoc :: TcIdSig -> SrcSpan
completeSigPolyId_maybe :: TcSigInfo -> Maybe TcId

-- | A typecheckable thing available in a local context. Could be
--   <a>AGlobal</a> <a>TyThing</a>, but also lexically scoped variables,
--   etc. See <a>GHC.Tc.Utils.Env</a> for how to retrieve a <a>TyThing</a>
--   given a <a>Name</a>.
data TcTyThing
AGlobal :: TyThing -> TcTyThing
ATcId :: Id -> IdBindingInfo -> TcTyThing
[tct_id] :: TcTyThing -> Id
[tct_info] :: TcTyThing -> IdBindingInfo
ATyVar :: Name -> TcTyVar -> TcTyThing
ATcTyCon :: TyCon -> TcTyThing
APromotionErr :: PromotionErr -> TcTyThing

-- | IdBindingInfo describes how an Id is bound.
--   
--   It is used for the following purposes: a) for static forms in
--   <a>checkClosedInStaticForm</a> and b) to figure out when a nested
--   binding can be generalised, in <a>decideGeneralisationPlan</a>.
data IdBindingInfo
NotLetBound :: IdBindingInfo
ClosedLet :: IdBindingInfo
NonClosedLet :: RhsNames -> ClosedTypeId -> IdBindingInfo

-- | IsGroupClosed describes a group of mutually-recursive bindings
data IsGroupClosed
IsGroupClosed :: NameEnv RhsNames -> ClosedTypeId -> IsGroupClosed
type RhsNames = NameSet
type ClosedTypeId = Bool
tcTyThingCategory :: TcTyThing -> String

-- | Matches on either a global <a>TyCon</a> or a <a>TcTyCon</a>.
tcTyThingTyCon_maybe :: TcTyThing -> Maybe TyCon
pprTcTyThingCategory :: TcTyThing -> SDoc
instance GHC.Types.Name.Occurrence.HasOccName GHC.Tc.Types.BasicTypes.TcBinder
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.BasicTypes.IdBindingInfo
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.BasicTypes.TcBinder
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.BasicTypes.TcCompleteSig
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.BasicTypes.TcIdSig
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.BasicTypes.TcIdSigInst
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.BasicTypes.TcPartialSig
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.BasicTypes.TcPatSynSig
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.BasicTypes.TcSigInfo
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.BasicTypes.TcTyThing


-- | The <a>ZonkM</a> monad, a stripped down <tt>TcM</tt>, used when
--   zonking within the typechecker in <a>GHC.Tc.Zonk.TcType</a>.
--   
--   See Note [Module structure for zonking] in GHC.Tc.Zonk.Type.
module GHC.Tc.Zonk.Monad

-- | A stripped down version of <tt>TcM</tt> which is sufficient for
--   zonking types.
data ZonkM a
pattern ZonkM :: (ZonkGblEnv -> IO a) -> ZonkM a

-- | Information needed by the <a>ZonkM</a> monad, which is a slimmed down
--   version of <tt>TcM</tt> with just enough information for zonking.
data ZonkGblEnv
ZonkGblEnv :: Logger -> NamePprCtx -> SrcSpan -> TcLevel -> TcBinderStack -> ZonkGblEnv
[zge_logger] :: ZonkGblEnv -> Logger
[zge_name_ppr_ctx] :: ZonkGblEnv -> NamePprCtx
[zge_src_span] :: ZonkGblEnv -> SrcSpan
[zge_tc_level] :: ZonkGblEnv -> TcLevel
[zge_binder_stack] :: ZonkGblEnv -> TcBinderStack
getZonkGblEnv :: ZonkM ZonkGblEnv
getZonkTcLevel :: ZonkM TcLevel

-- | Same as <tt>traceTc</tt>, but for the <a>ZonkM</a> monad.
traceZonk :: String -> SDoc -> ZonkM ()
instance GHC.Internal.Base.Applicative GHC.Tc.Zonk.Monad.ZonkM
instance GHC.Internal.Base.Functor GHC.Tc.Zonk.Monad.ZonkM
instance GHC.Internal.Control.Monad.IO.Class.MonadIO GHC.Tc.Zonk.Monad.ZonkM
instance GHC.Internal.Base.Monad GHC.Tc.Zonk.Monad.ZonkM

module GHC.Tc.Types.ErrCtxt

-- | Additional context to include in an error message, e.g. "In the type
--   signature ...", "In the ambiguity check for ...", etc.
type ErrCtxt = (Bool, TidyEnv -> ZonkM (TidyEnv, SDoc))

module GHC.Tc.Types.CtLoc
data CtLoc
CtLoc :: CtOrigin -> CtLocEnv -> Maybe TypeOrKind -> !SubGoalDepth -> CtLoc
[ctl_origin] :: CtLoc -> CtOrigin
[ctl_env] :: CtLoc -> CtLocEnv
[ctl_t_or_k] :: CtLoc -> Maybe TypeOrKind
[ctl_depth] :: CtLoc -> !SubGoalDepth
ctLocSpan :: CtLoc -> RealSrcSpan
ctLocEnv :: CtLoc -> CtLocEnv
ctLocLevel :: CtLoc -> TcLevel
ctLocOrigin :: CtLoc -> CtOrigin
ctLocTypeOrKind_maybe :: CtLoc -> Maybe TypeOrKind
toInvisibleLoc :: CtLoc -> CtLoc
ctLocDepth :: CtLoc -> SubGoalDepth
bumpCtLocDepth :: CtLoc -> CtLoc
isGivenLoc :: CtLoc -> Bool
mkGivenLoc :: TcLevel -> SkolemInfoAnon -> CtLocEnv -> CtLoc
mkKindEqLoc :: TcType -> TcType -> CtLoc -> CtLoc
setCtLocOrigin :: CtLoc -> CtOrigin -> CtLoc
updateCtLocOrigin :: CtLoc -> (CtOrigin -> CtOrigin) -> CtLoc
setCtLocEnv :: CtLoc -> CtLocEnv -> CtLoc
setCtLocSpan :: CtLoc -> RealSrcSpan -> CtLoc
pprCtLoc :: CtLoc -> SDoc
adjustCtLoc :: Bool -> Bool -> CtLoc -> CtLoc
adjustCtLocTyConBinder :: TyConBinder -> CtLoc -> CtLoc

-- | Local typechecker environment for a constraint.
--   
--   Used to restore the environment of a constraint when reporting errors,
--   see <tt>setCtLocM</tt>.
--   
--   See also <tt>TcLclCtxt</tt>.
data CtLocEnv
CtLocEnv :: ![ErrCtxt] -> !RealSrcSpan -> !TcBinderStack -> !TcLevel -> !Bool -> !LocalRdrEnv -> CtLocEnv
[ctl_ctxt] :: CtLocEnv -> ![ErrCtxt]
[ctl_loc] :: CtLocEnv -> !RealSrcSpan
[ctl_bndrs] :: CtLocEnv -> !TcBinderStack
[ctl_tclvl] :: CtLocEnv -> !TcLevel
[ctl_in_gen_code] :: CtLocEnv -> !Bool
[ctl_rdr] :: CtLocEnv -> !LocalRdrEnv
getCtLocEnvLoc :: CtLocEnv -> RealSrcSpan
setCtLocEnvLoc :: CtLocEnv -> SrcSpan -> CtLocEnv
setCtLocRealLoc :: CtLocEnv -> RealSrcSpan -> CtLocEnv
getCtLocEnvLvl :: CtLocEnv -> TcLevel
setCtLocEnvLvl :: CtLocEnv -> TcLevel -> CtLocEnv
ctLocEnvInGeneratedCode :: CtLocEnv -> Bool

-- | See Note [SubGoalDepth]
data SubGoalDepth
initialSubGoalDepth :: SubGoalDepth
maxSubGoalDepth :: SubGoalDepth -> SubGoalDepth -> SubGoalDepth
bumpSubGoalDepth :: SubGoalDepth -> SubGoalDepth
subGoalDepthExceeded :: IntWithInf -> SubGoalDepth -> Bool
instance GHC.Classes.Eq GHC.Tc.Types.CtLoc.SubGoalDepth
instance GHC.Classes.Ord GHC.Tc.Types.CtLoc.SubGoalDepth
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.CtLoc.SubGoalDepth


-- | This module defines types and simple operations over constraints, as
--   used in the type-checker and constraint solver.
module GHC.Tc.Types.Constraint

-- | A <a>Xi</a>-type is one that has been fully rewritten with respect to
--   the inert set; that is, it has been rewritten by the algorithm in
--   GHC.Tc.Solver.Rewrite. (Historical note: <a>Xi</a>, for years and
--   years, meant that a type was type-family-free. It does *not* mean this
--   any more.)
type Xi = TcType
data Ct
CDictCan :: DictCt -> Ct
CIrredCan :: IrredCt -> Ct
CEqCan :: EqCt -> Ct
CQuantCan :: QCInst -> Ct
CNonCanonical :: CtEvidence -> Ct
type Cts = Bag Ct
singleCt :: Ct -> Cts
listToCts :: [Ct] -> Cts
ctsElts :: Cts -> [Ct]
consCts :: Ct -> Cts -> Cts
snocCts :: Cts -> Ct -> Cts
extendCtsList :: Cts -> [Ct] -> Cts
isEmptyCts :: Cts -> Bool
emptyCts :: Cts
andCts :: Cts -> Cts -> Cts
ctsPreds :: Cts -> [PredType]
isPendingScDictCt :: DictCt -> Bool
isPendingScDict :: Ct -> Bool
pendingScDict_maybe :: Ct -> Maybe Ct

-- | True if taking superclasses of givens, or of wanteds (to perhaps
--   expose more equalities or functional dependencies) might help to solve
--   this constraint. See Note [When superclasses help]
superClassesMightHelp :: WantedConstraints -> Bool
getPendingWantedScs :: Cts -> ([Ct], Cts)
isWantedCt :: Ct -> Bool
isGivenCt :: Ct -> Bool

-- | Is this an user error message type, i.e. either the form <tt>TypeError
--   err</tt> or <tt>Unsatisfiable err</tt>?
isTopLevelUserTypeError :: PredType -> Bool

-- | Does this constraint contain an user error message?
--   
--   That is, the type is either of the form <tt>Unsatisfiable err</tt>, or
--   it contains a type of the form <tt>TypeError msg</tt>, either at the
--   top level or nested inside the type.
containsUserTypeError :: PredType -> Bool

-- | A constraint is considered to be a custom type error, if it contains
--   custom type errors anywhere in it. See Note [Custom type errors in
--   constraints]
getUserTypeErrorMsg :: PredType -> Maybe ErrorMsgType

-- | Is this type an unsatisfiable constraint? If so, return the error
--   message.
isUnsatisfiableCt_maybe :: Type -> Maybe ErrorMsgType
ctEvidence :: Ct -> CtEvidence
updCtEvidence :: (CtEvidence -> CtEvidence) -> Ct -> Ct
ctLoc :: Ct -> CtLoc
ctPred :: Ct -> PredType

-- | Get the flavour of the given <a>Ct</a>
ctFlavour :: Ct -> CtFlavour

-- | Get the equality relation for the given <a>Ct</a>
ctEqRel :: Ct -> EqRel
ctOrigin :: Ct -> CtOrigin
ctRewriters :: Ct -> RewriterSet
ctEvId :: HasDebugCallStack => Ct -> EvVar

-- | Returns the evidence <a>Id</a> for the argument <a>Ct</a> when this
--   <a>Ct</a> is a <a>Wanted</a>.
--   
--   Returns <a>Nothing</a> otherwise.
wantedEvId_maybe :: Ct -> Maybe EvVar

-- | Makes a new equality predicate with the same role as the given
--   evidence.
mkTcEqPredLikeEv :: CtEvidence -> TcType -> TcType -> TcType
mkNonCanonical :: CtEvidence -> Ct
mkGivens :: CtLoc -> [EvId] -> [Ct]

-- | Returns free variables of constraints as a non-deterministic set
tyCoVarsOfCt :: Ct -> TcTyCoVarSet

-- | Returns free variables of a bag of constraints as a non-deterministic
--   set. See Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfCts :: Cts -> TcTyCoVarSet

-- | Returns free variables of constraints as a deterministically ordered
--   list. See Note [Deterministic FV] in GHC.Utils.FV.
tyCoVarsOfCtList :: Ct -> [TcTyCoVar]

-- | Returns free variables of a bag of constraints as a deterministically
--   ordered list. See Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfCtsList :: Cts -> [TcTyCoVar]
boundOccNamesOfWC :: WantedConstraints -> [OccName]
data EqCt
EqCt :: CtEvidence -> CanEqLHS -> Xi -> EqRel -> EqCt
[eq_ev] :: EqCt -> CtEvidence
[eq_lhs] :: EqCt -> CanEqLHS
[eq_rhs] :: EqCt -> Xi
[eq_eq_rel] :: EqCt -> EqRel
eqCtEvidence :: EqCt -> CtEvidence
eqCtLHS :: EqCt -> CanEqLHS
data DictCt
DictCt :: CtEvidence -> Class -> [Xi] -> ExpansionFuel -> DictCt
[di_ev] :: DictCt -> CtEvidence
[di_cls] :: DictCt -> Class
[di_tys] :: DictCt -> [Xi]
[di_pend_sc] :: DictCt -> ExpansionFuel
dictCtEvidence :: DictCt -> CtEvidence
dictCtPred :: DictCt -> TcPredType
data IrredCt
IrredCt :: CtEvidence -> CtIrredReason -> IrredCt
[ir_ev] :: IrredCt -> CtEvidence
[ir_reason] :: IrredCt -> CtIrredReason
irredCtEvidence :: IrredCt -> CtEvidence
mkIrredCt :: CtIrredReason -> CtEvidence -> Ct
ctIrredCt :: CtIrredReason -> Ct -> IrredCt
irredCtPred :: IrredCt -> PredType
data QCInst
QCI :: CtEvidence -> [TcTyVar] -> TcPredType -> ExpansionFuel -> QCInst
[qci_ev] :: QCInst -> CtEvidence
[qci_tvs] :: QCInst -> [TcTyVar]
[qci_pred] :: QCInst -> TcPredType
[qci_pend_sc] :: QCInst -> ExpansionFuel
pendingScInst_maybe :: QCInst -> Maybe QCInst

-- | Says how many layers of superclasses can we expand. Invariant:
--   ExpansionFuel should always be &gt;= 0 see Note [Expanding Recursive
--   Superclasses and ExpansionFuel]
type ExpansionFuel = Int

-- | Do not expand superclasses any further
doNotExpand :: ExpansionFuel

-- | Consumes one unit of fuel. Precondition: fuel &gt; 0
consumeFuel :: ExpansionFuel -> ExpansionFuel

-- | Returns True if we have any fuel left for superclass expansion
pendingFuel :: ExpansionFuel -> Bool

-- | asserts if fuel is non-negative
assertFuelPrecondition :: ExpansionFuel -> a -> a

-- | asserts if fuel is strictly greater than 0
assertFuelPreconditionStrict :: ExpansionFuel -> a -> a

-- | Used to indicate extra information about why a CIrredCan is
--   irreducible
data CtIrredReason

-- | This constraint has a non-canonical shape (e.g. <tt>c Int</tt>, for a
--   variable <tt>c</tt>)
IrredShapeReason :: CtIrredReason

-- | An equality where some invariant other than (TyEq:H) of <a>CEqCan</a>
--   is not satisfied; the <a>CheckTyEqResult</a> states exactly why
NonCanonicalReason :: CheckTyEqResult -> CtIrredReason

-- | An equality that cannot be decomposed because it is representational.
--   Example: <tt>a b ~R# Int</tt>. These might still be solved later.
--   INVARIANT: The constraint is a representational equality constraint
ReprEqReason :: CtIrredReason

-- | A nominal equality that relates two wholly different types, like
--   <tt>Int ~# Bool</tt> or <tt>a b ~# 3</tt>. INVARIANT: The constraint
--   is a nominal equality constraint
ShapeMismatchReason :: CtIrredReason

-- | An equality like <tt>T a b c ~ Q d e</tt> where either <tt>T</tt> or
--   <tt>Q</tt> is an abstract type constructor. See Note [Skolem abstract
--   data] in GHC.Core.TyCon. INVARIANT: The constraint is an equality
--   constraint between two TyConApps
AbstractTyConReason :: CtIrredReason

-- | A typechecker plugin returned this in the pluginBadCts field of
--   TcPluginProgress
PluginReason :: CtIrredReason

-- | Are we sure that more solving will never solve this constraint?
isInsolubleReason :: CtIrredReason -> Bool

-- | A <i>set</i> of problems in checking the validity of a type equality.
--   See <tt>checkTypeEq</tt>.
data CheckTyEqResult

-- | An <i>individual</i> problem that might be logged in a
--   <a>CheckTyEqResult</a>
data CheckTyEqProblem
cteProblem :: CheckTyEqProblem -> CheckTyEqResult
cterClearOccursCheck :: CheckTyEqResult -> CheckTyEqResult

-- | No problems in checking the validity of a type equality.
cteOK :: CheckTyEqResult
cteImpredicative :: CheckTyEqProblem
cteTypeFamily :: CheckTyEqProblem
cteCoercionHole :: CheckTyEqProblem
cteInsolubleOccurs :: CheckTyEqProblem
cteSolubleOccurs :: CheckTyEqProblem

-- | Mark a <a>CheckTyEqResult</a> as not having an insoluble occurs-check:
--   any occurs check under a type family or in a representation equality
--   is soluble.
cterSetOccursCheckSoluble :: CheckTyEqResult -> CheckTyEqResult
cteConcrete :: CheckTyEqProblem
cteSkolemEscape :: CheckTyEqProblem
impredicativeProblem :: CheckTyEqResult
insolubleOccursProblem :: CheckTyEqResult
solubleOccursProblem :: CheckTyEqResult

-- | Check whether a <a>CheckTyEqResult</a> is marked successful.
cterHasNoProblem :: CheckTyEqResult -> Bool

-- | Check whether a <a>CheckTyEqResult</a> has a <a>CheckTyEqProblem</a>
cterHasProblem :: CheckTyEqResult -> CheckTyEqProblem -> Bool

-- | Check whether a <a>CheckTyEqResult</a> has one <a>CheckTyEqProblem</a>
--   and no other
cterHasOnlyProblem :: CheckTyEqResult -> CheckTyEqProblem -> Bool
cterHasOnlyProblems :: CheckTyEqResult -> CheckTyEqResult -> Bool
cterRemoveProblem :: CheckTyEqResult -> CheckTyEqProblem -> CheckTyEqResult
cterHasOccursCheck :: CheckTyEqResult -> Bool

-- | Retain only information about occurs-check failures, because only that
--   matters after recurring into a kind.
cterFromKind :: CheckTyEqResult -> CheckTyEqResult

-- | A <a>CanEqLHS</a> is a type that can appear on the left of a canonical
--   equality: a type variable or <i>exactly-saturated</i> type family
--   application.
data CanEqLHS
TyVarLHS :: TcTyVar -> CanEqLHS
TyFamLHS :: TyCon -> [Xi] -> CanEqLHS

-- | Is a type a canonical LHS? That is, is it a tyvar or an
--   exactly-saturated type family application? Does not look through type
--   synonyms.
canEqLHS_maybe :: Xi -> Maybe CanEqLHS
canTyFamEqLHS_maybe :: Xi -> Maybe CanEqLHS

-- | Retrieve the kind of a <a>CanEqLHS</a>
canEqLHSKind :: CanEqLHS -> TcKind

-- | Convert a <a>CanEqLHS</a> back into a <a>Type</a>
canEqLHSType :: CanEqLHS -> TcType

-- | Are two <a>CanEqLHS</a>s equal?
eqCanEqLHS :: CanEqLHS -> CanEqLHS -> Bool

-- | A hole stores the information needed to report diagnostics about holes
--   in terms (unbound identifiers or underscores) or in types (also called
--   wildcards, as used in partial type signatures). See Note [Holes].
data Hole
Hole :: HoleSort -> RdrName -> TcType -> CtLoc -> Hole

-- | What flavour of hole is this?
[hole_sort] :: Hole -> HoleSort

-- | The name of this hole
[hole_occ] :: Hole -> RdrName

-- | Type to be printed to the user For expression holes: type of expr For
--   type holes: the missing type
[hole_ty] :: Hole -> TcType

-- | Where hole was written
[hole_loc] :: Hole -> CtLoc

-- | Used to indicate which sort of hole we have.
data HoleSort

-- | Either an out-of-scope variable or a "true" hole in an expression
--   (TypedHoles). The HoleExprRef says where to write the the erroring
--   expression for -fdefer-type-errors.
ExprHole :: HoleExprRef -> HoleSort

-- | A hole in a type (PartialTypeSignatures)
TypeHole :: HoleSort

-- | A hole in a constraint, like @f :: (_, Eq a) =&gt; ... Differentiated
--   from TypeHole because a ConstraintHole is simplified differently. See
--   Note [Do not simplify ConstraintHoles] in GHC.Tc.Solver.
ConstraintHole :: HoleSort

-- | Does this hole represent an "out of scope" error? See Note [Insoluble
--   holes]
isOutOfScopeHole :: Hole -> Bool

-- | A delayed error, to be reported after constraint solving, in order to
--   benefit from deferred unifications.
data DelayedError

-- | A hole (in a type or in a term).
--   
--   See Note [Holes].
DE_Hole :: Hole -> DelayedError

-- | A type could not be ensured to be concrete.
--   
--   See Note [The Concrete mechanism] in GHC.Tc.Utils.Concrete.
DE_NotConcrete :: NotConcreteError -> DelayedError

-- | Why did we require that a certain type be concrete?
data NotConcreteError

-- | Concreteness was required by a representation-polymorphism check.
--   
--   See Note [The Concrete mechanism] in GHC.Tc.Utils.Concrete.
NCE_FRR :: CtLoc -> FixedRuntimeRepOrigin -> NonEmpty NotConcreteReason -> NotConcreteError

-- | Where did this check take place?
[nce_loc] :: NotConcreteError -> CtLoc

-- | Which representation-polymorphism check did we perform?
[nce_frr_origin] :: NotConcreteError -> FixedRuntimeRepOrigin

-- | Why did the check fail?
[nce_reasons] :: NotConcreteError -> NonEmpty NotConcreteReason

-- | Why did we decide that a type was not concrete?
data NotConcreteReason

-- | The type contains a <tt>TyConApp</tt> of a non-concrete <a>TyCon</a>.
--   
--   See Note [Concrete types] in GHC.Tc.Utils.Concrete.
NonConcreteTyCon :: TyCon -> [TcType] -> NotConcreteReason

-- | The type contains a type variable that could not be made concrete
--   (e.g. a skolem type variable).
NonConcretisableTyVar :: TyVar -> NotConcreteReason

-- | The type contains a cast.
ContainsCast :: TcType -> TcCoercionN -> NotConcreteReason

-- | The type contains a forall.
ContainsForall :: ForAllTyBinder -> TcType -> NotConcreteReason

-- | The type contains a <tt>CoercionTy</tt>.
ContainsCoercionTy :: TcCoercion -> NotConcreteReason
data WantedConstraints
WC :: Cts -> Bag Implication -> Bag DelayedError -> WantedConstraints
[wc_simple] :: WantedConstraints -> Cts
[wc_impl] :: WantedConstraints -> Bag Implication
[wc_errors] :: WantedConstraints -> Bag DelayedError
insolubleWC :: WantedConstraints -> Bool
emptyWC :: WantedConstraints
isEmptyWC :: WantedConstraints -> Bool

-- | Checks whether a the given wanted constraints are solved, i.e. that
--   there are no simple constraints left and all the implications are
--   solved.
isSolvedWC :: WantedConstraints -> Bool
andWC :: WantedConstraints -> WantedConstraints -> WantedConstraints
unionsWC :: [WantedConstraints] -> WantedConstraints
mkSimpleWC :: [CtEvidence] -> WantedConstraints
mkImplicWC :: Bag Implication -> WantedConstraints
addInsols :: WantedConstraints -> Bag IrredCt -> WantedConstraints
dropMisleading :: WantedConstraints -> WantedConstraints
addSimples :: WantedConstraints -> Bag Ct -> WantedConstraints
addImplics :: WantedConstraints -> Bag Implication -> WantedConstraints
addHoles :: WantedConstraints -> Bag Hole -> WantedConstraints
addNotConcreteError :: WantedConstraints -> NotConcreteError -> WantedConstraints
addDelayedErrors :: WantedConstraints -> Bag DelayedError -> WantedConstraints

-- | Returns free variables of WantedConstraints as a non-deterministic
--   set. See Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfWC :: WantedConstraints -> TyCoVarSet

-- | Returns free variables of WantedConstraints as a deterministically
--   ordered list. See Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfWCList :: WantedConstraints -> [TyCoVar]
insolubleWantedCt :: Ct -> Bool

-- | Returns True of constraints that are definitely insoluble, as well as
--   TypeError constraints. Can return <a>True</a> for Given constraints,
--   unlike <a>insolubleWantedCt</a>.
--   
--   The function is tuned for application <i>after</i> constraint solving
--   i.e. assuming canonicalisation has been done That's why it looks only
--   for IrredCt; all insoluble constraints are put into CIrredCan
insolubleCt :: Ct -> Bool
insolubleIrredCt :: IrredCt -> Bool
insolubleImplic :: Implication -> Bool

-- | Gather all the type variables from <a>WantedConstraints</a> that it
--   would be unhelpful to default. For the moment, these are only
--   <a>ConcreteTv</a> metavariables participating in a nominal equality
--   whose other side is not concrete; it's usually better to report those
--   as errors instead of defaulting.
nonDefaultableTyVarsOfWC :: WantedConstraints -> TyCoVarSet
data Implication
Implic :: TcLevel -> SkolemInfoAnon -> [TcTyVar] -> [EvVar] -> HasGivenEqs -> Bool -> !CtLocEnv -> WantedConstraints -> EvBindsVar -> VarSet -> VarSet -> ImplicStatus -> Implication
[ic_tclvl] :: Implication -> TcLevel
[ic_info] :: Implication -> SkolemInfoAnon
[ic_skols] :: Implication -> [TcTyVar]
[ic_given] :: Implication -> [EvVar]
[ic_given_eqs] :: Implication -> HasGivenEqs
[ic_warn_inaccessible] :: Implication -> Bool
[ic_env] :: Implication -> !CtLocEnv
[ic_wanted] :: Implication -> WantedConstraints
[ic_binds] :: Implication -> EvBindsVar
[ic_need_inner] :: Implication -> VarSet
[ic_need_outer] :: Implication -> VarSet
[ic_status] :: Implication -> ImplicStatus
implicationPrototype :: CtLocEnv -> Implication
checkTelescopeSkol :: SkolemInfoAnon -> Bool
data ImplicStatus
IC_Solved :: [EvVar] -> ImplicStatus
[ics_dead] :: ImplicStatus -> [EvVar]
IC_Insoluble :: ImplicStatus
IC_BadTelescope :: ImplicStatus
IC_Unsolved :: ImplicStatus
isInsolubleStatus :: ImplicStatus -> Bool
isSolvedStatus :: ImplicStatus -> Bool
type UserGiven = Implication
getUserGivensFromImplics :: [Implication] -> [UserGiven]
data HasGivenEqs
NoGivenEqs :: HasGivenEqs
LocalGivenEqs :: HasGivenEqs
MaybeGivenEqs :: HasGivenEqs
checkImplicationInvariants :: (HasCallStack, Applicative m) => Implication -> m ()

-- | Local typechecker environment for a constraint.
--   
--   Used to restore the environment of a constraint when reporting errors,
--   see <tt>setCtLocM</tt>.
--   
--   See also <tt>TcLclCtxt</tt>.
data CtLocEnv
CtLocEnv :: ![ErrCtxt] -> !RealSrcSpan -> !TcBinderStack -> !TcLevel -> !Bool -> !LocalRdrEnv -> CtLocEnv
[ctl_ctxt] :: CtLocEnv -> ![ErrCtxt]
[ctl_loc] :: CtLocEnv -> !RealSrcSpan
[ctl_bndrs] :: CtLocEnv -> !TcBinderStack
[ctl_tclvl] :: CtLocEnv -> !TcLevel
[ctl_in_gen_code] :: CtLocEnv -> !Bool
[ctl_rdr] :: CtLocEnv -> !LocalRdrEnv
setCtLocEnvLoc :: CtLocEnv -> SrcSpan -> CtLocEnv
setCtLocEnvLvl :: CtLocEnv -> TcLevel -> CtLocEnv
getCtLocEnvLoc :: CtLocEnv -> RealSrcSpan
getCtLocEnvLvl :: CtLocEnv -> TcLevel
ctLocEnvInGeneratedCode :: CtLocEnv -> Bool
data CtEvidence
CtGiven :: TcPredType -> EvVar -> CtLoc -> CtEvidence
[ctev_pred] :: CtEvidence -> TcPredType
[ctev_evar] :: CtEvidence -> EvVar
[ctev_loc] :: CtEvidence -> CtLoc
CtWanted :: TcPredType -> TcEvDest -> CtLoc -> RewriterSet -> CtEvidence
[ctev_pred] :: CtEvidence -> TcPredType
[ctev_dest] :: CtEvidence -> TcEvDest
[ctev_loc] :: CtEvidence -> CtLoc
[ctev_rewriters] :: CtEvidence -> RewriterSet

-- | A place for type-checking evidence to go after it is generated.
--   
--   <ul>
--   <li>Wanted equalities use HoleDest,</li>
--   <li>other Wanteds use EvVarDest.</li>
--   </ul>
data TcEvDest

-- | bind this var to the evidence EvVarDest is always used for
--   non-type-equalities e.g. class constraints
EvVarDest :: EvVar -> TcEvDest

-- | fill in this hole with the evidence HoleDest is always used for
--   type-equalities See Note [Coercion holes] in GHC.Core.TyCo.Rep
HoleDest :: CoercionHole -> TcEvDest
isWanted :: CtEvidence -> Bool
isGiven :: CtEvidence -> Bool
ctEvPred :: CtEvidence -> TcPredType
ctEvLoc :: CtEvidence -> CtLoc
ctEvOrigin :: CtEvidence -> CtOrigin

-- | Get the equality relation relevant for a <a>CtEvidence</a>
ctEvEqRel :: HasDebugCallStack => CtEvidence -> EqRel
ctEvExpr :: HasDebugCallStack => CtEvidence -> EvExpr
ctEvTerm :: CtEvidence -> EvTerm
ctEvCoercion :: HasDebugCallStack => CtEvidence -> TcCoercion
ctEvEvId :: CtEvidence -> EvVar

-- | Extract the set of rewriters from a <a>CtEvidence</a> See Note
--   [Wanteds rewrite Wanteds] If the provided CtEvidence is not for a
--   Wanted, just return an empty set.
ctEvRewriters :: CtEvidence -> RewriterSet
ctEvUnique :: CtEvidence -> Unique
tcEvDestUnique :: TcEvDest -> Unique

-- | Get the rewrite-role relevant for a <a>CtEvidence</a> See Note [The
--   rewrite-role of a constraint]
ctEvRewriteRole :: HasDebugCallStack => CtEvidence -> Role

-- | Return the rewrite-role of an abitrary CtEvidence See Note [The
--   rewrite-role of a constraint] We return ReprEq for (a ~R# b) and NomEq
--   for all other preds
ctEvRewriteEqRel :: CtEvidence -> EqRel

-- | Set the type of CtEvidence.
--   
--   This function ensures that the invariants on <a>CtEvidence</a> hold,
--   by updating the evidence and the ctev_pred in sync with each other.
--   See Note [CtEvidence invariants].
setCtEvPredType :: HasDebugCallStack => CtEvidence -> Type -> CtEvidence
setCtEvLoc :: CtEvidence -> CtLoc -> CtEvidence

-- | Returns free variables of constraints as a deterministically ordered
--   list. See Note [Deterministic FV] in GHC.Utils.FV.
tyCoVarsOfCtEvList :: CtEvidence -> [TcTyCoVar]

-- | Returns free variables of constraints as a non-deterministic set
tyCoVarsOfCtEv :: CtEvidence -> TcTyCoVarSet

-- | Returns free variables of a bag of constraints as a deterministically
--   ordered list. See Note [Deterministic FV] in GHC.Utils.FV.
tyCoVarsOfCtEvsList :: [CtEvidence] -> [TcTyCoVar]

-- | Stores a set of CoercionHoles that have been used to rewrite a
--   constraint. See Note [Wanteds rewrite Wanteds].
newtype RewriterSet
RewriterSet :: UniqSet CoercionHole -> RewriterSet
emptyRewriterSet :: RewriterSet
isEmptyRewriterSet :: RewriterSet -> Bool
addRewriter :: RewriterSet -> CoercionHole -> RewriterSet
unitRewriterSet :: CoercionHole -> RewriterSet
unionRewriterSet :: RewriterSet -> RewriterSet -> RewriterSet
rewriterSetFromCts :: Bag Ct -> RewriterSet
wrapType :: Type -> [TyVar] -> [PredType] -> Type
data CtFlavour
Given :: CtFlavour
Wanted :: CtFlavour
ctEvFlavour :: CtEvidence -> CtFlavour

-- | Whether or not one <a>Ct</a> can rewrite another is determined by its
--   flavour and its equality relation. See also Note [Flavours with roles]
--   in GHC.Tc.Solver.InertSet
type CtFlavourRole = (CtFlavour, EqRel)

-- | Extract the flavour, role, and boxity from a <a>CtEvidence</a>
ctEvFlavourRole :: HasDebugCallStack => CtEvidence -> CtFlavourRole

-- | Extract the flavour and role from a <a>Ct</a>
ctFlavourRole :: HasDebugCallStack => Ct -> CtFlavourRole

-- | Extract the flavour and role from a <a>Ct</a>
eqCtFlavourRole :: EqCt -> CtFlavourRole
eqCanRewrite :: EqRel -> EqRel -> Bool
eqCanRewriteFR :: CtFlavourRole -> CtFlavourRole -> Bool
pprEvVarTheta :: [EvVar] -> SDoc
pprEvVars :: [EvVar] -> SDoc
pprEvVarWithType :: EvVar -> SDoc
instance GHC.Classes.Eq GHC.Tc.Types.Constraint.CheckTyEqProblem
instance GHC.Classes.Eq GHC.Tc.Types.Constraint.CtFlavour
instance GHC.Classes.Eq GHC.Tc.Types.Constraint.HasGivenEqs
instance GHC.Internal.Base.Monoid GHC.Tc.Types.Constraint.CheckTyEqResult
instance GHC.Internal.Base.Monoid GHC.Tc.Types.Constraint.HasGivenEqs
instance GHC.Internal.Base.Monoid GHC.Tc.Types.Constraint.RewriterSet
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.CanEqLHS
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.CheckTyEqProblem
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.CheckTyEqResult
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.Ct
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.CtEvidence
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.CtFlavour
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.CtIrredReason
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.DelayedError
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.DictCt
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.EqCt
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.HasGivenEqs
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.Hole
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.HoleSort
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.ImplicStatus
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.Implication
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.IrredCt
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.NotConcreteError
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.QCInst
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.RewriterSet
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.TcEvDest
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.WantedConstraints
instance GHC.Internal.Base.Semigroup GHC.Tc.Types.Constraint.CheckTyEqResult
instance GHC.Internal.Base.Semigroup GHC.Tc.Types.Constraint.HasGivenEqs
instance GHC.Internal.Base.Semigroup GHC.Tc.Types.Constraint.RewriterSet

module GHC.Tc.Types.TH
data SpliceType
Typed :: SpliceType
Untyped :: SpliceType
data SpliceOrBracket
IsSplice :: SpliceOrBracket
IsBracket :: SpliceOrBracket
data ThStage
Splice :: SpliceType -> ThStage
RunSplice :: TcRef [ForeignRef (Q ())] -> ThStage
Comp :: ThStage
Brack :: ThStage -> PendingStuff -> ThStage
data PendingStuff
RnPendingUntyped :: TcRef [PendingRnSplice] -> PendingStuff
RnPendingTyped :: PendingStuff
TcPending :: TcRef [PendingTcSplice] -> TcRef WantedConstraints -> QuoteWrapper -> PendingStuff
type ThLevel = Int
topStage :: ThStage
topAnnStage :: ThStage
topSpliceStage :: ThStage
thLevel :: ThStage -> ThLevel
impLevel :: ThLevel
outerLevel :: ThLevel
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.TH.ThStage

module GHC.Tc.Errors.Hole.FitTypes
data TypedHole
TypedHole :: Bag CtEvidence -> [Implication] -> Maybe Hole -> TypedHole

-- | Any relevant Cts to the hole
[th_relevant_cts] :: TypedHole -> Bag CtEvidence

-- | The nested implications of the hole with the innermost implication
--   first.
[th_implics] :: TypedHole -> [Implication]

-- | The hole itself, if available.
[th_hole] :: TypedHole -> Maybe Hole

-- | HoleFit is the type we use for valid hole fits. It contains the
--   element that was checked, the Id of that element as found by
--   <tt>tcLookup</tt>, and the refinement level of the fit, which is the
--   number of extra argument holes that this fit uses (e.g. if hfRefLvl is
--   2, the fit is for `Id _ _`).
data HoleFit
HoleFit :: Id -> HoleFitCandidate -> TcType -> Int -> [TcType] -> [TcType] -> Maybe [HsDocString] -> HoleFit

-- | The elements id in the TcM
[hfId] :: HoleFit -> Id

-- | The candidate that was checked.
[hfCand] :: HoleFit -> HoleFitCandidate

-- | The type of the id, possibly zonked.
[hfType] :: HoleFit -> TcType

-- | The number of holes in this fit.
[hfRefLvl] :: HoleFit -> Int

-- | The wrapper for the match.
[hfWrap] :: HoleFit -> [TcType]

-- | What the refinement variables got matched with, if anything
[hfMatches] :: HoleFit -> [TcType]

-- | Documentation of this HoleFit, if available.
[hfDoc] :: HoleFit -> Maybe [HsDocString]

-- | A fit that is just displayed as is. Here so thatHoleFitPlugins can
--   inject any fit they want.
RawHoleFit :: SDoc -> HoleFit

-- | HoleFitCandidates are passed to hole fit plugins and then checked
--   whether they fit a given typed-hole.
data HoleFitCandidate
IdHFCand :: Id -> HoleFitCandidate
NameHFCand :: Name -> HoleFitCandidate
GreHFCand :: GlobalRdrElt -> HoleFitCandidate
hfIsLcl :: HoleFit -> Bool
pprHoleFitCand :: HoleFitCandidate -> SDoc
instance GHC.Classes.Eq GHC.Tc.Errors.Hole.FitTypes.HoleFit
instance GHC.Classes.Eq GHC.Tc.Errors.Hole.FitTypes.HoleFitCandidate
instance GHC.Types.Name.Occurrence.HasOccName GHC.Tc.Errors.Hole.FitTypes.HoleFitCandidate
instance GHC.Types.Name.NamedThing GHC.Tc.Errors.Hole.FitTypes.HoleFitCandidate
instance GHC.Classes.Ord GHC.Tc.Errors.Hole.FitTypes.HoleFit
instance GHC.Classes.Ord GHC.Tc.Errors.Hole.FitTypes.HoleFitCandidate
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Hole.FitTypes.HoleFit
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Hole.FitTypes.HoleFitCandidate
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Hole.FitTypes.TypedHole


-- | Utility types used within the constraint solver
module GHC.Tc.Solver.Types
type DictMap a = TcAppMap a
emptyDictMap :: DictMap a
findDictsByTyConKey :: DictMap a -> Unique -> Bag a
findDictsByClass :: DictMap a -> Class -> Bag a
foldDicts :: (a -> b -> b) -> DictMap a -> b -> b
findDict :: DictMap a -> CtLoc -> Class -> [Type] -> Maybe a
dictsToBag :: DictMap a -> Bag a
type FunEqMap a = TcAppMap a
emptyFunEqs :: TcAppMap a
findFunEq :: FunEqMap a -> TyCon -> [Type] -> Maybe a
insertFunEq :: FunEqMap a -> TyCon -> [Type] -> a -> FunEqMap a
findFunEqsByTyCon :: FunEqMap a -> TyCon -> [a]
type TcAppMap a = DTyConEnv ListMap LooseTypeMap a
emptyTcAppMap :: TcAppMap a
isEmptyTcAppMap :: TcAppMap a -> Bool
insertTcApp :: TcAppMap a -> TyCon -> [Type] -> a -> TcAppMap a
alterTcApp :: TcAppMap a -> TyCon -> [Type] -> XT a -> TcAppMap a
filterTcAppMap :: (a -> Bool) -> TcAppMap a -> TcAppMap a
tcAppMapToBag :: TcAppMap a -> Bag a
foldTcAppMap :: (a -> b -> b) -> TcAppMap a -> b -> b
delTcApp :: TcAppMap a -> TyCon -> [Type] -> TcAppMap a
type EqualCtList = [EqCt]
filterEqualCtList :: (EqCt -> Bool) -> EqualCtList -> Maybe EqualCtList
addToEqualCtList :: EqCt -> EqualCtList -> EqualCtList

module GHC.Tc.Solver.InertSet
data WorkList
WL :: [Ct] -> [Ct] -> [Ct] -> [Ct] -> Bag Implication -> WorkList
[wl_eqs_N] :: WorkList -> [Ct]
[wl_eqs_X] :: WorkList -> [Ct]
[wl_rw_eqs] :: WorkList -> [Ct]
[wl_rest] :: WorkList -> [Ct]
[wl_implics] :: WorkList -> Bag Implication
isEmptyWorkList :: WorkList -> Bool
emptyWorkList :: WorkList
extendWorkListNonEq :: Ct -> WorkList -> WorkList
extendWorkListCt :: Ct -> WorkList -> WorkList
extendWorkListCts :: Cts -> WorkList -> WorkList
extendWorkListCtList :: [Ct] -> WorkList -> WorkList
extendWorkListEq :: RewriterSet -> Ct -> WorkList -> WorkList
extendWorkListEqs :: RewriterSet -> Bag Ct -> WorkList -> WorkList
appendWorkList :: WorkList -> WorkList -> WorkList
extendWorkListImplic :: Implication -> WorkList -> WorkList
workListSize :: WorkList -> Int
selectWorkItem :: WorkList -> Maybe (Ct, WorkList)
data InertSet
IS :: InertCans -> CycleBreakerVarStack -> FunEqMap Reduction -> DictMap DictCt -> InertSet
[inert_cans] :: InertSet -> InertCans
[inert_cycle_breakers] :: InertSet -> CycleBreakerVarStack
[inert_famapp_cache] :: InertSet -> FunEqMap Reduction
[inert_solved_dicts] :: InertSet -> DictMap DictCt
data InertCans
IC :: InertEqs -> InertFunEqs -> DictMap DictCt -> [QCInst] -> DictMap DictCt -> InertIrreds -> TcLevel -> Bool -> InertCans
[inert_eqs] :: InertCans -> InertEqs
[inert_funeqs] :: InertCans -> InertFunEqs
[inert_dicts] :: InertCans -> DictMap DictCt
[inert_insts] :: InertCans -> [QCInst]

-- | See Note [Safe Haskell Overlapping Instances Implementation] in
--   GHC.Tc.Solver
[inert_safehask] :: InertCans -> DictMap DictCt
[inert_irreds] :: InertCans -> InertIrreds
[inert_given_eq_lvl] :: InertCans -> TcLevel
[inert_given_eqs] :: InertCans -> Bool
emptyInert :: InertSet

-- | Returns True iff there are no Given constraints that might,
--   potentially, match the given class constraint. This is used when
--   checking to see if a Given might overlap with an instance. See Note
--   [Instance and Given overlap] in GHC.Tc.Solver.Dict
noMatchableGivenDicts :: InertSet -> CtLoc -> Class -> [TcType] -> Bool
noGivenNewtypeReprEqs :: TyCon -> InertSet -> Bool
updGivenEqs :: TcLevel -> Ct -> InertCans -> InertCans
mightEqualLater :: InertSet -> TcPredType -> CtLoc -> TcPredType -> CtLoc -> Maybe Subst

-- | Is it (potentially) loopy to use the first <tt>ct1</tt> to solve
--   <tt>ct2</tt>?
--   
--   Necessary (but not sufficient) conditions for this function to return
--   <tt>True</tt>:
--   
--   <ul>
--   <li><tt>ct1</tt> and <tt>ct2</tt> both arise from superclass
--   expansion,</li>
--   <li><tt>ct1</tt> is a Given and <tt>ct2</tt> is a Wanted.</li>
--   </ul>
--   
--   See Note [Solving superclass constraints] in GHC.Tc.TyCl.Instance,
--   (sc2).
prohibitedSuperClassSolve :: CtLoc -> CtLoc -> Bool
type InertEqs = DTyVarEnv EqualCtList
foldTyEqs :: (EqCt -> b -> b) -> InertEqs -> b -> b
delEq :: EqCt -> InertCans -> InertCans
findEq :: InertCans -> CanEqLHS -> [EqCt]
partitionInertEqs :: (EqCt -> Bool) -> InertEqs -> ([EqCt], InertEqs)
partitionFunEqs :: (EqCt -> Bool) -> InertFunEqs -> ([EqCt], InertFunEqs)
foldFunEqs :: (EqCt -> b -> b) -> FunEqMap EqualCtList -> b -> b
addEqToCans :: TcLevel -> EqCt -> InertCans -> InertCans
updDicts :: (DictMap DictCt -> DictMap DictCt) -> InertCans -> InertCans
delDict :: DictCt -> DictMap a -> DictMap a
addDict :: DictCt -> DictMap DictCt -> DictMap DictCt
filterDicts :: (DictCt -> Bool) -> DictMap DictCt -> DictMap DictCt
partitionDicts :: (DictCt -> Bool) -> DictMap DictCt -> (Bag DictCt, DictMap DictCt)
addSolvedDict :: DictCt -> DictMap DictCt -> DictMap DictCt
type InertIrreds = Bag IrredCt
delIrred :: IrredCt -> InertCans -> InertCans
addIrreds :: [IrredCt] -> InertIrreds -> InertIrreds
addIrred :: IrredCt -> InertIrreds -> InertIrreds
foldIrreds :: (IrredCt -> b -> b) -> InertIrreds -> b -> b
findMatchingIrreds :: InertIrreds -> CtEvidence -> (Bag (IrredCt, SwapFlag), InertIrreds)
updIrreds :: (InertIrreds -> InertIrreds) -> InertCans -> InertCans
addIrredToCans :: TcLevel -> IrredCt -> InertCans -> InertCans
data KickOutSpec
KOAfterUnify :: TcTyVarSet -> KickOutSpec
KOAfterAdding :: CanEqLHS -> KickOutSpec
kickOutRewritableLHS :: KickOutSpec -> CtFlavourRole -> InertCans -> (Cts, InertCans)
type CycleBreakerVarStack = NonEmpty Bag (TcTyVar, TcType)

-- | Push a fresh environment onto the cycle-breaker var stack. Useful when
--   entering a nested implication.
pushCycleBreakerVarStack :: CycleBreakerVarStack -> CycleBreakerVarStack

-- | Add a new cycle-breaker binding to the top environment on the stack.
addCycleBreakerBindings :: Bag (TcTyVar, Type) -> InertSet -> InertSet

-- | Perform a monadic operation on all pairs in the top environment in the
--   stack.
forAllCycleBreakerBindings_ :: Monad m => CycleBreakerVarStack -> (TcTyVar -> TcType -> m ()) -> m ()
data InteractResult
KeepInert :: InteractResult
KeepWork :: InteractResult
solveOneFromTheOther :: Ct -> Ct -> InteractResult
instance GHC.Classes.Eq GHC.Tc.Solver.InertSet.WhereToLook
instance GHC.Utils.Outputable.Outputable GHC.Tc.Solver.InertSet.InertCans
instance GHC.Utils.Outputable.Outputable GHC.Tc.Solver.InertSet.InertSet
instance GHC.Utils.Outputable.Outputable GHC.Tc.Solver.InertSet.InteractResult
instance GHC.Utils.Outputable.Outputable GHC.Tc.Solver.InertSet.KickOutSpec
instance GHC.Utils.Outputable.Outputable GHC.Tc.Solver.InertSet.WorkList


-- | Domain types used in <a>GHC.HsToCore.Pmc.Solver</a>. The ultimate goal
--   is to define <a>Nabla</a>, which models normalised refinement types
--   from the paper <a>Lower Your Guards: A Compositional Pattern-Match
--   Coverage Checker"</a>.
module GHC.HsToCore.Pmc.Solver.Types

-- | See <a>vi_bot</a>.
data BotInfo
IsBot :: BotInfo
IsNotBot :: BotInfo
MaybeBot :: BotInfo
data PmAltConApp
PACA :: !PmAltCon -> ![TyVar] -> ![Id] -> PmAltConApp
[paca_con] :: PmAltConApp -> !PmAltCon
[paca_tvs] :: PmAltConApp -> ![TyVar]
[paca_ids] :: PmAltConApp -> ![Id]

-- | Information about an <a>Id</a>. Stores positive (<a>vi_pos</a>) facts,
--   like <tt>x ~ Just 42</tt>, and negative (<a>vi_neg</a>) facts, like "x
--   is not (:)". Also caches the type (<tt>vi_ty</tt>), the
--   <a>ResidualCompleteMatches</a> of a COMPLETE set (<a>vi_rcm</a>).
--   
--   Subject to Note [The Pos/Neg invariant] in
--   <a>GHC.HsToCore.Pmc.Solver</a>.
data VarInfo
VI :: !Id -> ![PmAltConApp] -> !PmAltConSet -> BotInfo -> !ResidualCompleteMatches -> VarInfo

-- | The <a>Id</a> in question. Important for adding new constraints
--   relative to this <a>VarInfo</a> when we don't easily have the
--   <a>Id</a> available.
[vi_id] :: VarInfo -> !Id

-- | Positive info: <a>PmAltCon</a> apps it is (i.e. <tt>x ~ [Just y,
--   PatSyn z]</tt>), all at the same time (i.e. conjunctive). We need a
--   list because of nested pattern matches involving pattern synonym case
--   x of { Just y -&gt; case x of PatSyn z -&gt; ... } However, no more
--   than one RealDataCon in the list, otherwise contradiction because of
--   generativity.
[vi_pos] :: VarInfo -> ![PmAltConApp]

-- | Negative info: A list of <a>PmAltCon</a>s that it cannot match.
--   Example, assuming
--   
--   <pre>
--   data T = Leaf Int | Branch T T | Node Int T
--   </pre>
--   
--   then <tt>x ≁ [Leaf, Node]</tt> means that <tt>x</tt> cannot match a
--   <tt>Leaf</tt> or <tt>Node</tt>, and hence can only match
--   <tt>Branch</tt>. Is orthogonal to anything from <a>vi_pos</a>, in the
--   sense that <a>eqPmAltCon</a> returns <tt>PossiblyOverlap</tt> for any
--   pairing between <a>vi_pos</a> and <a>vi_neg</a>.
[vi_neg] :: VarInfo -> !PmAltConSet

-- | Can this variable be ⊥? Models (mutually contradicting) <tt>x ~ ⊥</tt>
--   and <tt>x ≁ ⊥</tt> constraints. E.g. * <a>MaybeBot</a>: Don't know;
--   Neither <tt>x ~ ⊥</tt> nor <tt>x ≁ ⊥</tt>. * <a>IsBot</a>: <tt>x ~
--   ⊥</tt> * <a>IsNotBot</a>: <tt>x ≁ ⊥</tt>
[vi_bot] :: VarInfo -> BotInfo

-- | A cache of the associated COMPLETE sets. At any time a superset of
--   possible constructors of each COMPLETE set. So, if it's not in here,
--   we can't possibly match on it. Complementary to <a>vi_neg</a>. We
--   still need it to recognise completion of a COMPLETE set efficiently
--   for large enums.
[vi_rcm] :: VarInfo -> !ResidualCompleteMatches

-- | The term oracle state. Stores <a>VarInfo</a> for encountered
--   <a>Id</a>s. These entries are possibly shared when we figure out that
--   two variables must be equal, thus represent the same set of values.
--   
--   See Note [TmState invariants] in <a>GHC.HsToCore.Pmc.Solver</a>.
data TmState
TmSt :: !UniqSDFM Id VarInfo -> !CoreMap Id -> !DIdSet -> TmState

-- | Facts about term variables. Deterministic env, so that we generate
--   deterministic error messages.
[ts_facts] :: TmState -> !UniqSDFM Id VarInfo

-- | An environment for looking up whether we already encountered
--   semantically equivalent expressions that we want to represent by the
--   same <a>Id</a> representative.
[ts_reps] :: TmState -> !CoreMap Id

-- | Which <a>VarInfo</a> needs to be checked for inhabitants because of
--   new negative constraints (e.g. <tt>x ≁ ⊥</tt> or <tt>x ≁ K</tt>).
[ts_dirty] :: TmState -> !DIdSet

-- | The type oracle state. An <a>InertSet</a> that we incrementally add
--   local type constraints to, together with a sequence number that counts
--   the number of times we extended it with new facts.
data TyState
TySt :: !Int -> !InertSet -> TyState
[ty_st_n] :: TyState -> !Int
[ty_st_inert] :: TyState -> !InertSet

-- | A normalised refinement type ∇ ("nabla"), comprised of an inert set of
--   canonical (i.e. mutually compatible) term and type constraints that
--   form the refinement type's predicate.
data Nabla
MkNabla :: !TyState -> !TmState -> Nabla

-- | Type oracle; things like a~Int
[nabla_ty_st] :: Nabla -> !TyState

-- | Term oracle; things like x~Nothing
[nabla_tm_st] :: Nabla -> !TmState

-- | A disjunctive bag of <a>Nabla</a>s, representing a refinement type.
newtype Nablas
MkNablas :: Bag Nabla -> Nablas
initNablas :: Nablas
lookupRefuts :: Nabla -> Id -> [PmAltCon]
lookupSolution :: Nabla -> Id -> Maybe PmAltConApp
lookupVarInfo :: TmState -> Id -> VarInfo

-- | Like <tt>lookupVarInfo ts x</tt>, but <tt>lookupVarInfo ts x = (y,
--   vi)</tt> also looks through newtype constructors. We have <tt>x ~ N1
--   (... (Nk y))</tt> such that the returned <tt>y</tt> doesn't have a
--   positive newtype constructor constraint associated with it (yet). The
--   <a>VarInfo</a> returned is that of <tt>y</tt>'s representative.
--   
--   Careful, this means that <tt>idType x</tt> might be different to
--   <tt>idType y</tt>, even modulo type normalisation!
--   
--   See also Note [Coverage checking Newtype matches] in
--   GHC.HsToCore.Pmc.Solver.
lookupVarInfoNT :: TmState -> Id -> (Id, VarInfo)
trvVarInfo :: Functor f => (VarInfo -> f (a, VarInfo)) -> Nabla -> Id -> f (a, Nabla)
type CompleteMatch = CompleteMatchX Name

-- | A data type that caches for the <a>VarInfo</a> of <tt>x</tt> the
--   results of querying <tt>dsGetCompleteMatches</tt> and then striking
--   out all occurrences of <tt>K</tt> for which we already know <tt>x ≁
--   K</tt> from these sets.
--   
--   For motivation, see Section 5.3 in Lower Your Guards. See also Note
--   [Implementation of COMPLETE pragmas]
data ResidualCompleteMatches
RCM :: !Maybe DsCompleteMatch -> !Maybe DsCompleteMatches -> ResidualCompleteMatches

-- | The residual set for the vanilla COMPLETE set from the data defn.
--   Tracked separately from <a>rcm_pragmas</a>, because it might only be
--   known much later (when we have enough type information to see the
--   <a>TyCon</a> of the match), or not at all even. Until that happens, it
--   is <a>Nothing</a>.
[rcm_vanilla] :: ResidualCompleteMatches -> !Maybe DsCompleteMatch

-- | The residual sets for <i>all</i> COMPLETE sets from pragmas that are
--   visible when compiling this module. Querying that set with
--   <tt>dsGetCompleteMatches</tt> requires <tt>DsM</tt>, so we initialise
--   it with <a>Nothing</a> until first needed in a <tt>DsM</tt> context.
[rcm_pragmas] :: ResidualCompleteMatches -> !Maybe DsCompleteMatches
getRcm :: ResidualCompleteMatches -> DsCompleteMatches
isRcmInitialised :: ResidualCompleteMatches -> Bool

-- | Literals (simple and overloaded ones) for pattern match checking.
--   
--   See Note [Undecidable Equality for PmAltCons]
data PmLit
PmLit :: Type -> PmLitValue -> PmLit
[pm_lit_ty] :: PmLit -> Type
[pm_lit_val] :: PmLit -> PmLitValue
data PmLitValue
PmLitInt :: Integer -> PmLitValue
PmLitRat :: Rational -> PmLitValue
PmLitChar :: Char -> PmLitValue
PmLitString :: FastString -> PmLitValue
PmLitOverInt :: Int -> Integer -> PmLitValue
PmLitOverRat :: Int -> FractionalLit -> PmLitValue
PmLitOverString :: FastString -> PmLitValue

-- | Represents the head of a match against a <a>ConLike</a> or literal.
--   Really similar to <a>AltCon</a>.
data PmAltCon
PmAltConLike :: ConLike -> PmAltCon
PmAltLit :: PmLit -> PmAltCon

-- | Type of a <a>PmLit</a>
pmLitType :: PmLit -> Type

-- | Type of a <a>PmAltCon</a>
pmAltConType :: PmAltCon -> [Type] -> Type

-- | Is a match on this constructor forcing the match variable? True of
--   data constructors, literals and pattern synonyms (#17357), but not of
--   newtypes. See Note [Coverage checking Newtype matches] in
--   GHC.HsToCore.Pmc.Solver.
isPmAltConMatchStrict :: PmAltCon -> Bool
pmAltConImplBangs :: PmAltCon -> [HsImplBang]
data PmAltConSet
emptyPmAltConSet :: PmAltConSet
isEmptyPmAltConSet :: PmAltConSet -> Bool

-- | Whether there is a <a>PmAltCon</a> in the <a>PmAltConSet</a> that
--   compares <a>Equal</a> to the given <a>PmAltCon</a> according to
--   <a>eqPmAltCon</a>.
elemPmAltConSet :: PmAltCon -> PmAltConSet -> Bool
extendPmAltConSet :: PmAltConSet -> PmAltCon -> PmAltConSet
pmAltConSetElems :: PmAltConSet -> [PmAltCon]

-- | Undecidable semantic equality result. See Note [Undecidable Equality
--   for PmAltCons]
data PmEquality
Equal :: PmEquality
Disjoint :: PmEquality
PossiblyOverlap :: PmEquality

-- | We can't in general decide whether two <a>PmAltCon</a>s match the same
--   set of values. In addition to the reasons in <a>eqPmLit</a> and
--   <a>eqConLike</a>, a <a>PmAltConLike</a> might or might not represent
--   the same value as a <a>PmAltLit</a>. See Note [Undecidable Equality
--   for PmAltCons].
--   
--   <ul>
--   <li><tt>Just True</tt> ==&gt; Surely equal</li>
--   <li><tt>Just False</tt> ==&gt; Surely different (non-overlapping,
--   even!)</li>
--   <li><tt>Nothing</tt> ==&gt; Equality relation undecidable</li>
--   </ul>
--   
--   Examples (omitting some constructor wrapping):
--   
--   <ul>
--   <li><tt>eqPmAltCon (LitInt 42) (LitInt 1) == Just False</tt>: Lit
--   equality is decidable</li>
--   <li><tt>eqPmAltCon (DataCon A) (DataCon B) == Just False</tt>: DataCon
--   equality is decidable</li>
--   <li><tt>eqPmAltCon (LitOverInt 42) (LitOverInt 1) == Nothing</tt>:
--   OverLit equality is undecidable</li>
--   <li><tt>eqPmAltCon (PatSyn PA) (PatSyn PB) == Nothing</tt>: PatSyn
--   equality is undecidable</li>
--   <li><tt>eqPmAltCon (DataCon I#) (LitInt 1) == Nothing</tt>: DataCon to
--   Lit comparisons are undecidable without reasoning about the wrapped
--   <tt>Int#</tt></li>
--   <li><tt>eqPmAltCon (LitOverInt 1) (LitOverInt 1) == Just True</tt>: We
--   assume reflexivity for overloaded literals</li>
--   <li><tt>eqPmAltCon (PatSyn PA) (PatSyn PA) == Just True</tt>: We
--   assume reflexivity for Pattern Synonyms</li>
--   </ul>
eqPmAltCon :: PmAltCon -> PmAltCon -> PmEquality
literalToPmLit :: Type -> Literal -> Maybe PmLit
negatePmLit :: PmLit -> Maybe PmLit
overloadPmLit :: Type -> PmLit -> Maybe PmLit
pmLitAsStringLit :: PmLit -> Maybe FastString
coreExprAsPmLit :: CoreExpr -> Maybe PmLit
instance GHC.Classes.Eq GHC.HsToCore.Pmc.Solver.Types.BotInfo
instance GHC.Classes.Eq GHC.HsToCore.Pmc.Solver.Types.PmAltCon
instance GHC.Classes.Eq GHC.HsToCore.Pmc.Solver.Types.PmEquality
instance GHC.Classes.Eq GHC.HsToCore.Pmc.Solver.Types.PmLit
instance GHC.Internal.Base.Monoid GHC.HsToCore.Pmc.Solver.Types.Nablas
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.BotInfo
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.Nabla
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.Nablas
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.PmAltCon
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.PmAltConApp
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.PmAltConSet
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.PmEquality
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.PmLit
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.PmLitValue
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.ResidualCompleteMatches
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.TmState
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.TyState
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.VarInfo
instance GHC.Internal.Base.Semigroup GHC.HsToCore.Pmc.Solver.Types.Nablas
instance GHC.Internal.Show.Show GHC.HsToCore.Pmc.Solver.Types.PmEquality


-- | Types used through-out pattern match checking. This module is mostly
--   there to be imported from <a>GHC.HsToCore.Types</a>. The exposed API
--   is that of <a>GHC.HsToCore.Pmc</a>.
--   
--   These types model the paper <a>Lower Your Guards: A Compositional
--   Pattern-Match Coverage Checker"</a>.
module GHC.HsToCore.Pmc.Types

-- | Means by which we identify a source construct for later
--   pretty-printing in a warning message. <a>SDoc</a> for the equation to
--   show, <a>Located</a> for the location.
newtype SrcInfo
SrcInfo :: Located SDoc -> SrcInfo

-- | A very simple language for pattern guards. Let bindings, bang
--   patterns, and matching variables against flat constructor patterns.
--   The LYG guard language.
data PmGrd

-- | <tt>PmCon x K dicts args</tt> corresponds to a <tt>K dicts args &lt;-
--   x</tt> guard. The <tt>args</tt> are bound in this construct, the
--   <tt>x</tt> is just a use. For the arguments' meaning see
--   <a>ConPatOut</a>.
PmCon :: !Id -> !PmAltCon -> ![TyVar] -> ![EvVar] -> ![Id] -> PmGrd
[pm_id] :: PmGrd -> !Id
[pm_con_con] :: PmGrd -> !PmAltCon
[pm_con_tvs] :: PmGrd -> ![TyVar]
[pm_con_dicts] :: PmGrd -> ![EvVar]
[pm_con_args] :: PmGrd -> ![Id]

-- | <tt>PmBang x</tt> corresponds to a <tt>seq x True</tt> guard. If the
--   extra <a>SrcInfo</a> is present, the bang guard came from a source
--   bang pattern, in which case we might want to report it as redundant.
--   See Note [Dead bang patterns] in GHC.HsToCore.Pmc.Check.
PmBang :: !Id -> !Maybe SrcInfo -> PmGrd
[pm_id] :: PmGrd -> !Id
[_pm_loc] :: PmGrd -> !Maybe SrcInfo

-- | <tt>PmLet x expr</tt> corresponds to a <tt>let x = expr</tt> guard.
--   This actually <i>binds</i> <tt>x</tt>.
PmLet :: !Id -> !CoreExpr -> PmGrd
[pm_id] :: PmGrd -> !Id
[_pm_let_expr] :: PmGrd -> !CoreExpr

-- | A series-parallel graph of <a>PmGrd</a>s, so very nearly a guard tree,
--   if it weren't for or-patterns/<a>GdAlt</a>! The implicit "source"
--   corresponds to "before the match" and the implicit "sink" corresponds
--   to "after a successful match".
--   
--   <ul>
--   <li><a>GdEnd</a> is a <a>GrdDag</a> that always matches.</li>
--   <li><a>GdOne</a> is a <a>GrdDag</a> that matches iff its <a>PmGrd</a>
--   matches.</li>
--   <li><tt><a>GdSeq</a> g1 g2</tt> corresponds to matching guards
--   <tt>g1</tt> and then <tt>g2</tt> if matching <tt>g1</tt> succeeded.
--   Example: The Haskell guard <tt>| x &gt; 1, x &lt; 10 = ...</tt> will
--   test <tt>x &gt; 1</tt> before <tt>x &lt; 10</tt>, failing if either
--   test fails.</li>
--   <li><tt><a>GdAlt</a> g1 g2</tt> is far less common than <a>GdSeq</a>
--   and corresponds to matching an or-pattern <tt>(LT; EQ)</tt>,
--   succeeding if the match variable matches <i>either</i> <a>LT</a> or
--   <a>EQ</a>. See Note [Implementation of OrPatterns] for a larger
--   example.</li>
--   </ul>
data GrdDag
GdEnd :: GrdDag
GdOne :: !PmGrd -> GrdDag
GdSeq :: !GrdDag -> !GrdDag -> GrdDag
GdAlt :: !GrdDag -> !GrdDag -> GrdDag

-- | Sequentially compose a <a>PmGrd</a> in front of a <a>GrdDag</a>.
consGrdDag :: PmGrd -> GrdDag -> GrdDag

-- | Sequentially compose two <a>GrdDag</a>s. A smart constructor for
--   <a>GdSeq</a> that eliminates <a>GdEnd</a>s.
gdSeq :: GrdDag -> GrdDag -> GrdDag

-- | Sequentially compose a list of <a>PmGrd</a>s into a <a>GrdDag</a>.
sequencePmGrds :: [PmGrd] -> GrdDag

-- | Sequentially compose a list of <a>GrdDag</a>s.
sequenceGrdDags :: [GrdDag] -> GrdDag

-- | Parallel composition of a list of <a>GrdDag</a>s. Needs a non-empty
--   list as <a>GdAlt</a> does not have a neutral element.
alternativesGrdDags :: NonEmpty GrdDag -> GrdDag

-- | A guard tree denoting <tt>MatchGroup</tt>.
newtype PmMatchGroup p
PmMatchGroup :: NonEmpty (PmMatch p) -> PmMatchGroup p

-- | A guard tree denoting <tt>Match</tt>: A payload describing the pats
--   and a bunch of GRHS.
data PmMatch p
PmMatch :: !p -> !PmGRHSs p -> PmMatch p
[pm_pats] :: PmMatch p -> !p
[pm_grhss] :: PmMatch p -> !PmGRHSs p

-- | A guard tree denoting <tt>GRHSs</tt>: A bunch of <a>PmLet</a> guards
--   for local bindings from the <tt>GRHSs</tt>s <tt>where</tt> clauses and
--   the actual list of <tt>GRHS</tt>. See Note [Long-distance information
--   for HsLocalBinds] in <a>GHC.HsToCore.Pmc.Desugar</a>.
data PmGRHSs p
PmGRHSs :: !p -> !NonEmpty (PmGRHS p) -> PmGRHSs p
[pgs_lcls] :: PmGRHSs p -> !p
[pgs_grhss] :: PmGRHSs p -> !NonEmpty (PmGRHS p)

-- | A guard tree denoting <tt>GRHS</tt>: A payload describing the grds and
--   a <a>SrcInfo</a> useful for printing out in warnings messages.
data PmGRHS p
PmGRHS :: !p -> !SrcInfo -> PmGRHS p
[pg_grds] :: PmGRHS p -> !p
[pg_rhs] :: PmGRHS p -> !SrcInfo

-- | A guard tree denoting a pattern binding.
newtype PmPatBind p
PmPatBind :: PmGRHS p -> PmPatBind p

-- | A guard tree denoting an -XEmptyCase.
newtype PmEmptyCase
PmEmptyCase :: Id -> PmEmptyCase
[pe_var] :: PmEmptyCase -> Id
data PmRecSel v
PmRecSel :: v -> CoreExpr -> [ConLike] -> PmRecSel v
[pr_arg_var] :: PmRecSel v -> v
[pr_arg] :: PmRecSel v -> CoreExpr
[pr_cons] :: PmRecSel v -> [ConLike]

-- | Redundancy sets, used to determine redundancy of RHSs and bang
--   patterns (later digested into a <tt>CIRB</tt>).
data RedSets
RedSets :: !Nablas -> !Nablas -> !OrdList (Nablas, SrcInfo) -> RedSets

-- | The <i>Covered</i> set; the set of values reaching a particular
--   program point.
[rs_cov] :: RedSets -> !Nablas

-- | The <i>Diverging</i> set; empty if no match can lead to divergence. If
--   it wasn't empty, we have to turn redundancy warnings into
--   inaccessibility warnings for any subclauses.
[rs_div] :: RedSets -> !Nablas

-- | If any of the <a>Nablas</a> is empty, the corresponding <a>SrcInfo</a>
--   pin-points a bang pattern in source that is redundant. See Note [Dead
--   bang patterns].
[rs_bangs] :: RedSets -> !OrdList (Nablas, SrcInfo)
data Precision
Approximate :: Precision
Precise :: Precision

-- | Pattern-match coverage check result
data CheckResult a
CheckResult :: !a -> !Nablas -> !Precision -> CheckResult a

-- | A hole for redundancy info and covered sets.
[cr_ret] :: CheckResult a -> !a

-- | The set of uncovered values falling out at the bottom. (for
--   -Wincomplete-patterns, but also important state for the algorithm)
[cr_uncov] :: CheckResult a -> !Nablas

-- | A flag saying whether we ran into the <tt>maxPmCheckModels</tt> limit
--   for the purpose of suggesting to crank it up in the warning message.
--   Writer state.
[cr_approx] :: CheckResult a -> !Precision

-- | Used as tree payload pre-checking. The LYG guards to check.
type Pre = GrdDag

-- | Used as tree payload post-checking. The redundancy info we elaborated.
type Post = RedSets
instance GHC.Classes.Eq GHC.HsToCore.Pmc.Types.Precision
instance GHC.Internal.Base.Functor GHC.HsToCore.Pmc.Types.CheckResult
instance GHC.Internal.Base.Monoid GHC.HsToCore.Pmc.Types.Precision
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.HsToCore.Pmc.Types.CheckResult a)
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Types.GrdDag
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Types.PmEmptyCase
instance GHC.Utils.Outputable.Outputable p => GHC.Utils.Outputable.Outputable (GHC.HsToCore.Pmc.Types.PmGRHS p)
instance GHC.Utils.Outputable.Outputable p => GHC.Utils.Outputable.Outputable (GHC.HsToCore.Pmc.Types.PmGRHSs p)
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Types.PmGrd
instance GHC.Utils.Outputable.Outputable p => GHC.Utils.Outputable.Outputable (GHC.HsToCore.Pmc.Types.PmMatch p)
instance GHC.Utils.Outputable.Outputable p => GHC.Utils.Outputable.Outputable (GHC.HsToCore.Pmc.Types.PmMatchGroup p)
instance GHC.Utils.Outputable.Outputable p => GHC.Utils.Outputable.Outputable (GHC.HsToCore.Pmc.Types.PmPatBind p)
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Types.Precision
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Types.RedSets
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Types.SrcInfo
instance GHC.Internal.Base.Semigroup GHC.HsToCore.Pmc.Types.Precision
instance GHC.Internal.Show.Show GHC.HsToCore.Pmc.Types.Precision


-- | Provides facilities for pretty-printing <a>Nabla</a>s in a way
--   appropriate for user facing pattern match warnings.
module GHC.HsToCore.Pmc.Ppr

-- | Pretty-print the guts of an uncovered value vector abstraction, i.e.,
--   its components and refutable shapes associated to any mentioned
--   variables.
--   
--   Example for <tt>([Just p, q], [p :-&gt; [3,4], q :-&gt; [0,5]])</tt>:
--   
--   <pre>
--   (Just p) q
--       where p is not one of {3, 4}
--             q is not one of {0, 5}
--   </pre>
--   
--   When the set of refutable shapes contains more than 3 elements, the
--   additional elements are indicated by "...".
pprUncovered :: Nabla -> [Id] -> SDoc

module GHC.Parser.Errors.Types
type PsWarning = PsMessage
type PsError = PsMessage
data PsHeaderMessage
PsErrParseLanguagePragma :: PsHeaderMessage
PsErrUnsupportedExt :: !String -> ![String] -> PsHeaderMessage
PsErrParseOptionsPragma :: !String -> PsHeaderMessage

-- | PsErrUnsupportedOptionsPragma is an error that occurs when an unknown
--   OPTIONS_GHC pragma is supplied is found.
--   
--   Example(s): {-# OPTIONS_GHC foo #-}
--   
--   Test case(s):
--   
--   tests<i>safeHaskell</i>flags/SafeFlags28
--   tests<i>safeHaskell</i>flags/SafeFlags19
--   tests<i>safeHaskell</i>flags/SafeFlags29
--   tests<i>parser</i>should_fail/T19923c
--   tests<i>parser</i>should_fail/T19923b
--   tests<i>parser</i>should_fail/readFail044 tests<i>driver</i>T2499
PsErrUnknownOptionsPragma :: !String -> PsHeaderMessage
data PsMessage

-- | An "unknown" message from the parser. This type constructor allows
--   arbitrary messages to be embedded. The typical use case would be GHC
--   plugins willing to emit custom diagnostics.
PsUnknownMessage :: UnknownDiagnostic (DiagnosticOpts PsMessage) -> PsMessage

-- | A group of parser messages emitted in <a>Header</a>. See Note
--   [Messages from GHC.Parser.Header].
PsHeaderMessage :: !PsHeaderMessage -> PsMessage

-- | PsWarnBidirectionalFormatChars is a warning (controlled by the
--   -Wwarn-bidirectional-format-characters flag) that occurs when unicode
--   bi-directional format characters are found within in a file
--   
--   The <a>PsLoc</a> contains the exact position in the buffer the
--   character occurred, and the string contains a description of the
--   character.
PsWarnBidirectionalFormatChars :: NonEmpty (PsLoc, Char, String) -> PsMessage

-- | PsWarnTab is a warning (controlled by the -Wwarn-tabs flag) that
--   occurs when tabulations (tabs) are found within a file.
--   
--   Test case(s): parser<i>should_fail</i>T12610
--   parser<i>should_compile</i>T9723b parser<i>should_compile</i>T9723a
--   parser<i>should_compile</i>read043 parser<i>should_fail</i>T16270
--   warnings<i>should_compile</i>T9230
PsWarnTab :: !Word -> PsMessage

-- | PsWarnTransitionalLayout is a warning (controlled by the
--   -Walternative-layout-rule-transitional flag) that occurs when pipes
--   ('|') or 'where' are at the same depth of an implicit layout block.
--   
--   Example(s):
--   
--   f :: IO () f | True = do let x = () y = () return () | True = return
--   ()
--   
--   Test case(s): layout/layout006 layout/layout003 layout/layout001
PsWarnTransitionalLayout :: !TransLayoutReason -> PsMessage

-- | Unrecognised pragma. First field is the actual pragma name which might
--   be empty. Second field is the set of valid candidate pragmas.
PsWarnUnrecognisedPragma :: !String -> ![String] -> PsMessage
PsWarnMisplacedPragma :: !FileHeaderPragmaType -> PsMessage

-- | Invalid Haddock comment position
PsWarnHaddockInvalidPos :: PsMessage

-- | Multiple Haddock comment for the same entity
PsWarnHaddockIgnoreMulti :: PsMessage

-- | Found binding occurrence of "*" while StarIsType is enabled
PsWarnStarBinder :: PsMessage

-- | Using "*" for <a>Type</a> without StarIsType enabled
PsWarnStarIsType :: PsMessage

-- | Pre qualified import with <tt>WarnPrepositiveQualifiedModule</tt>
--   enabled
PsWarnImportPreQualified :: PsMessage
PsWarnOperatorWhitespaceExtConflict :: !OperatorWhitespaceSymbol -> PsMessage
PsWarnOperatorWhitespace :: !FastString -> !OperatorWhitespaceOccurrence -> PsMessage

-- | PsWarnViewPatternSignatures is a warning triggered by view patterns
--   whose RHS is an unparenthesised pattern signature. It warns on code
--   that is highly likely to break when the precedence of view patterns
--   relative to pattern signatures is changed per GHC Proposal #281. The
--   suggested fix is to add parentheses.
--   
--   Example: f1 (isJust -&gt; True :: Bool) = ()
--   
--   Suggested fix: f1 (isJust -&gt; (True :: Bool)) = ()
--   
--   Test cases: T24159_viewpat
PsWarnViewPatternSignatures :: !LPat GhcPs -> !LPat GhcPs -> PsMessage

-- | LambdaCase syntax used without the extension enabled
PsErrLambdaCase :: PsMessage

-- | A lambda requires at least one parameter
PsErrEmptyLambda :: PsMessage

-- | Underscores in literals without the extension enabled
PsErrNumUnderscores :: !NumUnderscoreReason -> PsMessage

-- | Invalid character in primitive string
PsErrPrimStringInvalidChar :: PsMessage

-- | Missing block
PsErrMissingBlock :: PsMessage

-- | Lexer error
PsErrLexer :: !LexErr -> !LexErrKind -> PsMessage

-- | Suffix occurrence of <tt>@</tt>
PsErrSuffixAT :: PsMessage

-- | Parse errors
PsErrParse :: !String -> !PsErrParseDetails -> PsMessage

-- | Cmm lexer error
PsErrCmmLexer :: PsMessage

-- | Unsupported boxed sum in expression
PsErrUnsupportedBoxedSumExpr :: !SumOrTuple (HsExpr GhcPs) -> PsMessage

-- | Unsupported boxed sum in pattern
PsErrUnsupportedBoxedSumPat :: !SumOrTuple (PatBuilder GhcPs) -> PsMessage

-- | Unexpected qualified constructor
PsErrUnexpectedQualifiedConstructor :: !RdrName -> PsMessage

-- | Tuple section in pattern context
PsErrTupleSectionInPat :: PsMessage

-- | Bang-pattern without BangPattterns enabled
PsErrIllegalBangPattern :: !Pat GhcPs -> PsMessage

-- | Operator applied to too few arguments
PsErrOpFewArgs :: !StarIsType -> !RdrName -> PsMessage

-- | Import: multiple occurrences of <tt>qualified</tt>
PsErrImportQualifiedTwice :: PsMessage

-- | Post qualified import without <tt>ImportQualifiedPost</tt>
PsErrImportPostQualified :: PsMessage

-- | Explicit namespace keyword without <tt>ExplicitNamespaces</tt>
PsErrIllegalExplicitNamespace :: PsMessage

-- | Expecting a type constructor but found a variable
PsErrVarForTyCon :: !RdrName -> PsMessage

-- | Illegal export form allowed by PatternSynonyms
PsErrIllegalPatSynExport :: PsMessage

-- | Malformed entity string
PsErrMalformedEntityString :: PsMessage

-- | Dots used in record update
PsErrDotsInRecordUpdate :: PsMessage

-- | Precedence out of range
PsErrPrecedenceOutOfRange :: !Int -> PsMessage

-- | Invalid use of record dot syntax <tt>.</tt>
PsErrOverloadedRecordDotInvalid :: PsMessage

-- | <tt>OverloadedRecordUpdate</tt> is not enabled.
PsErrOverloadedRecordUpdateNotEnabled :: PsMessage

-- | Can't use qualified fields when OverloadedRecordUpdate is enabled.
PsErrOverloadedRecordUpdateNoQualifiedFields :: PsMessage

-- | Cannot parse data constructor in a data/newtype declaration
PsErrInvalidDataCon :: !HsType GhcPs -> PsMessage

-- | Cannot parse data constructor in a data/newtype declaration
PsErrInvalidInfixDataCon :: !HsType GhcPs -> !RdrName -> !HsType GhcPs -> PsMessage

-- | Illegal DataKinds quote mark in data/newtype constructor declaration
PsErrIllegalPromotionQuoteDataCon :: !RdrName -> PsMessage

-- | UNPACK applied to a data constructor
PsErrUnpackDataCon :: PsMessage

-- | Unexpected kind application in data/newtype declaration
PsErrUnexpectedKindAppInDataCon :: !DataConBuilder -> !HsType GhcPs -> PsMessage

-- | Not a record constructor
PsErrInvalidRecordCon :: !PatBuilder GhcPs -> PsMessage

-- | Illegal unboxed string literal in pattern
PsErrIllegalUnboxedStringInPat :: !HsLit GhcPs -> PsMessage

-- | Illegal primitive floating point literal in pattern
PsErrIllegalUnboxedFloatingLitInPat :: !HsLit GhcPs -> PsMessage

-- | Do-notation in pattern
PsErrDoNotationInPat :: PsMessage

-- | If-then-else syntax in pattern
PsErrIfThenElseInPat :: PsMessage

-- | Lambda or Lambda-case in pattern
PsErrLambdaInPat :: HsLamVariant -> PsMessage

-- | case..of in pattern
PsErrCaseInPat :: PsMessage

-- | let-syntax in pattern
PsErrLetInPat :: PsMessage

-- | Arrow expression-syntax in pattern
PsErrArrowExprInPat :: !HsExpr GhcPs -> PsMessage

-- | Arrow command-syntax in pattern
PsErrArrowCmdInPat :: !HsCmd GhcPs -> PsMessage

-- | Arrow command-syntax in expression
PsErrArrowCmdInExpr :: !HsCmd GhcPs -> PsMessage

-- | Or-pattern in expression
PsErrOrPatInExpr :: !LPat GhcPs -> PsMessage

-- | Type-application without space before <tt>@</tt>
PsErrTypeAppWithoutSpace :: !RdrName -> !LHsExpr GhcPs -> PsMessage

-- | Lazy-pattern (<tt>~</tt>) without space after it
PsErrLazyPatWithoutSpace :: !LHsExpr GhcPs -> PsMessage

-- | Bang-pattern (<tt>!</tt>) without space after it
PsErrBangPatWithoutSpace :: !LHsExpr GhcPs -> PsMessage

-- | Pragma not allowed in this position
PsErrUnallowedPragma :: !HsPragE GhcPs -> PsMessage

-- | Qualified do block in command
PsErrQualifiedDoInCmd :: !ModuleName -> PsMessage

-- | Invalid infix hole, expected an infix operator
PsErrInvalidInfixHole :: PsMessage

-- | Unexpected semi-colons in conditional expression
PsErrSemiColonsInCondExpr :: !HsExpr GhcPs -> !Bool -> !HsExpr GhcPs -> !Bool -> !HsExpr GhcPs -> PsMessage

-- | Unexpected semi-colons in conditional command
PsErrSemiColonsInCondCmd :: !HsExpr GhcPs -> !Bool -> !HsCmd GhcPs -> !Bool -> !HsCmd GhcPs -> PsMessage

-- | @-operator in a pattern position
PsErrAtInPatPos :: PsMessage

-- | Unexpected case command in function application
PsErrCaseCmdInFunAppCmd :: !LHsCmd GhcPs -> PsMessage

-- | Unexpected lambda or case(s) command in function application
PsErrLambdaCmdInFunAppCmd :: !HsLamVariant -> !LHsCmd GhcPs -> PsMessage

-- | Unexpected if command in function application
PsErrIfCmdInFunAppCmd :: !LHsCmd GhcPs -> PsMessage

-- | Unexpected let command in function application
PsErrLetCmdInFunAppCmd :: !LHsCmd GhcPs -> PsMessage

-- | Unexpected do command in function application
PsErrDoCmdInFunAppCmd :: !LHsCmd GhcPs -> PsMessage

-- | Unexpected do block in function application
PsErrDoInFunAppExpr :: !Maybe ModuleName -> !LHsExpr GhcPs -> PsMessage

-- | Unexpected mdo block in function application
PsErrMDoInFunAppExpr :: !Maybe ModuleName -> !LHsExpr GhcPs -> PsMessage

-- | Unexpected case expression in function application
PsErrCaseInFunAppExpr :: !LHsExpr GhcPs -> PsMessage

-- | Unexpected lambda or case(s) expression in function application
PsErrLambdaInFunAppExpr :: !HsLamVariant -> !LHsExpr GhcPs -> PsMessage

-- | Unexpected let expression in function application
PsErrLetInFunAppExpr :: !LHsExpr GhcPs -> PsMessage

-- | Unexpected if expression in function application
PsErrIfInFunAppExpr :: !LHsExpr GhcPs -> PsMessage

-- | Unexpected proc expression in function application
PsErrProcInFunAppExpr :: !LHsExpr GhcPs -> PsMessage

-- | Malformed head of type or class declaration
PsErrMalformedTyOrClDecl :: !LHsType GhcPs -> PsMessage

-- | Illegal 'where' keyword in data declaration
PsErrIllegalWhereInDataDecl :: PsMessage

-- | Illegal datatype context
PsErrIllegalDataTypeContext :: !LHsContext GhcPs -> PsMessage

-- | Parse error on input
PsErrParseErrorOnInput :: !OccName -> PsMessage

-- | Malformed ... declaration for ...
PsErrMalformedDecl :: !SDoc -> !RdrName -> PsMessage

-- | Not a data constructor
PsErrNotADataCon :: !RdrName -> PsMessage

-- | Record syntax used in pattern synonym declaration
PsErrRecordSyntaxInPatSynDecl :: !LPat GhcPs -> PsMessage

-- | Empty 'where' clause in pattern-synonym declaration
PsErrEmptyWhereInPatSynDecl :: !RdrName -> PsMessage

-- | Invalid binding name in 'where' clause of pattern-synonym declaration
PsErrInvalidWhereBindInPatSynDecl :: !RdrName -> !HsDecl GhcPs -> PsMessage

-- | Multiple bindings in 'where' clause of pattern-synonym declaration
PsErrNoSingleWhereBindInPatSynDecl :: !RdrName -> !HsDecl GhcPs -> PsMessage

-- | Declaration splice not a top-level
PsErrDeclSpliceNotAtTopLevel :: !SpliceDecl GhcPs -> PsMessage

-- | Inferred type variables not allowed here
PsErrInferredTypeVarNotAllowed :: PsMessage

-- | Multiple names in standalone kind signatures
PsErrMultipleNamesInStandaloneKindSignature :: [LIdP GhcPs] -> PsMessage

-- | Illegal import bundle form
PsErrIllegalImportBundleForm :: PsMessage

-- | Illegal role name
PsErrIllegalRoleName :: !FastString -> [Role] -> PsMessage

-- | Invalid type signature
PsErrInvalidTypeSignature :: !PsInvalidTypeSignature -> !LHsExpr GhcPs -> PsMessage

-- | Unexpected type in declaration
PsErrUnexpectedTypeInDecl :: !LHsType GhcPs -> !SDoc -> !RdrName -> [LHsTypeArg GhcPs] -> !SDoc -> PsMessage

-- | Expected a hyphen
PsErrExpectedHyphen :: PsMessage

-- | Found a space in a SCC
PsErrSpaceInSCC :: PsMessage

-- | Found two single quotes
PsErrEmptyDoubleQuotes :: !Bool -> PsMessage

-- | Invalid package name
PsErrInvalidPackageName :: !FastString -> PsMessage

-- | Invalid rule activation marker
PsErrInvalidRuleActivationMarker :: PsMessage

-- | Linear function found but LinearTypes not enabled
PsErrLinearFunction :: PsMessage

-- | Multi-way if-expression found but MultiWayIf not enabled
PsErrMultiWayIf :: PsMessage

-- | Explicit forall found but no extension allowing it is enabled
PsErrExplicitForall :: !Bool -> PsMessage

-- | Found qualified-do without QualifiedDo enabled
PsErrIllegalQualifiedDo :: !SDoc -> PsMessage

-- | Cmm parser error
PsErrCmmParser :: !CmmParserError -> PsMessage

-- | Illegal traditional record syntax
--   
--   TODO: distinguish errors without using SDoc
PsErrIllegalTraditionalRecordSyntax :: !SDoc -> PsMessage

-- | Parse error in command
--   
--   TODO: distinguish errors without using SDoc
PsErrParseErrorInCmd :: !SDoc -> PsMessage

-- | Parse error in pattern
PsErrInPat :: !PatBuilder GhcPs -> !PsErrInPatDetails -> PsMessage

-- | Parse error in right operator section pattern TODO: embed the proper
--   operator, if possible
PsErrParseRightOpSectionInPat :: !RdrName -> !PatBuilder GhcPs -> PsMessage

-- | Illegal linear arrow or multiplicity annotation in GADT record syntax
PsErrIllegalGadtRecordMultiplicity :: !HsArrow GhcPs -> PsMessage
PsErrInvalidCApiImport :: PsMessage
PsErrMultipleConForNewtype :: !RdrName -> !Int -> PsMessage
PsErrUnicodeCharLooksLike :: Char -> Char -> String -> PsMessage
PsErrInvalidPun :: !PsErrPunDetails -> PsMessage

-- | Or pattern used without -XOrPatterns
PsErrIllegalOrPat :: LPat GhcPs -> PsMessage

-- | Temporary error until GHC gains support for type syntax in patterns.
--   Test cases: T24159_pat_parse_error_1 T24159_pat_parse_error_2
--   T24159_pat_parse_error_3 T24159_pat_parse_error_4
--   T24159_pat_parse_error_5 T24159_pat_parse_error_6
PsErrTypeSyntaxInPat :: !PsErrTypeSyntaxDetails -> PsMessage

-- | Extra details about a parse error, which helps us in determining which
--   should be the hints to suggest.
data PsErrParseDetails
PsErrParseDetails :: !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> PsErrParseDetails
[ped_th_enabled] :: PsErrParseDetails -> !Bool

-- | Is there a 'do' in the last 100 characters?
[ped_do_in_last_100] :: PsErrParseDetails -> !Bool

-- | Is there an <tt>mdo</tt> in the last 100 characters?
[ped_mdo_in_last_100] :: PsErrParseDetails -> !Bool

-- | Is <tt>PatternSynonyms</tt> enabled?
[ped_pat_syn_enabled] :: PsErrParseDetails -> !Bool

-- | Did we parse a "pattern" keyword?
[ped_pattern_parsed] :: PsErrParseDetails -> !Bool
data PsInvalidTypeSignature
PsErrInvalidTypeSig_Qualified :: PsInvalidTypeSignature
PsErrInvalidTypeSig_DataCon :: PsInvalidTypeSignature
PsErrInvalidTypeSig_Other :: PsInvalidTypeSignature

-- | Is the parsed pattern recursive?
data PatIsRecursive
YesPatIsRecursive :: PatIsRecursive
NoPatIsRecursive :: PatIsRecursive
data PatIncompleteDoBlock
YesIncompleteDoBlock :: PatIncompleteDoBlock
NoIncompleteDoBlock :: PatIncompleteDoBlock

-- | Extra information for the expression GHC is currently
--   inspecting/parsing. It can be used to generate more informative parser
--   diagnostics and hints.
data ParseContext
ParseContext :: !Maybe RdrName -> !PatIncompleteDoBlock -> ParseContext

-- | If <a>Just</a>, this is an infix pattern with the bound operator name
[is_infix] :: ParseContext -> !Maybe RdrName

-- | Did the parser likely fail due to an incomplete do block?
[incomplete_do_block] :: ParseContext -> !PatIncompleteDoBlock
data PsErrInPatDetails

-- | Negative application pattern?
PEIP_NegApp :: PsErrInPatDetails

-- | The list of type arguments for the pattern
PEIP_TypeArgs :: [HsConPatTyArg GhcPs] -> PsErrInPatDetails
PEIP_RecPattern :: [LPat GhcPs] -> !PatIsRecursive -> !ParseContext -> PsErrInPatDetails
PEIP_OtherPatDetails :: !ParseContext -> PsErrInPatDetails
data PsErrPunDetails
PEP_QuoteDisambiguation :: PsErrPunDetails
PEP_TupleSyntaxType :: PsErrPunDetails
PEP_SumSyntaxType :: PsErrPunDetails
data PsErrTypeSyntaxDetails
PETS_FunctionArrow :: !LocatedA (PatBuilder GhcPs) -> !HsArrowOf (LocatedA (PatBuilder GhcPs)) GhcPs -> !LocatedA (PatBuilder GhcPs) -> PsErrTypeSyntaxDetails
PETS_Multiplicity :: !EpToken "%" -> !LocatedA (PatBuilder GhcPs) -> PsErrTypeSyntaxDetails
PETS_ForallTelescope :: !HsForAllTelescope GhcPs -> !LocatedA (PatBuilder GhcPs) -> PsErrTypeSyntaxDetails
PETS_ConstraintContext :: !LocatedA (PatBuilder GhcPs) -> PsErrTypeSyntaxDetails
noParseContext :: ParseContext
incompleteDoBlock :: ParseContext

-- | Builds a <a>PsErrInPatDetails</a> with the information provided by the
--   <a>ParseContext</a>.
fromParseContext :: ParseContext -> PsErrInPatDetails
data NumUnderscoreReason
NumUnderscore_Integral :: NumUnderscoreReason
NumUnderscore_Float :: NumUnderscoreReason
data LexErrKind

-- | End of input
LexErrKind_EOF :: LexErrKind

-- | UTF-8 decoding error
LexErrKind_UTF8 :: LexErrKind

-- | Error at given character
LexErrKind_Char :: !Char -> LexErrKind
data LexErr

-- | Lexical error
LexError :: LexErr

-- | Unknown pragma
LexUnknownPragma :: LexErr

-- | Lexical error in pragma
LexErrorInPragma :: LexErr

-- | Numeric escape sequence out of range
LexNumEscapeRange :: LexErr

-- | Unterminated `{-'
LexUnterminatedComment :: LexErr

-- | Unterminated OPTIONS pragma
LexUnterminatedOptions :: LexErr

-- | Unterminated quasiquotation
LexUnterminatedQQ :: LexErr

-- | Errors from the Cmm parser
data CmmParserError

-- | Unknown Cmm primitive
CmmUnknownPrimitive :: !FastString -> CmmParserError

-- | Unknown macro
CmmUnknownMacro :: !FastString -> CmmParserError

-- | Unknown calling convention
CmmUnknownCConv :: !String -> CmmParserError

-- | Unrecognised safety
CmmUnrecognisedSafety :: !String -> CmmParserError

-- | Unrecognised hint
CmmUnrecognisedHint :: !String -> CmmParserError
data TransLayoutReason

-- | "`where' clause at the same depth as implicit layout block"
TransLayout_Where :: TransLayoutReason

-- | "`|' at the same depth as implicit layout block")
TransLayout_Pipe :: TransLayoutReason
data FileHeaderPragmaType
OptionsPrag :: FileHeaderPragmaType
IncludePrag :: FileHeaderPragmaType
LanguagePrag :: FileHeaderPragmaType
DocOptionsPrag :: FileHeaderPragmaType
instance GHC.Classes.Eq GHC.Parser.Errors.Types.LexErrKind
instance GHC.Classes.Eq GHC.Parser.Errors.Types.NumUnderscoreReason
instance GHC.Classes.Eq GHC.Parser.Errors.Types.ParseContext
instance GHC.Classes.Eq GHC.Parser.Errors.Types.PatIncompleteDoBlock
instance GHC.Internal.Generics.Generic GHC.Parser.Errors.Types.PsHeaderMessage
instance GHC.Internal.Generics.Generic GHC.Parser.Errors.Types.PsMessage
instance GHC.Classes.Ord GHC.Parser.Errors.Types.LexErrKind
instance GHC.Classes.Ord GHC.Parser.Errors.Types.NumUnderscoreReason
instance GHC.Internal.Show.Show GHC.Parser.Errors.Types.LexErrKind
instance GHC.Internal.Show.Show GHC.Parser.Errors.Types.NumUnderscoreReason

module GHC.Parser.String
data StringLexError
StringLexError :: LexErr -> BufPos -> StringLexError
lexString :: Int -> StringBuffer -> Either StringLexError String

-- | See Note [Multiline string literals]
--   
--   Assumes string is lexically valid. Skips the steps about splitting and
--   rejoining lines, and instead manually find newline characters, for
--   performance.
lexMultilineString :: Int -> StringBuffer -> Either StringLexError String
isDoubleSmartQuote :: Char -> Bool
isSingleSmartQuote :: Char -> Bool
instance GHC.Parser.String.HasChar GHC.Types.Char
instance GHC.Parser.String.HasChar (GHC.Types.Char, x)

module GHC.Iface.Warnings
toIfaceWarnings :: Warnings GhcRn -> IfaceWarnings
toIfaceWarningTxt :: WarningTxt GhcRn -> IfaceWarningTxt


-- | Compute the <a>Type</a> of an <tt><a>HsExpr</a> <a>GhcTc</a></tt> in a
--   pure fashion.
--   
--   Note that this does <i>not</i> currently support the use case of
--   annotating every subexpression in an <a>HsExpr</a> with its
--   <a>Type</a>. For more information on this task, see #12706, #15320,
--   #16804, and #17331.
module GHC.Hs.Syn.Type

-- | Compute the <a>Type</a> of an <tt><a>LHsExpr</a> <a>GhcTc</a></tt> in
--   a pure fashion.
lhsExprType :: LHsExpr GhcTc -> Type

-- | Compute the <a>Type</a> of an <tt><a>HsExpr</a> <a>GhcTc</a></tt> in a
--   pure fashion.
hsExprType :: HsExpr GhcTc -> Type
hsWrapperType :: HsWrapper -> Type -> Type
hsLitType :: forall (p :: Pass). HsLit (GhcPass p) -> Type
hsPatType :: Pat GhcTc -> Type
hsLPatType :: LPat GhcTc -> Type


-- | Statistics for per-module compilations
--   
--   (c) The GRASP/AQUA Project, Glasgow University, 1993-1998
module GHC.Hs.Stats

-- | Source Statistics
ppSourceStats :: Bool -> Located (HsModule GhcPs) -> SDoc


-- | Contains a debug function to dump parts of the GHC.Hs AST. It uses a
--   syb traversal which falls back to displaying based on the constructor
--   name, so can be used to dump anything having a <tt>Data.Data</tt>
--   instance.
module GHC.Hs.Dump

-- | Show a GHC syntax tree. This parameterised because it is also used for
--   comparing ASTs in ppr roundtripping tests, where the SrcSpan's are
--   blanked out, to avoid comparing locations, only structure
showAstData :: Data a => BlankSrcSpan -> BlankEpAnnotations -> a -> SDoc

-- | Show the full AST as the compiler sees it.
showAstDataFull :: Data a => a -> SDoc

-- | Should source spans be removed from output.
data BlankSrcSpan
BlankSrcSpan :: BlankSrcSpan
BlankSrcSpanFile :: BlankSrcSpan
NoBlankSrcSpan :: BlankSrcSpan

-- | Should EpAnnotations be removed from output.
data BlankEpAnnotations
BlankEpAnnotations :: BlankEpAnnotations
NoBlankEpAnnotations :: BlankEpAnnotations
instance GHC.Classes.Eq GHC.Hs.Dump.BlankEpAnnotations
instance GHC.Classes.Eq GHC.Hs.Dump.BlankSrcSpan
instance GHC.Internal.Show.Show GHC.Hs.Dump.BlankEpAnnotations
instance GHC.Internal.Show.Show GHC.Hs.Dump.BlankSrcSpan


-- | This is the syntax for bkp files which are parsed in 'ghc --backpack'
--   mode. This syntax is used purely for testing purposes.
module GHC.Driver.Backpack.Syntax
data HsUnitId n
HsUnitId :: Located n -> [LHsModuleSubst n] -> HsUnitId n
type LHsUnitId n = Located HsUnitId n
type HsModuleSubst n = (Located ModuleName, LHsModuleId n)
type LHsModuleSubst n = Located HsModuleSubst n
data HsModuleId n
HsModuleVar :: Located ModuleName -> HsModuleId n
HsModuleId :: LHsUnitId n -> Located ModuleName -> HsModuleId n
type LHsModuleId n = Located HsModuleId n
data HsComponentId
HsComponentId :: PackageName -> UnitId -> HsComponentId
[hsPackageName] :: HsComponentId -> PackageName
[hsComponentId] :: HsComponentId -> UnitId
type LHsUnit n = Located HsUnit n

-- | Top level <tt>unit</tt> declaration in a Backpack file.
data HsUnit n
HsUnit :: Located n -> [LHsUnitDecl n] -> HsUnit n
[hsunitName] :: HsUnit n -> Located n
[hsunitBody] :: HsUnit n -> [LHsUnitDecl n]
type LHsUnitDecl n = Located HsUnitDecl n

-- | A declaration in a package, e.g. a module or signature definition, or
--   an include.
data HsUnitDecl n
DeclD :: HscSource -> Located ModuleName -> Located (HsModule GhcPs) -> HsUnitDecl n
IncludeD :: IncludeDecl n -> HsUnitDecl n

-- | An include of another unit
data IncludeDecl n
IncludeDecl :: LHsUnitId n -> Maybe [LRenaming] -> Bool -> IncludeDecl n
[idUnitId] :: IncludeDecl n -> LHsUnitId n
[idModRenaming] :: IncludeDecl n -> Maybe [LRenaming]

-- | Is this a <tt>dependency signature</tt> include? If so, we don't
--   compile this include when we instantiate this unit (as there should
--   not be any modules brought into scope.)
[idSignatureInclude] :: IncludeDecl n -> Bool
type LRenaming = Located Renaming

-- | Rename a module from one name to another. The identity renaming means
--   that the module should be brought into scope.
data Renaming
Renaming :: Located ModuleName -> Maybe (Located ModuleName) -> Renaming
[renameFrom] :: Renaming -> Located ModuleName
[renameTo] :: Renaming -> Maybe (Located ModuleName)
instance GHC.Utils.Outputable.Outputable GHC.Driver.Backpack.Syntax.HsComponentId

module GHC.Core.Opt.FloatIn
floatInwards :: Platform -> CoreProgram -> CoreProgram
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.FloatIn.FloatInBind

module GHC.Core.LateCC.Utils

-- | Insert cost centres into the <a>CoreProgram</a> using the provided
--   environment, initial state, and insertion method.
doLateCostCenters :: LateCCEnv -> LateCCState s -> (CoreBind -> LateCCM s CoreBind) -> CoreProgram -> (CoreProgram, LateCCState s)

-- | Given the name of a cost centre, get its flavour
getCCFlavour :: FastString -> LateCCM s CCFlavour

-- | Insert a cost centre with the specified name and source span on the
--   given expression. The inserted cost centre will be appropriately
--   tracked in the late cost centre state.
insertCC :: FastString -> SrcSpan -> CoreExpr -> LateCCM s CoreExpr

module GHC.Core.LateCC.OverloadedCalls

-- | Insert cost centres on function applications with dictionary
--   arguments. The source locations attached to the cost centres is
--   approximated based on the "closest" source note encountered in the
--   traversal.
overloadedCallsCC :: CoreBind -> LateCCM OverloadedCallsCCState CoreBind

module GHC.Core.Unfold

-- | Records the <i>unfolding</i> of an identifier, which is approximately
--   the form the identifier would have if we substituted its definition in
--   for the identifier. This type should be treated as abstract everywhere
--   except in <a>GHC.Core.Unfold</a>
data Unfolding

-- | <a>UnfoldingGuidance</a> says when unfolding should take place
data UnfoldingGuidance

-- | The size of a candidate expression for unfolding
data ExprSize
TooBig :: ExprSize
SizeIs :: {-# UNPACK #-} !Int -> !Bag (Id, Int) -> {-# UNPACK #-} !Int -> ExprSize

-- | Size found
[_es_size_is] :: ExprSize -> {-# UNPACK #-} !Int

-- | Arguments cased herein, and discount for each such
[_es_args] :: ExprSize -> !Bag (Id, Int)

-- | Size to subtract if result is scrutinised by a case expression
[_es_discount] :: ExprSize -> {-# UNPACK #-} !Int
sizeExpr :: UnfoldingOpts -> Int -> [Id] -> CoreExpr -> ExprSize
data ArgSummary
TrivArg :: ArgSummary
NonTrivArg :: ArgSummary
ValueArg :: ArgSummary
nonTriv :: ArgSummary -> Bool
data CallCtxt
BoringCtxt :: CallCtxt
RhsCtxt :: RecFlag -> CallCtxt
DiscArgCtxt :: CallCtxt
RuleArgCtxt :: CallCtxt
ValAppCtxt :: CallCtxt
CaseCtxt :: CallCtxt

-- | Unfolding options
data UnfoldingOpts
UnfoldingOpts :: !Int -> !Int -> !Int -> !Int -> !Bool -> !Int -> !Int -> !Maybe String -> UnfoldingOpts

-- | Threshold above which unfoldings are not *created*
[unfoldingCreationThreshold] :: UnfoldingOpts -> !Int

-- | Threshold above which unfoldings are not *inlined*
[unfoldingUseThreshold] :: UnfoldingOpts -> !Int

-- | Discount for lambdas that are used (applied)
[unfoldingFunAppDiscount] :: UnfoldingOpts -> !Int

-- | Discount for dictionaries
[unfoldingDictDiscount] :: UnfoldingOpts -> !Int

-- | Force inlining in many more cases
[unfoldingVeryAggressive] :: UnfoldingOpts -> !Bool

-- | Don't consider depth up to x
[unfoldingCaseThreshold] :: UnfoldingOpts -> !Int

-- | Penalize depth with 1/x
[unfoldingCaseScaling] :: UnfoldingOpts -> !Int

-- | Only report inlining decisions for names with this prefix
[unfoldingReportPrefix] :: UnfoldingOpts -> !Maybe String
defaultUnfoldingOpts :: UnfoldingOpts
updateCreationThreshold :: Int -> UnfoldingOpts -> UnfoldingOpts
updateUseThreshold :: Int -> UnfoldingOpts -> UnfoldingOpts
updateFunAppDiscount :: Int -> UnfoldingOpts -> UnfoldingOpts
updateDictDiscount :: Int -> UnfoldingOpts -> UnfoldingOpts
updateVeryAggressive :: Bool -> UnfoldingOpts -> UnfoldingOpts
updateCaseScaling :: Int -> UnfoldingOpts -> UnfoldingOpts
updateCaseThreshold :: Int -> UnfoldingOpts -> UnfoldingOpts
updateReportPrefix :: Maybe String -> UnfoldingOpts -> UnfoldingOpts
inlineBoringOk :: CoreExpr -> Bool
calcUnfoldingGuidance :: UnfoldingOpts -> Bool -> Bool -> CoreExpr -> UnfoldingGuidance
uncondInlineJoin :: [Var] -> CoreExpr -> Bool
instance GHC.Utils.Outputable.Outputable GHC.Core.Unfold.ArgSummary
instance GHC.Utils.Outputable.Outputable GHC.Core.Unfold.CallCtxt
instance GHC.Utils.Outputable.Outputable GHC.Core.Unfold.ExprSize

module GHC.Driver.DynFlags

-- | Debugging flags
data DumpFlag
Opt_D_dump_cmm :: DumpFlag
Opt_D_dump_cmm_from_stg :: DumpFlag
Opt_D_dump_cmm_raw :: DumpFlag
Opt_D_dump_cmm_verbose_by_proc :: DumpFlag
Opt_D_dump_cmm_verbose :: DumpFlag
Opt_D_dump_cmm_cfg :: DumpFlag
Opt_D_dump_cmm_cbe :: DumpFlag
Opt_D_dump_cmm_switch :: DumpFlag
Opt_D_dump_cmm_proc :: DumpFlag
Opt_D_dump_cmm_sp :: DumpFlag
Opt_D_dump_cmm_sink :: DumpFlag
Opt_D_dump_cmm_caf :: DumpFlag
Opt_D_dump_cmm_procmap :: DumpFlag
Opt_D_dump_cmm_split :: DumpFlag
Opt_D_dump_cmm_info :: DumpFlag
Opt_D_dump_cmm_cps :: DumpFlag
Opt_D_dump_cmm_thread_sanitizer :: DumpFlag

-- | Dump the cfg used for block layout.
Opt_D_dump_cfg_weights :: DumpFlag
Opt_D_dump_asm :: DumpFlag
Opt_D_dump_asm_native :: DumpFlag
Opt_D_dump_asm_liveness :: DumpFlag
Opt_D_dump_asm_regalloc :: DumpFlag
Opt_D_dump_asm_regalloc_stages :: DumpFlag
Opt_D_dump_asm_conflicts :: DumpFlag
Opt_D_dump_asm_stats :: DumpFlag
Opt_D_dump_c_backend :: DumpFlag
Opt_D_dump_llvm :: DumpFlag
Opt_D_dump_js :: DumpFlag
Opt_D_dump_core_stats :: DumpFlag
Opt_D_dump_deriv :: DumpFlag
Opt_D_dump_ds :: DumpFlag
Opt_D_dump_ds_preopt :: DumpFlag
Opt_D_dump_foreign :: DumpFlag
Opt_D_dump_inlinings :: DumpFlag
Opt_D_dump_verbose_inlinings :: DumpFlag
Opt_D_dump_rule_firings :: DumpFlag
Opt_D_dump_rule_rewrites :: DumpFlag
Opt_D_dump_simpl_trace :: DumpFlag
Opt_D_dump_occur_anal :: DumpFlag
Opt_D_dump_parsed :: DumpFlag
Opt_D_dump_parsed_ast :: DumpFlag
Opt_D_dump_rn :: DumpFlag
Opt_D_dump_rn_ast :: DumpFlag
Opt_D_dump_simpl :: DumpFlag
Opt_D_dump_simpl_iterations :: DumpFlag
Opt_D_dump_spec :: DumpFlag
Opt_D_dump_spec_constr :: DumpFlag
Opt_D_dump_prep :: DumpFlag
Opt_D_dump_late_cc :: DumpFlag

-- | Initial STG (CoreToStg output)
Opt_D_dump_stg_from_core :: DumpFlag

-- | STG after unarise
Opt_D_dump_stg_unarised :: DumpFlag

-- | STG (after stg2stg)
Opt_D_dump_stg_cg :: DumpFlag

-- | Result of tag inference analysis.
Opt_D_dump_stg_tags :: DumpFlag

-- | Final STG (before cmm gen)
Opt_D_dump_stg_final :: DumpFlag
Opt_D_dump_call_arity :: DumpFlag
Opt_D_dump_exitify :: DumpFlag
Opt_D_dump_dmdanal :: DumpFlag
Opt_D_dump_dmd_signatures :: DumpFlag
Opt_D_dump_cpranal :: DumpFlag
Opt_D_dump_cpr_signatures :: DumpFlag
Opt_D_dump_tc :: DumpFlag
Opt_D_dump_tc_ast :: DumpFlag
Opt_D_dump_hie :: DumpFlag
Opt_D_dump_types :: DumpFlag
Opt_D_dump_rules :: DumpFlag
Opt_D_dump_cse :: DumpFlag
Opt_D_dump_float_out :: DumpFlag
Opt_D_dump_float_in :: DumpFlag
Opt_D_dump_liberate_case :: DumpFlag
Opt_D_dump_static_argument_transformation :: DumpFlag
Opt_D_dump_worker_wrapper :: DumpFlag
Opt_D_dump_rn_trace :: DumpFlag
Opt_D_dump_rn_stats :: DumpFlag
Opt_D_dump_opt_cmm :: DumpFlag
Opt_D_dump_simpl_stats :: DumpFlag
Opt_D_dump_cs_trace :: DumpFlag
Opt_D_dump_tc_trace :: DumpFlag
Opt_D_dump_ec_trace :: DumpFlag
Opt_D_dump_if_trace :: DumpFlag
Opt_D_dump_splices :: DumpFlag
Opt_D_th_dec_file :: DumpFlag
Opt_D_dump_BCOs :: DumpFlag
Opt_D_dump_ticked :: DumpFlag
Opt_D_dump_rtti :: DumpFlag
Opt_D_source_stats :: DumpFlag
Opt_D_verbose_stg2stg :: DumpFlag
Opt_D_dump_hi :: DumpFlag
Opt_D_dump_hi_diffs :: DumpFlag
Opt_D_dump_mod_cycles :: DumpFlag
Opt_D_dump_mod_map :: DumpFlag
Opt_D_dump_timings :: DumpFlag
Opt_D_dump_view_pattern_commoning :: DumpFlag
Opt_D_verbose_core2core :: DumpFlag
Opt_D_dump_debug :: DumpFlag
Opt_D_dump_json :: DumpFlag
Opt_D_ppr_debug :: DumpFlag
Opt_D_no_debug_output :: DumpFlag
Opt_D_dump_faststrings :: DumpFlag
Opt_D_faststring_stats :: DumpFlag
Opt_D_ipe_stats :: DumpFlag

-- | Enumerates the simple on-or-off dynamic flags
data GeneralFlag

-- | Append dump output to files instead of stdout.
Opt_DumpToFile :: GeneralFlag

-- | Use foo.ways.<a>dumpFlag</a> instead of foo.<a>dumpFlag</a>
Opt_DumpWithWays :: GeneralFlag
Opt_D_dump_minimal_imports :: GeneralFlag
Opt_DoCoreLinting :: GeneralFlag
Opt_DoLinearCoreLinting :: GeneralFlag
Opt_DoStgLinting :: GeneralFlag
Opt_DoCmmLinting :: GeneralFlag
Opt_DoAsmLinting :: GeneralFlag
Opt_DoAnnotationLinting :: GeneralFlag
Opt_DoBoundsChecking :: GeneralFlag
Opt_NoLlvmMangler :: GeneralFlag
Opt_FastLlvm :: GeneralFlag
Opt_NoTypeableBinds :: GeneralFlag
Opt_DistinctConstructorTables :: GeneralFlag
Opt_InfoTableMap :: GeneralFlag
Opt_InfoTableMapWithFallback :: GeneralFlag
Opt_InfoTableMapWithStack :: GeneralFlag
Opt_WarnIsError :: GeneralFlag
Opt_ShowWarnGroups :: GeneralFlag
Opt_HideSourcePaths :: GeneralFlag
Opt_PrintExplicitForalls :: GeneralFlag
Opt_PrintExplicitKinds :: GeneralFlag
Opt_PrintExplicitCoercions :: GeneralFlag
Opt_PrintExplicitRuntimeReps :: GeneralFlag
Opt_PrintEqualityRelations :: GeneralFlag
Opt_PrintAxiomIncomps :: GeneralFlag
Opt_PrintUnicodeSyntax :: GeneralFlag
Opt_PrintExpandedSynonyms :: GeneralFlag
Opt_PrintPotentialInstances :: GeneralFlag
Opt_PrintRedundantPromotionTicks :: GeneralFlag
Opt_PrintTypecheckerElaboration :: GeneralFlag
Opt_CallArity :: GeneralFlag
Opt_Exitification :: GeneralFlag
Opt_Strictness :: GeneralFlag
Opt_LateDmdAnal :: GeneralFlag
Opt_KillAbsence :: GeneralFlag
Opt_KillOneShot :: GeneralFlag
Opt_FullLaziness :: GeneralFlag
Opt_FloatIn :: GeneralFlag

-- | Enable floating out of let-bindings in the simplifier
Opt_LocalFloatOut :: GeneralFlag

-- | Enable floating out of let-bindings at the top level in the simplifier
--   N.B. See Note [RHS Floating]
Opt_LocalFloatOutTopLevel :: GeneralFlag
Opt_LateSpecialise :: GeneralFlag
Opt_Specialise :: GeneralFlag
Opt_SpecialiseAggressively :: GeneralFlag
Opt_CrossModuleSpecialise :: GeneralFlag
Opt_PolymorphicSpecialisation :: GeneralFlag
Opt_InlineGenerics :: GeneralFlag
Opt_InlineGenericsAggressively :: GeneralFlag
Opt_StaticArgumentTransformation :: GeneralFlag
Opt_CSE :: GeneralFlag
Opt_StgCSE :: GeneralFlag
Opt_StgLiftLams :: GeneralFlag
Opt_LiberateCase :: GeneralFlag
Opt_SpecConstr :: GeneralFlag
Opt_SpecConstrKeen :: GeneralFlag
Opt_SpecialiseIncoherents :: GeneralFlag
Opt_DoLambdaEtaExpansion :: GeneralFlag
Opt_DoCleverArgEtaExpansion :: GeneralFlag
Opt_IgnoreAsserts :: GeneralFlag
Opt_DoEtaReduction :: GeneralFlag
Opt_CaseMerge :: GeneralFlag
Opt_CaseFolding :: GeneralFlag
Opt_UnboxStrictFields :: GeneralFlag
Opt_UnboxSmallStrictFields :: GeneralFlag
Opt_DictsCheap :: GeneralFlag
Opt_EnableRewriteRules :: GeneralFlag
Opt_EnableThSpliceWarnings :: GeneralFlag
Opt_RegsGraph :: GeneralFlag
Opt_RegsIterative :: GeneralFlag
Opt_PedanticBottoms :: GeneralFlag
Opt_LlvmFillUndefWithGarbage :: GeneralFlag
Opt_IrrefutableTuples :: GeneralFlag
Opt_CmmSink :: GeneralFlag
Opt_CmmStaticPred :: GeneralFlag
Opt_CmmElimCommonBlocks :: GeneralFlag
Opt_CmmControlFlow :: GeneralFlag
Opt_AsmShortcutting :: GeneralFlag
Opt_OmitYields :: GeneralFlag
Opt_FunToThunk :: GeneralFlag
Opt_DictsStrict :: GeneralFlag

-- | deprecated, no effect and behaviour is now default. Allowed switching
--   of a special demand transformer for dictionary selectors
Opt_DmdTxDictSel :: GeneralFlag
Opt_Loopification :: GeneralFlag

-- | Use the cfg based block layout algorithm.
Opt_CfgBlocklayout :: GeneralFlag

-- | Layout based on last instruction per block.
Opt_WeightlessBlocklayout :: GeneralFlag
Opt_CprAnal :: GeneralFlag
Opt_WorkerWrapper :: GeneralFlag

-- | Do W/W split for unlifting even if we won't unbox anything.
Opt_WorkerWrapperUnlift :: GeneralFlag
Opt_SolveConstantDicts :: GeneralFlag
Opt_AlignmentSanitisation :: GeneralFlag
Opt_CatchNonexhaustiveCases :: GeneralFlag
Opt_NumConstantFolding :: GeneralFlag
Opt_CoreConstantFolding :: GeneralFlag
Opt_FastPAPCalls :: GeneralFlag
Opt_SpecEval :: GeneralFlag
Opt_SpecEvalDictFun :: GeneralFlag
Opt_DoTagInferenceChecks :: GeneralFlag
Opt_SimplPreInlining :: GeneralFlag
Opt_IgnoreInterfacePragmas :: GeneralFlag
Opt_OmitInterfacePragmas :: GeneralFlag
Opt_ExposeAllUnfoldings :: GeneralFlag
Opt_ExposeOverloadedUnfoldings :: GeneralFlag

-- | Keep auto-generated rules even if they seem to have become useless
Opt_KeepAutoRules :: GeneralFlag
Opt_WriteInterface :: GeneralFlag
Opt_WriteHie :: GeneralFlag

-- | render JavaScript pretty-printed instead of minified (compacted)
Opt_DisableJsMinifier :: GeneralFlag

-- | don't link C sources (compiled to JS) with Haskell code (compiled to
--   JS)
Opt_DisableJsCsources :: GeneralFlag
Opt_AutoSccsOnIndividualCafs :: GeneralFlag
Opt_ProfCountEntries :: GeneralFlag
Opt_ProfLateInlineCcs :: GeneralFlag
Opt_ProfLateCcs :: GeneralFlag
Opt_ProfLateOverloadedCcs :: GeneralFlag
Opt_ProfLateoverloadedCallsCCs :: GeneralFlag

-- | Ignore manual SCC annotations
Opt_ProfManualCcs :: GeneralFlag
Opt_Pp :: GeneralFlag
Opt_ForceRecomp :: GeneralFlag
Opt_IgnoreOptimChanges :: GeneralFlag
Opt_IgnoreHpcChanges :: GeneralFlag
Opt_ExcessPrecision :: GeneralFlag
Opt_EagerBlackHoling :: GeneralFlag
Opt_OrigThunkInfo :: GeneralFlag
Opt_NoHsMain :: GeneralFlag
Opt_SplitSections :: GeneralFlag
Opt_StgStats :: GeneralFlag
Opt_HideAllPackages :: GeneralFlag
Opt_HideAllPluginPackages :: GeneralFlag
Opt_PrintBindResult :: GeneralFlag
Opt_Haddock :: GeneralFlag
Opt_HaddockOptions :: GeneralFlag
Opt_BreakOnException :: GeneralFlag
Opt_BreakOnError :: GeneralFlag
Opt_PrintEvldWithShow :: GeneralFlag
Opt_PrintBindContents :: GeneralFlag
Opt_GenManifest :: GeneralFlag
Opt_EmbedManifest :: GeneralFlag
Opt_SharedImplib :: GeneralFlag
Opt_BuildingCabalPackage :: GeneralFlag
Opt_IgnoreDotGhci :: GeneralFlag
Opt_GhciSandbox :: GeneralFlag
Opt_InsertBreakpoints :: GeneralFlag
Opt_GhciHistory :: GeneralFlag
Opt_GhciLeakCheck :: GeneralFlag
Opt_ValidateHie :: GeneralFlag
Opt_LocalGhciHistory :: GeneralFlag
Opt_NoIt :: GeneralFlag
Opt_HelpfulErrors :: GeneralFlag
Opt_DeferTypeErrors :: GeneralFlag
Opt_DeferTypedHoles :: GeneralFlag
Opt_DeferOutOfScopeVariables :: GeneralFlag

-- | <pre>
--   -fPIC
--   </pre>
Opt_PIC :: GeneralFlag

-- | <pre>
--   -fPIE
--   </pre>
Opt_PIE :: GeneralFlag

-- | <pre>
--   -pie
--   </pre>
Opt_PICExecutable :: GeneralFlag
Opt_ExternalDynamicRefs :: GeneralFlag
Opt_Ticky :: GeneralFlag
Opt_Ticky_Allocd :: GeneralFlag
Opt_Ticky_LNE :: GeneralFlag
Opt_Ticky_Dyn_Thunk :: GeneralFlag
Opt_Ticky_Tag :: GeneralFlag

-- | Use regular thunks even when we could use std ap thunks in order to
--   get entry counts
Opt_Ticky_AP :: GeneralFlag
Opt_CmmThreadSanitizer :: GeneralFlag
Opt_RPath :: GeneralFlag
Opt_RelativeDynlibPaths :: GeneralFlag

-- | <pre>
--   -fcompact-unwind
--   </pre>
Opt_CompactUnwind :: GeneralFlag
Opt_Hpc :: GeneralFlag
Opt_FamAppCache :: GeneralFlag
Opt_ExternalInterpreter :: GeneralFlag
Opt_OptimalApplicativeDo :: GeneralFlag
Opt_VersionMacros :: GeneralFlag
Opt_WholeArchiveHsLibs :: GeneralFlag
Opt_SingleLibFolder :: GeneralFlag
Opt_ExposeInternalSymbols :: GeneralFlag
Opt_KeepCAFs :: GeneralFlag
Opt_KeepGoing :: GeneralFlag
Opt_ByteCode :: GeneralFlag
Opt_ByteCodeAndObjectCode :: GeneralFlag
Opt_UnoptimizedCoreForInterpreter :: GeneralFlag
Opt_LinkRts :: GeneralFlag
Opt_ErrorSpans :: GeneralFlag
Opt_DeferDiagnostics :: GeneralFlag

-- | Dump diagnostics as JSON
Opt_DiagnosticsAsJSON :: GeneralFlag
Opt_DiagnosticsShowCaret :: GeneralFlag
Opt_PprCaseAsLet :: GeneralFlag
Opt_PprShowTicks :: GeneralFlag
Opt_ShowHoleConstraints :: GeneralFlag
Opt_ShowValidHoleFits :: GeneralFlag
Opt_SortValidHoleFits :: GeneralFlag
Opt_SortBySizeHoleFits :: GeneralFlag
Opt_SortBySubsumHoleFits :: GeneralFlag
Opt_AbstractRefHoleFits :: GeneralFlag
Opt_UnclutterValidHoleFits :: GeneralFlag
Opt_ShowTypeAppOfHoleFits :: GeneralFlag
Opt_ShowTypeAppVarsOfHoleFits :: GeneralFlag
Opt_ShowDocsOfHoleFits :: GeneralFlag
Opt_ShowTypeOfHoleFits :: GeneralFlag
Opt_ShowProvOfHoleFits :: GeneralFlag
Opt_ShowMatchesOfHoleFits :: GeneralFlag
Opt_ShowLoadedModules :: GeneralFlag
Opt_HexWordLiterals :: GeneralFlag
Opt_SuppressCoercions :: GeneralFlag
Opt_SuppressCoercionTypes :: GeneralFlag
Opt_SuppressVarKinds :: GeneralFlag
Opt_SuppressModulePrefixes :: GeneralFlag
Opt_SuppressTypeApplications :: GeneralFlag
Opt_SuppressIdInfo :: GeneralFlag
Opt_SuppressUnfoldings :: GeneralFlag
Opt_SuppressTypeSignatures :: GeneralFlag
Opt_SuppressUniques :: GeneralFlag
Opt_SuppressStgExts :: GeneralFlag
Opt_SuppressStgReps :: GeneralFlag
Opt_SuppressTicks :: GeneralFlag

-- | Suppress timestamps in dumps
Opt_SuppressTimestamps :: GeneralFlag

-- | Suppress per binding Core size stats in dumps
Opt_SuppressCoreSizes :: GeneralFlag
Opt_ShowErrorContext :: GeneralFlag
Opt_ObjectDeterminism :: GeneralFlag
Opt_AutoLinkPackages :: GeneralFlag
Opt_ImplicitImportQualified :: GeneralFlag
Opt_KeepHscppFiles :: GeneralFlag
Opt_KeepHiDiffs :: GeneralFlag
Opt_KeepHcFiles :: GeneralFlag
Opt_KeepSFiles :: GeneralFlag
Opt_KeepTmpFiles :: GeneralFlag
Opt_KeepRawTokenStream :: GeneralFlag
Opt_KeepLlvmFiles :: GeneralFlag
Opt_KeepHiFiles :: GeneralFlag
Opt_KeepOFiles :: GeneralFlag
Opt_BuildDynamicToo :: GeneralFlag
Opt_WriteIfSimplifiedCore :: GeneralFlag
Opt_UseBytecodeRatherThanObjects :: GeneralFlag
Opt_DistrustAllPackages :: GeneralFlag
Opt_PackageTrust :: GeneralFlag
Opt_PluginTrustworthy :: GeneralFlag
Opt_G_NoStateHack :: GeneralFlag
Opt_G_NoOptCoercion :: GeneralFlag
data WarningFlag
Opt_WarnDuplicateExports :: WarningFlag
Opt_WarnDuplicateConstraints :: WarningFlag
Opt_WarnRedundantConstraints :: WarningFlag
Opt_WarnHiShadows :: WarningFlag
Opt_WarnImplicitPrelude :: WarningFlag
Opt_WarnIncompletePatterns :: WarningFlag
Opt_WarnIncompleteUniPatterns :: WarningFlag
Opt_WarnIncompletePatternsRecUpd :: WarningFlag
Opt_WarnOverflowedLiterals :: WarningFlag
Opt_WarnEmptyEnumerations :: WarningFlag
Opt_WarnMissingFields :: WarningFlag
Opt_WarnMissingImportList :: WarningFlag
Opt_WarnMissingMethods :: WarningFlag
Opt_WarnMissingSignatures :: WarningFlag
Opt_WarnMissingLocalSignatures :: WarningFlag
Opt_WarnNameShadowing :: WarningFlag
Opt_WarnOverlappingPatterns :: WarningFlag
Opt_WarnTypeDefaults :: WarningFlag
Opt_WarnMonomorphism :: WarningFlag
Opt_WarnUnusedTopBinds :: WarningFlag
Opt_WarnUnusedLocalBinds :: WarningFlag
Opt_WarnUnusedPatternBinds :: WarningFlag
Opt_WarnUnusedImports :: WarningFlag
Opt_WarnUnusedMatches :: WarningFlag
Opt_WarnUnusedTypePatterns :: WarningFlag
Opt_WarnUnusedForalls :: WarningFlag
Opt_WarnUnusedRecordWildcards :: WarningFlag
Opt_WarnRedundantBangPatterns :: WarningFlag
Opt_WarnRedundantRecordWildcards :: WarningFlag
Opt_WarnDeprecatedFlags :: WarningFlag
Opt_WarnMissingMonadFailInstances :: WarningFlag
Opt_WarnSemigroup :: WarningFlag
Opt_WarnDodgyExports :: WarningFlag
Opt_WarnDodgyImports :: WarningFlag
Opt_WarnOrphans :: WarningFlag
Opt_WarnAutoOrphans :: WarningFlag
Opt_WarnIdentities :: WarningFlag
Opt_WarnTabs :: WarningFlag
Opt_WarnUnrecognisedPragmas :: WarningFlag
Opt_WarnMisplacedPragmas :: WarningFlag
Opt_WarnDodgyForeignImports :: WarningFlag
Opt_WarnUnusedDoBind :: WarningFlag
Opt_WarnWrongDoBind :: WarningFlag
Opt_WarnAlternativeLayoutRuleTransitional :: WarningFlag
Opt_WarnUnsafe :: WarningFlag
Opt_WarnSafe :: WarningFlag
Opt_WarnTrustworthySafe :: WarningFlag
Opt_WarnMissedSpecs :: WarningFlag
Opt_WarnAllMissedSpecs :: WarningFlag
Opt_WarnUnsupportedCallingConventions :: WarningFlag
Opt_WarnUnsupportedLlvmVersion :: WarningFlag
Opt_WarnMissedExtraSharedLib :: WarningFlag
Opt_WarnInlineRuleShadowing :: WarningFlag
Opt_WarnTypedHoles :: WarningFlag
Opt_WarnPartialTypeSignatures :: WarningFlag
Opt_WarnMissingExportedSignatures :: WarningFlag
Opt_WarnUntickedPromotedConstructors :: WarningFlag
Opt_WarnDerivingTypeable :: WarningFlag
Opt_WarnDeferredTypeErrors :: WarningFlag
Opt_WarnDeferredOutOfScopeVariables :: WarningFlag
Opt_WarnNonCanonicalMonadInstances :: WarningFlag
Opt_WarnNonCanonicalMonadFailInstances :: WarningFlag
Opt_WarnNonCanonicalMonoidInstances :: WarningFlag
Opt_WarnMissingPatternSynonymSignatures :: WarningFlag
Opt_WarnUnrecognisedWarningFlags :: WarningFlag
Opt_WarnSimplifiableClassConstraints :: WarningFlag
Opt_WarnCPPUndef :: WarningFlag
Opt_WarnUnbangedStrictPatterns :: WarningFlag
Opt_WarnMissingHomeModules :: WarningFlag
Opt_WarnPartialFields :: WarningFlag
Opt_WarnMissingExportList :: WarningFlag
Opt_WarnInaccessibleCode :: WarningFlag
Opt_WarnStarIsType :: WarningFlag
Opt_WarnStarBinder :: WarningFlag
Opt_WarnImplicitKindVars :: WarningFlag
Opt_WarnSpaceAfterBang :: WarningFlag
Opt_WarnMissingDerivingStrategies :: WarningFlag
Opt_WarnPrepositiveQualifiedModule :: WarningFlag
Opt_WarnUnusedPackages :: WarningFlag
Opt_WarnInferredSafeImports :: WarningFlag
Opt_WarnMissingSafeHaskellMode :: WarningFlag
Opt_WarnCompatUnqualifiedImports :: WarningFlag
Opt_WarnDerivingDefaults :: WarningFlag
Opt_WarnInvalidHaddock :: WarningFlag
Opt_WarnOperatorWhitespaceExtConflict :: WarningFlag
Opt_WarnOperatorWhitespace :: WarningFlag
Opt_WarnAmbiguousFields :: WarningFlag
Opt_WarnImplicitLift :: WarningFlag
Opt_WarnMissingKindSignatures :: WarningFlag
Opt_WarnMissingPolyKindSignatures :: WarningFlag
Opt_WarnMissingExportedPatternSynonymSignatures :: WarningFlag
Opt_WarnRedundantStrictnessFlags :: WarningFlag
Opt_WarnForallIdentifier :: WarningFlag
Opt_WarnUnicodeBidirectionalFormatCharacters :: WarningFlag
Opt_WarnGADTMonoLocalBinds :: WarningFlag
Opt_WarnTypeEqualityOutOfScope :: WarningFlag
Opt_WarnTypeEqualityRequiresOperators :: WarningFlag
Opt_WarnLoopySuperclassSolve :: WarningFlag
Opt_WarnTermVariableCapture :: WarningFlag
Opt_WarnMissingRoleAnnotations :: WarningFlag
Opt_WarnImplicitRhsQuantification :: WarningFlag
Opt_WarnIncompleteExportWarnings :: WarningFlag
Opt_WarnIncompleteRecordSelectors :: WarningFlag
Opt_WarnBadlyStagedTypes :: WarningFlag
Opt_WarnInconsistentFlags :: WarningFlag
Opt_WarnDataKindsTC :: WarningFlag
Opt_WarnDeprecatedTypeAbstractions :: WarningFlag
Opt_WarnDefaultedExceptionContext :: WarningFlag
Opt_WarnViewPatternSignatures :: WarningFlag

-- | The reason <i>why</i> a <a>Diagnostic</a> was emitted in the first
--   place. Diagnostic messages are born within GHC with a very precise
--   reason, which can be completely statically-computed (i.e. this is an
--   error or a warning no matter what), or influenced by the specific
--   state of the <tt>DynFlags</tt> at the moment of the creation of a new
--   <a>Diagnostic</a>. For example, a parsing error is <i>always</i> going
--   to be an error, whereas a 'WarningWithoutFlag Opt_WarnUnusedImports'
--   might turn into an error due to '-Werror' or
--   '-Werror=warn-unused-imports'. Interpreting a <a>DiagnosticReason</a>
--   together with its associated <a>Severity</a> gives us the full
--   picture.
data DiagnosticReason

-- | Born as a warning.
WarningWithoutFlag :: DiagnosticReason

-- | Warning was enabled with the flag.
WarningWithFlags :: !NonEmpty WarningFlag -> DiagnosticReason

-- | Warning was enabled with a custom category.
WarningWithCategory :: !WarningCategory -> DiagnosticReason

-- | Born as an error.
ErrorWithoutFlag :: DiagnosticReason

-- | The single warning case <a>DiagnosticReason</a> is very common.
pattern WarningWithFlag :: WarningFlag -> DiagnosticReason
data Language
Haskell98 :: Language
Haskell2010 :: Language
GHC2021 :: Language
GHC2024 :: Language
type FatalMessager = String -> IO ()
newtype FlushOut
FlushOut :: IO () -> FlushOut

-- | What kind of {-# SCC #-} to add automatically
data ProfAuto

-- | no SCC annotations added
NoProfAuto :: ProfAuto

-- | top-level and nested functions are annotated
ProfAutoAll :: ProfAuto

-- | top-level functions annotated only
ProfAutoTop :: ProfAuto

-- | exported functions annotated only
ProfAutoExports :: ProfAuto

-- | annotate call-sites
ProfAutoCalls :: ProfAuto
hasPprDebug :: DynFlags -> Bool
hasNoDebugOutput :: DynFlags -> Bool
hasNoStateHack :: DynFlags -> Bool
hasNoOptCoercion :: DynFlags -> Bool

-- | Test whether a <a>DumpFlag</a> is set
dopt :: DumpFlag -> DynFlags -> Bool

-- | Set a <a>DumpFlag</a>
dopt_set :: DynFlags -> DumpFlag -> DynFlags

-- | Unset a <a>DumpFlag</a>
dopt_unset :: DynFlags -> DumpFlag -> DynFlags

-- | Test whether a <a>GeneralFlag</a> is set
--   
--   Note that <a>dynamicNow</a> (i.e., dynamic objects built with
--   `-dynamic-too`) always implicitly enables Opt_PIC,
--   Opt_ExternalDynamicRefs, and disables Opt_SplitSections.
gopt :: GeneralFlag -> DynFlags -> Bool

-- | Set a <a>GeneralFlag</a>
gopt_set :: DynFlags -> GeneralFlag -> DynFlags

-- | Unset a <a>GeneralFlag</a>
gopt_unset :: DynFlags -> GeneralFlag -> DynFlags

-- | Test whether a <a>WarningFlag</a> is set
wopt :: WarningFlag -> DynFlags -> Bool

-- | Set a <a>WarningFlag</a>
wopt_set :: DynFlags -> WarningFlag -> DynFlags

-- | Unset a <a>WarningFlag</a>
wopt_unset :: DynFlags -> WarningFlag -> DynFlags

-- | Test whether a <a>WarningFlag</a> is set as fatal
wopt_fatal :: WarningFlag -> DynFlags -> Bool

-- | Mark a <a>WarningFlag</a> as fatal (do not set the flag)
wopt_set_fatal :: DynFlags -> WarningFlag -> DynFlags

-- | Mark a <a>WarningFlag</a> as not fatal
wopt_unset_fatal :: DynFlags -> WarningFlag -> DynFlags

-- | Enable all custom warning categories.
wopt_set_all_custom :: DynFlags -> DynFlags

-- | Disable all custom warning categories.
wopt_unset_all_custom :: DynFlags -> DynFlags

-- | Mark all custom warning categories as fatal (do not set the flags).
wopt_set_all_fatal_custom :: DynFlags -> DynFlags

-- | Mark all custom warning categories as non-fatal.
wopt_unset_all_fatal_custom :: DynFlags -> DynFlags

-- | Set a custom <a>WarningCategory</a>
wopt_set_custom :: DynFlags -> WarningCategory -> DynFlags

-- | Unset a custom <a>WarningCategory</a>
wopt_unset_custom :: DynFlags -> WarningCategory -> DynFlags

-- | Mark a custom <a>WarningCategory</a> as fatal (do not set the flag)
wopt_set_fatal_custom :: DynFlags -> WarningCategory -> DynFlags

-- | Mark a custom <a>WarningCategory</a> as not fatal
wopt_unset_fatal_custom :: DynFlags -> WarningCategory -> DynFlags

-- | Are there any custom warning categories enabled?
wopt_any_custom :: DynFlags -> Bool

-- | Test whether a <a>Extension</a> is set
xopt :: Extension -> DynFlags -> Bool

-- | Set a <a>Extension</a>
xopt_set :: DynFlags -> Extension -> DynFlags

-- | Unset a <a>Extension</a>
xopt_unset :: DynFlags -> Extension -> DynFlags

-- | Set or unset a <a>Extension</a>, unless it has been explicitly set or
--   unset before.
xopt_set_unlessExplSpec :: Extension -> (DynFlags -> Extension -> DynFlags) -> DynFlags -> DynFlags
xopt_DuplicateRecordFields :: DynFlags -> DuplicateRecordFields
xopt_FieldSelectors :: DynFlags -> FieldSelectors
lang_set :: DynFlags -> Maybe Language -> DynFlags
data DynamicTooState

-- | Don't try to build dynamic objects too
DT_Dont :: DynamicTooState

-- | Will still try to generate dynamic objects
DT_OK :: DynamicTooState

-- | Currently generating dynamic objects (in the backend)
DT_Dyn :: DynamicTooState
dynamicTooState :: DynFlags -> DynamicTooState
setDynamicNow :: DynFlags -> DynFlags
data OnOff a
On :: a -> OnOff a
Off :: a -> OnOff a

-- | Contains not only a collection of <a>GeneralFlag</a>s but also a
--   plethora of information relating to the compilation of a single file
--   or GHC session
data DynFlags
DynFlags :: GhcMode -> GhcLink -> !Backend -> {-# UNPACK #-} !GhcNameVersion -> {-# UNPACK #-} !FileSettings -> Platform -> {-# UNPACK #-} !ToolSettings -> {-# UNPACK #-} !PlatformMisc -> [(String, String)] -> TempDir -> Int -> Int -> Int -> Int -> Int -> Maybe String -> [Int] -> Maybe ParMakeCount -> Bool -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Int -> Int -> Int -> !Int -> Int -> Maybe Int -> Maybe Int -> Int -> Maybe Word -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Bool -> Maybe Int -> Int -> [FilePath] -> ModuleName -> Maybe String -> IntWithInf -> IntWithInf -> Int -> Int -> Int -> UnitId -> Maybe UnitId -> [(ModuleName, Module)] -> Maybe FilePath -> Maybe String -> Set ModuleName -> [ReexportedModule] -> Ways -> Maybe (String, Int) -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> String -> String -> String -> String -> String -> String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> DynLibLoader -> !Bool -> FilePath -> Maybe FilePath -> [Option] -> IncludeSpecs -> [String] -> [String] -> [String] -> Maybe String -> RtsOptsEnabled -> Bool -> String -> [ModuleName] -> [(ModuleName, String)] -> [String] -> [ExternalPluginSpec] -> FilePath -> Bool -> Bool -> [ModuleName] -> [String] -> [PackageDBFlag] -> [IgnorePackageFlag] -> [PackageFlag] -> [PackageFlag] -> [TrustFlag] -> Maybe FilePath -> EnumSet DumpFlag -> EnumSet GeneralFlag -> EnumSet WarningFlag -> EnumSet WarningFlag -> WarningCategorySet -> WarningCategorySet -> Maybe Language -> SafeHaskellMode -> Bool -> Bool -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> [OnOff Extension] -> EnumSet Extension -> !UnfoldingOpts -> Int -> Int -> Int -> FlushOut -> Maybe FilePath -> Maybe String -> [String] -> Int -> Int -> Bool -> OverridingBool -> Bool -> OverridingBool -> Bool -> Scheme -> ProfAuto -> [CallerCcFilter] -> Maybe String -> Maybe SseVersion -> Maybe BmiVersion -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Int -> Int -> Int -> Bool -> Maybe Int -> Word64 -> Int -> Weights -> DynFlags
[ghcMode] :: DynFlags -> GhcMode
[ghcLink] :: DynFlags -> GhcLink

-- | The backend to use (if any).
--   
--   Whenever you change the backend, also make sure to set <a>ghcLink</a>
--   to something sensible.
--   
--   <tt>NoBackend</tt> can be used to avoid generating any output,
--   however, note that:
--   
--   <ul>
--   <li>If a program uses Template Haskell the typechecker may need to run
--   code from an imported module. To facilitate this, code generation is
--   enabled for modules imported by modules that use template haskell,
--   using the default backend for the platform. See Note [-fno-code
--   mode].</li>
--   </ul>
[backend] :: DynFlags -> !Backend
[ghcNameVersion] :: DynFlags -> {-# UNPACK #-} !GhcNameVersion
[fileSettings] :: DynFlags -> {-# UNPACK #-} !FileSettings
[targetPlatform] :: DynFlags -> Platform
[toolSettings] :: DynFlags -> {-# UNPACK #-} !ToolSettings
[platformMisc] :: DynFlags -> {-# UNPACK #-} !PlatformMisc
[rawSettings] :: DynFlags -> [(String, String)]
[tmpDir] :: DynFlags -> TempDir

-- | LLVM optimisation level
[llvmOptLevel] :: DynFlags -> Int

-- | Verbosity level: see Note [Verbosity levels]
[verbosity] :: DynFlags -> Int

-- | How much debug information to produce
[debugLevel] :: DynFlags -> Int

-- | Number of simplifier phases
[simplPhases] :: DynFlags -> Int

-- | Max simplifier iterations
[maxSimplIterations] :: DynFlags -> Int
[ruleCheck] :: DynFlags -> Maybe String

-- | Additional demand analysis
[strictnessBefore] :: DynFlags -> [Int]

-- | The number of modules to compile in parallel If unspecified, compile
--   with a single job.
[parMakeCount] :: DynFlags -> Maybe ParMakeCount

-- | Enable RTS timing statistics?
[enableTimeStats] :: DynFlags -> Bool

-- | The heap size to set.
[ghcHeapSize] :: DynFlags -> Maybe Int

-- | Maximum number of bindings from the type envt to show in type error
--   messages
[maxRelevantBinds] :: DynFlags -> Maybe Int

-- | Maximum number of hole fits to show in typed hole error messages
[maxValidHoleFits] :: DynFlags -> Maybe Int

-- | Maximum number of refinement hole fits to show in typed hole error
--   messages
[maxRefHoleFits] :: DynFlags -> Maybe Int

-- | Maximum level of refinement for refinement hole fits in typed hole
--   error messages
[refLevelHoleFits] :: DynFlags -> Maybe Int

-- | Maximum number of unmatched patterns to show in non-exhaustiveness
--   warnings
[maxUncoveredPatterns] :: DynFlags -> Int

-- | Soft limit on the number of models the pattern match checker checks a
--   pattern against. A safe guard against exponential blow-up.
[maxPmCheckModels] :: DynFlags -> Int

-- | Multiplier for simplifier ticks
[simplTickFactor] :: DynFlags -> Int

-- | Whether DmdAnal should optimistically put an Unboxed demand on
--   returned products with at most this number of fields
[dmdUnboxWidth] :: DynFlags -> !Int
[ifCompression] :: DynFlags -> Int

-- | Threshold for SpecConstr
[specConstrThreshold] :: DynFlags -> Maybe Int

-- | Max number of specialisations for any one function
[specConstrCount] :: DynFlags -> Maybe Int

-- | Max number of specialisations for recursive types Not optional;
--   otherwise ForceSpecConstr can diverge.
[specConstrRecursive] :: DynFlags -> Int

-- | Binary literals (e.g. strings) whose size is above this threshold will
--   be dumped in a binary file by the assembler code generator. 0 and
--   Nothing disables this feature. See <a>Config</a>.
[binBlobThreshold] :: DynFlags -> Maybe Word

-- | Threshold for LiberateCase
[liberateCaseThreshold] :: DynFlags -> Maybe Int

-- | Arg count for lambda floating See <a>FloatOutSwitches</a>
[floatLamArgs] :: DynFlags -> Maybe Int

-- | Maximum number of arguments after lambda lifting a recursive function.
[liftLamsRecArgs] :: DynFlags -> Maybe Int

-- | Maximum number of arguments after lambda lifting a non-recursive
--   function.
[liftLamsNonRecArgs] :: DynFlags -> Maybe Int

-- | Lambda lift even when this turns a known call into an unknown call.
[liftLamsKnown] :: DynFlags -> Bool

-- | Align Cmm functions at this boundary or use default.
[cmmProcAlignment] :: DynFlags -> Maybe Int

-- | Simplification history size
[historySize] :: DynFlags -> Int
[importPaths] :: DynFlags -> [FilePath]
[mainModuleNameIs] :: DynFlags -> ModuleName
[mainFunIs] :: DynFlags -> Maybe String

-- | Typechecker maximum stack depth
[reductionDepth] :: DynFlags -> IntWithInf

-- | Number of iterations in the constraints solver Typically only 1 is
--   needed
[solverIterations] :: DynFlags -> IntWithInf

-- | Number of layers of superclass expansion for givens Should be &lt;
--   solverIterations See Note [Expanding Recursive Superclasses and
--   ExpansionFuel]
[givensFuel] :: DynFlags -> Int

-- | Number of layers of superclass expansion for wanteds Should be &lt;
--   givensFuel See Note [Expanding Recursive Superclasses and
--   ExpansionFuel]
[wantedsFuel] :: DynFlags -> Int

-- | Number of layers of superclass expansion for quantified constraints
--   Should be &lt; givensFuel See Note [Expanding Recursive Superclasses
--   and ExpansionFuel]
[qcsFuel] :: DynFlags -> Int

-- | Target home unit-id
[homeUnitId_] :: DynFlags -> UnitId

-- | Id of the unit to instantiate
[homeUnitInstanceOf_] :: DynFlags -> Maybe UnitId

-- | Module instantiations
[homeUnitInstantiations_] :: DynFlags -> [(ModuleName, Module)]
[workingDirectory] :: DynFlags -> Maybe FilePath

-- | What the package is called, use with multiple home units
[thisPackageName] :: DynFlags -> Maybe String
[hiddenModules] :: DynFlags -> Set ModuleName
[reexportedModules] :: DynFlags -> [ReexportedModule]

-- | Target way flags from the command line
[targetWays_] :: DynFlags -> Ways
[splitInfo] :: DynFlags -> Maybe (String, Int)
[objectDir] :: DynFlags -> Maybe String
[dylibInstallName] :: DynFlags -> Maybe String
[hiDir] :: DynFlags -> Maybe String
[hieDir] :: DynFlags -> Maybe String
[stubDir] :: DynFlags -> Maybe String
[dumpDir] :: DynFlags -> Maybe String
[objectSuf_] :: DynFlags -> String
[hcSuf] :: DynFlags -> String
[hiSuf_] :: DynFlags -> String
[hieSuf] :: DynFlags -> String
[dynObjectSuf_] :: DynFlags -> String
[dynHiSuf_] :: DynFlags -> String
[outputFile_] :: DynFlags -> Maybe String
[dynOutputFile_] :: DynFlags -> Maybe String
[outputHi] :: DynFlags -> Maybe String
[dynOutputHi] :: DynFlags -> Maybe String
[dynLibLoader] :: DynFlags -> DynLibLoader

-- | Indicate if we are now generating dynamic output because of
--   -dynamic-too. This predicate is used to query the appropriate fields
--   (outputFile/dynOutputFile, ways, etc.)
[dynamicNow] :: DynFlags -> !Bool

-- | This defaults to 'non-module'. It can be set by <a>setDumpPrefix</a>
--   or 'ghc.GHCi.UI.runStmt' based on where its output is going.
[dumpPrefix] :: DynFlags -> FilePath

-- | Override the <a>dumpPrefix</a> set by <a>setDumpPrefix</a> or
--   'ghc.GHCi.UI.runStmt'. Set by <tt>-ddump-file-prefix</tt>
[dumpPrefixForce] :: DynFlags -> Maybe FilePath
[ldInputs] :: DynFlags -> [Option]
[includePaths] :: DynFlags -> IncludeSpecs
[libraryPaths] :: DynFlags -> [String]
[frameworkPaths] :: DynFlags -> [String]
[cmdlineFrameworks] :: DynFlags -> [String]
[rtsOpts] :: DynFlags -> Maybe String
[rtsOptsEnabled] :: DynFlags -> RtsOptsEnabled
[rtsOptsSuggestions] :: DynFlags -> Bool

-- | Path to store the .mix files
[hpcDir] :: DynFlags -> String

-- | the <tt>-fplugin</tt> flags given on the command line, in *reverse*
--   order that they're specified on the command line.
[pluginModNames] :: DynFlags -> [ModuleName]
[pluginModNameOpts] :: DynFlags -> [(ModuleName, String)]

-- | the <tt>-ffrontend-opt</tt> flags given on the command line, in
--   *reverse* order that they're specified on the command line.
[frontendPluginOpts] :: DynFlags -> [String]

-- | External plugins loaded from shared libraries
[externalPluginSpecs] :: DynFlags -> [ExternalPluginSpec]
[depMakefile] :: DynFlags -> FilePath
[depIncludePkgDeps] :: DynFlags -> Bool
[depIncludeCppDeps] :: DynFlags -> Bool
[depExcludeMods] :: DynFlags -> [ModuleName]
[depSuffixes] :: DynFlags -> [String]

-- | The <tt>-package-db</tt> flags given on the command line, In *reverse*
--   order that they're specified on the command line. This is intended to
--   be applied with the list of "initial" package databases derived from
--   <tt>GHC_PACKAGE_PATH</tt>; see <tt>getUnitDbRefs</tt>.
[packageDBFlags] :: DynFlags -> [PackageDBFlag]

-- | The <tt>-ignore-package</tt> flags from the command line. In *reverse*
--   order that they're specified on the command line.
[ignorePackageFlags] :: DynFlags -> [IgnorePackageFlag]

-- | The <tt>-package</tt> and <tt>-hide-package</tt> flags from the
--   command-line. In *reverse* order that they're specified on the command
--   line.
[packageFlags] :: DynFlags -> [PackageFlag]

-- | The <tt>-plugin-package-id</tt> flags from command line. In *reverse*
--   order that they're specified on the command line.
[pluginPackageFlags] :: DynFlags -> [PackageFlag]

-- | The <tt>-trust</tt> and <tt>-distrust</tt> flags. In *reverse* order
--   that they're specified on the command line.
[trustFlags] :: DynFlags -> [TrustFlag]

-- | Filepath to the package environment file (if overriding default)
[packageEnv] :: DynFlags -> Maybe FilePath
[dumpFlags] :: DynFlags -> EnumSet DumpFlag
[generalFlags] :: DynFlags -> EnumSet GeneralFlag
[warningFlags] :: DynFlags -> EnumSet WarningFlag
[fatalWarningFlags] :: DynFlags -> EnumSet WarningFlag
[customWarningCategories] :: DynFlags -> WarningCategorySet
[fatalCustomWarningCategories] :: DynFlags -> WarningCategorySet
[language] :: DynFlags -> Maybe Language

-- | Safe Haskell mode
[safeHaskell] :: DynFlags -> SafeHaskellMode
[safeInfer] :: DynFlags -> Bool
[safeInferred] :: DynFlags -> Bool
[thOnLoc] :: DynFlags -> SrcSpan
[newDerivOnLoc] :: DynFlags -> SrcSpan
[deriveViaOnLoc] :: DynFlags -> SrcSpan
[overlapInstLoc] :: DynFlags -> SrcSpan
[incoherentOnLoc] :: DynFlags -> SrcSpan
[pkgTrustOnLoc] :: DynFlags -> SrcSpan
[warnSafeOnLoc] :: DynFlags -> SrcSpan
[warnUnsafeOnLoc] :: DynFlags -> SrcSpan
[trustworthyOnLoc] :: DynFlags -> SrcSpan
[extensions] :: DynFlags -> [OnOff Extension]
[extensionFlags] :: DynFlags -> EnumSet Extension

-- | Unfolding control See Note [Discounts and thresholds] in
--   GHC.Core.Unfold
[unfoldingOpts] :: DynFlags -> !UnfoldingOpts
[maxWorkerArgs] :: DynFlags -> Int
[maxForcedSpecArgs] :: DynFlags -> Int
[ghciHistSize] :: DynFlags -> Int
[flushOut] :: DynFlags -> FlushOut
[ghcVersionFile] :: DynFlags -> Maybe FilePath
[haddockOptions] :: DynFlags -> Maybe String

-- | GHCi scripts specified by -ghci-script, in reverse order
[ghciScripts] :: DynFlags -> [String]
[pprUserLength] :: DynFlags -> Int
[pprCols] :: DynFlags -> Int
[useUnicode] :: DynFlags -> Bool
[useColor] :: DynFlags -> OverridingBool
[canUseColor] :: DynFlags -> Bool
[useErrorLinks] :: DynFlags -> OverridingBool
[canUseErrorLinks] :: DynFlags -> Bool
[colScheme] :: DynFlags -> Scheme

-- | what kind of {-# SCC #-} to add automatically
[profAuto] :: DynFlags -> ProfAuto
[callerCcFilters] :: DynFlags -> [CallerCcFilter]
[interactivePrint] :: DynFlags -> Maybe String

-- | Machine dependent flags (-m&lt;blah&gt; stuff)
[sseVersion] :: DynFlags -> Maybe SseVersion
[bmiVersion] :: DynFlags -> Maybe BmiVersion
[avx] :: DynFlags -> Bool
[avx2] :: DynFlags -> Bool
[avx512cd] :: DynFlags -> Bool
[avx512er] :: DynFlags -> Bool
[avx512f] :: DynFlags -> Bool
[avx512pf] :: DynFlags -> Bool

-- | Enable FMA instructions.
[fma] :: DynFlags -> Bool

-- | Max size, in bytes, of inline array allocations.
[maxInlineAllocSize] :: DynFlags -> Int

-- | Only inline memcpy if it generates no more than this many pseudo
--   (roughly: Cmm) instructions.
[maxInlineMemcpyInsns] :: DynFlags -> Int

-- | Only inline memset if it generates no more than this many pseudo
--   (roughly: Cmm) instructions.
[maxInlineMemsetInsns] :: DynFlags -> Int

-- | Reverse the order of error messages in GHC/GHCi
[reverseErrors] :: DynFlags -> Bool

-- | Limit the maximum number of errors to show
[maxErrors] :: DynFlags -> Maybe Int

-- | Unique supply configuration for testing build determinism
[initialUnique] :: DynFlags -> Word64
[uniqueIncrement] :: DynFlags -> Int

-- | Temporary: CFG Edge weights for fast iterations
[cfgWeights] :: DynFlags -> Weights

-- | The type for the -jN argument, specifying that -j on its own
--   represents using the number of machine processors.
data ParMakeCount

-- | Use this many processors (<tt>-j<a>n</a></tt> flag).
ParMakeThisMany :: Int -> ParMakeCount

-- | Use parallelism with as many processors as possible (<tt>-j</tt> flag
--   without an argument).
ParMakeNumProcessors :: ParMakeCount

-- | Use the specific semaphore <tt><a>sem</a></tt> to control parallelism
--   (<tt>-jsem <a>sem</a></tt> flag).
ParMakeSemaphore :: FilePath -> ParMakeCount
ways :: DynFlags -> Ways
class HasDynFlags (m :: Type -> Type)
getDynFlags :: HasDynFlags m => m DynFlags
class ContainsDynFlags t
extractDynFlags :: ContainsDynFlags t => t -> DynFlags
data RtsOptsEnabled
RtsOptsNone :: RtsOptsEnabled
RtsOptsIgnore :: RtsOptsEnabled
RtsOptsIgnoreAll :: RtsOptsEnabled
RtsOptsSafeOnly :: RtsOptsEnabled
RtsOptsAll :: RtsOptsEnabled

-- | The <a>GhcMode</a> tells us whether we're doing multi-module
--   compilation (controlled via the <a>GHC</a> API) or one-shot
--   (single-module) compilation. This makes a difference primarily to the
--   <a>GHC.Unit.Finder</a>: in one-shot mode we look for interface files
--   for imported modules, but in multi-module mode we look for source
--   files in order to check whether they need to be recompiled.
data GhcMode

-- | <tt>--make</tt>, GHCi, etc.
CompManager :: GhcMode

-- | <pre>
--   ghc -c Foo.hs
--   </pre>
OneShot :: GhcMode

-- | <tt>ghc -M</tt>, see <a>GHC.Unit.Finder</a> for why we need this
MkDepend :: GhcMode
isOneShot :: GhcMode -> Bool

-- | What to do in the link step, if there is one.
data GhcLink

-- | Don't link at all
NoLink :: GhcLink

-- | Link object code into a binary
LinkBinary :: GhcLink

-- | Use the in-memory dynamic linker (works for both bytecode and object
--   code).
LinkInMemory :: GhcLink

-- | Link objects into a dynamic lib (DLL on Windows, DSO on ELF platforms)
LinkDynLib :: GhcLink

-- | Link objects into a static lib
LinkStaticLib :: GhcLink

-- | Link objects into a merged "GHCi object"
LinkMergedObj :: GhcLink
isNoLink :: GhcLink -> Bool

-- | Flags for manipulating packages visibility.
data PackageFlag

-- | <tt>-package</tt>, <tt>-package-id</tt>
ExposePackage :: String -> PackageArg -> ModRenaming -> PackageFlag

-- | <pre>
--   -hide-package
--   </pre>
HidePackage :: String -> PackageFlag

-- | We accept flags which make packages visible, but how they select the
--   package varies; this data type reflects what selection criterion is
--   used.
data PackageArg

-- | <tt>-package</tt>, by <tt>PackageName</tt>
PackageArg :: String -> PackageArg

-- | <tt>-package-id</tt>, by <a>Unit</a>
UnitIdArg :: Unit -> PackageArg

-- | Represents the renaming that may be associated with an exposed
--   package, e.g. the <tt>rns</tt> part of <tt>-package "foo (rns)"</tt>.
--   
--   Here are some example parsings of the package flags (where a string
--   literal is punned to be a <a>ModuleName</a>:
--   
--   <ul>
--   <li><tt>-package foo</tt> is <tt>ModRenaming True []</tt></li>
--   <li><tt>-package foo ()</tt> is <tt>ModRenaming False []</tt></li>
--   <li><tt>-package foo (A)</tt> is <tt>ModRenaming False [(<a>A</a>,
--   <a>A</a>)]</tt></li>
--   <li><tt>-package foo (A as B)</tt> is <tt>ModRenaming False
--   [(<a>A</a>, <a>B</a>)]</tt></li>
--   <li><tt>-package foo with (A as B)</tt> is <tt>ModRenaming True
--   [(<a>A</a>, <a>B</a>)]</tt></li>
--   </ul>
data ModRenaming
ModRenaming :: Bool -> [(ModuleName, ModuleName)] -> ModRenaming

-- | Bring all exposed modules into scope?
[modRenamingWithImplicit] :: ModRenaming -> Bool

-- | Bring module <tt>m</tt> into scope under name <tt>n</tt>.
[modRenamings] :: ModRenaming -> [(ModuleName, ModuleName)]
packageFlagsChanged :: DynFlags -> DynFlags -> Bool

-- | Flags for manipulating the set of non-broken packages.
newtype IgnorePackageFlag

-- | <pre>
--   -ignore-package
--   </pre>
IgnorePackage :: String -> IgnorePackageFlag

-- | Flags for manipulating package trust.
data TrustFlag

-- | <pre>
--   -trust
--   </pre>
TrustPackage :: String -> TrustFlag

-- | <pre>
--   -distrust
--   </pre>
DistrustPackage :: String -> TrustFlag
data PackageDBFlag
PackageDB :: PkgDbRef -> PackageDBFlag
NoUserPackageDB :: PackageDBFlag
NoGlobalPackageDB :: PackageDBFlag
ClearPackageDBs :: PackageDBFlag
data PkgDbRef
GlobalPkgDb :: PkgDbRef
UserPkgDb :: PkgDbRef
PkgDbPath :: FilePath -> PkgDbRef

-- | When invoking external tools as part of the compilation pipeline, we
--   pass these a sequence of options on the command-line. Rather than just
--   using a list of Strings, we use a type that allows us to distinguish
--   between filepaths and 'other stuff'. The reason for this is that this
--   type gives us a handle on transforming filenames, and filenames only,
--   to whatever format they're expected to be on a particular platform.
data Option
FileOption :: String -> String -> Option
Option :: String -> Option
showOpt :: Option -> String
data DynLibLoader
Deployable :: DynLibLoader
SystemDependent :: DynLibLoader

-- | Are we building with <tt>-fPIE</tt> or <tt>-fPIC</tt> enabled?
positionIndependent :: DynFlags -> Bool

-- | The set of flags which affect optimisation for the purposes of
--   recompilation avoidance. Specifically, these include flags which
--   affect code generation but not the semantics of the program.
--   
--   See Note [Ignoring some flag changes] in GHC.Iface.Recomp.Flags)
optimisationFlags :: EnumSet GeneralFlag

-- | Get target profile
targetProfile :: DynFlags -> Profile
data ReexportedModule
ReexportedModule :: ModuleName -> ModuleName -> ReexportedModule
[reexportFrom] :: ReexportedModule -> ModuleName
[reexportTo] :: ReexportedModule -> ModuleName

-- | The normal <a>DynFlags</a>. Note that they are not suitable for use in
--   this form and must be fully initialized by <a>runGhc</a> first.
defaultDynFlags :: Settings -> DynFlags

-- | Used by <a>runGhc</a> to partially initialize a new <a>DynFlags</a>
--   value
initDynFlags :: DynFlags -> IO DynFlags
defaultFatalMessager :: FatalMessager
defaultFlushOut :: FlushOut
optLevelFlags :: [([Int], GeneralFlag)]

-- | The language extensions implied by the various language variants. When
--   updating this be sure to update the flag documentation in
--   <tt>docs<i>users_guide</i>exts</tt>.
languageExtensions :: Maybe Language -> [Extension]
type TurnOnFlag = Bool
turnOn :: TurnOnFlag
turnOff :: TurnOnFlag
programName :: DynFlags -> String
projectVersion :: DynFlags -> String
ghcUsagePath :: DynFlags -> FilePath
ghciUsagePath :: DynFlags -> FilePath
topDir :: DynFlags -> FilePath
toolDir :: DynFlags -> Maybe FilePath

-- | The directory for this version of ghc in the user's app directory The
--   appdir used to be in ~/.ghc but to respect the XDG specification we
--   want to move it under $XDG_DATA_HOME/ However, old tooling (like
--   cabal) might still write package environments to the old directory, so
--   we prefer that if a subdirectory of ~/.ghc with the correct target and
--   GHC version suffix exists.
--   
--   i.e. if ~<i>.ghc</i>$UNIQUE_SUBDIR exists we use that otherwise we use
--   $XDG_DATA_HOME/$UNIQUE_SUBDIR
--   
--   UNIQUE_SUBDIR is typically a combination of the target platform and
--   GHC version
versionedAppDir :: String -> ArchOS -> MaybeT IO FilePath
versionedFilePath :: ArchOS -> FilePath
extraGccViaCFlags :: DynFlags -> [String]
globalPackageDatabasePath :: DynFlags -> FilePath

-- | Used to differentiate the scope an include needs to apply to. We have
--   to split the include paths to avoid accidentally forcing recursive
--   includes since -I overrides the system search paths. See #14312.
data IncludeSpecs
IncludeSpecs :: [String] -> [String] -> [String] -> IncludeSpecs
[includePathsQuote] :: IncludeSpecs -> [String]
[includePathsGlobal] :: IncludeSpecs -> [String]

-- | See Note [Implicit include paths]
[includePathsQuoteImplicit] :: IncludeSpecs -> [String]

-- | Append to the list of includes a path that shall be included using
--   `-I` when the C compiler is called. These paths override system search
--   paths.
addGlobalInclude :: IncludeSpecs -> [String] -> IncludeSpecs

-- | Append to the list of includes a path that shall be included using
--   `-iquote` when the C compiler is called. These paths only apply when
--   quoted includes are used. e.g. #include "foo.h"
addQuoteInclude :: IncludeSpecs -> [String] -> IncludeSpecs

-- | Concatenate and flatten the list of global and quoted includes
--   returning just a flat list of paths.
flattenIncludes :: IncludeSpecs -> [String]

-- | These includes are not considered while fingerprinting the flags for
--   iface | See Note [Implicit include paths]
addImplicitQuoteInclude :: IncludeSpecs -> [String] -> IncludeSpecs

-- | Initialize the pretty-printing options
initSDocContext :: DynFlags -> PprStyle -> SDocContext

-- | Initialize the pretty-printing options using the default user style
initDefaultSDocContext :: DynFlags -> SDocContext
initPromotionTickContext :: DynFlags -> PromotionTickContext
isSse4_1Enabled :: DynFlags -> Bool
isSse4_2Enabled :: DynFlags -> Bool
isAvxEnabled :: DynFlags -> Bool
isAvx2Enabled :: DynFlags -> Bool
isAvx512cdEnabled :: DynFlags -> Bool
isAvx512erEnabled :: DynFlags -> Bool
isAvx512fEnabled :: DynFlags -> Bool
isAvx512pfEnabled :: DynFlags -> Bool
isFmaEnabled :: DynFlags -> Bool
isBmiEnabled :: DynFlags -> Bool
isBmi2Enabled :: DynFlags -> Bool
instance GHC.Classes.Eq GHC.Driver.DynFlags.DynLibLoader
instance GHC.Classes.Eq GHC.Driver.DynFlags.DynamicTooState
instance GHC.Classes.Eq GHC.Driver.DynFlags.GhcLink
instance GHC.Classes.Eq GHC.Driver.DynFlags.GhcMode
instance GHC.Classes.Eq GHC.Driver.DynFlags.IgnorePackageFlag
instance GHC.Classes.Eq GHC.Driver.DynFlags.ModRenaming
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Driver.DynFlags.OnOff a)
instance GHC.Classes.Eq GHC.Driver.DynFlags.PackageArg
instance GHC.Classes.Eq GHC.Driver.DynFlags.PackageDBFlag
instance GHC.Classes.Eq GHC.Driver.DynFlags.PackageFlag
instance GHC.Classes.Eq GHC.Driver.DynFlags.PkgDbRef
instance GHC.Classes.Eq GHC.Driver.DynFlags.TrustFlag
instance (GHC.Internal.Base.Monad m, GHC.Driver.DynFlags.HasDynFlags m) => GHC.Driver.DynFlags.HasDynFlags (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Internal.Base.Monad m, GHC.Driver.DynFlags.HasDynFlags m) => GHC.Driver.DynFlags.HasDynFlags (Control.Monad.Trans.Maybe.MaybeT m)
instance (GHC.Internal.Base.Monad m, GHC.Driver.DynFlags.HasDynFlags m) => GHC.Driver.DynFlags.HasDynFlags (Control.Monad.Trans.Reader.ReaderT a m)
instance (GHC.Internal.Base.Monoid a, GHC.Internal.Base.Monad m, GHC.Driver.DynFlags.HasDynFlags m) => GHC.Driver.DynFlags.HasDynFlags (Control.Monad.Trans.Writer.Lazy.WriterT a m)
instance GHC.Classes.Ord GHC.Driver.DynFlags.DynamicTooState
instance GHC.Utils.Outputable.Outputable GHC.Driver.DynFlags.GhcMode
instance GHC.Utils.Outputable.Outputable GHC.Driver.DynFlags.ModRenaming
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Driver.DynFlags.OnOff a)
instance GHC.Utils.Outputable.Outputable GHC.Driver.DynFlags.PackageArg
instance GHC.Utils.Outputable.Outputable GHC.Driver.DynFlags.PackageFlag
instance GHC.Utils.Outputable.Outputable GHC.Driver.DynFlags.ReexportedModule
instance GHC.Internal.Show.Show GHC.Driver.DynFlags.DynamicTooState
instance GHC.Internal.Show.Show GHC.Driver.DynFlags.GhcLink
instance GHC.Internal.Show.Show GHC.Driver.DynFlags.IncludeSpecs
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Driver.DynFlags.OnOff a)
instance GHC.Internal.Show.Show GHC.Driver.DynFlags.PackageArg
instance GHC.Internal.Show.Show GHC.Driver.DynFlags.RtsOptsEnabled


-- | Unit manipulation
module GHC.Unit.State
data UnitState
UnitState :: UnitInfoMap -> PreloadUnitClosure -> UniqFM PackageName UnitId -> UniqMap UnitId UnitId -> UniqMap UnitId UnitId -> [UnitId] -> [(Unit, Maybe PackageArg)] -> [UnitId] -> !ModuleNameProvidersMap -> !ModuleNameProvidersMap -> UniqMap ModuleName [InstantiatedModule] -> !Bool -> UnitState

-- | A mapping of <a>Unit</a> to <a>UnitInfo</a>. This list is adjusted so
--   that only valid units are here. <a>UnitInfo</a> reflects what was
--   stored *on disk*, except for the <tt>trusted</tt> flag, which is
--   adjusted at runtime. (In particular, some units in this map may have
--   the <tt>exposed</tt> flag be <a>False</a>.)
[unitInfoMap] :: UnitState -> UnitInfoMap

-- | The set of transitively reachable units according to the explicitly
--   provided command line arguments. A fully instantiated VirtUnit may
--   only be replaced by a RealUnit from this set. See Note [VirtUnit to
--   RealUnit improvement]
[preloadClosure] :: UnitState -> PreloadUnitClosure

-- | A mapping of <a>PackageName</a> to <a>UnitId</a>. If several units
--   have the same package name (e.g. different instantiations), then we
--   return one of them... This is used when users refer to packages in
--   Backpack includes. And also to resolve package qualifiers with the
--   PackageImports extension.
[packageNameMap] :: UnitState -> UniqFM PackageName UnitId

-- | A mapping from database unit keys to wired in unit ids.
[wireMap] :: UnitState -> UniqMap UnitId UnitId

-- | A mapping from wired in unit ids to unit keys from the database.
[unwireMap] :: UnitState -> UniqMap UnitId UnitId

-- | The units we're going to link in eagerly. This list should be in
--   reverse dependency order; that is, a unit is always mentioned before
--   the units it depends on.
[preloadUnits] :: UnitState -> [UnitId]

-- | Units which we explicitly depend on (from a command line flag). We'll
--   use this to generate version macros and the unused packages warning.
--   The original flag which was used to bring the unit into scope is
--   recorded for the -Wunused-packages warning.
[explicitUnits] :: UnitState -> [(Unit, Maybe PackageArg)]
[homeUnitDepends] :: UnitState -> [UnitId]

-- | This is a full map from <a>ModuleName</a> to all modules which may
--   possibly be providing it. These providers may be hidden (but we'll
--   still want to report them in error messages), or it may be an
--   ambiguous import.
[moduleNameProvidersMap] :: UnitState -> !ModuleNameProvidersMap

-- | A map, like <a>moduleNameProvidersMap</a>, but controlling plugin
--   visibility.
[pluginModuleNameProvidersMap] :: UnitState -> !ModuleNameProvidersMap

-- | A map saying, for each requirement, what interfaces must be merged
--   together when we use them. For example, if our dependencies are
--   <tt>p[A=&lt;A&gt;]</tt> and
--   <tt>q[A=&lt;A&gt;,B=r[C=&lt;A&gt;]:B]</tt>, then the interfaces to
--   merge for A are <tt>p[A=&lt;A&gt;]:A</tt>,
--   <tt>q[A=&lt;A&gt;,B=r[C=&lt;A&gt;]:B]:A</tt> and
--   <tt>r[C=&lt;A&gt;]:C</tt>.
--   
--   There's an entry in this map for each hole in our home library.
[requirementContext] :: UnitState -> UniqMap ModuleName [InstantiatedModule]

-- | Indicate if we can instantiate units on-the-fly.
--   
--   This should only be true when we are type-checking an indefinite unit.
--   See Note [About units] in GHC.Unit.
[allowVirtualUnits] :: UnitState -> !Bool
type PreloadUnitClosure = UniqSet UnitId

-- | Unit database
data UnitDatabase unit
UnitDatabase :: FilePath -> [GenUnitInfo unit] -> UnitDatabase unit
[unitDatabasePath] :: UnitDatabase unit -> FilePath
[unitDatabaseUnits] :: UnitDatabase unit -> [GenUnitInfo unit]
data UnitErr
CloseUnitErr :: !UnitId -> !Maybe UnitId -> UnitErr
PackageFlagErr :: !PackageFlag -> ![(UnitInfo, UnusableUnitReason)] -> UnitErr
TrustFlagErr :: !TrustFlag -> ![(UnitInfo, UnusableUnitReason)] -> UnitErr
emptyUnitState :: UnitState

-- | Read the unit database files, and sets up various internal tables of
--   unit information, according to the unit-related flags on the
--   command-line (<tt>-package</tt>, <tt>-hide-package</tt> etc.)
--   
--   <a>initUnits</a> can be called again subsequently after updating the
--   <a>packageFlags</a> field of the <a>DynFlags</a>, and it will update
--   the <tt>unitState</tt> in <a>DynFlags</a>.
initUnits :: Logger -> DynFlags -> Maybe [UnitDatabase UnitId] -> Set UnitId -> IO ([UnitDatabase UnitId], UnitState, HomeUnit, Maybe PlatformConstants)
readUnitDatabases :: Logger -> UnitConfig -> IO [UnitDatabase UnitId]
readUnitDatabase :: Logger -> UnitConfig -> FilePath -> IO (UnitDatabase UnitId)
getUnitDbRefs :: UnitConfig -> IO [PkgDbRef]

-- | Return the path of a package database from a <a>PkgDbRef</a>. Return
--   <a>Nothing</a> when the user database filepath is expected but the
--   latter doesn't exist.
--   
--   NB: This logic is reimplemented in Cabal, so if you change it, make
--   sure you update Cabal. (Or, better yet, dump it in the compiler info
--   so Cabal can use the info.)
resolveUnitDatabase :: UnitConfig -> PkgDbRef -> IO (Maybe FilePath)

-- | Get a list of entries from the unit database. NB: be careful with this
--   function, although all units in this map are "visible", this does not
--   imply that the exposed-modules of the unit are available (they may
--   have been thinned or renamed).
listUnitInfo :: UnitState -> [UnitInfo]
type UnitInfoMap = UniqMap UnitId UnitInfo

-- | Find the unit we know about with the given unit, if any
lookupUnit :: UnitState -> Unit -> Maybe UnitInfo

-- | A more specialized interface, which doesn't require a <a>UnitState</a>
--   (so it can be used while we're initializing <a>DynFlags</a>)
--   
--   Parameters: * a boolean specifying whether or not to look for
--   on-the-fly renamed interfaces * a <a>UnitInfoMap</a> * a
--   <a>PreloadUnitClosure</a>
lookupUnit' :: Bool -> UnitInfoMap -> PreloadUnitClosure -> Unit -> Maybe UnitInfo

-- | Looks up the given unit in the unit state, panicking if it is not
--   found
unsafeLookupUnit :: HasDebugCallStack => UnitState -> Unit -> UnitInfo

-- | Find the unit we know about with the given unit id, if any
lookupUnitId :: UnitState -> UnitId -> Maybe UnitInfo

-- | Find the unit we know about with the given unit id, if any
lookupUnitId' :: UnitInfoMap -> UnitId -> Maybe UnitInfo

-- | Looks up the given unit id in the unit state, panicking if it is not
--   found
unsafeLookupUnitId :: HasDebugCallStack => UnitState -> UnitId -> UnitInfo

-- | Find the unit we know about with the given package name (e.g.
--   <tt>foo</tt>), if any (NB: there might be a locally defined unit name
--   which overrides this) This function is unsafe to use in general
--   because it doesn't respect package visibility.
lookupPackageName :: UnitState -> PackageName -> Maybe UnitId

-- | Find the UnitId which an import qualified by a package import comes
--   from. Compared to <a>lookupPackageName</a>, this function correctly
--   accounts for visibility, renaming and thinning.
resolvePackageImport :: UnitState -> ModuleName -> PackageName -> Maybe UnitId

-- | Given a fully instantiated <a>InstantiatedUnit</a>, improve it into a
--   <a>RealUnit</a> if we can find it in the package database.
improveUnit :: UnitState -> Unit -> Unit

-- | Search for units with a given package ID (e.g. "foo-0.1")
searchPackageId :: UnitState -> PackageId -> [UnitInfo]
listVisibleModuleNames :: UnitState -> [ModuleName]

-- | Takes a <a>ModuleName</a>, and if the module is in any package returns
--   list of modules which take that name.
lookupModuleInAllUnits :: UnitState -> ModuleName -> [(Module, UnitInfo)]
lookupModuleWithSuggestions :: UnitState -> ModuleName -> PkgQual -> LookupResult

-- | The package which the module **appears** to come from, this could be
--   the one which reexports the module from it's original package. This
--   function is currently only used for -Wunused-packages
lookupModulePackage :: UnitState -> ModuleName -> PkgQual -> Maybe [UnitInfo]
lookupPluginModuleWithSuggestions :: UnitState -> ModuleName -> PkgQual -> LookupResult

-- | Return this list of requirement interfaces that need to be merged to
--   form <tt>mod_name</tt>, or <tt>[]</tt> if this is not a requirement.
requirementMerges :: UnitState -> ModuleName -> [InstantiatedModule]

-- | The result of performing a lookup
data LookupResult

-- | Found the module uniquely, nothing else to do
LookupFound :: Module -> (UnitInfo, ModuleOrigin) -> LookupResult

-- | Multiple modules with the same name in scope
LookupMultiple :: [(Module, ModuleOrigin)] -> LookupResult

-- | No modules found, but there were some hidden ones with an exact name
--   match. First is due to package hidden, second is due to module being
--   hidden
LookupHidden :: [(Module, ModuleOrigin)] -> [(Module, ModuleOrigin)] -> LookupResult

-- | No modules found, but there were some unusable ones with an exact name
--   match
LookupUnusable :: [(Module, ModuleOrigin)] -> LookupResult

-- | Nothing found, here are some suggested different names
LookupNotFound :: [ModuleSuggestion] -> LookupResult
data ModuleSuggestion
SuggestVisible :: ModuleName -> Module -> ModuleOrigin -> ModuleSuggestion
SuggestHidden :: ModuleName -> Module -> ModuleOrigin -> ModuleSuggestion

-- | Given a module name, there may be multiple ways it came into scope,
--   possibly simultaneously. This data type tracks all the possible ways
--   it could have come into scope. Warning: don't use the record
--   functions, they're partial!
data ModuleOrigin

-- | Module is hidden, and thus never will be available for import. (But
--   maybe the user didn't realize), so we'll still keep track of these
--   modules.)
ModHidden :: ModuleOrigin

-- | Module is unavailable because the unit is unusable.
ModUnusable :: !UnusableUnit -> ModuleOrigin

-- | Module is public, and could have come from some places.
ModOrigin :: Maybe Bool -> [UnitInfo] -> [UnitInfo] -> Bool -> ModuleOrigin

-- | <tt>Just False</tt> means that this module is in someone's
--   <tt>exported-modules</tt> list, but that package is hidden; <tt>Just
--   True</tt> means that it is available; <tt>Nothing</tt> means neither
--   applies.
[fromOrigUnit] :: ModuleOrigin -> Maybe Bool

-- | Is the module available from a reexport of an exposed package? There
--   could be multiple.
[fromExposedReexport] :: ModuleOrigin -> [UnitInfo]

-- | Is the module available from a reexport of a hidden package?
[fromHiddenReexport] :: ModuleOrigin -> [UnitInfo]

-- | Did the module export come from a package flag? (ToDo: track more
--   information.
[fromPackageFlag] :: ModuleOrigin -> Bool

-- | A unusable unit module origin
data UnusableUnit
UnusableUnit :: !Unit -> !UnusableUnitReason -> !Bool -> UnusableUnit

-- | Unusable unit
[uuUnit] :: UnusableUnit -> !Unit

-- | Reason
[uuReason] :: UnusableUnit -> !UnusableUnitReason

-- | Is the "module" a reexport?
[uuIsReexport] :: UnusableUnit -> !Bool

-- | The reason why a unit is unusable.
data UnusableUnitReason

-- | We ignored it explicitly using <tt>-ignore-package</tt>.
IgnoredWithFlag :: UnusableUnitReason

-- | This unit transitively depends on a unit that was never present in any
--   of the provided databases.
BrokenDependencies :: [UnitId] -> UnusableUnitReason

-- | This unit transitively depends on a unit involved in a cycle. Note
--   that the list of <a>UnitId</a> reports the direct dependencies of this
--   unit that (transitively) depended on the cycle, and not the actual
--   cycle itself (which we report separately at high verbosity.)
CyclicDependencies :: [UnitId] -> UnusableUnitReason

-- | This unit transitively depends on a unit which was ignored.
IgnoredDependencies :: [UnitId] -> UnusableUnitReason

-- | This unit transitively depends on a unit which was shadowed by an
--   ABI-incompatible unit.
ShadowedDependencies :: [UnitId] -> UnusableUnitReason
pprReason :: SDoc -> UnusableUnitReason -> SDoc

-- | Takes a list of UnitIds (and their "parent" dependency, used for error
--   messages), and returns the list with dependencies included, in reverse
--   dependency order (a units appears before those it depends on).
closeUnitDeps :: UnitInfoMap -> [(UnitId, Maybe UnitId)] -> MaybeErr UnitErr [UnitId]

-- | Similar to closeUnitDeps but takes a list of already loaded units as
--   an additional argument.
closeUnitDeps' :: UnitInfoMap -> [UnitId] -> [(UnitId, Maybe UnitId)] -> MaybeErr UnitErr [UnitId]
mayThrowUnitErr :: MaybeErr UnitErr a -> IO a

-- | Substitution on module variables, mapping module names to module
--   identifiers.
type ShHoleSubst = ModuleNameEnv Module

-- | Substitutes holes in a <a>Unit</a>, suitable for renaming when an
--   include occurs; see Note [Representation of module/name variables].
--   
--   <tt>p[A=&lt;A&gt;]</tt> maps to <tt>p[A=&lt;B&gt;]</tt> with
--   <tt>A=&lt;B&gt;</tt>.
renameHoleUnit :: UnitState -> ShHoleSubst -> Unit -> Unit

-- | Substitutes holes in a <a>Module</a>. NOT suitable for being called
--   directly on a <tt>nameModule</tt>, see Note [Representation of
--   module/name variables]. <tt>p[A=&lt;A&gt;]:B</tt> maps to
--   <tt>p[A=q():A]:B</tt> with <tt>A=q():A</tt>; similarly,
--   <tt>&lt;A&gt;</tt> maps to <tt>q():A</tt>.
renameHoleModule :: UnitState -> ShHoleSubst -> Module -> Module

-- | Like 'renameHoleUnit, but requires only <tt>ClosureUnitInfoMap</tt> so
--   it can be used by <a>GHC.Unit.State</a>.
renameHoleUnit' :: UnitInfoMap -> PreloadUnitClosure -> ShHoleSubst -> Unit -> Unit

-- | Like <a>renameHoleModule</a>, but requires only
--   <tt>ClosureUnitInfoMap</tt> so it can be used by
--   <a>GHC.Unit.State</a>.
renameHoleModule' :: UnitInfoMap -> PreloadUnitClosure -> ShHoleSubst -> Module -> Module

-- | Check the database to see if we already have an installed unit that
--   corresponds to the given <a>InstantiatedUnit</a>.
--   
--   Return a <a>UnitId</a> which either wraps the <a>InstantiatedUnit</a>
--   unchanged or references a matching installed unit.
--   
--   See Note [VirtUnit to RealUnit improvement]
instUnitToUnit :: UnitState -> InstantiatedUnit -> Unit

-- | Injects an <a>InstantiatedModule</a> to <a>Module</a> (see also
--   <a>instUnitToUnit</a>.
instModuleToModule :: UnitState -> InstantiatedModule -> Module
pprFlag :: PackageFlag -> SDoc

-- | Show (very verbose) package info
pprUnits :: UnitState -> SDoc

-- | Show simplified unit info.
--   
--   The idea is to only print package id, and any information that might
--   be different from the package databases (exposure, trust)
pprUnitsSimple :: UnitState -> SDoc

-- | Pretty-print a UnitId for the user.
--   
--   Cabal packages may contain several components (programs, libraries,
--   etc.). As far as GHC is concerned, installed package components
--   ("units") are identified by an opaque UnitId string provided by Cabal.
--   As the string contains a hash, we don't want to display it to users so
--   GHC queries the database to retrieve some infos about the original
--   source package (name, version, component name).
--   
--   Instead we want to display: packagename-version[:componentname]
--   
--   Component name is only displayed if it isn't the default library
--   
--   To do this we need to query a unit database.
pprUnitIdForUser :: UnitState -> UnitId -> SDoc
pprUnitInfoForUser :: UnitInfo -> SDoc

-- | Show the mapping of modules to where they come from.
pprModuleMap :: ModuleNameProvidersMap -> SDoc

-- | Print unit-ids with UnitInfo found in the given UnitState
pprWithUnitState :: UnitState -> SDoc -> SDoc

-- | Given a wired-in <a>Unit</a>, "unwire" it into the <a>Unit</a> that it
--   was recorded as in the package database.
unwireUnit :: UnitState -> Unit -> Unit
instance GHC.Internal.Base.Monoid GHC.Unit.State.ModuleOrigin
instance GHC.Internal.Base.Monoid GHC.Unit.State.UnitVisibility
instance GHC.Utils.Outputable.Outputable GHC.Unit.State.ModuleOrigin
instance GHC.Utils.Outputable.Outputable u => GHC.Utils.Outputable.Outputable (GHC.Unit.State.UnitDatabase u)
instance GHC.Utils.Outputable.Outputable GHC.Unit.State.UnitErr
instance GHC.Utils.Outputable.Outputable GHC.Unit.State.UnitVisibility
instance GHC.Utils.Outputable.Outputable GHC.Unit.State.UnusableUnitReason
instance GHC.Internal.Base.Semigroup GHC.Unit.State.ModuleOrigin
instance GHC.Internal.Base.Semigroup GHC.Unit.State.UnitVisibility


-- | Dependencies and Usage of a module
module GHC.Unit.Module.Deps

-- | Dependency information about ALL modules and packages below this one
--   in the import hierarchy. This is the serialisable version of
--   <a>ImportAvails</a>.
--   
--   Invariant: the dependencies of a module <tt>M</tt> never includes
--   <tt>M</tt>.
--   
--   Invariant: none of the lists contain duplicates.
--   
--   Invariant: lists are ordered canonically (e.g. using stableModuleCmp)
--   
--   See Note [Transitive Information in Dependencies]
data Dependencies

-- | Extract information from the rename and typecheck phases to produce a
--   dependencies information for the module being compiled.
--   
--   The fourth argument is a list of plugin modules.
mkDependencies :: HomeUnit -> Module -> ImportAvails -> [Module] -> Dependencies
noDependencies :: Dependencies

-- | All home-package modules which are directly imported by this one. This
--   may include modules from other units when using multiple home units
dep_direct_mods :: Dependencies -> Set (UnitId, ModuleNameWithIsBoot)

-- | All packages directly imported by this module I.e. packages to which
--   this module's direct imports belong. Does not include other home units
--   when using multiple home units. Modules from these units will go in
--   <a>dep_direct_mods</a>
dep_direct_pkgs :: Dependencies -> Set UnitId

-- | Transitive closure of hsig files in the home package
dep_sig_mods :: Dependencies -> [ModuleName]
dep_trusted_pkgs :: Dependencies -> Set UnitId

-- | Transitive closure of orphan modules (whether home or external pkg).
--   
--   (Possible optimization: don't include family instance orphans as they
--   are anyway included in <a>dep_finsts</a>. But then be careful about
--   code which relies on dep_orphs having the complete list!) This does
--   NOT include us, unlike <a>imp_orphs</a>.
dep_orphs :: Dependencies -> [Module]

-- | All units needed for plugins
dep_plugin_pkgs :: Dependencies -> Set UnitId

-- | Transitive closure of depended upon modules which contain family
--   instances (whether home or external). This is used by
--   <tt>checkFamInstConsistency</tt>. This does NOT include us, unlike
--   <a>imp_finsts</a>. See Note [The type family instance consistency
--   story].
dep_finsts :: Dependencies -> [Module]

-- | All modules which have boot files below this one, and whether we
--   should use the boot file or not. This information is only used to
--   populate the eps_is_boot field. See Note [Structure of dep_boot_mods]
dep_boot_mods :: Dependencies -> Set (UnitId, ModuleNameWithIsBoot)

-- | Update module dependencies containing orphans (used by Backpack)
dep_orphs_update :: Monad m => Dependencies -> ([Module] -> m [Module]) -> m Dependencies

-- | Update module dependencies containing family instances (used by
--   Backpack)
dep_finsts_update :: Monad m => Dependencies -> ([Module] -> m [Module]) -> m Dependencies

-- | Pretty-print unit dependencies
pprDeps :: UnitState -> Dependencies -> SDoc

-- | Records modules for which changes may force recompilation of this
--   module See wiki:
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/recompilation-avoidance</a>
--   
--   This differs from Dependencies. A module X may be in the dep_mods of
--   this module (via an import chain) but if we don't use anything from X
--   it won't appear in our Usage
data Usage

-- | Module from another package
UsagePackageModule :: Module -> Fingerprint -> IsSafeImport -> Usage

-- | External package module depended on
[usg_mod] :: Usage -> Module

-- | Cached module ABI fingerprint (corresponds to mi_mod_hash)
[usg_mod_hash] :: Usage -> Fingerprint

-- | Was this module imported as a safe import
[usg_safe] :: Usage -> IsSafeImport

-- | Module from the current package
UsageHomeModule :: ModuleName -> UnitId -> Fingerprint -> [(OccName, Fingerprint)] -> Maybe Fingerprint -> IsSafeImport -> Usage

-- | Name of the module
[usg_mod_name] :: Usage -> ModuleName

-- | UnitId of the HomeUnit the module is from
[usg_unit_id] :: Usage -> UnitId

-- | Cached module ABI fingerprint (corresponds to mi_mod_hash)
[usg_mod_hash] :: Usage -> Fingerprint

-- | Entities we depend on, sorted by occurrence name and fingerprinted.
--   NB: usages are for parent names only, e.g. type constructors but not
--   the associated data constructors.
[usg_entities] :: Usage -> [(OccName, Fingerprint)]

-- | Fingerprint for the export list of this module, if we directly
--   imported it (and hence we depend on its export list)
[usg_exports] :: Usage -> Maybe Fingerprint

-- | Was this module imported as a safe import
[usg_safe] :: Usage -> IsSafeImport

-- | A file upon which the module depends, e.g. a CPP #include, or using
--   TH's <tt>addDependentFile</tt>
UsageFile :: FastString -> Fingerprint -> Maybe String -> Usage

-- | External file dependency. From a CPP #include or TH addDependentFile.
--   Should be absolute.
[usg_file_path] :: Usage -> FastString

-- | <a>Fingerprint</a> of the file contents.
[usg_file_hash] :: Usage -> Fingerprint

-- | An optional string which is used in recompilation messages if file in
--   question has changed.
[usg_file_label] :: Usage -> Maybe String
UsageHomeModuleInterface :: ModuleName -> UnitId -> Fingerprint -> Usage

-- | Name of the module
[usg_mod_name] :: Usage -> ModuleName

-- | UnitId of the HomeUnit the module is from
[usg_unit_id] :: Usage -> UnitId

-- | The *interface* hash of the module, not the ABI hash. This changes
--   when anything about the interface (and hence the module) has changed.
[usg_iface_hash] :: Usage -> Fingerprint

-- | A requirement which was merged into this one.
UsageMergedRequirement :: Module -> Fingerprint -> Usage

-- | External package module depended on
[usg_mod] :: Usage -> Module

-- | Cached module ABI fingerprint (corresponds to mi_mod_hash)
[usg_mod_hash] :: Usage -> Fingerprint

-- | <a>ImportAvails</a> summarises what was imported from where,
--   irrespective of whether the imported things are actually used or not.
--   It is used:
--   
--   <ul>
--   <li>when processing the export list,</li>
--   <li>when constructing usage info for the interface file,</li>
--   <li>to identify the list of directly imported modules for
--   initialisation purposes and for optimised overlap checking of family
--   instances,</li>
--   <li>when figuring out what things are really unused</li>
--   </ul>
data ImportAvails
ImportAvails :: ImportedMods -> InstalledModuleEnv ModuleNameWithIsBoot -> Set UnitId -> Bool -> Set UnitId -> InstalledModuleEnv ModuleNameWithIsBoot -> [ModuleName] -> [Module] -> [Module] -> ImportAvails

-- | Domain is all directly-imported modules
--   
--   See the documentation on ImportedModsVal in
--   <a>GHC.Unit.Module.Imported</a> for the meaning of the fields.
--   
--   We need a full ModuleEnv rather than a ModuleNameEnv here, because we
--   might be importing modules of the same name from different packages.
--   (currently not the case, but might be in the future).
[imp_mods] :: ImportAvails -> ImportedMods

-- | Home-package modules directly imported by the module being compiled.
[imp_direct_dep_mods] :: ImportAvails -> InstalledModuleEnv ModuleNameWithIsBoot

-- | Packages directly needed by the module being compiled
[imp_dep_direct_pkgs] :: ImportAvails -> Set UnitId

-- | Do we require that our own package is trusted? This is to handle
--   efficiently the case where a Safe module imports a Trustworthy module
--   that resides in the same package as it. See Note [Trust Own Package]
--   in <a>GHC.Rename.Names</a>
[imp_trust_own_pkg] :: ImportAvails -> Bool

-- | This records the packages the current module needs to trust for Safe
--   Haskell compilation to succeed. A package is required to be trusted if
--   we are dependent on a trustworthy module in that package. See Note
--   [Tracking Trust Transitively] in <a>GHC.Rename.Names</a>
[imp_trust_pkgs] :: ImportAvails -> Set UnitId

-- | Domain is all modules which have hs-boot files, and whether we should
--   import the boot version of interface file. Only used in one-shot mode
--   to populate eps_is_boot.
[imp_boot_mods] :: ImportAvails -> InstalledModuleEnv ModuleNameWithIsBoot

-- | Signature modules below this one
[imp_sig_mods] :: ImportAvails -> [ModuleName]

-- | Orphan modules below us in the import tree (and maybe including us for
--   imported modules)
[imp_orphs] :: ImportAvails -> [Module]

-- | Family instance modules below us in the import tree (and maybe
--   including us for imported modules)
[imp_finsts] :: ImportAvails -> [Module]
instance GHC.Utils.Binary.Binary GHC.Unit.Module.Deps.Dependencies
instance GHC.Utils.Binary.Binary GHC.Unit.Module.Deps.Usage
instance GHC.Classes.Eq GHC.Unit.Module.Deps.Dependencies
instance GHC.Classes.Eq GHC.Unit.Module.Deps.Usage


-- | Units are library components from Cabal packages compiled and
--   installed in a database
module GHC.Unit

module GHC.Types.Target

-- | A compilation target.
--   
--   A target may be supplied with the actual text of the module. If so,
--   use this instead of the file contents (this is for use in an IDE where
--   the file hasn't been saved by the user yet).
--   
--   These fields are strict because Targets are long lived.
data Target
Target :: !TargetId -> !Bool -> !UnitId -> !Maybe (InputFileBuffer, UTCTime) -> Target

-- | module or filename
[targetId] :: Target -> !TargetId

-- | object code allowed?
[targetAllowObjCode] :: Target -> !Bool

-- | id of the unit this target is part of
[targetUnitId] :: Target -> !UnitId

-- | Optional in-memory buffer containing the source code GHC should use
--   for this target instead of reading it from disk.
--   
--   Since GHC version 8.10 modules which require preprocessors such as
--   Literate Haskell or CPP to run are also supported.
--   
--   If a corresponding source file does not exist on disk this will result
--   in a <tt>SourceError</tt> exception if <tt>targetId = TargetModule
--   _</tt> is used. However together with <tt>targetId = TargetFile _</tt>
--   GHC will not complain about the file missing.
[targetContents] :: Target -> !Maybe (InputFileBuffer, UTCTime)
data TargetId

-- | A module name: search for the file
TargetModule :: !ModuleName -> TargetId

-- | A filename: preprocess &amp; parse it to find the module name. If
--   specified, the Phase indicates how to compile this file (which phase
--   to start from). Nothing indicates the starting phase should be
--   determined from the suffix of the filename.
TargetFile :: !FilePath -> !Maybe Phase -> TargetId
type InputFileBuffer = StringBuffer
pprTarget :: Target -> SDoc
pprTargetId :: TargetId -> SDoc
instance GHC.Classes.Eq GHC.Types.Target.TargetId
instance GHC.Utils.Outputable.Outputable GHC.Types.Target.Target
instance GHC.Utils.Outputable.Outputable GHC.Types.Target.TargetId

module GHC.HsToCore.Ticks

-- | Configuration for compilation pass to add tick for instrumentation to
--   binding sites.
data TicksConfig
TicksConfig :: ![TickishType] -> !ProfAuto -> !Bool -> TicksConfig

-- | What purposes do we need ticks for
[ticks_passes] :: TicksConfig -> ![TickishType]

-- | What kind of {-# SCC #-} to add automatically
[ticks_profAuto] :: TicksConfig -> !ProfAuto

-- | Whether to count the entries to functions
--   
--   Requires extra synchronization which can vastly degrade performance.
[ticks_countEntries] :: TicksConfig -> !Bool
data Tick
Tick :: SrcSpan -> [String] -> [OccName] -> BoxLabel -> Tick

-- | Tick source span
[tick_loc] :: Tick -> SrcSpan

-- | Path to the declaration
[tick_path] :: Tick -> [String]

-- | Identifiers being bound
[tick_ids] :: Tick -> [OccName]

-- | Label for the tick counter
[tick_label] :: Tick -> BoxLabel

-- | Reasons why we need ticks,
data TickishType

-- | For profiling
ProfNotes :: TickishType

-- | For Haskell Program Coverage
HpcTicks :: TickishType

-- | For ByteCode interpreter break points
Breakpoints :: TickishType

-- | For source notes
SourceNotes :: TickishType
addTicksToBinds :: Logger -> TicksConfig -> Module -> ModLocation -> NameSet -> [TyCon] -> LHsBinds GhcTc -> IO (LHsBinds GhcTc, Maybe (FilePath, SizedSeq Tick))
isGoodSrcSpan' :: SrcSpan -> Bool

-- | Strip CoreTicks from an HsExpr
stripTicksTopHsExpr :: HsExpr GhcTc -> ([CoreTickish], HsExpr GhcTc)
instance GHC.Internal.Base.Applicative GHC.HsToCore.Ticks.TM
instance GHC.Classes.Eq GHC.HsToCore.Ticks.TickDensity
instance GHC.Classes.Eq GHC.HsToCore.Ticks.TickishType
instance GHC.Internal.Base.Functor GHC.HsToCore.Ticks.TM
instance GHC.Internal.Base.Monad GHC.HsToCore.Ticks.TM

module GHC.Iface.Errors.Types
data MissingInterfaceError
BadSourceImport :: !Module -> MissingInterfaceError
HomeModError :: !InstalledModule -> !ModLocation -> MissingInterfaceError
DynamicHashMismatchError :: !Module -> !ModLocation -> MissingInterfaceError
CantFindErr :: !UnitState -> FindingModuleOrInterface -> CantFindInstalled -> MissingInterfaceError
BadIfaceFile :: ReadInterfaceError -> MissingInterfaceError
FailedToLoadDynamicInterface :: Module -> ReadInterfaceError -> MissingInterfaceError
data InterfaceLookingFor
LookingForName :: !Name -> InterfaceLookingFor
LookingForHiBoot :: !Module -> InterfaceLookingFor
LookingForModule :: !ModuleName -> !IsBootInterface -> InterfaceLookingFor
LookingForSig :: !InstalledModule -> InterfaceLookingFor
data IfaceMessage
Can'tFindInterface :: MissingInterfaceError -> InterfaceLookingFor -> IfaceMessage
Can'tFindNameInInterface :: Name -> [TyThing] -> IfaceMessage
CircularImport :: !Module -> IfaceMessage
data ReadInterfaceError
ExceptionOccurred :: FilePath -> SomeException -> ReadInterfaceError
HiModuleNameMismatchWarn :: FilePath -> Module -> Module -> ReadInterfaceError
data CantFindInstalled
CantFindInstalled :: ModuleName -> CantFindInstalledReason -> CantFindInstalled
data CantFindInstalledReason
NoUnitIdMatching :: UnitId -> [UnitInfo] -> CantFindInstalledReason
MissingPackageFiles :: UnitId -> [FilePath] -> CantFindInstalledReason
MissingPackageWayFiles :: String -> UnitId -> [FilePath] -> CantFindInstalledReason
ModuleSuggestion :: [ModuleSuggestion] -> [FilePath] -> CantFindInstalledReason
NotAModule :: CantFindInstalledReason
CouldntFindInFiles :: [FilePath] -> CantFindInstalledReason
GenericMissing :: [(Unit, Maybe UnitInfo)] -> [Unit] -> [UnusableUnit] -> [FilePath] -> CantFindInstalledReason
MultiplePackages :: [(Module, ModuleOrigin)] -> CantFindInstalledReason
data FindingModuleOrInterface
FindingModule :: FindingModuleOrInterface
FindingInterface :: FindingModuleOrInterface

-- | Pass to a <tt>DriverMessage</tt> the information whether or not the
--   '-fbuilding-cabal-package' flag is set.
data BuildingCabalPackage
YesBuildingCabalPackage :: BuildingCabalPackage
NoBuildingCabalPackage :: BuildingCabalPackage
data IfaceMessageOpts
IfaceMessageOpts :: !Bool -> !BuildingCabalPackage -> IfaceMessageOpts

-- | Whether to show files we tried to look for or not when printing loader
--   errors
[ifaceShowTriedFiles] :: IfaceMessageOpts -> !Bool
[ifaceBuildingCabalPackage] :: IfaceMessageOpts -> !BuildingCabalPackage
instance GHC.Classes.Eq GHC.Iface.Errors.Types.BuildingCabalPackage
instance GHC.Internal.Generics.Generic GHC.Iface.Errors.Types.CantFindInstalled
instance GHC.Internal.Generics.Generic GHC.Iface.Errors.Types.CantFindInstalledReason
instance GHC.Internal.Generics.Generic GHC.Iface.Errors.Types.IfaceMessage
instance GHC.Internal.Generics.Generic GHC.Iface.Errors.Types.MissingInterfaceError
instance GHC.Internal.Generics.Generic GHC.Iface.Errors.Types.ReadInterfaceError


-- | A ModSummary is a node in the compilation manager's dependency graph
--   (ModuleGraph)
module GHC.Unit.Module.ModSummary

-- | Data for a module node in a <tt>ModuleGraph</tt>. Module nodes of the
--   module graph are one of:
--   
--   <ul>
--   <li>A regular Haskell source module</li>
--   <li>A hi-boot source module</li>
--   </ul>
data ModSummary
ModSummary :: Module -> HscSource -> ModLocation -> Fingerprint -> Maybe UTCTime -> !Maybe UTCTime -> Maybe UTCTime -> Maybe UTCTime -> [(PkgQual, Located ModuleName)] -> [(PkgQual, Located ModuleName)] -> !Bool -> Maybe HsParsedModule -> FilePath -> DynFlags -> Maybe StringBuffer -> ModSummary

-- | Identity of the module
[ms_mod] :: ModSummary -> Module

-- | The module source either plain Haskell, hs-boot, or hsig
[ms_hsc_src] :: ModSummary -> HscSource

-- | Location of the various files belonging to the module
[ms_location] :: ModSummary -> ModLocation

-- | Content hash of source file
[ms_hs_hash] :: ModSummary -> Fingerprint

-- | Timestamp of object, if we have one
[ms_obj_date] :: ModSummary -> Maybe UTCTime

-- | Timestamp of dynamic object, if we have one
[ms_dyn_obj_date] :: ModSummary -> !Maybe UTCTime

-- | Timestamp of hi file, if we have one See Note [When source is
--   considered modified] and #9243
[ms_iface_date] :: ModSummary -> Maybe UTCTime

-- | Timestamp of hie file, if we have one
[ms_hie_date] :: ModSummary -> Maybe UTCTime

-- | Source imports of the module
[ms_srcimps] :: ModSummary -> [(PkgQual, Located ModuleName)]

-- | Non-source imports of the module from the module *text*
[ms_textual_imps] :: ModSummary -> [(PkgQual, Located ModuleName)]

-- | Whether the special module GHC.Prim was imported explicitly
[ms_ghc_prim_import] :: ModSummary -> !Bool

-- | The parsed, nonrenamed source, if we have it. This is also used to
--   support "inline module syntax" in Backpack files.
[ms_parsed_mod] :: ModSummary -> Maybe HsParsedModule

-- | Filename of preprocessed source file
[ms_hspp_file] :: ModSummary -> FilePath

-- | Cached flags from <tt>OPTIONS</tt>, <tt>INCLUDE</tt> and
--   <tt>LANGUAGE</tt> pragmas in the modules source code
[ms_hspp_opts] :: ModSummary -> DynFlags

-- | The actual preprocessed source, if we have it
[ms_hspp_buf] :: ModSummary -> Maybe StringBuffer
ms_unitid :: ModSummary -> UnitId
ms_installed_mod :: ModSummary -> InstalledModule
ms_mod_name :: ModSummary -> ModuleName

-- | Textual imports, plus plugin imports but not SOURCE imports.
ms_imps :: ModSummary -> [(PkgQual, Located ModuleName)]

-- | Plugin imports
ms_plugin_imps :: ModSummary -> [(PkgQual, Located ModuleName)]
ms_mnwib :: ModSummary -> ModuleNameWithIsBoot

-- | Like <a>ms_home_imps</a>, but for SOURCE imports.
ms_home_srcimps :: ModSummary -> [Located ModuleName]

-- | All of the (possibly) home module imports from a <a>ModSummary</a>;
--   that is to say, each of these module names could be a home import if
--   an appropriately named file existed. (This is in contrast to package
--   qualified imports, which are guaranteed not to be home imports.)
ms_home_imps :: ModSummary -> [(PkgQual, Located ModuleName)]
msHiFilePath :: ModSummary -> FilePath
msDynHiFilePath :: ModSummary -> FilePath
msHsFilePath :: ModSummary -> FilePath
msObjFilePath :: ModSummary -> FilePath
msDynObjFilePath :: ModSummary -> FilePath
msHsFileOsPath :: ModSummary -> OsPath
msHiFileOsPath :: ModSummary -> OsPath
msDynHiFileOsPath :: ModSummary -> OsPath
msObjFileOsPath :: ModSummary -> OsPath
msDynObjFileOsPath :: ModSummary -> OsPath

-- | Returns the dependencies of the ModSummary s.
msDeps :: ModSummary -> [(PkgQual, GenWithIsBoot (Located ModuleName))]

-- | Did this <a>ModSummary</a> originate from a hs-boot file?
isBootSummary :: ModSummary -> IsBootInterface

-- | Find the first target in the provided list which matches the specified
--   <a>ModSummary</a>.
findTarget :: ModSummary -> [Target] -> Maybe Target
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.ModSummary.ModSummary

module GHC.Unit.Module.Graph

-- | A '<tt>ModuleGraph</tt>' contains all the nodes from the home package
--   (only). See '<tt>ModuleGraphNode</tt>' for information about the
--   nodes.
--   
--   Modules need to be compiled. hs-boots need to be typechecked before
--   the associated "real" module so modules with {-# SOURCE #-} imports
--   can be built. Instantiations also need to be typechecked to ensure
--   that the module fits the signature. Substantiation typechecking is
--   roughly comparable to the check that the module and its hs-boot agree.
--   
--   The graph is not necessarily stored in topologically-sorted order. Use
--   <a>topSortModuleGraph</a> and <a>flattenSCC</a> to achieve this.
data ModuleGraph

-- | A '<tt>ModuleGraphNode</tt>' is a node in the '<tt>ModuleGraph</tt>'.
--   Edges between nodes mark dependencies arising from module imports and
--   dependencies arising from backpack instantiations.
data ModuleGraphNode

-- | Instantiation nodes track the instantiation of other units (backpack
--   dependencies) with the holes (signatures) of the current package.
InstantiationNode :: UnitId -> InstantiatedUnit -> ModuleGraphNode

-- | There is a module summary node for each module, signature, and boot
--   module being built.
ModuleNode :: [NodeKey] -> ModSummary -> ModuleGraphNode

-- | Link nodes are whether are are creating a linked product (ie
--   executable/shared object etc) for a unit.
LinkNode :: [NodeKey] -> UnitId -> ModuleGraphNode

-- | Collect the immediate dependencies of a ModuleGraphNode, optionally
--   avoiding hs-boot dependencies. If the drop_hs_boot_nodes flag is
--   False, and if this is a .hs and there is an equivalent .hs-boot, add a
--   link from the former to the latter. This has the effect of detecting
--   bogus cases where the .hs-boot depends on the .hs, by introducing a
--   cycle. Additionally, it ensures that we will always process the
--   .hs-boot before the .hs, and so the HomePackageTable will always have
--   the most up to date information.
nodeDependencies :: Bool -> ModuleGraphNode -> [NodeKey]
emptyMG :: ModuleGraph
mkModuleGraph :: [ModuleGraphNode] -> ModuleGraph

-- | Add an ExtendedModSummary to ModuleGraph. Assumes that the new
--   ModSummary is not an element of the ModuleGraph.
extendMG :: ModuleGraph -> [NodeKey] -> ModSummary -> ModuleGraph
extendMGInst :: ModuleGraph -> UnitId -> InstantiatedUnit -> ModuleGraph
extendMG' :: ModuleGraph -> ModuleGraphNode -> ModuleGraph
unionMG :: ModuleGraph -> ModuleGraph -> ModuleGraph
isTemplateHaskellOrQQNonBoot :: ModSummary -> Bool

-- | This function filters out all the instantiation nodes from each SCC of
--   a topological sort. Use this with care, as the resulting "strongly
--   connected components" may not really be strongly connected in a direct
--   way, as instantiations have been removed. It would probably be best to
--   eliminate uses of this function where possible.
filterToposortToModules :: [SCC ModuleGraphNode] -> [SCC ModSummary]

-- | Map a function <tt>f</tt> over all the <tt>ModSummaries</tt>. To
--   preserve invariants <tt>f</tt> can't change the isBoot status.
mapMG :: (ModSummary -> ModSummary) -> ModuleGraph -> ModuleGraph
mgModSummaries :: ModuleGraph -> [ModSummary]
mgModSummaries' :: ModuleGraph -> [ModuleGraphNode]

-- | Look up a ModSummary in the ModuleGraph Looks up the non-boot
--   ModSummary Linear in the size of the module graph
mgLookupModule :: ModuleGraph -> Module -> Maybe ModSummary
mgTransDeps :: ModuleGraph -> Map NodeKey (Set NodeKey)
showModMsg :: DynFlags -> Bool -> ModuleGraphNode -> SDoc
moduleGraphNodeModule :: ModuleGraphNode -> Maybe ModuleName
moduleGraphNodeModSum :: ModuleGraphNode -> Maybe ModSummary

-- | This function returns all the modules belonging to the home-unit that
--   can be reached by following the given dependencies. Additionally, if
--   both the boot module and the non-boot module can be reached, it only
--   returns the non-boot one.
moduleGraphModulesBelow :: ModuleGraph -> UnitId -> ModuleNameWithIsBoot -> Set ModNodeKeyWithUid

-- | Turn a list of graph nodes into an efficient queriable graph. The
--   first boolean parameter indicates whether nodes corresponding to
--   hs-boot files should be collapsed into their relevant hs nodes.
moduleGraphNodes :: Bool -> [ModuleGraphNode] -> (Graph SummaryNode, NodeKey -> Maybe SummaryNode)
type SummaryNode = Node Int ModuleGraphNode
summaryNodeSummary :: SummaryNode -> ModuleGraphNode
data NodeKey
NodeKey_Unit :: {-# UNPACK #-} !InstantiatedUnit -> NodeKey
NodeKey_Module :: {-# UNPACK #-} !ModNodeKeyWithUid -> NodeKey
NodeKey_Link :: !UnitId -> NodeKey
nodeKeyUnitId :: NodeKey -> UnitId
nodeKeyModName :: NodeKey -> Maybe ModuleName
type ModNodeKey = ModuleNameWithIsBoot
mkNodeKey :: ModuleGraphNode -> NodeKey
msKey :: ModSummary -> ModNodeKeyWithUid
moduleGraphNodeUnitId :: ModuleGraphNode -> UnitId
data ModNodeKeyWithUid
ModNodeKeyWithUid :: !ModuleNameWithIsBoot -> !UnitId -> ModNodeKeyWithUid
[mnkModuleName] :: ModNodeKeyWithUid -> !ModuleNameWithIsBoot
[mnkUnitId] :: ModNodeKeyWithUid -> !UnitId
instance GHC.Classes.Eq GHC.Unit.Module.Graph.ModNodeKeyWithUid
instance GHC.Classes.Eq GHC.Unit.Module.Graph.ModuleGraphNode
instance GHC.Classes.Eq GHC.Unit.Module.Graph.NodeKey
instance GHC.Internal.Data.Foldable.Foldable GHC.Unit.Module.Graph.NodeMap
instance GHC.Internal.Base.Functor GHC.Unit.Module.Graph.NodeMap
instance GHC.Classes.Ord GHC.Unit.Module.Graph.ModNodeKeyWithUid
instance GHC.Classes.Ord GHC.Unit.Module.Graph.ModuleGraphNode
instance GHC.Classes.Ord GHC.Unit.Module.Graph.NodeKey
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.Graph.ModNodeKeyWithUid
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.Graph.ModuleGraphNode
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.Graph.NodeKey
instance GHC.Internal.Data.Traversable.Traversable GHC.Unit.Module.Graph.NodeMap

module GHC.Tc.Types.EvTerm
evDelayedError :: Type -> String -> EvTerm
evCallStack :: (MonadThings m, HasModule m, HasDynFlags m) => EvCallStack -> m EvExpr

module GHC.HsToCore.Errors.Types
newtype MinBound
MinBound :: Integer -> MinBound
newtype MaxBound
MaxBound :: Integer -> MaxBound
type MaxUncoveredPatterns = Int
type MaxPmCheckModels = Int

-- | Diagnostics messages emitted during desugaring.
data DsMessage

-- | Simply wraps a generic <a>Diagnostic</a> message.
DsUnknownMessage :: UnknownDiagnostic (DiagnosticOpts DsMessage) -> DsMessage

-- | DsEmptyEnumeration is a warning (controlled by the
--   -Wempty-enumerations flag) that is emitted if an enumeration is empty.
--   
--   Example(s):
--   
--   main :: IO () main = do let enum = [5 .. 3] print enum
--   
--   Here <tt>enum</tt> would yield an empty list, because 5 is greater
--   than 3.
--   
--   Test case(s): warnings<i>should_compile</i>T10930
--   warnings<i>should_compile</i>T18402
--   warnings<i>should_compile</i>T10930b
--   numeric<i>should_compile</i>T10929 numeric<i>should_compile</i>T7881
--   deSugar<i>should_run</i>T18172
DsEmptyEnumeration :: DsMessage

-- | DsIdentitiesFound is a warning (controlled by the -Widentities flag)
--   that is emitted on uses of Prelude numeric conversions that are
--   probably the identity (and hence could be omitted).
--   
--   Example(s):
--   
--   main :: IO () main = do let x = 10 print $ conv 10
--   
--   where conv :: Int -&gt; Int conv x = fromIntegral x
--   
--   Here calling <tt>conv</tt> is essentially the identity function, and
--   therefore can be omitted.
--   
--   Test case(s): deSugar<i>should_compile</i>T4488
DsIdentitiesFound :: !Id -> !Type -> DsMessage
DsOverflowedLiterals :: !Integer -> !Name -> !Maybe (MinBound, MaxBound) -> !NegLiteralExtEnabled -> DsMessage
DsRedundantBangPatterns :: !HsMatchContextRn -> !SDoc -> DsMessage
DsOverlappingPatterns :: !HsMatchContextRn -> !SDoc -> DsMessage
DsInaccessibleRhs :: !HsMatchContextRn -> !SDoc -> DsMessage
DsMaxPmCheckModelsReached :: !MaxPmCheckModels -> DsMessage
DsNonExhaustivePatterns :: !HsMatchContextRn -> !ExhaustivityCheckType -> !MaxUncoveredPatterns -> [Id] -> [Nabla] -> DsMessage
DsTopLevelBindsNotAllowed :: !BindsType -> !HsBindLR GhcTc GhcTc -> DsMessage
DsUselessSpecialiseForClassMethodSelector :: !Id -> DsMessage
DsUselessSpecialiseForNoInlineFunction :: !Id -> DsMessage
DsMultiplicityCoercionsNotSupported :: DsMessage
DsOrphanRule :: !CoreRule -> DsMessage
DsRuleLhsTooComplicated :: !CoreExpr -> !CoreExpr -> DsMessage
DsRuleIgnoredDueToConstructor :: !DataCon -> DsMessage
DsRuleBindersNotBound :: ![Var] -> ![Var] -> !CoreExpr -> !CoreExpr -> DsMessage
DsLazyPatCantBindVarsOfUnliftedType :: [Var] -> DsMessage
DsNotYetHandledByTH :: !ThRejectionReason -> DsMessage
DsAggregatedViewExpressions :: [[LHsExpr GhcTc]] -> DsMessage
DsUnbangedStrictPatterns :: !HsBindLR GhcTc GhcTc -> DsMessage
DsCannotMixPolyAndUnliftedBindings :: !HsBindLR GhcTc GhcTc -> DsMessage
DsWrongDoBind :: !LHsExpr GhcTc -> !Type -> DsMessage
DsUnusedDoBind :: !LHsExpr GhcTc -> !Type -> DsMessage
DsRecBindsNotAllowedForUnliftedTys :: ![LHsBindLR GhcTc GhcTc] -> DsMessage
DsRuleMightInlineFirst :: !RuleName -> !Var -> !Activation -> DsMessage
DsAnotherRuleMightFireFirst :: !RuleName -> !RuleName -> !Var -> DsMessage

-- | DsIncompleteRecordSelector is a warning triggered when we are not
--   certain whether a record selector application will be successful.
--   Currently, this means that the warning is triggered when there is a
--   record selector of a data type that does not have that field in all
--   its constructors.
--   
--   Example(s): data T = T1 | T2 {x :: Bool} f :: T -&gt; Bool f a = x a
--   
--   Test cases: DsIncompleteRecSel1 DsIncompleteRecSel2
--   DsIncompleteRecSel3
DsIncompleteRecordSelector :: !Name -> ![ConLike] -> !Bool -> DsMessage
newtype DsArgNum
DsArgNum :: Int -> DsArgNum

-- | Why TemplateHaskell rejected the splice. Used in the
--   <a>DsNotYetHandledByTH</a> constructor of a <a>DsMessage</a>.
data ThRejectionReason
ThAmbiguousRecordUpdates :: !HsRecUpdField GhcRn GhcRn -> ThRejectionReason
ThAbstractClosedTypeFamily :: !LFamilyDecl GhcRn -> ThRejectionReason
ThForeignLabel :: !CLabelString -> ThRejectionReason
ThForeignExport :: !LForeignDecl GhcRn -> ThRejectionReason
ThMinimalPragmas :: ThRejectionReason
ThSCCPragmas :: ThRejectionReason
ThNoUserInline :: ThRejectionReason
ThExoticFormOfType :: !HsType GhcRn -> ThRejectionReason
ThAmbiguousRecordSelectors :: !HsExpr GhcRn -> ThRejectionReason
ThMonadComprehensionSyntax :: !HsExpr GhcRn -> ThRejectionReason
ThCostCentres :: !HsExpr GhcRn -> ThRejectionReason
ThExpressionForm :: !HsExpr GhcRn -> ThRejectionReason
ThExoticStatement :: [Stmt GhcRn (LHsExpr GhcRn)] -> ThRejectionReason
ThExoticLiteral :: !HsLit GhcRn -> ThRejectionReason
ThExoticPattern :: !Pat GhcRn -> ThRejectionReason
ThGuardedLambdas :: !Match GhcRn (LHsExpr GhcRn) -> ThRejectionReason
ThNegativeOverloadedPatterns :: !Pat GhcRn -> ThRejectionReason
ThHaddockDocumentation :: ThRejectionReason
ThWarningAndDeprecationPragmas :: [LIdP GhcRn] -> ThRejectionReason
ThSplicesWithinDeclBrackets :: ThRejectionReason
ThNonLinearDataCon :: ThRejectionReason
data NegLiteralExtEnabled
YesUsingNegLiterals :: NegLiteralExtEnabled
NotUsingNegLiterals :: NegLiteralExtEnabled
negLiteralExtEnabled :: DynFlags -> NegLiteralExtEnabled
newtype ExhaustivityCheckType
ExhaustivityCheckType :: Maybe WarningFlag -> ExhaustivityCheckType
data BindsType
UnliftedTypeBinds :: BindsType
StrictBinds :: BindsType
instance GHC.Internal.Generics.Generic GHC.HsToCore.Errors.Types.DsMessage


-- | Printing related functions that depend on session state (DynFlags)
module GHC.Driver.Ppr

-- | Show a SDoc as a String with the default user style
showSDoc :: DynFlags -> SDoc -> String
showSDocUnsafe :: SDoc -> String

-- | Allows caller to specify the NamePprCtx to use
showSDocForUser :: DynFlags -> UnitState -> NamePprCtx -> SDoc -> String
showPpr :: Outputable a => DynFlags -> a -> String
showPprUnsafe :: Outputable a => a -> String
printForUser :: DynFlags -> Handle -> NamePprCtx -> Depth -> SDoc -> IO ()

module GHC.Driver.Config.Stg.Lift
initStgLiftConfig :: DynFlags -> StgLiftConfig

module GHC.Driver.Config.Logger

-- | Initialize LogFlags from DynFlags
initLogFlags :: DynFlags -> LogFlags

module GHC.Driver.Config.Core.Rules

-- | Initialize RuleOpts from DynFlags
initRuleOpts :: DynFlags -> RuleOpts

module GHC.Driver.Config.Core.Opt.Arity
initArityOpts :: DynFlags -> ArityOpts

module GHC.Driver.Config.Cmm
initCmmConfig :: DynFlags -> CmmConfig


-- | The IO Monad with an environment
--   
--   The environment is passed around as a Reader monad but as its in the
--   IO monad, mutable references can be used for updating state.
module GHC.Data.IOEnv
data IOEnv env a
failM :: IOEnv env a
failWithM :: String -> IOEnv env a
data IOEnvFailure
IOEnvFailure :: IOEnvFailure
getEnv :: IOEnv env env

-- | Perform a computation with a different environment
setEnv :: env' -> IOEnv env' a -> IOEnv env a

-- | Perform a computation with an altered environment
updEnv :: (env -> env') -> IOEnv env' a -> IOEnv env a
runIOEnv :: env -> IOEnv env a -> IO a
unsafeInterleaveM :: IOEnv env a -> IOEnv env a
uninterruptibleMaskM_ :: IOEnv env a -> IOEnv env a
tryM :: IOEnv env r -> IOEnv env (Either IOEnvFailure r)
tryAllM :: IOEnv env r -> IOEnv env (Either SomeException r)
tryMostM :: IOEnv env r -> IOEnv env (Either SomeException r)
fixM :: (a -> IOEnv env a) -> IOEnv env a
data IORef a
newMutVar :: a -> IOEnv env (IORef a)
readMutVar :: IORef a -> IOEnv env a
writeMutVar :: IORef a -> a -> IOEnv env ()
updMutVar :: IORef a -> (a -> a) -> IOEnv env ()

-- | Atomically update the reference. Does not force the evaluation of the
--   new variable contents. For strict update, use <a>atomicUpdMutVar'</a>.
atomicUpdMutVar :: IORef a -> (a -> (a, b)) -> IOEnv env b

-- | Strict variant of <a>atomicUpdMutVar</a>.
atomicUpdMutVar' :: IORef a -> (a -> (a, b)) -> IOEnv env b
instance GHC.Internal.Base.Alternative (GHC.Data.IOEnv.IOEnv env)
instance GHC.Internal.Base.Applicative (GHC.Data.IOEnv.IOEnv m)
instance GHC.Internal.Exception.Type.Exception GHC.Data.IOEnv.IOEnvFailure
instance GHC.Internal.Base.Functor (GHC.Data.IOEnv.IOEnv env)
instance GHC.Driver.DynFlags.ContainsDynFlags env => GHC.Driver.DynFlags.HasDynFlags (GHC.Data.IOEnv.IOEnv env)
instance GHC.Driver.Hooks.ContainsHooks env => GHC.Driver.Hooks.HasHooks (GHC.Data.IOEnv.IOEnv env)
instance GHC.Utils.Logger.ContainsLogger env => GHC.Utils.Logger.HasLogger (GHC.Data.IOEnv.IOEnv env)
instance GHC.Unit.Module.ContainsModule env => GHC.Unit.Module.HasModule (GHC.Data.IOEnv.IOEnv env)
instance Control.Monad.Catch.MonadCatch (GHC.Data.IOEnv.IOEnv env)
instance GHC.Internal.Control.Monad.Fail.MonadFail (GHC.Data.IOEnv.IOEnv m)
instance GHC.Internal.Control.Monad.Fix.MonadFix (GHC.Data.IOEnv.IOEnv env)
instance GHC.Internal.Base.Monad (GHC.Data.IOEnv.IOEnv m)
instance GHC.Internal.Control.Monad.IO.Class.MonadIO (GHC.Data.IOEnv.IOEnv env)
instance Control.Monad.Catch.MonadMask (GHC.Data.IOEnv.IOEnv env)
instance GHC.Internal.Base.MonadPlus (GHC.Data.IOEnv.IOEnv env)
instance Control.Monad.Catch.MonadThrow (GHC.Data.IOEnv.IOEnv env)
instance GHC.Internal.Show.Show GHC.Data.IOEnv.IOEnvFailure


-- | Unfolding creation
module GHC.Core.Unfold.Make

-- | There is no known <a>Unfolding</a>
noUnfolding :: Unfolding
mkUnfolding :: UnfoldingOpts -> UnfoldingSource -> Bool -> Bool -> Bool -> CoreExpr -> Maybe UnfoldingCache -> Unfolding
mkCoreUnfolding :: UnfoldingSource -> Bool -> CoreExpr -> Maybe UnfoldingCache -> UnfoldingGuidance -> Unfolding
mkFinalUnfolding :: UnfoldingOpts -> UnfoldingSource -> DmdSig -> CoreExpr -> Unfolding
mkFinalUnfolding' :: UnfoldingOpts -> UnfoldingSource -> DmdSig -> CoreExpr -> Maybe UnfoldingCache -> Unfolding
mkSimpleUnfolding :: UnfoldingOpts -> CoreExpr -> Unfolding
mkWorkerUnfolding :: SimpleOpts -> (CoreExpr -> CoreExpr) -> Unfolding -> Unfolding

-- | Make an INLINE unfolding that will be used once the RHS has been
--   saturated to the given arity.
mkInlineUnfoldingWithArity :: SimpleOpts -> UnfoldingSource -> Arity -> CoreExpr -> Unfolding

-- | Make an INLINE unfolding that may be used unsaturated (ug_unsat_ok =
--   unSaturatedOk) and that is reported as having its manifest arity (the
--   number of outer lambdas applications will resolve before doing any
--   work).
mkInlineUnfoldingNoArity :: SimpleOpts -> UnfoldingSource -> CoreExpr -> Unfolding
mkInlinableUnfolding :: SimpleOpts -> UnfoldingSource -> CoreExpr -> Unfolding
mkWrapperUnfolding :: SimpleOpts -> CoreExpr -> Arity -> Unfolding

-- | Used for things that absolutely must be unfolded
mkCompulsoryUnfolding :: CoreExpr -> Unfolding

-- | Same as <a>mkCompulsoryUnfolding</a> but simplifies the unfolding
--   first
mkCompulsoryUnfolding' :: SimpleOpts -> CoreExpr -> Unfolding
mkDFunUnfolding :: [Var] -> DataCon -> [CoreExpr] -> Unfolding
mkDataConUnfolding :: CoreExpr -> Unfolding
specUnfolding :: SimpleOpts -> [Var] -> (CoreExpr -> CoreExpr) -> [CoreArg] -> Unfolding -> Unfolding

-- | Sees if the unfolding is pretty certain to inline. If so, return a
--   *stable* unfolding for it, that will always inline. The CoreExpr is
--   the WW'd and simplified RHS. In contrast, the unfolding template might
--   not have been WW'd yet.
certainlyWillInline :: UnfoldingOpts -> IdInfo -> CoreExpr -> Maybe Unfolding

module GHC.Core.SimpleOpt

-- | Simple optimiser options
data SimpleOpts
SimpleOpts :: !UnfoldingOpts -> !OptCoercionOpts -> !Bool -> SimpleOpts

-- | Unfolding options
[so_uf_opts] :: SimpleOpts -> !UnfoldingOpts

-- | Coercion optimiser options
[so_co_opts] :: SimpleOpts -> !OptCoercionOpts

-- | Eta reduction on?
[so_eta_red] :: SimpleOpts -> !Bool

-- | Default options for the Simple optimiser.
defaultSimpleOpts :: SimpleOpts
simpleOptPgm :: SimpleOpts -> Module -> CoreProgram -> [CoreRule] -> (CoreProgram, [CoreRule], CoreProgram)
simpleOptExpr :: HasDebugCallStack => SimpleOpts -> CoreExpr -> CoreExpr
simpleOptExprWith :: HasDebugCallStack => SimpleOpts -> Subst -> InExpr -> OutExpr

-- | Returns Just (bndr,rhs) if the binding is a join point: If it's a
--   JoinId, just return it If it's not yet a JoinId but is always
--   tail-called, make it into a JoinId and return it. In the latter case,
--   eta-expand the RHS if necessary, to make the lambdas explicit, as is
--   required for join points
--   
--   Precondition: the InBndr has been occurrence-analysed, so its OccInfo
--   is valid
joinPointBinding_maybe :: InBndr -> InExpr -> Maybe (InBndr, InExpr)
joinPointBindings_maybe :: [(InBndr, InExpr)] -> Maybe [(InBndr, InExpr)]

-- | Returns <tt>Just ([b1..bp], dc, [t1..tk], [x1..xn])</tt> if the
--   argument expression is a *saturated* constructor application of the
--   form <tt>let b1 in .. let bp in dc t1..tk x1 .. xn</tt>, where t1..tk
--   are the *universally-quantified* type args of <tt>dc</tt>. Floats can
--   also be (and most likely are) single-alternative case expressions. Why
--   does <a>exprIsConApp_maybe</a> return floats? We may have to look
--   through lets and cases to detect that we are in the presence of a data
--   constructor wrapper. In this case, we need to return the lets and
--   cases that we traversed. See Note [exprIsConApp_maybe on data
--   constructors with wrappers]. Data constructor wrappers are unfolded
--   late, but we really want to trigger case-of-known-constructor as early
--   as possible. See also Note [Activation for data constructor wrappers]
--   in <a>GHC.Types.Id.Make</a>.
--   
--   We also return the incoming InScopeSet, augmented with the binders
--   from any [FloatBind] that we return
exprIsConApp_maybe :: HasDebugCallStack => InScopeEnv -> CoreExpr -> Maybe (InScopeSet, [FloatBind], DataCon, [Type], [CoreExpr])
exprIsLiteral_maybe :: InScopeEnv -> CoreExpr -> Maybe Literal
exprIsLambda_maybe :: HasDebugCallStack => InScopeEnv -> CoreExpr -> Maybe (Var, CoreExpr, [CoreTickish])
instance GHC.Utils.Outputable.Outputable GHC.Core.SimpleOpt.SimpleOptEnv

module GHC.Types.Id.Make
mkDictFunId :: Name -> [TyVar] -> ThetaType -> Class -> [Type] -> Id
mkDictSelId :: Name -> Class -> Id
mkDictSelRhs :: Class -> Int -> CoreExpr
mkFCallId :: Unique -> ForeignCall -> Type -> Id
unwrapNewTypeBody :: TyCon -> [Type] -> CoreExpr -> CoreExpr
wrapFamInstBody :: TyCon -> [Type] -> CoreExpr -> CoreExpr

-- | Data Constructor Boxer
newtype DataConBoxer
DCB :: ([Type] -> [Var] -> UniqSM ([Var], [CoreBind])) -> DataConBoxer
vanillaDataConBoxer :: DataConBoxer
mkDataConRep :: DataConBangOpts -> FamInstEnvs -> Name -> DataCon -> UniqSM DataConRep
mkDataConWorkId :: Name -> DataCon -> Id
data DataConBangOpts

-- | Used for imported data constructors See Note [Bangs on imported data
--   constructors]
FixedBangOpts :: [HsImplBang] -> DataConBangOpts
SrcBangOpts :: !BangOpts -> DataConBangOpts
data BangOpts
BangOpts :: !Bool -> !Bool -> !Bool -> !Bool -> BangOpts

-- | Strict fields by default
[bang_opt_strict_data] :: BangOpts -> !Bool

-- | Disable automatic field unboxing (e.g. if we aren't optimising)
[bang_opt_unbox_disable] :: BangOpts -> !Bool

-- | Unbox strict fields
[bang_opt_unbox_strict] :: BangOpts -> !Bool

-- | Unbox small strict fields
[bang_opt_unbox_small] :: BangOpts -> !Bool
unboxedUnitExpr :: CoreExpr
wiredInIds :: [Id]
ghcPrimIds :: [Id]
realWorldPrimId :: Id
voidPrimId :: Id
voidArgId :: Id
nullAddrId :: Id
seqId :: Id
lazyId :: Id
lazyIdKey :: Unique
coercionTokenId :: Id
coerceId :: Id
proxyHashId :: Id
nospecId :: Id
nospecIdName :: Name
noinlineId :: Id
noinlineIdName :: Name
noinlineConstraintId :: Id
noinlineConstraintIdName :: Name
coerceName :: Name
leftSectionName :: Name
rightSectionName :: Name
pcRepPolyId :: Name -> Type -> (Name -> ConcreteTyVars) -> IdInfo -> Id

-- | Directly specify which outer forall'd type variables of a
--   representation-polymorphic <a>Id</a> such become concrete
--   metavariables when instantiated.
mkRepPolyIdConcreteTyVars :: [((Type, Position 'Neg), TyVar)] -> Name -> ConcreteTyVars


-- | Prepare the STG for bytecode generation:
--   
--   <ul>
--   <li>Ensure that all breakpoints are directly under a let-binding,
--   introducing a new binding for those that aren't already.</li>
--   <li>Protect Not-necessarily lifted join points, see Note
--   [Not-necessarily-lifted join points]</li>
--   </ul>
module GHC.Stg.BcPrep
bcPrep :: UniqSupply -> [InStgTopBinding] -> [OutStgTopBinding]

module GHC.Driver.Config.HsToCore
initBangOpts :: DynFlags -> BangOpts


-- | Subsystem configuration
module GHC.Driver.Config

-- | Initialise coercion optimiser configuration from DynFlags
initOptCoercionOpts :: DynFlags -> OptCoercionOpts

-- | Initialise Simple optimiser configuration from DynFlags
initSimpleOpts :: DynFlags -> SimpleOpts

-- | Extract GHCi options from DynFlags and step
initEvalOpts :: DynFlags -> Bool -> EvalOpts

module GHC.Core.Opt.WorkWrap.Utils
data WwOpts
MkWwOpts :: !FamInstEnvs -> !SimpleOpts -> !Bool -> !Module -> !Bool -> WwOpts

-- | Environment of type/data family instances
[wo_fam_envs] :: WwOpts -> !FamInstEnvs

-- | Options for the "Simple optimiser"
[wo_simple_opts] :: WwOpts -> !SimpleOpts

-- | Whether to enable "Constructed Product Result" analysis. (Originally
--   from DOI: 10.1017/S0956796803004751)
[wo_cpr_anal] :: WwOpts -> !Bool

-- | Used for absent argument error message
[wo_module] :: WwOpts -> !Module

-- | Generate workers even if the only effect is some args get passed
--   unlifted. See Note [WW for calling convention]
[wo_unlift_strict] :: WwOpts -> !Bool

-- | Given a function definition
--   
--   <pre>
--   data T = MkT Int Bool Char
--   f :: (a, b) -&gt; Int -&gt; T
--   f = \x y -&gt; E
--   </pre>
--   
--   <tt>mkWwBodies _ <tt>f</tt> ['x::(a,b)','y::Int'] '(a,b)' ['1P(L,L)',
--   '1P(L)'] '1'</tt> returns
--   
--   <ul>
--   <li>The wrapper body context for the call to the worker function,
--   lacking only the <a>Id</a> for the worker function:</li>
--   </ul>
--   
--   <pre>
--   W[_] :: Id -&gt; CoreExpr
--   W[work_fn] = \x y -&gt;          -- args of the wrapper    (cloned_arg_vars)
--     case x of (a, b) -&gt;         -- unbox wrapper args     (wrap_fn_str)
--     case y of I# n -&gt;           --
--     case &lt;work_fn&gt; a b n of     -- call to the worker fun (call_work)
--     (# i, b, c #) -&gt; MkT i b c  -- rebox result           (wrap_fn_cpr)
--   </pre>
--   
--   <ul>
--   <li>The worker body context that wraps around its hole reboxing defns
--   for x and y, as well as returning CPR transit variables of the unboxed
--   MkT result in an unboxed tuple:</li>
--   </ul>
--   
--   <pre>
--   w[_] :: CoreExpr -&gt; CoreExpr
--   w[fn_rhs] = \a b n -&gt;              -- args of the worker       (work_lam_args)
--     let { y = I# n; x = (a, b) } in  -- reboxing wrapper args    (work_fn_str)
--     case &lt;fn_rhs&gt; x y of             -- call to the original RHS (call_rhs)
--     MkT i b c -&gt; (# i, b, c #)       -- return CPR transit vars  (work_fn_cpr)
--   </pre>
--   
--   NB: The wrap_rhs hole is to be filled with the original wrapper RHS
--   <tt>x y -&gt; E</tt>. This is so that we can also use <tt>w</tt> to
--   transform stable unfoldings, the lambda args of which may be different
--   than x and y.
--   
--   <ul>
--   <li>Id details for the worker function like demands on arguments and
--   its join arity.</li>
--   </ul>
--   
--   All without looking at E (except for beta reduction, see Note [Join
--   points and beta-redexes]), which allows us to apply the same split to
--   function body and its unfolding(s) alike.
mkWwBodies :: WwOpts -> Id -> Arity -> [Var] -> Type -> [Demand] -> Cpr -> UniqSM (Maybe WwResult)
mkWWstr :: WwOpts -> [Var] -> [StrictnessMark] -> UniqSM (WwUse, [(Var, StrictnessMark)], CoreExpr -> CoreExpr, [CoreExpr])
mkWWstr_one :: WwOpts -> Var -> StrictnessMark -> UniqSM (WwUse, [(Var, StrictnessMark)], CoreExpr -> CoreExpr, CoreExpr)

-- | Whether the worker needs an additional `Void#` arg as per Note
--   [Protecting the last value argument] or Note [Preserving float
--   barriers].
needsVoidWorkerArg :: Id -> [Var] -> [Var] -> Bool

-- | The information needed to build a pattern for a DataCon to be unboxed.
--   The pattern can be generated from <a>dcpc_dc</a> and
--   <a>dcpc_tc_args</a> via <a>dataConRepInstPat</a>. The coercion
--   <a>dcpc_co</a> is for newtype wrappers.
--   
--   If we get <tt>DataConPatContext dc tys co</tt> for some type
--   <tt>ty</tt> and <tt>dataConRepInstPat ... dc tys = (exs, flds)</tt>,
--   then
--   
--   <ul>
--   <li><tt>dc </tt>exs flds :: T tys@</li>
--   <li><pre>co :: T tys ~ ty</pre></li>
--   </ul>
--   
--   <tt>s</tt> will be <a>Demand</a> or <a>Cpr</a>.
data DataConPatContext s
DataConPatContext :: !DataCon -> ![Type] -> !Coercion -> ![s] -> DataConPatContext s
[dcpc_dc] :: DataConPatContext s -> !DataCon
[dcpc_tc_args] :: DataConPatContext s -> ![Type]
[dcpc_co] :: DataConPatContext s -> !Coercion
[dcpc_args] :: DataConPatContext s -> ![s]

-- | Describes the outer shape of an argument to be unboxed or left as-is
--   Depending on how <tt>s</tt> is instantiated (e.g., <a>Demand</a> or
--   <a>Cpr</a>).
data UnboxingDecision unboxing_info

-- | We ran out of strictness info. Leave untouched.
DontUnbox :: UnboxingDecision unboxing_info

-- | The argument is used strictly or the returned product was constructed,
--   so unbox it.
DoUnbox :: !unboxing_info -> UnboxingDecision unboxing_info

-- | The argument/field was absent. Drop it.
DropAbsent :: UnboxingDecision unboxing_info

-- | Unwraps the <a>Boxity</a> decision encoded in the given
--   <a>SubDemand</a> and returns a <a>DataConPatContext</a> as well the
--   nested demands on fields of the <a>DataCon</a> to unbox.
canUnboxArg :: FamInstEnvs -> Type -> Demand -> UnboxingDecision (DataConPatContext Demand)
findTypeShape :: FamInstEnvs -> Type -> TypeShape

-- | Returned by <a>isRecDataCon</a>. See also Note [Detecting recursive
--   data constructors].
data IsRecDataConResult

-- | The algorithm detected a loop
DefinitelyRecursive :: IsRecDataConResult

-- | The algorithm detected no loop, went out of fuel or hit an .hs-boot
--   file
NonRecursiveOrUnsure :: IsRecDataConResult

-- | <tt>isRecDataCon _ fuel dc</tt>, where <tt>tc = dataConTyCon dc</tt>
--   returns
--   
--   <ul>
--   <li><tt>DefinitelyRecursive</tt> if the analysis found that
--   <tt>tc</tt> is reachable through one of <tt>dc</tt>'s
--   <tt>arg_tys</tt>.</li>
--   <li><tt>NonRecursiveOrUnsure</tt> if the analysis found that
--   <tt>tc</tt> is not reachable through one of <tt>dc</tt>'s fields (so
--   surely non-recursive).</li>
--   <li><tt>NonRecursiveOrUnsure</tt> when <tt>fuel /= Infinity</tt> and
--   <tt>fuel</tt> expansions of nested data TyCons were not enough to
--   prove non-recursiveness, nor arrive at an occurrence of <tt>tc</tt>
--   thus proving recursiveness. (So not sure if non-recursive.)</li>
--   <li><tt>NonRecursiveOrUnsure</tt> when we hit an abstract TyCon (one
--   without visible DataCons), such as those imported from .hs-boot files.
--   Similarly for stuck type and data families.</li>
--   </ul>
--   
--   If <tt>fuel = <tt>Infinity</tt></tt> and there are no boot files
--   involved, then the result is never <tt>Nothing</tt> and the analysis
--   is a depth-first search. If <tt>fuel = <a>Int</a> f</tt>, then the
--   analysis behaves like a depth-limited DFS and returns <tt>Nothing</tt>
--   if the search was inconclusive.
--   
--   See Note [Detecting recursive data constructors] for which recursive
--   DataCons we want to flag.
isRecDataCon :: FamInstEnvs -> IntWithInf -> DataCon -> IsRecDataConResult

-- | Tries to find a suitable absent filler to bind the given absent
--   identifier to. See Note [Absent fillers].
--   
--   If <tt>mkAbsentFiller _ id == Just e</tt>, then <tt>e</tt> is an
--   absent filler with the same type as <tt>id</tt>. Otherwise, no
--   suitable filler could be found.
mkAbsentFiller :: WwOpts -> Id -> StrictnessMark -> Maybe CoreExpr
isWorkerSmallEnough :: Int -> Int -> [Var] -> Bool

-- | Exactly <a>dataConInstArgTys</a>, but lacks the (ASSERT'ed)
--   precondition that the <a>DataCon</a> may not have existentials. The
--   lack of cloning the existentials this function "dubious"; only use it
--   where type variables aren't substituted for! Why may the data con bind
--   existentials? See Note [Which types are unboxed?]
dubiousDataConInstArgTys :: DataCon -> [Type] -> [Type]

-- | WW split not profitable
boringSplit :: WwUse

-- | WW split profitable
usefulSplit :: WwUse
workWrapArity :: Id -> CoreExpr -> Arity
instance GHC.Classes.Eq GHC.Core.Opt.WorkWrap.Utils.IsRecDataConResult
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.WorkWrap.Utils.IsRecDataConResult
instance GHC.Utils.Outputable.Outputable i => GHC.Utils.Outputable.Outputable (GHC.Core.Opt.WorkWrap.Utils.UnboxingDecision i)
instance GHC.Internal.Show.Show GHC.Core.Opt.WorkWrap.Utils.IsRecDataConResult


-- | Constructed Product Result analysis. Identifies functions that surely
--   return heap-allocated records on every code path, so that we can
--   eliminate said heap allocation by performing a worker/wrapper split.
--   
--   See
--   <a>https://www.microsoft.com/en-us/research/publication/constructed-product-result-analysis-haskell/</a>.
--   CPR analysis should happen after strictness analysis. See Note [Phase
--   ordering].
module GHC.Core.Opt.CprAnal
cprAnalProgram :: Logger -> FamInstEnvs -> CoreProgram -> IO CoreProgram
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.CprAnal.AnalEnv
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.CprAnal.SigEnv

module GHC.Core.Opt.WorkWrap
data WwOpts
MkWwOpts :: !FamInstEnvs -> !SimpleOpts -> !Bool -> !Module -> !Bool -> WwOpts

-- | Environment of type/data family instances
[wo_fam_envs] :: WwOpts -> !FamInstEnvs

-- | Options for the "Simple optimiser"
[wo_simple_opts] :: WwOpts -> !SimpleOpts

-- | Whether to enable "Constructed Product Result" analysis. (Originally
--   from DOI: 10.1017/S0956796803004751)
[wo_cpr_anal] :: WwOpts -> !Bool

-- | Used for absent argument error message
[wo_module] :: WwOpts -> !Module

-- | Generate workers even if the only effect is some args get passed
--   unlifted. See Note [WW for calling convention]
[wo_unlift_strict] :: WwOpts -> !Bool
wwTopBinds :: WwOpts -> UniqSupply -> CoreProgram -> CoreProgram

module GHC.Driver.Config.Core.Opt.WorkWrap
initWorkWrapOpts :: Module -> DynFlags -> FamInstEnvs -> WwOpts

module GHC.Core.Opt.DmdAnal

-- | Options for the demand analysis
data DmdAnalOpts
DmdAnalOpts :: !Bool -> !Bool -> !Int -> !Int -> DmdAnalOpts

-- | Value of `-fdicts-strict` (on by default). When set, all functons are
--   implicitly strict in dictionary args.
[dmd_strict_dicts] :: DmdAnalOpts -> !Bool

-- | Governs whether the analysis should update boxity signatures. See Note
--   [Don't change boxity without worker/wrapper].
[dmd_do_boxity] :: DmdAnalOpts -> !Bool

-- | Value of `-fdmd-unbox-width`. See Note [Unboxed demand on function
--   bodies returning small products]
[dmd_unbox_width] :: DmdAnalOpts -> !Int

-- | Value of `-fmax-worker-args`. Don't unbox anything if we end up with
--   more than this many args.
[dmd_max_worker_args] :: DmdAnalOpts -> !Int

-- | Outputs a new copy of the Core program in which binders have been
--   annotated with demand and strictness information.
--   
--   Note: use <tt>seqBinds</tt> on the result to avoid leaks due to
--   laziness (cf Note [Stamp out space leaks in demand analysis])
dmdAnalProgram :: DmdAnalOpts -> FamInstEnvs -> [CoreRule] -> CoreProgram -> CoreProgram
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.DmdAnal.AnalEnv

module GHC.Cmm.CLabel

-- | <a>CLabel</a> is an abstract type that supports the following
--   operations:
--   
--   <ul>
--   <li>Pretty printing</li>
--   <li>In a C file, does it need to be declared before use? (i.e. is it
--   guaranteed to be already in scope in the places we need to refer to
--   it?)</li>
--   <li>If it needs to be declared, what type (code or data) should it be
--   declared to have?</li>
--   <li>Is it visible outside this object file or not?</li>
--   <li>Is it "dynamic" (see details below)</li>
--   <li>Eq and Ord, so that we can make sets of CLabels (currently only
--   used in outputting C as far as I can tell, to avoid generating more
--   than one declaration for any given label).</li>
--   <li>Converting an info table label into an entry label.</li>
--   </ul>
--   
--   CLabel usage is a bit messy in GHC as they are used in a number of
--   different contexts:
--   
--   <ul>
--   <li>By the C-- AST to identify labels</li>
--   <li>By the unregisterised C code generator ("PprC") for naming
--   functions (hence the name <a>CLabel</a>)</li>
--   <li>By the native and LLVM code generators to identify labels</li>
--   </ul>
--   
--   For extra fun, each of these uses a slightly different subset of
--   constructors (e.g. <a>AsmTempLabel</a> and <a>AsmTempDerivedLabel</a>
--   are used only in the NCG and LLVM backends).
--   
--   In general, we use <a>IdLabel</a> to represent Haskell things early in
--   the pipeline. However, later optimization passes will often represent
--   blocks they create with <a>LocalBlockLabel</a> where there is no
--   obvious <a>Name</a> to hang off the label.
data CLabel

-- | Indicate if <a>GHC.CmmToC</a> has to generate an extern declaration
--   for the label (e.g. "extern StgWordArray(foo)"). The type is fixed to
--   StgWordArray.
--   
--   Symbols from the RTS don't need "extern" declarations because they are
--   exposed via "rts<i>include</i>Stg.h" with the appropriate type. See
--   <a>needsCDecl</a>.
--   
--   The fixed StgWordArray type led to "conflicting types" issues with
--   user provided Cmm files (not in the RTS) that declare data of another
--   type (#15467 and test for #17920). Hence the Cmm parser considers that
--   labels in data sections don't need the "extern" declaration (just add
--   one explicitly if you need it).
--   
--   See
--   <a>https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/compiler/backends/ppr-c#prototypes</a>
--   for why extern declaration are needed at all.
newtype NeedExternDecl
NeedExternDecl :: Bool -> NeedExternDecl

-- | Record where a foreign label is stored.
data ForeignLabelSource

-- | Label is in a named package
ForeignLabelInPackage :: UnitId -> ForeignLabelSource

-- | Label is in some external, system package that doesn't also contain
--   compiled Haskell code, and is not associated with any .hi files. We
--   don't have to worry about Haskell code being inlined from external
--   packages. It is safe to treat the RTS package as "external".
ForeignLabelInExternalPackage :: ForeignLabelSource

-- | Label is in the package currently being compiled. This is only used
--   for creating hacky tmp labels during code generation. Don't use it in
--   any code that might be inlined across a package boundary (ie, core
--   code) else the information will be wrong relative to the destination
--   module.
ForeignLabelInThisPackage :: ForeignLabelSource
data DynamicLinkerLabelInfo
CodeStub :: DynamicLinkerLabelInfo
SymbolPtr :: DynamicLinkerLabelInfo
GotSymbolPtr :: DynamicLinkerLabelInfo
GotSymbolOffset :: DynamicLinkerLabelInfo

-- | Which module is the info table from, and which number was it.
data ConInfoTableLocation
UsageSite :: Module -> Int -> ConInfoTableLocation
DefinitionSite :: ConInfoTableLocation
getConInfoTableLocation :: IdLabelInfo -> Maybe ConInfoTableLocation
mkClosureLabel :: Name -> CafInfo -> CLabel
mkSRTLabel :: Unique -> CLabel

-- | Decides between external and local labels based on the names
--   externality.
mkInfoTableLabel :: Name -> CafInfo -> CLabel
mkEntryLabel :: Name -> CafInfo -> CLabel
mkRednCountsLabel :: Name -> CLabel
mkTagHitLabel :: Name -> Unique -> CLabel
mkConInfoTableLabel :: Name -> ConInfoTableLocation -> CLabel
mkApEntryLabel :: Platform -> Bool -> Int -> CLabel
mkApInfoTableLabel :: Platform -> Bool -> Int -> CLabel
mkClosureTableLabel :: Name -> CafInfo -> CLabel
mkBytesLabel :: Name -> CLabel
mkLocalBlockLabel :: Unique -> CLabel
mkBlockInfoTableLabel :: Name -> CafInfo -> CLabel
mkBitmapLabel :: Unique -> CLabel
mkStringLitLabel :: Unique -> CLabel
mkInitializerStubLabel :: Module -> FastString -> CLabel
mkInitializerArrayLabel :: Module -> CLabel
mkFinalizerStubLabel :: Module -> FastString -> CLabel
mkFinalizerArrayLabel :: Module -> CLabel
mkAsmTempLabel :: Uniquable a => a -> CLabel
mkAsmTempDerivedLabel :: CLabel -> FastString -> CLabel
mkAsmTempEndLabel :: CLabel -> CLabel

-- | A label indicating the end of a procedure.
mkAsmTempProcEndLabel :: CLabel -> CLabel

-- | Construct a label for a DWARF Debug Information Entity (DIE)
--   describing another symbol.
mkAsmTempDieLabel :: CLabel -> CLabel
mkDirty_MUT_VAR_Label :: CLabel
mkMUT_VAR_CLEAN_infoLabel :: CLabel
mkNonmovingWriteBarrierEnabledLabel :: CLabel
mkOrigThunkInfoLabel :: CLabel
mkUpdInfoLabel :: CLabel
mkBHUpdInfoLabel :: CLabel
mkIndStaticInfoLabel :: CLabel
mkMainCapabilityLabel :: CLabel
mkMAP_FROZEN_CLEAN_infoLabel :: CLabel
mkMAP_FROZEN_DIRTY_infoLabel :: CLabel
mkMAP_DIRTY_infoLabel :: CLabel
mkSMAP_FROZEN_CLEAN_infoLabel :: CLabel
mkSMAP_FROZEN_DIRTY_infoLabel :: CLabel
mkSMAP_DIRTY_infoLabel :: CLabel
mkBadAlignmentLabel :: CLabel
mkOutOfBoundsAccessLabel :: CLabel
mkMemcpyRangeOverlapLabel :: CLabel
mkArrWords_infoLabel :: CLabel
mkSRTInfoLabel :: Int -> CLabel
mkTopTickyCtrLabel :: CLabel
mkCAFBlackHoleInfoTableLabel :: CLabel
mkRtsPrimOpLabel :: PrimOp -> CLabel
mkRtsSlowFastTickyCtrLabel :: String -> CLabel

-- | A standard string unpacking thunk. See Note [unpack_cstring closures]
--   in StgStdThunks.cmm.
mkRtsUnpackCStringLabel :: CLabel

-- | A standard string unpacking thunk. See Note [unpack_cstring closures]
--   in StgStdThunks.cmm.
mkRtsUnpackCStringUtf8Label :: CLabel
mkSelectorInfoLabel :: Platform -> Bool -> Int -> CLabel
mkSelectorEntryLabel :: Platform -> Bool -> Int -> CLabel
mkCmmInfoLabel :: UnitId -> FastString -> CLabel
mkCmmEntryLabel :: UnitId -> FastString -> CLabel
mkCmmRetInfoLabel :: UnitId -> FastString -> CLabel
mkCmmRetLabel :: UnitId -> FastString -> CLabel
mkCmmCodeLabel :: UnitId -> FastString -> CLabel
mkCmmDataLabel :: UnitId -> NeedExternDecl -> FastString -> CLabel
mkRtsCmmDataLabel :: FastString -> CLabel
mkCmmClosureLabel :: UnitId -> FastString -> CLabel
mkRtsApFastLabel :: FastString -> CLabel
mkPrimCallLabel :: PrimCall -> CLabel

-- | Make a foreign label
mkForeignLabel :: FastString -> ForeignLabelSource -> FunctionOrData -> CLabel
mkCCLabel :: CostCentre -> CLabel
mkCCSLabel :: CostCentreStack -> CLabel
mkIPELabel :: Module -> CLabel

-- | Info Table Provenance Entry See Note [Mapping Info Tables to Source
--   Positions]
data InfoProvEnt
InfoProvEnt :: !CLabel -> !Int -> !String -> !Module -> !Maybe (RealSrcSpan, LexicalFastString) -> InfoProvEnt
[infoTablePtr] :: InfoProvEnt -> !CLabel
[infoProvEntClosureType] :: InfoProvEnt -> !Int
[infoTableType] :: InfoProvEnt -> !String
[infoProvModule] :: InfoProvEnt -> !Module
[infoTableProv] :: InfoProvEnt -> !Maybe (RealSrcSpan, LexicalFastString)
mkDynamicLinkerLabel :: DynamicLinkerLabelInfo -> CLabel -> CLabel
mkPicBaseLabel :: CLabel
mkDeadStripPreventer :: CLabel -> CLabel
mkHpcTicksLabel :: Module -> CLabel
hasCAF :: CLabel -> Bool
needsCDecl :: CLabel -> Bool

-- | If a label is a local block label then return just its <a>BlockId</a>,
--   otherwise <a>Nothing</a>.
maybeLocalBlockLabel :: CLabel -> Maybe BlockId

-- | Is a CLabel visible outside this object file or not? From the point of
--   view of the code generator, a name is externally visible if it has to
--   be declared as exported in the .o file's symbol table; that is, made
--   non-static.
externallyVisibleCLabel :: CLabel -> Bool

-- | Check whether a label corresponds to a C function that has a prototype
--   in a system header somewhere, or is built-in to the C compiler. For
--   these labels we avoid generating our own C prototypes.
isMathFun :: CLabel -> Bool
isCFunctionLabel :: CLabel -> Bool
isGcPtrLabel :: CLabel -> Bool

-- | Does a <a>CLabel</a> need dynamic linkage?
--   
--   When referring to data in code, we need to know whether that data
--   resides in a DLL or not. [Win32 only.] <tt>labelDynamic</tt> returns
--   <tt>True</tt> if the label is located in a DLL, be it a data reference
--   or not.
labelDynamic :: Module -> Platform -> Bool -> CLabel -> Bool

-- | Is a <a>CLabel</a> defined in the current module being compiled?
--   
--   Sometimes we can optimise references within a compilation unit in ways
--   that we couldn't for inter-module references. This provides a
--   conservative estimate of whether a <a>CLabel</a> lives in the current
--   module.
isLocalCLabel :: Module -> CLabel -> Bool
mayRedirectTo :: CLabel -> CLabel -> Bool

-- | Whether label is points to some kind of info table
isInfoTableLabel :: CLabel -> Bool

-- | Whether label points to an info table defined in Cmm
isCmmInfoTableLabel :: CLabel -> Bool

-- | Whether label is points to constructor info table
isConInfoTableLabel :: CLabel -> Bool
isIdLabel :: CLabel -> Bool
isTickyLabel :: CLabel -> Bool
hasHaskellName :: CLabel -> Maybe Name
hasIdLabelInfo :: CLabel -> Maybe IdLabelInfo

-- | Whether label is a top-level string literal
isBytesLabel :: CLabel -> Bool

-- | Whether label is a non-haskell label (defined in C code)
isForeignLabel :: CLabel -> Bool

-- | Whether label is a .rodata label
isSomeRODataLabel :: CLabel -> Bool

-- | Whether label is a static closure label (can come from haskell or cmm)
isStaticClosureLabel :: CLabel -> Bool
toClosureLbl :: Platform -> CLabel -> CLabel
toSlowEntryLbl :: Platform -> CLabel -> CLabel
toEntryLbl :: Platform -> CLabel -> CLabel
toInfoLbl :: Platform -> CLabel -> CLabel

-- | Generate a CmmProc delimiter label from the actual entry label.
--   
--   This delimiter label might be the entry label itself, except when the
--   entry label is a LocalBlockLabel. If we reused the entry label to
--   delimit the proc, we would generate redundant labels (see #22792)
toProcDelimiterLbl :: CLabel -> CLabel

-- | Style of label pretty-printing.
--   
--   When we produce C sources or headers, we have to take into account
--   that C compilers transform C labels when they convert them into
--   symbols. For example, they can add prefixes (e.g., "_" on Darwin). So
--   we provide two ways to pretty-print CLabels: C style or Asm style.
data LabelStyle

-- | C label style (used by C and LLVM backends)
CStyle :: LabelStyle

-- | Asm label style (used by NCG backend)
AsmStyle :: LabelStyle

-- | For debugging problems with the CLabel representation. We can't make a
--   Show instance for CLabel because lots of its components don't have
--   instances. The regular Outputable instance only shows the label name,
--   and not its other info.
pprDebugCLabel :: Platform -> CLabel -> SDoc
pprCLabel :: IsLine doc => Platform -> CLabel -> doc
pprAsmLabel :: IsLine doc => Platform -> CLabel -> doc

-- | Generate a label for a procedure internal to a module (if
--   <tt>Opt_ExposeAllSymbols</tt> is enabled). See Note [Internal proc
--   labels].
ppInternalProcLabel :: IsLine doc => Module -> CLabel -> Maybe doc
dynamicLinkerLabelInfo :: CLabel -> Maybe (DynamicLinkerLabelInfo, CLabel)

-- | This type encodes the subset of <a>CLabel</a> that occurs in C stubs
--   of foreign declarations for the purpose of serializing to interface
--   files.
--   
--   See Note [Foreign stubs and TH bytecode linking]
data CStubLabel
CStubLabel :: Bool -> Module -> FastString -> CStubLabel
[csl_is_initializer] :: CStubLabel -> Bool
[csl_module] :: CStubLabel -> Module
[csl_name] :: CStubLabel -> FastString

-- | Project the constructor <a>ModuleLabel</a> out of <a>CLabel</a> if it
--   is an initializer or finalizer.
cStubLabel :: CLabel -> Maybe CStubLabel

-- | Inject a <a>CStubLabel</a> into a <a>CLabel</a> as a
--   <a>ModuleLabel</a>.
fromCStubLabel :: CStubLabel -> CLabel

-- | A utility for renaming uniques in CLabels to produce deterministic
--   object. Note that not all Uniques are mapped over. Only those that can
--   be safely alpha renamed, e.g. uniques of local symbols, but not of
--   external ones. See Note [Renaming uniques deterministically].
mapInternalNonDetUniques :: Applicative m => (Unique -> m Unique) -> CLabel -> m CLabel
instance GHC.Classes.Eq GHC.Cmm.CLabel.CLabel
instance GHC.Classes.Eq GHC.Cmm.CLabel.CmmLabelInfo
instance GHC.Classes.Eq GHC.Cmm.CLabel.ConInfoTableLocation
instance GHC.Classes.Eq GHC.Cmm.CLabel.DynamicLinkerLabelInfo
instance GHC.Classes.Eq GHC.Cmm.CLabel.ForeignLabelSource
instance GHC.Classes.Eq GHC.Cmm.CLabel.IdLabelInfo
instance GHC.Classes.Eq GHC.Cmm.CLabel.InfoProvEnt
instance GHC.Classes.Eq GHC.Cmm.CLabel.ModuleLabelKind
instance GHC.Classes.Eq GHC.Cmm.CLabel.NeedExternDecl
instance GHC.Classes.Eq GHC.Cmm.CLabel.RtsLabelInfo
instance GHC.Classes.Eq GHC.Cmm.CLabel.TickyIdInfo
instance GHC.Classes.Ord GHC.Cmm.CLabel.CLabel
instance GHC.Classes.Ord GHC.Cmm.CLabel.CmmLabelInfo
instance GHC.Classes.Ord GHC.Cmm.CLabel.ConInfoTableLocation
instance GHC.Classes.Ord GHC.Cmm.CLabel.DynamicLinkerLabelInfo
instance GHC.Classes.Ord GHC.Cmm.CLabel.ForeignLabelSource
instance GHC.Classes.Ord GHC.Cmm.CLabel.IdLabelInfo
instance GHC.Classes.Ord GHC.Cmm.CLabel.InfoProvEnt
instance GHC.Classes.Ord GHC.Cmm.CLabel.ModuleLabelKind
instance GHC.Classes.Ord GHC.Cmm.CLabel.NeedExternDecl
instance GHC.Classes.Ord GHC.Cmm.CLabel.RtsLabelInfo
instance GHC.Classes.Ord GHC.Cmm.CLabel.TickyIdInfo
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.CLabel.CLabel
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.CLabel.InfoProvEnt
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CLabel.CStubLabel
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CLabel.ConInfoTableLocation
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CLabel.ForeignLabelSource
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CLabel.IdLabelInfo
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CLabel.TickyIdInfo
instance GHC.Internal.Show.Show GHC.Cmm.CLabel.CLabel
instance GHC.Internal.Show.Show GHC.Cmm.CLabel.TickyIdInfo

module GHC.Unit.Module.WholeCoreBindings
data WholeCoreBindings
WholeCoreBindings :: [IfaceBindingX IfaceMaybeRhs IfaceTopBndrInfo] -> Module -> ModLocation -> IfaceForeign -> WholeCoreBindings

-- | serialised tidied core bindings.
[wcb_bindings] :: WholeCoreBindings -> [IfaceBindingX IfaceMaybeRhs IfaceTopBndrInfo]

-- | The module which the bindings are for
[wcb_module] :: WholeCoreBindings -> Module

-- | The location where the sources reside. | Stubs for foreign
--   declarations and files added via <a>addForeignFilePath</a>.
[wcb_mod_location] :: WholeCoreBindings -> ModLocation
[wcb_foreign] :: WholeCoreBindings -> IfaceForeign

-- | Wrapper for avoiding a dependency on <a>Binary</a> and <a>NFData</a>
--   in <a>CLabel</a>.
newtype IfaceCLabel
IfaceCLabel :: CStubLabel -> IfaceCLabel

-- | Simplified encoding of <a>ForeignStubs</a> for interface
--   serialization.
--   
--   See Note [Foreign stubs and TH bytecode linking]
data IfaceCStubs
IfaceCStubs :: String -> String -> [IfaceCLabel] -> [IfaceCLabel] -> IfaceCStubs
[header] :: IfaceCStubs -> String
[source] :: IfaceCStubs -> String
[initializers] :: IfaceCStubs -> [IfaceCLabel]
[finalizers] :: IfaceCStubs -> [IfaceCLabel]

-- | <a>Binary</a> <a>put_</a> for <a>ForeignSrcLang</a>.
binary_put_ForeignSrcLang :: WriteBinHandle -> ForeignSrcLang -> IO ()

-- | <a>Binary</a> <a>get</a> for <a>ForeignSrcLang</a>.
binary_get_ForeignSrcLang :: ReadBinHandle -> IO ForeignSrcLang

-- | A source file added from Template Haskell using
--   <tt>qAddForeignFilePath</tt>, for storage in interfaces.
--   
--   See Note [Foreign stubs and TH bytecode linking]
data IfaceForeignFile
IfaceForeignFile :: ForeignSrcLang -> String -> FilePath -> IfaceForeignFile

-- | The language is specified by the user.
[lang] :: IfaceForeignFile -> ForeignSrcLang

-- | The contents of the file, which will be written to a temporary file
--   when loaded from an interface.
[source] :: IfaceForeignFile -> String

-- | The extension used by the user is preserved, to avoid confusing
--   external tools with an unexpected <tt>.c</tt> file or similar.
[extension] :: IfaceForeignFile -> FilePath
data IfaceForeign
IfaceForeign :: Maybe IfaceCStubs -> [IfaceForeignFile] -> IfaceForeign
[stubs] :: IfaceForeign -> Maybe IfaceCStubs
[files] :: IfaceForeign -> [IfaceForeignFile]
emptyIfaceForeign :: IfaceForeign

-- | Convert foreign stubs and foreign files to a format suitable for
--   writing to interfaces.
--   
--   See Note [Foreign stubs and TH bytecode linking]
encodeIfaceForeign :: Logger -> DynFlags -> ForeignStubs -> [(ForeignSrcLang, FilePath)] -> IO IfaceForeign

-- | Decode serialized foreign stubs and foreign files.
--   
--   See Note [Foreign stubs and TH bytecode linking]
decodeIfaceForeign :: Logger -> TmpFs -> TempDir -> IfaceForeign -> IO (ForeignStubs, [(ForeignSrcLang, FilePath)])
instance GHC.Utils.Binary.Binary GHC.Unit.Module.WholeCoreBindings.IfaceCLabel
instance GHC.Utils.Binary.Binary GHC.Unit.Module.WholeCoreBindings.IfaceCStubs
instance GHC.Utils.Binary.Binary GHC.Unit.Module.WholeCoreBindings.IfaceForeign
instance GHC.Utils.Binary.Binary GHC.Unit.Module.WholeCoreBindings.IfaceForeignFile
instance Control.DeepSeq.NFData GHC.Unit.Module.WholeCoreBindings.IfaceCLabel
instance Control.DeepSeq.NFData GHC.Unit.Module.WholeCoreBindings.IfaceCStubs
instance Control.DeepSeq.NFData GHC.Unit.Module.WholeCoreBindings.IfaceForeign
instance Control.DeepSeq.NFData GHC.Unit.Module.WholeCoreBindings.IfaceForeignFile
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.WholeCoreBindings.IfaceCLabel
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.WholeCoreBindings.IfaceCStubs
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.WholeCoreBindings.IfaceForeign
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.WholeCoreBindings.IfaceForeignFile

module GHC.Unit.Module.ModIface
type ModIface = ModIface_ 'ModIfaceFinal

-- | A <a>ModIface</a> plus a <tt>ModDetails</tt> summarises everything we
--   know about a compiled module. The <a>ModIface</a> is the stuff
--   *before* linking, and can be written out to an interface file. The
--   'ModDetails is after linking and can be completely recovered from just
--   the <a>ModIface</a>.
--   
--   When we read an interface file, we also construct a <a>ModIface</a>
--   from it, except that we explicitly make the <a>mi_decls</a> and a few
--   other fields empty; as when reading we consolidate the declarations
--   etc. into a number of indexed maps and environments in the
--   <tt>ExternalPackageState</tt>.
--   
--   See Note [Strictness in ModIface] to learn about why some fields are
--   strict and others are not.
--   
--   See Note [Private fields in ModIface] to learn why we don't export any
--   of the fields.
data ModIface_ (phase :: ModIfacePhase)
pattern ModIface :: Module -> Maybe Module -> HscSource -> Dependencies -> [Usage] -> [IfaceExport] -> Bool -> [(OccName, Fixity)] -> IfaceWarnings -> [IfaceAnnotation] -> [IfaceDeclExts phase] -> Maybe [IfaceBindingX IfaceMaybeRhs IfaceTopBndrInfo] -> IfaceForeign -> [IfaceDefault] -> Maybe IfaceTopEnv -> [IfaceClsInst] -> [IfaceFamInst] -> [IfaceRule] -> AnyHpcUsage -> IfaceTrustInfo -> Bool -> [IfaceCompleteMatch] -> Maybe Docs -> IfaceBackendExts phase -> ExtensibleFields -> Fingerprint -> IfaceBinHandle phase -> ModIface_ phase

-- | Copy fields that aren't serialised to disk to the new
--   <a>ModIface_</a>. This includes especially hashes that are usually
--   stored in the interface file header and <a>mi_top_env</a>.
--   
--   We need this function after calling <tt>shareIface</tt>, to make sure
--   the <a>ModIface_</a> doesn't lose any information. This function does
--   not discard the in-memory byte array buffer <a>mi_hi_bytes</a>.
restoreFromOldModIface :: forall (phase :: ModIfacePhase). ModIface_ phase -> ModIface_ phase -> ModIface_ phase

-- | Add a source fingerprint to a <a>ModIface_</a> without invalidating
--   the byte array buffer <a>mi_hi_bytes</a>. This is a variant of
--   <a>set_mi_src_hash</a> which does invalidate the buffer.
--   
--   The <a>mi_src_hash</a> is computed outside of <a>ModIface_</a> based
--   on the <tt>ModSummary</tt>.
addSourceFingerprint :: forall (phase :: ModIfacePhase). Fingerprint -> ModIface_ phase -> ModIface_ phase
set_mi_module :: forall (phase :: ModIfacePhase). Module -> ModIface_ phase -> ModIface_ phase
set_mi_sig_of :: forall (phase :: ModIfacePhase). Maybe Module -> ModIface_ phase -> ModIface_ phase
set_mi_hsc_src :: forall (phase :: ModIfacePhase). HscSource -> ModIface_ phase -> ModIface_ phase
set_mi_src_hash :: forall (phase :: ModIfacePhase). Fingerprint -> ModIface_ phase -> ModIface_ phase
set_mi_hi_bytes :: forall (phase :: ModIfacePhase). IfaceBinHandle phase -> ModIface_ phase -> ModIface_ phase
set_mi_deps :: forall (phase :: ModIfacePhase). Dependencies -> ModIface_ phase -> ModIface_ phase
set_mi_usages :: forall (phase :: ModIfacePhase). [Usage] -> ModIface_ phase -> ModIface_ phase
set_mi_exports :: forall (phase :: ModIfacePhase). [IfaceExport] -> ModIface_ phase -> ModIface_ phase
set_mi_used_th :: forall (phase :: ModIfacePhase). Bool -> ModIface_ phase -> ModIface_ phase
set_mi_fixities :: forall (phase :: ModIfacePhase). [(OccName, Fixity)] -> ModIface_ phase -> ModIface_ phase
set_mi_warns :: forall (phase :: ModIfacePhase). IfaceWarnings -> ModIface_ phase -> ModIface_ phase
set_mi_anns :: forall (phase :: ModIfacePhase). [IfaceAnnotation] -> ModIface_ phase -> ModIface_ phase
set_mi_insts :: forall (phase :: ModIfacePhase). [IfaceClsInst] -> ModIface_ phase -> ModIface_ phase
set_mi_fam_insts :: forall (phase :: ModIfacePhase). [IfaceFamInst] -> ModIface_ phase -> ModIface_ phase
set_mi_rules :: forall (phase :: ModIfacePhase). [IfaceRule] -> ModIface_ phase -> ModIface_ phase
set_mi_decls :: forall (phase :: ModIfacePhase). [IfaceDeclExts phase] -> ModIface_ phase -> ModIface_ phase
set_mi_defaults :: forall (phase :: ModIfacePhase). [IfaceDefault] -> ModIface_ phase -> ModIface_ phase
set_mi_extra_decls :: forall (phase :: ModIfacePhase). Maybe [IfaceBindingX IfaceMaybeRhs IfaceTopBndrInfo] -> ModIface_ phase -> ModIface_ phase
set_mi_foreign :: forall (phase :: ModIfacePhase). IfaceForeign -> ModIface_ phase -> ModIface_ phase
set_mi_top_env :: forall (phase :: ModIfacePhase). Maybe IfaceTopEnv -> ModIface_ phase -> ModIface_ phase
set_mi_hpc :: forall (phase :: ModIfacePhase). AnyHpcUsage -> ModIface_ phase -> ModIface_ phase
set_mi_trust :: forall (phase :: ModIfacePhase). IfaceTrustInfo -> ModIface_ phase -> ModIface_ phase
set_mi_trust_pkg :: forall (phase :: ModIfacePhase). Bool -> ModIface_ phase -> ModIface_ phase
set_mi_complete_matches :: forall (phase :: ModIfacePhase). [IfaceCompleteMatch] -> ModIface_ phase -> ModIface_ phase
set_mi_docs :: forall (phase :: ModIfacePhase). Maybe Docs -> ModIface_ phase -> ModIface_ phase
set_mi_final_exts :: forall (phase :: ModIfacePhase). IfaceBackendExts phase -> ModIface_ phase -> ModIface_ phase
set_mi_ext_fields :: forall (phase :: ModIfacePhase). ExtensibleFields -> ModIface_ phase -> ModIface_ phase

-- | Given a <a>PartialModIface</a>, turn it into a <a>ModIface</a> by
--   completing missing fields.
completePartialModIface :: PartialModIface -> [(Fingerprint, IfaceDecl)] -> Maybe [IfaceBindingX IfaceMaybeRhs IfaceTopBndrInfo] -> ModIfaceBackend -> ModIface

-- | In-memory byte array representation of a <a>ModIface</a>.
--   
--   See Note [Sharing of ModIface] for why we need this.
data IfaceBinHandle (phase :: ModIfacePhase)

-- | A partial <a>ModIface</a> cannot be serialised to disk.
[PartialIfaceBinHandle] :: IfaceBinHandle 'ModIfaceCore

-- | Optional <a>FullBinData</a> that can be serialised to disk directly.
--   
--   See Note [Private fields in ModIface] for when this fields needs to be
--   cleared (e.g., set to <a>Nothing</a>).
[FullIfaceBinHandle] :: !Maybe FullBinData -> IfaceBinHandle 'ModIfaceFinal
type PartialModIface = ModIface_ 'ModIfaceCore

-- | Extends a PartialModIface with information which is either: * Computed
--   after codegen * Or computed just before writing the iface to disk.
--   (Hashes) In order to fully instantiate it.
data ModIfaceBackend
ModIfaceBackend :: !Fingerprint -> !Fingerprint -> !Fingerprint -> !Fingerprint -> !Fingerprint -> !Fingerprint -> !WhetherHasOrphans -> !WhetherHasFamInst -> !Fingerprint -> !Fingerprint -> !OccName -> Maybe (WarningTxt GhcRn) -> !Name -> Maybe (WarningTxt GhcRn) -> !OccName -> Maybe Fixity -> !OccName -> Maybe (OccName, Fingerprint) -> ModIfaceBackend

-- | Hash of the whole interface
[mi_iface_hash] :: ModIfaceBackend -> !Fingerprint

-- | Hash of the ABI only
[mi_mod_hash] :: ModIfaceBackend -> !Fingerprint

-- | Hash of the important flags used when compiling the module, excluding
--   optimisation flags
[mi_flag_hash] :: ModIfaceBackend -> !Fingerprint

-- | Hash of optimisation flags
[mi_opt_hash] :: ModIfaceBackend -> !Fingerprint

-- | Hash of hpc flags
[mi_hpc_hash] :: ModIfaceBackend -> !Fingerprint

-- | Hash of plugins
[mi_plugin_hash] :: ModIfaceBackend -> !Fingerprint

-- | Whether this module has orphans
[mi_orphan] :: ModIfaceBackend -> !WhetherHasOrphans

-- | Whether this module has family instances. See Note [The type family
--   instance consistency story].
[mi_finsts] :: ModIfaceBackend -> !WhetherHasFamInst

-- | Hash of export list
[mi_exp_hash] :: ModIfaceBackend -> !Fingerprint

-- | Hash for orphan rules, class and family instances combined
[mi_orphan_hash] :: ModIfaceBackend -> !Fingerprint

-- | Cached lookup for <a>mi_warns</a> for declaration deprecations
[mi_decl_warn_fn] :: ModIfaceBackend -> !OccName -> Maybe (WarningTxt GhcRn)

-- | Cached lookup for <a>mi_warns</a> for export deprecations
[mi_export_warn_fn] :: ModIfaceBackend -> !Name -> Maybe (WarningTxt GhcRn)

-- | Cached lookup for <a>mi_fixities</a>
[mi_fix_fn] :: ModIfaceBackend -> !OccName -> Maybe Fixity

-- | Cached lookup for <a>mi_decls</a>. The <tt>Nothing</tt> in
--   <a>mi_hash_fn</a> means that the thing isn't in decls. It's useful to
--   know that when seeing if we are up to date wrt. the old interface. The
--   <a>OccName</a> is the parent of the name, if it has one.
[mi_hash_fn] :: ModIfaceBackend -> !OccName -> Maybe (OccName, Fingerprint)

-- | Selects a IfaceDecl representation. For fully instantiated interfaces
--   we also maintain a fingerprint, which is used for recompilation
--   checks.
type family IfaceDeclExts (phase :: ModIfacePhase) = (decl :: Type) | decl -> phase
type family IfaceBackendExts (phase :: ModIfacePhase) = (bk :: Type) | bk -> phase

-- | The original names declared of a certain module that are exported
type IfaceExport = AvailInfo

-- | Records whether a module has orphans. An "orphan" is one of:
--   
--   <ul>
--   <li>An instance declaration in a module other than the definition
--   module for one of the type constructors or classes in the instance
--   head</li>
--   <li>A rewrite rule in a module other than the one defining the
--   function in the head of the rule</li>
--   </ul>
type WhetherHasOrphans = Bool

-- | Does this module define family instances?
type WhetherHasFamInst = Bool
data IfaceTopEnv
IfaceTopEnv :: !IfGlobalRdrEnv -> ![IfaceImport] -> IfaceTopEnv

-- | all top level things in this module, including unexported stuff
[ifaceTopExports] :: IfaceTopEnv -> !IfGlobalRdrEnv

-- | all the imports in this module
[ifaceImports] :: IfaceTopEnv -> ![IfaceImport]
data IfaceImport
IfaceImport :: ImpDeclSpec -> ImpIfaceList -> IfaceImport

-- | Old-style accessor for whether or not the ModIface came from an
--   hs-boot file.
mi_boot :: ModIface -> IsBootInterface

-- | Lookups up a (possibly cached) fixity from a <a>ModIface</a>. If one
--   cannot be found, <a>defaultFixity</a> is returned instead.
mi_fix :: ModIface -> OccName -> Fixity

-- | The semantic module for this interface; e.g., if it's a interface for
--   a signature, if <a>mi_module</a> is <tt>p[A=<a>A</a>]:A</tt>,
--   <a>mi_semantic_module</a> will be <tt><a>A</a></tt>.
mi_semantic_module :: forall (a :: ModIfacePhase). ModIface_ a -> Module

-- | The "precise" free holes, e.g., the signatures that this
--   <a>ModIface</a> depends on.
mi_free_holes :: ModIface -> UniqDSet ModuleName
mi_mnwib :: ModIface -> ModuleNameWithIsBoot

-- | Given a set of free holes, and a unit identifier, rename the free
--   holes according to the instantiation of the unit identifier. For
--   example, if we have A and B free, and our unit identity is
--   <tt>p[A=<a>C</a>,B=impl:B]</tt>, the renamed free holes are just C.
renameFreeHoles :: UniqDSet ModuleName -> [(ModuleName, Module)] -> UniqDSet ModuleName
emptyPartialModIface :: Module -> PartialModIface
emptyFullModIface :: Module -> ModIface

-- | Constructs cache for the <a>mi_hash_fn</a> field of a <a>ModIface</a>
mkIfaceHashCache :: [(Fingerprint, IfaceDecl)] -> OccName -> Maybe (OccName, Fingerprint)
emptyIfaceHashCache :: OccName -> Maybe (OccName, Fingerprint)
forceModIface :: ModIface -> IO ()
instance GHC.Utils.Binary.Binary GHC.Unit.Module.ModIface.ModIface
instance Control.DeepSeq.NFData GHC.Unit.Module.ModIface.IfaceTopEnv
instance Control.DeepSeq.NFData GHC.Unit.Module.ModIface.ModIfaceBackend
instance (Control.DeepSeq.NFData (GHC.Unit.Module.ModIface.IfaceBackendExts phase), Control.DeepSeq.NFData (GHC.Unit.Module.ModIface.IfaceDeclExts phase)) => Control.DeepSeq.NFData (GHC.Unit.Module.ModIface.ModIface_ phase)

module GHC.Tc.Errors.Types

-- | An error which might arise during typechecking/renaming.
data TcRnMessage

-- | Simply wraps an unknown <a>Diagnostic</a> message <tt>a</tt>. It can
--   be used by plugins to provide custom diagnostic messages originated
--   during typechecking/renaming.
[TcRnUnknownMessage] :: UnknownDiagnostic (DiagnosticOpts TcRnMessage) -> TcRnMessage

-- | Wrap an <a>IfaceMessage</a> to a <a>TcRnMessage</a> for when we
--   attempt to load interface files during typechecking but encounter an
--   error.
[TcRnInterfaceError] :: !IfaceMessage -> TcRnMessage

-- | TcRnMessageWithInfo is a constructor which is used when extra
--   information is needed to be provided in order to qualify a diagnostic
--   and where it was originated (and why). It carries an extra
--   <a>UnitState</a> which can be used to pretty-print some names and it
--   wraps a <a>TcRnMessageDetailed</a>, which includes any extra context
--   associated with this diagnostic.
[TcRnMessageWithInfo] :: !UnitState -> !TcRnMessageDetailed -> TcRnMessage

-- | TcRnWithHsDocContext annotates an error message with the context in
--   which it originated.
[TcRnWithHsDocContext] :: !HsDocContext -> !TcRnMessage -> TcRnMessage

-- | TcRnSolverReport is the constructor used to report unsolved
--   constraints after constraint solving, as well as other errors such as
--   hole fit errors.
--   
--   See the documentation of <a>TcSolverReportMsg</a> datatype for an
--   overview of the different errors.
[TcRnSolverReport] :: SolverReportWithCtxt -> DiagnosticReason -> TcRnMessage

-- | TcRnSolverDepthError is an error that occurs when the constraint
--   solver exceeds the maximum recursion depth.
--   
--   Example:
--   
--   class C a where { meth :: a } instance Cls [a] =&gt; Cls a where {
--   meth = head . meth }
--   
--   t :: () t = meth
--   
--   Test cases: T7788 T8550 T9554 T15316A T17267{∅,a,b,c,e} T17458
--   ContextStack1 T22924b TcCoercibleFail
[TcRnSolverDepthError] :: !Type -> !SubGoalDepth -> TcRnMessage

-- | TcRnRedundantConstraints is a warning that is emitted when a binding
--   has a user-written type signature which contains superfluous
--   constraints.
--   
--   Example:
--   
--   f :: (Eq a, Ord a) =&gt; a -&gt; a -&gt; a f x y = (x &lt; y) || x ==
--   y -- `Eq a` is superfluous: the `Ord a` constraint suffices.
--   
--   Test cases: T9939, T10632, T18036a, T20602, PluralS, T19296.
[TcRnRedundantConstraints] :: [Id] -> (SkolemInfoAnon, Bool) -> TcRnMessage

-- | TcRnInaccessibleCode is a warning that is emitted when the RHS of a
--   pattern match is inaccessible, because the constraint solver has
--   detected a contradiction.
--   
--   Example:
--   
--   data B a where { MkTrue :: B True; MkFalse :: B False }
--   
--   foo :: B False -&gt; Bool foo MkFalse = False foo MkTrue = True --
--   Inaccessible: requires True ~ False
--   
--   Test cases: T7293, T7294, T15558, T17646, T18572, T18610, tcfail167.
[TcRnInaccessibleCode] :: Implication -> SolverReportWithCtxt -> TcRnMessage

-- | TcRnInaccessibleCoAxBranch is a warning that is emitted when a closed
--   type family has a branch which is inaccessible due to a more general,
--   prior branch.
--   
--   Example: type family F a where F a = Int F Bool = Bool Test cases:
--   T9085, T14066a, T9085, T6018, tc265,
[TcRnInaccessibleCoAxBranch] :: TyCon -> CoAxBranch -> TcRnMessage

-- | A type which was expected to have a fixed runtime representation does
--   not have a fixed runtime representation.
--   
--   Example:
--   
--   data D (a :: TYPE r) = MkD a
--   
--   Test cases: T11724, T18534, RepPolyPatSynArg,
--   RepPolyPatSynUnliftedNewtype, RepPolyPatSynRes, T20423
[TcRnTypeDoesNotHaveFixedRuntimeRep] :: !Type -> !FixedRuntimeRepProvenance -> !ErrInfo -> TcRnMessage

-- | TcRnImplicitLift is a warning (controlled with -Wimplicit-lift) that
--   occurs when a Template Haskell quote implicitly uses <tt>lift</tt>.
--   
--   Example: warning1 :: Lift t =&gt; t -&gt; Q Exp warning1 x = [| x |]
--   
--   Test cases: th/T17804
[TcRnImplicitLift] :: Name -> !ErrInfo -> TcRnMessage

-- | TcRnUnusedPatternBinds is a warning (controlled with
--   -Wunused-pattern-binds) that occurs if a pattern binding binds no
--   variables at all, unless it is a lone wild-card pattern, or a banged
--   pattern.
--   
--   Example: Just _ = rhs3 -- Warning: unused pattern binding (_, _) =
--   rhs4 -- Warning: unused pattern binding _ = rhs3 -- No warning: lone
--   wild-card pattern !() = rhs4 -- No warning: banged pattern; behaves
--   like seq
--   
--   Test cases: rename/{T13646,T17c,T17e,T7085}
[TcRnUnusedPatternBinds] :: HsBind GhcRn -> TcRnMessage

-- | TcRnUnusedQuantifiedTypeVar is a warning that occurs if there are
--   unused quantified type variables.
--   
--   Examples: f :: forall a. Int -&gt; Char
--   
--   Test cases: rename<i>should_compile</i>ExplicitForAllRules1
--   rename<i>should_compile</i>T5331
[TcRnUnusedQuantifiedTypeVar] :: HsDocContext -> HsTyVarBndrExistentialFlag -> TcRnMessage

-- | TcRnDodgyImports is a group of warnings (controlled with
--   -Wdodgy-imports).
--   
--   See <a>DodgyImportsReason</a> for the different warnings.
[TcRnDodgyImports] :: !DodgyImportsReason -> TcRnMessage

-- | TcRnDodgyExports is a warning (controlled by -Wdodgy-exports) that
--   occurs when an export of the form 'T(..)' for a type constructor
--   <tt>T</tt> does not actually export anything beside <tt>T</tt> itself.
--   
--   Example: module Foo ( T(..) -- Warning: T is a type synonym , A(..) --
--   Warning: A is a type family , C(..) -- Warning: C is a data family )
--   where
--   
--   type T = Int type family A :: * -&gt; * data family C :: * -&gt; *
--   
--   Test cases: warnings<i>should_compile</i>DodgyExports01
[TcRnDodgyExports] :: GlobalRdrElt -> TcRnMessage

-- | TcRnMissingImportList is a warning (controlled by
--   -Wmissing-import-lists) that occurs when an import declaration does
--   not explicitly list all the names brought into scope.
--   
--   Test cases: rename<i>should_compile</i>T4489
[TcRnMissingImportList] :: IE GhcPs -> TcRnMessage

-- | When a module marked trustworthy or unsafe (using -XTrustworthy or
--   -XUnsafe) is compiled with a plugin, the TcRnUnsafeDueToPlugin warning
--   (controlled by -Wunsafe) is used as the reason the module was inferred
--   to be unsafe. This warning is not raised if the -fplugin-trustworthy
--   flag is passed.
--   
--   Test cases: plugins/T19926
[TcRnUnsafeDueToPlugin] :: TcRnMessage

-- | TcRnModMissingRealSrcSpan is an error that occurs when compiling a
--   module that lacks an associated <a>RealSrcSpan</a>.
--   
--   Test cases: None
[TcRnModMissingRealSrcSpan] :: Module -> TcRnMessage

-- | TcRnIdNotExportedFromModuleSig is an error pertaining to backpack that
--   occurs when an identifier required by a signature is not exported by
--   the module or signature that is being used as a substitution for that
--   signature.
--   
--   Example(s): None
--   
--   Test cases: backpack<i>should_fail</i>bkpfail36
[TcRnIdNotExportedFromModuleSig] :: Name -> Module -> TcRnMessage

-- | TcRnIdNotExportedFromLocalSig is an error pertaining to backpack that
--   occurs when an identifier which is necessary for implementing a module
--   signature is not exported from that signature.
--   
--   Example(s): None
--   
--   Test cases: backpack<i>should_fail</i>bkpfail30
--   backpack<i>should_fail</i>bkpfail31
--   backpack<i>should_fail</i>bkpfail34
[TcRnIdNotExportedFromLocalSig] :: Name -> TcRnMessage

-- | TcRnShadowedName is a warning (controlled by -Wname-shadowing) that
--   occurs whenever an inner-scope value has the same name as an
--   outer-scope value, i.e. the inner value shadows the outer one. This
--   can catch typographical errors that turn into hard-to-find bugs. The
--   warning is suppressed for names beginning with an underscore.
--   
--   Examples(s): f = ... let f = id in ... f ... -- NOT OK, <tt>f</tt> is
--   shadowed f x = do { _ignore &lt;- this; _ignore &lt;- that; return
--   (the other) } -- suppressed via underscore
--   
--   Test cases: typecheck<i>should_compile</i>T10971a
--   rename<i>should_compile</i>rn039 rename<i>should_compile</i>rn064
--   rename<i>should_compile</i>T1972 rename<i>should_fail</i>T2723
--   rename<i>should_compile</i>T3262 driver/werror
--   rename<i>should_fail</i>T22478d
--   typecheck<i>should_fail</i>TyAppPat_ScopedTyVarConflict
[TcRnShadowedName] :: OccName -> ShadowedNameProvenance -> TcRnMessage

-- | TcRnInvalidWarningCategory is an error that occurs when a warning is
--   declared with a category name that is not the special category
--   "deprecations", and either does not begin with the prefix "x-"
--   indicating a user-defined category, or contains characters not valid
--   in category names. See Note [Warning categories] in
--   GHC.Unit.Module.Warnings
--   
--   Examples(s): module M {-# WARNING in "invalid" <a>Oops</a> #-} where
--   
--   {-# WARNING in "x- spaces not allowed" foo <a>Oops</a> #-}
--   
--   Test cases: warnings<i>should_fail</i>WarningCategoryInvalid
[TcRnInvalidWarningCategory] :: !WarningCategory -> TcRnMessage

-- | TcRnDuplicateWarningDecls is an error that occurs whenever a warning
--   is declared twice.
--   
--   Examples(s): {-# DEPRECATED foo "Don't use me" #-} {-# DEPRECATED foo
--   "Don't use me" #-} foo :: Int foo = 2
--   
--   Test cases: rename<i>should_fail</i>rnfail058
[TcRnDuplicateWarningDecls] :: !LocatedN RdrName -> !RdrName -> TcRnMessage

-- | TcRnSimplifierTooManyIterations is an error that occurs whenever the
--   constraint solver in the simplifier hits the iterations' limit.
--   
--   Examples(s): None.
--   
--   Test cases: None.
[TcRnSimplifierTooManyIterations] :: Cts -> !IntWithInf -> WantedConstraints -> TcRnMessage

-- | TcRnIllegalPatSynDecl is an error that occurs whenever there is an
--   illegal pattern synonym declaration.
--   
--   Examples(s):
--   
--   varWithLocalPatSyn x = case x of P -&gt; () where pattern P = () --
--   not valid, it can't be local, it must be defined at top-level.
--   
--   Test cases: patsyn<i>should_fail</i>local
[TcRnIllegalPatSynDecl] :: !LIdP GhcPs -> TcRnMessage

-- | TcRnLinearPatSyn is an error that occurs whenever a pattern synonym
--   signature uses a field that is not unrestricted.
--   
--   Example(s): None
--   
--   Test cases: linear<i>should_fail</i>LinearPatSyn2
[TcRnLinearPatSyn] :: !Type -> TcRnMessage

-- | TcRnEmptyRecordUpdate is an error that occurs whenever a record is
--   updated without specifying any field.
--   
--   Examples(s):
--   
--   $(deriveJSON defaultOptions{} ''Bad) -- not ok, no fields selected for
--   update of defaultOptions
--   
--   Test cases: th/T12788
[TcRnEmptyRecordUpdate] :: TcRnMessage

-- | TcRnIllegalFieldPunning is an error that occurs whenever field punning
--   is used without the <tt>NamedFieldPuns</tt> extension enabled.
--   
--   Examples(s):
--   
--   data Foo = Foo { a :: Int }
--   
--   foo :: Foo -&gt; Int foo Foo{a} = a -- Not ok, punning used without
--   extension.
--   
--   Test cases: parser<i>should_fail</i>RecordDotSyntaxFail12
[TcRnIllegalFieldPunning] :: !Located RdrName -> TcRnMessage

-- | TcRnIllegalWildcardsInRecord is an error that occurs whenever
--   wildcards (..) are used in a record without the relevant extension
--   being enabled.
--   
--   Examples(s):
--   
--   data Foo = Foo { a :: Int }
--   
--   foo :: Foo -&gt; Int foo Foo{..} = a -- Not ok, wildcards used without
--   extension.
--   
--   Test cases: parser<i>should_fail</i>RecordWildCardsFail
[TcRnIllegalWildcardsInRecord] :: !RecordFieldPart -> TcRnMessage

-- | TcRnIllegalWildcardInType is an error that occurs when a wildcard
--   appears in a type in a location in which wildcards aren't allowed.
--   
--   Examples:
--   
--   Type synonyms:
--   
--   type T = _
--   
--   Class declarations and instances:
--   
--   class C _ instance C _
--   
--   Standalone kind signatures:
--   
--   type D :: _ data D
--   
--   Test cases: ExtraConstraintsWildcardInTypeSplice2
--   ExtraConstraintsWildcardInTypeSpliceUsed
--   ExtraConstraintsWildcardNotLast ExtraConstraintsWildcardTwice
--   NestedExtraConstraintsWildcard NestedNamedExtraConstraintsWildcard
--   PartialClassMethodSignature PartialClassMethodSignature2 T12039
--   T13324_fail1 UnnamedConstraintWildcard1 UnnamedConstraintWildcard2
--   WildcardInADT1 WildcardInADT2 WildcardInADT3 WildcardInADTContext1
--   WildcardInDefault WildcardInDefaultSignature WildcardInDeriving
--   WildcardInForeignExport WildcardInForeignImport WildcardInGADT1
--   WildcardInGADT2 WildcardInInstanceHead WildcardInInstanceSig
--   WildcardInNewtype WildcardInPatSynSig WildcardInStandaloneDeriving
--   WildcardInTypeFamilyInstanceRHS WildcardInTypeSynonymRHS saks_fail003
--   T15433a
[TcRnIllegalWildcardInType] :: Maybe Name -> !BadAnonWildcardContext -> TcRnMessage

-- | TcRnIllegalNamedWildcardInTypeArgument is an error that occurs when a
--   named wildcard is used in a required type argument.
--   
--   Example:
--   
--   vfun :: forall (a :: k) -&gt; () x = vfun _nwc -- ^^^^ -- named
--   wildcards not allowed in type arguments
--   
--   Test cases: T23738_fail_wild
[TcRnIllegalNamedWildcardInTypeArgument] :: RdrName -> TcRnMessage
[TcRnIllegalImplicitTyVarInTypeArgument] :: RdrName -> TcRnMessage

-- | TcRnDuplicateFieldName is an error that occurs whenever there are
--   duplicate field names in a single record.
--   
--   Examples(s):
--   
--   data R = MkR { x :: Int, x :: Bool } f r = r { x = 3, x = 4 }
--   
--   Test cases: T21959.
[TcRnDuplicateFieldName] :: !RecordFieldPart -> NonEmpty RdrName -> TcRnMessage

-- | TcRnIllegalViewPattern is an error that occurs whenever the
--   ViewPatterns syntax is used but the ViewPatterns language extension is
--   not enabled.
--   
--   Examples(s): data Foo = Foo { a :: Int }
--   
--   foo :: Foo -&gt; Int foo (a -&gt; l) = l -- not OK, the
--   <tt>ViewPattern</tt> extension is not enabled.
--   
--   Test cases: parser<i>should_fail</i>ViewPatternsFail
[TcRnIllegalViewPattern] :: !Pat GhcPs -> TcRnMessage

-- | TcRnCharLiteralOutOfRange is an error that occurs whenever a character
--   is out of range.
--   
--   Examples(s): None
--   
--   Test cases: None
[TcRnCharLiteralOutOfRange] :: !Char -> TcRnMessage

-- | TcRnNegativeNumTypeLiteral is an error that occurs whenever a
--   type-level number literal is negative.
--   
--   type Neg = -1
--   
--   Test cases: th/T8412 typecheck<i>should_fail</i>T8306
[TcRnNegativeNumTypeLiteral] :: HsTyLit GhcPs -> TcRnMessage

-- | TcRnIllegalWildcardsInConstructor is an error that occurs whenever the
--   record wildcards '..' are used inside a constructor without labeled
--   fields.
--   
--   Examples(s): None
--   
--   Test cases: rename<i>should_fail</i>T9815.hs
--   rename<i>should_fail</i>T9815b.hs rename<i>should_fail</i>T9815ghci.hs
--   rename<i>should_fail</i>T9815bghci.hs
[TcRnIllegalWildcardsInConstructor] :: !Name -> TcRnMessage

-- | TcRnIgnoringAnnotations is a warning that occurs when the source code
--   contains annotation pragmas but the platform in use does not support
--   an external interpreter such as GHCi and therefore the annotations are
--   ignored.
--   
--   Example(s): None
--   
--   Test cases: None
[TcRnIgnoringAnnotations] :: [LAnnDecl GhcRn] -> TcRnMessage

-- | TcRnAnnotationInSafeHaskell is an error that occurs if annotation
--   pragmas are used in conjunction with Safe Haskell.
--   
--   Example(s): None
--   
--   Test cases: annotations<i>should_fail</i>T10826
[TcRnAnnotationInSafeHaskell] :: TcRnMessage

-- | TcRnInvalidTypeApplication is an error that occurs when a visible type
--   application is used with an expression that does not accept
--   "specified" type arguments.
--   
--   Example(s): foo :: forall {a}. a -&gt; a foo x = x bar :: () bar = let
--   x = foo @Int 42 in ()
--   
--   Test cases: overloadedrecflds<i>should_fail</i>overloadedlabelsfail03
--   typecheck<i>should_fail</i>ExplicitSpecificity1
--   typecheck<i>should_fail</i>ExplicitSpecificity10
--   typecheck<i>should_fail</i>ExplicitSpecificity2
--   typecheck<i>should_fail</i>T17173 typecheck<i>should_fail</i>VtaFail
[TcRnInvalidTypeApplication] :: Type -> LHsWcType GhcRn -> TcRnMessage

-- | TcRnTagToEnumMissingValArg is an error that occurs when the
--   'tagToEnum#' function is not applied to a single value argument.
--   
--   Example(s): tagToEnum# 1 2
--   
--   Test cases: None
[TcRnTagToEnumMissingValArg] :: TcRnMessage

-- | TcRnTagToEnumUnspecifiedResTy is an error that occurs when the
--   'tagToEnum#' function is not given a concrete result type.
--   
--   Example(s): foo :: forall a. a foo = tagToEnum# 0#
--   
--   Test cases: typecheck<i>should_fail</i>tcfail164
[TcRnTagToEnumUnspecifiedResTy] :: Type -> TcRnMessage

-- | TcRnTagToEnumResTyNotAnEnum is an error that occurs when the
--   'tagToEnum#' function is given a result type that is not an
--   enumeration type.
--   
--   Example(s): foo :: Int -- not an enumeration TyCon foo = tagToEnum# 0#
--   
--   Test cases: typecheck<i>should_fail</i>tcfail164
[TcRnTagToEnumResTyNotAnEnum] :: Type -> TcRnMessage

-- | TcRnTagToEnumResTyTypeData is an error that occurs when the
--   'tagToEnum#' function is given a result type that is headed by a
--   <tt>type data</tt> type, as the data constructors of a <tt>type
--   data</tt> do not exist at the term level.
--   
--   Example(s): type data Letter = A | B | C
--   
--   foo :: Letter foo = tagToEnum# 0#
--   
--   Test cases: type-data<i>should_fail</i>TDTagToEnum.hs
[TcRnTagToEnumResTyTypeData] :: Type -> TcRnMessage

-- | TcRnArrowIfThenElsePredDependsOnResultTy is an error that occurs when
--   the predicate type of an ifThenElse expression in arrow notation
--   depends on the type of the result.
--   
--   Example(s): None
--   
--   Test cases: None
[TcRnArrowIfThenElsePredDependsOnResultTy] :: TcRnMessage

-- | TcRnIllegalHsBootOrSigDecl is an error that occurs when an hs-boot
--   file contains declarations that are not allowed, such as bindings.
--   
--   Examples:
--   
--   <ul>
--   <li>- A.hs-boot f :: Int -&gt; Int f x = 2 * x -- binding not
--   allowed</li>
--   <li>- B.hs-boot type family F a where { F Int = Bool }</li>
--   <li>- type family equations not allowed</li>
--   <li>- C.hsig bar :: Int -&gt; Int {-# RULES forall x. bar x = x #-} --
--   RULES not allowed</li>
--   </ul>
--   
--   Test cases:
--   
--   <ul>
--   <li>bindings: T19781</li>
--   <li>class instance body: none</li>
--   <li>type family instance: HsBootFam</li>
--   <li>splice: none</li>
--   <li>foreign declaration: none</li>
--   <li>default declaration: none</li>
--   <li>RULEs: none</li>
--   </ul>
[TcRnIllegalHsBootOrSigDecl] :: !HsBootOrSig -> !BadBootDecls -> TcRnMessage

-- | TcRnBootMismatch is a family of errors that occur when there is a
--   mismatch between the hs-boot and hs files.
--   
--   Examples:
--   
--   <ul>
--   <li>- A.hs-boot foo :: Int -&gt; Bool data D = MkD</li>
--   <li>- A.hs foo :: Int -&gt; Char foo = chr</li>
--   </ul>
--   
--   data D = MkD Int
--   
--   Test cases:
--   
--   <ul>
--   <li>missing export: bkpcabal06, bkpfail{01,05,09,16,35},
--   rnfail{047,055}</li>
--   <li>missing definition: none</li>
--   <li>missing instance: T14075</li>
--   <li>mismatch in exports: bkpfail{03,19}</li>
--   <li>conflicting definitions: bkpcabal02,
--   bkpfail{04,06,07,10,12,133,14,15,17,22,23,25,26,27,41,42,45,47,50,52,53,54},
--   T19244{a,b}, T23344, ClosedFam3, rnfail055</li>
--   </ul>
[TcRnBootMismatch] :: !HsBootOrSig -> !BootMismatch -> TcRnMessage

-- | TcRnRecursivePatternSynonym is an error that occurs when a pattern
--   synonym is defined in terms of itself, either directly or indirectly.
--   
--   Example(s): pattern A = B pattern B = A
--   
--   Test cases: patsyn<i>should_fail</i>T16900
[TcRnRecursivePatternSynonym] :: LHsBinds GhcRn -> TcRnMessage

-- | TcRnPartialTypeSigTyVarMismatch is an error that occurs when a partial
--   type signature attempts to unify two different types.
--   
--   Example(s): f :: a -&gt; b -&gt; _ f x y = [x, y]
--   
--   Test cases: partial-sigs<i>should_fail</i>T14449
[TcRnPartialTypeSigTyVarMismatch] :: Name -> Name -> Name -> LHsSigWcType GhcRn -> TcRnMessage

-- | TcRnPartialTypeSigBadQuantifier is an error that occurs when a type
--   variable being quantified over in the partial type signature of a
--   function gets unified with a type that is free in that function's
--   context.
--   
--   Example(s): foo :: Num a =&gt; a -&gt; a foo xxx = g xxx where g ::
--   forall b. Num b =&gt; _ -&gt; b g y = xxx + y
--   
--   Test cases: partial-sig<i>should_fail</i>T14479
[TcRnPartialTypeSigBadQuantifier] :: Name -> Name -> Maybe Type -> LHsSigWcType GhcRn -> TcRnMessage

-- | TcRnMissingSignature is a warning that occurs when a top-level binding
--   or a pattern synonym does not have a type signature.
--   
--   Controlled by the flags: -Wmissing-signatures
--   -Wmissing-exported-signatures -Wmissing-pattern-synonym-signatures
--   -Wmissing-exported-pattern-synonym-signatures
--   -Wmissing-kind-signatures -Wmissing-poly-kind-signatures
--   
--   Test cases: T11077 (top-level bindings) T12484 (pattern synonyms)
--   T19564 (kind signatures)
[TcRnMissingSignature] :: MissingSignature -> Exported -> TcRnMessage

-- | TcRnPolymorphicBinderMissingSig is a warning controlled by
--   -Wmissing-local-signatures that occurs when a local polymorphic
--   binding lacks a type signature.
--   
--   Example(s): id a = a
--   
--   Test cases: warnings<i>should_compile</i>T12574
[TcRnPolymorphicBinderMissingSig] :: Name -> Type -> TcRnMessage

-- | TcRnOverloadedSig is an error that occurs when a binding group
--   conflicts with the monomorphism restriction.
--   
--   Example(s): data T a = T a mono = ... where x :: Applicative f =&gt; f
--   a T x = ...
--   
--   Test cases: typecheck<i>should_compile</i>T11339
[TcRnOverloadedSig] :: TcIdSig -> TcRnMessage

-- | TcRnTupleConstraintInst is an error that occurs whenever an instance
--   for a tuple constraint is specified.
--   
--   Examples(s): class C m a class D m a f :: (forall a. Eq a =&gt; (C m
--   a, D m a)) =&gt; m a f = undefined
--   
--   Test cases: quantified-constraints/T15334
[TcRnTupleConstraintInst] :: !Class -> TcRnMessage

-- | TcRnUserTypeError is an error that occurs due to a user's custom type
--   error, which can be triggered by adding a <tt>TypeError</tt>
--   constraint in a type signature or typeclass instance.
--   
--   Examples(s): f :: TypeError (Text "This is a type error") f =
--   undefined
--   
--   Test cases: typecheck<i>should_fail</i>CustomTypeErrors02
--   typecheck<i>should_fail</i>CustomTypeErrors03
[TcRnUserTypeError] :: !Type -> TcRnMessage

-- | TcRnConstraintInKind is an error that occurs whenever a constraint is
--   specified in a kind.
--   
--   Examples(s): data Q :: Eq a =&gt; Type where {}
--   
--   Test cases: dependent<i>should_fail</i>T13895 polykinds/T16263
--   saks<i>should_fail</i>saks_fail004 typecheck<i>should_fail</i>T16059a
--   typecheck<i>should_fail</i>T18714
[TcRnConstraintInKind] :: !Type -> TcRnMessage

-- | TcRnUnboxedTupleTypeFuncArg is an error that occurs whenever an
--   unboxed tuple or unboxed sum type is specified as a function argument,
--   when the appropriate extension (`-XUnboxedTuples` or `-XUnboxedSums`)
--   isn't enabled.
--   
--   Examples(s): -- T15073.hs import T15073a newtype Foo a = MkFoo a
--   deriving P
--   
--   <ul>
--   <li>- T15073a.hs class P a where p :: a -&gt; (# a #)</li>
--   </ul>
--   
--   Test cases: deriving<i>should_fail</i>T15073.hs
--   deriving<i>should_fail</i>T15073a.hs
--   typecheck<i>should_fail</i>T16059d
[TcRnUnboxedTupleOrSumTypeFuncArg] :: UnboxedTupleOrSum -> !Type -> TcRnMessage

-- | TcRnLinearFuncInKind is an error that occurs whenever a linear
--   function is specified in a kind.
--   
--   Examples(s): data A :: * %1 -&gt; *
--   
--   Test cases: linear<i>should_fail</i>LinearKind
--   linear<i>should_fail</i>LinearKind2
--   linear<i>should_fail</i>LinearKind3
[TcRnLinearFuncInKind] :: !Type -> TcRnMessage

-- | TcRnForAllEscapeError is an error that occurs whenever a quantified
--   type's kind mentions quantified type variable.
--   
--   Examples(s): type T :: TYPE (BoxedRep l) data T = MkT
--   
--   Test cases: unlifted-datatypes<i>should_fail</i>UnlDataNullaryPoly
[TcRnForAllEscapeError] :: !Type -> !Kind -> TcRnMessage

-- | TcRnVDQInTermType is an error that occurs whenever a visible dependent
--   quantification is specified in the type of a term.
--   
--   Examples(s): a = (undefined :: forall k -&gt; k -&gt; Type) @Int
--   
--   Test cases: dependent<i>should_fail</i>T15859
--   dependent<i>should_fail</i>T16326_Fail1
--   dependent<i>should_fail</i>T16326_Fail2
--   dependent<i>should_fail</i>T16326_Fail3
--   dependent<i>should_fail</i>T16326_Fail4
--   dependent<i>should_fail</i>T16326_Fail5
--   dependent<i>should_fail</i>T16326_Fail6
--   dependent<i>should_fail</i>T16326_Fail7
--   dependent<i>should_fail</i>T16326_Fail8
--   dependent<i>should_fail</i>T16326_Fail9
--   dependent<i>should_fail</i>T16326_Fail10
--   dependent<i>should_fail</i>T16326_Fail11
--   dependent<i>should_fail</i>T16326_Fail12
--   dependent<i>should_fail</i>T17687 dependent<i>should_fail</i>T18271
[TcRnVDQInTermType] :: !Maybe Type -> TcRnMessage

-- | TcRnBadQuantPredHead is an error that occurs whenever a quantified
--   predicate lacks a class or type variable head.
--   
--   Examples(s): class (forall a. A t a =&gt; A t [a]) =&gt; B t where
--   type A t a :: Constraint
--   
--   Test cases: quantified-constraints/T16474
[TcRnBadQuantPredHead] :: !Type -> TcRnMessage

-- | TcRnIllegalTupleConstraint is an error that occurs whenever an illegal
--   tuple constraint is specified.
--   
--   Examples(s): g :: ((Show a, Num a), Eq a) =&gt; a -&gt; a g =
--   undefined
--   
--   Test cases: typecheck<i>should_fail</i>tcfail209a
[TcRnIllegalTupleConstraint] :: !Type -> TcRnMessage

-- | TcRnNonTypeVarArgInConstraint is an error that occurs whenever a non
--   type-variable argument is specified in a constraint.
--   
--   Examples(s): data T instance Eq Int =&gt; Eq T
--   
--   Test cases: ghci<i>scripts</i>T13202 ghci<i>scripts</i>T13202a
--   polykinds/T12055a typecheck<i>should_fail</i>T10351
--   typecheck<i>should_fail</i>T19187 typecheck<i>should_fail</i>T6022
--   typecheck<i>should_fail</i>T8883
[TcRnNonTypeVarArgInConstraint] :: !Type -> TcRnMessage

-- | TcRnIllegalImplicitParam is an error that occurs whenever an illegal
--   implicit parameter is specified.
--   
--   Examples(s): type Bla = ?x::Int data T = T instance Bla =&gt; Eq T
--   
--   Test cases: polykinds/T11466 typecheck<i>should_fail</i>T8912
--   typecheck<i>should_fail</i>tcfail041
--   typecheck<i>should_fail</i>tcfail211
--   typecheck<i>should_fail</i>tcrun045
[TcRnIllegalImplicitParam] :: !Type -> TcRnMessage

-- | TcRnIllegalConstraintSynonymOfKind is an error that occurs whenever an
--   illegal constraint synonym of kind is specified.
--   
--   Examples(s): type Showish = Show f :: (Showish a) =&gt; a -&gt; a f =
--   undefined
--   
--   Test cases: typecheck<i>should_fail</i>tcfail209
[TcRnIllegalConstraintSynonymOfKind] :: !Type -> TcRnMessage

-- | TcRnOversaturatedVisibleKindArg is an error that occurs whenever an
--   illegal oversaturated visible kind argument is specified.
--   
--   Examples(s): type family F2 :: forall (a :: Type). Type where F2 @a =
--   Maybe a
--   
--   Test cases: typecheck<i>should_fail</i>T15793
--   typecheck<i>should_fail</i>T16255
[TcRnOversaturatedVisibleKindArg] :: !Type -> TcRnMessage

-- | TcRnForAllRankErr is an error that occurs whenever an illegal ranked
--   type is specified.
--   
--   Examples(s): foo :: (a,b) -&gt; (a~b =&gt; t) -&gt; (a,b) foo p x = p
--   
--   Test cases: - ghci<i>should_run</i>T15806 -
--   indexed-types<i>should_fail</i>SimpleFail15 -
--   typecheck<i>should_fail</i>T11355 - typecheck<i>should_fail</i>T12083a
--   - typecheck<i>should_fail</i>T12083b -
--   typecheck<i>should_fail</i>T16059c -
--   typecheck<i>should_fail</i>T16059e - typecheck<i>should_fail</i>T17213
--   - typecheck<i>should_fail</i>T18939_Fail -
--   typecheck<i>should_fail</i>T2538 - typecheck<i>should_fail</i>T5957 -
--   typecheck<i>should_fail</i>T7019 - typecheck<i>should_fail</i>T7019a -
--   typecheck<i>should_fail</i>T7809 - typecheck<i>should_fail</i>T9196 -
--   typecheck<i>should_fail</i>tcfail127 -
--   typecheck<i>should_fail</i>tcfail184 -
--   typecheck<i>should_fail</i>tcfail196 -
--   typecheck<i>should_fail</i>tcfail197
[TcRnForAllRankErr] :: !Rank -> !Type -> TcRnMessage

-- | TcRnSimplifiableConstraint is a warning triggered by the occurrence of
--   a simplifiable constraint in a context, when MonoLocalBinds is not
--   enabled.
--   
--   Examples(s): simplifiableEq :: Eq (a, a) =&gt; a -&gt; a -&gt; Bool
--   simplifiableEq = undefined
--   
--   Test cases: - indexed-types<i>should_compile</i>T15322 -
--   partial-sigs<i>should_compile</i>SomethingShowable -
--   typecheck<i>should_compile</i>T13526
[TcRnSimplifiableConstraint] :: !PredType -> !InstanceWhat -> TcRnMessage

-- | TcRnArityMismatch is an error that occurs when a type constructor is
--   supplied with fewer arguments than required.
--   
--   Examples(s): f Left = undefined
--   
--   Test cases: - backpack<i>should_fail</i>bkpfail25.bkp -
--   ghci<i>should_fail</i>T16013 - ghci<i>should_fail</i>T16287 -
--   indexed-types<i>should_fail</i>BadSock -
--   indexed-types<i>should_fail</i>T9433 - module/mod60 -
--   ndexed-types<i>should_fail</i>T2157 -
--   parser<i>should_fail</i>ParserNoBinaryLiterals2 -
--   parser<i>should_fail</i>ParserNoBinaryLiterals3 -
--   patsyn<i>should_fail</i>T12819 - polykinds/T10516 -
--   typecheck<i>should_fail</i>T12124 - typecheck<i>should_fail</i>T15954
--   - typecheck<i>should_fail</i>T16874 -
--   typecheck<i>should_fail</i>tcfail100 -
--   typecheck<i>should_fail</i>tcfail101 -
--   typecheck<i>should_fail</i>tcfail107 -
--   typecheck<i>should_fail</i>tcfail129 -
--   typecheck<i>should_fail</i>tcfail187
[TcRnArityMismatch] :: !TyThing -> !Arity -> !Arity -> TcRnMessage

-- | TcRnIllegalClassInstance is a collection of diagnostics that arise
--   from an invalid class or family instance declaration.
--   
--   See <a>IllegalInstanceReason</a>.
[TcRnIllegalInstance] :: IllegalInstanceReason -> TcRnMessage

-- | TcRnMonomorphicBindings is a warning (controlled by
--   -Wmonomorphism-restriction) that arises when the monomorphism
--   restriction applies to the given bindings.
--   
--   Examples(s): {-# OPTIONS_GHC -Wmonomorphism-restriction #-}
--   
--   bar = 10
--   
--   foo :: Int foo = bar
--   
--   main :: IO () main = print foo
--   
--   The example above emits the warning (for <tt>bar</tt>), because
--   without monomorphism restriction the inferred type for <tt>bar</tt> is
--   'bar :: Num p =&gt; p'. This warning tells us that <i>if</i> we were
--   to enable '-XMonomorphismRestriction' we would make <tt>bar</tt> less
--   polymorphic, as its type would become 'bar :: Int', so GHC warns us
--   about that.
--   
--   Test cases: typecheck<i>should_compile</i>T13785
[TcRnMonomorphicBindings] :: [Name] -> TcRnMessage

-- | TcRnOrphanInstance is a warning (controlled by -Worphans) that arises
--   when a typeclass instance or family instance is an "orphan", i.e. if
--   it appears in a module in which neither the class/family nor the type
--   being instanced are declared in the same module.
--   
--   Examples(s): None
--   
--   Test cases: warnings<i>should_compile</i>T9178
--   typecheck<i>should_compile</i>T4912
[TcRnOrphanInstance] :: Either ClsInst FamInst -> TcRnMessage

-- | TcRnFunDepConflict is an error that occurs when there are functional
--   dependencies conflicts between instance declarations.
--   
--   Examples(s): None
--   
--   Test cases: typecheck<i>should_fail</i>T2307
--   typecheck<i>should_fail</i>tcfail096
--   typecheck<i>should_fail</i>tcfail202
[TcRnFunDepConflict] :: !UnitState -> NonEmpty ClsInst -> TcRnMessage

-- | TcRnDupInstanceDecls is an error that occurs when there are duplicate
--   instance declarations.
--   
--   Examples(s): class Foo a where foo :: a -&gt; Int
--   
--   instance Foo Int where foo = id
--   
--   instance Foo Int where foo = const 42
--   
--   Test cases: cabal<i>T12733</i>T12733
--   typecheck<i>should_fail</i>tcfail035
--   typecheck<i>should_fail</i>tcfail023
--   backpack<i>should_fail</i>bkpfail18
--   typecheck<i>should_fail</i>TcNullaryTCFail
--   typecheck<i>should_fail</i>tcfail036
--   typecheck<i>should_fail</i>tcfail073 module/mod51 module/mod52
--   module/mod44
[TcRnDupInstanceDecls] :: !UnitState -> NonEmpty ClsInst -> TcRnMessage

-- | TcRnConflictingFamInstDecls is an error that occurs when there are
--   conflicting family instance declarations.
--   
--   Examples(s): None.
--   
--   Test cases: indexed-types<i>should_fail</i>ExplicitForAllFams4b
--   indexed-types<i>should_fail</i>NoGood
--   indexed-types<i>should_fail</i>Over
--   indexed-types<i>should_fail</i>OverDirectThisMod
--   indexed-types<i>should_fail</i>OverIndirectThisMod
--   indexed-types<i>should_fail</i>SimpleFail11a
--   indexed-types<i>should_fail</i>SimpleFail11b
--   indexed-types<i>should_fail</i>SimpleFail11c
--   indexed-types<i>should_fail</i>SimpleFail11d
--   indexed-types<i>should_fail</i>SimpleFail2a
--   indexed-types<i>should_fail</i>SimpleFail2b
--   indexed-types<i>should_fail</i>T13092/T13092
--   indexed-types<i>should_fail</i>T13092c/T13092c
--   indexed-types<i>should_fail</i>T14179
--   indexed-types<i>should_fail</i>T2334A
--   indexed-types<i>should_fail</i>T2677
--   indexed-types<i>should_fail</i>T3330b
--   indexed-types<i>should_fail</i>T4246
--   indexed-types<i>should_fail</i>T7102a
--   indexed-types<i>should_fail</i>T9371 polykinds/T7524
--   typecheck<i>should_fail</i>UnliftedNewtypesOverlap
[TcRnConflictingFamInstDecls] :: NonEmpty FamInst -> TcRnMessage

-- | TcRnFamInstNotInjective is a collection of errors that arise from a
--   type family equation violating the injectivity annotation.
--   
--   See <a>InjectivityErrReason</a>.
[TcRnFamInstNotInjective] :: InjectivityErrReason -> TyCon -> NonEmpty CoAxBranch -> TcRnMessage

-- | TcRnBangOnUnliftedType is a warning (controlled by
--   -Wredundant-strictness-flags) that occurs when a strictness annotation
--   is applied to an unlifted type.
--   
--   Example(s): data T = MkT !Int# -- Strictness flag has no effect on
--   unlifted types
--   
--   Test cases: typecheck<i>should_compile</i>T20187a
--   typecheck<i>should_compile</i>T20187b
[TcRnBangOnUnliftedType] :: !Type -> TcRnMessage

-- | TcRnLazyBangOnUnliftedType is a warning (controlled by
--   -Wredundant-strictness-flags) that occurs when a lazy annotation is
--   applied to an unlifted type.
--   
--   Example(s): data T = MkT ~Int# -- Lazy flag has no effect on unlifted
--   types
--   
--   Test cases: typecheck<i>should_compile</i>T21951a
--   typecheck<i>should_compile</i>T21951b
[TcRnLazyBangOnUnliftedType] :: !Type -> TcRnMessage

-- | TcRnMultipleDefaultDeclarations is an error that occurs when a module
--   has more than one default declaration for the same class.
--   
--   Example: default (Integer, Int) -- implicitly applies to Num default
--   (Double, Float) -- 2nd default declaration not allowed
--   
--   Text cases: module/mod58
[TcRnMultipleDefaultDeclarations] :: TyCon -> [LDefaultDecl GhcRn] -> TcRnMessage

-- | TcRnWarnClashingDefaultImports is a warning that occurs when a module
--   imports more than one default declaration for the same class, and they
--   are not all subsumed by one of them nor by a local `default`
--   declaration.
--   
--   See Note [Named default declarations] in GHC.Tc.Gen.Default
--   
--   Test cases: default/Import07.hs
[TcRnWarnClashingDefaultImports] :: TyCon -> Maybe [Type] -> NonEmpty ClassDefaults -> TcRnMessage

-- | TcRnBadDefaultType is an error that occurs when a type used in a
--   default declaration does not have an instance for any of the
--   applicable classes.
--   
--   Example(s): data Foo default (Foo)
--   
--   Test cases: typecheck<i>should_fail</i>T11974b
[TcRnBadDefaultType] :: Type -> [TyCon] -> TcRnMessage

-- | TcRnPatSynBundledWithNonDataCon is an error that occurs when a
--   module's export list bundles a pattern synonym with a type that is not
--   a proper `data` or `newtype` construction.
--   
--   Example(s): module Foo (MyClass(.., P)) where pattern P = Nothing
--   class MyClass a where foo :: a -&gt; Int
--   
--   Test cases: patsyn<i>should_fail</i>export-class
[TcRnPatSynBundledWithNonDataCon] :: TcRnMessage

-- | TcRnPatSynBundledWithWrongType is an error that occurs when the export
--   list of a module has a pattern synonym bundled with a type that does
--   not match the type of the pattern synonym.
--   
--   Example(s): module Foo (R(P,x)) where data Q = Q Int data R = R
--   pattern P{x} = Q x
--   
--   Text cases: patsyn<i>should_fail</i>export-ps-rec-sel
--   patsyn<i>should_fail</i>export-type-synonym
--   patsyn<i>should_fail</i>export-type
[TcRnPatSynBundledWithWrongType] :: Type -> Type -> TcRnMessage

-- | TcRnDupeModuleExport is a warning controlled by
--   <tt>-Wduplicate-exports</tt> that occurs when a module appears more
--   than once in an export list.
--   
--   Example(s): module Foo (module Bar, module Bar) import Bar
--   
--   Text cases: None
[TcRnDupeModuleExport] :: ModuleName -> TcRnMessage

-- | TcRnExportedModNotImported is an error that occurs when an export list
--   contains a module that is not imported.
--   
--   Example(s): None
--   
--   Text cases: module/mod135 module/mod8
--   rename<i>should_fail</i>rnfail028 backpack<i>should_fail</i>bkpfail48
[TcRnExportedModNotImported] :: ModuleName -> TcRnMessage

-- | TcRnNullExportedModule is a warning controlled by -Wdodgy-exports that
--   occurs when an export list contains a module that has no exports.
--   
--   Example(s): module Foo (module Bar) where import Bar ()
--   
--   Test cases: None
[TcRnNullExportedModule] :: ModuleName -> TcRnMessage

-- | TcRnMissingExportList is a warning controlled by
--   -Wmissing-export-lists that occurs when a module does not have an
--   explicit export list.
--   
--   Example(s): None
--   
--   Test cases: typecheck<i>should_fail</i>MissingExportList03
[TcRnMissingExportList] :: ModuleName -> TcRnMessage

-- | TcRnExportHiddenComponents is an error that occurs when an export
--   contains constructor or class methods that are not visible.
--   
--   Example(s): None
--   
--   Test cases: None
[TcRnExportHiddenComponents] :: IE GhcPs -> TcRnMessage

-- | TcRnExportHiddenDefault is an error that occurs when an export
--   contains a class default (with language extension NamedDefaults) that
--   is not visible.
--   
--   Example(s): None
--   
--   Test cases: default/fail06.hs
[TcRnExportHiddenDefault] :: IE GhcPs -> TcRnMessage

-- | TcRnDuplicateExport is a warning (controlled by -Wduplicate-exports)
--   that occurs when an identifier appears in an export list more than
--   once.
--   
--   Example(s): None
--   
--   Test cases: module/MultiExport module/mod128 module/mod14 module/mod5
--   overloadedrecflds<i>should_fail</i>DuplicateExports
--   patsyn<i>should_compile</i>T11959
[TcRnDuplicateExport] :: GlobalRdrElt -> IE GhcPs -> IE GhcPs -> TcRnMessage

-- | TcRnExportedParentChildMismatch is an error that occurs when an export
--   is bundled with a parent that it does not belong to
--   
--   Example(s): module Foo (T(a)) where data T a = True
--   
--   Test cases: module/T11970 module/T11970B module/mod17 module/mod3
--   overloadedrecflds<i>should_fail</i>NoParent
[TcRnExportedParentChildMismatch] :: Name -> TyThing -> Name -> [Name] -> TcRnMessage

-- | TcRnConflictingExports is an error that occurs when different
--   identifiers that have the same name are being exported by a module.
--   
--   Example(s): module Foo (Bar.f, module Baz) where import qualified Bar
--   (f) import Baz (f)
--   
--   Test cases: module/mod131 module/mod142 module/mod143 module/mod144
--   module/mod145 module/mod146 module/mod150 module/mod155
--   overloadedrecflds<i>should_fail</i>T14953
--   overloadedrecflds<i>should_fail</i>overloadedrecfldsfail10
--   rename<i>should_fail</i>rnfail029 rename<i>should_fail</i>rnfail040
--   typecheck<i>should_fail</i>T16453E2
--   typecheck<i>should_fail</i>tcfail025
--   typecheck<i>should_fail</i>tcfail026
[TcRnConflictingExports] :: OccName -> GlobalRdrElt -> IE GhcPs -> GlobalRdrElt -> IE GhcPs -> TcRnMessage

-- | TcRnDuplicateFieldExport is an error that occurs when a module exports
--   multiple record fields with the same name, without enabling
--   DuplicateRecordFields.
--   
--   Example:
--   
--   module M1 where data D1 = MkD1 { foo :: Int } module M2 where data D2
--   = MkD2 { foo :: Int } module M ( D1(..), D2(..) ) where import module
--   M1 import module M2
--   
--   Test case: overloadedrecflds<i>should_fail</i>overloadedrecfldsfail10
[TcRnDuplicateFieldExport] :: (GlobalRdrElt, IE GhcPs) -> NonEmpty (GlobalRdrElt, IE GhcPs) -> TcRnMessage

-- | TcRnAmbiguousRecordUpdate is a warning, controlled by
--   -Wambiguous-fields, which occurs when a user relies on the
--   type-directed disambiguation mechanism to disambiguate a record
--   update. This will not be supported by -XDuplicateRecordFields in
--   future releases.
--   
--   Example(s):
--   
--   data Person = MkPerson { personId :: Int, name :: String } data
--   Address = MkAddress { personId :: Int, address :: String } bad1 x = x
--   { personId = 4 } :: Person -- ambiguous bad2 (x :: Person) = x {
--   personId = 4 } -- ambiguous good x = (x :: Person) { personId = 4 } --
--   not ambiguous
--   
--   Test cases: overloadedrecflds<i>should_fail</i>overloadedrecfldsfail06
[TcRnAmbiguousRecordUpdate] :: HsExpr GhcRn -> TyCon -> TcRnMessage

-- | TcRnMissingFields is a warning controlled by -Wmissing-fields
--   occurring when the intialisation of a record is missing one or more
--   (lazy) fields.
--   
--   Example(s): data Rec = Rec { a :: Int, b :: String, c :: Bool } x =
--   Rec { a = 1, b = "two" } -- missing field <tt>c</tt>
--   
--   Test cases: deSugar<i>should_compile</i>T13870
--   deSugar<i>should_compile</i>ds041 patsyn<i>should_compile</i>T11283
--   rename<i>should_compile</i>T5334 rename<i>should_compile</i>T12229
--   rename<i>should_compile</i>T5892a
--   warnings<i>should_fail</i>WerrorFail2
[TcRnMissingFields] :: ConLike -> [(FieldLabelString, TcType)] -> TcRnMessage

-- | TcRnFieldUpdateInvalidType is an error occurring when an updated
--   field's type mentions something that is outside the universally
--   quantified variables of the data constructor, such as an existentially
--   quantified type.
--   
--   Example(s): data X = forall a. MkX { f :: a } x = (MkX ()) { f = False
--   }
--   
--   Test cases: patsyn<i>should_fail</i>records-exquant
--   typecheck<i>should_fail</i>T3323
[TcRnFieldUpdateInvalidType] :: [(FieldLabelString, TcType)] -> TcRnMessage

-- | TcRnMissingStrictFields is an error occurring when a record field
--   marked as strict is omitted when constructing said record.
--   
--   Example(s): data R = R { strictField :: !Bool, nonStrict :: Int } x =
--   R { nonStrict = 1 }
--   
--   Test cases: typecheck<i>should_fail</i>T18869
--   typecheck<i>should_fail</i>tcfail085
--   typecheck<i>should_fail</i>tcfail112
[TcRnMissingStrictFields] :: ConLike -> [(FieldLabelString, TcType)] -> TcRnMessage

-- | TcRnAmbiguousFieldInUpdate is an error that occurs when a field in a
--   record update clashes with another field or top-level function of the
--   same name, and the user hasn't enabled -XDisambiguateRecordFields.
--   
--   Example:
--   
--   {-# LANGUAGE NoFieldSelectors #-} {-# LANGUAGE
--   NoDisambiguateRecordFields #-} module M where
--   
--   data A = MkA { fld :: Int }
--   
--   fld :: Bool fld = False
--   
--   f r = r { fld = 3 }
[TcRnAmbiguousFieldInUpdate] :: (GlobalRdrElt, GlobalRdrElt, [GlobalRdrElt]) -> TcRnMessage

-- | TcRnBadRecordUpdate is an error when a regular (non-overloaded) record
--   update cannot be pinned down to any one parent.
--   
--   The problem with the record update is stored in the
--   <a>BadRecordUpdateReason</a> field.
--   
--   Example(s):
--   
--   data R1 = R1 { x :: Int } data R2 = R2 { x :: Int } update r = r { x =
--   1 } -- ambiguous
--   
--   data R1 = R1 { x :: Int, y :: Int } data R2 = R2 { y :: Int, z :: Int
--   } update r = r { x = 1, y = 2, z = 3 } -- no parent has all the fields
--   
--   Test cases: overloadedrecflds<i>should_fail</i>overloadedrecfldsfail01
--   overloadedrecflds<i>should_fail</i>overloadedrecfldsfail01
--   overloadedrecflds<i>should_fail</i>overloadedrecfldsfail14
[TcRnBadRecordUpdate] :: [RdrName] -> BadRecordUpdateReason -> TcRnMessage

-- | TcRnStaticFormNotClosed is an error pertaining to terms that are
--   marked static using the -XStaticPointers extension but which are not
--   closed terms.
--   
--   Example(s): f x = static x
--   
--   Test cases: rename<i>should_fail</i>RnStaticPointersFail01
--   rename<i>should_fail</i>RnStaticPointersFail03
[TcRnStaticFormNotClosed] :: Name -> NotClosedReason -> TcRnMessage

-- | TcRnUselessTypeable is a warning (controlled by -Wderiving-typeable)
--   that occurs when trying to derive an instance of the <a>Typeable</a>
--   class. Deriving <a>Typeable</a> is no longer necessary (hence the
--   "useless") as all types automatically derive <a>Typeable</a> in modern
--   GHC versions.
--   
--   Example(s): None.
--   
--   Test cases: warnings<i>should_compile</i>DerivingTypeable
[TcRnUselessTypeable] :: TcRnMessage

-- | TcRnDerivingDefaults is a warning (controlled by -Wderiving-defaults)
--   that occurs when both <tt>DeriveAnyClass</tt> and
--   <tt>GeneralizedNewtypeDeriving</tt> are enabled, and therefore GHC
--   defaults to <tt>DeriveAnyClass</tt>, which might not be what the user
--   wants.
--   
--   Example(s): None.
--   
--   Test cases: typecheck<i>should_compile</i>T15839a
--   deriving<i>should_compile</i>T16179
[TcRnDerivingDefaults] :: !Class -> TcRnMessage

-- | TcRnNonUnaryTypeclassConstraint is an error that occurs when GHC
--   encounters a non-unary constraint when trying to derive a typeclass.
--   
--   Example(s): class A deriving instance A data B deriving A -- We cannot
--   derive A, is not unary (i.e. 'class A a').
--   
--   Test cases: deriving<i>should_fail</i>T7959
--   deriving<i>should_fail</i>drvfail005
--   deriving<i>should_fail</i>drvfail009
--   deriving<i>should_fail</i>drvfail006
[TcRnNonUnaryTypeclassConstraint] :: !UserTypeCtxt -> !LHsSigType GhcRn -> TcRnMessage

-- | TcRnPartialTypeSignatures is a warning (controlled by
--   -Wpartial-type-signatures) that occurs when a wildcard '_' is found in
--   place of a type in a signature or a type class derivation
--   
--   Example(s): foo :: _ -&gt; Int foo = ...
--   
--   deriving instance _ =&gt; Eq (Foo a)
--   
--   Test cases: dependent<i>should_compile</i>T11241
--   dependent<i>should_compile</i>T15076
--   dependent<i>should_compile</i>T14880-2
--   typecheck<i>should_compile</i>T17024
--   typecheck<i>should_compile</i>T10072
--   partial-sigs<i>should_fail</i>TidyClash2
--   partial-sigs<i>should_fail</i>Defaulting1MROff
--   partial-sigs<i>should_fail</i>WildcardsInPatternAndExprSig
--   partial-sigs<i>should_fail</i>T10615
--   partial-sigs<i>should_fail</i>T14584a
--   partial-sigs<i>should_fail</i>TidyClash
--   partial-sigs<i>should_fail</i>T11122
--   partial-sigs<i>should_fail</i>T14584
--   partial-sigs<i>should_fail</i>T10045
--   partial-sigs<i>should_fail</i>PartialTypeSignaturesDisabled
--   partial-sigs<i>should_fail</i>T10999
--   partial-sigs<i>should_fail</i>ExtraConstraintsWildcardInExpressionSignature
--   partial-sigs<i>should_fail</i>ExtraConstraintsWildcardInPatternSplice
--   partial-sigs<i>should_fail</i>WildcardInstantiations
--   partial-sigs<i>should_run</i>T15415
--   partial-sigs<i>should_compile</i>T10463
--   partial-sigs<i>should_compile</i>T15039a
--   partial-sigs<i>should_compile</i>T16728b
--   partial-sigs<i>should_compile</i>T15039c
--   partial-sigs<i>should_compile</i>T10438
--   partial-sigs<i>should_compile</i>SplicesUsed
--   partial-sigs<i>should_compile</i>T18008
--   partial-sigs<i>should_compile</i>ExprSigLocal
--   partial-sigs<i>should_compile</i>T11339a
--   partial-sigs<i>should_compile</i>T11670
--   partial-sigs<i>should_compile</i>WarningWildcardInstantiations
--   partial-sigs<i>should_compile</i>T16728
--   partial-sigs<i>should_compile</i>T12033
--   partial-sigs<i>should_compile</i>T15039b
--   partial-sigs<i>should_compile</i>T10403
--   partial-sigs<i>should_compile</i>T11192
--   partial-sigs<i>should_compile</i>T16728a
--   partial-sigs<i>should_compile</i>TypedSplice
--   partial-sigs<i>should_compile</i>T15039d
--   partial-sigs<i>should_compile</i>T11016
--   partial-sigs<i>should_compile</i>T13324_compile2
--   linear<i>should_fail</i>LinearPartialSig polykinds/T14265
--   polykinds/T14172
[TcRnPartialTypeSignatures] :: !SuggestPartialTypeSignatures -> !ThetaType -> TcRnMessage

-- | TcRnCannotDeriveInstance is an error that occurs every time a
--   typeclass instance can't be derived. The
--   <a>DeriveInstanceErrReason</a> will contain the specific reason this
--   error arose.
--   
--   Example(s): None.
--   
--   Test cases: generics<i>T10604</i>T10604_no_PolyKinds
--   deriving<i>should_fail</i>drvfail009
--   deriving<i>should_fail</i>drvfail-functor2
--   deriving<i>should_fail</i>T10598_fail3
--   deriving<i>should_fail</i>deriving-via-fail2
--   deriving<i>should_fail</i>deriving-via-fail
--   deriving<i>should_fail</i>T16181
[TcRnCannotDeriveInstance] :: !Class -> [Type] -> !Maybe (DerivStrategy GhcTc) -> !UsingGeneralizedNewtypeDeriving -> !DeriveInstanceErrReason -> TcRnMessage

-- | TcRnLazyGADTPattern is an error that occurs when a user writes a
--   nested GADT pattern match inside a lazy (~) pattern.
--   
--   Test case: gadt/lazypat
[TcRnLazyGADTPattern] :: TcRnMessage

-- | TcRnArrowProcGADTPattern is an error that occurs when a user writes a
--   GADT pattern inside arrow proc notation.
--   
--   Test case: arrows<i>should_fail</i>arrowfail004.
[TcRnArrowProcGADTPattern] :: TcRnMessage

-- | TcRnCapturedTermName is a warning (controlled by
--   -Wterm-variable-capture) that occurs when an implicitly quantified
--   type variable's name is already used for a term. Example: a = 10 f ::
--   a -&gt; a
--   
--   Test cases: T22513a T22513b T22513c T22513d T22513e T22513f T22513g
--   T22513h T22513i
[TcRnCapturedTermName] :: RdrName -> Either [GlobalRdrElt] Name -> TcRnMessage

-- | TcRnTypeEqualityOutOfScope is a warning (controlled by
--   -Wtype-equality-out-of-scope) that occurs when the type equality (a ~
--   b) is not in scope.
--   
--   Test case: warnings<i>should_compile</i>T18862b
[TcRnTypeEqualityOutOfScope] :: TcRnMessage

-- | TcRnTypeEqualityRequiresOperators is a warning (controlled by
--   -Wtype-equality-requires-operators) that occurs when the type equality
--   (a ~ b) is used without the TypeOperators extension.
--   
--   Example: {-# LANGUAGE NoTypeOperators #-} f :: (a ~ b) =&gt; a -&gt; b
--   
--   Test case: T18862a
[TcRnTypeEqualityRequiresOperators] :: TcRnMessage

-- | TcRnIllegalTypeOperator is an error that occurs when a type operator
--   is used without the TypeOperators extension.
--   
--   Example: {-# LANGUAGE NoTypeOperators #-} f :: Vec a n -&gt; Vec a m
--   -&gt; Vec a (n + m)
--   
--   Test case: T12811
[TcRnIllegalTypeOperator] :: !SDoc -> !RdrName -> TcRnMessage

-- | TcRnIllegalTypeOperatorDecl is an error that occurs when a type or
--   class operator is declared without the TypeOperators extension.
--   
--   See Note [Type and class operator definitions]
--   
--   Example: {-# LANGUAGE Haskell2010 #-} {-# LANGUAGE
--   MultiParamTypeClasses #-}
--   
--   module T3265 where
--   
--   data a :+: b = Left a | Right b
--   
--   class a :*: b where {}
--   
--   Test cases: T3265, tcfail173
[TcRnIllegalTypeOperatorDecl] :: !RdrName -> TcRnMessage

-- | TcRnGADTMonoLocalBinds is a warning controlled by
--   -Wgadt-mono-local-binds that occurs when pattern matching on a GADT
--   when -XMonoLocalBinds is off.
--   
--   Example(s): None
--   
--   Test cases: T20485, T20485a
[TcRnGADTMonoLocalBinds] :: TcRnMessage

-- | The TcRnNotInScope constructor is used for various not-in-scope
--   errors. See <a>NotInScopeError</a> for more details.
[TcRnNotInScope] :: NotInScopeError -> RdrName -> [ImportError] -> [GhcHint] -> TcRnMessage

-- | TcRnTermNameInType is an error that occurs when a term-level
--   identifier is used in a type.
--   
--   Example:
--   
--   import qualified Prelude
--   
--   bad :: Prelude.fst (Bool, Float) bad = False
--   
--   Test cases: T21605{c,d}
[TcRnTermNameInType] :: RdrName -> [GhcHint] -> TcRnMessage

-- | TcRnUntickedPromotedThing is a warning (controlled with
--   -Wunticked-promoted-constructors) that is triggered by an unticked
--   occurrence of a promoted data constructor.
--   
--   Examples:
--   
--   data A = MkA type family F (a :: A) where { F MkA = Bool }
--   
--   type B = [ Int, Bool ]
--   
--   Test cases: T9778, T19984.
[TcRnUntickedPromotedThing] :: UntickedPromotedThing -> TcRnMessage

-- | TcRnIllegalBuiltinSyntax is an error that occurs when built-in syntax
--   appears in an unexpected location, e.g. as a data constructor or in a
--   fixity declaration.
--   
--   Examples:
--   
--   infixl 5 :
--   
--   data P = (,)
--   
--   Test cases: rnfail042, T14907b, T15124, T15233.
[TcRnIllegalBuiltinSyntax] :: SDoc -> RdrName -> TcRnMessage

-- | TcRnWarnDefaulting is a warning (controlled by -Wtype-defaults) that
--   is triggered whenever a Wanted typeclass constraint is solving through
--   the defaulting of a type variable.
--   
--   Example:
--   
--   one = show 1 -- We get Wanteds Show a0, Num a0, and default a0 to
--   Integer.
--   
--   Test cases: none (which are really specific to defaulting), but see
--   e.g. tcfail204.
[TcRnWarnDefaulting] :: [Ct] -> Maybe TyVar -> Type -> TcRnMessage

-- | TcRnIncorrectNameSpace is an error that occurs when a <a>Name</a> is
--   used in the incorrect <tt>NameSpace</tt>, e.g. a type constructor or
--   class used in a term, or a term variable used in a type.
--   
--   Example:
--   
--   list2 = $( conE ''(:) <tt>appE</tt> litE (IntegerL 5) <tt>appE</tt>
--   conE '[] ) -- ^^^^^ -- should use a single quotation tick, i.e. '(:)
--   
--   Test cases: T20884.
[TcRnIncorrectNameSpace] :: Name -> Bool -> TcRnMessage

-- | TcRnForeignImportPrimExtNotSet is an error occurring when a foreign
--   import is declared using the <tt>prim</tt> calling convention without
--   having turned on the -XGHCForeignImportPrim extension.
--   
--   Example(s): foreign import prim "foo" foo :: ByteArray# -&gt; (# Int#,
--   Int# #)
--   
--   Test cases: ffi<i>should_fail</i>T20116
[TcRnForeignImportPrimExtNotSet] :: ForeignImport GhcRn -> TcRnMessage

-- | TcRnForeignImportPrimSafeAnn is an error declaring that the
--   safe/unsafe annotation should not be used with <tt>prim</tt> foreign
--   imports.
--   
--   Example(s): foreign import prim unsafe "my_primop_cmm" :: ...
--   
--   Test cases: None
[TcRnForeignImportPrimSafeAnn] :: ForeignImport GhcRn -> TcRnMessage

-- | TcRnForeignFunctionImportAsValue is an error explaining that foreign
--   <tt>value</tt> imports cannot have function types.
--   
--   Example(s): foreign import capi "math.h value sqrt" f :: CInt -&gt;
--   CInt
--   
--   Test cases: ffi<i>should_fail</i>capi_value_function
[TcRnForeignFunctionImportAsValue] :: ForeignImport GhcRn -> TcRnMessage

-- | TcRnFunPtrImportWithoutAmpersand is a warning controlled by
--   <tt>-Wdodgy-foreign-imports</tt> that informs the user of a possible
--   missing <tt>&amp;</tt> in the declaration of a foreign import with a
--   <tt>FunPtr</tt> return type.
--   
--   Example(s): foreign import ccall "f" f :: FunPtr (Int -&gt; IO ())
--   
--   Test cases: ffi<i>should_compile</i>T1357
[TcRnFunPtrImportWithoutAmpersand] :: ForeignImport GhcRn -> TcRnMessage

-- | TcRnIllegalForeignDeclBackend is an error occurring when a foreign
--   import declaration is not compatible with the code generation backend
--   being used.
--   
--   Example(s): None
--   
--   Test cases: None
[TcRnIllegalForeignDeclBackend] :: Either (ForeignExport GhcRn) (ForeignImport GhcRn) -> Backend -> ExpectedBackends -> TcRnMessage

-- | TcRnUnsupportedCallConv informs the user that the calling convention
--   specified for a foreign export declaration is not compatible with the
--   target platform. It is a warning controlled by
--   <tt>-Wunsupported-calling-conventions</tt> in the case of
--   <tt>stdcall</tt> but is otherwise considered an error.
--   
--   Example(s): None
--   
--   Test cases: None
[TcRnUnsupportedCallConv] :: Either (ForeignExport GhcRn) (ForeignImport GhcRn) -> UnsupportedCallConvention -> TcRnMessage

-- | TcRnIllegalForeignType is an error for when a type appears in a
--   foreign function signature that is not compatible with the FFI.
--   
--   Example(s): None
--   
--   Test cases: ffi<i>should_fail</i>T3066 ffi<i>should_fail</i>ccfail004
--   ffi<i>should_fail</i>T10461 ffi<i>should_fail</i>T7506
--   ffi<i>should_fail</i>T5664 safeHaskell<i>ghci</i>p6
--   safeHaskell<i>safeLanguage</i>SafeLang08 ffi<i>should_fail</i>T16702
--   linear<i>should_fail</i>LinearFFI ffi<i>should_fail</i>T7243
[TcRnIllegalForeignType] :: !Maybe ArgOrResult -> !IllegalForeignTypeReason -> TcRnMessage

-- | TcRnInvalidCIdentifier indicates a C identifier that is not valid.
--   
--   Example(s): foreign import prim safe "not valid" cmm_test2 :: Int#
--   -&gt; Int#
--   
--   Test cases: th/T10638
[TcRnInvalidCIdentifier] :: !CLabelString -> TcRnMessage

-- | TcRnExpectedValueId is an error occurring when something that is not a
--   value identifier is used where one is expected.
--   
--   Example(s): none
--   
--   Test cases: none
[TcRnExpectedValueId] :: !TcTyThing -> TcRnMessage

-- | TcRnRecSelectorEscapedTyVar is an error indicating that a record field
--   selector containing an existential type variable is used as a function
--   rather than in a pattern match.
--   
--   Example(s): data Rec = forall a. Rec { field :: a } field (Rec True)
--   
--   Test cases: patsyn<i>should_fail</i>records-exquant
--   typecheck<i>should_fail</i>T3176
[TcRnRecSelectorEscapedTyVar] :: !OccName -> TcRnMessage

-- | TcRnPatSynNotBidirectional is an error for when a non-bidirectional
--   pattern synonym is used as a constructor.
--   
--   Example(s): pattern Five :: Int pattern Five &lt;- 5 five = Five
--   
--   Test cases: patsyn<i>should_fail</i>records-no-uni-update
--   patsyn<i>should_fail</i>records-no-uni-update2
[TcRnPatSynNotBidirectional] :: !Name -> TcRnMessage

-- | TcRnIllegalDerivingItem is an error for when something other than a
--   type class appears in a deriving statement.
--   
--   Example(s): data X = X deriving Int
--   
--   Test cases: deriving<i>should_fail</i>T5922
[TcRnIllegalDerivingItem] :: !LHsSigType GhcRn -> TcRnMessage

-- | TcRnIllegalDefaultClass is an error for when something other than a
--   type class appears in a default declaration after the keyword.
--   
--   Example(s): default Integer (Int)
--   
--   Test cases: default/fail01
[TcRnIllegalDefaultClass] :: !LHsSigType GhcRn -> TcRnMessage

-- | TcRnIllegalNamedDefault is an error for specifying an explicit default
--   class name without <tt>-XNamedDefaults</tt>.
--   
--   Example(s): default Num (Integer)
--   
--   Test cases: default/fail02
[TcRnIllegalNamedDefault] :: !LDefaultDecl GhcRn -> TcRnMessage

-- | TcRnUnexpectedAnnotation indicates the erroroneous use of an
--   annotation such as strictness, laziness, or unpacking.
--   
--   Example(s): data T = T { t :: Maybe {-# UNPACK #-} Int } data C = C {
--   f :: !IntMap Int }
--   
--   Test cases: parser<i>should_fail</i>unpack_inside_type
--   typecheck<i>should_fail</i>T7210 rename<i>should_fail</i>T22478b
[TcRnUnexpectedAnnotation] :: !HsType GhcRn -> !HsBang -> TcRnMessage

-- | TcRnIllegalRecordSyntax is an error indicating an illegal use of
--   record syntax.
--   
--   Example(s): data T = T Int { field :: Int }
--   
--   Test cases: rename<i>should_fail</i>T7943
--   rename<i>should_fail</i>T9077 rename<i>should_fail</i>T22478b
[TcRnIllegalRecordSyntax] :: Either (HsType GhcPs) (HsType GhcRn) -> TcRnMessage

-- | TcRnInvalidVisibleKindArgument is an error for a kind application on a
--   target type that cannot accept it.
--   
--   Example(s): bad :: Int <tt>Type bad = 1 type Foo :: forall a {b}. a
--   -&gt; b -&gt; b type Foo x y = y type Bar = Foo </tt>Bool @Int True 42
--   
--   Test cases: indexed-types<i>should_fail</i>T16356_Fail3
--   typecheck<i>should_fail</i>ExplicitSpecificity7
--   typecheck<i>should_fail</i>T12045b typecheck<i>should_fail</i>T12045c
--   typecheck<i>should_fail</i>T15592a typecheck<i>should_fail</i>T15816
[TcRnInvalidVisibleKindArgument] :: !LHsType GhcRn -> !Type -> TcRnMessage

-- | TcRnTooManyBinders is an error for a type constructor that is declared
--   with more arguments then its kind specifies.
--   
--   Example(s): type T :: Type -&gt; (Type -&gt; Type) -&gt; Type data T a
--   (b :: Type -&gt; Type) x1 (x2 :: Type -&gt; Type)
--   
--   Test cases: saks<i>should_fail</i>saks_fail008
[TcRnTooManyBinders] :: !Kind -> ![LHsTyVarBndr (HsBndrVis GhcRn) GhcRn] -> TcRnMessage

-- | TcRnDifferentNamesForTyVar is an error that indicates different names
--   being used for the same type variable.
--   
--   Example(s): data SameKind :: k -&gt; k -&gt; * data Q (a :: k1) (b ::
--   k2) c = MkQ (SameKind a b)
--   
--   Test cases: polykinds/T11203 polykinds/T11821a
--   saks<i>should_fail</i>T20916 typecheck<i>should_fail</i>T17566b
--   typecheck<i>should_fail</i>T17566c
[TcRnDifferentNamesForTyVar] :: !Name -> !Name -> TcRnMessage

-- | TcRnDisconnectedTyVar is an error for a data declaration that has a
--   kind signature, where the implicitly-bound type type variables can't
--   be matched up unambiguously with the ones from the signature. See Note
--   [Disconnected type variables] in GHC.Tc.Gen.HsType.
--   
--   Test cases: T24083
[TcRnDisconnectedTyVar] :: !Name -> TcRnMessage

-- | TcRnInvalidReturnKind is an error for a data declaration that has a
--   kind signature with an invalid result kind.
--   
--   Example(s): data family Foo :: Constraint
--   
--   Test cases: typecheck<i>should_fail</i>T14048b
--   typecheck<i>should_fail</i>UnliftedNewtypesConstraintFamily
--   typecheck<i>should_fail</i>T12729 typecheck<i>should_fail</i>T15883
--   typecheck<i>should_fail</i>T16829a typecheck<i>should_fail</i>T16829b
--   typecheck<i>should_fail</i>UnliftedNewtypesNotEnabled
--   typecheck<i>should_fail</i>tcfail079
[TcRnInvalidReturnKind] :: !DataSort -> !AllowedDataResKind -> !Kind -> !Maybe SuggestUnliftedTypes -> TcRnMessage

-- | TcRnUnexpectedKindVar is an error that occurs when the user tries to
--   use kind variables without -XPolyKinds.
--   
--   Example: f :: forall k a. Proxy (a :: k)
--   
--   Test cases: polykinds/BadKindVar polykinds/T14710
--   saks<i>should_fail</i>T16722
[TcRnUnexpectedKindVar] :: RdrName -> TcRnMessage

-- | TcRnIllegalKind is used for a various illegal kinds errors including
--   
--   Example: type T :: forall k. Type -- without emabled -XPolyKinds
--   
--   Test cases: polykinds/T16762b
[TcRnIllegalKind] :: HsTypeOrSigType GhcPs -> Bool -> TcRnMessage

-- | TcRnClassKindNotConstraint is an error for a type class that has a
--   kind that is not equivalent to Constraint.
--   
--   Example(s): type C :: Type -&gt; Type class C a
--   
--   Test cases: saks<i>should_fail</i>T16826
[TcRnClassKindNotConstraint] :: !Kind -> TcRnMessage

-- | TcRnUnpromotableThing is an error that occurs when the user attempts
--   to use the promoted version of something which is not promotable.
--   
--   Example(s): data T :: T -&gt; * data X a where MkX :: Show a =&gt; a
--   -&gt; X a foo :: Proxy ('MkX 'True) foo = Proxy
--   
--   Test cases: dependent<i>should_fail</i>PromotedClass
--   dependent<i>should_fail</i>T14845_fail1
--   dependent<i>should_fail</i>T14845_fail2
--   dependent<i>should_fail</i>T15215 dependent<i>should_fail</i>T13780c
--   dependent<i>should_fail</i>T15245 polykinds/T5716 polykinds/T5716a
--   polykinds/T6129 polykinds/T7433 patsyn<i>should_fail</i>T11265
--   patsyn<i>should_fail</i>T9161-1 patsyn<i>should_fail</i>T9161-2
--   dependent<i>should_fail</i>SelfDep polykinds/PolyKinds06
--   polykinds/PolyKinds07 polykinds/T13625 polykinds/T15116
--   polykinds/T15116a saks<i>should_fail</i>T16727a
--   saks<i>should_fail</i>T16727b rename<i>should_fail</i>T12686
--   rename<i>should_fail</i>T16635a rename<i>should_fail</i>T16635b
--   rename<i>should_fail</i>T16635c
[TcRnUnpromotableThing] :: !Name -> !PromotionErr -> TcRnMessage

-- | TcRnIllegalTermLevelUse is an error that occurs when the user attempts
--   to use a type-level entity at the term-level.
--   
--   Examples: f x = Int -- illegal use of a type constructor g (Proxy ::
--   Proxy a) = a -- illegal use of a type variable
--   
--   Note that the namespace cannot be used to determine if a name refers
--   to a type-level entity:
--   
--   {-# LANGUAGE RequiredTypeArguments #-} bad :: forall (a :: k) -&gt; k
--   bad t = t
--   
--   The name <tt>t</tt> is assigned the <tt>varName</tt> namespace but
--   stands for a type variable that cannot be used at the term level.
--   
--   Test cases: T18740a, T18740b, T23739_fail_ret, T23739_fail_case
[TcRnIllegalTermLevelUse] :: !Name -> !TermLevelUseErr -> TcRnMessage

-- | TcRnMatchesHaveDiffNumArgs is an error occurring when something has
--   matches that have different numbers of arguments
--   
--   Example(s): foo x = True foo x y = False
--   
--   Test cases: rename<i>should_fail</i>rnfail045
--   typecheck<i>should_fail</i>T20768_fail
[TcRnMatchesHaveDiffNumArgs] :: !HsMatchContextRn -> !MatchArgBadMatches -> TcRnMessage

-- | TcRnUnexpectedPatSigType is an error occurring when there is a type
--   signature in a pattern without -XScopedTypeVariables extension
--   
--   Examples: f (a :: Bool) = ...
--   
--   Test case: rename<i>should_fail</i>T11663
[TcRnUnexpectedPatSigType] :: HsPatSigType GhcPs -> TcRnMessage

-- | TcRnIllegalKindSignature is an error occurring when there is a kind
--   signature without -XKindSignatures extension
--   
--   Examples: data Foo (a :: Nat) = ....
--   
--   Test case: parser<i>should_fail</i>readFail036
[TcRnIllegalKindSignature] :: HsType GhcPs -> TcRnMessage

-- | TcRnDataKindsError is an error occurring when there is an illegal type
--   or kind, probably required -XDataKinds and is used without the enabled
--   extension.
--   
--   This error can occur in both the renamer and the typechecker. The
--   field of type <tt><a>Either</a> (<a>HsType</a> <a>GhcPs</a>)
--   <a>Type</a></tt> reflects this: this field will contain a <a>Left</a>
--   value if the error occurred in the renamer, and this field will
--   contain a <a>Right</a> value if the error occurred in the typechecker.
--   
--   Examples:
--   
--   type Foo = [Nat, Char]
--   
--   type Bar = [Int, String]
--   
--   Test cases: linear<i>should_fail</i>T18888
--   parser<i>should_fail</i>readFail001 polykinds/T7151 polykinds/T7433
--   rename<i>should_fail</i>T13568 rename<i>should_fail</i>T22478e
--   th/TH_Promoted1Tuple typecheck<i>should_compile</i>tcfail094
--   typecheck<i>should_compile</i>T22141a
--   typecheck<i>should_compile</i>T22141b
--   typecheck<i>should_compile</i>T22141c
--   typecheck<i>should_compile</i>T22141d
--   typecheck<i>should_compile</i>T22141e
--   typecheck<i>should_compile</i>T22141f
--   typecheck<i>should_compile</i>T22141g
--   typecheck<i>should_fail</i>T20873c typecheck<i>should_fail</i>T20873d
[TcRnDataKindsError] :: TypeOrKind -> Either (HsType GhcPs) Type -> TcRnMessage

-- | TcRnCannotBindScopedTyVarInPatSig is an error stating that scoped type
--   variables cannot be used in pattern bindings.
--   
--   Example(s): let (x :: a) = 5
--   
--   Test cases: typecheck<i>should_compile</i>tc141
[TcRnCannotBindScopedTyVarInPatSig] :: !NonEmpty (Name, TcTyVar) -> TcRnMessage

-- | TcRnCannotBindTyVarsInPatBind is an error for when type variables are
--   introduced in a pattern binding
--   
--   Example(s): Just @a x = Just True
--   
--   Test cases: typecheck<i>should_fail</i>TyAppPat_PatternBinding
--   typecheck<i>should_fail</i>TyAppPat_PatternBindingExistential
[TcRnCannotBindTyVarsInPatBind] :: !NonEmpty (Name, TcTyVar) -> TcRnMessage

-- | TcRnTooManyTyArgsInConPattern is an error occurring when a constructor
--   pattern has more than the expected number of type arguments
--   
--   Example(s): f (Just <tt>Int </tt>Bool x) = x
--   
--   Test cases: typecheck<i>should_fail</i>TyAppPat_TooMany
--   typecheck<i>should_fail</i>T20443b
[TcRnTooManyTyArgsInConPattern] :: !ConLike -> !Int -> !Int -> TcRnMessage

-- | TcRnMultipleInlinePragmas is a warning signifying that multiple inline
--   pragmas reference the same definition.
--   
--   Example(s): {-# INLINE foo #-} {-# INLINE foo #-} foo :: Bool -&gt;
--   Bool foo = id
--   
--   Test cases: none
[TcRnMultipleInlinePragmas] :: !Id -> !LocatedA InlinePragma -> !NonEmpty (LocatedA InlinePragma) -> TcRnMessage

-- | TcRnUnexpectedPragmas is a warning that occurs when unexpected pragmas
--   appear in the source.
--   
--   Example(s):
--   
--   Test cases: none
[TcRnUnexpectedPragmas] :: !Id -> !NonEmpty (LSig GhcRn) -> TcRnMessage

-- | TcRnNonOverloadedSpecialisePragma is a warning for a specialise pragma
--   being placed on a definition that is not overloaded.
--   
--   Example(s): {-# SPECIALISE foo :: Bool -&gt; Bool #-} foo :: Bool
--   -&gt; Bool foo = id
--   
--   Test cases: simplCore<i>should_compile</i>T8537
--   typecheck<i>should_compile</i>T10504
[TcRnNonOverloadedSpecialisePragma] :: !LIdP GhcRn -> TcRnMessage

-- | TcRnSpecialiseNotVisible is a warning that occurs when the subject of
--   a SPECIALISE pragma has a definition that is not visible from the
--   current module.
--   
--   Example(s): none
--   
--   Test cases: none
[TcRnSpecialiseNotVisible] :: !Name -> TcRnMessage

-- | TcRnPragmaWarning is a warning that can happen when usage of something
--   is warned or deprecated by pragma.
--   
--   Test cases: DeprU T5281 T5867 rn050 rn066 (here is a warning, not
--   deprecation) T3303 ExportWarnings1 ExportWarnings2 ExportWarnings3
--   ExportWarnings4 ExportWarnings5 ExportWarnings6 InstanceWarnings
[TcRnPragmaWarning] :: PragmaWarningInfo -> WarningTxt GhcRn -> TcRnMessage

-- | TcRnDifferentExportWarnings is an error that occurs when the warning
--   messages for exports of a name differ between several export items.
--   
--   Test case: DifferentExportWarnings
[TcRnDifferentExportWarnings] :: !Name -> NonEmpty SrcSpan -> TcRnMessage

-- | TcRnIncompleteExportWarnings is a warning (controlled by
--   -Wincomplete-export-warnings) that occurs when some of the exports of
--   a name do not have an export warning and some do
--   
--   Test case: ExportWarnings6
[TcRnIncompleteExportWarnings] :: !Name -> NonEmpty SrcSpan -> TcRnMessage

-- | TcRnIllegalHsigDefaultMethods is an error that occurs when a binding
--   for a class default method is provided in a Backpack signature file.
--   
--   Test case: bkpfail40
[TcRnIllegalHsigDefaultMethods] :: !Name -> NonEmpty (LHsBind GhcRn) -> TcRnMessage

-- | TcRnHsigFixityMismatch is an error indicating that the fixity decl in
--   a Backpack signature file differs from the one in the source file for
--   the same operator.
--   
--   Test cases: bkpfail37, bkpfail38
[TcRnHsigFixityMismatch] :: !TyThing -> !Fixity -> !Fixity -> TcRnMessage

-- | TcRnHsigShapeMismatch is a group of errors related to mismatches
--   between backpack signatures.
[TcRnHsigShapeMismatch] :: !HsigShapeMismatchReason -> TcRnMessage

-- | TcRnHsigMissingModuleExport is an error indicating that a module
--   doesn't export a name exported by its signature.
--   
--   Test cases: bkpfail01, bkpfail05, bkpfail09, bkpfail16, bkpfail35,
--   bkpcabal06
[TcRnHsigMissingModuleExport] :: !OccName -> !UnitState -> !Module -> TcRnMessage

-- | TcRnBadGenericMethod This test ensures that if you provide a "more
--   specific" type signatures for the default method, you must also
--   provide a binding.
--   
--   Example: {-# LANGUAGE DefaultSignatures #-}
--   
--   class C a where meth :: a default meth :: Num a =&gt; a meth = 0
--   
--   Test case: typecheck<i>should_fail</i>MissingDefaultMethodBinding.hs
[TcRnBadGenericMethod] :: !Name -> !Name -> TcRnMessage

-- | TcRnWarningMinimalDefIncomplete is a warning that one must specify
--   which methods must be implemented by all instances.
--   
--   Example: class Cheater a where -- WARNING LINE cheater :: a {-#
--   MINIMAL #-} -- warning!
--   
--   Test case: warnings<i>minimal</i>WarnMinimal.hs:
[TcRnWarningMinimalDefIncomplete] :: ClassMinimalDef -> TcRnMessage

-- | TcRnIllegalQuasiQuotes is an error that occurs when a quasi-quote is
--   used without the QuasiQuotes extension.
--   
--   Example:
--   
--   foo = [myQuoter|x y z|]
--   
--   Test cases: none; the parser fails to parse this if QuasiQuotes is
--   off.
[TcRnIllegalQuasiQuotes] :: TcRnMessage

-- | TcRnTHError is a family of errors involving Template Haskell. See
--   <a>THError</a>.
[TcRnTHError] :: THError -> TcRnMessage

-- | TcRnDefaultMethodForPragmaLacksBinding is an error that occurs when a
--   default method pragma is missing an accompanying binding.
--   
--   Test cases: typecheck<i>should_fail</i>T5084.hs
--   typecheck<i>should_fail</i>T2354.hs
[TcRnDefaultMethodForPragmaLacksBinding] :: Id -> Sig GhcRn -> TcRnMessage

-- | TcRnIgnoreSpecialisePragmaOnDefMethod is a warning that occurs when a
--   specialise pragma is put on a default method.
--   
--   Test cases: none
[TcRnIgnoreSpecialisePragmaOnDefMethod] :: !Name -> TcRnMessage

-- | TcRnBadMethodErr is an error that happens when one attempts to provide
--   a method in a class instance, when the class doesn't have a method by
--   that name.
--   
--   Test case: th/T12387
[TcRnBadMethodErr] :: !Name -> !Name -> TcRnMessage

-- | TcRnIllegalNewtype is an error that occurs when a newtype:
--   
--   <ul>
--   <li>Does not have exactly one field, or</li>
--   <li>is non-linear, or</li>
--   <li>is a GADT, or</li>
--   <li>has a context in its constructor's type, or</li>
--   <li>has existential type variables in its constructor's type, or</li>
--   <li>has strictness annotations.</li>
--   </ul>
--   
--   Test cases: gadt/T14719 indexed-types<i>should_fail</i>T14033
--   indexed-types<i>should_fail</i>T2334A
--   linear<i>should_fail</i>LinearGADTNewtype
--   parser<i>should_fail</i>readFail008 polykinds/T11459
--   typecheck<i>should_fail</i>T15523 typecheck<i>should_fail</i>T15796
--   typecheck<i>should_fail</i>T17955 typecheck<i>should_fail</i>T18891a
--   typecheck<i>should_fail</i>T21447 typecheck<i>should_fail</i>tcfail156
[TcRnIllegalNewtype] :: DataCon -> Bool -> IllegalNewtypeReason -> TcRnMessage

-- | TcRnIllegalTypeData is an error that occurs when a <tt>type data</tt>
--   declaration occurs without the TypeOperators extension.
--   
--   See Note [Type data declarations]
--   
--   Test case: type-data<i>should_fail</i>TDNoPragma
[TcRnIllegalTypeData] :: TcRnMessage

-- | TcRnTypeDataForbids is an error that occurs when a <tt>type data</tt>
--   declaration contains <tt>data</tt> declaration features that are
--   forbidden in a <tt>type data</tt> declaration.
--   
--   See Note [Type data declarations]
--   
--   Test cases: type-data<i>should_fail</i>TDDeriving
--   type-data<i>should_fail</i>TDRecordsGADT
--   type-data<i>should_fail</i>TDRecordsH98
--   type-data<i>should_fail</i>TDStrictnessGADT
--   type-data<i>should_fail</i>TDStrictnessH98
[TcRnTypeDataForbids] :: !TypeDataForbids -> TcRnMessage

-- | TcRnOrPatBindsVariables is an error that happens when an or-pattern
--   binds term or type variables, e.g. (A @x; B y).
--   
--   Test case: testsuite<i>tests</i>typecheck<i>should_fail</i>Or3
[TcRnOrPatBindsVariables] :: NonEmpty (IdP GhcRn) -> TcRnMessage

-- | TcRnUnsatisfiedMinimalDef is a warning that occurs when a class
--   instance is missing methods that are required by the minimal
--   definition.
--   
--   Example: class C a where foo :: a -&gt; a instance C () -- | foo needs
--   to be defined here
--   
--   Test cases: typecheck<i>prog001</i>typecheck.prog001
--   typecheck<i>should_compile</i>tc126
--   typecheck<i>should_compile</i>T7903
--   typecheck<i>should_compile</i>tc116
--   typecheck<i>should_compile</i>tc175
--   typecheck<i>should_compile</i>HasKey
--   typecheck<i>should_compile</i>tc125
--   typecheck<i>should_compile</i>tc078
--   typecheck<i>should_compile</i>tc161 typecheck<i>should_fail</i>T5051
--   typecheck<i>should_compile</i>T21583
--   backpack<i>should_compile</i>bkp47 backpack<i>should_fail</i>bkpfail25
--   parser<i>should_compile</i>T2245 parser<i>should_compile</i>read014
--   indexed-types<i>should_compile</i>Class3
--   indexed-types<i>should_compile</i>Simple2
--   indexed-types<i>should_fail</i>T7862
--   deriving<i>should_compile</i>deriving-1935
--   deriving<i>should_compile</i>T9968a
--   deriving<i>should_compile</i>drv003 deriving<i>should_compile</i>T4966
--   deriving<i>should_compile</i>T14094 perf<i>compiler</i>T15304
--   warnings<i>minimal</i>WarnMinimal
--   simplCore<i>should_compile</i>simpl020
--   deSugar<i>should_compile</i>T14546d ghci<i>scripts</i>T5820
--   ghci<i>scripts</i>ghci019
[TcRnUnsatisfiedMinimalDef] :: ClassMinimalDef -> TcRnMessage

-- | <a>TcRnMisplacedInstSig</a> is an error that happens when a method in
--   a class instance is given a type signature, but the user has not
--   enabled the <tt>InstanceSigs</tt> extension.
--   
--   Test case: module/mod45
[TcRnMisplacedInstSig] :: Name -> LHsSigType GhcRn -> TcRnMessage

-- | TcRnNoRebindableSyntaxRecordDot is an error triggered by an overloaded
--   record update without RebindableSyntax enabled.
--   
--   Example(s):
--   
--   Test cases: parser<i>should_fail</i>RecordDotSyntaxFail5
[TcRnNoRebindableSyntaxRecordDot] :: TcRnMessage

-- | TcRnNoFieldPunsRecordDot is an error triggered by the use of record
--   field puns in an overloaded record update without enabling
--   NamedFieldPuns.
--   
--   Example(s): print $ a{ foo.bar.baz.quux }
--   
--   Test cases: parser<i>should_fail</i>RecordDotSyntaxFail12
[TcRnNoFieldPunsRecordDot] :: TcRnMessage

-- | TcRnIllegalStaticExpression is an error thrown when user creates a
--   static pointer via TemplateHaskell without enabling the StaticPointers
--   extension.
--   
--   Example(s):
--   
--   Test cases: th/T14204
[TcRnIllegalStaticExpression] :: HsExpr GhcPs -> TcRnMessage

-- | TcRnListComprehensionDuplicateBinding is an error triggered by
--   duplicate let-bindings in a list comprehension.
--   
--   Example(s): [ () | let a = 13 | let a = 17 ]
--   
--   Test cases: typecheck<i>should_fail</i>tcfail092
[TcRnListComprehensionDuplicateBinding] :: Name -> TcRnMessage

-- | TcRnEmptyStmtsGroup is an error triggered by an empty list of
--   statements in a statement block. For more information, see
--   <a>EmptyStatementGroupErrReason</a>
--   
--   Example(s):
--   
--   <ul>
--   <li><i>() | then ()</i></li>
--   </ul>
--   
--   do
--   
--   proc () -&gt; do
--   
--   Test cases: rename<i>should_fail</i>RnEmptyStatementGroup1
[TcRnEmptyStmtsGroup] :: EmptyStatementGroupErrReason -> TcRnMessage

-- | TcRnLastStmtNotExpr is an error caused by the last statement in a
--   statement block not being an expression.
--   
--   Example(s):
--   
--   do x &lt;- pure ()
--   
--   do let x = 5
--   
--   Test cases: rename<i>should_fail</i>T6060
--   parser<i>should_fail</i>T3811g parser<i>should_fail</i>readFail028
[TcRnLastStmtNotExpr] :: HsStmtContextRn -> UnexpectedStatement -> TcRnMessage

-- | TcRnUnexpectedStatementInContext is an error when a statement appears
--   in an unexpected context (e.g. an arrow statement appears in a list
--   comprehension).
--   
--   Example(s):
--   
--   Test cases: parser<i>should_fail</i>readFail042
--   parser<i>should_fail</i>readFail038
--   parser<i>should_fail</i>readFail043
[TcRnUnexpectedStatementInContext] :: HsStmtContextRn -> UnexpectedStatement -> Maybe Extension -> TcRnMessage

-- | TcRnIllegalTupleSection is an error triggered by usage of a tuple
--   section without enabling the TupleSections extension.
--   
--   Example(s): (5,)
--   
--   Test cases: rename<i>should_fail</i>rnfail056
[TcRnIllegalTupleSection] :: TcRnMessage

-- | TcRnIllegalImplicitParameterBindings is an error triggered by binding
--   an implicit parameter in an mdo block.
--   
--   Example(s): mdo { let { ?x = 5 }; () }
--   
--   Test cases: rename<i>should_fail</i>RnImplicitBindInMdoNotation
[TcRnIllegalImplicitParameterBindings] :: Either (HsLocalBindsLR GhcPs GhcPs) (HsLocalBindsLR GhcRn GhcPs) -> TcRnMessage

-- | TcRnSectionWithoutParentheses is an error triggered by attempting to
--   use an operator section without parentheses.
--   
--   Example(s): (<a>head</a> x, ())
--   
--   Test cases: rename<i>should_fail</i>T2490
--   rename<i>should_fail</i>T5657
[TcRnSectionWithoutParentheses] :: HsExpr GhcPs -> TcRnMessage

-- | TcRnBindingOfExistingName is an error triggered by an attempt to
--   rebind built-in syntax, punned list or tuple syntax, or a name quoted
--   via Template Haskell.
--   
--   Examples:
--   
--   data [] data (-&gt;) $(pure [ValD (VarP 'succ) (NormalB (ConE 'True))
--   []])
--   
--   Test cases: rename<i>should_fail</i>T14907b
--   rename<i>should_fail</i>T22839 rename<i>should_fail</i>rnfail042
--   th/T13968
[TcRnBindingOfExistingName] :: RdrName -> TcRnMessage

-- | TcRnMultipleFixityDecls is an error triggered by multiple fixity
--   declarations for the same operator.
--   
--   Example(s):
--   
--   infixr 6 $$ infixl 4 $$
--   
--   Test cases: rename<i>should_fail</i>RnMultipleFixityFail
[TcRnMultipleFixityDecls] :: SrcSpan -> RdrName -> TcRnMessage

-- | TcRnIllegalPatternSynonymDecl is an error thrown when a user defines a
--   pattern synonyms without enabling the PatternSynonyms extension.
--   
--   Example:
--   
--   pattern O :: Int pattern O = 0
--   
--   Test cases: rename<i>should_fail</i>RnPatternSynonymFail
[TcRnIllegalPatternSynonymDecl] :: TcRnMessage

-- | TcRnIllegalClassBinding is an error triggered by a binding in a class
--   or instance declaration of an illegal form.
--   
--   Examples:
--   
--   class ZeroOne a where zero :: a one :: a instance ZeroOne Int where
--   (zero,one) = (0,1)
--   
--   class C a where pattern P = ()
--   
--   Test cases: module/mod48 patsyn<i>should_fail</i>T9705-1
--   patsyn<i>should_fail</i>T9705-2 typecheck<i>should_fail</i>tcfail021
[TcRnIllegalClassBinding] :: DeclSort -> HsBindLR GhcPs GhcPs -> TcRnMessage

-- | TcRnOrphanCompletePragma is an error triggered by a {-# COMPLETE #-}
--   pragma which does not mention any data constructors or pattern
--   synonyms defined in the current module.
--   
--   Test cases: patsyn<i>should_fail</i>T13349
[TcRnOrphanCompletePragma] :: TcRnMessage

-- | TcRnEmptyCase is an error thrown when a user uses a case expression
--   with an empty list of alternatives without enabling the EmptyCase
--   extension.
--   
--   Example(s):
--   
--   case () of
--   
--   Test cases: rename<i>should_fail</i>RnEmptyCaseFail
[TcRnEmptyCase] :: HsMatchContextRn -> TcRnMessage

-- | TcRnNonStdGuards is a warning thrown when a user uses non-standard
--   guards (e.g. patterns in guards) without enabling the PatternGuards
--   extension. More realistically: the user has explicitly disabled
--   PatternGuards, as it is enabled by default with `-XHaskell2010`.
--   
--   Example(s):
--   
--   f | 5 &lt;- 2 + 3 = ...
--   
--   Test cases: rename<i>should_compile</i>rn049
[TcRnNonStdGuards] :: NonStandardGuards -> TcRnMessage

-- | TcRnDuplicateSigDecl is an error triggered by two or more signatures
--   for one entity.
--   
--   Examples:
--   
--   f :: Int -&gt; Bool f :: Int -&gt; Bool f _ = True
--   
--   g x = x {-# INLINE g #-} {-# NOINLINE g #-}
--   
--   pattern P = () {-# COMPLETE P #-} {-# COMPLETE P #-}
--   
--   Test cases: module/mod68 parser<i>should_fail</i>OpaqueParseFail4
--   patsyn<i>should_fail</i>T12165 rename<i>should_fail</i>rnfail048
--   rename<i>should_fail</i>T5589 rename<i>should_fail</i>T7338
--   rename<i>should_fail</i>T7338a
[TcRnDuplicateSigDecl] :: NonEmpty (LocatedN RdrName, Sig GhcPs) -> TcRnMessage

-- | TcRnMisplacedSigDecl is an error triggered by the pragma application
--   in the wrong context, like <tt>MINIMAL</tt> applied to a function or
--   <tt>SPECIALIZE</tt> to an instance.
--   
--   Example:
--   
--   f x = x {-# MINIMAL f #-}
--   
--   Test cases: rename<i>should_fail</i>T18138
--   warnings<i>minimal</i>WarnMinimalFail1
[TcRnMisplacedSigDecl] :: Sig GhcRn -> TcRnMessage

-- | TcRnUnexpectedDefaultSig is an error thrown when a user uses default
--   signatures without enabling the DefaultSignatures extension.
--   
--   Example:
--   
--   class C a where m :: a default m :: Num a =&gt; a m = 0
--   
--   Test cases: rename<i>should_fail</i>RnDefaultSigFail
[TcRnUnexpectedDefaultSig] :: Sig GhcPs -> TcRnMessage

-- | TcRnDuplicateMinimalSig is an error triggered by two or more minimal
--   signatures for one type class.
--   
--   Example:
--   
--   class C where f :: () {-# MINIMAL f #-} {-# MINIMAL f #-}
--   
--   Test cases: rename<i>should_fail</i>RnMultipleMinimalPragmaFail
[TcRnDuplicateMinimalSig] :: LSig GhcPs -> LSig GhcPs -> [LSig GhcPs] -> TcRnMessage

-- | <a>TcRnIllegalInvisTyVarBndr</a> is an error that occurs when
--   invisible type variable binders in type declarations are used without
--   enabling the <tt>TypeAbstractions</tt> extension.
--   
--   Example: {-# LANGUAGE NoTypeAbstractions #-} -- extension disabled
--   data T <tt>k (a :: k) </tt>(j :: Type) (b :: j) ^^ ^^^^^^^^^^^^
--   
--   Test case: T22560_fail_ext
[TcRnIllegalInvisTyVarBndr] :: !LHsTyVarBndr (HsBndrVis GhcRn) GhcRn -> TcRnMessage

-- | <a>TcRnIllegalWildcardTyVarBndr</a> is an error that occurs when a
--   wildcard binder is used in a type declaration without enabling the
--   <tt>TypeAbstractions</tt> extension.
--   
--   Example: {-# LANGUAGE NoTypeAbstractions #-} -- extension disabled
--   type Const a _ = a ^
--   
--   Test case: T23501_fail_ext
[TcRnIllegalWildcardTyVarBndr] :: !LHsTyVarBndr (HsBndrVis GhcRn) GhcRn -> TcRnMessage

-- | <a>TcRnInvalidInvisTyVarBndr</a> is an error that occurs when an
--   invisible type variable binder has no corresponding <tt>forall k.</tt>
--   quantifier in the standalone kind signature.
--   
--   Example: type P :: forall a -&gt; Type data P @a = MkP
--   
--   Test cases: T22560_fail_a T22560_fail_b
[TcRnInvalidInvisTyVarBndr] :: !Name -> !LHsTyVarBndr (HsBndrVis GhcRn) GhcRn -> TcRnMessage

-- | <a>TcRnInvisBndrWithoutSig</a> is an error triggered by attempting to
--   use an invisible type variable binder in a type declaration without a
--   standalone kind signature or a complete user-supplied kind.
--   
--   Example: data T @k (a :: k) -- No CUSK, no SAKS
--   
--   Test case: T22560_fail_d
[TcRnInvisBndrWithoutSig] :: !Name -> !LHsTyVarBndr (HsBndrVis GhcRn) GhcRn -> TcRnMessage

-- | TcRnDeprecatedInvisTyArgInConPat is a warning that triggers on type
--   applications in constructor patterns when the user has not enabled
--   '-XTypeAbstractions' but instead has enabled both
--   '-XScopedTypeVariables' and '-XTypeApplications'.
--   
--   This warning is a deprecation mechanism that is scheduled until GHC
--   9.12.
[TcRnDeprecatedInvisTyArgInConPat] :: TcRnMessage

-- | TcRnUnexpectedStandaloneDerivingDecl is an error thrown when a user
--   uses standalone deriving without enabling the StandaloneDeriving
--   extension.
--   
--   Example:
--   
--   deriving instance Eq Foo
--   
--   Test cases: rename<i>should_fail</i>RnUnexpectedStandaloneDeriving
[TcRnUnexpectedStandaloneDerivingDecl] :: TcRnMessage

-- | TcRnUnusedVariableInRuleDecl is an error triggered by forall'd
--   variable in rewrite rule that does not appear on left-hand side
--   
--   Example:
--   
--   {-# RULES "rule" forall a. id = id #-}
--   
--   Test cases: rename<i>should_fail</i>ExplicitForAllRules2
[TcRnUnusedVariableInRuleDecl] :: FastString -> Name -> TcRnMessage

-- | TcRnUnexpectedStandaloneKindSig is an error thrown when a user uses
--   standalone kind signature without enabling the
--   StandaloneKindSignatures extension.
--   
--   Example:
--   
--   type D :: Type data D = D
--   
--   Test cases: saks<i>should_fail</i>saks_fail001
[TcRnUnexpectedStandaloneKindSig] :: TcRnMessage

-- | TcRnIllegalRuleLhs is an error triggered by malformed left-hand side
--   of rewrite rule
--   
--   Examples:
--   
--   {-# RULES "test" forall x. f x = x #-}
--   
--   {-# RULES "test" forall x. case x of = x #-}
--   
--   Test cases: rename<i>should_fail</i>T15659
[TcRnIllegalRuleLhs] :: RuleLhsErrReason -> FastString -> LHsExpr GhcRn -> HsExpr GhcRn -> TcRnMessage

-- | TcRnDuplicateRoleAnnot is an error triggered by two or more role
--   annotations for one type
--   
--   Example:
--   
--   data D a type role D phantom type role D phantom
--   
--   Test cases: roles<i>should_fail</i>Roles8
[TcRnDuplicateRoleAnnot] :: NonEmpty (LRoleAnnotDecl GhcPs) -> TcRnMessage

-- | TcRnDuplicateKindSig is an error triggered by two or more standalone
--   kind signatures for one type
--   
--   Example:
--   
--   type D :: Type type D :: Type data D
--   
--   Test cases: saks<i>should_fail</i>saks_fail002
[TcRnDuplicateKindSig] :: NonEmpty (LStandaloneKindSig GhcPs) -> TcRnMessage

-- | TcRnIllegalDerivStrategy is an error thrown when a user uses deriving
--   strategy without enabling the DerivingStrategies extension or uses
--   deriving via without enabling the DerivingVia extension.
--   
--   Examples:
--   
--   data T = T deriving stock Eq
--   
--   data T = T deriving via Eq T
--   
--   Test cases: deriving<i>should_fail</i>deriving-via-fail3
--   deriving<i>should_fail</i>T10598_fail4
[TcRnIllegalDerivStrategy] :: DerivStrategy GhcPs -> TcRnMessage

-- | TcRnIllegalMultipleDerivClauses is an error thrown when a user uses
--   two or more deriving clauses without enabling the DerivingStrategies
--   extension.
--   
--   Example:
--   
--   data T = T deriving Eq deriving Ord
--   
--   Test cases: deriving<i>should_fail</i>T10598_fail5
[TcRnIllegalMultipleDerivClauses] :: TcRnMessage

-- | TcRnNoDerivStratSpecified is a warning implied by
--   -Wmissing-deriving-strategies and triggered by deriving without
--   mentioning a strategy.
--   
--   See <a>TcRnNoDerivStratSpecifiedInfo</a> cases for examples.
--   
--   Test cases: deriving<i>should_compile</i>T15798a
--   deriving<i>should_compile</i>T15798b
--   deriving<i>should_compile</i>T15798c
--   deriving<i>should_compile</i>T24955a
--   deriving<i>should_compile</i>T24955b
--   deriving<i>should_compile</i>T24955c
[TcRnNoDerivStratSpecified] :: Bool -> TcRnNoDerivStratSpecifiedInfo -> TcRnMessage

-- | TcRnStupidThetaInGadt is an error triggered by data contexts in
--   GADT-style data declaration
--   
--   Example:
--   
--   data (Eq a) =&gt; D a where MkD :: D Int
--   
--   Test cases: rename<i>should_fail</i>RnStupidThetaInGadt
[TcRnStupidThetaInGadt] :: HsDocContext -> TcRnMessage

-- | TcRnShadowedTyVarNameInFamResult is an error triggered by type
--   variable in type family result that shadows type variable from left
--   hand side
--   
--   Example:
--   
--   type family F a b c = b
--   
--   Test cases: ghci<i>scripts</i>T6018ghcirnfail
--   rename<i>should_fail</i>T6018rnfail
[TcRnShadowedTyVarNameInFamResult] :: IdP GhcPs -> TcRnMessage

-- | TcRnIncorrectTyVarOnRhsOfInjCond is an error caused by a situation
--   where the left-hand side of an injectivity condition of a type family
--   is not a variable referring to the type family result. See Note
--   [Renaming injectivity annotation] for more details.
--   
--   Example:
--   
--   type family F a = r | a -&gt; a
--   
--   Test cases: ghci<i>scripts</i>T6018ghcirnfail
--   rename<i>should_fail</i>T6018rnfail
[TcRnIncorrectTyVarOnLhsOfInjCond] :: IdP GhcRn -> LIdP GhcPs -> TcRnMessage

-- | TcRnUnknownTyVarsOnRhsOfInjCond is an error triggered by out-of-scope
--   type variables on the right-hand side of a of an injectivity condition
--   of a type family
--   
--   Example:
--   
--   type family F a = res | res -&gt; b
--   
--   Test cases: ghci<i>scripts</i>T6018ghcirnfail
--   rename<i>should_fail</i>T6018rnfail
[TcRnUnknownTyVarsOnRhsOfInjCond] :: [Name] -> TcRnMessage

-- | TcRnLookupInstance groups several errors emitted when looking up class
--   instances.
--   
--   Test cases: none
[TcRnLookupInstance] :: !Class -> ![Type] -> !LookupInstanceErrReason -> TcRnMessage

-- | TcRnBadlyStaged is an error that occurs when a TH binding is used in
--   an invalid stage.
--   
--   Test cases: T17820d
[TcRnBadlyStaged] :: !StageCheckReason -> !Int -> !Int -> TcRnMessage

-- | TcRnStageRestriction is an error that occurs when a top level splice
--   refers to a local name.
--   
--   Test cases: T17820, T21547, T5795, qq00[1-4], annfail0{3,4,6,9}
[TcRnStageRestriction] :: !StageCheckReason -> TcRnMessage

-- | TcRnBadlyStagedWarn is a warning that occurs when a TH type binding is
--   used in an invalid stage.
--   
--   Controlled by flags: - Wbadly-staged-type
--   
--   Test cases: T23829_timely T23829_tardy T23829_hasty
[TcRnBadlyStagedType] :: !Name -> !Int -> !Int -> TcRnMessage

-- | TcRnTyThingUsedWrong is an error that occurs when a thing is used
--   where another thing was expected.
--   
--   Test cases: none
[TcRnTyThingUsedWrong] :: !WrongThingSort -> !TcTyThing -> !Name -> TcRnMessage

-- | TcRnCannotDefaultKindVar is an error that occurs when attempting to
--   use unconstrained kind variables whose type isn't <tt>Type</tt>,
--   without -XPolyKinds.
--   
--   Test cases: T11334b
[TcRnCannotDefaultKindVar] :: !TyVar -> !Kind -> TcRnMessage

-- | TcRnUninferrableTyVar is an error that occurs when metavariables in a
--   type could not be defaulted.
--   
--   Test cases: T17301, T17562, T17567, T17567StupidTheta, T15474, T21479
[TcRnUninferrableTyVar] :: ![TyCoVar] -> !UninferrableTyVarCtx -> TcRnMessage

-- | TcRnSkolemEscape is an error that occurs when type variables from an
--   outer scope is used in a context where they should be locally scoped.
--   
--   Test cases: T15076, T15076b, T14880-2, T15825, T14880, T15807, T16946,
--   T14350, T14040A, T15795, T15795a, T14552
[TcRnSkolemEscape] :: ![TcTyVar] -> !TcTyVar -> !Type -> TcRnMessage

-- | TcRnPatSynEscapedCoercion is an error indicating that a coercion
--   escaped from a pattern synonym into a type. See Note [Coercions that
--   escape] in GHC.Tc.TyCl.PatSyn
--   
--   Test cases: T14507
[TcRnPatSynEscapedCoercion] :: !Id -> !NonEmpty CoVar -> TcRnMessage

-- | TcRnPatSynExistentialInResult is an error indicating that the result
--   type of a pattern synonym mentions an existential type variable.
--   
--   Test cases: PatSynExistential
[TcRnPatSynExistentialInResult] :: !Name -> !TcSigmaType -> ![TyVar] -> TcRnMessage

-- | TcRnPatSynArityMismatch is an error indicating that the number of
--   arguments in a pattern synonym's equation differs from the number of
--   parameters in its signature.
--   
--   Test cases: PatSynArity
[TcRnPatSynArityMismatch] :: !Name -> !Arity -> !Arity -> TcRnMessage

-- | TcRnPatSynInvalidRhs is an error group indicating that the pattern on
--   the right hand side of a pattern synonym is invalid.
--   
--   Test cases: unidir, T14112
[TcRnPatSynInvalidRhs] :: !Name -> !LPat GhcRn -> ![LIdP GhcRn] -> !PatSynInvalidRhsReason -> TcRnMessage

-- | TcRnZonkerMessage is collection of errors that occur when zonking,
--   i.e. filling in metavariables with their final values.
--   
--   See <a>ZonkerMessage</a>
[TcRnZonkerMessage] :: ZonkerMessage -> TcRnMessage

-- | TcRnTyFamDepsDisabled is an error indicating that a type family
--   injectivity annotation was used without enabling the extension
--   TypeFamilyDependencies.
--   
--   Test cases: T11381
[TcRnTyFamDepsDisabled] :: TcRnMessage

-- | TcRnAbstractClosedTyFamDecl is an error indicating that an abstract
--   closed type family was declared in a regular source file, while it is
--   only allowed in hs-boot files.
--   
--   Test cases: ClosedFam4
[TcRnAbstractClosedTyFamDecl] :: TcRnMessage

-- | TcRnPartialFieldSelector is a warning indicating that a record field
--   was not defined for all constructors of a data type.
--   
--   Test cases: DRFPartialFields, T7169
[TcRnPartialFieldSelector] :: !FieldLabel -> TcRnMessage

-- | TcRnHasFieldResolvedIncomplete is a warning triggered when a HasField
--   constraint is resolved for a record field for which a `getField
--   @"field"` application might not be successful. Currently, this means
--   that the warning is triggered when the parent data type of that record
--   field does not have that field in all its constructors.
--   
--   Example(s): data T = T1 | T2 {x :: Bool} f :: HasField t "x" Bool
--   =&gt; t -&gt; Bool f = getField @"x" g :: T -&gt; Bool g = f
--   
--   Test cases: TcIncompleteRecSel
[TcRnHasFieldResolvedIncomplete] :: !Name -> TcRnMessage

-- | TcRnBadFieldAnnotation is an error/warning group indicating that a
--   strictness/unpack related data type field annotation is invalid.
[TcRnBadFieldAnnotation] :: !Int -> !DataCon -> !BadFieldAnnotationReason -> TcRnMessage

-- | TcRnSuperclassCycle is an error indicating that a class has a
--   superclass cycle.
--   
--   Test cases: mod40, tcfail027, tcfail213, tcfail216, tcfail217, T9415,
--   T9739
[TcRnSuperclassCycle] :: !SuperclassCycle -> TcRnMessage

-- | TcRnDefaultSigMismatch is an error indicating that a default method
--   signature doesn't match the regular method signature.
--   
--   Test cases: T7437, T12918a, T12918b, T12151
[TcRnDefaultSigMismatch] :: !Id -> !Type -> TcRnMessage

-- | TcRnTyFamsDisabled is an error indicating that a type family or
--   instance was declared while the extension TypeFamilies was disabled.
--   
--   Test cases: TyFamsDisabled
[TcRnTyFamsDisabled] :: !TyFamsDisabledReason -> TcRnMessage

-- | TcRnBadTyConTelescope is an error caused by an ill-scoped <a>TyCon</a>
--   kind, due to type variables being out of dependency order.
--   
--   Example:
--   
--   class C a (b :: Proxy a) (c :: Proxy b) where type T c a
--   
--   Test cases: BadTelescope{∅,3,4} T14066{f,g} T14887 T15591{b,c}
--   T15743{c,d} T15764 T23252
[TcRnBadTyConTelescope] :: !TyCon -> TcRnMessage

-- | TcRnTyFamResultDisabled is an error indicating that a result variable
--   was used on a type family while the extension TypeFamilyDependencies
--   was disabled.
--   
--   Test cases: T13571, T13571a
[TcRnTyFamResultDisabled] :: !Name -> !LHsTyVarBndr () GhcRn -> TcRnMessage

-- | TcRnRoleValidationFailed is an error indicating that a variable was
--   assigned an invalid role by the inference algorithm. This is only
--   performed with -dcore-lint.
[TcRnRoleValidationFailed] :: !Role -> !RoleValidationFailedReason -> TcRnMessage

-- | TcRnCommonFieldResultTypeMismatch is an error indicating that a sum
--   type declares the same field name in multiple constructors, but the
--   constructors' result types differ.
--   
--   Test cases: CommonFieldResultTypeMismatch
[TcRnCommonFieldResultTypeMismatch] :: !DataCon -> !DataCon -> !FieldLabelString -> TcRnMessage

-- | TcRnCommonFieldTypeMismatch is an error indicating that a sum type
--   declares the same field name in multiple constructors, but their types
--   differ.
--   
--   Test cases: CommonFieldTypeMismatch
[TcRnCommonFieldTypeMismatch] :: !DataCon -> !DataCon -> !FieldLabelString -> TcRnMessage

-- | TcRnClassExtensionDisabled is an error indicating that a class was
--   declared with an extension feature while the extension was disabled.
[TcRnClassExtensionDisabled] :: !Class -> !DisabledClassExtension -> TcRnMessage

-- | TcRnDataConParentTypeMismatch is an error indicating that a data
--   constructor was declared with a type that doesn't match its type
--   constructor (i.e. a GADT result type and its data name).
--   
--   Test cases: T7175, T13300, T14719, T18357, T18357b, gadt11, tcfail155,
--   tcfail176
[TcRnDataConParentTypeMismatch] :: !DataCon -> !Type -> TcRnMessage

-- | TcRnGADTsDisabled is an error indicating that a GADT was declared
--   while the extension GADTs was disabled.
--   
--   Test cases: ghci057, T9293
[TcRnGADTsDisabled] :: !Name -> TcRnMessage

-- | TcRnExistentialQuantificationDisabled is an error indicating that a
--   data constructor was declared with existential features while the
--   extension ExistentialQuantification was disabled.
--   
--   Test cases: ghci057, T9293, gadtSyntaxFail001, gadtSyntaxFail002,
--   gadtSyntaxFail003, prog006, rnfail053, T12083a
[TcRnExistentialQuantificationDisabled] :: !DataCon -> TcRnMessage

-- | TcRnGADTDataContext is an error indicating that a GADT was declared
--   with a data type context. This error is emitted in the tc, but it is
--   also caught in the renamer.
[TcRnGADTDataContext] :: !Name -> TcRnMessage

-- | TcRnMultipleConForNewtype is an error indicating that a newtype was
--   declared with multiple constructors. This error is caught by the
--   parser.
[TcRnMultipleConForNewtype] :: !Name -> !Int -> TcRnMessage

-- | TcRnKindSignaturesDisabled is an error indicating that a kind
--   signature was used in a data type declaration while the extension
--   KindSignatures was disabled.
--   
--   Test cases: T20873c, readFail036
[TcRnKindSignaturesDisabled] :: !Either (HsType GhcPs) (Name, HsType GhcRn) -> TcRnMessage

-- | TcRnEmptyDataDeclsDisabled is an error indicating that a data type was
--   declared with no constructors while the extension EmptyDataDecls was
--   disabled.
--   
--   Test cases: readFail035
[TcRnEmptyDataDeclsDisabled] :: !Name -> TcRnMessage

-- | TcRnRoleMismatch is an error indicating that the role specified in an
--   annotation differs from its inferred role.
--   
--   Test cases: T7253, Roles11
[TcRnRoleMismatch] :: !Name -> !Role -> !Role -> TcRnMessage

-- | TcRnRoleCountMismatch is an error indicating that the number of roles
--   in an annotation doesn't match the number of type parameters.
--   
--   Test cases: Roles6
[TcRnRoleCountMismatch] :: !Int -> !LRoleAnnotDecl GhcRn -> TcRnMessage

-- | TcRnIllegalRoleAnnotation is an error indicating that a role
--   annotation was attached to a decl that doesn't allow it.
--   
--   Test cases: Roles5
[TcRnIllegalRoleAnnotation] :: !RoleAnnotDecl GhcRn -> TcRnMessage

-- | TcRnRoleAnnotationsDisabled is an error indicating that a role
--   annotation was declared while the extension RoleAnnotations was
--   disabled.
--   
--   Test cases: Roles5, TH_Roles1
[TcRnRoleAnnotationsDisabled] :: !TyCon -> TcRnMessage

-- | TcRnIncoherentRoles is an error indicating that a role annotation for
--   a class parameter was declared as not nominal.
--   
--   Test cases: T8773
[TcRnIncoherentRoles] :: !TyCon -> TcRnMessage

-- | TcRnPrecedenceParsingError is an error caused by attempting to use
--   operators with the same precedence in one infix expression.
--   
--   Example: eq :: (a ~ b ~ c) :~: ()
--   
--   Test cases: module/mod61 parser<i>should_fail</i>readFail016
--   rename<i>should_fail</i>rnfail017 rename<i>should_fail</i>T9077
--   typecheck<i>should_fail</i>T18252a
[TcRnPrecedenceParsingError] :: (OpName, Fixity) -> (OpName, Fixity) -> TcRnMessage

-- | TcRnPrecedenceParsingError is an error caused by attempting to use an
--   operator with higher precedence than the operand.
--   
--   Example: k = (-3 **) where (**) = const infixl 7 **
--   
--   Test cases: overloadedrecflds<i>should_fail</i>T13132_duplicaterecflds
--   parser<i>should_fail</i>readFail023 rename<i>should_fail</i>rnfail019
--   th/TH_unresolvedInfix2
[TcRnSectionPrecedenceError] :: (OpName, Fixity) -> (OpName, Fixity) -> HsExpr GhcPs -> TcRnMessage

-- | TcRnTypeSynonymCycle is an error indicating that a cycle between type
--   synonyms has occurred.
--   
--   Test cases: mod27, ghc-e-fail2, bkpfail29
[TcRnTypeSynonymCycle] :: !TySynCycleTyCons -> TcRnMessage

-- | TcRnSelfImport is an error indicating that a module contains an import
--   of itself.
--   
--   Test cases: T9032
[TcRnSelfImport] :: !ModuleName -> TcRnMessage

-- | TcRnNoExplicitImportList is a warning indicating that an import
--   statement did not include an explicit import list.
--   
--   Test cases: T1789, T4489
[TcRnNoExplicitImportList] :: !ModuleName -> TcRnMessage

-- | TcRnSafeImportsDisabled is an error indicating that an import was
--   declared using the <tt>safe</tt> keyword while SafeHaskell wasn't
--   active.
--   
--   Test cases: Mixed01
[TcRnSafeImportsDisabled] :: !ModuleName -> TcRnMessage

-- | TcRnDeprecatedModule is a warning indicating that an imported module
--   is annotated with a warning or deprecation pragma.
--   
--   Test cases: DeprU
[TcRnDeprecatedModule] :: !ModuleName -> !WarningTxt GhcRn -> TcRnMessage

-- | TcRnRedundantSourceImport is a warning indicating that a {-# SOURCE
--   #-} import was used when there is no import cycle.
--   
--   Test cases: none
[TcRnRedundantSourceImport] :: !ModuleName -> TcRnMessage

-- | TcRnImportLookup is a group of errors about bad imported names.
[TcRnImportLookup] :: !ImportLookupReason -> TcRnMessage

-- | TcRnUnusedImport is a group of errors about unused imports.
[TcRnUnusedImport] :: !ImportDecl GhcRn -> !UnusedImportReason -> TcRnMessage

-- | TcRnDuplicateDecls is an error indicating that the same name was used
--   for multiple declarations.
--   
--   Test cases: FieldSelectors, overloadedrecfldsfail03, T17965,
--   NFSDuplicate, T9975a, TDMultiple01, mod19, mod38, mod21, mod66, mod20,
--   TDPunning, mod18, mod22, TDMultiple02, T4127a, ghci048, T8932,
--   rnfail015, rnfail010, rnfail011, rnfail013, rnfail002, rnfail003,
--   rn_dup, rnfail009, T7164, rnfail043, TH_dupdecl, rnfail012
[TcRnDuplicateDecls] :: !OccName -> !NonEmpty Name -> TcRnMessage

-- | TcRnPackageImportsDisabled is an error indicating that an import uses
--   a package qualifier while the extension PackageImports was disabled.
--   
--   Test cases: PackageImportsDisabled
[TcRnPackageImportsDisabled] :: TcRnMessage

-- | TcRnIllegalDataCon is an error indicating that a data constructor was
--   defined using a lowercase name, or a symbolic name in prefix position.
--   Mostly caught by PsErrNotADataCon.
--   
--   Test cases: None
[TcRnIllegalDataCon] :: !RdrName -> TcRnMessage

-- | TcRnNestedForallsContexts is an error indicating that multiple foralls
--   or contexts are nested/curried where this is not supported, like <tt>∀
--   x. ∀ y.</tt> instead of <tt>∀ x y.</tt>.
--   
--   Test cases: T12087, T14320, T16114, T16394, T16427, T18191, T18240a,
--   T18240b, T18455, T5951
[TcRnNestedForallsContexts] :: !NestedForallsContextsIn -> TcRnMessage

-- | TcRnRedundantRecordWildcard is a warning indicating that a pattern
--   uses a record wildcard even though all of the record's fields are
--   bound explicitly.
--   
--   Test cases: T15957_Fail
[TcRnRedundantRecordWildcard] :: TcRnMessage

-- | TcRnUnusedRecordWildcard is a warning indicating that a pattern uses a
--   record wildcard while none of the fields bound by it are used.
--   
--   Test cases: T15957_Fail
[TcRnUnusedRecordWildcard] :: ![Name] -> TcRnMessage

-- | TcRnUnusedName is a warning indicating that a defined or imported name
--   is not used in the module.
--   
--   Test cases: ds053, mc10, overloadedrecfldsfail05,
--   overloadedrecfldsfail06, prog018, read014, rn040, rn041, rn047, rn063,
--   T13839, T13839a, T13919, T17171b, T17a, T17b, T17d, T17e, T18470,
--   T1972, t22391, t22391j, T2497, T3371, T3449, T7145b, T7336,
--   TH_recover_warns, unused_haddock, WarningGroups, werror
[TcRnUnusedName] :: !OccName -> !UnusedNameProv -> TcRnMessage

-- | TcRnQualifiedBinder is an error indicating that a qualified name was
--   used in binding position.
--   
--   Test cases: mod62, rnfail021, rnfail034, rnfail039, rnfail046
[TcRnQualifiedBinder] :: !RdrName -> TcRnMessage

-- | TcRnTypeApplicationsDisabled is an error indicating that a type
--   application was used while the extension TypeApplications was
--   disabled.
--   
--   Test cases: T12411, T12446, T15527, T16133, T18251c
[TcRnTypeApplicationsDisabled] :: !TypeApplication -> TcRnMessage

-- | TcRnInvalidRecordField is an error indicating that a record field was
--   used that doesn't exist in a constructor.
--   
--   Test cases: T13644, T13847, T17469, T8448, T8570, tcfail083, tcfail084
[TcRnInvalidRecordField] :: !Name -> !FieldLabelString -> TcRnMessage

-- | TcRnTupleTooLarge is an error indicating that the arity of a tuple
--   exceeds mAX_TUPLE_SIZE.
--   
--   Test cases: T18723a, T18723b, T18723c, T6148a, T6148b, T6148c, T6148d
[TcRnTupleTooLarge] :: !Int -> TcRnMessage

-- | TcRnCTupleTooLarge is an error indicating that the arity of a
--   constraint tuple exceeds mAX_CTUPLE_SIZE.
--   
--   Test cases: T10451
[TcRnCTupleTooLarge] :: !Int -> TcRnMessage

-- | TcRnIllegalInferredTyVars is an error indicating that some type
--   variables were quantified as inferred (like <tt>∀ {a}.</tt>) in a
--   place where this is not allowed, like in an instance declaration.
--   
--   Test cases: ExplicitSpecificity5, ExplicitSpecificity6,
--   ExplicitSpecificity8, ExplicitSpecificity9
[TcRnIllegalInferredTyVars] :: !NonEmpty (HsTyVarBndr Specificity GhcPs) -> TcRnMessage

-- | TcRnAmbiguousName is an error indicating that an unbound name might
--   refer to multiple names in scope.
--   
--   Test cases: BootFldReexport, DRFUnused, duplicaterecfldsghci01,
--   GHCiDRF, mod110, mod151, mod152, mod153, mod164, mod165,
--   NoFieldSelectorsFail, overloadedrecfldsfail02,
--   overloadedrecfldsfail04, overloadedrecfldsfail11,
--   overloadedrecfldsfail12, overloadedrecfldsfail13,
--   overloadedrecfldswasrunnowfail06, rnfail044, T11167_ambig,
--   T11167_ambiguous_fixity, T13132_duplicaterecflds, T15487, T16745,
--   T17420, T18999_NoDisambiguateRecordFields, T19397E1, T19397E2,
--   T23010_fail, tcfail037
[TcRnAmbiguousName] :: !GlobalRdrEnv -> !RdrName -> !NonEmpty GlobalRdrElt -> TcRnMessage

-- | TcRnBindingNameConflict is an error indicating that multiple local or
--   top-level bindings have the same name.
--   
--   Test cases: dsrun006, mdofail002, mdofail003, mod23, mod24, qq006,
--   rnfail001, rnfail004, SimpleFail6, T14114, T16110_Fail1, tcfail038,
--   TH_spliceD1, T22478b, TyAppPat_NonlinearMultiAppPat,
--   TyAppPat_NonlinearMultiPat, TyAppPat_NonlinearSinglePat,
[TcRnBindingNameConflict] :: !RdrName -> !NonEmpty SrcSpan -> TcRnMessage

-- | TcRnNonCanonicalDefinition is a warning indicating that an instance
--   defines an implementation for a method that should not be defined in a
--   way that deviates from its default implementation, for example because
--   it has been scheduled to be absorbed into another method, like
--   <tt>pure</tt> making <tt>return</tt> obsolete.
--   
--   Test cases: WCompatWarningsOn, WCompatWarningsOff,
--   WCompatWarningsOnOff
[TcRnNonCanonicalDefinition] :: !NonCanonicalDefinition -> !LHsSigType GhcRn -> TcRnMessage

-- | TcRnImplicitImportOfPrelude is a warning, controlled by
--   <tt>Wimplicit-prelude</tt>, that is triggered upon an implicit import
--   of the <tt>Prelude</tt> module.
--   
--   Example:
--   
--   {-# OPTIONS_GHC -fwarn-implicit-prelude #-} module M where {}
--   
--   Test case: rn055
[TcRnImplicitImportOfPrelude] :: TcRnMessage

-- | TcRnMissingMain is an error that occurs when a Main module does not
--   define a main function (named <tt>main</tt> by default, but
--   overridable with the <tt>main-is</tt> command line flag).
--   
--   Example:
--   
--   module Main where {}
--   
--   Test cases: T414, T7765, readFail021, rnfail007, T13839b, T17171a,
--   T16453E1, tcfail030, T19397E3, T19397E4
[TcRnMissingMain] :: !Bool -> !Module -> !OccName -> TcRnMessage

-- | TcRnGhciUnliftedBind is an error that occurs when a user attempts to
--   bind an unlifted value in GHCi.
--   
--   Example (in GHCi):
--   
--   let a = (# 1#, 3# #)
--   
--   Test cases: T9140, T19035b
[TcRnGhciUnliftedBind] :: !Id -> TcRnMessage

-- | TcRnGhciMonadLookupFail is an error that occurs when the user sets the
--   GHCi monad, using the GHC API <tt>setGHCiMonad</tt> function, but GHC
--   can't find which monad the user is referring to.
--   
--   Example:
--   
--   import GHC ( setGHCiMonad )
--   
--   ... setGHCiMonad <a>NoSuchThing</a>
--   
--   Test cases: none
[TcRnGhciMonadLookupFail] :: String -> Maybe [GlobalRdrElt] -> TcRnMessage

-- | TcRnMissingRoleAnnotation is a warning that occurs when type
--   declaration doesn't have a role annotatiosn
--   
--   Controlled by flags: - Wmissing-role-annotations
--   
--   Test cases: T22702
[TcRnMissingRoleAnnotation] :: Name -> [Role] -> TcRnMessage

-- | TcRnPatersonCondFailure is an error that occurs when an instance
--   declaration fails to conform to the Paterson conditions. Which
--   particular condition fails depends on the constructor of
--   PatersonCondFailure See Note [Paterson conditions].
--   
--   Test cases: T15231, tcfail157, T15316, T19187a, fd-loop, tcfail108,
--   tcfail154, T15172, tcfail214
[TcRnPatersonCondFailure] :: PatersonCondFailure -> PatersonCondFailureContext -> Type -> Type -> TcRnMessage

-- | TcRnImplicitRhsQuantification is a warning that occurs when GHC
--   implicitly quantifies over a type variable that occurs free on the RHS
--   of the type declaration that is not mentioned on the LHS
--   
--   Example:
--   
--   type T = 'Nothing :: Maybe a
--   
--   Controlled by flags: - Wimplicit-rhs-quantification
--   
--   Test cases: T23510a T23510b
[TcRnImplicitRhsQuantification] :: LocatedN RdrName -> TcRnMessage

-- | TcRnIllformedTypePattern is an error raised when the pattern
--   corresponding to a required type argument (visible forall) does not
--   have a form that can be interpreted as a type pattern.
--   
--   Example:
--   
--   vfun :: forall (a :: k) -&gt; () vfun !x = () -- ^^ -- bang-patterns
--   not allowed as type patterns
--   
--   Test cases: T22326_fail_bang_pat
[TcRnIllformedTypePattern] :: !Pat GhcRn -> TcRnMessage

-- | TcRnIllegalTypePattern is an error raised when a pattern constructed
--   with the <tt>type</tt> keyword occurs in a position that does not
--   correspond to a required type argument (visible forall).
--   
--   Example:
--   
--   case x of (type _) -&gt; True -- the (type _) pattern is illegal here
--   _ -&gt; False
--   
--   Test cases: T22326_fail_ado T22326_fail_caseof
[TcRnIllegalTypePattern] :: TcRnMessage

-- | TcRnIllformedTypeArgument is an error raised when an argument that
--   specifies a required type argument (instantiates a visible forall)
--   does not have a form that can be interpreted as a type argument.
--   
--   Example:
--   
--   vfun :: forall (a :: k) -&gt; () x = vfun (_ -&gt; _) -- ^^^^^^^^^ --
--   lambdas not allowed in type arguments
--   
--   Test cases: T22326_fail_lam_arg
[TcRnIllformedTypeArgument] :: !LHsExpr GhcRn -> TcRnMessage
[TcRnIllegalTypeExpr] :: TypeSyntax -> TcRnMessage

-- | TcRnInvalidDefaultedTyVar is an error raised when a defaulting plugin
--   proposes to default a type variable that is not an unfilled
--   metavariable
--   
--   Test cases: T23832_invalid
[TcRnInvalidDefaultedTyVar] :: ![Ct] -> [(TcTyVar, Type)] -> NonEmpty TcTyVar -> TcRnMessage

-- | TcRnNamespacedWarningPragmaWithoutFlag is an error that occurs when a
--   namespace specifier is used in {-# WARNING ... #-} or {-# DEPRECATED
--   ... #-} pragmas without the -XExplicitNamespaces extension enabled
--   
--   Example:
--   
--   {-# LANGUAGE NoExplicitNamespaces #-} f = id {-# WARNING data f "some
--   warning message" #-}
--   
--   Test cases: T24396c
[TcRnNamespacedWarningPragmaWithoutFlag] :: WarnDecl GhcPs -> TcRnMessage

-- | TcRnInvisPatWithNoForAll is an error raised when invisible type
--   pattern is used without associated `forall` in types
--   
--   Examples:
--   
--   f :: Int f @t = 5
--   
--   g :: [a -&gt; a] g = [ @t x -&gt; x :: t]
--   
--   Test cases: T17694c T17594d
[TcRnInvisPatWithNoForAll] :: HsTyPat GhcRn -> TcRnMessage

-- | TcRnIllegalInvisibleTypePattern is an error raised when invisible type
--   pattern is used without the TypeAbstractions extension enabled
--   
--   Example:
--   
--   {-# LANGUAGE NoTypeAbstractions #-} id :: a -&gt; a id @t x = x
--   
--   Test cases: T17694b
[TcRnIllegalInvisibleTypePattern] :: HsTyPat GhcPs -> TcRnMessage

-- | TcRnNamespacedFixitySigWithoutFlag is an error that occurs when a
--   namespace specifier is used in fixity signatures without the
--   -XExplicitNamespaces extension enabled
--   
--   Example:
--   
--   {-# LANGUAGE NoExplicitNamespaces #-} f = const infixl 7 data
--   <tt>f</tt>
--   
--   Test cases: T14032c
[TcRnNamespacedFixitySigWithoutFlag] :: FixitySig GhcPs -> TcRnMessage

-- | TcRnDefaultedExceptionContext is a warning that is triggered when the
--   backward-compatibility logic solving for implicit ExceptionContext
--   constraints fires.
--   
--   Test cases: DefaultExceptionContext
[TcRnDefaultedExceptionContext] :: CtLoc -> TcRnMessage

-- | TcRnOutOfArityTyVar is an error raised when the arity of a type
--   synonym (as determined by the SAKS and the LHS) is insufficiently high
--   to accommodate an implicit binding for a free variable that occurs in
--   the outermost kind signature on the RHS of the said type synonym.
--   
--   Example:
--   
--   type SynBad :: forall k. k -&gt; Type type SynBad = Proxy :: j -&gt;
--   Type
--   
--   Test cases: T24770a
[TcRnOutOfArityTyVar] :: Name -> Name -> TcRnMessage
[TcRnMisplacedInvisPat] :: HsTyPat GhcPs -> TcRnMessage
[TcRnUnexpectedTypeSyntaxInTerms] :: TypeSyntax -> TcRnMessage
data TcRnMessageOpts
TcRnMessageOpts :: !Bool -> !IfaceMessageOpts -> TcRnMessageOpts

-- | Whether we show the error context or not
[tcOptsShowContext] :: TcRnMessageOpts -> !Bool
[tcOptsIfaceOpts] :: TcRnMessageOpts -> !IfaceMessageOpts
mkTcRnUnknownMessage :: (Diagnostic a, Typeable a, DiagnosticOpts a ~ NoDiagnosticOpts) => a -> TcRnMessage

-- | <a>TcRnMessageDetailed</a> is an "internal" type (used only inside
--   <a>Monad</a> that wraps a <a>TcRnMessage</a> while also providing any
--   extra info needed to correctly pretty-print this diagnostic later on.
data TcRnMessageDetailed
TcRnMessageDetailed :: !ErrInfo -> !TcRnMessage -> TcRnMessageDetailed

-- | Things forbidden in <tt>type data</tt> declarations. See Note [Type
--   data declarations]
data TypeDataForbids
TypeDataForbidsDatatypeContexts :: TypeDataForbids
TypeDataForbidsLabelledFields :: TypeDataForbids
TypeDataForbidsStrictnessAnnotations :: TypeDataForbids
TypeDataForbidsDerivingClauses :: TypeDataForbids
data ErrInfo
ErrInfo :: !SDoc -> !SDoc -> ErrInfo

-- | Extra context associated to the error.
[errInfoContext] :: ErrInfo -> !SDoc

-- | Extra supplementary info associated to the error.
[errInfoSupplementary] :: ErrInfo -> !SDoc

-- | In what context did we require a type to have a fixed runtime
--   representation?
--   
--   Used by <a>checkTypeHasFixedRuntimeRep</a> for throwing representation
--   polymorphism errors when validity checking.
--   
--   See Note [Representation polymorphism checking] in
--   GHC.Tc.Utils.Concrete
data FixedRuntimeRepProvenance

-- | Data constructor fields must have a fixed runtime representation.
--   
--   Tests: T11734, T18534.
FixedRuntimeRepDataConField :: FixedRuntimeRepProvenance

-- | Pattern synonym signature arguments must have a fixed runtime
--   representation.
--   
--   Test: RepPolyPatSynArg.
FixedRuntimeRepPatSynSigArg :: FixedRuntimeRepProvenance

-- | Pattern synonym signature scrutinee must have a fixed runtime
--   representation.
--   
--   Test: RepPolyPatSynRes.
FixedRuntimeRepPatSynSigRes :: FixedRuntimeRepProvenance
pprFixedRuntimeRepProvenance :: FixedRuntimeRepProvenance -> SDoc

-- | Where a shadowed name comes from
data ShadowedNameProvenance

-- | The shadowed name is local to the module
ShadowedNameProvenanceLocal :: !SrcLoc -> ShadowedNameProvenance

-- | The shadowed name is global, typically imported from elsewhere.
ShadowedNameProvenanceGlobal :: [GlobalRdrElt] -> ShadowedNameProvenance

-- | Which parts of a record field are affected by a particular error or
--   warning.
data RecordFieldPart
RecordFieldDecl :: !Name -> RecordFieldPart
RecordFieldConstructor :: !Name -> RecordFieldPart
RecordFieldPattern :: !Name -> RecordFieldPart
RecordFieldUpdate :: RecordFieldPart

-- | Why the particular illegal newtype error arose together with more
--   information, if any.
data IllegalNewtypeReason
DoesNotHaveSingleField :: !Int -> IllegalNewtypeReason
IsNonLinear :: IllegalNewtypeReason
IsGADT :: IllegalNewtypeReason
HasConstructorContext :: IllegalNewtypeReason
HasExistentialTyVar :: IllegalNewtypeReason
HasStrictnessAnnotation :: IllegalNewtypeReason

-- | Why did we reject a record update?
data BadRecordUpdateReason

-- | No constructor has all of the required fields.
NoConstructorHasAllFields :: [FieldLabelString] -> BadRecordUpdateReason
[conflictingFields] :: BadRecordUpdateReason -> [FieldLabelString]

-- | There are several possible parents which have all of the required
--   fields, and we weren't able to disambiguate in any way.
MultiplePossibleParents :: (RecSelParent, RecSelParent, [RecSelParent]) -> BadRecordUpdateReason

-- | We used type-directed disambiguation, but this resulted in an invalid
--   parent (the type-directed parent is not among the parents we computed
--   from the field labels alone).
InvalidTyConParent :: TyCon -> NonEmpty RecSelParent -> BadRecordUpdateReason

-- | Why the particular injectivity error arose together with more
--   information, if any.
data InjectivityErrReason
InjErrRhsBareTyVar :: [Type] -> InjectivityErrReason
InjErrRhsCannotBeATypeFam :: InjectivityErrReason
InjErrRhsOverlap :: InjectivityErrReason
InjErrCannotInferFromRhs :: !TyVarSet -> !HasKinds -> !SuggestUndecidableInstances -> InjectivityErrReason
data HasKinds
YesHasKinds :: HasKinds
NoHasKinds :: HasKinds
hasKinds :: Bool -> HasKinds
data SuggestUndecidableInstances
YesSuggestUndecidableInstaces :: SuggestUndecidableInstances
NoSuggestUndecidableInstaces :: SuggestUndecidableInstances
suggestUndecidableInstances :: Bool -> SuggestUndecidableInstances
data SuggestUnliftedTypes
SuggestUnliftedNewtypes :: SuggestUnliftedTypes
SuggestUnliftedDatatypes :: SuggestUnliftedTypes

-- | A description of whether something is a
--   
--   <ul>
--   <li><tt>data</tt> or <tt>newtype</tt> (<a>DataDeclSort</a>)</li>
--   <li><tt>data instance</tt> or <tt>newtype instance</tt>
--   (<a>DataInstanceSort</a>)</li>
--   <li><tt>data family</tt> (<a>DataFamilySort</a>)</li>
--   </ul>
--   
--   At present, this data type is only consumed by
--   <tt>checkDataKindSig</tt>.
data DataSort
DataDeclSort :: NewOrData -> DataSort
DataInstanceSort :: NewOrData -> DataSort
DataFamilySort :: DataSort
ppDataSort :: DataSort -> SDoc

-- | Helper type used in <tt>checkDataKindSig</tt>.
--   
--   Superficially similar to <tt>ContextKind</tt>, but it lacks
--   <tt>AnyKind</tt> and <a>AnyBoxedKind</a>, and instead of
--   <tt><tt>TheKind</tt> liftedTypeKind</tt> provides <a>LiftedKind</a>,
--   which is much simpler to match on and handle in
--   <tt>isAllowedDataResKind</tt>.
data AllowedDataResKind
AnyTYPEKind :: AllowedDataResKind
AnyBoxedKind :: AllowedDataResKind
LiftedKind :: AllowedDataResKind

-- | A data type to describe why a variable is not closed. See Note
--   [Not-closed error messages] in GHC.Tc.Gen.Expr
data NotClosedReason
NotLetBoundReason :: NotClosedReason
NotTypeClosed :: VarSet -> NotClosedReason
NotClosed :: Name -> NotClosedReason -> NotClosedReason
data SuggestPartialTypeSignatures
YesSuggestPartialTypeSignatures :: SuggestPartialTypeSignatures
NoSuggestPartialTypeSignatures :: SuggestPartialTypeSignatures
suggestPartialTypeSignatures :: Bool -> SuggestPartialTypeSignatures

-- | Why a particular typeclass instance couldn't be derived.
data DeriveInstanceErrReason

-- | The typeclass instance is not well-kinded.
DerivErrNotWellKinded :: !TyCon -> !Kind -> !Int -> DeriveInstanceErrReason
DerivErrSafeHaskellGenericInst :: DeriveInstanceErrReason
DerivErrDerivingViaWrongKind :: !Kind -> !Type -> !Kind -> DeriveInstanceErrReason

-- | The instance type | We cannot derive instances in boot files
DerivErrNoEtaReduce :: !Type -> DeriveInstanceErrReason
DerivErrBootFileFound :: DeriveInstanceErrReason
DerivErrDataConsNotAllInScope :: !TyCon -> DeriveInstanceErrReason

-- | We cannot use GND on non-newtype types
DerivErrGNDUsedOnData :: DeriveInstanceErrReason

-- | We cannot derive instances of nullary classes
DerivErrNullaryClasses :: DeriveInstanceErrReason

-- | Last arg must be newtype or data application
DerivErrLastArgMustBeApp :: DeriveInstanceErrReason
DerivErrNoFamilyInstance :: !TyCon -> [Type] -> DeriveInstanceErrReason
DerivErrNotStockDeriveable :: !DeriveAnyClassEnabled -> DeriveInstanceErrReason
DerivErrHasAssociatedDatatypes :: !HasAssociatedDataFamInsts -> !AssociatedTyLastVarInKind -> !AssociatedTyNotParamOverLastTyVar -> DeriveInstanceErrReason
DerivErrNewtypeNonDeriveableClass :: DeriveInstanceErrReason
DerivErrCannotEtaReduceEnough :: !Bool -> DeriveInstanceErrReason
DerivErrOnlyAnyClassDeriveable :: !TyCon -> !DeriveAnyClassEnabled -> DeriveInstanceErrReason
DerivErrNotDeriveable :: !DeriveAnyClassEnabled -> DeriveInstanceErrReason

-- | The given <a>PredType</a> is not a class.
DerivErrNotAClass :: !PredType -> DeriveInstanceErrReason

-- | The given (representation of the) <a>TyCon</a> has no data
--   constructors.
DerivErrNoConstructors :: !TyCon -> DeriveInstanceErrReason
DerivErrLangExtRequired :: !Extension -> DeriveInstanceErrReason

-- | GHC simply doesn't how to how derive the input <a>Class</a> for the
--   given <a>Type</a>.
DerivErrDunnoHowToDeriveForType :: !Type -> DeriveInstanceErrReason

-- | The given <a>TyCon</a> must be an enumeration. See Note [Enumeration
--   types] in GHC.Core.TyCon
DerivErrMustBeEnumType :: !TyCon -> DeriveInstanceErrReason

-- | The given <a>TyCon</a> must have <i>precisely</i> one constructor.
DerivErrMustHaveExactlyOneConstructor :: !TyCon -> DeriveInstanceErrReason

-- | The given data type must have some parameters.
DerivErrMustHaveSomeParameters :: !TyCon -> DeriveInstanceErrReason

-- | The given data type must not have a class context.
DerivErrMustNotHaveClassContext :: !TyCon -> !ThetaType -> DeriveInstanceErrReason

-- | We couldn't derive an instance for a particular data constructor for a
--   variety of reasons.
DerivErrBadConstructor :: !Maybe HasWildcard -> [DeriveInstanceBadConstructor] -> DeriveInstanceErrReason

-- | We couldn't derive a <a>Generic</a> instance for the given type for a
--   variety of reasons
DerivErrGenerics :: [DeriveGenericsErrReason] -> DeriveInstanceErrReason

-- | We couldn't derive an instance either because the type was not an enum
--   type or because it did have more than one constructor.
DerivErrEnumOrProduct :: !DeriveInstanceErrReason -> !DeriveInstanceErrReason -> DeriveInstanceErrReason
data UsingGeneralizedNewtypeDeriving
YesGeneralizedNewtypeDeriving :: UsingGeneralizedNewtypeDeriving
NoGeneralizedNewtypeDeriving :: UsingGeneralizedNewtypeDeriving
usingGeneralizedNewtypeDeriving :: Bool -> UsingGeneralizedNewtypeDeriving
data DeriveAnyClassEnabled
YesDeriveAnyClassEnabled :: DeriveAnyClassEnabled
NoDeriveAnyClassEnabled :: DeriveAnyClassEnabled
deriveAnyClassEnabled :: Bool -> DeriveAnyClassEnabled
data DeriveInstanceBadConstructor

-- | The given <a>DataCon</a> must be truly polymorphic in the last
--   argument of the data type.
DerivErrBadConExistential :: !DataCon -> DeriveInstanceBadConstructor

-- | The given <a>DataCon</a> must not use the type variable in a function
--   argument"
DerivErrBadConCovariant :: !DataCon -> DeriveInstanceBadConstructor

-- | The given <a>DataCon</a> must not contain function types
DerivErrBadConFunTypes :: !DataCon -> DeriveInstanceBadConstructor

-- | The given <a>DataCon</a> must use the type variable only as the last
--   argument of a data type
DerivErrBadConWrongArg :: !DataCon -> DeriveInstanceBadConstructor

-- | The given <a>DataCon</a> is a GADT so we cannot directly derive an
--   istance for it.
DerivErrBadConIsGADT :: !DataCon -> DeriveInstanceBadConstructor

-- | The given <a>DataCon</a> has existentials type vars in its type.
DerivErrBadConHasExistentials :: !DataCon -> DeriveInstanceBadConstructor

-- | The given <a>DataCon</a> has constraints in its type.
DerivErrBadConHasConstraints :: !DataCon -> DeriveInstanceBadConstructor

-- | The given <a>DataCon</a> has a higher-rank type.
DerivErrBadConHasHigherRankType :: !DataCon -> DeriveInstanceBadConstructor
data HasWildcard
YesHasWildcard :: HasWildcard
NoHasWildcard :: HasWildcard
hasWildcard :: Bool -> HasWildcard

-- | A context in which we don't allow anonymous wildcards.
data BadAnonWildcardContext
WildcardNotLastInConstraint :: BadAnonWildcardContext
ExtraConstraintWildcardNotAllowed :: SoleExtraConstraintWildcardAllowed -> BadAnonWildcardContext
WildcardsNotAllowedAtAll :: BadAnonWildcardContext
WildcardBndrInForallTelescope :: BadAnonWildcardContext
WildcardBndrInTyFamResultVar :: BadAnonWildcardContext

-- | Whether a sole extra-constraint wildcard is allowed, e.g. <tt>_ =&gt;
--   ..</tt> as opposed to <tt>( .., _ ) =&gt; ..</tt>.
data SoleExtraConstraintWildcardAllowed
SoleExtraConstraintWildcardNotAllowed :: SoleExtraConstraintWildcardAllowed
SoleExtraConstraintWildcardAllowed :: SoleExtraConstraintWildcardAllowed
data DeriveGenericsErrReason

-- | The type must not have some datatype context.
DerivErrGenericsMustNotHaveDatatypeContext :: !TyCon -> DeriveGenericsErrReason

-- | The data constructor must not have exotic unlifted or polymorphic
--   arguments.
DerivErrGenericsMustNotHaveExoticArgs :: !DataCon -> DeriveGenericsErrReason

-- | The data constructor must be a vanilla constructor.
DerivErrGenericsMustBeVanillaDataCon :: !DataCon -> DeriveGenericsErrReason

-- | The type must have some type parameters. check (d) from Note
--   [Requirements for deriving Generic and Rep] in GHC.Tc.Deriv.Generics.
DerivErrGenericsMustHaveSomeTypeParams :: !TyCon -> DeriveGenericsErrReason

-- | The data constructor must not have existential arguments.
DerivErrGenericsMustNotHaveExistentials :: !DataCon -> DeriveGenericsErrReason

-- | The derivation applies a type to an argument involving the last
--   parameter but the applied type is not of kind * -&gt; *.
DerivErrGenericsWrongArgKind :: !DataCon -> DeriveGenericsErrReason

-- | A type representing whether or not the input type has associated data
--   family instances.
data HasAssociatedDataFamInsts
YesHasAdfs :: HasAssociatedDataFamInsts
NoHasAdfs :: HasAssociatedDataFamInsts
hasAssociatedDataFamInsts :: Bool -> HasAssociatedDataFamInsts

-- | If <a>YesAssocTyLastVarInKind</a>, the associated type of a typeclass
--   contains the last type variable of the class in a kind, which is not
--   (yet) allowed by GHC.
data AssociatedTyLastVarInKind

-- | The associated type family of the class
YesAssocTyLastVarInKind :: !TyCon -> AssociatedTyLastVarInKind
NoAssocTyLastVarInKind :: AssociatedTyLastVarInKind
associatedTyLastVarInKind :: Maybe TyCon -> AssociatedTyLastVarInKind

-- | If <a>NoAssociatedTyNotParamOverLastTyVar</a>, the associated type of
--   a typeclass is not parameterized over the last type variable of the
--   class
data AssociatedTyNotParamOverLastTyVar

-- | The associated type family of the class
YesAssociatedTyNotParamOverLastTyVar :: !TyCon -> AssociatedTyNotParamOverLastTyVar
NoAssociatedTyNotParamOverLastTyVar :: AssociatedTyNotParamOverLastTyVar
associatedTyNotParamOverLastTyVar :: Maybe TyCon -> AssociatedTyNotParamOverLastTyVar

-- | What kind of thing is missing a type signature?
--   
--   Used for reporting <tt>"missing signature"</tt> warnings, see
--   <tt>tcRnMissingSignature</tt>.
data MissingSignature
MissingTopLevelBindingSig :: Name -> Type -> MissingSignature
MissingPatSynSig :: PatSyn -> MissingSignature

-- | whether -XCUSKs is enabled
MissingTyConKindSig :: TyCon -> Bool -> MissingSignature

-- | Is the object we are dealing with exported or not?
--   
--   Used for reporting <tt>"missing signature"</tt> warnings, see
--   <a>TcRnMissingSignature</a>.
data Exported
IsNotExported :: Exported
IsExported :: Exported
data HsDocContext
TypeSigCtx :: SDoc -> HsDocContext
StandaloneKindSigCtx :: SDoc -> HsDocContext
PatCtx :: HsDocContext
SpecInstSigCtx :: HsDocContext
DefaultDeclCtx :: HsDocContext
ForeignDeclCtx :: LocatedN RdrName -> HsDocContext
DerivDeclCtx :: HsDocContext
RuleCtx :: FastString -> HsDocContext
TyDataCtx :: LocatedN RdrName -> HsDocContext
TySynCtx :: LocatedN RdrName -> HsDocContext
TyFamilyCtx :: LocatedN RdrName -> HsDocContext
FamPatCtx :: LocatedN RdrName -> HsDocContext
ConDeclCtx :: [LocatedN Name] -> HsDocContext
ClassDeclCtx :: LocatedN RdrName -> HsDocContext
ExprWithTySigCtx :: HsDocContext
TypBrCtx :: HsDocContext
HsTypeCtx :: HsDocContext
HsTypePatCtx :: HsDocContext
GHCiCtx :: HsDocContext
SpliceTypeCtx :: LHsType GhcPs -> HsDocContext
ClassInstanceCtx :: HsDocContext
GenericCtx :: SDoc -> HsDocContext

-- | Stores the information to be reported in a representation-polymorphism
--   error message.
data FixedRuntimeRepErrorInfo
FRR_Info :: FixedRuntimeRepOrigin -> Maybe (TcTyVar, TcType) -> FixedRuntimeRepErrorInfo

-- | What is the original type we checked for representation-polymorphism,
--   and what specific check did we perform?
[frr_info_origin] :: FixedRuntimeRepErrorInfo -> FixedRuntimeRepOrigin

-- | Which non-concrete type did we try to unify this concrete type
--   variable with?
[frr_info_not_concrete] :: FixedRuntimeRepErrorInfo -> Maybe (TcTyVar, TcType)
data TcRnNoDerivStratSpecifiedInfo

-- | 'TcRnNoDerivStratSpecified TcRnNoDerivingClauseStrategySpecified' is a
--   warning implied by -Wmissing-deriving-strategies and triggered by a
--   deriving clause without a specified deriving strategy.
--   
--   Example:
--   
--   newtype T = T Int deriving (Eq, Ord, Show)
--   
--   Here we would suggest fixing the deriving clause to:
--   
--   deriving stock (Show) deriving newtype (Eq, Ord)
--   
--   Test cases: deriving<i>should_compile</i>T15798a
--   deriving<i>should_compile</i>T15798c
--   deriving<i>should_compile</i>T24955a
--   deriving<i>should_compile</i>T24955b
[TcRnNoDerivingClauseStrategySpecified] :: Map AssumedDerivingStrategy [LHsSigType GhcRn] -> TcRnNoDerivStratSpecifiedInfo

-- | 'TcRnNoDerivStratSpecified TcRnNoStandaloneDerivingStrategySpecified'
--   is a warning implied by -Wmissing-deriving-strategies and triggered by
--   a standalone deriving declaration without a specified deriving
--   strategy.
--   
--   Example:
--   
--   data T a = T a deriving instance Show a =&gt; Show (T a)
--   
--   Here we would suggest fixing the instance to:
--   
--   deriving stock instance Show a =&gt; Show (T a)
--   
--   Test cases: deriving<i>should_compile</i>T15798b
--   deriving<i>should_compile</i>T24955c
[TcRnNoStandaloneDerivingStrategySpecified] :: AssumedDerivingStrategy -> LHsSigWcType GhcRn -> TcRnNoDerivStratSpecifiedInfo

-- | A predicate with its arising location; used to encapsulate a
--   constraint that will give rise to a diagnostic.
data ErrorItem
EI :: PredType -> Maybe TcEvDest -> CtFlavour -> CtLoc -> Maybe CtIrredReason -> Bool -> ErrorItem
[ei_pred] :: ErrorItem -> PredType

-- | for Wanteds, where to put the evidence for Givens, Nothing
[ei_evdest] :: ErrorItem -> Maybe TcEvDest
[ei_flavour] :: ErrorItem -> CtFlavour
[ei_loc] :: ErrorItem -> CtLoc
[ei_m_reason] :: ErrorItem -> Maybe CtIrredReason
[ei_suppress] :: ErrorItem -> Bool
errorItemOrigin :: ErrorItem -> CtOrigin
errorItemEqRel :: ErrorItem -> EqRel
errorItemPred :: ErrorItem -> PredType
errorItemCtLoc :: ErrorItem -> CtLoc

-- | A collection of main error messages and supplementary information.
--   
--   In practice, we will: - display the important messages first, - then
--   the error context (e.g. by way of a call to <a>mkErrorReport</a>), -
--   then the supplementary information (e.g. relevant bindings, valid hole
--   fits), - then the hints ("Possible fix: ...").
--   
--   So this is mostly just a way of making sure that the error context
--   appears early on rather than at the end of the message.
--   
--   See Note [Error report] for details.
data SolverReport
SolverReport :: SolverReportWithCtxt -> [SolverReportSupplementary] -> SolverReport
[sr_important_msg] :: SolverReport -> SolverReportWithCtxt
[sr_supplementary] :: SolverReport -> [SolverReportSupplementary]

-- | Additional information to print in a <a>SolverReport</a>, after the
--   important messages and after the error context.
--   
--   See Note [Error report].
data SolverReportSupplementary
SupplementaryBindings :: RelevantBindings -> SolverReportSupplementary
SupplementaryHoleFits :: ValidHoleFits -> SolverReportSupplementary
SupplementaryCts :: [(PredType, RealSrcSpan)] -> SolverReportSupplementary

-- | A <a>TcSolverReportMsg</a>, together with context (e.g. enclosing
--   implication constraints) that are needed in order to report it.
data SolverReportWithCtxt
SolverReportWithCtxt :: SolverReportErrCtxt -> TcSolverReportMsg -> SolverReportWithCtxt

-- | Context for what we wish to report. This can change as we enter
--   implications, so is stored alongside the content.
[reportContext] :: SolverReportWithCtxt -> SolverReportErrCtxt

-- | The content of the message to report.
[reportContent] :: SolverReportWithCtxt -> TcSolverReportMsg

-- | Context needed when reporting a <a>TcSolverReportMsg</a>, such as the
--   enclosing implication constraints or whether we are deferring type
--   errors.
data SolverReportErrCtxt
CEC :: [Implication] -> TidyEnv -> EvBindsVar -> DiagnosticReason -> DiagnosticReason -> DiagnosticReason -> DiagnosticReason -> Bool -> Bool -> Bool -> SolverReportErrCtxt

-- | Enclosing implications (innermost first) ic_skols and givens are
--   tidied, rest are not
[cec_encl] :: SolverReportErrCtxt -> [Implication]
[cec_tidy] :: SolverReportErrCtxt -> TidyEnv

-- | We make some errors (depending on cec_defer) into warnings, and emit
--   evidence bindings into <a>cec_binds</a> for unsolved constraints
[cec_binds] :: SolverReportErrCtxt -> EvBindsVar

-- | Whether to defer type errors until runtime
[cec_defer_type_errors] :: SolverReportErrCtxt -> DiagnosticReason

-- | Reason for reporting holes in expressions.
[cec_expr_holes] :: SolverReportErrCtxt -> DiagnosticReason

-- | Reason for reporting holes in types.
[cec_type_holes] :: SolverReportErrCtxt -> DiagnosticReason

-- | Reason for reporting out of scope holes.
[cec_out_of_scope_holes] :: SolverReportErrCtxt -> DiagnosticReason

-- | True <a>=</a> -Wredundant-constraints
[cec_warn_redundant] :: SolverReportErrCtxt -> Bool

-- | True <a>=</a> -fprint-expanded-synonyms
[cec_expand_syns] :: SolverReportErrCtxt -> Bool

-- | True <a>=</a> More important errors have occurred, so create bindings
--   if need be, but don't issue any more errors/warnings See Note
--   [Suppressing error messages]
[cec_suppress] :: SolverReportErrCtxt -> Bool
getUserGivens :: SolverReportErrCtxt -> [UserGiven]
discardProvCtxtGivens :: CtOrigin -> [UserGiven] -> [UserGiven]

-- | An error reported after constraint solving. This is usually, some sort
--   of unsolved constraint error, but we try to be specific about the
--   precise problem we encountered.
data TcSolverReportMsg

-- | Quantified variables appear out of dependency order.
--   
--   Example:
--   
--   forall (a :: k) k. ...
--   
--   Test cases: BadTelescope2, T16418, T16247, T16726, T18451.
BadTelescope :: TyVarBndrs -> [TyCoVar] -> TcSolverReportMsg

-- | We came across a custom type error and we have decided to report it.
--   
--   Example:
--   
--   type family F a where F a = TypeError (Text "error")
--   
--   err :: F () err = ()
--   
--   Test cases: CustomTypeErrors0{1,2,3,4,5}, T12104.
UserTypeError :: ErrorMsgType -> TcSolverReportMsg

-- | Report a Wanted constraint of the form "Unsatisfiable msg".
UnsatisfiableError :: ErrorMsgType -> TcSolverReportMsg

-- | We want to report an out of scope variable or a typed hole. See
--   <a>HoleError</a>.
ReportHoleError :: Hole -> HoleError -> TcSolverReportMsg

-- | Cannot unify a variable, because of a type mismatch.
CannotUnifyVariable :: MismatchMsg -> CannotUnifyVariableReason -> TcSolverReportMsg
[mismatchMsg] :: TcSolverReportMsg -> MismatchMsg
[cannotUnifyReason] :: TcSolverReportMsg -> CannotUnifyVariableReason

-- | A mismatch between two types.
Mismatch :: MismatchMsg -> Maybe TyVarInfo -> [AmbiguityInfo] -> Maybe CoercibleMsg -> TcSolverReportMsg
[mismatchMsg] :: TcSolverReportMsg -> MismatchMsg
[mismatchTyVarInfo] :: TcSolverReportMsg -> Maybe TyVarInfo
[mismatchAmbiguityInfo] :: TcSolverReportMsg -> [AmbiguityInfo]
[mismatchCoercibleInfo] :: TcSolverReportMsg -> Maybe CoercibleMsg

-- | A violation of the representation-polymorphism invariants.
--   
--   See <a>FixedRuntimeRepErrorInfo</a> and
--   <tt>FixedRuntimeRepContext</tt> for more information.
FixedRuntimeRepError :: [FixedRuntimeRepErrorInfo] -> TcSolverReportMsg

-- | An equality between two types is blocked on a kind equality between
--   their kinds.
--   
--   Test cases: none.
BlockedEquality :: ErrorItem -> TcSolverReportMsg

-- | Something was not applied to sufficiently many arguments.
--   
--   Example:
--   
--   instance Eq Maybe where {..}
--   
--   Test case: T11563.
ExpectingMoreArguments :: Int -> TypedThing -> TcSolverReportMsg

-- | Trying to use an unbound implicit parameter.
--   
--   Example:
--   
--   foo :: Int foo = ?param
--   
--   Test case: tcfail130.
UnboundImplicitParams :: NonEmpty ErrorItem -> TcSolverReportMsg

-- | A constraint couldn't be solved because it contains ambiguous type
--   variables.
--   
--   Example:
--   
--   class C a b where f :: (a,b)
--   
--   x = fst f
--   
--   Test case: T4921.
AmbiguityPreventsSolvingCt :: ErrorItem -> ([TyVar], [TyVar]) -> TcSolverReportMsg

-- | Could not solve a constraint; there were several unifying candidate
--   instances but no matching instances. This is used to report as much
--   useful information as possible about why we couldn't choose any
--   instance, e.g. because of ambiguous type variables.
CannotResolveInstance :: ErrorItem -> [ClsInst] -> [ClsInst] -> [ImportError] -> [GhcHint] -> RelevantBindings -> TcSolverReportMsg
[cannotResolve_item] :: TcSolverReportMsg -> ErrorItem
[cannotResolve_unifiers] :: TcSolverReportMsg -> [ClsInst]
[cannotResolve_candidates] :: TcSolverReportMsg -> [ClsInst]
[cannotResolve_importErrors] :: TcSolverReportMsg -> [ImportError]
[cannotResolve_suggestions] :: TcSolverReportMsg -> [GhcHint]
[cannotResolve_relevant_bindings] :: TcSolverReportMsg -> RelevantBindings

-- | Could not solve a constraint using available instances because the
--   instances overlap.
--   
--   Test cases: tcfail118, tcfail121, tcfail218.
OverlappingInstances :: ErrorItem -> NonEmpty ClsInst -> [ClsInst] -> TcSolverReportMsg
[overlappingInstances_item] :: TcSolverReportMsg -> ErrorItem
[overlappingInstances_matches] :: TcSolverReportMsg -> NonEmpty ClsInst
[overlappingInstances_unifiers] :: TcSolverReportMsg -> [ClsInst]

-- | Could not solve a constraint from instances because instances declared
--   in a Safe module cannot overlap instances from other modules (with
--   -XSafeHaskell).
--   
--   Test cases: SH_Overlap{1,2,5,6,7,11}.
UnsafeOverlap :: ErrorItem -> ClsInst -> NonEmpty ClsInst -> TcSolverReportMsg
[unsafeOverlap_item] :: TcSolverReportMsg -> ErrorItem
[unsafeOverlap_match] :: TcSolverReportMsg -> ClsInst
[unsafeOverlapped] :: TcSolverReportMsg -> NonEmpty ClsInst
data CannotUnifyVariableReason

-- | A type equality between a type variable and a polytype.
--   
--   Test cases: T12427a, T2846b, T10194, ...
CannotUnifyWithPolytype :: ErrorItem -> TyVar -> Type -> Maybe TyVarInfo -> CannotUnifyVariableReason

-- | An occurs check.
OccursCheck :: [TyVar] -> [AmbiguityInfo] -> CannotUnifyVariableReason
[occursCheckInterestingTyVars] :: CannotUnifyVariableReason -> [TyVar]
[occursCheckAmbiguityInfos] :: CannotUnifyVariableReason -> [AmbiguityInfo]

-- | A skolem type variable escapes its scope.
--   
--   Example:
--   
--   data Ex where { MkEx :: a -&gt; MkEx } foo (MkEx x) = x
--   
--   Test cases: TypeSkolEscape, T11142.
SkolemEscape :: ErrorItem -> Implication -> [TyVar] -> CannotUnifyVariableReason

-- | Can't unify the type variable with the other type due to the kind of
--   type variable it is.
--   
--   For example, trying to unify a <tt>SkolemTv</tt> with the type Int, or
--   with a <tt>TyVarTv</tt>.
DifferentTyVars :: TyVarInfo -> CannotUnifyVariableReason
RepresentationalEq :: TyVarInfo -> Maybe CoercibleMsg -> CannotUnifyVariableReason
data MismatchMsg

-- | Couldn't unify two types or kinds.
--   
--   Example:
--   
--   3 + 3# -- can't match a lifted type with an unlifted type
--   
--   Test cases: T1396, T8263, ...
BasicMismatch :: MismatchEA -> ErrorItem -> Type -> Type -> Maybe WhenMatching -> Maybe SameOccInfo -> MismatchMsg

-- | Should this be phrased in terms of expected vs actual?
[mismatch_ea] :: MismatchMsg -> MismatchEA

-- | The constraint in which the mismatch originated.
[mismatch_item] :: MismatchMsg -> ErrorItem

-- | First type (the expected type if if mismatch_ea is True)
[mismatch_ty1] :: MismatchMsg -> Type

-- | Second type (the actual type if mismatch_ea is True)
[mismatch_ty2] :: MismatchMsg -> Type
[mismatch_whenMatching] :: MismatchMsg -> Maybe WhenMatching
[mismatch_mb_same_occ] :: MismatchMsg -> Maybe SameOccInfo

-- | A type has an unexpected kind.
--   
--   Test cases: T2994, T7609, ...
KindMismatch :: TypedThing -> Type -> Type -> MismatchMsg

-- | What thing is <a>kmismatch_actual</a> the kind of?
[kmismatch_what] :: MismatchMsg -> TypedThing
[kmismatch_expected] :: MismatchMsg -> Type
[kmismatch_actual] :: MismatchMsg -> Type

-- | A mismatch between two types, which arose from a type equality.
--   
--   Test cases: T1470, tcfail212.
TypeEqMismatch :: ErrorItem -> Type -> Type -> Type -> Type -> Maybe TypedThing -> Maybe SameOccInfo -> MismatchMsg
[teq_mismatch_item] :: MismatchMsg -> ErrorItem
[teq_mismatch_ty1] :: MismatchMsg -> Type
[teq_mismatch_ty2] :: MismatchMsg -> Type

-- | The overall expected type
[teq_mismatch_expected] :: MismatchMsg -> Type

-- | The overall actual type
[teq_mismatch_actual] :: MismatchMsg -> Type

-- | What thing is <a>teq_mismatch_actual</a> the kind of?
[teq_mismatch_what] :: MismatchMsg -> Maybe TypedThing
[teq_mb_same_occ] :: MismatchMsg -> Maybe SameOccInfo

-- | Couldn't solve some Wanted constraints using the Givens. Used for
--   messages such as <tt>"No instance for ..."</tt> and <tt>"Could not
--   deduce ... from"</tt>.
CouldNotDeduce :: [Implication] -> NonEmpty ErrorItem -> Maybe CND_Extra -> MismatchMsg
[cnd_user_givens] :: MismatchMsg -> [Implication]

-- | The Wanted constraints we couldn't solve.
--   
--   N.B.: the <a>ErrorItem</a> at the head of the list has been tidied,
--   perhaps not the others.
[cnd_wanted] :: MismatchMsg -> NonEmpty ErrorItem

-- | Some additional info consumed by <tt>mk_supplementary_ea_msg</tt>.
[cnd_extra] :: MismatchMsg -> Maybe CND_Extra

-- | Whether to use expected/actual in a type mismatch message.
data MismatchEA

-- | Don't use expected/actual.
NoEA :: MismatchEA

-- | Use expected/actual.
EA :: Maybe ExpectedActualInfo -> MismatchEA

-- | Whether to also mention type synonym expansion.
[mismatch_mbEA] :: MismatchEA -> Maybe ExpectedActualInfo

-- | Report a mismatch error without any extra information.
mkPlainMismatchMsg :: MismatchMsg -> TcSolverReportMsg

-- | Construct a basic mismatch message between two types.
--   
--   See <tt>pprMismatchMsg</tt> for how such a message is displayed to
--   users.
mkBasicMismatchMsg :: MismatchEA -> ErrorItem -> Type -> Type -> MismatchMsg

-- | Explain how a kind equality originated.
data WhenMatching
WhenMatching :: TcType -> TcType -> CtOrigin -> Maybe TypeOrKind -> WhenMatching

-- | Expected/actual information.
data ExpectedActualInfo

-- | Display the expected and actual types.
ExpectedActual :: Type -> Type -> ExpectedActualInfo
[ea_expected] :: ExpectedActualInfo -> Type
[ea_actual] :: ExpectedActualInfo -> Type

-- | Display the expected and actual types, after expanding type synonyms.
ExpectedActualAfterTySynExpansion :: Type -> Type -> ExpectedActualInfo
[ea_expanded_expected] :: ExpectedActualInfo -> Type
[ea_expanded_actual] :: ExpectedActualInfo -> Type

-- | A cue to print out information about type variables, e.g. where they
--   were bound, when there is a mismatch <tt>tv1 ~ ty2</tt>.
data TyVarInfo
TyVarInfo :: TyVar -> Maybe Implication -> Maybe TyVar -> TyVarInfo
[thisTyVar] :: TyVarInfo -> TyVar
[thisTyVarIsUntouchable] :: TyVarInfo -> Maybe Implication
[otherTy] :: TyVarInfo -> Maybe TyVar

-- | Add some information to disambiguate errors in which two
--   <tt>Names</tt> would otherwise appear to be identical.
--   
--   See Note [Disambiguating (X ~ X) errors].
data SameOccInfo
SameOcc :: Bool -> Name -> Name -> SameOccInfo

-- | Whether the two <a>Name</a>s also came from the same package.
[sameOcc_same_pkg] :: SameOccInfo -> Bool
[sameOcc_lhs] :: SameOccInfo -> Name
[sameOcc_rhs] :: SameOccInfo -> Name

-- | Add some information about ambiguity
data AmbiguityInfo

-- | Some type variables remained ambiguous: print them to the user.
Ambiguity :: Bool -> ([TyVar], [TyVar]) -> AmbiguityInfo

-- | True <a>=</a> start the message with "Ambiguous type variable ..."
--   False <a>=</a> create a message of the form "The type variable is
--   ambiguous."
[lead_with_ambig_msg] :: AmbiguityInfo -> Bool

-- | Ambiguous kind and type variables, respectively. Guaranteed to not
--   both be empty.
[ambig_tyvars] :: AmbiguityInfo -> ([TyVar], [TyVar])

-- | Remind the user that a particular type family is not injective.
NonInjectiveTyFam :: TyCon -> AmbiguityInfo

-- | Additional information to be given in a <a>CouldNotDeduce</a> message,
--   which is then passed on to <tt>mk_supplementary_ea_msg</tt>.
data CND_Extra
CND_Extra :: TypeOrKind -> Type -> Type -> CND_Extra

-- | A collection of valid hole fits or refinement fits, in which some fits
--   might have been suppressed.
data FitsMbSuppressed
Fits :: [HoleFit] -> Bool -> FitsMbSuppressed
[fits] :: FitsMbSuppressed -> [HoleFit]

-- | Whether we have suppressed any fits because there were too many.
[fitsSuppressed] :: FitsMbSuppressed -> Bool

-- | A collection of hole fits and refinement fits.
data ValidHoleFits
ValidHoleFits :: FitsMbSuppressed -> FitsMbSuppressed -> ValidHoleFits
[holeFits] :: ValidHoleFits -> FitsMbSuppressed
[refinementFits] :: ValidHoleFits -> FitsMbSuppressed
noValidHoleFits :: ValidHoleFits

-- | Configuration for pretty-printing valid hole fits.
data HoleFitDispConfig
HFDC :: Bool -> Bool -> Bool -> Bool -> Bool -> HoleFitDispConfig
[showWrap] :: HoleFitDispConfig -> Bool
[showWrapVars] :: HoleFitDispConfig -> Bool
[showType] :: HoleFitDispConfig -> Bool
[showProv] :: HoleFitDispConfig -> Bool
[showMatches] :: HoleFitDispConfig -> Bool
data RelevantBindings
RelevantBindings :: [(Name, Type)] -> Bool -> RelevantBindings
[relevantBindingNamesAndTys] :: RelevantBindings -> [(Name, Type)]

-- | Whether we ran out of fuel generating the bindings.
[ranOutOfFuel] :: RelevantBindings -> Bool

-- | Display some relevant bindings.
pprRelevantBindings :: RelevantBindings -> SDoc
data PromotionErr
TyConPE :: PromotionErr
ClassPE :: PromotionErr
FamDataConPE :: PromotionErr
ConstrainedDataConPE :: ThetaType -> PromotionErr
PatSynPE :: PromotionErr
RecDataConPE :: PromotionErr
TermVariablePE :: PromotionErr
TypeVariablePE :: PromotionErr
pprPECategory :: PromotionErr -> SDoc
peCategory :: PromotionErr -> String
data TermLevelUseErr
TyConTE :: TermLevelUseErr
ClassTE :: TermLevelUseErr
TyVarTE :: TermLevelUseErr
teCategory :: TermLevelUseErr -> String

-- | Some form of <tt>"not in scope"</tt> error. See also the
--   <a>OutOfScopeHole</a> constructor of <a>HoleError</a>.
data NotInScopeError

-- | A run-of-the-mill <tt>"not in scope"</tt> error.
NotInScope :: NotInScopeError

-- | Like <a>NotInScope</a>, but when we know we are looking for a record
--   field.
NotARecordField :: NotInScopeError

-- | An exact <a>Name</a> was not in scope.
--   
--   This usually indicates a problem with a Template Haskell splice.
--   
--   Test cases: T5971, T18263.
NoExactName :: Name -> NotInScopeError

-- | always at least 2 elements
SameName :: [GlobalRdrElt] -> NotInScopeError
MissingBinding :: SDoc -> [GhcHint] -> NotInScopeError

-- | Couldn't find a top-level binding.
--   
--   Happens when specifying an annotation for something that is not in
--   scope.
--   
--   Test cases: annfail01, annfail02, annfail11.
NoTopLevelBinding :: NotInScopeError

-- | A class doesn't have a method with this name, or, a class doesn't have
--   an associated type with this name, or, a record doesn't have a record
--   field with this name.
UnknownSubordinate :: SDoc -> NotInScopeError

-- | A name is not in scope during type checking but passed the renamer.
--   
--   Test cases: none
NotInScopeTc :: NameEnv TcTyThing -> NotInScopeError

-- | Create a <tt>"not in scope"</tt> error message for the given
--   <a>RdrName</a>.
mkTcRnNotInScope :: RdrName -> NotInScopeError -> TcRnMessage

-- | Explain a problem with an import.
data ImportError

-- | Couldn't find a module with the requested name.
MissingModule :: ModuleName -> ImportError

-- | The imported modules don't export what we're looking for.
ModulesDoNotExport :: NonEmpty Module -> OccName -> ImportError

-- | Report an error involving a <a>Hole</a>.
--   
--   This could be an out of scope data constructor or variable, a typed
--   hole, or a wildcard in a type.
data HoleError

-- | Report an out-of-scope data constructor or variable masquerading as an
--   expression hole.
--   
--   See Note [Insoluble holes] in GHC.Tc.Types.Constraint. See
--   <a>NotInScopeError</a> for other not-in-scope errors.
--   
--   Test cases: T9177a.
OutOfScopeHole :: [ImportError] -> [GhcHint] -> HoleError

-- | Report a typed hole, or wildcard, with additional information.
HoleError :: HoleSort -> [TcTyVar] -> [(SkolemInfoAnon, [TcTyVar])] -> HoleError

-- | A message that aims to explain why two types couldn't be seen to be
--   representationally equal.
data CoercibleMsg

-- | Not knowing the role of a type constructor prevents us from concluding
--   that two types are representationally equal.
--   
--   Example:
--   
--   foo :: Applicative m =&gt; m (Sum Int) foo = coerce (pure $ 1 :: Int)
--   
--   We don't know what role <tt>m</tt> has, so we can't coerce `m Int` to
--   `m (Sum Int)`.
--   
--   Test cases: T8984, TcCoercibleFail.
UnknownRoles :: Type -> CoercibleMsg

-- | The fact that a <a>TyCon</a> is abstract prevents us from decomposing
--   a <tt>TyConApp</tt> and deducing that two types are representationally
--   equal.
--   
--   Test cases: none.
TyConIsAbstract :: TyCon -> CoercibleMsg

-- | We can't unwrap a newtype whose constructor is not in scope.
--   
--   Example:
--   
--   import Data.Ord (Down) -- NB: not importing the constructor foo :: Int
--   -&gt; Down Int foo = coerce
--   
--   Test cases: TcCoercibleFail.
OutOfScopeNewtypeConstructor :: TyCon -> DataCon -> CoercibleMsg

-- | This datatype collates instances that match or unifier, in order to
--   report an error message for an unsolved typeclass constraint.
data PotentialInstances
PotentialInstances :: [ClsInst] -> [ClsInst] -> PotentialInstances
[matches] :: PotentialInstances -> [ClsInst]
[unifiers] :: PotentialInstances -> [ClsInst]

-- | Specifies which calling convention is unsupported on the current
--   platform
data UnsupportedCallConvention
StdCallConvUnsupported :: UnsupportedCallConvention
PrimCallConvUnsupported :: UnsupportedCallConvention
JavaScriptCallConvUnsupported :: UnsupportedCallConvention

-- | Specifies which back ends can handle a requested foreign import or
--   export
type ExpectedBackends = [Backend]

-- | Whether the error pertains to a function argument or a result.
data ArgOrResult
Arg :: ArgOrResult
Result :: ArgOrResult

-- | Context for a mismatch in the number of arguments
data MatchArgsContext

-- | Name of the function
EquationArgs :: !Name -> MatchArgsContext

-- | Pattern match specifics
PatternArgs :: !HsMatchContextRn -> MatchArgsContext

-- | The information necessary to report mismatched numbers of arguments in
--   a match group.
data MatchArgBadMatches
[MatchArgMatches] :: forall body. LocatedA (Match GhcRn body) -> NonEmpty (LocatedA (Match GhcRn body)) -> MatchArgBadMatches
data PragmaWarningInfo
PragmaWarningName :: OccName -> ModuleName -> ModuleName -> PragmaWarningInfo
[pwarn_occname] :: PragmaWarningInfo -> OccName
[pwarn_impmod] :: PragmaWarningInfo -> ModuleName
[pwarn_declmod] :: PragmaWarningInfo -> ModuleName
PragmaWarningExport :: OccName -> ModuleName -> PragmaWarningInfo
[pwarn_occname] :: PragmaWarningInfo -> OccName
[pwarn_impmod] :: PragmaWarningInfo -> ModuleName
PragmaWarningInstance :: DFunId -> CtOrigin -> PragmaWarningInfo
[pwarn_dfunid] :: PragmaWarningInfo -> DFunId
[pwarn_ctorig] :: PragmaWarningInfo -> CtOrigin
PragmaWarningDefault :: TyCon -> ModuleName -> PragmaWarningInfo
[pwarn_class] :: PragmaWarningInfo -> TyCon
[pwarn_impmod] :: PragmaWarningInfo -> ModuleName

-- | The context for an "empty statement group" error.
data EmptyStatementGroupErrReason

-- | Empty statement group in a parallel list comprehension
EmptyStmtsGroupInParallelComp :: EmptyStatementGroupErrReason

-- | Empty statement group in a transform list comprehension
--   
--   Example: [() | then ()]
EmptyStmtsGroupInTransformListComp :: EmptyStatementGroupErrReason

-- | Empty statement group in do notation
--   
--   Example: do
EmptyStmtsGroupInDoNotation :: HsDoFlavour -> EmptyStatementGroupErrReason

-- | Empty statement group in arrow notation
--   
--   Example: proc () -&gt; do
EmptyStmtsGroupInArrowNotation :: EmptyStatementGroupErrReason

-- | An existential wrapper around <tt><a>StmtLR</a> GhcPs GhcPs body</tt>.
data UnexpectedStatement
[UnexpectedStatement] :: forall body. Outputable (StmtLR GhcPs GhcPs body) => StmtLR GhcPs GhcPs body -> UnexpectedStatement
data DeclSort
ClassDeclSort :: DeclSort
InstanceDeclSort :: DeclSort
data NonStandardGuards
[NonStandardGuards] :: forall body. (Outputable body, Anno (Stmt GhcRn body) ~ SrcSpanAnnA) => [LStmtLR GhcRn GhcRn body] -> NonStandardGuards
data RuleLhsErrReason
UnboundVariable :: RdrName -> NotInScopeError -> RuleLhsErrReason
IllegalExpression :: RuleLhsErrReason
data HsigShapeMismatchReason

-- | HsigShapeSortMismatch is an error indicating that an item in the
--   export list of a signature doesn't match the item of the same name in
--   another signature when merging the two – one is a type while the other
--   is a plain identifier.
--   
--   Test cases: none
HsigShapeSortMismatch :: !AvailInfo -> !AvailInfo -> HsigShapeMismatchReason

-- | HsigShapeNotUnifiable is an error indicating that a name in the export
--   list of a signature cannot be unified with a name of the same name in
--   another signature when merging the two.
--   
--   Test cases: bkpfail20, bkpfail21
HsigShapeNotUnifiable :: !Name -> !Name -> !Bool -> HsigShapeMismatchReason
data WrongThingSort
WrongThingType :: WrongThingSort
WrongThingDataCon :: WrongThingSort
WrongThingPatSyn :: WrongThingSort
WrongThingConLike :: WrongThingSort
WrongThingClass :: WrongThingSort
WrongThingTyCon :: WrongThingSort
WrongThingAxiom :: WrongThingSort
data StageCheckReason
StageCheckInstance :: !InstanceWhat -> !PredType -> StageCheckReason
StageCheckSplice :: !Name -> StageCheckReason
data UninferrableTyVarCtx
UninfTyCtx_ClassContext :: [TcType] -> UninferrableTyVarCtx
UninfTyCtx_DataContext :: [TcType] -> UninferrableTyVarCtx
UninfTyCtx_ProvidedContext :: [TcType] -> UninferrableTyVarCtx
UninfTyCtx_TyFamRhs :: TcType -> UninferrableTyVarCtx
UninfTyCtx_TySynRhs :: TcType -> UninferrableTyVarCtx
UninfTyCtx_Sig :: TcType -> LHsSigType GhcRn -> UninferrableTyVarCtx
data PatSynInvalidRhsReason
PatSynNotInvertible :: !Pat GhcRn -> PatSynInvalidRhsReason
PatSynUnboundVar :: !Name -> PatSynInvalidRhsReason
data BadFieldAnnotationReason

-- | A lazy data type field annotation (~) was used without enabling the
--   extension StrictData.
--   
--   Test cases: LazyFieldsDisabled
[LazyFieldsDisabled] :: BadFieldAnnotationReason

-- | An UNPACK pragma was applied to a field without strictness annotation
--   (!).
--   
--   Test cases: T14761a, T7562
[UnpackWithoutStrictness] :: BadFieldAnnotationReason

-- | An UNPACK pragma was applied to an abstract type in an indefinite
--   package in Backpack.
--   
--   Test cases: unpack_sums_5, T3966, T7050
[BackpackUnpackAbstractType] :: BadFieldAnnotationReason
data SuperclassCycle
MkSuperclassCycle :: Class -> Bool -> [SuperclassCycleDetail] -> SuperclassCycle
[cls] :: SuperclassCycle -> Class
[definite] :: SuperclassCycle -> Bool
[reasons] :: SuperclassCycle -> [SuperclassCycleDetail]
data SuperclassCycleDetail
SCD_HeadTyVar :: !PredType -> SuperclassCycleDetail
SCD_HeadTyFam :: !PredType -> SuperclassCycleDetail
SCD_Superclass :: !Class -> SuperclassCycleDetail
data RoleValidationFailedReason
TyVarRoleMismatch :: !TyVar -> !Role -> RoleValidationFailedReason
TyVarMissingInEnv :: !TyVar -> RoleValidationFailedReason
BadCoercionRole :: !Coercion -> RoleValidationFailedReason
data DisabledClassExtension

-- | MultiParamTypeClasses is required.
--   
--   Test cases: readFail037, TcNoNullaryTC
[MultiParamDisabled] :: !Int -> DisabledClassExtension

-- | FunctionalDependencies is required.
--   
--   Test cases: readFail041
[FunDepsDisabled] :: DisabledClassExtension

-- | ConstrainedClassMethods is required.
--   
--   Test cases: mod39, tcfail150
[ConstrainedClassMethodsDisabled] :: !Id -> !TcPredType -> DisabledClassExtension
data TyFamsDisabledReason
TyFamsDisabledFamily :: !Name -> TyFamsDisabledReason
TyFamsDisabledInstance :: !TyCon -> TyFamsDisabledReason
data TypeApplication
TypeApplication :: !HsType GhcPs -> !TypeOrKind -> TypeApplication
TypeApplicationInPattern :: !HsConPatTyArg GhcPs -> TypeApplication

-- | Either `HsType p` or `HsSigType p`.
--   
--   Used for reporting errors in <a>TcRnIllegalKind</a>.
data HsTypeOrSigType p
HsType :: HsType p -> HsTypeOrSigType p
HsSigType :: HsSigType p -> HsTypeOrSigType p

-- | A wrapper around HsTyVarBndr. Used for reporting errors in
--   <a>TcRnUnusedQuantifiedTypeVar</a>.
data HsTyVarBndrExistentialFlag
HsTyVarBndrExistentialFlag :: HsTyVarBndr flag GhcRn -> HsTyVarBndrExistentialFlag
type TySynCycleTyCons = [Either TyCon LTyClDecl GhcRn]
data BadImportKind

-- | Module does not export...
BadImportNotExported :: [GhcHint] -> BadImportKind

-- | is ExplicitNamespaces enabled? | Trying to import a data constructor
--   directly, e.g. <tt>import Data.Maybe (Just)</tt> instead of <tt>import
--   Data.Maybe (Maybe(Just))</tt>
BadImportAvailTyCon :: Bool -> BadImportKind
BadImportAvailDataCon :: OccName -> BadImportKind

-- | The parent does not export the given children.
BadImportNotExportedSubordinates :: [OccName] -> BadImportKind

-- | Incorrect <tt>type</tt> keyword when importing something which isn't a
--   type.
BadImportAvailVar :: BadImportKind

-- | Different types of warnings for dodgy imports.
data DodgyImportsReason

-- | An import of the form 'T(..)' or 'f(..)' does not actually import
--   anything beside <tt>T</tt>/<tt>f</tt> itself.
--   
--   Test cases: DodgyImports
DodgyImportsEmptyParent :: !GlobalRdrElt -> DodgyImportsReason

-- | A <tt>hiding</tt> clause contains something that would be reported as
--   an error in a regular import, but is relaxed to a warning.
--   
--   Test cases: DodgyImports_hiding
DodgyImportsHiding :: !ImportLookupReason -> DodgyImportsReason

-- | Different types of errors for import lookup.
data ImportLookupReason

-- | An item in an import statement is not exported by the corresponding
--   module.
--   
--   Test cases: T21826, recomp001, retc001, mod79, mod80, mod81, mod91,
--   T6007, T7167, T9006, T11071, T9905fail2, T5385, T10668
[ImportLookupBad] :: BadImportKind -> ModIface -> ImpDeclSpec -> IE GhcPs -> Bool -> ImportLookupReason

-- | A name is specified with a qualifying module.
--   
--   Test cases: T3792
[ImportLookupQualified] :: !RdrName -> ImportLookupReason

-- | Something completely unexpected is in an import list, like <tt>module
--   Foo</tt>.
--   
--   Test cases: ImportLookupIllegal
[ImportLookupIllegal] :: ImportLookupReason

-- | An item in an import list matches multiple names exported from that
--   module.
--   
--   Test cases: None
[ImportLookupAmbiguous] :: !RdrName -> ![GlobalRdrElt] -> ImportLookupReason

-- | Different types of errors for unused imports.
data UnusedImportReason

-- | No names in the import list are used in the module.
--   
--   Test cases: overloadedrecfldsfail06, T10890_2, t22391, t22391j, T1074,
--   prog018, mod177, rn046, rn037, T5211
[UnusedImportNone] :: UnusedImportReason

-- | A set of names in the import list are not used in the module.
--   
--   Test cases: overloadedrecfldsfail06, T17324, mod176, T11970A, rn046,
--   T14881, T7454, T8149, T13064
[UnusedImportSome] :: ![UnusedImportName] -> UnusedImportReason

-- | Distinguish record fields from other names for pretty-printing.
data UnusedImportName
[UnusedImportNameRecField] :: !Parent -> !OccName -> UnusedImportName
[UnusedImportNameRegular] :: !Name -> UnusedImportName

-- | Different places in which a nested foralls/contexts error might occur.
data NestedForallsContextsIn

-- | Nested forall in <tt>SPECIALISE instance</tt>
NFC_Specialize :: NestedForallsContextsIn

-- | Nested forall in <tt>deriving via</tt> (via-type)
NFC_ViaType :: NestedForallsContextsIn

-- | Nested forall in the type of a GADT constructor
NFC_GadtConSig :: NestedForallsContextsIn

-- | Nested forall in an instance head
NFC_InstanceHead :: NestedForallsContextsIn

-- | Nested forall in a standalone deriving instance head
NFC_StandaloneDerivedInstanceHead :: NestedForallsContextsIn

-- | Nested forall in deriving class type
NFC_DerivedClassType :: NestedForallsContextsIn

-- | Provenance of an unused name.
data UnusedNameProv
UnusedNameTopDecl :: UnusedNameProv
UnusedNameImported :: !ModuleName -> UnusedNameProv
UnusedNameTypePattern :: UnusedNameProv
UnusedNameMatch :: UnusedNameProv
UnusedNameLocalBind :: UnusedNameProv

-- | Different reasons for TcRnNonCanonicalDefinition.
data NonCanonicalDefinition

-- | Related to <tt>(&lt;&gt;)</tt> and <tt>mappend</tt>.
NonCanonicalMonoid :: NonCanonical_Monoid -> NonCanonicalDefinition

-- | Related to <tt>(*&gt;)</tt><i><tt>(&gt;&gt;)</tt> and
--   <tt>pure</tt></i><tt>return</tt>.
NonCanonicalMonad :: NonCanonical_Monad -> NonCanonicalDefinition

-- | Possible cases for the -Wnoncanonical-monoid-instances.
data NonCanonical_Monoid

-- | <tt>(&lt;&gt;) = mappend</tt> was defined.
NonCanonical_Sappend :: NonCanonical_Monoid

-- | <tt>mappend</tt> was defined as something other than
--   <tt>(&lt;&gt;)</tt>.
NonCanonical_Mappend :: NonCanonical_Monoid

-- | Possible cases for the -Wnoncanonical-monad-instances.
data NonCanonical_Monad

-- | <tt>pure = return</tt> was defined.
NonCanonical_Pure :: NonCanonical_Monad

-- | <tt>(*&gt;) = (&gt;&gt;)</tt> was defined.
NonCanonical_ThenA :: NonCanonical_Monad

-- | <tt>return</tt> was defined as something other than <tt>pure</tt>.
NonCanonical_Return :: NonCanonical_Monad

-- | <tt>(&gt;&gt;)</tt> was defined as something other than
--   <tt>(*&gt;)</tt>.
NonCanonical_ThenM :: NonCanonical_Monad

-- | Label for syntax that may occur in terms (expressions) only as part of
--   a required type argument.
data TypeSyntax

-- | <pre>
--   type t
--   </pre>
TypeKeywordSyntax :: TypeSyntax

-- | <pre>
--   ctx =&gt; t
--   </pre>
ContextArrowSyntax :: TypeSyntax

-- | <pre>
--   t1 -&gt; t2
--   </pre>
FunctionArrowSyntax :: TypeSyntax

-- | <pre>
--   forall tvs. t
--   </pre>
ForallTelescopeSyntax :: TypeSyntax
typeSyntaxExtension :: TypeSyntax -> Extension

-- | What declarations were not allowed in an hs-boot or hsig file?
data BadBootDecls
BootBindsPs :: !NonEmpty (LHsBindLR GhcRn GhcPs) -> BadBootDecls
BootBindsRn :: !NonEmpty (LHsBindLR GhcRn GhcRn) -> BadBootDecls
BootInstanceSigs :: !NonEmpty (LSig GhcRn) -> BadBootDecls
BootFamInst :: !TyCon -> BadBootDecls
BootSpliceDecls :: !NonEmpty (LocatedA (HsUntypedSplice GhcPs)) -> BadBootDecls
BootForeignDecls :: !NonEmpty (LForeignDecl GhcRn) -> BadBootDecls
BootDefaultDecls :: !NonEmpty (LDefaultDecl GhcRn) -> BadBootDecls
BootRuleDecls :: !NonEmpty (LRuleDecls GhcRn) -> BadBootDecls

-- | Something from the hs-boot or signature file is missing from the
--   implementing module.
data MissingBootThing

-- | Something defined in the hs-boot or signature file is not defined in
--   the implementing module.
MissingBootDefinition :: MissingBootThing

-- | Something exported by the hs-boot or signature file is not exported by
--   the implementing module.
MissingBootExport :: MissingBootThing
missingBootThing :: HsBootOrSig -> Name -> MissingBootThing -> TcRnMessage

-- | A mismatch between an hs-boot or signature file and its implementing
--   module.
data BootMismatch

-- | Something defined or exported by an hs-boot or signature file is
--   missing from the implementing module.
MissingBootThing :: !Name -> !MissingBootThing -> BootMismatch

-- | A typeclass instance is declared in the hs-boot file but it is not
--   present in the implementing module.
MissingBootInstance :: !DFunId -> BootMismatch

-- | A mismatch between an hsig file and its implementing module in the
--   <a>Name</a> that a particular re-export refers to.
BadReexportedBootThing :: !Name -> !Name -> BootMismatch

-- | A mismatch between the declaration of something in the hs-boot or
--   signature file and its implementation, e.g. a type mismatch or a type
--   family implemented as a class.
BootMismatch :: !TyThing -> !TyThing -> !BootMismatchWhat -> BootMismatch

-- | A mismatch of two <a>TyThing</a>s between an hs-boot or signature file
--   and its implementing module.
data BootMismatchWhat

-- | The <a>Id</a>s have different types.
BootMismatchedIdTypes :: !Id -> !Id -> BootMismatchWhat
BootMismatchedTyCons :: !TyCon -> !TyCon -> !NonEmpty BootTyConMismatch -> BootMismatchWhat

-- | Mismatched implementation of a <a>TyCon</a> in an hs-boot or signature
--   file.
data BootTyConMismatch

-- | The <a>TyCon</a> kinds differ.
TyConKindMismatch :: BootTyConMismatch

-- | The <a>TyCon</a> <a>Role</a>s aren't compatible.
TyConRoleMismatch :: !Bool -> BootTyConMismatch
TyConSynonymMismatch :: !Kind -> !Kind -> BootTyConMismatch

-- | The two <a>TyCon</a>s are of a different flavour, e.g. one is a data
--   family and the other is a type family.
TyConFlavourMismatch :: !FamTyConFlav -> !FamTyConFlav -> BootTyConMismatch

-- | The equations of a type family don't match.
TyConAxiomMismatch :: !BootListMismatches CoAxBranch BootAxiomBranchMismatch -> BootTyConMismatch

-- | The type family injectivity annotations don't match.
TyConInjectivityMismatch :: BootTyConMismatch

-- | The <a>TyCon</a>s are both datatype <a>TyCon</a>s, but they have
--   diferent <a>DataCon</a>s.
TyConMismatchedData :: !AlgTyConRhs -> !AlgTyConRhs -> !BootDataMismatch -> BootTyConMismatch

-- | The <a>TyCon</a>s are both <a>Class</a> <a>TyCon</a>s, but the classes
--   don't match.
TyConMismatchedClasses :: !Class -> !Class -> !BootClassMismatch -> BootTyConMismatch

-- | The <a>TyCon</a>s are something completely different.
TyConsVeryDifferent :: BootTyConMismatch

-- | An abstract <a>TyCon</a> is implemented using a type synonym in an
--   invalid manner. See <a>SynAbstractDataError</a>.
SynAbstractData :: !SynAbstractDataError -> BootTyConMismatch
data BootAxiomBranchMismatch

-- | The quantified variables in an equation don't match.
--   
--   Example: the quantification of <tt>a</tt> in
--   
--   <pre>
--   type family F a where { forall a. F a = Maybe a }
--   </pre>
MismatchedAxiomBinders :: BootAxiomBranchMismatch

-- | The LHSs of an equation don't match.
MismatchedAxiomLHS :: BootAxiomBranchMismatch

-- | The RHSs of an equation don't match.
MismatchedAxiomRHS :: BootAxiomBranchMismatch

-- | A mismatch in a class, between its declaration in an hs-boot or
--   signature file, and its implementation in a source Haskell file.
data BootClassMismatch

-- | The class methods don't match.
MismatchedMethods :: !BootListMismatches ClassOpItem BootMethodMismatch -> BootClassMismatch

-- | The associated types don't match.
MismatchedATs :: !BootListMismatches ClassATItem BootATMismatch -> BootClassMismatch

-- | The functional dependencies don't match.
MismatchedFunDeps :: BootClassMismatch

-- | The superclasses don't match.
MismatchedSuperclasses :: BootClassMismatch

-- | The <tt>MINIMAL</tt> pragmas are not compatible.
MismatchedMinimalPragmas :: BootClassMismatch

-- | A mismatch in a class method, between its declaration in an hs-boot or
--   signature file, and its implementation in a source Haskell file.
data BootMethodMismatch

-- | The class method names are different.
MismatchedMethodNames :: BootMethodMismatch

-- | The types of a class method are different.
MismatchedMethodTypes :: !Type -> !Type -> BootMethodMismatch

-- | The default method types are not compatible.
MismatchedDefaultMethods :: !Bool -> BootMethodMismatch

-- | A mismatch in an associated type of a class, between its declaration
--   in an hs-boot or signature file, and its implementation in a source
--   Haskell file.
data BootATMismatch

-- | Two associated types don't match.
MismatchedTyConAT :: !BootTyConMismatch -> BootATMismatch

-- | Two associated type defaults don't match.
MismatchedATDefaultType :: BootATMismatch

-- | A mismatch in a datatype declaration, between an hs-boot file or
--   signature file and its implementing module.
data BootDataMismatch

-- | A datatype is implemented as a newtype or vice-versa.
MismatchedNewtypeVsData :: BootDataMismatch

-- | The constructors don't match.
MismatchedConstructors :: !BootListMismatches DataCon BootDataConMismatch -> BootDataMismatch

-- | The datatype contexts differ.
MismatchedDatatypeContexts :: BootDataMismatch

-- | A mismatch in a data constrcutor, between its declaration in an
--   hs-boot file or signature file, and its implementation in a source
--   Haskell module.
data BootDataConMismatch

-- | The <a>Name</a>s of the <a>DataCon</a>s differ.
MismatchedDataConNames :: BootDataConMismatch

-- | The fixities of the <a>DataCon</a>s differ.
MismatchedDataConFixities :: BootDataConMismatch

-- | The strictness annotations of the <a>DataCon</a>s differ.
MismatchedDataConBangs :: BootDataConMismatch

-- | The <a>DataCon</a>s have different field labels.
MismatchedDataConFieldLabels :: BootDataConMismatch

-- | The <a>DataCon</a>s have incompatible types.
MismatchedDataConTypes :: BootDataConMismatch

-- | An error in the implementation of an abstract datatype using a type
--   synonym.
data SynAbstractDataError

-- | The type synony was not nullary.
SynAbsDataTySynNotNullary :: SynAbstractDataError

-- | The type synonym RHS contained invalid types, e.g. a type family or a
--   forall.
SynAbstractDataInvalidRHS :: !NonEmpty Type -> SynAbstractDataError

-- | Utility datatype to record errors when checking compatibity between
--   two lists of things, e.g. class methods, associated types, type family
--   equations, etc.
data BootListMismatch item err

-- | Different number of items.
MismatchedLength :: BootListMismatch item err

-- | The item at the given position in the list differs.
MismatchedThing :: !Int -> !item -> !item -> !err -> BootListMismatch item err
type BootListMismatches item err = NonEmpty BootListMismatch item err

-- | Why was an instance declaration rejected?
data IllegalInstanceReason
IllegalClassInstance :: !TypedThing -> !IllegalClassInstanceReason -> IllegalInstanceReason
IllegalFamilyInstance :: !IllegalFamilyInstanceReason -> IllegalInstanceReason
IllegalFamilyApplicationInInstance :: !Type -> !Bool -> !TyCon -> ![Type] -> IllegalInstanceReason

-- | Why was a class instance declaration rejected?
data IllegalClassInstanceReason

-- | An illegal type at the head of the instance.
--   
--   See <a>IllegalInstanceHeadReason</a>.
IllegalInstanceHead :: !IllegalInstanceHeadReason -> IllegalClassInstanceReason

-- | An illegal HasField instance. See <a>IllegalHasFieldInstance</a>.
IllegalHasFieldInstance :: !IllegalHasFieldInstance -> IllegalClassInstanceReason

-- | An illegal instance for a built-in typeclass such as
--   <tt>Coercible</tt>, <a>Typeable</a>, or <tt>KnownNat</tt>, outside of
--   a signature file.
--   
--   Test cases: deriving<i>should_fail</i>T9687
--   deriving<i>should_fail</i>T14916 polykinds/T8132
--   typecheck<i>should_fail</i>TcCoercibleFail2
--   typecheck<i>should_fail</i>T12837 typecheck<i>should_fail</i>T14390
IllegalSpecialClassInstance :: !Class -> !Bool -> IllegalClassInstanceReason
IllegalInstanceFailsCoverageCondition :: !Class -> !CoverageProblem -> IllegalClassInstanceReason

-- | Why is a class instance head invalid?
data IllegalInstanceHeadReason

-- | An instance for an abstract class from an hs-boot or Backpack hsig
--   file.
--   
--   Example:
--   
--   <ul>
--   <li>- A.hs-boot module A where class C a</li>
--   <li>- B.hs module B where import {-# SOURCE #-} A instance C Int
--   where</li>
--   <li>- A.hs module A where import B class C a where f :: a</li>
--   </ul>
--   
--   Test cases: typecheck<i>should_fail</i>T13068
InstHeadAbstractClass :: !Class -> IllegalInstanceHeadReason

-- | An instance whose head is not a class.
--   
--   Examples(s):
--   
--   instance c
--   
--   instance 42
--   
--   instance !Show D
--   
--   type C1 a = (Show (a -&gt; Bool)) instance C1 Int where
--   
--   Test cases: typecheck<i>rename</i>T5513 typecheck<i>rename</i>T16385
--   parser<i>should_fail</i>T3811c rename<i>should_fail</i>T18240a
--   polykinds/T13267 deriving<i>should_fail</i>T23522
InstHeadNonClass :: !Maybe TyCon -> IllegalInstanceHeadReason

-- | Instance head was headed by a type synonym.
--   
--   Example: type MyInt = Int class C a where {..} instance C MyInt where
--   {..}
--   
--   Test cases: drvfail015, mod42, TidyClassKinds, tcfail139
InstHeadTySynArgs :: IllegalInstanceHeadReason

-- | Instance head was not of the form <tt>T a1 ... an</tt>, where <tt>a1,
--   ..., an</tt> are all type variables or literals.
--   
--   Example:
--   
--   instance Num [Int] where {..}
--   
--   Test cases: mod41, mod42, tcfail044, tcfail047.
InstHeadNonTyVarArgs :: IllegalInstanceHeadReason

-- | Multi-param instance without -XMultiParamTypeClasses.
--   
--   Example:
--   
--   instance C a b where {..}
--   
--   Test case: IllegalMultiParamInstance
InstHeadMultiParam :: IllegalInstanceHeadReason

-- | Why was a HasField instance declaration rejected?
data IllegalHasFieldInstance

-- | HasField instance for a type not headed by a TyCon.
--   
--   Example:
--   
--   instance HasField a where {..}
--   
--   Test case: hasfieldfail03
IllegalHasFieldInstanceNotATyCon :: IllegalHasFieldInstance

-- | HasField instance for a data family.
--   
--   Example:
--   
--   data family D a data instance D Int = MkDInt Char
--   
--   instance HasField "fld" (D Int) where {..}
--   
--   Test case: hasfieldfail03
IllegalHasFieldInstanceFamilyTyCon :: IllegalHasFieldInstance

-- | HasField instance for a type that already has that field.
--   
--   Example
--   
--   data T = MkT { quux :: Int } instance HasField "quux" T Int where {..}
--   
--   Test case: hasfieldfail03
IllegalHasFieldInstanceTyConHasField :: !TyCon -> !FieldLabelString -> IllegalHasFieldInstance

-- | HasField instance for a type that already has fields, when the field
--   label could potentially unify with those fields.
--   
--   Example:
--   
--   data T = MkInt { quux :: Int } instance forall (fld :: Symbol).
--   HasField fld T Int where {..}
--   
--   Test case: hasfieldfail03
IllegalHasFieldInstanceTyConHasFields :: !TyCon -> !Type -> IllegalHasFieldInstance

-- | Description of an instance coverage condition failure.
data CoverageProblem
CoverageProblem :: ([TyVar], [TyVar]) -> ([Type], [Type]) -> Pair VarSet -> FailedCoverageCondition -> CoverageProblem
[not_covered_fundep] :: CoverageProblem -> ([TyVar], [TyVar])
[not_covered_fundep_inst] :: CoverageProblem -> ([Type], [Type])
[not_covered_invis_vis_tvs] :: CoverageProblem -> Pair VarSet
[not_covered_liberal] :: CoverageProblem -> FailedCoverageCondition

-- | Which instance coverage condition failed? Was it the liberal coverage
--   condition?
data FailedCoverageCondition

-- | Failed the instance coverage condition (ICC)
FailedICC :: !Bool -> FailedCoverageCondition

-- | Whether the instance also failed the LICC
[alsoFailedLICC] :: FailedCoverageCondition -> !Bool

-- | Failed the liberal instance coverage condition (LICC)
FailedLICC :: FailedCoverageCondition

-- | Why is a (type or data) family instance invalid?
data IllegalFamilyInstanceReason

-- | A top-level family instance for a <a>TyCon</a> that isn't a family
--   <a>TyCon</a>.
--   
--   Example:
--   
--   data D a = MkD type instance D Int = Bool
--   
--   Test case: indexed-types<i>should_fail</i>T3092
NotAFamilyTyCon :: !TypeOrData -> !TyCon -> IllegalFamilyInstanceReason

-- | A top-level (open) type family instance for a closed type family.
--   
--   Test cases: indexed-types<i>should_fail</i>Overlap7
--   indexed-types<i>should_fail</i>Overlap3
NotAnOpenFamilyTyCon :: !TyCon -> IllegalFamilyInstanceReason

-- | A family instance was declared for a family of a different kind, e.g.
--   a data instance for a type family <a>TyCon</a>.
--   
--   Test cases: T9896, SimpleFail3a
FamilyCategoryMismatch :: !TyCon -> IllegalFamilyInstanceReason

-- | A family instance was declared with a different number of arguments
--   than expected. See Note [Oversaturated type family equations] in
--   <a>GHC.Tc.Validity</a>.
--   
--   Test cases: TyFamArity1, TyFamArity2, T11136, Overlap4, AssocTyDef05,
--   AssocTyDef06, T14110
FamilyArityMismatch :: !TyCon -> !Arity -> IllegalFamilyInstanceReason

-- | A closed type family equation used a different name than the parent
--   family.
--   
--   Example:
--   
--   type family F a where G Int = Bool
--   
--   Test cases: Overlap5, T15362, T16002, T20260, T11623
TyFamNameMismatch :: !Name -> !Name -> IllegalFamilyInstanceReason

-- | There are out-of-scope type variables in the right-hand side of an
--   associated type or data family instance.
--   
--   Example:
--   
--   instance forall a. C Int where data instance D Int = MkD1 a
--   
--   Test cases: indexed-types<i>should_fail</i>T5515, polykinds<i>T9574,
--   rename</i>should_fail/T18021
FamInstRHSOutOfScopeTyVars :: !Maybe (TyCon, [Type], TyVarSet) -> !NonEmpty Name -> IllegalFamilyInstanceReason

-- | the unused bound type variables
FamInstLHSUnusedBoundTyVars :: !NonEmpty InvalidFamInstQTv -> IllegalFamilyInstanceReason
InvalidAssoc :: !InvalidAssoc -> IllegalFamilyInstanceReason

-- | A quantified type variable in a type or data family equation that is
--   either not bound in any LHS patterns or not used in the RHS (or both).
data InvalidFamInstQTv
InvalidFamInstQTv :: TcTyVar -> Bool -> InvalidFamInstQTvReason -> InvalidFamInstQTv
[ifiqtv] :: InvalidFamInstQTv -> TcTyVar

-- | Did the user write this type variable, or was introduced by GHC? For
--   example: with <tt>-XPolyKinds</tt>, in <tt>type instance forall a. F =
--   ()</tt>, we have a user-written <tt>a</tt> but GHC introduces a kind
--   variable <tt>k</tt> as well. See #23734.
[ifiqtv_user_written] :: InvalidFamInstQTv -> Bool

-- | For what reason was the quantified type variable invalid?
[ifiqtv_reason] :: InvalidFamInstQTv -> InvalidFamInstQTvReason
data InvalidFamInstQTvReason

-- | A dodgy binder, i.e. a variable that syntactically appears in LHS
--   patterns but only in non-injective positions.
--   
--   See Note [Dodgy binding sites in type family instances] in
--   GHC.Tc.Validity.
InvalidFamInstQTvDodgy :: InvalidFamInstQTvReason

-- | A quantified type variable in a type or data family equation that is
--   not bound in any LHS patterns.
InvalidFamInstQTvNotBoundInPats :: InvalidFamInstQTvReason

-- | A quantified type variable in a type or data family equation that is
--   not used on the RHS.
InvalidFamInstQTvNotUsedInRHS :: InvalidFamInstQTvReason
data InvalidAssoc

-- | An invalid associated family instance.
--   
--   See <a>InvalidAssocInstance</a>.Builder
InvalidAssocInstance :: !InvalidAssocInstance -> InvalidAssoc

-- | An invalid associated family default declaration.
--   
--   See <a>InvalidAssocDefault</a>.
InvalidAssocDefault :: !InvalidAssocDefault -> InvalidAssoc

-- | The reason that an associated family instance was invalid.
data InvalidAssocInstance

-- | A class instance is missing its expected associated type/data
--   instance.
--   
--   Test cases: deriving<i>should_compile</i>T14094
--   indexed-types<i>should_compile</i>Simple2
--   typecheck<i>should_compile</i>tc254
AssocInstanceMissing :: !Name -> InvalidAssocInstance

-- | A top-level instance for an associated family <a>TyCon</a>.
--   
--   Example:
--   
--   class C a where { type T a } instance T Int = Bool
--   
--   Test case: indexed-types<i>should_fail</i>SimpleFail7
AssocInstanceNotInAClass :: !TyCon -> InvalidAssocInstance

-- | An associated type instance is provided for a class that doesn't have
--   that associated type.
--   
--   Examples(s): $(do d &lt;- instanceD (cxt []) (conT ''Eq <tt>appT</tt>
--   conT ''Foo) [tySynInstD $ tySynEqn Nothing (conT ''Rep <tt>appT</tt>
--   conT ''Foo) (conT ''Maybe)] return [d]) ======&gt; instance Eq Foo
--   where type Rep Foo = Maybe
--   
--   Test cases: th/T12387a
AssocNotInThisClass :: !Class -> !TyCon -> InvalidAssocInstance

-- | An associated family instance does not mention any of the parent
--   <a>Class</a> <a>TyVar</a>s.
--   
--   Test cases: T2888, T9167, T12867
AssocNoClassTyVar :: !Class -> !TyCon -> InvalidAssocInstance
AssocTyVarsDontMatch :: !ForAllTyFlag -> !TyCon -> ![Type] -> ![Type] -> InvalidAssocInstance

-- | The reason that an associated family default declaration was invalid.
data InvalidAssocDefault

-- | An associated family default declaration for something that isn't an
--   associated family.
AssocDefaultNotAssoc :: !Name -> !Name -> InvalidAssocDefault
AssocMultipleDefaults :: !Name -> InvalidAssocDefault

-- | Invalid arguments in an associated family instance.
--   
--   See <a>AssocDefaultBadArgs</a>.
AssocDefaultBadArgs :: !TyCon -> ![Type] -> AssocDefaultBadArgs -> InvalidAssocDefault

-- | Invalid arguments in an associated family instance declaration.
data AssocDefaultBadArgs

-- | An argument which isn't a type variable in an associated family
--   instance default declaration.
AssocDefaultNonTyVarArg :: !(Type, ForAllTyFlag) -> AssocDefaultBadArgs

-- | Duplicate occurrence of a type variable in an associated family
--   instance default declaration.
AssocDefaultDuplicateTyVars :: !NonEmpty (TyCoVar, ForAllTyFlag) -> AssocDefaultBadArgs
data THError

-- | A syntax error with Template Haskel quotes &amp; splices. See
--   <a>THSyntaxError</a>.
THSyntaxError :: !THSyntaxError -> THError

-- | An error in Template Haskell involving <a>Name</a>s. See
--   <a>THNameError</a>.
THNameError :: !THNameError -> THError

-- | An error in Template Haskell reification. See <a>THReifyError</a>.
THReifyError :: !THReifyError -> THError

-- | An error due to typing restrictions in Typed Template Haskell. See
--   <a>TypedTHError</a>.
TypedTHError :: !TypedTHError -> THError

-- | An error occurred when trying to run a splice in Template Haskell. See
--   <a>SpliceFailReason</a>.
THSpliceFailed :: !SpliceFailReason -> THError

-- | An error involving the <tt>addTopDecls</tt> functionality. See
--   <a>AddTopDeclsError</a>.
AddTopDeclsError :: !AddTopDeclsError -> THError

-- | IllegalStaticFormInSplice is an error when a user attempts to define a
--   static pointer in a Template Haskell splice.
--   
--   Example(s):
--   
--   Test cases: th/TH_StaticPointers02
IllegalStaticFormInSplice :: !HsExpr GhcPs -> THError

-- | FailedToLookupThInstName is a Template Haskell error that occurrs when
--   looking up an instance fails.
--   
--   Example(s):
--   
--   Test cases: showIface<i>should_fail</i>THPutDocNonExistent
FailedToLookupThInstName :: !Type -> !LookupTHInstNameErrReason -> THError

-- | AddInvalidCorePlugin is a Template Haskell error indicating that a
--   Core plugin being added has an invalid module due to being in the
--   current package.
--   
--   Example(s):
--   
--   Test cases:
AddInvalidCorePlugin :: !String -> THError

-- | AddDocToNonLocalDefn is a Template Haskell error for documentation
--   being added to a definition which is not in the current module.
--   
--   Example(s):
--   
--   Test cases: showIface<i>should_fail</i>THPutDocExternal
AddDocToNonLocalDefn :: !DocLoc -> THError

-- | ReportCustomQuasiError is an error or warning thrown using
--   <tt>qReport</tt> from the <tt>Quasi</tt> instance of <tt>TcM</tt>.
--   
--   Example(s):
--   
--   Test cases:
ReportCustomQuasiError :: !Bool -> !String -> THError

-- | An error involving Template Haskell quotes or splices, e.g. nested
--   quotation brackets or the use of an untyped bracket inside a typed
--   splice.
data THSyntaxError

-- | IllegalTHQuotes is an error that occurs when a Template Haskell quote
--   is used without the TemplateHaskell extension enabled.
--   
--   Test case: T18251e
IllegalTHQuotes :: !HsExpr GhcPs -> THSyntaxError

-- | IllegalTHSplice is an error that occurs when a Template Haskell splice
--   occurs without having enabled the TemplateHaskell extension.
--   
--   Test cases: bkpfail01, bkpfail05, bkpfail09, bkpfail16, bkpfail35,
--   bkpcabal06
IllegalTHSplice :: THSyntaxError

-- | NestedTHBrackets is an error that occurs when Template Haskell
--   brackets are nested without any intervening splices.
--   
--   Example:
--   
--   foo = [| [| <tt>x</tt> |] |]
--   
--   Test cases: TH_NestedSplicesFail{5,6,7,8}
NestedTHBrackets :: THSyntaxError

-- | MismatchedSpliceType is an error that happens when a typed bracket or
--   splice is used inside a typed splice/bracket, or the other way around.
--   
--   Examples:
--   
--   f1 = [| $$x |] f2 = [|| $y ||] f3 = $$( [| <tt>x</tt> |] ) f4 = $( [||
--   <tt>y</tt> ||] )
--   
--   Test cases: TH_NestedSplicesFail{1,2,3,4}
MismatchedSpliceType :: SpliceType -> SpliceOrBracket -> THSyntaxError

-- | BadImplicitSplice is an error thrown when a user uses top-level
--   implicit TH-splice without enabling the TemplateHaskell extension.
--   
--   Example:
--   
--   pure [] -- on top-level
--   
--   Test cases: ghci<i>prog019</i>prog019 ghci<i>scripts</i>T1914
--   ghci<i>scripts</i>T6106 rename<i>should_fail</i>T4042
--   rename<i>should_fail</i>T12146
BadImplicitSplice :: THSyntaxError
data THNameError

-- | NonExactName is a Template Haskell error that occurs when the user
--   attempts to define a binder with a <a>RdrName</a> that is not an exact
--   <a>Name</a>.
--   
--   Example(s):
--   
--   Test cases:
NonExactName :: !RdrName -> THNameError

-- | QuotedNameWrongStage is an error that can happen when a
--   (non-top-level) Name is used at a different Template Haskell stage
--   than the stage at which it is bound.
--   
--   Test cases: T16976z
QuotedNameWrongStage :: !HsQuote GhcPs -> THNameError
data THReifyError

-- | CannotReifyInstance is a Template Haskell error for when an instance
--   being reified via <tt>reifyInstances</tt> is not a class constraint or
--   type family application.
--   
--   Example(s):
--   
--   Test cases:
CannotReifyInstance :: !Type -> THReifyError

-- | CannotReifyOutOfScopeThing is a Template Haskell error indicating that
--   the given name is not in scope and therefore cannot be reified.
--   
--   Example(s):
--   
--   Test cases: th/T16976f
CannotReifyOutOfScopeThing :: !Name -> THReifyError

-- | CannotReifyThingNotInTypeEnv is a Template Haskell error occurring
--   when the given name is not in the type environment and therefore
--   cannot be reified.
--   
--   Example(s):
--   
--   Test cases:
CannotReifyThingNotInTypeEnv :: !Name -> THReifyError

-- | NoRolesAssociatedWithName is a Template Haskell error for when the
--   user tries to reify the roles of a given name but it is not something
--   that has roles associated with it.
--   
--   Example(s):
--   
--   Test cases:
NoRolesAssociatedWithThing :: !TcTyThing -> THReifyError

-- | CannotRepresentThing is a Template Haskell error indicating that a
--   type cannot be reified because it does not have a representation in
--   Template Haskell.
--   
--   Example(s):
--   
--   Test cases:
CannotRepresentType :: !UnrepresentableTypeDescr -> !Type -> THReifyError
data TypedTHError

-- | SplicePolymorphicLocalVar is the error that occurs when the expression
--   inside typed Template Haskell brackets is a polymorphic local
--   variable.
--   
--   Example(s): x = (y :: forall a. a -&gt; a) -&gt; [|| y ||]
--   
--   Test cases: quotes/T10384
SplicePolymorphicLocalVar :: !Id -> TypedTHError

-- | TypedTHWithPolyType is an error that signifies the illegal use of a
--   polytype in a typed Template Haskell expression.
--   
--   Example(s): bad :: (forall a. a -&gt; a) -&gt; () bad = $$( [|| _
--   -&gt; () ||] )
--   
--   Test cases: th/T11452
TypedTHWithPolyType :: !TcType -> TypedTHError
data SpliceFailReason

-- | SpliceThrewException is an error that occurs when running a Template
--   Haskell splice throws an exception.
--   
--   Example(s):
--   
--   Test cases: annotations<i>should_fail</i>annfail12
--   perf<i>compiler</i>MultiLayerModulesTH_Make
--   perf<i>compiler</i>MultiLayerModulesTH_OneShot th/T10796b th/T19470
--   th/T19709d th/T5358 th/T5976 th/T7276a th/T8987 th/TH_exn1 th/TH_exn2
--   th/TH_runIO
SpliceThrewException :: !SplicePhase -> !SomeException -> !String -> !LHsExpr GhcTc -> !Bool -> SpliceFailReason

-- | RunSpliceFailure is an error indicating that a Template Haskell splice
--   failed to be converted into a valid expression.
--   
--   Example(s):
--   
--   Test cases: th/T10828a th/T10828b th/T12478_4 th/T15270A th/T15270B
--   th/T16895a th/T16895b th/T16895c th/T16895d th/T16895e th/T18740d
--   th/T2597b th/T2674 th/T3395 th/T7484 th/T7667a
--   th/TH_implicitParamsErr1 th/TH_implicitParamsErr2
--   th/TH_implicitParamsErr3 th/TH_invalid_add_top_decl
RunSpliceFailure :: !RunSpliceFailReason -> SpliceFailReason
data RunSpliceFailReason
ConversionFail :: !ThingBeingConverted -> !ConversionFailReason -> RunSpliceFailReason
data AddTopDeclsError

-- | InvalidTopDecl is a Template Haskell error occurring when one of the
--   <tt>Dec</tt>s passed to <tt>addTopDecls</tt> is not a function, value,
--   annotation, or foreign import declaration.
--   
--   Example(s):
--   
--   Test cases:
InvalidTopDecl :: !HsDecl GhcPs -> AddTopDeclsError

-- | UnexpectedDeclarationSplice is an error that occurs when a Template
--   Haskell splice appears inside top-level declarations added with
--   <tt>addTopDecls</tt>.
--   
--   Example(s): none
--   
--   Test cases: none
AddTopDeclsUnexpectedDeclarationSplice :: AddTopDeclsError
AddTopDeclsRunSpliceFailure :: !RunSpliceFailReason -> AddTopDeclsError

-- | The reason a TH splice could not be converted to a Haskell expression
data ConversionFailReason
IllegalOccName :: !NameSpace -> !String -> ConversionFailReason
SumAltArityExceeded :: !SumAlt -> !SumArity -> ConversionFailReason
IllegalSumAlt :: !SumAlt -> ConversionFailReason
IllegalSumArity :: !SumArity -> ConversionFailReason
MalformedType :: !TypeOrKind -> !Type -> ConversionFailReason
IllegalLastStatement :: !HsDoFlavour -> !LStmt GhcPs (LHsExpr GhcPs) -> ConversionFailReason
KindSigsOnlyAllowedOnGADTs :: ConversionFailReason
IllegalDeclaration :: !THDeclDescriptor -> !IllegalDecls -> ConversionFailReason
CannotMixGADTConsWith98Cons :: ConversionFailReason
EmptyStmtListInDoBlock :: ConversionFailReason
NonVarInInfixExpr :: ConversionFailReason
MultiWayIfWithoutAlts :: ConversionFailReason
CasesExprWithoutAlts :: ConversionFailReason
ImplicitParamsWithOtherBinds :: ConversionFailReason

-- | Source
InvalidCCallImpent :: !String -> ConversionFailReason
RecGadtNoCons :: ConversionFailReason
GadtNoCons :: ConversionFailReason
InvalidTypeInstanceHeader :: !Type -> ConversionFailReason
InvalidTyFamInstLHS :: !Type -> ConversionFailReason
InvalidImplicitParamBinding :: ConversionFailReason
DefaultDataInstDecl :: ![LDataFamInstDecl GhcPs] -> ConversionFailReason
FunBindLacksEquations :: !Name -> ConversionFailReason
data UnrepresentableTypeDescr
LinearInvisibleArgument :: UnrepresentableTypeDescr
CoercionsInTypes :: UnrepresentableTypeDescr
data LookupTHInstNameErrReason
NoMatchesFound :: LookupTHInstNameErrReason
CouldNotDetermineInstance :: LookupTHInstNameErrReason

-- | The phase in which an exception was encountered when dealing with a TH
--   splice
data SplicePhase
SplicePhase_Run :: SplicePhase
SplicePhase_CompileAndLink :: SplicePhase

-- | Label for a TH declaration
data THDeclDescriptor
InstanceDecl :: THDeclDescriptor
WhereClause :: THDeclDescriptor
LetBinding :: THDeclDescriptor
LetExpression :: THDeclDescriptor
ClssDecl :: THDeclDescriptor

-- | Identifies the TH splice attempting to be converted
data ThingBeingConverted
ConvDec :: !Dec -> ThingBeingConverted
ConvExp :: !Exp -> ThingBeingConverted
ConvPat :: !Pat -> ThingBeingConverted
ConvType :: !Type -> ThingBeingConverted
data IllegalDecls
IllegalDecls :: !NonEmpty (LHsDecl GhcPs) -> IllegalDecls
IllegalFamDecls :: !NonEmpty (LFamilyDecl GhcPs) -> IllegalDecls
data ZonkerMessage

-- | ZonkerCannotDefaultConcrete is an error occurring when a concrete type
--   variable cannot be defaulted.
--   
--   Test cases: T23153
[ZonkerCannotDefaultConcrete] :: !FixedRuntimeRepOrigin -> ZonkerMessage
data IllegalForeignTypeReason
TypeCannotBeMarshaled :: !Type -> TypeCannotBeMarshaledReason -> IllegalForeignTypeReason
ForeignDynNotPtr :: !Type -> !Type -> IllegalForeignTypeReason
SafeHaskellMustBeInIO :: IllegalForeignTypeReason
IOResultExpected :: IllegalForeignTypeReason
UnexpectedNestedForall :: IllegalForeignTypeReason
LinearTypesNotAllowed :: IllegalForeignTypeReason
OneArgExpected :: IllegalForeignTypeReason
AtLeastOneArgExpected :: IllegalForeignTypeReason

-- | Reason why a type cannot be marshalled through the FFI.
data TypeCannotBeMarshaledReason
NotADataType :: TypeCannotBeMarshaledReason
NewtypeDataConNotInScope :: !TyCon -> ![Type] -> TypeCannotBeMarshaledReason
UnliftedFFITypesNeeded :: TypeCannotBeMarshaledReason
NotABoxedMarshalableTyCon :: TypeCannotBeMarshaledReason
ForeignLabelNotAPtr :: TypeCannotBeMarshaledReason
NotSimpleUnliftedType :: TypeCannotBeMarshaledReason
NotBoxedKindAny :: TypeCannotBeMarshaledReason
instance GHC.Classes.Eq GHC.Tc.Errors.Types.AssociatedTyLastVarInKind
instance GHC.Classes.Eq GHC.Tc.Errors.Types.AssociatedTyNotParamOverLastTyVar
instance GHC.Classes.Eq GHC.Tc.Errors.Types.DeriveAnyClassEnabled
instance GHC.Classes.Eq GHC.Tc.Errors.Types.Exported
instance GHC.Classes.Eq GHC.Tc.Errors.Types.HasAssociatedDataFamInsts
instance GHC.Classes.Eq GHC.Tc.Errors.Types.HasKinds
instance GHC.Classes.Eq GHC.Tc.Errors.Types.HasWildcard
instance GHC.Classes.Eq GHC.Tc.Errors.Types.SuggestPartialTypeSignatures
instance GHC.Classes.Eq GHC.Tc.Errors.Types.SuggestUndecidableInstances
instance GHC.Classes.Eq GHC.Tc.Errors.Types.UnsupportedCallConvention
instance GHC.Classes.Eq GHC.Tc.Errors.Types.UsingGeneralizedNewtypeDeriving
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.AddTopDeclsError
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.AssocDefaultBadArgs
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.BadFieldAnnotationReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.BadImportKind
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.BadRecordUpdateReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.BootMismatch
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.BootMismatchWhat
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.CannotUnifyVariableReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.ConversionFailReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.DeriveInstanceErrReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.DisabledClassExtension
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.DodgyImportsReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.EmptyStatementGroupErrReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.HsigShapeMismatchReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.IllegalClassInstanceReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.IllegalFamilyInstanceReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.IllegalForeignTypeReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.IllegalHasFieldInstance
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.IllegalInstanceHeadReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.IllegalInstanceReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.IllegalNewtypeReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.ImportLookupReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.InvalidAssoc
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.InvalidAssocDefault
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.InvalidAssocInstance
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.MismatchMsg
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.MissingBootThing
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.NonCanonicalDefinition
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.NotInScopeError
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.PatSynInvalidRhsReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.RoleValidationFailedReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.RunSpliceFailReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.SolverReportWithCtxt
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.SpliceFailReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.THError
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.THNameError
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.THReifyError
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.THSyntaxError
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.TcRnMessage
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.TcRnMessageDetailed
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.TcSolverReportMsg
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.TyFamsDisabledReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.TypeApplication
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.TypeCannotBeMarshaledReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.TypeDataForbids
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.TypeSyntax
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.TypedTHError
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.UnusedImportReason
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.WhenMatching
instance GHC.Internal.Generics.Generic GHC.Tc.Errors.Types.ZonkerMessage
instance GHC.Types.Name.NamedThing GHC.Tc.Errors.Types.InvalidFamInstQTv
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Types.ErrorItem
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Types.Exported
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Types.HsTyVarBndrExistentialFlag
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (GHC.Tc.Errors.Types.HsTypeOrSigType (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Types.TypeDataForbids
instance GHC.Internal.Show.Show GHC.Tc.Errors.Types.HasKinds
instance GHC.Internal.Show.Show GHC.Tc.Errors.Types.SuggestPartialTypeSignatures
instance GHC.Internal.Show.Show GHC.Tc.Errors.Types.SuggestUndecidableInstances

module GHC.Tc.Types.LclEnv
data TcLclEnv
TcLclEnv :: !TcLclCtxt -> TcRef UsageEnv -> TcRef WantedConstraints -> TcRef (Messages TcRnMessage) -> TcLclEnv
[tcl_lcl_ctxt] :: TcLclEnv -> !TcLclCtxt
[tcl_usage] :: TcLclEnv -> TcRef UsageEnv
[tcl_lie] :: TcLclEnv -> TcRef WantedConstraints
[tcl_errs] :: TcLclEnv -> TcRef (Messages TcRnMessage)
data TcLclCtxt
TcLclCtxt :: RealSrcSpan -> [ErrCtxt] -> Bool -> TcLevel -> TcBinderStack -> LocalRdrEnv -> ThStage -> ThBindEnv -> ArrowCtxt -> TcTypeEnv -> TcLclCtxt
[tcl_loc] :: TcLclCtxt -> RealSrcSpan
[tcl_ctxt] :: TcLclCtxt -> [ErrCtxt]
[tcl_in_gen_code] :: TcLclCtxt -> Bool
[tcl_tclvl] :: TcLclCtxt -> TcLevel
[tcl_bndrs] :: TcLclCtxt -> TcBinderStack
[tcl_rdr] :: TcLclCtxt -> LocalRdrEnv
[tcl_th_ctxt] :: TcLclCtxt -> ThStage
[tcl_th_bndrs] :: TcLclCtxt -> ThBindEnv
[tcl_arrow_ctxt] :: TcLclCtxt -> ArrowCtxt
[tcl_env] :: TcLclCtxt -> TcTypeEnv
modifyLclCtxt :: (TcLclCtxt -> TcLclCtxt) -> TcLclEnv -> TcLclEnv
getLclEnvArrowCtxt :: TcLclEnv -> ArrowCtxt
getLclEnvThBndrs :: TcLclEnv -> ThBindEnv
getLclEnvTypeEnv :: TcLclEnv -> TcTypeEnv
getLclEnvBinderStack :: TcLclEnv -> TcBinderStack
getLclEnvErrCtxt :: TcLclEnv -> [ErrCtxt]
getLclEnvLoc :: TcLclEnv -> RealSrcSpan
getLclEnvRdrEnv :: TcLclEnv -> LocalRdrEnv
getLclEnvTcLevel :: TcLclEnv -> TcLevel
getLclEnvThStage :: TcLclEnv -> ThStage
setLclEnvTcLevel :: TcLevel -> TcLclEnv -> TcLclEnv
setLclEnvLoc :: RealSrcSpan -> TcLclEnv -> TcLclEnv
setLclEnvRdrEnv :: LocalRdrEnv -> TcLclEnv -> TcLclEnv
setLclEnvBinderStack :: TcBinderStack -> TcLclEnv -> TcLclEnv
setLclEnvErrCtxt :: [ErrCtxt] -> TcLclEnv -> TcLclEnv
setLclEnvThStage :: ThStage -> TcLclEnv -> TcLclEnv
setLclEnvTypeEnv :: TcTypeEnv -> TcLclEnv -> TcLclEnv
modifyLclEnvTcLevel :: (TcLevel -> TcLevel) -> TcLclEnv -> TcLclEnv
lclEnvInGeneratedCode :: TcLclEnv -> Bool
addLclEnvErrCtxt :: ErrCtxt -> TcLclEnv -> TcLclEnv
data ArrowCtxt
NoArrowCtxt :: ArrowCtxt
ArrowCtxt :: LocalRdrEnv -> TcRef WantedConstraints -> ArrowCtxt
type ThBindEnv = NameEnv (TopLevelFlag, ThLevel)
type TcTypeEnv = NameEnv TcTyThing


-- | Functional dependencies
--   
--   It's better to read it as: "if we know these, then we're going to know
--   these"
module GHC.Tc.Instance.FunDeps
data FunDepEqn loc
FDEqn :: [TyVar] -> [TypeEqn] -> loc -> FunDepEqn loc
[fd_qtvs] :: FunDepEqn loc -> [TyVar]
[fd_eqs] :: FunDepEqn loc -> [TypeEqn]
[fd_loc] :: FunDepEqn loc -> loc
pprEquation :: FunDepEqn a -> SDoc
improveFromInstEnv :: InstEnvs -> (ClsInst -> loc) -> Class -> [Type] -> [FunDepEqn loc]
improveFromAnother :: loc -> PredType -> PredType -> [FunDepEqn loc]
checkInstCoverage :: Bool -> Class -> [PredType] -> [Type] -> Validity' CoverageProblem
checkFunDeps :: InstEnvs -> ClsInst -> [ClsInst]
pprFundeps :: Outputable a => [FunDep a] -> SDoc
instFD :: FunDep TyVar -> [TyVar] -> [Type] -> FunDep Type
closeWrtFunDeps :: [PredType] -> TyCoVarSet -> TyCoVarSet
instance GHC.Internal.Base.Functor GHC.Tc.Instance.FunDeps.FunDepEqn
instance GHC.Utils.Outputable.Outputable (GHC.Tc.Instance.FunDeps.FunDepEqn a)

module GHC.Driver.Errors.Types

-- | The umbrella type that encompasses all the different messages that GHC
--   might output during the different compilation stages. See Note
--   [GhcMessage].
data GhcMessage

-- | A message from the parsing phase.
[GhcPsMessage] :: PsMessage -> GhcMessage

-- | A message from typecheck/renaming phase.
[GhcTcRnMessage] :: TcRnMessage -> GhcMessage

-- | A message from the desugaring (HsToCore) phase.
[GhcDsMessage] :: DsMessage -> GhcMessage

-- | A message from the driver.
[GhcDriverMessage] :: DriverMessage -> GhcMessage

-- | An "escape" hatch which can be used when we don't know the source of
--   the message or if the message is not one of the typed ones. The
--   <a>Diagnostic</a> and <a>Typeable</a> constraints ensure that if we
--   <i>know</i>, at pattern-matching time, the originating type, we can
--   attempt a cast and access the fully-structured error. This would be
--   the case for a GHC plugin that offers a domain-specific error type but
--   that doesn't want to place the burden on IDEs/application code to
--   "know" it. The <a>Diagnostic</a> constraint ensures that worst case
--   scenario we can still render this into something which can be
--   eventually converted into a <a>DecoratedSDoc</a>.
[GhcUnknownMessage] :: UnknownDiagnostic (DiagnosticOpts GhcMessage) -> GhcMessage
data GhcMessageOpts
GhcMessageOpts :: DiagnosticOpts PsMessage -> DiagnosticOpts TcRnMessage -> DiagnosticOpts DsMessage -> DiagnosticOpts DriverMessage -> GhcMessageOpts
[psMessageOpts] :: GhcMessageOpts -> DiagnosticOpts PsMessage
[tcMessageOpts] :: GhcMessageOpts -> DiagnosticOpts TcRnMessage
[dsMessageOpts] :: GhcMessageOpts -> DiagnosticOpts DsMessage
[driverMessageOpts] :: GhcMessageOpts -> DiagnosticOpts DriverMessage

-- | A message from the driver.
data DriverMessage

-- | Simply wraps a generic <a>Diagnostic</a> message <tt>a</tt>.
[DriverUnknownMessage] :: UnknownDiagnostic (DiagnosticOpts DriverMessage) -> DriverMessage

-- | A parse error in parsing a Haskell file header during dependency
--   analysis
[DriverPsHeaderMessage] :: !PsMessage -> DriverMessage

-- | DriverMissingHomeModules is a warning (controlled with
--   -Wmissing-home-modules) that arises when running GHC in --make mode
--   when some modules needed for compilation are not included on the
--   command line. For example, if A imports B, `ghc --make A.hs` will
--   cause this warning, while `ghc --make A.hs B.hs` will not.
--   
--   Useful for cabal to ensure GHC won't pick up modules listed neither in
--   'exposed-modules' nor in 'other-modules'.
--   
--   Test case: warnings<i>should_compile</i>MissingMod
[DriverMissingHomeModules] :: UnitId -> [ModuleName] -> !BuildingCabalPackage -> DriverMessage

-- | DriverUnknown is a warning that arises when a user tries to reexport a
--   module which isn't part of that unit.
[DriverUnknownReexportedModules] :: UnitId -> [ReexportedModule] -> DriverMessage

-- | DriverUnknownHiddenModules is a warning that arises when a user tries
--   to hide a module which isn't part of that unit.
[DriverUnknownHiddenModules] :: UnitId -> [ModuleName] -> DriverMessage

-- | DriverUnusedPackages occurs when when package is requested on command
--   line, but was never needed during compilation. Activated by
--   -Wunused-packages.
--   
--   Test cases: warnings<i>should_compile</i>UnusedPackages
[DriverUnusedPackages] :: [(UnitId, PackageName, Version, PackageArg)] -> DriverMessage

-- | DriverUnnecessarySourceImports (controlled with -Wunused-imports)
--   occurs if there are {-# SOURCE #-} imports which are not necessary.
--   See <tt>warnUnnecessarySourceImports</tt> in <a>Make</a>.
--   
--   Test cases: warnings<i>should_compile</i>T10637
[DriverUnnecessarySourceImports] :: !ModuleName -> DriverMessage

-- | DriverDuplicatedModuleDeclaration occurs if a module <tt>A</tt> is
--   declared in multiple files.
--   
--   Test cases: None.
[DriverDuplicatedModuleDeclaration] :: !Module -> [FilePath] -> DriverMessage

-- | DriverModuleNotFound occurs if a module <tt>A</tt> can't be found.
--   
--   Test cases: None.
[DriverModuleNotFound] :: !ModuleName -> DriverMessage

-- | DriverFileModuleNameMismatch occurs if a module <tt>A</tt> is defined
--   in a file with a different name. The first field is the name written
--   in the source code; the second argument is the name extracted from the
--   filename.
--   
--   Test cases: module<i>mod178, </i>driver/bug1677
[DriverFileModuleNameMismatch] :: !ModuleName -> !ModuleName -> DriverMessage

-- | DriverUnexpectedSignature occurs when GHC encounters a module
--   <tt>A</tt> that imports a signature file which is neither in the
--   <tt>signatures</tt> section of a '.cabal' file nor in any package in
--   the home modules.
--   
--   Example:
--   
--   <ul>
--   <li>- MyStr.hsig is defined, but not added to <tt>signatures</tt> in
--   the '.cabal' file. signature MyStr where data Str</li>
--   <li>- A.hs, which tries to import the signature. module A where import
--   MyStr</li>
--   </ul>
--   
--   Test cases: driver/T12955
[DriverUnexpectedSignature] :: !ModuleName -> !BuildingCabalPackage -> GenInstantiations UnitId -> DriverMessage

-- | DriverFileNotFound occurs when the input file (e.g. given on the
--   command line) can't be found.
--   
--   Test cases: None.
[DriverFileNotFound] :: !FilePath -> DriverMessage

-- | DriverStaticPointersNotSupported occurs when the
--   <tt>StaticPointers</tt> extension is used in an interactive GHCi
--   context.
--   
--   Test cases: ghci<i>scripts</i>StaticPtr
[DriverStaticPointersNotSupported] :: DriverMessage

-- | DriverBackpackModuleNotFound occurs when Backpack can't find a
--   particular module during its dependency analysis.
--   
--   Test cases: -
[DriverBackpackModuleNotFound] :: !ModuleName -> DriverMessage

-- | DriverUserDefinedRuleIgnored is a warning that occurs when
--   user-defined rules are ignored. This typically happens when Safe
--   Haskell.
--   
--   Test cases:
--   
--   tests<i>safeHaskell</i>safeInfered/UnsafeWarn05
--   tests<i>safeHaskell</i>safeInfered/UnsafeWarn06
--   tests<i>safeHaskell</i>safeInfered/UnsafeWarn07
--   tests<i>safeHaskell</i>safeInfered/UnsafeInfered11
--   tests<i>safeHaskell</i>safeLanguage/SafeLang03
[DriverUserDefinedRuleIgnored] :: !RuleDecl GhcTc -> DriverMessage

-- | DriverMixedSafetyImport is an error that occurs when a module is
--   imported both as safe and unsafe.
--   
--   Test cases:
--   
--   tests<i>safeHaskell</i>safeInfered/Mixed03
--   tests<i>safeHaskell</i>safeInfered/Mixed02
[DriverMixedSafetyImport] :: !ModuleName -> DriverMessage

-- | DriverCannotLoadInterfaceFile is an error that occurs when we cannot
--   load the interface file for a particular module. This can happen for
--   example in the context of Safe Haskell, when we have to load a module
--   to check if it can be safely imported.
--   
--   Test cases: None.
[DriverCannotLoadInterfaceFile] :: !Module -> DriverMessage

-- | DriverInferredSafeImport is a warning (controlled by the Opt_WarnSafe
--   flag) that occurs when a module is inferred safe.
--   
--   Test cases: None.
[DriverInferredSafeModule] :: !Module -> DriverMessage

-- | DriverMarkedTrustworthyButInferredSafe is a warning (controlled by the
--   Opt_WarnTrustworthySafe flag) that occurs when a module is marked
--   trustworthy in SafeHaskell but it has been inferred safe.
--   
--   Test cases: tests<i>safeHaskell</i>safeInfered/TrustworthySafe02
--   tests<i>safeHaskell</i>safeInfered/TrustworthySafe03
[DriverMarkedTrustworthyButInferredSafe] :: !Module -> DriverMessage

-- | DriverInferredSafeImport is a warning (controlled by the
--   Opt_WarnInferredSafeImports flag) that occurs when a safe-inferred
--   module is imported from a safe module.
--   
--   Test cases: None.
[DriverInferredSafeImport] :: !Module -> DriverMessage

-- | DriverCannotImportUnsafeModule is an error that occurs when an usafe
--   module is being imported from a safe one.
--   
--   Test cases: None.
[DriverCannotImportUnsafeModule] :: !Module -> DriverMessage

-- | DriverMissingSafeHaskellMode is a warning (controlled by the
--   Opt_WarnMissingSafeHaskellMode flag) that occurs when a module is
--   using SafeHaskell features but SafeHaskell mode is not enabled.
--   
--   Test cases: None.
[DriverMissingSafeHaskellMode] :: !Module -> DriverMessage

-- | DriverPackageNotTrusted is an error that occurs when a package is
--   required to be trusted but it isn't.
--   
--   Test cases: tests<i>safeHaskell</i>check/Check01
--   tests<i>safeHaskell</i>check/Check08
--   tests<i>safeHaskell</i>check/Check06
--   tests<i>safeHaskell</i>check<i>pkg01</i>ImpSafeOnly09
--   tests<i>safeHaskell</i>check<i>pkg01</i>ImpSafe03
--   tests<i>safeHaskell</i>check<i>pkg01</i>ImpSafeOnly07
--   tests<i>safeHaskell</i>check<i>pkg01</i>ImpSafeOnly08
[DriverPackageNotTrusted] :: !UnitState -> !UnitId -> DriverMessage

-- | DriverCannotImportFromUntrustedPackage is an error that occurs in the
--   context of Safe Haskell when trying to import a module coming from an
--   untrusted package.
--   
--   Test cases: tests<i>safeHaskell</i>check/Check09
--   tests<i>safeHaskell</i>check<i>pkg01</i>ImpSafe01
--   tests<i>safeHaskell</i>check<i>pkg01</i>ImpSafe04
--   tests<i>safeHaskell</i>check<i>pkg01</i>ImpSafeOnly03
--   tests<i>safeHaskell</i>check<i>pkg01</i>ImpSafeOnly05
--   tests<i>safeHaskell</i>flags/SafeFlags17
--   tests<i>safeHaskell</i>flags/SafeFlags22
--   tests<i>safeHaskell</i>flags/SafeFlags23
--   tests<i>safeHaskell</i>ghci/p11 tests<i>safeHaskell</i>ghci/p12
--   tests<i>safeHaskell</i>ghci/p17 tests<i>safeHaskell</i>ghci/p3
--   tests<i>safeHaskell</i>safeInfered/UnsafeInfered01
--   tests<i>safeHaskell</i>safeInfered/UnsafeInfered02
--   tests<i>safeHaskell</i>safeInfered/UnsafeInfered02
--   tests<i>safeHaskell</i>safeInfered/UnsafeInfered03
--   tests<i>safeHaskell</i>safeInfered/UnsafeInfered05
--   tests<i>safeHaskell</i>safeInfered/UnsafeInfered06
--   tests<i>safeHaskell</i>safeInfered/UnsafeInfered09
--   tests<i>safeHaskell</i>safeInfered/UnsafeInfered10
--   tests<i>safeHaskell</i>safeInfered/UnsafeInfered11
--   tests<i>safeHaskell</i>safeInfered/UnsafeWarn01
--   tests<i>safeHaskell</i>safeInfered/UnsafeWarn03
--   tests<i>safeHaskell</i>safeInfered/UnsafeWarn04
--   tests<i>safeHaskell</i>safeInfered/UnsafeWarn05
--   tests<i>safeHaskell</i>unsafeLibs/BadImport01
--   tests<i>safeHaskell</i>unsafeLibs/BadImport06
--   tests<i>safeHaskell</i>unsafeLibs/BadImport07
--   tests<i>safeHaskell</i>unsafeLibs/BadImport08
--   tests<i>safeHaskell</i>unsafeLibs/BadImport09
--   tests<i>safeHaskell</i>unsafeLibs/Dep05
--   tests<i>safeHaskell</i>unsafeLibs/Dep06
--   tests<i>safeHaskell</i>unsafeLibs/Dep07
--   tests<i>safeHaskell</i>unsafeLibs/Dep08
--   tests<i>safeHaskell</i>unsafeLibs/Dep09
--   tests<i>safeHaskell</i>unsafeLibs/Dep10
[DriverCannotImportFromUntrustedPackage] :: !UnitState -> !Module -> DriverMessage
[DriverRedirectedNoMain] :: !ModuleName -> DriverMessage
[DriverHomePackagesNotClosed] :: ![UnitId] -> DriverMessage
[DriverInterfaceError] :: !IfaceMessage -> DriverMessage
[DriverInconsistentDynFlags] :: String -> DriverMessage
[DriverSafeHaskellIgnoredExtension] :: !Extension -> DriverMessage
[DriverPackageTrustIgnored] :: DriverMessage
[DriverUnrecognisedFlag] :: String -> DriverMessage
[DriverDeprecatedFlag] :: String -> String -> DriverMessage

-- | DriverModuleGraphCycle is an error that occurs if the module graph
--   contains cyclic imports.
--   
--   Test cases: tests<i>backpack</i>should_fail/bkpfail51
--   tests<i>driver</i>T20459 tests<i>driver</i>T24196/T24196
--   tests<i>driver</i>T24275/T24275
[DriverModuleGraphCycle] :: [ModuleGraphNode] -> DriverMessage

-- | DriverInstantiationNodeInDependencyGeneration is an error that occurs
--   if the module graph used for dependency generation contains Backpack
--   <a>InstantiationNode</a>s.
[DriverInstantiationNodeInDependencyGeneration] :: InstantiatedUnit -> DriverMessage

-- | DriverNoConfiguredLLVMToolchain is an error that occurs if there is no
--   LLVM toolchain configured but -fllvm is passed as an option to the
--   compiler.
--   
--   Test cases: None.
[DriverNoConfiguredLLVMToolchain] :: DriverMessage
data DriverMessageOpts
DriverMessageOpts :: DiagnosticOpts PsMessage -> DiagnosticOpts IfaceMessage -> DriverMessageOpts
[psDiagnosticOpts] :: DriverMessageOpts -> DiagnosticOpts PsMessage
[ifaceDiagnosticOpts] :: DriverMessageOpts -> DiagnosticOpts IfaceMessage

-- | A collection of driver messages
type DriverMessages = Messages DriverMessage
data PsMessage

-- | A group of parser messages emitted in <a>Header</a>. See Note
--   [Messages from GHC.Parser.Header].
PsHeaderMessage :: !PsHeaderMessage -> PsMessage

-- | A collection of warning messages. <i>INVARIANT</i>: Each
--   <a>GhcMessage</a> in the collection should have <a>SevWarning</a>
--   severity.
type WarningMessages = Messages GhcMessage

-- | A collection of error messages. <i>INVARIANT</i>: Each
--   <a>GhcMessage</a> in the collection should have <a>SevError</a>
--   severity.
type ErrorMessages = Messages GhcMessage

-- | A single warning message. <i>INVARIANT</i>: It must have
--   <a>SevWarning</a> severity.
type WarnMsg = MsgEnvelope GhcMessage

-- | Creates a new <a>GhcMessage</a> out of any diagnostic. This function
--   is also provided to ease the integration of #18516 by allowing
--   diagnostics to be wrapped into the general (but structured)
--   <a>GhcMessage</a> type, so that the conversion can happen gradually.
--   This function should not be needed within GHC, as it would typically
--   be used by plugin or library authors (see comment for the
--   <a>GhcUnknownMessage</a> type constructor)
ghcUnknownMessage :: (DiagnosticOpts a ~ NoDiagnosticOpts, Diagnostic a, Typeable a) => a -> GhcMessage

-- | Abstracts away the frequent pattern where we are calling
--   <tt>ioMsgMaybe</tt> on the result of 'IO (Messages TcRnMessage, a)'.
hoistTcRnMessage :: Monad m => m (Messages TcRnMessage, a) -> m (Messages GhcMessage, a)

-- | Abstracts away the frequent pattern where we are calling
--   <tt>ioMsgMaybe</tt> on the result of 'IO (Messages DsMessage, a)'.
hoistDsMessage :: Monad m => m (Messages DsMessage, a) -> m (Messages GhcMessage, a)

-- | Checks if we are building a cabal package by consulting the
--   <a>DynFlags</a>.
checkBuildingCabalPackage :: DynFlags -> BuildingCabalPackage
instance GHC.Internal.Generics.Generic GHC.Driver.Errors.Types.DriverMessage
instance GHC.Internal.Generics.Generic GHC.Driver.Errors.Types.GhcMessage


-- | Defines diagnostic codes for the diagnostics emitted by GHC.
--   
--   A diagnostic code is a numeric unique identifier for a diagnostic. See
--   Note [Diagnostic codes].
module GHC.Types.Error.Codes

-- | Type family computing the numeric diagnostic code for a given error
--   message constructor.
--   
--   Its injectivity annotation ensures uniqueness of error codes.
--   
--   Never remove a return value from this type family! Outdated error
--   messages must still be tracked here to ensure uniqueness of diagnostic
--   codes across GHC versions.
--   
--   See Note [Diagnostic codes] in GHC.Types.Error.
type family GhcDiagnosticCode (c :: Symbol) = (n :: Nat) | n -> c

-- | This function obtain a diagnostic code by looking up the constructor
--   name using generics, and using the <a>GhcDiagnosticCode</a> type
--   family.
constructorCode :: (Generic diag, GDiagnosticCode (Rep diag)) => diag -> Maybe DiagnosticCode

-- | This function computes all diagnostic codes that occur inside a given
--   type using generics and the <a>GhcDiagnosticCode</a> type family.
--   
--   For example, if <tt>T = MkT1 | MkT2</tt>, <tt>GhcDiagnosticCode "MkT1"
--   = 123</tt> and <tt>GhcDiagnosticCode "MkT2" = 456</tt>, then we will
--   get &gt; constructorCodes @T = fromList [ (123, "MkT1"), (456, "MkT2")
--   ]
constructorCodes :: (Generic diag, GDiagnosticCodes '[diag] (Rep diag)) => Map DiagnosticCode String
instance (GHC.Types.Error.Codes.ConRecursInto con GHC.Types.~ 'GHC.Internal.Maybe.Just (GHC.Types.Error.UnknownDiagnostic opts), GHC.Types.Error.Codes.HasType (GHC.Types.Error.UnknownDiagnostic opts) con f) => GHC.Types.Error.Codes.ConstructorCode con f ('GHC.Internal.Maybe.Just (GHC.Types.Error.UnknownDiagnostic opts))
instance (GHC.Types.Error.Codes.ConRecursInto con GHC.Types.~ 'GHC.Internal.Maybe.Just ty, GHC.Types.Error.Codes.HasType ty con f, GHC.Internal.Generics.Generic ty, GHC.Types.Error.Codes.GDiagnosticCode (GHC.Internal.Generics.Rep ty)) => GHC.Types.Error.Codes.ConstructorCode con f ('GHC.Internal.Maybe.Just ty)
instance (GHC.Types.Error.Codes.KnownConstructor con, GHC.Internal.TypeLits.KnownSymbol con) => GHC.Types.Error.Codes.ConstructorCode con f 'GHC.Internal.Maybe.Nothing
instance (GHC.Types.Error.Codes.ConRecursInto con GHC.Types.~ 'GHC.Internal.Maybe.Just ty, GHC.Types.Error.Codes.HasType ty con f, GHC.Internal.Generics.Generic ty, GHC.Types.Error.Codes.GDiagnosticCodes (GHC.Types.Error.Codes.Insert ty seen) (GHC.Internal.Generics.Rep ty), GHC.Types.Error.Codes.Seen seen ty) => GHC.Types.Error.Codes.ConstructorCodes con f seen ('GHC.Internal.Maybe.Just ty)
instance (GHC.Types.Error.Codes.ConRecursInto con GHC.Types.~ 'GHC.Internal.Maybe.Just (GHC.Types.Error.UnknownDiagnostic opts)) => GHC.Types.Error.Codes.ConstructorCodes con f seen ('GHC.Internal.Maybe.Just (GHC.Types.Error.UnknownDiagnostic opts))
instance (GHC.Types.Error.Codes.KnownConstructor con, GHC.Internal.TypeLits.KnownSymbol con) => GHC.Types.Error.Codes.ConstructorCodes con f seen 'GHC.Internal.Maybe.Nothing
instance (GHC.Types.Error.Codes.GDiagnosticCode f, GHC.Types.Error.Codes.GDiagnosticCode g) => GHC.Types.Error.Codes.GDiagnosticCode (f GHC.Internal.Generics.:+: g)
instance (GHC.Types.Error.Codes.ConstructorCode con f recur, recur GHC.Types.~ GHC.Types.Error.Codes.ConRecursInto con, GHC.Internal.TypeLits.KnownSymbol con) => GHC.Types.Error.Codes.GDiagnosticCode (GHC.Internal.Generics.M1 i ('GHC.Internal.Generics.MetaCons con x y) f)
instance GHC.Types.Error.Codes.GDiagnosticCode f => GHC.Types.Error.Codes.GDiagnosticCode (GHC.Internal.Generics.M1 i ('GHC.Internal.Generics.MetaData nm mod pkg nt) f)
instance (GHC.Types.Error.Codes.GDiagnosticCodes seen f, GHC.Types.Error.Codes.GDiagnosticCodes seen g) => GHC.Types.Error.Codes.GDiagnosticCodes seen (f GHC.Internal.Generics.:+: g)
instance (GHC.Types.Error.Codes.ConstructorCodes con f seen recur, recur GHC.Types.~ GHC.Types.Error.Codes.ConRecursInto con, GHC.Internal.TypeLits.KnownSymbol con) => GHC.Types.Error.Codes.GDiagnosticCodes seen (GHC.Internal.Generics.M1 i ('GHC.Internal.Generics.MetaCons con x y) f)
instance GHC.Types.Error.Codes.GDiagnosticCodes seen f => GHC.Types.Error.Codes.GDiagnosticCodes seen (GHC.Internal.Generics.M1 i ('GHC.Internal.Generics.MetaData nm mod pkg nt) f)
instance forall a ty (orig :: GHC.Types.Symbol) (f :: * -> *) (l :: a) (g :: * -> *). GHC.Types.Error.Codes.HasType ty orig f => GHC.Types.Error.Codes.HasTypeProd ty ('GHC.Internal.Maybe.Just l) orig f g
instance GHC.Types.Error.Codes.HasType ty orig g => GHC.Types.Error.Codes.HasTypeProd ty 'GHC.Internal.Maybe.Nothing orig f g
instance GHC.Types.Error.Codes.HasTypeProd ty (GHC.Types.Error.Codes.HasTypeQ ty f) orig f g => GHC.Types.Error.Codes.HasType ty orig (f GHC.Internal.Generics.:*: g)
instance GHC.Types.Error.Codes.HasType ty orig (GHC.Internal.Generics.M1 i s (GHC.Internal.Generics.K1 x ty))
instance (TypeError ...) => GHC.Types.Error.Codes.HasType ty orig f
instance GHC.Types.Error.Codes.Seen (ty : tys) ty
instance GHC.Types.Error.Codes.Seen tys ty => GHC.Types.Error.Codes.Seen (ty' : tys) ty
instance GHC.Types.Error.Codes.Seen '[] ty

module GHC.Parser.Errors.Ppr
psHeaderMessageDiagnostic :: PsHeaderMessage -> DecoratedSDoc
psHeaderMessageReason :: PsHeaderMessage -> DiagnosticReason
psHeaderMessageHints :: PsHeaderMessage -> [GhcHint]
suggestParensAndBlockArgs :: [GhcHint]
pp_unexpected_fun_app :: Outputable a => SDoc -> a -> SDoc
parse_error_in_pat :: SDoc
forallSym :: Bool -> SDoc
pprFileHeaderPragmaType :: FileHeaderPragmaType -> SDoc
instance GHC.Types.Error.Diagnostic GHC.Parser.Errors.Types.PsMessage

module GHC.Parser.Lexer
data Token
ITas :: Token
ITcase :: Token
ITclass :: Token
ITdata :: Token
ITdefault :: Token
ITderiving :: Token
ITdo :: Maybe FastString -> Token
ITelse :: Token
IThiding :: Token
ITforeign :: Token
ITif :: Token
ITimport :: Token
ITin :: Token
ITinfix :: Token
ITinfixl :: Token
ITinfixr :: Token
ITinstance :: Token
ITlet :: Token
ITmodule :: Token
ITnewtype :: Token
ITof :: Token
ITqualified :: Token
ITthen :: Token
ITtype :: Token
ITwhere :: Token
ITforall :: IsUnicodeSyntax -> Token
ITexport :: Token
ITlabel :: Token
ITdynamic :: Token
ITsafe :: Token
ITinterruptible :: Token
ITunsafe :: Token
ITstdcallconv :: Token
ITccallconv :: Token
ITcapiconv :: Token
ITprimcallconv :: Token
ITjavascriptcallconv :: Token
ITmdo :: Maybe FastString -> Token
ITfamily :: Token
ITrole :: Token
ITgroup :: Token
ITby :: Token
ITusing :: Token
ITpattern :: Token
ITstatic :: Token
ITstock :: Token
ITanyclass :: Token
ITvia :: Token
ITunit :: Token
ITsignature :: Token
ITdependency :: Token
ITrequires :: Token
ITinline_prag :: SourceText -> InlineSpec -> RuleMatchInfo -> Token
ITopaque_prag :: SourceText -> Token
ITspec_prag :: SourceText -> Token
ITspec_inline_prag :: SourceText -> Bool -> Token
ITsource_prag :: SourceText -> Token
ITrules_prag :: SourceText -> Token
ITwarning_prag :: SourceText -> Token
ITdeprecated_prag :: SourceText -> Token
ITline_prag :: SourceText -> Token
ITcolumn_prag :: SourceText -> Token
ITscc_prag :: SourceText -> Token
ITunpack_prag :: SourceText -> Token
ITnounpack_prag :: SourceText -> Token
ITann_prag :: SourceText -> Token
ITcomplete_prag :: SourceText -> Token
ITclose_prag :: Token
IToptions_prag :: String -> Token
ITinclude_prag :: String -> Token
ITlanguage_prag :: Token
ITminimal_prag :: SourceText -> Token
IToverlappable_prag :: SourceText -> Token
IToverlapping_prag :: SourceText -> Token
IToverlaps_prag :: SourceText -> Token
ITincoherent_prag :: SourceText -> Token
ITctype :: SourceText -> Token
ITcomment_line_prag :: Token
ITdotdot :: Token
ITcolon :: Token
ITdcolon :: IsUnicodeSyntax -> Token
ITequal :: Token
ITlam :: Token
ITlcase :: Token
ITlcases :: Token
ITvbar :: Token
ITlarrow :: IsUnicodeSyntax -> Token
ITrarrow :: IsUnicodeSyntax -> Token
ITdarrow :: IsUnicodeSyntax -> Token
ITlolly :: Token
ITminus :: Token
ITprefixminus :: Token
ITbang :: Token
ITtilde :: Token
ITat :: Token
ITtypeApp :: Token
ITpercent :: Token
ITstar :: IsUnicodeSyntax -> Token
ITdot :: Token
ITproj :: Bool -> Token
ITbiglam :: Token
ITocurly :: Token
ITccurly :: Token
ITvocurly :: Token
ITvccurly :: Token
ITobrack :: Token
ITopabrack :: Token
ITcpabrack :: Token
ITcbrack :: Token
IToparen :: Token
ITcparen :: Token
IToubxparen :: Token
ITcubxparen :: Token
ITsemi :: Token
ITcomma :: Token
ITunderscore :: Token
ITbackquote :: Token
ITsimpleQuote :: Token
ITvarid :: FastString -> Token
ITconid :: FastString -> Token
ITvarsym :: FastString -> Token
ITconsym :: FastString -> Token
ITqvarid :: (FastString, FastString) -> Token
ITqconid :: (FastString, FastString) -> Token
ITqvarsym :: (FastString, FastString) -> Token
ITqconsym :: (FastString, FastString) -> Token
ITdupipvarid :: FastString -> Token
ITlabelvarid :: SourceText -> FastString -> Token
ITchar :: SourceText -> Char -> Token
ITstring :: SourceText -> FastString -> Token
ITstringMulti :: SourceText -> FastString -> Token
ITinteger :: IntegralLit -> Token
ITrational :: FractionalLit -> Token
ITprimchar :: SourceText -> Char -> Token
ITprimstring :: SourceText -> ByteString -> Token
ITprimint :: SourceText -> Integer -> Token
ITprimword :: SourceText -> Integer -> Token
ITprimint8 :: SourceText -> Integer -> Token
ITprimint16 :: SourceText -> Integer -> Token
ITprimint32 :: SourceText -> Integer -> Token
ITprimint64 :: SourceText -> Integer -> Token
ITprimword8 :: SourceText -> Integer -> Token
ITprimword16 :: SourceText -> Integer -> Token
ITprimword32 :: SourceText -> Integer -> Token
ITprimword64 :: SourceText -> Integer -> Token
ITprimfloat :: FractionalLit -> Token
ITprimdouble :: FractionalLit -> Token
ITopenExpQuote :: HasE -> IsUnicodeSyntax -> Token
ITopenPatQuote :: Token
ITopenDecQuote :: Token
ITopenTypQuote :: Token
ITcloseQuote :: IsUnicodeSyntax -> Token
ITopenTExpQuote :: HasE -> Token
ITcloseTExpQuote :: Token
ITdollar :: Token
ITdollardollar :: Token
ITtyQuote :: Token
ITquasiQuote :: (FastString, FastString, PsSpan) -> Token
ITqQuasiQuote :: (FastString, FastString, FastString, PsSpan) -> Token
ITproc :: Token
ITrec :: Token

-- | <pre>
--   (|
--   </pre>
IToparenbar :: IsUnicodeSyntax -> Token

-- | <pre>
--   |)
--   </pre>
ITcparenbar :: IsUnicodeSyntax -> Token

-- | <pre>
--   -&lt;
--   </pre>
ITlarrowtail :: IsUnicodeSyntax -> Token

-- | <pre>
--   &gt;-
--   </pre>
ITrarrowtail :: IsUnicodeSyntax -> Token

-- | <pre>
--   -&lt;&lt;
--   </pre>
ITLarrowtail :: IsUnicodeSyntax -> Token

-- | <pre>
--   &gt;&gt;-
--   </pre>
ITRarrowtail :: IsUnicodeSyntax -> Token

-- | Used when the lexer can't make sense of it
ITunknown :: String -> Token

-- | end of file token
ITeof :: Token

-- | The HsDocString contains more details about what this is and how to
--   pretty print it
ITdocComment :: HsDocString -> PsSpan -> Token

-- | doc options (prune, ignore-exports, etc)
ITdocOptions :: String -> PsSpan -> Token

-- | comment starting by "--"
ITlineComment :: String -> PsSpan -> Token

-- | comment in {- -}
ITblockComment :: String -> PsSpan -> Token
lexer :: Bool -> (Located Token -> P a) -> P a
lexerDbg :: Bool -> (Located Token -> P a) -> P a

-- | Parser options.
--   
--   See <a>mkParserOpts</a> to construct this.
data ParserOpts
ParserOpts :: !ExtsBitmap -> !DiagOpts -> [String] -> ParserOpts

-- | bitmap of permitted extensions
[pExtsBitmap] :: ParserOpts -> !ExtsBitmap

-- | Options to construct diagnostic messages.
[pDiagOpts] :: ParserOpts -> !DiagOpts

-- | supported extensions (only used for suggestions in error messages)
[pSupportedExts] :: ParserOpts -> [String]

-- | Given exactly the information needed, set up the <a>ParserOpts</a>
mkParserOpts :: EnumSet Extension -> DiagOpts -> [String] -> Bool -> Bool -> Bool -> Bool -> ParserOpts
data PState
PState :: StringBuffer -> ParserOpts -> Messages PsMessage -> Messages PsMessage -> Maybe RealSrcSpan -> !Word -> Maybe (PsLocated Token) -> PsSpan -> PsSpan -> !Int -> PsLoc -> [LayoutContext] -> [Int] -> [FastString] -> [PsLocated Token] -> Maybe (PsLocated Token) -> PsSpan -> [ALRContext] -> Maybe ALRLayout -> Bool -> Maybe (Pair RealSrcSpan RealSrcSpan) -> Maybe [LEpaComment] -> [LEpaComment] -> OrdList (PsLocated HdkComment) -> PState
[buffer] :: PState -> StringBuffer
[options] :: PState -> ParserOpts
[warnings] :: PState -> Messages PsMessage
[errors] :: PState -> Messages PsMessage
[tab_first] :: PState -> Maybe RealSrcSpan
[tab_count] :: PState -> !Word
[last_tk] :: PState -> Maybe (PsLocated Token)
[prev_loc] :: PState -> PsSpan
[last_loc] :: PState -> PsSpan
[last_len] :: PState -> !Int
[loc] :: PState -> PsLoc
[context] :: PState -> [LayoutContext]
[lex_state] :: PState -> [Int]
[srcfiles] :: PState -> [FastString]
[alr_pending_implicit_tokens] :: PState -> [PsLocated Token]
[alr_next_token] :: PState -> Maybe (PsLocated Token)
[alr_last_loc] :: PState -> PsSpan
[alr_context] :: PState -> [ALRContext]
[alr_expecting_ocurly] :: PState -> Maybe ALRLayout
[alr_justClosedExplicitLetBlock] :: PState -> Bool
[eof_pos] :: PState -> Maybe (Pair RealSrcSpan RealSrcSpan)
[header_comments] :: PState -> Maybe [LEpaComment]
[comment_q] :: PState -> [LEpaComment]
[hdk_comments] :: PState -> OrdList (PsLocated HdkComment)

-- | Creates a parse state from a <a>ParserOpts</a> value
initParserState :: ParserOpts -> StringBuffer -> RealSrcLoc -> PState

-- | Set parser options for parsing OPTIONS pragmas
initPragState :: ParserOpts -> StringBuffer -> RealSrcLoc -> PState

-- | The parsing monad, isomorphic to <tt>StateT PState Maybe</tt>.
newtype P a
P :: (PState -> ParseResult a) -> P a
[unP] :: P a -> PState -> ParseResult a

-- | The result of running a parser.
data ParseResult a :: TYPE 'SumRep '[ 'TupleRep '[LiftedRep, LiftedRep], LiftedRep]

-- | The parser has consumed a (possibly empty) prefix of the input and
--   produced a result. Use <a>getPsMessages</a> to check for accumulated
--   warnings and non-fatal errors.
--   
--   The carried parsing state can be used to resume parsing.
pattern POk :: PState -> a -> ParseResult a

-- | The parser has consumed a (possibly empty) prefix of the input and
--   failed.
--   
--   The carried parsing state can be used to resume parsing. It is the
--   state right before failure, including the fatal parse error.
--   <a>getPsMessages</a> and <a>getPsErrorMessages</a> must return a
--   non-empty bag of errors.
pattern PFailed :: PState -> ParseResult a
allocateComments :: RealSrcSpan -> [LEpaComment] -> ([LEpaComment], [LEpaComment])
allocatePriorComments :: RealSrcSpan -> [LEpaComment] -> Maybe [LEpaComment] -> (Maybe [LEpaComment], [LEpaComment], [LEpaComment])
allocateFinalComments :: RealSrcSpan -> [LEpaComment] -> Maybe [LEpaComment] -> (Maybe [LEpaComment], [LEpaComment], [LEpaComment])

-- | An mtl-style class for monads that support parsing-related operations.
--   For example, sometimes we make a second pass over the parsing results
--   to validate, disambiguate, or rearrange them, and we do so in the PV
--   monad which cannot consume input but can report parsing errors, check
--   for extension bits, and accumulate parsing annotations. Both P and PV
--   are instances of MonadP.
--   
--   MonadP grants us convenient overloading. The other option is to have
--   separate operations for each monad: addErrorP vs addErrorPV, getBitP
--   vs getBitPV, and so on.
class Monad m => MonadP (m :: Type -> Type)

-- | Add a non-fatal error. Use this when the parser can produce a result
--   despite the error.
--   
--   For example, when GHC encounters a <tt>forall</tt> in a type, but
--   <tt>-XExplicitForAll</tt> is disabled, the parser constructs
--   <tt>ForAllTy</tt> as if <tt>-XExplicitForAll</tt> was enabled, adding
--   a non-fatal error to the accumulator.
--   
--   Control flow wise, non-fatal errors act like warnings: they are added
--   to the accumulator and parsing continues. This allows GHC to report
--   more than one parse error per file.
addError :: MonadP m => MsgEnvelope PsMessage -> m ()

-- | Add a warning to the accumulator. Use <a>getPsMessages</a> to get the
--   accumulated warnings.
addWarning :: MonadP m => MsgEnvelope PsMessage -> m ()

-- | Add a fatal error. This will be the last error reported by the parser,
--   and the parser will not produce any result, ending in a <a>PFailed</a>
--   state.
addFatalError :: MonadP m => MsgEnvelope PsMessage -> m a

-- | Get parser options
getParserOpts :: MonadP m => m ParserOpts

-- | Go through the <tt>comment_q</tt> in <tt>PState</tt> and remove all
--   comments that belong within the given span
allocateCommentsP :: MonadP m => RealSrcSpan -> m EpAnnComments

-- | Go through the <tt>comment_q</tt> in <tt>PState</tt> and remove all
--   comments that come before or within the given span
allocatePriorCommentsP :: MonadP m => RealSrcSpan -> m EpAnnComments

-- | Go through the <tt>comment_q</tt> in <tt>PState</tt> and remove all
--   comments that come after the given span
allocateFinalCommentsP :: MonadP m => RealSrcSpan -> m EpAnnComments

-- | Check if a given flag is currently set in the bitmap.
getBit :: MonadP m => ExtBits -> m Bool
getRealSrcLoc :: P RealSrcLoc
getPState :: P PState
failMsgP :: (SrcSpan -> MsgEnvelope PsMessage) -> P a
failLocMsgP :: RealSrcLoc -> RealSrcLoc -> (SrcSpan -> MsgEnvelope PsMessage) -> P a
srcParseFail :: P a

-- | Get a bag of the errors that have been accumulated so far. Does not
--   take -Werror into account.
getPsErrorMessages :: PState -> Messages PsMessage

-- | Get the warnings and errors accumulated so far. Does not take -Werror
--   into account.
getPsMessages :: PState -> (Messages PsMessage, Messages PsMessage)
popContext :: P ()
pushModuleContext :: P ()
setLastToken :: PsSpan -> Int -> P ()
setSrcLoc :: RealSrcLoc -> P ()
activeContext :: P Bool
nextIsEOF :: P Bool
getLexState :: P Int
popLexState :: P Int
pushLexState :: Int -> P ()

-- | Various boolean flags, mostly language extensions, that impact lexing
--   and parsing. Note that a handful of these can change during
--   lexing/parsing.
data ExtBits
FfiBit :: ExtBits
InterruptibleFfiBit :: ExtBits
CApiFfiBit :: ExtBits
ArrowsBit :: ExtBits
ThBit :: ExtBits
ThQuotesBit :: ExtBits
IpBit :: ExtBits
OverloadedLabelsBit :: ExtBits
ExplicitForallBit :: ExtBits
BangPatBit :: ExtBits
PatternSynonymsBit :: ExtBits
HaddockBit :: ExtBits
MagicHashBit :: ExtBits
RecursiveDoBit :: ExtBits
QualifiedDoBit :: ExtBits
UnicodeSyntaxBit :: ExtBits
UnboxedParensBit :: ExtBits
DatatypeContextsBit :: ExtBits
MonadComprehensionsBit :: ExtBits
TransformComprehensionsBit :: ExtBits
QqBit :: ExtBits
RawTokenStreamBit :: ExtBits
AlternativeLayoutRuleBit :: ExtBits
ALRTransitionalBit :: ExtBits
RelaxedLayoutBit :: ExtBits
NondecreasingIndentationBit :: ExtBits
SafeHaskellBit :: ExtBits
TraditionalRecordSyntaxBit :: ExtBits
ExplicitNamespacesBit :: ExtBits
LambdaCaseBit :: ExtBits
BinaryLiteralsBit :: ExtBits
NegativeLiteralsBit :: ExtBits
HexFloatLiteralsBit :: ExtBits
StaticPointersBit :: ExtBits
NumericUnderscoresBit :: ExtBits
StarIsTypeBit :: ExtBits
BlockArgumentsBit :: ExtBits
NPlusKPatternsBit :: ExtBits
DoAndIfThenElseBit :: ExtBits
MultiWayIfBit :: ExtBits
GadtSyntaxBit :: ExtBits
ImportQualifiedPostBit :: ExtBits
LinearTypesBit :: ExtBits
NoLexicalNegationBit :: ExtBits
OverloadedRecordDotBit :: ExtBits
OverloadedRecordUpdateBit :: ExtBits
OrPatternsBit :: ExtBits
ExtendedLiteralsBit :: ExtBits
ListTuplePunsBit :: ExtBits
ViewPatternsBit :: ExtBits
RequiredTypeArgumentsBit :: ExtBits
MultilineStringsBit :: ExtBits
InRulePragBit :: ExtBits
InNestedCommentBit :: ExtBits

-- | If this is enabled, '{-# LINE ... -#}' and '{-# COLUMN ... #-}' update
--   the internal position. Otherwise, those pragmas are lexed as tokens of
--   their own.
UsePosPragsBit :: ExtBits
xtest :: ExtBits -> ExtsBitmap -> Bool
xunset :: ExtBits -> ExtsBitmap -> ExtsBitmap
xset :: ExtBits -> ExtsBitmap -> ExtsBitmap
disableHaddock :: ParserOpts -> ParserOpts
lexTokenStream :: ParserOpts -> StringBuffer -> RealSrcLoc -> ParseResult [Located Token]

-- | Given a <a>RealSrcSpan</a> that surrounds a <tt>HsPar</tt> or
--   <tt>HsParTy</tt>, generate <a>EpToken</a> values for the opening and
--   closing bordering on the start and end of the span
mkParensEpToks :: RealSrcSpan -> (EpToken "(", EpToken ")")

-- | Given a <a>RealSrcSpan</a> that surrounds a <tt>HsPar</tt> or
--   <tt>HsParTy</tt>, generate <a>EpaLocation</a> values for the opening
--   and closing bordering on the start and end of the span
mkParensLocs :: RealSrcSpan -> (EpaLocation, EpaLocation)
getCommentsFor :: MonadP m => SrcSpan -> m EpAnnComments
getPriorCommentsFor :: MonadP m => SrcSpan -> m EpAnnComments
getFinalCommentsFor :: MonadP m => SrcSpan -> m EpAnnComments
getEofPos :: P (Maybe (Pair RealSrcSpan RealSrcSpan))
commentToAnnotation :: RealLocated Token -> LEpaComment

-- | Haddock comment as produced by the lexer. These are accumulated in
--   <a>PState</a> and then processed in
--   <a>GHC.Parser.PostProcess.Haddock</a>. The location of the
--   <a>HsDocString</a>s spans over the contents of the docstring - i.e. it
--   does not include the decorator ("-- |", "{-|" etc.)
data HdkComment
HdkCommentNext :: HsDocString -> HdkComment
HdkCommentPrev :: HsDocString -> HdkComment
HdkCommentNamed :: String -> HsDocString -> HdkComment
HdkCommentSection :: Int -> HsDocString -> HdkComment

-- | Test whether a <a>WarningFlag</a> is set
warnopt :: WarningFlag -> ParserOpts -> Bool
adjustChar :: Char -> Word8
addPsMessage :: MonadP m => SrcSpan -> PsMessage -> m ()
instance GHC.Internal.Base.Applicative GHC.Parser.Lexer.P
instance GHC.Internal.Enum.Enum GHC.Parser.Lexer.ExtBits
instance GHC.Internal.Base.Functor GHC.Parser.Lexer.P
instance GHC.Internal.Base.Monad GHC.Parser.Lexer.P
instance GHC.Parser.Lexer.MonadP GHC.Parser.Lexer.P
instance GHC.Utils.Outputable.Outputable GHC.Parser.Lexer.Token
instance GHC.Internal.Show.Show GHC.Parser.Lexer.AlexInput
instance GHC.Internal.Show.Show GHC.Parser.Lexer.HdkComment
instance GHC.Internal.Show.Show GHC.Parser.Lexer.LayoutContext
instance GHC.Internal.Show.Show GHC.Parser.Lexer.OpWs
instance GHC.Internal.Show.Show GHC.Parser.Lexer.Token

module GHC.Parser.PostProcess
mkRdrGetField :: LHsExpr GhcPs -> LocatedAn NoEpAnns (DotFieldOcc GhcPs) -> HsExpr GhcPs
mkRdrProjection :: NonEmpty (LocatedAn NoEpAnns (DotFieldOcc GhcPs)) -> AnnProjection -> HsExpr GhcPs
type Fbind b = Either LHsRecField GhcPs LocatedA b LHsRecProj GhcPs LocatedA b

-- | A useful function for building <tt>OpApps</tt>. The operator is always
--   a variable, and we don't know the fixity yet.
mkHsOpApp :: LHsExpr GhcPs -> IdP GhcPs -> LHsExpr GhcPs -> HsExpr GhcPs
mkHsIntegral :: IntegralLit -> HsOverLit GhcPs
mkHsFractional :: FractionalLit -> HsOverLit GhcPs
mkHsIsString :: SourceText -> FastString -> HsOverLit GhcPs
mkHsDo :: HsDoFlavour -> LocatedLW [ExprLStmt GhcPs] -> HsExpr GhcPs
mkMDo :: HsDoFlavour -> LocatedLW [ExprLStmt GhcPs] -> EpaLocation -> EpaLocation -> HsExpr GhcPs
mkSpliceDecl :: LHsExpr GhcPs -> LHsDecl GhcPs
mkRoleAnnotDecl :: SrcSpan -> LocatedN RdrName -> [Located (Maybe FastString)] -> (EpToken "type", EpToken "role") -> P (LRoleAnnotDecl GhcPs)
mkClassDecl :: SrcSpan -> Located (Maybe (LHsContext GhcPs), LHsType GhcPs) -> Located (a, [LHsFunDep GhcPs]) -> OrdList (LHsDecl GhcPs) -> EpLayout -> AnnClassDecl -> P (LTyClDecl GhcPs)
mkTyData :: SrcSpan -> Bool -> NewOrData -> Maybe (LocatedP CType) -> Located (Maybe (LHsContext GhcPs), LHsType GhcPs) -> Maybe (LHsKind GhcPs) -> [LConDecl GhcPs] -> Located (HsDeriving GhcPs) -> AnnDataDefn -> P (LTyClDecl GhcPs)
mkDataFamInst :: SrcSpan -> NewOrData -> Maybe (LocatedP CType) -> (Maybe (LHsContext GhcPs), HsOuterFamEqnTyVarBndrs GhcPs, LHsType GhcPs) -> Maybe (LHsKind GhcPs) -> [LConDecl GhcPs] -> Located (HsDeriving GhcPs) -> AnnDataDefn -> P (LInstDecl GhcPs)
mkTySynonym :: SrcSpan -> LHsType GhcPs -> LHsType GhcPs -> EpToken "type" -> EpToken "=" -> P (LTyClDecl GhcPs)
mkTyFamInstEqn :: SrcSpan -> HsOuterFamEqnTyVarBndrs GhcPs -> LHsType GhcPs -> LHsType GhcPs -> EpToken "=" -> P (LTyFamInstEqn GhcPs)
mkStandaloneKindSig :: SrcSpan -> Located [LocatedN RdrName] -> LHsSigType GhcPs -> (EpToken "type", TokDcolon) -> P (LStandaloneKindSig GhcPs)
mkTyFamInst :: SrcSpan -> TyFamInstEqn GhcPs -> EpToken "type" -> EpToken "instance" -> P (LInstDecl GhcPs)
mkFamDecl :: SrcSpan -> FamilyInfo GhcPs -> TopLevelFlag -> LHsType GhcPs -> LFamilyResultSig GhcPs -> Maybe (LInjectivityAnn GhcPs) -> AnnFamilyDecl -> P (LTyClDecl GhcPs)
mkInlinePragma :: SourceText -> (InlineSpec, RuleMatchInfo) -> Maybe Activation -> InlinePragma
mkOpaquePragma :: SourceText -> InlinePragma
mkPatSynMatchGroup :: LocatedN RdrName -> LocatedLW (OrdList (LHsDecl GhcPs)) -> P (MatchGroup GhcPs (LHsExpr GhcPs))
mkRecConstrOrUpdate :: Bool -> LHsExpr GhcPs -> SrcSpan -> ([Fbind (HsExpr GhcPs)], Maybe SrcSpan) -> (Maybe (EpToken "{"), Maybe (EpToken "}")) -> PV (HsExpr GhcPs)

-- | mkClassDecl builds a RdrClassDecl, filling in the names for tycon and
--   datacon by deriving them from the name of the class. We fill in the
--   names for the tycon and datacon corresponding to the class, by
--   deriving them from the name of the class itself. This saves recording
--   the names in the interface file (which would be equally good).
mkTyClD :: forall (p :: Pass). LTyClDecl (GhcPass p) -> LHsDecl (GhcPass p)
mkInstD :: forall (p :: Pass). LInstDecl (GhcPass p) -> LHsDecl (GhcPass p)
mkRdrRecordCon :: LocatedN RdrName -> HsRecordBinds GhcPs -> (Maybe (EpToken "{"), Maybe (EpToken "}")) -> HsExpr GhcPs
mkRdrRecordUpd :: Bool -> LHsExpr GhcPs -> [Fbind (HsExpr GhcPs)] -> (Maybe (EpToken "{"), Maybe (EpToken "}")) -> PV (HsExpr GhcPs)

-- | This rather gruesome function is used mainly by the parser.
--   
--   Case #1. When parsing:
--   
--   <pre>
--   data T a = T | T1 Int
--   </pre>
--   
--   we parse the data constructors as <i>types</i> because of parser
--   ambiguities, so then we need to change the <i>type constr</i> to a
--   <i>data constr</i>
--   
--   The exact-name case <i>can</i> occur when parsing:
--   
--   <pre>
--   data [] a = [] | a : [a]
--   </pre>
--   
--   For the exact-name case we return an original name.
--   
--   Case #2. When parsing:
--   
--   <pre>
--   x = fn (forall a. a)   -- RequiredTypeArguments
--   </pre>
--   
--   we use setRdrNameSpace to set the namespace of forall-bound variables.
setRdrNameSpace :: RdrName -> NameSpace -> RdrName

-- | Converts <a>LHsTyVarBndr</a> annotated with its <a>Specificity</a> to
--   one without annotations. Only accepts specified variables, and errors
--   if the provided binder has an <a>InferredSpec</a> annotation.
fromSpecTyVarBndr :: LHsTyVarBndr Specificity GhcPs -> P (LHsTyVarBndr () GhcPs)

-- | Converts a list of <a>LHsTyVarBndr</a>s annotated with their
--   <a>Specificity</a> to binders without annotations. Only accepts
--   specified variables, and errors if any of the provided binders has an
--   <a>InferredSpec</a> annotation.
fromSpecTyVarBndrs :: [LHsTyVarBndr Specificity GhcPs] -> P [LHsTyVarBndr () GhcPs]

-- | Add the annotation for a 'where' keyword to existing
--   <tt>HsLocalBinds</tt>
annBinds :: EpToken "where" -> EpAnnComments -> HsLocalBinds GhcPs -> (HsLocalBinds GhcPs, Maybe EpAnnComments)

-- | The anchor for a stmtlist is based on either the location or the first
--   semicolon annotion.
stmtsAnchor :: forall (tok :: Symbol) a. Located (OrdList (EpToken tok), a) -> Maybe EpaLocation
stmtsLoc :: forall (tok :: Symbol) a. Located (OrdList (EpToken tok), a) -> SrcSpan
cvBindGroup :: OrdList (LHsDecl GhcPs) -> P (HsValBinds GhcPs)
cvBindsAndSigs :: OrdList (LHsDecl GhcPs) -> P (LHsBinds GhcPs, [LSig GhcPs], [LFamilyDecl GhcPs], [LTyFamInstDecl GhcPs], [LDataFamInstDecl GhcPs], [LDocDecl GhcPs])

-- | Function definitions are restructured here. Each is assumed to be
--   recursive initially, and non recursive definitions are discovered by
--   the dependency analyser.
cvTopDecls :: OrdList (LHsDecl GhcPs) -> [LHsDecl GhcPs]
placeHolderPunRhs :: DisambECP b => PV (LocatedA b)
mkImport :: Located CCallConv -> Located Safety -> (Located StringLiteral, LocatedN RdrName, LHsSigType GhcPs) -> (EpToken "import", TokDcolon) -> P (EpToken "foreign" -> HsDecl GhcPs)
parseCImport :: forall (p :: Pass). LocatedE CCallConv -> LocatedE Safety -> FastString -> String -> Located SourceText -> Maybe (ForeignImport (GhcPass p))
mkExport :: Located CCallConv -> (Located StringLiteral, LocatedN RdrName, LHsSigType GhcPs) -> (EpToken "export", TokDcolon) -> P (EpToken "foreign" -> HsDecl GhcPs)
mkExtName :: RdrName -> CLabelString

-- | Construct a GADT-style data constructor from the constructor names and
--   their type. Some interesting aspects of this function:
--   
--   <ul>
--   <li>This splits up the constructor type into its quantified type
--   variables (if provided), context (if provided), argument types, and
--   result type, and records whether this is a prefix or record GADT
--   constructor. See Note [GADT abstract syntax] in <a>GHC.Hs.Decls</a>
--   for more details.</li>
--   </ul>
mkGadtDecl :: SrcSpan -> NonEmpty (LocatedN RdrName) -> TokDcolon -> LHsSigType GhcPs -> P (LConDecl GhcPs)
mkConDeclH98 :: (TokDarrow, (TokForall, EpToken ".")) -> LocatedN RdrName -> Maybe [LHsTyVarBndr Specificity GhcPs] -> Maybe (LHsContext GhcPs) -> HsConDeclH98Details GhcPs -> ConDecl GhcPs
checkImportDecl :: Maybe (EpToken "qualified") -> Maybe (EpToken "qualified") -> P ()

-- | Yield a parse error if we have a function applied directly to a do
--   block etc. and BlockArguments is not enabled.
checkExpBlockArguments :: LHsExpr GhcPs -> PV ()
checkCmdBlockArguments :: LHsCmd GhcPs -> PV ()

-- | Check if a fixity is valid. We support bypassing the usual bound
--   checks for some special operators.
checkPrecP :: Located (SourceText, Int) -> Located (OrdList (LocatedN RdrName)) -> P ()

-- | Validate the context constraints and break up a context into a list of
--   predicates.
--   
--   <pre>
--   (Eq a, Ord b)        --&gt;  [Eq a, Ord b]
--   Eq a                 --&gt;  [Eq a]
--   (Eq a)               --&gt;  [Eq a]
--   (((Eq a)))           --&gt;  [Eq a]
--   </pre>
checkContext :: LHsType GhcPs -> P (LHsContext GhcPs)
checkPattern :: LocatedA (PatBuilder GhcPs) -> P (LPat GhcPs)
checkPattern_details :: ParseContext -> PV (LocatedA (PatBuilder GhcPs)) -> P (LPat GhcPs)
incompleteDoBlock :: ParseContext

-- | Extra information for the expression GHC is currently
--   inspecting/parsing. It can be used to generate more informative parser
--   diagnostics and hints.
data ParseContext
ParseContext :: !Maybe RdrName -> !PatIncompleteDoBlock -> ParseContext

-- | If <a>Just</a>, this is an infix pattern with the bound operator name
[is_infix] :: ParseContext -> !Maybe RdrName

-- | Did the parser likely fail due to an incomplete do block?
[incomplete_do_block] :: ParseContext -> !PatIncompleteDoBlock

-- | Check for monad comprehensions
--   
--   If the flag MonadComprehensions is set, return a <a>MonadComp</a>
--   context, otherwise use the usual <a>ListComp</a> context
checkMonadComp :: PV HsDoFlavour
checkValDef :: SrcSpan -> LocatedA (PatBuilder GhcPs) -> (HsMultAnn GhcPs, Maybe (TokDcolon, LHsType GhcPs)) -> Located (GRHSs GhcPs (LHsExpr GhcPs)) -> P (HsBind GhcPs)
checkValSigLhs :: LHsExpr GhcPs -> P (LocatedN RdrName)
type LRuleTyTmVar = LocatedAn NoEpAnns RuleTyTmVar

-- | Essentially a wrapper for a <tt>RuleBndr GhcPs</tt>
data RuleTyTmVar
RuleTyTmVar :: AnnTyVarBndr -> LocatedN RdrName -> Maybe (LHsType GhcPs) -> RuleTyTmVar
mkRuleBndrs :: [LRuleTyTmVar] -> [LRuleBndr GhcPs]
mkRuleTyVarBndrs :: [LRuleTyTmVar] -> [LHsTyVarBndr () GhcPs]
checkRuleTyVarBndrNames :: [LHsTyVarBndr flag GhcPs] -> P ()
checkRecordSyntax :: (MonadP m, Outputable a) => LocatedA a -> m (LocatedA a)

-- | Check if the gadt_constrlist is empty. Only raise parse error for
--   `data T where` to avoid affecting existing error message, see #8258.
checkEmptyGADTs :: Located ((EpToken "where", EpToken "{", EpToken "}"), [LConDecl GhcPs]) -> P (Located ((EpToken "where", EpToken "{", EpToken "}"), [LConDecl GhcPs]))

-- | Add a fatal error. This will be the last error reported by the parser,
--   and the parser will not produce any result, ending in a <a>PFailed</a>
--   state.
addFatalError :: MonadP m => MsgEnvelope PsMessage -> m a

-- | Hint about bang patterns, assuming <tt>BangPatterns</tt> is off.
hintBangPat :: SrcSpan -> Pat GhcPs -> PV ()
mkBangTy :: EpaLocation -> SrcStrictness -> LHsType GhcPs -> HsType GhcPs

-- | Result of parsing <tt>{-# UNPACK #-}</tt> or <tt>{-# NOUNPACK
--   #-}</tt>.
data UnpackednessPragma
UnpackednessPragma :: (EpaLocation, EpToken "#-}") -> SourceText -> SrcUnpackedness -> UnpackednessPragma
mkMultTy :: EpToken "%" -> LHsType GhcPs -> TokRarrow -> HsArrow GhcPs
mkMultAnn :: EpToken "%" -> LHsType GhcPs -> HsMultAnn GhcPs
mkTokenLocation :: SrcSpan -> TokenLocation
data ImpExpSubSpec
ImpExpAbs :: ImpExpSubSpec
ImpExpAll :: EpToken ".." -> ImpExpSubSpec
ImpExpList :: [LocatedA ImpExpQcSpec] -> ImpExpSubSpec
ImpExpAllWith :: [LocatedA ImpExpQcSpec] -> ImpExpSubSpec
data ImpExpQcSpec
ImpExpQcName :: LocatedN RdrName -> ImpExpQcSpec
ImpExpQcType :: EpToken "type" -> LocatedN RdrName -> ImpExpQcSpec
ImpExpQcWildcard :: EpToken ".." -> EpToken "," -> ImpExpQcSpec
mkModuleImpExp :: Maybe (LWarningTxt GhcPs) -> (EpToken "(", EpToken ")") -> LocatedA ImpExpQcSpec -> ImpExpSubSpec -> P (IE GhcPs)
mkTypeImpExp :: LocatedN RdrName -> P (LocatedN RdrName)
mkImpExpSubSpec :: [LocatedA ImpExpQcSpec] -> P ImpExpSubSpec
checkImportSpec :: LocatedLI [LIE GhcPs] -> P (LocatedLI [LIE GhcPs])
starSym :: Bool -> FastString
warnStarIsType :: SrcSpan -> P ()
warnPrepositiveQualifiedModule :: SrcSpan -> P ()
failOpFewArgs :: MonadP m => LocatedN RdrName -> m a
failNotEnabledImportQualifiedPost :: SrcSpan -> P ()
failImportQualifiedTwice :: SrcSpan -> P ()
data SumOrTuple b

-- | Last two are the locations of the '|' before and after the payload
Sum :: ConTag -> Arity -> LocatedA b -> [EpToken "|"] -> [EpToken "|"] -> SumOrTuple b
Tuple :: [Either (EpAnn Bool) (LocatedA b)] -> SumOrTuple b
data PV a
runPV :: PV a -> P a
newtype ECP
ECP :: (forall b. DisambECP b => PV (LocatedA b)) -> ECP
[unECP] :: ECP -> forall b. DisambECP b => PV (LocatedA b)

-- | Disambiguate infix operators. See Note [Ambiguous syntactic
--   categories]
class DisambInfixOp b
mkHsVarOpPV :: DisambInfixOp b => LocatedN RdrName -> PV (LocatedN b)
mkHsConOpPV :: DisambInfixOp b => LocatedN RdrName -> PV (LocatedN b)
mkHsInfixHolePV :: DisambInfixOp b => LocatedN (HsExpr GhcPs) -> PV (LocatedN b)

-- | Disambiguate constructs that may appear when we do not know ahead of
--   time whether we are parsing an expression, a command, or a pattern.
--   See Note [Ambiguous syntactic categories]
class (b ~ Body b GhcPs, AnnoBody b) => DisambECP b where {
    
    -- | See Note [Body in DisambECP]
    type Body b :: Type -> Type;
    
    -- | Infix operator representation
    type InfixOp b;
    
    -- | Function argument representation
    type FunArg b;
}

-- | Return a command without ambiguity, or fail in a non-command context.
ecpFromCmd' :: DisambECP b => LHsCmd GhcPs -> PV (LocatedA b)

-- | Return an expression without ambiguity, or fail in a non-expression
--   context.
ecpFromExp' :: DisambECP b => LHsExpr GhcPs -> PV (LocatedA b)

-- | Return a pattern without ambiguity, or fail in a non-pattern context.
ecpFromPat' :: DisambECP b => LPat GhcPs -> PV (LocatedA b)
mkHsProjUpdatePV :: DisambECP b => SrcSpan -> Located [LocatedAn NoEpAnns (DotFieldOcc GhcPs)] -> LocatedA b -> Bool -> Maybe (EpToken "=") -> PV (LHsRecProj GhcPs (LocatedA b))

-- | Disambiguate "let ... in ..."
mkHsLetPV :: DisambECP b => SrcSpan -> EpToken "let" -> HsLocalBinds GhcPs -> EpToken "in" -> LocatedA b -> PV (LocatedA b)

-- | Bring superclass constraints on InfixOp into scope. See Note
--   [UndecidableSuperClasses for associated types]
superInfixOp :: DisambECP b => (DisambInfixOp (InfixOp b) => PV (LocatedA b)) -> PV (LocatedA b)

-- | Disambiguate "f # x" (infix operator)
mkHsOpAppPV :: DisambECP b => SrcSpan -> LocatedA b -> LocatedN (InfixOp b) -> LocatedA b -> PV (LocatedA b)

-- | Disambiguate "case ... of ..."
mkHsCasePV :: DisambECP b => SrcSpan -> LHsExpr GhcPs -> LocatedLW [LMatch GhcPs (LocatedA b)] -> EpAnnHsCase -> PV (LocatedA b)

-- | Disambiguate "... -&gt; ..." (lambda), "case" and "cases"
mkHsLamPV :: DisambECP b => SrcSpan -> HsLamVariant -> LocatedLW [LMatch GhcPs (LocatedA b)] -> EpAnnLam -> PV (LocatedA b)

-- | Bring superclass constraints on FunArg into scope. See Note
--   [UndecidableSuperClasses for associated types]
superFunArg :: DisambECP b => (DisambECP (FunArg b) => PV (LocatedA b)) -> PV (LocatedA b)

-- | Disambiguate "f x" (function application)
mkHsAppPV :: DisambECP b => SrcSpanAnnA -> LocatedA b -> LocatedA (FunArg b) -> PV (LocatedA b)

-- | Disambiguate "f @t" (visible type application)
mkHsAppTypePV :: DisambECP b => SrcSpanAnnA -> LocatedA b -> EpToken "@" -> LHsType GhcPs -> PV (LocatedA b)

-- | Disambiguate "if ... then ... else ..."
mkHsIfPV :: DisambECP b => SrcSpan -> LHsExpr GhcPs -> Bool -> LocatedA b -> Bool -> LocatedA b -> AnnsIf -> PV (LocatedA b)

-- | Disambiguate "do { ... }" (do notation)
mkHsDoPV :: DisambECP b => SrcSpan -> Maybe ModuleName -> LocatedLW [LStmt GhcPs (LocatedA b)] -> EpaLocation -> EpaLocation -> PV (LocatedA b)

-- | Disambiguate "( ... )" (parentheses)
mkHsParPV :: DisambECP b => SrcSpan -> EpToken "(" -> LocatedA b -> EpToken ")" -> PV (LocatedA b)

-- | Disambiguate a variable "f" or a data constructor <a>MkF</a>.
mkHsVarPV :: DisambECP b => LocatedN RdrName -> PV (LocatedA b)

-- | Disambiguate a monomorphic literal
mkHsLitPV :: DisambECP b => Located (HsLit GhcPs) -> PV (LocatedA b)

-- | Disambiguate an overloaded literal
mkHsOverLitPV :: DisambECP b => LocatedAn a (HsOverLit GhcPs) -> PV (LocatedAn a b)

-- | Disambiguate a wildcard
mkHsWildCardPV :: (DisambECP b, NoAnn a) => SrcSpan -> PV (LocatedAn a b)

-- | Disambiguate "a :: t" (type annotation)
mkHsTySigPV :: DisambECP b => SrcSpanAnnA -> LocatedA b -> LHsType GhcPs -> TokDcolon -> PV (LocatedA b)

-- | Disambiguate "[a,b,c]" (list syntax)
mkHsExplicitListPV :: DisambECP b => SrcSpan -> [LocatedA b] -> AnnList () -> PV (LocatedA b)

-- | Disambiguate "$(...)" and "[quasi|...|]" (TH splices)
mkHsSplicePV :: DisambECP b => Located (HsUntypedSplice GhcPs) -> PV (LocatedA b)

-- | Disambiguate "f { a = b, ... }" syntax (record construction and record
--   updates)
mkHsRecordPV :: DisambECP b => Bool -> SrcSpan -> SrcSpan -> LocatedA b -> ([Fbind b], Maybe SrcSpan) -> (Maybe (EpToken "{"), Maybe (EpToken "}")) -> PV (LocatedA b)

-- | Disambiguate "-a" (negation)
mkHsNegAppPV :: DisambECP b => SrcSpan -> LocatedA b -> EpToken "-" -> PV (LocatedA b)

-- | Disambiguate "(# a)" (right operator section)
mkHsSectionR_PV :: DisambECP b => SrcSpan -> LocatedA (InfixOp b) -> LocatedA b -> PV (LocatedA b)

-- | Disambiguate "(a -&gt; b)" (view pattern or function type arrow)
mkHsArrowPV :: DisambECP b => SrcSpan -> ArrowParsingMode lhs b -> LocatedA lhs -> HsArrowOf (LocatedA b) GhcPs -> LocatedA b -> PV (LocatedA b)

-- | Disambiguate "%m" to the left of "-&gt;" (multiplicity)
mkHsMultPV :: DisambECP b => EpToken "%" -> LocatedA b -> PV (TokRarrow -> HsArrowOf (LocatedA b) GhcPs)

-- | Disambiguate "forall a. b" and "forall a -&gt; b" (forall telescope)
mkHsForallPV :: DisambECP b => SrcSpan -> HsForAllTelescope GhcPs -> LocatedA b -> PV (LocatedA b)

-- | Disambiguate "(a,b,c)" to the left of "=&gt;" (constraint list)
checkContextPV :: DisambECP b => LocatedA b -> PV (LocatedC [LocatedA b])

-- | Disambiguate "a =&gt; b" (constraint context)
mkQualPV :: DisambECP b => SrcSpan -> LocatedC [LocatedA b] -> LocatedA b -> PV (LocatedA b)

-- | Disambiguate "a@b" (as-pattern)
mkHsAsPatPV :: DisambECP b => SrcSpan -> LocatedN RdrName -> EpToken "@" -> LocatedA b -> PV (LocatedA b)

-- | Disambiguate "~a" (lazy pattern)
mkHsLazyPatPV :: DisambECP b => SrcSpan -> LocatedA b -> EpToken "~" -> PV (LocatedA b)

-- | Disambiguate "!a" (bang pattern)
mkHsBangPatPV :: DisambECP b => SrcSpan -> LocatedA b -> EpToken "!" -> PV (LocatedA b)

-- | Disambiguate tuple sections and unboxed sums
mkSumOrTuplePV :: DisambECP b => SrcSpanAnnA -> Boxity -> SumOrTuple b -> (EpaLocation, EpaLocation) -> PV (LocatedA b)

-- | Disambiguate "type t" (embedded type)
mkHsEmbTyPV :: DisambECP b => SrcSpan -> EpToken "type" -> LHsType GhcPs -> PV (LocatedA b)

-- | Validate infixexp LHS to reject unwanted {-# SCC ... #-} pragmas
rejectPragmaPV :: DisambECP b => LocatedA b -> PV ()
ecpFromExp :: LHsExpr GhcPs -> ECP
ecpFromCmd :: LHsCmd GhcPs -> ECP
ecpFromPat :: LPat GhcPs -> ECP
data ArrowParsingMode lhs rhs
[ArrowIsViewPat] :: forall rhs. ArrowParsingMode (HsExpr GhcPs) rhs
[ArrowIsFunType] :: forall lhs. ArrowParsingMode lhs lhs
withArrowParsingMode :: DisambECP b => (forall lhs. DisambECP lhs => ArrowParsingMode lhs b -> PV r) -> PV r
withArrowParsingMode' :: DisambECP b => (forall lhs. DisambECP lhs => ArrowParsingMode lhs b -> PV (LocatedA b)) -> PV (LocatedA b)
setTelescopeBndrsNameSpace :: NameSpace -> HsForAllTelescope GhcPs -> HsForAllTelescope GhcPs

-- | See Note [Ambiguous syntactic categories] and Note [PatBuilder]
data PatBuilder p
hsHoleExpr :: Maybe EpAnnUnboundVar -> HsExpr GhcPs

-- | Disambiguate constructs that may appear when we do not know ahead of
--   time whether we are parsing a type or a newtype/data constructor.
--   
--   See Note [Ambiguous syntactic categories] for the general idea.
--   
--   See Note [Parsing data constructors is hard] for the specific issue
--   this particular class is solving.
class DisambTD b

-- | Process the head of a type-level function/constructor application,
--   i.e. the <tt>H</tt> in <tt>H a b c</tt>.
mkHsAppTyHeadPV :: DisambTD b => LHsType GhcPs -> PV (LocatedA b)

-- | Disambiguate <tt>f x</tt> (function application or prefix data
--   constructor).
mkHsAppTyPV :: DisambTD b => LocatedA b -> LHsType GhcPs -> PV (LocatedA b)

-- | Disambiguate <tt>f @t</tt> (visible kind application)
mkHsAppKindTyPV :: DisambTD b => LocatedA b -> EpToken "@" -> LHsType GhcPs -> PV (LocatedA b)

-- | Disambiguate <tt>f # x</tt> (infix operator)
mkHsOpTyPV :: DisambTD b => PromotionFlag -> LHsType GhcPs -> LocatedN RdrName -> LHsType GhcPs -> PV (LocatedA b)

-- | Disambiguate <tt>{-# UNPACK #-} t</tt> (unpack/nounpack pragma)
mkUnpackednessPV :: DisambTD b => Located UnpackednessPragma -> LocatedA b -> PV (LocatedA b)

-- | Annotate a type with either an <tt>{-# UNPACK #-}</tt> or a <tt>{-#
--   NOUNPACK #-}</tt> pragma.
addUnpackednessP :: MonadP m => Located UnpackednessPragma -> LHsType GhcPs -> m (LHsType GhcPs)
dataConBuilderCon :: LocatedA DataConBuilder -> LocatedN RdrName
dataConBuilderDetails :: LocatedA DataConBuilder -> HsConDeclH98Details GhcPs
mkUnboxedSumCon :: LHsType GhcPs -> ConTag -> Arity -> (LocatedN RdrName, HsConDeclH98Details GhcPs)

-- | Decide whether to parse tuple syntax <tt>(Int, Double)</tt> in a type
--   as a type or data constructor, based on the extension
--   <tt>ListTuplePuns</tt>. The case with an explicit promotion quote,
--   <tt>'(Int, Double)</tt>, is handled by <tt>mkExplicitTupleTy</tt>.
mkTupleSyntaxTy :: EpToken "(" -> [LocatedA (HsType GhcPs)] -> EpToken ")" -> P (HsType GhcPs)

-- | Decide whether to parse tuple con syntax <tt>(,)</tt> in a type as a
--   type or data constructor, based on the extension
--   <tt>ListTuplePuns</tt>. The case with an explicit promotion quote,
--   <tt>'(,)</tt>, is handled by the rule <tt>SIMPLEQUOTE
--   sysdcon_nolist</tt> in <tt>atype</tt>.
mkTupleSyntaxTycon :: Boxity -> Int -> P RdrName

-- | Decide whether to parse list tycon syntax <tt>[]</tt> in a type as a
--   type or data constructor, based on the extension
--   <tt>ListTuplePuns</tt>. The case with an explicit promotion quote,
--   <tt>'[]</tt>, is handled by <tt>mkExplicitListTy</tt>.
mkListSyntaxTy0 :: EpToken "[" -> EpToken "]" -> SrcSpan -> P (HsType GhcPs)

-- | Decide whether to parse list type syntax <tt>[Int]</tt> in a type as a
--   type or data constructor, based on the extension
--   <tt>ListTuplePuns</tt>. The case with an explicit promotion quote,
--   <tt>'[Int]</tt>, is handled by <tt>mkExplicitListTy</tt>.
mkListSyntaxTy1 :: EpToken "[" -> LocatedA (HsType GhcPs) -> EpToken "]" -> P (HsType GhcPs)

-- | Call a parser with a span and its comments given by a start and end
--   token.
withCombinedComments :: (HasLoc l1, HasLoc l2) => l1 -> l2 -> (SrcSpan -> P a) -> P (LocatedA a)

-- | Emit an error of type <a>PsErrInvalidPun</a> with a location from
--   <tt>start</tt> to <tt>end</tt> if the extension <tt>ListTuplePuns</tt>
--   is disabled.
--   
--   This is used in Parser.y to guard rules that require punning.
requireLTPuns :: PsErrPunDetails -> Located a -> Located b -> P ()
instance GHC.Internal.Base.Applicative GHC.Parser.PostProcess.PV
instance GHC.Parser.PostProcess.DisambECP (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcPs)
instance GHC.Parser.PostProcess.DisambECP (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)
instance GHC.Parser.PostProcess.DisambECP (GHC.Parser.Types.PatBuilder GHC.Hs.Extension.GhcPs)
instance GHC.Parser.PostProcess.DisambInfixOp (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)
instance GHC.Parser.PostProcess.DisambInfixOp GHC.Types.Name.Reader.RdrName
instance GHC.Parser.PostProcess.DisambTD GHC.Parser.Types.DataConBuilder
instance GHC.Parser.PostProcess.DisambTD (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Foldable.Foldable GHC.Parser.PostProcess.PV_Result
instance GHC.Internal.Base.Functor GHC.Parser.PostProcess.PV
instance GHC.Internal.Base.Functor GHC.Parser.PostProcess.PV_Result
instance GHC.Parser.Lexer.MonadP GHC.Parser.PostProcess.PV
instance GHC.Internal.Base.Monad GHC.Parser.PostProcess.PV
instance GHC.Utils.Outputable.Outputable (GHC.Parser.PostProcess.ArgPatBuilder GHC.Hs.Extension.GhcPs)
instance GHC.Internal.Data.Traversable.Traversable GHC.Parser.PostProcess.PV_Result

module GHC.ThToHs
convertToHsExpr :: Origin -> SrcSpan -> Exp -> Either RunSpliceFailReason (LHsExpr GhcPs)
convertToPat :: Origin -> SrcSpan -> Pat -> Either RunSpliceFailReason (LPat GhcPs)
convertToHsDecls :: Origin -> SrcSpan -> [Dec] -> Either RunSpliceFailReason [LHsDecl GhcPs]
convertToHsType :: Origin -> SrcSpan -> Type -> Either RunSpliceFailReason (LHsType GhcPs)
thRdrNameGuesses :: Name -> [RdrName]
instance GHC.Internal.Base.Applicative (GHC.ThToHs.CvtM' err)
instance GHC.ThToHs.CvtFlag GHC.Internal.TH.Syntax.BndrVis (Language.Haskell.Syntax.Type.HsBndrVis GHC.Hs.Extension.GhcPs)
instance GHC.ThToHs.CvtFlag GHC.Internal.TH.Syntax.Specificity Language.Haskell.Syntax.Specificity.Specificity
instance GHC.ThToHs.CvtFlag () ()
instance GHC.Internal.Base.Functor (GHC.ThToHs.CvtM' err)
instance GHC.Internal.Base.Monad (GHC.ThToHs.CvtM' err)

module GHC.Parser.HaddockLex

-- | Lex identifiers from a docstring.
lexHsDoc :: P (LocatedN RdrName) -> HsDocString -> HsDoc GhcPs

-- | Lex <a>StringLiteral</a> for warning messages
lexStringLiteral :: P (LocatedN RdrName) -> Located StringLiteral -> Located (WithHsDocIdentifiers StringLiteral GhcPs)


-- | This module implements <a>addHaddockToModule</a>, which inserts
--   Haddock comments accumulated during parsing into the AST (#17544).
--   
--   We process Haddock comments in two phases:
--   
--   <ol>
--   <li>Parse the program (via the Happy parser in <a>y</a>), generating
--   an AST, and (quite separately) a list of all the Haddock comments
--   found in the file. More precisely, the Haddock comments are
--   accumulated in the <a>hdk_comments</a> field of the <a>PState</a>, the
--   parser state (see Lexer.x):data PState = PState { ... , hdk_comments
--   :: [PsLocated HdkComment] }</li>
--   </ol>
--   
--   Each of these Haddock comments has a <a>PsSpan</a>, which gives the
--   <a>BufPos</a> of the beginning and end of the Haddock comment.
--   
--   <ol>
--   <li>Walk over the AST, attaching the Haddock comments to the correct
--   parts of the tree. This step is called <a>addHaddockToModule</a>, and
--   is implemented in this module.</li>
--   </ol>
--   
--   See Note [Adding Haddock comments to the syntax tree].
--   
--   This approach codifies an important principle:
--   
--   The presence or absence of a Haddock comment should never change the
--   parsing of a program.
--   
--   Alternative approaches that did not work properly:
--   
--   <ol>
--   <li>Using <a>RealSrcLoc</a> instead of <a>BufPos</a>. This led to
--   failures in presence of {-# LANGUAGE CPP #-} and other sources of line
--   pragmas. See documentation on <a>BufPos</a> (in GHC.Types.SrcLoc) for
--   the details.</li>
--   <li>In earlier versions of GHC, the Haddock comments were incorporated
--   into the Parser.y grammar. The parser constructed the AST and attached
--   comments to it in a single pass. See Note [Old solution: Haddock in
--   the grammar] for the details.</li>
--   </ol>
module GHC.Parser.PostProcess.Haddock

-- | Add Haddock documentation accumulated in the parser state to a parsed
--   HsModule.
--   
--   Reports badly positioned comments when -Winvalid-haddock is enabled.
addHaddockToModule :: Located (HsModule GhcPs) -> P (Located (HsModule GhcPs))
instance GHC.Internal.Base.Applicative GHC.Parser.PostProcess.Haddock.HdkA
instance GHC.Internal.Base.Applicative GHC.Parser.PostProcess.Haddock.HdkM
instance GHC.Internal.Base.Functor GHC.Parser.PostProcess.Haddock.HdkA
instance GHC.Internal.Base.Functor GHC.Parser.PostProcess.Haddock.HdkM
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.HsModule GHC.Hs.Extension.GhcPs))
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedLI [GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.ImpExp.IE GHC.Hs.Extension.GhcPs)])
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.ImpExp.IE GHC.Hs.Extension.GhcPs))
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.HsDecl GHC.Hs.Extension.GhcPs))
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Types.SrcLoc.Located [GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Decls.HsDerivingClause GHC.Hs.Extension.GhcPs)])
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Decls.HsDerivingClause GHC.Hs.Extension.GhcPs))
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedC (Language.Haskell.Syntax.Decls.DerivClauseTys GHC.Hs.Extension.GhcPs))
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.ConDecl GHC.Hs.Extension.GhcPs))
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsSigType GHC.Hs.Extension.GhcPs))
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcPs))
instance GHC.Parser.PostProcess.Haddock.HasHaddock (Language.Haskell.Syntax.Decls.HsDataDefn GHC.Hs.Extension.GhcPs)
instance GHC.Parser.PostProcess.Haddock.HasHaddock (Language.Haskell.Syntax.Decls.HsDecl GHC.Hs.Extension.GhcPs)
instance GHC.Parser.PostProcess.Haddock.HasHaddock a => GHC.Parser.PostProcess.Haddock.HasHaddock (Language.Haskell.Syntax.Type.HsScaled GHC.Hs.Extension.GhcPs a)
instance GHC.Parser.PostProcess.Haddock.HasHaddock a => GHC.Parser.PostProcess.Haddock.HasHaddock (Language.Haskell.Syntax.Type.HsWildCardBndrs GHC.Hs.Extension.GhcPs a)
instance GHC.Parser.PostProcess.Haddock.HasHaddock a => GHC.Parser.PostProcess.Haddock.HasHaddock [a]
instance GHC.Internal.Base.Monad GHC.Parser.PostProcess.Haddock.HdkM
instance GHC.Internal.Base.Monoid GHC.Parser.PostProcess.Haddock.ColumnBound
instance GHC.Internal.Base.Monoid GHC.Parser.PostProcess.Haddock.LocRange
instance GHC.Internal.Base.Monoid GHC.Parser.PostProcess.Haddock.LowerLocBound
instance GHC.Internal.Base.Monoid GHC.Parser.PostProcess.Haddock.UpperLocBound
instance GHC.Internal.Base.Semigroup GHC.Parser.PostProcess.Haddock.ColumnBound
instance GHC.Internal.Base.Semigroup GHC.Parser.PostProcess.Haddock.LocRange
instance GHC.Internal.Base.Semigroup GHC.Parser.PostProcess.Haddock.LowerLocBound
instance GHC.Internal.Base.Semigroup GHC.Parser.PostProcess.Haddock.UpperLocBound
instance GHC.Internal.Show.Show GHC.Parser.PostProcess.Haddock.ColumnBound
instance GHC.Internal.Show.Show GHC.Parser.PostProcess.Haddock.LowerLocBound
instance GHC.Internal.Show.Show GHC.Parser.PostProcess.Haddock.UpperLocBound

module GHC.Cmm.Parser.Config
data PDConfig
PDConfig :: !Profile -> !Bool -> PDConfig
[pdProfile] :: PDConfig -> !Profile

-- | Insert alignment checks (cf <tt>-falignment-sanitisation</tt>)
[pdSanitizeAlignment] :: PDConfig -> !Bool
data CmmParserConfig
CmmParserConfig :: !ParserOpts -> !PDConfig -> !StgToCmmConfig -> CmmParserConfig
[cmmpParserOpts] :: CmmParserConfig -> !ParserOpts
[cmmpPDConfig] :: CmmParserConfig -> !PDConfig
[cmmpStgToCmmConfig] :: CmmParserConfig -> !StgToCmmConfig

module GHC.Cmm.Parser.Monad
newtype PD a
PD :: (PDConfig -> HomeUnit -> PState -> ParseResult a) -> PD a
[unPD] :: PD a -> PDConfig -> HomeUnit -> PState -> ParseResult a
liftP :: P a -> PD a
failMsgPD :: (SrcSpan -> MsgEnvelope PsMessage) -> PD a
getPDConfig :: PD PDConfig
getProfile :: PD Profile
getPlatform :: PD Platform

-- | Return the UnitId of the home-unit. This is used to create labels.
getHomeUnitId :: PD UnitId
data PDConfig
PDConfig :: !Profile -> !Bool -> PDConfig
[pdProfile] :: PDConfig -> !Profile

-- | Insert alignment checks (cf <tt>-falignment-sanitisation</tt>)
[pdSanitizeAlignment] :: PDConfig -> !Bool
instance GHC.Internal.Base.Applicative GHC.Cmm.Parser.Monad.PD
instance GHC.Internal.Base.Functor GHC.Cmm.Parser.Monad.PD
instance GHC.Internal.Base.Monad GHC.Cmm.Parser.Monad.PD


-- | This module provides the generated Happy parser for Haskell. It
--   exports a number of parsers which may be used in any library that uses
--   the GHC API. A common usage pattern is to initialize the parser state
--   with a given string and then parse that string:
--   
--   <pre>
--   runParser :: ParserOpts -&gt; String -&gt; P a -&gt; ParseResult a
--   runParser opts str parser = unP parser parseState
--   where
--     filename = "&lt;interactive&gt;"
--     location = mkRealSrcLoc (mkFastString filename) 1 1
--     buffer = stringToStringBuffer str
--     parseState = initParserState opts buffer location
--   </pre>
module GHC.Parser

-- | Parse a Haskell module with Haddock comments. This is done in two
--   steps:
--   
--   <ul>
--   <li><a>parseModuleNoHaddock</a> to build the AST</li>
--   <li><a>addHaddockToModule</a> to insert Haddock comments into it</li>
--   </ul>
--   
--   This and the signature module parser are the only parser entry points
--   that deal with Haddock comments. The other entry points
--   (<a>parseDeclaration</a>, <a>parseExpression</a>, etc) do not insert
--   them into the AST.
parseModule :: P (Located (HsModule GhcPs))

-- | Parse a Haskell signature module with Haddock comments. This is done
--   in two steps:
--   
--   <ul>
--   <li><a>parseSignatureNoHaddock</a> to build the AST</li>
--   <li><a>addHaddockToModule</a> to insert Haddock comments into it</li>
--   </ul>
--   
--   This and the module parser are the only parser entry points that deal
--   with Haddock comments. The other entry points
--   (<a>parseDeclaration</a>, <a>parseExpression</a>, etc) do not insert
--   them into the AST.
parseSignature :: P (Located (HsModule GhcPs))
parseImport :: P (GenLocated SrcSpanAnnA (ImportDecl GhcPs))
parseStatement :: P (GenLocated SrcSpanAnnA (StmtLR GhcPs GhcPs (GenLocated SrcSpanAnnA (HsExpr GhcPs))))
parseBackpack :: P [LHsUnit PackageName]
parseDeclaration :: P (GenLocated SrcSpanAnnA (HsDecl GhcPs))
parseExpression :: P ECP
parsePattern :: P (GenLocated SrcSpanAnnA (Pat GhcPs))
parseTypeSignature :: P (GenLocated SrcSpanAnnA (HsDecl GhcPs))
parseStmt :: P (Maybe (GenLocated SrcSpanAnnA (StmtLR GhcPs GhcPs (GenLocated SrcSpanAnnA (HsExpr GhcPs)))))
parseIdentifier :: P (LocatedN RdrName)
parseType :: P (GenLocated SrcSpanAnnA (HsType GhcPs))
parseHeader :: P (Located (HsModule GhcPs))
parseModuleNoHaddock :: P (Located (HsModule GhcPs))

module GHC.Parser.Utils

-- | Returns <tt>True</tt> if passed string is a statement.
isStmt :: ParserOpts -> String -> Bool

-- | Returns <tt>True</tt> if passed string has an import declaration.
hasImport :: ParserOpts -> String -> Bool

-- | Returns <tt>True</tt> if passed string is an import declaration.
isImport :: ParserOpts -> String -> Bool

-- | Returns <tt>True</tt> if passed string is a declaration but <b><i>not
--   a splice</i></b>.
isDecl :: ParserOpts -> String -> Bool

module GHC.Iface.Errors.Ppr
data IfaceMessageOpts
IfaceMessageOpts :: !Bool -> !BuildingCabalPackage -> IfaceMessageOpts

-- | Whether to show files we tried to look for or not when printing loader
--   errors
[ifaceShowTriedFiles] :: IfaceMessageOpts -> !Bool
[ifaceBuildingCabalPackage] :: IfaceMessageOpts -> !BuildingCabalPackage
interfaceErrorHints :: IfaceMessage -> [GhcHint]
interfaceErrorReason :: IfaceMessage -> DiagnosticReason
interfaceErrorDiagnostic :: IfaceMessageOpts -> IfaceMessage -> SDoc
missingInterfaceErrorHints :: MissingInterfaceError -> [GhcHint]
missingInterfaceErrorReason :: MissingInterfaceError -> DiagnosticReason
missingInterfaceErrorDiagnostic :: IfaceMessageOpts -> MissingInterfaceError -> SDoc
readInterfaceErrorDiagnostic :: ReadInterfaceError -> SDoc
lookingForHerald :: InterfaceLookingFor -> SDoc

-- | General version of cantFindError which has some holes which allow
--   GHC/GHCi to display slightly different error messages.
cantFindErrorX :: (UnitInfo -> SDoc) -> ([FilePath] -> SDoc) -> FindingModuleOrInterface -> CantFindInstalled -> SDoc
mayShowLocations :: String -> Bool -> [FilePath] -> SDoc
pkgHiddenHint :: (UnitInfo -> SDoc) -> BuildingCabalPackage -> UnitInfo -> SDoc
instance GHC.Types.Error.Diagnostic GHC.Iface.Errors.Types.IfaceMessage
instance GHC.Types.Error.HasDefaultDiagnosticOpts GHC.Iface.Errors.Types.IfaceMessageOpts

module GHC.HsToCore.Errors.Ppr
badMonadBind :: Type -> SDoc
pprEqn :: HsMatchContextRn -> SDoc -> String -> SDoc
pprContext :: Bool -> HsMatchContextRn -> SDoc -> ((SDoc -> SDoc) -> SDoc) -> SDoc
dots :: Int -> [a] -> SDoc
instance GHC.Types.Error.Diagnostic GHC.HsToCore.Errors.Types.DsMessage

module GHC.Types.IPE

-- | A map storing all the different uses of a specific data constructor
--   and the approximate source position that usage arose from. The
--   <a>Int</a> is an incrementing identifier which distinguishes each
--   usage of a constructor in a module. It is paired with the source
--   position the constructor was used at, if possible and a string which
--   names the source location. This is the same information as is the
--   payload for the <a>SourceNote</a> constructor.
type DCMap = UniqDFM DataCon (DataCon, NonEmpty (Int, Maybe IpeSourceLocation))

-- | A map from a <a>Name</a> to the best approximate source position that
--   name arose from.
type ClosureMap = UniqDFM Name (Name, (Type, Maybe IpeSourceLocation))
data InfoTableProvMap
InfoTableProvMap :: DCMap -> ClosureMap -> InfoTableToSourceLocationMap -> InfoTableProvMap
[provDC] :: InfoTableProvMap -> DCMap
[provClosure] :: InfoTableProvMap -> ClosureMap
[provInfoTables] :: InfoTableProvMap -> InfoTableToSourceLocationMap
emptyInfoTableProvMap :: InfoTableProvMap

-- | Position and information about an info table. For return frames these
--   are the contents of a <a>SourceNote</a>.
type IpeSourceLocation = (RealSrcSpan, LexicalFastString)

module GHC.Stg.Debug
data StgDebugOpts
StgDebugOpts :: !Bool -> !Bool -> StgDebugOpts
[stgDebug_infoTableMap] :: StgDebugOpts -> !Bool
[stgDebug_distinctConstructorTables] :: StgDebugOpts -> !Bool
collectDebugInformation :: StgDebugOpts -> ModLocation -> [StgTopBinding] -> ([StgTopBinding], InfoTableProvMap)

module GHC.Driver.Config.Stg.Debug

-- | Initialize STG pretty-printing options from DynFlags
initStgDebugOpts :: DynFlags -> StgDebugOpts

module GHC.CoreToStg
data CoreToStgOpts
CoreToStgOpts :: Platform -> Ways -> Bool -> Bool -> Bool -> StgDebugOpts -> CoreToStgOpts
[coreToStg_platform] :: CoreToStgOpts -> Platform
[coreToStg_ways] :: CoreToStgOpts -> Ways
[coreToStg_AutoSccsOnIndividualCafs] :: CoreToStgOpts -> Bool
[coreToStg_InfoTableMap] :: CoreToStgOpts -> Bool
[coreToStg_ExternalDynamicRefs] :: CoreToStgOpts -> Bool
[coreToStg_stgDebugOpts] :: CoreToStgOpts -> StgDebugOpts
coreToStg :: CoreToStgOpts -> Module -> ModLocation -> CoreProgram -> ([StgTopBinding], InfoTableProvMap, CollectedCCs)
instance GHC.Internal.Base.Applicative GHC.CoreToStg.CtsM
instance GHC.Classes.Eq GHC.CoreToStg.HowBound
instance GHC.Classes.Eq GHC.CoreToStg.LetInfo
instance GHC.Internal.Base.Functor GHC.CoreToStg.CtsM
instance GHC.Internal.Base.Monad GHC.CoreToStg.CtsM

module GHC.Driver.Config.CoreToStg
initCoreToStgOpts :: DynFlags -> CoreToStgOpts

module GHC.HsToCore.Coverage
writeMixEntries :: FilePath -> Module -> SizedSeq Tick -> FilePath -> IO Int

-- | Create HPC initialization C code for a module
--   
--   Each module compiled with -fhpc declares an initialisation function of
--   the form `hpc_init_<a>module</a>()`, which is emitted into the _stub.c
--   file and annotated with <b>attribute</b>((constructor)) so that it
--   gets executed at startup time.
--   
--   The function's purpose is to call hs_hpc_module to register this
--   module with the RTS, and it looks something like this:
--   
--   <pre>
--   static void hpc_init_Main(void) __attribute__((constructor));
--   static void hpc_init_Main(void)
--   {
--     extern StgWord64 _hpc_tickboxes_Main_hpc[];
--     hs_hpc_module("Main",8,1150288664,_hpc_tickboxes_Main_hpc);
--   }
--   </pre>
hpcInitCode :: Platform -> Module -> HpcInfo -> CStub

module GHC.Cmm.BlockId
type BlockId = Label
mkBlockId :: Unique -> BlockId
newBlockId :: MonadGetUnique m => m BlockId
blockLbl :: BlockId -> CLabel
infoTblLbl :: BlockId -> CLabel

module GHC.Cmm.Expr
data CmmExpr
CmmLit :: !CmmLit -> CmmExpr
CmmLoad :: !CmmExpr -> !CmmType -> !AlignmentSpec -> CmmExpr
CmmReg :: !CmmReg -> CmmExpr
CmmMachOp :: MachOp -> [CmmExpr] -> CmmExpr
CmmStackSlot :: Area -> {-# UNPACK #-} !Int -> CmmExpr
CmmRegOff :: !CmmReg -> !Int -> CmmExpr
cmmExprType :: Platform -> CmmExpr -> CmmType
cmmExprWidth :: Platform -> CmmExpr -> Width

-- | Returns an alignment in bytes of a CmmExpr when it's a statically
--   known integer constant, otherwise returns an alignment of 1 byte. The
--   caller is responsible for using with a sensible CmmExpr argument.
cmmExprAlignment :: CmmExpr -> Alignment
maybeInvertCmmExpr :: CmmExpr -> Maybe CmmExpr
data CmmReg
CmmLocal :: {-# UNPACK #-} !LocalReg -> CmmReg
CmmGlobal :: GlobalRegUse -> CmmReg
cmmRegType :: CmmReg -> CmmType
cmmRegWidth :: CmmReg -> Width
data CmmLit
CmmInt :: !Integer -> !Width -> CmmLit
CmmFloat :: Rational -> !Width -> CmmLit
CmmVec :: [CmmLit] -> CmmLit
CmmLabel :: CLabel -> CmmLit
CmmLabelOff :: CLabel -> !Int -> CmmLit
CmmLabelDiffOff :: CLabel -> CLabel -> !Int -> !Width -> CmmLit
CmmBlock :: {-# UNPACK #-} !BlockId -> CmmLit
CmmHighStackMark :: CmmLit
cmmLitType :: Platform -> CmmLit -> CmmType
data AlignmentSpec
NaturallyAligned :: AlignmentSpec
Unaligned :: AlignmentSpec
data LocalReg

-- | Parameters: 1. Identifier 2. Type
LocalReg :: {-# UNPACK #-} !Unique -> !CmmType -> LocalReg
localRegType :: LocalReg -> CmmType

-- | An abstract global register for the STG machine.
--   
--   See also <a>GlobalRegUse</a>, which denotes a usage of a register at a
--   particular type (e.g. using a 32-bit wide register to store an 8-bit
--   wide value), as per Note [GlobalReg vs GlobalRegUse].
data GlobalReg
VanillaReg :: {-# UNPACK #-} !Int -> GlobalReg
FloatReg :: {-# UNPACK #-} !Int -> GlobalReg
DoubleReg :: {-# UNPACK #-} !Int -> GlobalReg
LongReg :: {-# UNPACK #-} !Int -> GlobalReg
XmmReg :: {-# UNPACK #-} !Int -> GlobalReg
YmmReg :: {-# UNPACK #-} !Int -> GlobalReg
ZmmReg :: {-# UNPACK #-} !Int -> GlobalReg

-- | Stack ptr; points to last occupied stack location.
Sp :: GlobalReg

-- | Stack limit
SpLim :: GlobalReg

-- | Heap ptr; points to last occupied heap location.
Hp :: GlobalReg

-- | Heap limit register
HpLim :: GlobalReg

-- | Current cost-centre stack
CCCS :: GlobalReg

-- | pointer to current thread's TSO
CurrentTSO :: GlobalReg

-- | pointer to allocation area
CurrentNursery :: GlobalReg

-- | allocation count for heap check failure
HpAlloc :: GlobalReg

-- | address of stg_EAGER_BLACKHOLE_info
EagerBlackholeInfo :: GlobalReg

-- | address of stg_gc_enter_1
GCEnter1 :: GlobalReg

-- | address of stg_gc_fun
GCFun :: GlobalReg

-- | Base offset for the register table, used for accessing registers which
--   do not have real registers assigned to them. This register will only
--   appear after we have expanded GlobalReg into memory accesses (where
--   necessary) in the native code generator.
BaseReg :: GlobalReg

-- | The register used by the platform for the C stack pointer. This is a
--   break in the STG abstraction used exclusively to setup stack unwinding
--   information.
MachSp :: GlobalReg

-- | A dummy register used to indicate to the stack unwinder where a
--   routine would return to.
UnwindReturnReg :: GlobalReg

-- | Base Register for PIC (position-independent code) calculations.
--   
--   Only used inside the native code generator. Its exact meaning differs
--   from platform to platform (see module PositionIndependentCode).
PicBaseReg :: GlobalReg
isArgReg :: GlobalReg -> Bool
globalRegSpillType :: Platform -> GlobalReg -> CmmType

-- | A use of a global register at a particular type.
--   
--   While a <a>GlobalReg</a> identifies a global register in the STG
--   machine, a <a>GlobalRegUse</a> also contains information about the
--   type we are storing in the register.
--   
--   See Note [GlobalReg vs GlobalRegUse] for more information.
data GlobalRegUse
GlobalRegUse :: !GlobalReg -> !CmmType -> GlobalRegUse

-- | The underlying <a>GlobalReg</a>
[globalRegUse_reg] :: GlobalRegUse -> !GlobalReg

-- | The <a>CmmType</a> at which we are using the <a>GlobalReg</a>.
--   
--   Its width must be less than the width of the <a>GlobalReg</a>:
--   
--   <pre>
--   typeWidth ty &lt;= typeWidth (globalRegSpillType platform reg)
--   </pre>
[globalRegUse_type] :: GlobalRegUse -> !CmmType
spReg :: Platform -> CmmReg
hpReg :: Platform -> CmmReg
spLimReg :: Platform -> CmmReg
hpLimReg :: Platform -> CmmReg
nodeReg :: Platform -> CmmReg
currentTSOReg :: Platform -> CmmReg
currentNurseryReg :: Platform -> CmmReg
hpAllocReg :: Platform -> CmmReg
cccsReg :: Platform -> CmmReg
node :: GlobalReg
baseReg :: Platform -> CmmReg
class Ord r => DefinerOfRegs r a
class Ord r => UserOfRegs r a
foldRegsDefd :: DefinerOfRegs r a => Platform -> (b -> r -> b) -> b -> a -> b
foldRegsUsed :: UserOfRegs r a => Platform -> (b -> r -> b) -> b -> a -> b
foldLocalRegsDefd :: DefinerOfRegs LocalReg a => Platform -> (b -> LocalReg -> b) -> b -> a -> b
foldLocalRegsUsed :: UserOfRegs LocalReg a => Platform -> (b -> LocalReg -> b) -> b -> a -> b

-- | Sets of registers
type RegSet r = Set r
type LocalRegSet = RegSet LocalReg
type GlobalRegSet = RegSet GlobalReg
emptyRegSet :: RegSet r
elemRegSet :: Ord r => r -> RegSet r -> Bool
extendRegSet :: Ord r => RegSet r -> r -> RegSet r
deleteFromRegSet :: Ord r => RegSet r -> r -> RegSet r
mkRegSet :: Ord r => [r] -> RegSet r
plusRegSet :: Ord r => RegSet r -> RegSet r -> RegSet r
minusRegSet :: Ord r => RegSet r -> RegSet r -> RegSet r
timesRegSet :: Ord r => RegSet r -> RegSet r -> RegSet r
sizeRegSet :: RegSet r -> Int
nullRegSet :: RegSet r -> Bool
regSetToList :: RegSet r -> [r]
isTrivialCmmExpr :: CmmExpr -> Bool
hasNoGlobalRegs :: CmmExpr -> Bool
isLit :: CmmExpr -> Bool
isComparisonExpr :: CmmExpr -> Bool

-- | A stack area is either the stack slot where a variable is spilled or
--   the stack space where function arguments and results are passed.
data Area
Old :: Area
Young :: {-# UNPACK #-} !BlockId -> Area
instance GHC.Cmm.Expr.DefinerOfRegs GHC.Cmm.Reg.GlobalReg GHC.Cmm.Reg.CmmReg
instance GHC.Cmm.Expr.DefinerOfRegs GHC.Cmm.Reg.GlobalRegUse GHC.Cmm.Reg.CmmReg
instance GHC.Cmm.Expr.DefinerOfRegs GHC.Cmm.Reg.LocalReg GHC.Cmm.Reg.CmmReg
instance GHC.Cmm.Expr.DefinerOfRegs r a => GHC.Cmm.Expr.DefinerOfRegs r [a]
instance GHC.Classes.Ord r => GHC.Cmm.Expr.DefinerOfRegs r r
instance GHC.Classes.Eq GHC.Cmm.Expr.AlignmentSpec
instance GHC.Classes.Eq GHC.Cmm.Expr.Area
instance GHC.Classes.Eq GHC.Cmm.Expr.CmmExpr
instance GHC.Classes.Eq GHC.Cmm.Expr.CmmLit
instance GHC.Classes.Ord GHC.Cmm.Expr.AlignmentSpec
instance GHC.Classes.Ord GHC.Cmm.Expr.Area
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Expr.Area
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Expr.CmmLit
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.Expr.CmmExpr
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.Expr.CmmLit
instance GHC.Internal.Show.Show GHC.Cmm.Expr.AlignmentSpec
instance GHC.Internal.Show.Show GHC.Cmm.Expr.Area
instance GHC.Internal.Show.Show GHC.Cmm.Expr.CmmExpr
instance GHC.Internal.Show.Show GHC.Cmm.Expr.CmmLit
instance GHC.Cmm.Expr.UserOfRegs GHC.Cmm.Reg.GlobalReg GHC.Cmm.Reg.CmmReg
instance GHC.Cmm.Expr.UserOfRegs GHC.Cmm.Reg.GlobalRegUse GHC.Cmm.Reg.CmmReg
instance GHC.Cmm.Expr.UserOfRegs GHC.Cmm.Reg.LocalReg GHC.Cmm.Reg.CmmReg
instance (GHC.Classes.Ord r, GHC.Cmm.Expr.UserOfRegs r GHC.Cmm.Reg.CmmReg) => GHC.Cmm.Expr.UserOfRegs r GHC.Cmm.Expr.CmmExpr
instance GHC.Cmm.Expr.UserOfRegs r a => GHC.Cmm.Expr.UserOfRegs r [a]
instance GHC.Classes.Ord r => GHC.Cmm.Expr.UserOfRegs r r

module GHC.Platform.X86_64
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool
freeRegBase :: RegNo -> Bool

module GHC.Platform.X86
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool
freeRegBase :: RegNo -> Bool

module GHC.Platform.Wasm32
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.S390X
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.RISCV64
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.PPC
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.NoRegs
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.LoongArch64
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.ARM
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.AArch64
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.Regs

-- | Returns <a>True</a> if this global register is stored in a
--   caller-saves machine register.
callerSaves :: Platform -> GlobalReg -> Bool

-- | Here is where the STG register map is defined for each target arch.
--   The order matters (for the llvm backend anyway)! We must make sure to
--   maintain the order here with the order used in the LLVM calling
--   conventions. Note that also, this isn't all registers, just the ones
--   that are currently possibly mapped to real registers.
activeStgRegs :: Platform -> [GlobalReg]
haveRegBase :: Platform -> Bool
globalRegMaybe :: Platform -> GlobalReg -> Maybe RealReg
freeReg :: Platform -> RegNo -> Bool

module GHC.Cmm.Node
data CmmNode (e :: Extensibility) (x :: Extensibility)
[CmmEntry] :: {-# UNPACK #-} !Label -> CmmTickScope -> CmmNode 'Closed 'Open
[CmmComment] :: FastString -> CmmNode 'Open 'Open
[CmmTick] :: !CmmTickish -> CmmNode 'Open 'Open
[CmmUnwind] :: [(GlobalReg, Maybe CmmExpr)] -> CmmNode 'Open 'Open
[CmmAssign] :: !CmmReg -> !CmmExpr -> CmmNode 'Open 'Open
[CmmStore] :: !CmmExpr -> !CmmExpr -> !AlignmentSpec -> CmmNode 'Open 'Open
[CmmUnsafeForeignCall] :: ForeignTarget -> [CmmFormal] -> [CmmActual] -> CmmNode 'Open 'Open
[CmmBranch] :: {-# UNPACK #-} !Label -> CmmNode 'Open 'Closed
[CmmCondBranch] :: CmmExpr -> {-# UNPACK #-} !Label -> {-# UNPACK #-} !Label -> Maybe Bool -> CmmNode 'Open 'Closed
[CmmSwitch] :: CmmExpr -> SwitchTargets -> CmmNode 'Open 'Closed
[CmmCall] :: CmmExpr -> Maybe Label -> [GlobalRegUse] -> ByteOff -> ByteOff -> ByteOff -> CmmNode 'Open 'Closed
[CmmForeignCall] :: ForeignTarget -> [CmmFormal] -> [CmmActual] -> {-# UNPACK #-} !Label -> ByteOff -> ByteOff -> Bool -> CmmNode 'Open 'Closed
type CmmFormal = LocalReg
type CmmActual = CmmExpr

-- | Tickish in Cmm context (annotations only)
type CmmTickish = GenTickish 'TickishPassCmm
type UpdFrameOffset = ByteOff

-- | A convention maps a list of values (function arguments or return
--   values) to registers or stack locations.
data Convention

-- | top-level Haskell functions use <tt>NativeDirectCall</tt>, which maps
--   arguments to registers starting with R2, according to how many
--   registers are available on the platform. This convention ignores R1,
--   because for a top-level function call the function closure is
--   implicit, and doesn't need to be passed.
NativeDirectCall :: Convention

-- | non-top-level Haskell functions, which pass the address of the
--   function closure in R1 (regardless of whether R1 is a real register or
--   not), and the rest of the arguments in registers or on the stack.
NativeNodeCall :: Convention

-- | a native return. The convention for returns depends on how many values
--   are returned: for just one value returned, the appropriate register is
--   used (R1, F1, etc.). regardless of whether it is a real register or
--   not. For multiple values returned, they are mapped to registers or the
--   stack.
NativeReturn :: Convention

-- | Slow entry points: all args pushed on the stack
Slow :: Convention

-- | Entry to the garbage collector: uses the node reg! (TODO: I don't
--   think we need this --SDM)
GC :: Convention
data ForeignConvention
ForeignConvention :: CCallConv -> [ForeignHint] -> [ForeignHint] -> CmmReturnInfo -> ForeignConvention
data ForeignTarget
ForeignTarget :: CmmExpr -> ForeignConvention -> ForeignTarget
PrimTarget :: CallishMachOp -> ForeignTarget
foreignTargetHints :: ForeignTarget -> ([ForeignHint], [ForeignHint])
data CmmReturnInfo
CmmMayReturn :: CmmReturnInfo
CmmNeverReturns :: CmmReturnInfo
mapExp :: forall (e :: Extensibility) (x :: Extensibility). (CmmExpr -> CmmExpr) -> CmmNode e x -> CmmNode e x
mapExpDeep :: forall (e :: Extensibility) (x :: Extensibility). (CmmExpr -> CmmExpr) -> CmmNode e x -> CmmNode e x
wrapRecExp :: (CmmExpr -> CmmExpr) -> CmmExpr -> CmmExpr
foldExp :: forall z (e :: Extensibility) (x :: Extensibility). (CmmExpr -> z -> z) -> CmmNode e x -> z -> z
foldExpDeep :: forall z (e :: Extensibility) (x :: Extensibility). (CmmExpr -> z -> z) -> CmmNode e x -> z -> z
wrapRecExpf :: (CmmExpr -> z -> z) -> CmmExpr -> z -> z
mapExpM :: forall (e :: Extensibility) (x :: Extensibility). (CmmExpr -> Maybe CmmExpr) -> CmmNode e x -> Maybe (CmmNode e x)
mapExpDeepM :: forall (e :: Extensibility) (x :: Extensibility). (CmmExpr -> Maybe CmmExpr) -> CmmNode e x -> Maybe (CmmNode e x)
wrapRecExpM :: (CmmExpr -> Maybe CmmExpr) -> CmmExpr -> Maybe CmmExpr
mapSuccessors :: (Label -> Label) -> CmmNode O C -> CmmNode O C
mapCollectSuccessors :: (Label -> (Label, a)) -> CmmNode O C -> (CmmNode O C, [a])

-- | Tick scope identifier, allowing us to reason about what annotations in
--   a Cmm block should scope over. We especially take care to allow
--   optimisations to reorganise blocks without losing tick association in
--   the process.
data CmmTickScope

-- | The global scope is the "root" of the scope graph. Every scope is a
--   sub-scope of the global scope. It doesn't make sense to add ticks to
--   this scope. On the other hand, this means that setting this scope on a
--   block means no ticks apply to it.
GlobalScope :: CmmTickScope

-- | Constructs a new sub-scope to an existing scope. This allows us to
--   translate Core-style scoping rules (see <tt>tickishScoped</tt>) into
--   the Cmm world. Suppose the following code:
--   
--   tick<a>1</a> case ... of A -&gt; tick<a>2</a> ... B -&gt; tick<a>3</a>
--   ...
--   
--   We want the top-level tick annotation to apply to blocks generated for
--   the A and B alternatives. We can achieve that by generating
--   tick<a>1</a> into a block with scope a, while the code for
--   alternatives A and B gets generated into sub-scopes a/b and a/c
--   respectively.
SubScope :: !Unique -> CmmTickScope -> CmmTickScope

-- | A combined scope scopes over everything that the two given scopes
--   cover. It is therefore a sub-scope of either scope. This is required
--   for optimisations. Consider common block elimination:
--   
--   A -&gt; tick<a>2</a> case ... of C -&gt; [common] B -&gt; tick<a>3</a>
--   case ... of D -&gt; [common]
--   
--   We will generate code for the C and D alternatives, and figure out
--   afterwards that it's actually common code. Scoping rules dictate that
--   the resulting common block needs to be covered by both tick<a>2</a>
--   and tick<a>3</a>, therefore we need to construct a scope that is a
--   child to *both* scope. Now we can do that - if we assign the scopes
--   a<i>c and b</i>d to the common-ed up blocks, the new block could have
--   a combined tick scope a<i>c+b</i>d, which both tick<a>2</a> and
--   tick<a>3</a> apply to.
CombinedScope :: CmmTickScope -> CmmTickScope -> CmmTickScope

-- | Checks whether two tick scopes are sub-scopes of each other. True if
--   the two scopes are equal.
isTickSubScope :: CmmTickScope -> CmmTickScope -> Bool

-- | Combine two tick scopes. The new scope should be sub-scope of both
--   parameters. We simplify automatically if one tick scope is a sub-scope
--   of the other already.
combineTickScopes :: CmmTickScope -> CmmTickScope -> CmmTickScope
instance GHC.Cmm.Expr.DefinerOfRegs GHC.Cmm.Reg.GlobalRegUse (GHC.Cmm.Node.CmmNode e x)
instance GHC.Cmm.Expr.DefinerOfRegs GHC.Cmm.Reg.LocalReg (GHC.Cmm.Node.CmmNode e x)
instance GHC.Classes.Eq (GHC.Cmm.Node.CmmNode e x)
instance GHC.Classes.Eq GHC.Cmm.Node.CmmReturnInfo
instance GHC.Classes.Eq GHC.Cmm.Node.CmmTickScope
instance GHC.Classes.Eq GHC.Cmm.Node.Convention
instance GHC.Classes.Eq GHC.Cmm.Node.ForeignConvention
instance GHC.Classes.Eq GHC.Cmm.Node.ForeignTarget
instance GHC.Cmm.Dataflow.Graph.NonLocal GHC.Cmm.Node.CmmNode
instance GHC.Classes.Ord GHC.Cmm.Node.CmmTickScope
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Node.CmmReturnInfo
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Node.CmmTickScope
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Node.Convention
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Node.ForeignConvention
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.Dataflow.Block.Block GHC.Cmm.Node.CmmNode GHC.Cmm.Dataflow.Block.C GHC.Cmm.Dataflow.Block.C)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.Dataflow.Block.Block GHC.Cmm.Node.CmmNode GHC.Cmm.Dataflow.Block.C GHC.Cmm.Dataflow.Block.O)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.Dataflow.Block.Block GHC.Cmm.Node.CmmNode GHC.Cmm.Dataflow.Block.O GHC.Cmm.Dataflow.Block.C)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.Dataflow.Block.Block GHC.Cmm.Node.CmmNode GHC.Cmm.Dataflow.Block.O GHC.Cmm.Dataflow.Block.O)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.Node.CmmNode e x)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.Node.ForeignTarget
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.Dataflow.Graph.Graph GHC.Cmm.Node.CmmNode e x)
instance GHC.Cmm.Expr.UserOfRegs GHC.Cmm.Reg.GlobalRegUse (GHC.Cmm.Node.CmmNode e x)
instance GHC.Cmm.Expr.UserOfRegs GHC.Cmm.Reg.LocalReg (GHC.Cmm.Node.CmmNode e x)
instance (GHC.Classes.Ord r, GHC.Cmm.Expr.UserOfRegs r GHC.Cmm.Reg.CmmReg) => GHC.Cmm.Expr.UserOfRegs r GHC.Cmm.Node.ForeignTarget

module GHC.Cmm.Lexer
data CmmToken
CmmT_SpecChar :: Char -> CmmToken
CmmT_DotDot :: CmmToken
CmmT_DoubleColon :: CmmToken
CmmT_Shr :: CmmToken
CmmT_Shl :: CmmToken
CmmT_Ge :: CmmToken
CmmT_Le :: CmmToken
CmmT_Eq :: CmmToken
CmmT_Ne :: CmmToken
CmmT_BoolAnd :: CmmToken
CmmT_BoolOr :: CmmToken
CmmT_CLOSURE :: CmmToken
CmmT_INFO_TABLE :: CmmToken
CmmT_INFO_TABLE_RET :: CmmToken
CmmT_INFO_TABLE_FUN :: CmmToken
CmmT_INFO_TABLE_CONSTR :: CmmToken
CmmT_INFO_TABLE_SELECTOR :: CmmToken
CmmT_else :: CmmToken
CmmT_export :: CmmToken
CmmT_section :: CmmToken
CmmT_goto :: CmmToken
CmmT_if :: CmmToken
CmmT_call :: CmmToken
CmmT_jump :: CmmToken
CmmT_foreign :: CmmToken
CmmT_never :: CmmToken
CmmT_prim :: CmmToken
CmmT_reserve :: CmmToken
CmmT_return :: CmmToken
CmmT_returns :: CmmToken
CmmT_import :: CmmToken
CmmT_switch :: CmmToken
CmmT_case :: CmmToken
CmmT_default :: CmmToken
CmmT_push :: CmmToken
CmmT_unwind :: CmmToken
CmmT_bits8 :: CmmToken
CmmT_bits16 :: CmmToken
CmmT_bits32 :: CmmToken
CmmT_bits64 :: CmmToken
CmmT_vec128 :: CmmToken
CmmT_vec256 :: CmmToken
CmmT_vec512 :: CmmToken
CmmT_float32 :: CmmToken
CmmT_float64 :: CmmToken
CmmT_gcptr :: CmmToken
CmmT_GlobalReg :: GlobalRegUse -> CmmToken
CmmT_GlobalArgRegs :: GlobalArgRegs -> CmmToken
CmmT_Name :: FastString -> CmmToken
CmmT_String :: String -> CmmToken
CmmT_Int :: Integer -> CmmToken
CmmT_Float :: Rational -> CmmToken
CmmT_EOF :: CmmToken
CmmT_False :: CmmToken
CmmT_True :: CmmToken
CmmT_likely :: CmmToken
CmmT_Relaxed :: CmmToken
CmmT_Acquire :: CmmToken
CmmT_Release :: CmmToken
CmmT_SeqCst :: CmmToken
cmmlex :: (Located CmmToken -> PD a) -> PD a
instance GHC.Internal.Show.Show GHC.Cmm.Lexer.CmmToken

module GHC.Cmm.LRegSet
type LRegSet = UniqueSet
emptyLRegSet :: LRegSet
nullLRegSet :: LRegSet -> Bool
insertLRegSet :: LocalReg -> LRegSet -> LRegSet
elemLRegSet :: LocalReg -> LRegSet -> Bool
deleteFromLRegSet :: LRegSet -> LocalReg -> LRegSet
sizeLRegSet :: LRegSet -> Int
unionLRegSet :: LRegSet -> LRegSet -> LRegSet
unionsLRegSet :: [LRegSet] -> LRegSet
elemsLRegSet :: LRegSet -> [Unique]

module GHC.Cmm

-- | Cmm group after STG generation
type DCmmGroup = GenCmmGroup CmmStatics DCmmTopInfo DCmmGraph
type CmmProgram = [CmmGroup]

-- | Cmm group before SRT generation
type CmmGroup = GenCmmGroup CmmStatics CmmTopInfo CmmGraph

-- | Cmm group with SRTs
type CmmGroupSRTs = GenCmmGroup RawCmmStatics CmmTopInfo CmmGraph

-- | <a>Raw</a> cmm group (TODO (osa): not sure what that means)
type RawCmmGroup = GenCmmGroup RawCmmStatics LabelMap RawCmmStatics CmmGraph
type GenCmmGroup d h g = [GenCmmDecl d h g]
type CmmDecl = GenCmmDecl CmmStatics CmmTopInfo CmmGraph
type DCmmDecl = GenCmmDecl CmmStatics DCmmTopInfo DCmmGraph
type CmmDeclSRTs = GenCmmDecl RawCmmStatics CmmTopInfo CmmGraph

-- | A top-level chunk, abstracted over the type of the contents of the
--   basic blocks (Cmm or instructions are the likely instantiations).
data GenCmmDecl d h g
CmmProc :: h -> CLabel -> [GlobalRegUse] -> g -> GenCmmDecl d h g
CmmData :: Section -> d -> GenCmmDecl d h g
type CmmDataDecl = GenCmmDataDecl CmmStatics
cmmDataDeclCmmDecl :: GenCmmDataDecl d -> GenCmmDecl d h g
type DCmmGraph = GenGenCmmGraph DWrap CmmNode
type CmmGraph = GenCmmGraph CmmNode
type GenCmmGraph (n :: Extensibility -> Extensibility -> Type) = GenGenCmmGraph LabelMap n
data GenGenCmmGraph (s :: Type -> Type) (n :: Extensibility -> Extensibility -> Type)
CmmGraph :: BlockId -> Graph' s Block n C C -> GenGenCmmGraph (s :: Type -> Type) (n :: Extensibility -> Extensibility -> Type)
[g_entry] :: GenGenCmmGraph (s :: Type -> Type) (n :: Extensibility -> Extensibility -> Type) -> BlockId
[g_graph] :: GenGenCmmGraph (s :: Type -> Type) (n :: Extensibility -> Extensibility -> Type) -> Graph' s Block n C C
toBlockMap :: CmmGraph -> LabelMap CmmBlock
revPostorder :: CmmGraph -> [CmmBlock]
toBlockList :: CmmGraph -> [CmmBlock]
type CmmBlock = Block CmmNode C C
type RawCmmDecl = GenCmmDecl RawCmmStatics LabelMap RawCmmStatics CmmGraph
data Section
Section :: SectionType -> CLabel -> Section
data SectionType
Text :: SectionType
Data :: SectionType
ReadOnlyData :: SectionType
RelocatableReadOnlyData :: SectionType
UninitialisedData :: SectionType
InitArray :: SectionType
FiniArray :: SectionType
CString :: SectionType
OtherSection :: String -> SectionType

-- | Static data before or after SRT generation
data GenCmmStatics (rawOnly :: Bool)
[CmmStatics] :: CLabel -> CmmInfoTable -> CostCentreStack -> [CmmLit] -> [CmmLit] -> GenCmmStatics 'False

-- | Static data, after SRTs are generated
[CmmStaticsRaw] :: forall (rawOnly :: Bool). CLabel -> [CmmStatic] -> GenCmmStatics rawOnly
type CmmStatics = GenCmmStatics 'False
type RawCmmStatics = GenCmmStatics 'True
data CmmStatic

-- | a literal value, size given by cmmLitRep of the literal.
CmmStaticLit :: CmmLit -> CmmStatic

-- | uninitialised data, N bytes long
CmmUninitialised :: Int -> CmmStatic

-- | string of 8-bit values only, not zero terminated.
CmmString :: ByteString -> CmmStatic

-- | an embedded binary file and its byte length
CmmFileEmbed :: FilePath -> Int -> CmmStatic
data SectionProtection
ReadWriteSection :: SectionProtection
ReadOnlySection :: SectionProtection
WriteProtectedSection :: SectionProtection

-- | Should a data in this section be considered constant at runtime
sectionProtection :: Section -> SectionProtection
newtype DWrap a
DWrap :: [(BlockId, a)] -> DWrap a
unDeterm :: DWrap a -> [(BlockId, a)]
removeDeterm :: DCmmGroup -> CmmGroup
removeDetermDecl :: DCmmDecl -> CmmDecl
removeDetermGraph :: DCmmGraph -> CmmGraph
data GenBasicBlock i
BasicBlock :: BlockId -> [i] -> GenBasicBlock i

-- | The branch block id is that of the first block in the branch, which is
--   that branch's entry point
blockId :: GenBasicBlock i -> BlockId
newtype ListGraph i
ListGraph :: [GenBasicBlock i] -> ListGraph i
pprBBlock :: Outputable stmt => GenBasicBlock stmt -> SDoc

-- | CmmTopInfo is attached to each CmmDecl (see defn of CmmGroup), and
--   contains the extra info (beyond the executable code) that belongs to
--   that CmmDecl.
data GenCmmTopInfo (f :: Type -> Type)
TopInfo :: f CmmInfoTable -> CmmStackInfo -> GenCmmTopInfo (f :: Type -> Type)
[info_tbls] :: GenCmmTopInfo (f :: Type -> Type) -> f CmmInfoTable
[stack_info] :: GenCmmTopInfo (f :: Type -> Type) -> CmmStackInfo
type DCmmTopInfo = GenCmmTopInfo DWrap
type CmmTopInfo = GenCmmTopInfo LabelMap
data CmmStackInfo
StackInfo :: ByteOff -> Bool -> CmmStackInfo
[arg_space] :: CmmStackInfo -> ByteOff
[do_layout] :: CmmStackInfo -> Bool

-- | Info table as a haskell data type
data CmmInfoTable
CmmInfoTable :: CLabel -> SMRep -> ProfilingInfo -> Maybe CLabel -> Maybe (Id, CostCentreStack) -> CmmInfoTable
[cit_lbl] :: CmmInfoTable -> CLabel
[cit_rep] :: CmmInfoTable -> SMRep
[cit_prof] :: CmmInfoTable -> ProfilingInfo
[cit_srt] :: CmmInfoTable -> Maybe CLabel
[cit_clo] :: CmmInfoTable -> Maybe (Id, CostCentreStack)
topInfoTable :: forall a (s :: Type -> Type) (n :: Extensibility -> Extensibility -> Type). GenCmmDecl a CmmTopInfo (GenGenCmmGraph s n) -> Maybe CmmInfoTable
topInfoTableD :: forall a (s :: Type -> Type) (n :: Extensibility -> Extensibility -> Type). GenCmmDecl a DCmmTopInfo (GenGenCmmGraph s n) -> Maybe CmmInfoTable
data ClosureTypeInfo
Constr :: ConTagZ -> ConstrDescription -> ClosureTypeInfo
Fun :: FunArity -> ArgDescr -> ClosureTypeInfo
Thunk :: ClosureTypeInfo
ThunkSelector :: SelectorOffset -> ClosureTypeInfo
BlackHole :: ClosureTypeInfo
IndStatic :: ClosureTypeInfo
data ProfilingInfo
NoProfilingInfo :: ProfilingInfo
ProfilingInfo :: ByteString -> ByteString -> ProfilingInfo
type ConstrDescription = ByteString
pprCmmGroup :: (OutputableP Platform d, OutputableP Platform info, OutputableP Platform g) => Platform -> GenCmmGroup d info g -> SDoc
pprSection :: Platform -> Section -> SDoc
pprStatic :: Platform -> CmmStatic -> SDoc
instance GHC.Classes.Eq GHC.Cmm.CmmInfoTable
instance GHC.Classes.Eq GHC.Cmm.ProfilingInfo
instance GHC.Classes.Eq GHC.Cmm.SectionProtection
instance GHC.Internal.Base.Functor GHC.Cmm.GenBasicBlock
instance GHC.Internal.Base.Functor (GHC.Cmm.GenCmmDecl d h)
instance GHC.Internal.Base.Functor GHC.Cmm.ListGraph
instance GHC.Classes.Ord GHC.Cmm.CmmInfoTable
instance GHC.Classes.Ord GHC.Cmm.ProfilingInfo
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CmmStackInfo
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CmmStatic
instance GHC.Utils.Outputable.Outputable instr => GHC.Utils.Outputable.Outputable (GHC.Cmm.GenBasicBlock instr)
instance GHC.Utils.Outputable.Outputable instr => GHC.Utils.Outputable.Outputable (GHC.Cmm.ListGraph instr)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.CmmInfoTable
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.CmmStatic
instance (GHC.Utils.Outputable.OutputableP GHC.Platform.Platform d, GHC.Utils.Outputable.OutputableP GHC.Platform.Platform info, GHC.Utils.Outputable.OutputableP GHC.Platform.Platform i) => GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.GenCmmDecl d info i)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.GenCmmStatics a)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.CmmTopInfo
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.CmmGraph
instance GHC.Utils.Outputable.OutputableP env instr => GHC.Utils.Outputable.OutputableP env (GHC.Cmm.GenBasicBlock instr)
instance GHC.Utils.Outputable.OutputableP env instr => GHC.Utils.Outputable.OutputableP env (GHC.Cmm.ListGraph instr)
instance GHC.Internal.Show.Show GHC.Cmm.SectionType

module GHC.StgToCmm.Sequel

-- | A Sequel tells what to do with the result of this expression
data Sequel

-- | Return result(s) to continuation found on the stack.
Return :: Sequel
AssignTo :: [LocalReg] -> Bool -> Sequel
data SelfLoopInfo
MkSelfLoopInfo :: !Id -> !RepArity -> ![LocalReg] -> !BlockId -> SelfLoopInfo
[sli_id] :: SelfLoopInfo -> !Id

-- | always equal to <a>idFunRepArity</a> of sli_id, i.e. unarised arity,
--   including void arguments
[sli_arity] :: SelfLoopInfo -> !RepArity

-- | Excludes void arguments (LocalReg is never void)
[sli_registers] :: SelfLoopInfo -> ![LocalReg]
[sli_header_block] :: SelfLoopInfo -> !BlockId
instance GHC.Utils.Outputable.Outputable GHC.StgToCmm.Sequel.Sequel

module GHC.CmmToAsm.X86.Regs

-- | regSqueeze_class reg Calculate the maximum number of register colors
--   that could be denied to a node of this class due to having this reg as
--   a neighbour.
virtualRegSqueeze :: RegClass -> VirtualReg -> Int
realRegSqueeze :: RegClass -> RealReg -> Int
data Imm
ImmInt :: Int -> Imm
ImmInteger :: Integer -> Imm
ImmCLbl :: CLabel -> Imm
ImmLit :: FastString -> Imm
ImmIndex :: CLabel -> Int -> Imm
ImmFloat :: Rational -> Imm
ImmDouble :: Rational -> Imm
ImmConstantSum :: Imm -> Imm -> Imm
ImmConstantDiff :: Imm -> Imm -> Imm
strImmLit :: FastString -> Imm
litToImm :: CmmLit -> Imm
data AddrMode
AddrBaseIndex :: EABase -> EAIndex -> Displacement -> AddrMode
ImmAddr :: Imm -> Int -> AddrMode
addrOffset :: AddrMode -> Int -> Maybe AddrMode
spRel :: Platform -> Int -> AddrMode
argRegs :: RegNo -> [Reg]
allArgRegs :: Platform -> [(Reg, Reg)]
allIntArgRegs :: Platform -> [Reg]

-- | these are the regs which we cannot assume stay alive over a C call.
callClobberedRegs :: Platform -> [Reg]
instrClobberedRegs :: Platform -> [Reg]

-- | The complete set of machine registers.
allMachRegNos :: Platform -> [RegNo]

-- | Take the class of a register.
classOfRealReg :: Platform -> RealReg -> RegClass
data EABase
EABaseNone :: EABase
EABaseReg :: Reg -> EABase
EABaseRip :: EABase
data EAIndex
EAIndexNone :: EAIndex
EAIndex :: Reg -> Int -> EAIndex
addrModeRegs :: AddrMode -> [Reg]
eax :: Reg
ebx :: Reg
ecx :: Reg
edx :: Reg
esi :: Reg
edi :: Reg
ebp :: Reg
esp :: Reg
rax :: Reg
rbx :: Reg
rcx :: Reg
rdx :: Reg
rsi :: Reg
rdi :: Reg
rbp :: Reg
rsp :: Reg
r8 :: Reg
r9 :: Reg
r10 :: Reg
r11 :: Reg
r12 :: Reg
r13 :: Reg
r14 :: Reg
r15 :: Reg
lastint :: Platform -> RegNo
xmm0 :: Reg
xmm1 :: Reg
xmm2 :: Reg
xmm3 :: Reg
xmm4 :: Reg
xmm5 :: Reg
xmm6 :: Reg
xmm7 :: Reg
xmm8 :: Reg
xmm9 :: Reg
xmm10 :: Reg
xmm11 :: Reg
xmm12 :: Reg
xmm13 :: Reg
xmm14 :: Reg
xmm15 :: Reg
xmm :: RegNo -> Reg
firstxmm :: RegNo
lastxmm :: Platform -> RegNo
intregnos :: Platform -> [RegNo]
xmmregnos :: Platform -> [RegNo]
ripRel :: Displacement -> AddrMode

-- | on 64bit platforms we pass the first 8 float/double arguments in the
--   xmm registers.
allFPArgRegs :: Platform -> [Reg]
allocatableRegs :: Platform -> [RealReg]


-- | Free regs map for x86_64
module GHC.CmmToAsm.Reg.Linear.X86_64
newtype FreeRegs
FreeRegs :: Word64 -> FreeRegs
noFreeRegs :: FreeRegs
releaseReg :: RealReg -> FreeRegs -> FreeRegs
initFreeRegs :: Platform -> FreeRegs
getFreeRegs :: Platform -> RegClass -> FreeRegs -> [RealReg]
allocateReg :: RealReg -> FreeRegs -> FreeRegs
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Linear.X86_64.FreeRegs
instance GHC.Internal.Show.Show GHC.CmmToAsm.Reg.Linear.X86_64.FreeRegs


-- | Free regs map for i386
module GHC.CmmToAsm.Reg.Linear.X86
newtype FreeRegs
FreeRegs :: Word32 -> FreeRegs
noFreeRegs :: FreeRegs
releaseReg :: RealReg -> FreeRegs -> FreeRegs
initFreeRegs :: Platform -> FreeRegs
getFreeRegs :: Platform -> RegClass -> FreeRegs -> [RealReg]
allocateReg :: RealReg -> FreeRegs -> FreeRegs
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Linear.X86.FreeRegs
instance GHC.Internal.Show.Show GHC.CmmToAsm.Reg.Linear.X86.FreeRegs

module GHC.CmmToAsm.Wasm.Utils
widthMax :: Width -> Integer
detEltsUFM :: forall {k1} k2 (k0 :: k1) a. Ord k2 => UniqFM k0 (k2, a) -> [(k2, a)]
detEltsUniqMap :: Ord k => UniqMap k a -> [(k, a)]
builderCommas :: (a -> Builder) -> [a] -> Builder

module GHC.CmmToAsm.Wasm.Types

-- | WebAssembly type of a WebAssembly value that WebAssembly code could
--   either expect on the evaluation stack or leave on the evaluation
--   stack.
data WasmType
I32 :: WasmType
I64 :: WasmType
F32 :: WasmType
F64 :: WasmType

-- | Singleton type useful for programming with <a>WasmType</a> at the type
--   level.
data WasmTypeTag (a :: WasmType)
[TagI32] :: WasmTypeTag 'I32
[TagI64] :: WasmTypeTag 'I64
[TagF32] :: WasmTypeTag 'F32
[TagF64] :: WasmTypeTag 'F64
data SomeWasmType
[SomeWasmType] :: forall (t :: WasmType). WasmTypeTag t -> SomeWasmType

-- | List of WebAssembly types used to describe the sequence of WebAssembly
--   values that a block of code may expect on the stack or leave on the
--   stack.
data TypeList (a :: [WasmType])
[TypeListNil] :: TypeList ('[] :: [WasmType])
[TypeListCons] :: forall (t :: WasmType) (ts :: [WasmType]). WasmTypeTag t -> TypeList ts -> TypeList (t ': ts)
someWasmTypesFromTypeList :: forall (ts :: [WasmType]). TypeList ts -> [SomeWasmType]

-- | The type of a WebAssembly function, loop, block, or conditional. This
--   type says what values the code expects to pop off the stack and what
--   values it promises to push. The WebAssembly standard requires that
--   this type appear explicitly in the code.
data WasmFunctionType (pre :: [WasmType]) (post :: [WasmType])
WasmFunctionType :: TypeList pre -> TypeList post -> WasmFunctionType (pre :: [WasmType]) (post :: [WasmType])
[ft_pops] :: WasmFunctionType (pre :: [WasmType]) (post :: [WasmType]) -> TypeList pre
[ft_pushes] :: WasmFunctionType (pre :: [WasmType]) (post :: [WasmType]) -> TypeList post

-- | For simplicity, we record other metadata in <a>WasmCodeGenState</a> by
--   need, instead of carrying them along with <a>SymName</a>.
newtype SymName
SymName :: FastString -> SymName
data SymVisibility

-- | Not defined in the current compilation unit.
--   
--   <pre>
--   [ undefined binding=global vis=default ]
--   </pre>
SymUndefined :: SymVisibility

-- | Defined, not visible to other compilation units.
--   
--   <pre>
--   [ binding=local vis=default ]
--   </pre>
SymStatic :: SymVisibility

-- | Defined, visible to other compilation units.
--   
--   Adds <tt>.globl</tt> directives in the output assembly. Also adds
--   <tt>.hidden</tt> when not generating PIC code, similar to
--   -fvisibility=hidden in clang.
--   
--   <pre>
--   [ binding=global vis=hidden ]
--   </pre>
SymDefault :: SymVisibility

-- | Represents whether a symbol is a data symbol or a function symbol.
--   Unlike linkers for other targets, <tt>wasm-ld</tt> does panic at
--   link-time if it finds symbol kind inconsistency between the definition
--   site and other use sites.
--   
--   Currently we solely rely on <tt>isCFunctionLabel</tt> to determine a
--   symbol's kind, but it does take extra effort to make it work. The main
--   source of inconsistency arises from hand-written Cmm sources, where
--   it's possible to refer to external entities like <tt>xxx_info</tt> and
--   <tt>xxx_closure</tt> without explicit <tt>import CLOSURE</tt>
--   declarations. The Cmm parser will implicitly assume those are foreign
--   function labels, and then this will break the WebAssembly backend.
--   #22368 provides more context on this issue.
--   
--   tl;dr for any GHC contributor that accidentally triggers
--   <tt>wasm-ld</tt> errors when hacking Cmm: whatever data symbols are
--   used in new code, just add the corresponding <tt>import CLOSURE</tt>
--   declarations at the top of that Cmm file.
data SymKind
SymData :: SymKind
SymFunc :: SymKind

-- | WebAssembly doesn't really have proper read-only memory regions yet.
--   Neverthless we add the .rodata logic here, wasm-ld will aggregate all
--   .rodata sections into a single one, which adds possibility for runtime
--   checks later, either via a customized runtime, or via code
--   instrumentation. See
--   <a>https://github.com/llvm/llvm-project/blob/b296aed8ae239c20ebdd7969e978f8d2a3b9c178/lld/wasm/Writer.cpp#L856</a>
data DataSectionKind
SectionData :: DataSectionKind
SectionROData :: DataSectionKind

-- | Neither Cmm or Wasm type system takes integer signedness into account,
--   therefore we always round up a <a>CmmLit</a> to the right width and
--   handle it as an untyped integer.
data DataSectionContent
DataI8 :: Word8 -> DataSectionContent
DataI16 :: Word16 -> DataSectionContent
DataI32 :: Word32 -> DataSectionContent
DataI64 :: Word64 -> DataSectionContent
DataF32 :: Float -> DataSectionContent
DataF64 :: Double -> DataSectionContent
DataSym :: SymName -> Int -> DataSectionContent
DataSkip :: Int -> DataSectionContent
DataASCII :: ByteString -> DataSectionContent
DataIncBin :: FilePath -> Int -> DataSectionContent
data DataSection
DataSection :: DataSectionKind -> Alignment -> [DataSectionContent] -> DataSection
[dataSectionKind] :: DataSection -> DataSectionKind
[dataSectionAlignment] :: DataSection -> Alignment
[dataSectionContents] :: DataSection -> [DataSectionContent]
type GlobalInfo = (SymName, SomeWasmType)
type LocalInfo = (Int, SomeWasmType)
data FuncBody (w :: WasmType)
FuncBody :: [SomeWasmType] -> WasmControl (WasmStatements w) (WasmExpr w w) ('[] :: [WasmType]) '[w] -> FuncBody (w :: WasmType)
[funcLocals] :: FuncBody (w :: WasmType) -> [SomeWasmType]

-- | Most are Cmm functions, but may also contain synthesized function of
--   other types, sigh.
[funcBody] :: FuncBody (w :: WasmType) -> WasmControl (WasmStatements w) (WasmExpr w w) ('[] :: [WasmType]) '[w]
data Signage
Signed :: Signage
Unsigned :: Signage

-- | The <tt>w</tt> type variable in the Wasm IR stands for "platform word
--   type", so <a>TagI32</a> on wasm32, and <a>TagI64</a> on wasm64. This
--   way, we can make the codegen logic work on both wasm32/wasm64 in a
--   type-safe manner.
data WasmInstr (a :: WasmType) (b :: [WasmType]) (c :: [WasmType])
[WasmComment] :: forall (a :: WasmType) (b :: [WasmType]). String -> WasmInstr a b b
[WasmNop] :: forall (a :: WasmType) (b :: [WasmType]). WasmInstr a b b
[WasmDrop] :: forall (a :: WasmType) (t :: WasmType) (c :: [WasmType]). WasmInstr a (t ': c) c
[WasmUnreachable] :: forall (a :: WasmType) (b :: [WasmType]) (c :: [WasmType]). WasmInstr a b c
[WasmConst] :: forall (t :: WasmType) (a :: WasmType) (b :: [WasmType]). WasmTypeTag t -> Integer -> WasmInstr a b (t ': b)
[WasmSymConst] :: forall (a :: WasmType) (b :: [WasmType]). SymName -> WasmInstr a b (a ': b)
[WasmLoad] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). WasmTypeTag t -> Maybe Int -> Signage -> Int -> AlignmentSpec -> WasmInstr a (a ': pre) (t ': pre)
[WasmStore] :: forall (t :: WasmType) (a :: WasmType) (c :: [WasmType]). WasmTypeTag t -> Maybe Int -> Int -> AlignmentSpec -> WasmInstr a (t ': (a ': c)) c
[WasmGlobalGet] :: forall (t :: WasmType) (a :: WasmType) (b :: [WasmType]). WasmTypeTag t -> SymName -> WasmInstr a b (t ': b)
[WasmGlobalSet] :: forall (t :: WasmType) (a :: WasmType) (c :: [WasmType]). WasmTypeTag t -> SymName -> WasmInstr a (t ': c) c
[WasmLocalGet] :: forall (t :: WasmType) (a :: WasmType) (b :: [WasmType]). WasmTypeTag t -> Int -> WasmInstr a b (t ': b)
[WasmLocalSet] :: forall (t :: WasmType) (a :: WasmType) (c :: [WasmType]). WasmTypeTag t -> Int -> WasmInstr a (t ': c) c
[WasmLocalTee] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). WasmTypeTag t -> Int -> WasmInstr a (t ': pre) (t ': pre)
[WasmCCall] :: forall (a :: WasmType) (b :: [WasmType]) (c :: [WasmType]). SymName -> WasmInstr a b c
[WasmCCallIndirect] :: forall (arg_tys :: [WasmType]) (ret_tys :: [WasmType]) (a :: WasmType) (pre :: [WasmType]) (c :: [WasmType]). TypeList arg_tys -> TypeList ret_tys -> WasmInstr a (a ': pre) c
[WasmConcat] :: forall (a :: WasmType) (b :: [WasmType]) (mid :: [WasmType]) (c :: [WasmType]). WasmInstr a b mid -> WasmInstr a mid c -> WasmInstr a b c
[WasmReinterpret] :: forall (t0 :: WasmType) (t1 :: WasmType) (a :: WasmType) (pre :: [WasmType]). WasmTypeTag t0 -> WasmTypeTag t1 -> WasmInstr a (t0 ': pre) (t1 ': pre)
[WasmTruncSat] :: forall (t0 :: WasmType) (t1 :: WasmType) (a :: WasmType) (pre :: [WasmType]). Signage -> WasmTypeTag t0 -> WasmTypeTag t1 -> WasmInstr a (t0 ': pre) (t1 ': pre)
[WasmConvert] :: forall (t0 :: WasmType) (t1 :: WasmType) (a :: WasmType) (pre :: [WasmType]). Signage -> WasmTypeTag t0 -> WasmTypeTag t1 -> WasmInstr a (t0 ': pre) (t1 ': pre)
[WasmAdd] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). WasmTypeTag t -> WasmInstr a (t ': (t ': pre)) (t ': pre)
[WasmSub] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). WasmTypeTag t -> WasmInstr a (t ': (t ': pre)) (t ': pre)
[WasmMul] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). WasmTypeTag t -> WasmInstr a (t ': (t ': pre)) (t ': pre)
[WasmDiv] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). Signage -> WasmTypeTag t -> WasmInstr a (t ': (t ': pre)) (t ': pre)
[WasmRem] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). Signage -> WasmTypeTag t -> WasmInstr a (t ': (t ': pre)) (t ': pre)
[WasmAnd] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). WasmTypeTag t -> WasmInstr a (t ': (t ': pre)) (t ': pre)
[WasmOr] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). WasmTypeTag t -> WasmInstr a (t ': (t ': pre)) (t ': pre)
[WasmXor] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). WasmTypeTag t -> WasmInstr a (t ': (t ': pre)) (t ': pre)
[WasmEq] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). WasmTypeTag t -> WasmInstr a (t ': (t ': pre)) (a ': pre)
[WasmNe] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). WasmTypeTag t -> WasmInstr a (t ': (t ': pre)) (a ': pre)
[WasmLt] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). Signage -> WasmTypeTag t -> WasmInstr a (t ': (t ': pre)) (a ': pre)
[WasmGt] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). Signage -> WasmTypeTag t -> WasmInstr a (t ': (t ': pre)) (a ': pre)
[WasmLe] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). Signage -> WasmTypeTag t -> WasmInstr a (t ': (t ': pre)) (a ': pre)
[WasmGe] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). Signage -> WasmTypeTag t -> WasmInstr a (t ': (t ': pre)) (a ': pre)
[WasmShl] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). WasmTypeTag t -> WasmInstr a (t ': (t ': pre)) (t ': pre)
[WasmShr] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). Signage -> WasmTypeTag t -> WasmInstr a (t ': (t ': pre)) (t ': pre)
[WasmI32Extend8S] :: forall (a :: WasmType) (pre :: [WasmType]). WasmInstr a ('I32 ': pre) ('I32 ': pre)
[WasmI32Extend16S] :: forall (a :: WasmType) (pre :: [WasmType]). WasmInstr a ('I32 ': pre) ('I32 ': pre)
[WasmI64Extend8S] :: forall (a :: WasmType) (pre :: [WasmType]). WasmInstr a ('I64 ': pre) ('I64 ': pre)
[WasmI64Extend16S] :: forall (a :: WasmType) (pre :: [WasmType]). WasmInstr a ('I64 ': pre) ('I64 ': pre)
[WasmI64Extend32S] :: forall (a :: WasmType) (pre :: [WasmType]). WasmInstr a ('I64 ': pre) ('I64 ': pre)
[WasmI64ExtendI32] :: forall (a :: WasmType) (pre :: [WasmType]). Signage -> WasmInstr a ('I32 ': pre) ('I64 ': pre)
[WasmI32WrapI64] :: forall (a :: WasmType) (pre :: [WasmType]). WasmInstr a ('I64 ': pre) ('I32 ': pre)
[WasmF32DemoteF64] :: forall (a :: WasmType) (pre :: [WasmType]). WasmInstr a ('F64 ': pre) ('F32 ': pre)
[WasmF64PromoteF32] :: forall (a :: WasmType) (pre :: [WasmType]). WasmInstr a ('F32 ': pre) ('F64 ': pre)
[WasmAbs] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). WasmTypeTag t -> WasmInstr a (t ': pre) (t ': pre)
[WasmNeg] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). WasmTypeTag t -> WasmInstr a (t ': pre) (t ': pre)
[WasmMin] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). WasmTypeTag t -> WasmInstr a (t ': (t ': pre)) (t ': pre)
[WasmMax] :: forall (t :: WasmType) (a :: WasmType) (pre :: [WasmType]). WasmTypeTag t -> WasmInstr a (t ': (t ': pre)) (t ': pre)
[WasmCond] :: forall (a :: WasmType) (c :: [WasmType]). WasmInstr a c c -> WasmInstr a (a ': c) c
newtype WasmExpr (w :: WasmType) (t :: WasmType)
WasmExpr :: (forall (pre :: [WasmType]). () => WasmInstr w pre (t ': pre)) -> WasmExpr (w :: WasmType) (t :: WasmType)
data SomeWasmExpr (w :: WasmType)
[SomeWasmExpr] :: forall (t :: WasmType) (w :: WasmType). WasmTypeTag t -> WasmExpr w t -> SomeWasmExpr w
newtype WasmStatements (w :: WasmType)
WasmStatements :: (forall (pre :: [WasmType]). () => WasmInstr w pre pre) -> WasmStatements (w :: WasmType)

-- | Representation of WebAssembly control flow. Normally written as <tt>
--   WasmControl s e pre post </tt> Type parameter <tt>s</tt> is the type
--   of (unspecified) statements. It might be instantiated with an open Cmm
--   block or with a sequence of Wasm instructions. Parameter <tt>e</tt> is
--   the type of expressions. Parameter <tt>pre</tt> represents the values
--   that are expected on the WebAssembly stack when the code runs, and
--   <tt>post</tt> represents the state of the stack on completion.
data WasmControl a b (c :: [WasmType]) (d :: [WasmType])
[WasmPush] :: forall (t :: WasmType) b a (c :: [WasmType]). WasmTypeTag t -> b -> WasmControl a b c (t ': c)
[WasmBlock] :: forall (c :: [WasmType]) (d :: [WasmType]) a b. WasmFunctionType c d -> WasmControl a b c d -> WasmControl a b c d
[WasmLoop] :: forall (c :: [WasmType]) (d :: [WasmType]) a b. WasmFunctionType c d -> WasmControl a b c d -> WasmControl a b c d
[WasmIfTop] :: forall (pre :: [WasmType]) (d :: [WasmType]) a b. WasmFunctionType pre d -> WasmControl a b pre d -> WasmControl a b pre d -> WasmControl a b ('I32 ': pre) d
[WasmBr] :: forall a b (c :: [WasmType]) (d :: [WasmType]). Int -> WasmControl a b c d
[WasmFallthrough] :: forall a b (c :: [WasmType]) (d :: [WasmType]). WasmControl a b c d
[WasmBrTable] :: forall b a (c :: [WasmType]) (d :: [WasmType]). b -> BrTableInterval -> [Int] -> Int -> WasmControl a b c d
[WasmTailCall] :: forall b a (c :: [WasmType]) (d :: [WasmType]). b -> WasmControl a b c d
[WasmActions] :: forall a b (c :: [WasmType]). a -> WasmControl a b c c
[WasmSeq] :: forall a b (c :: [WasmType]) (mid :: [WasmType]) (d :: [WasmType]). WasmControl a b c mid -> WasmControl a b mid d -> WasmControl a b c d
data BrTableInterval
BrTableInterval :: Integer -> Integer -> BrTableInterval
[bti_lo] :: BrTableInterval -> Integer
[bti_count] :: BrTableInterval -> Integer
wasmControlCast :: forall s e (pre :: [WasmType]) (post :: [WasmType]) (pre' :: [WasmType]) (post' :: [WasmType]). WasmControl s e pre post -> WasmControl s e pre' post'
data WasmCodeGenState (w :: WasmType)
WasmCodeGenState :: Platform -> SymSet -> SymMap ([SomeWasmType], [SomeWasmType]) -> SymMap (FuncBody w) -> SymMap DataSection -> [SymName] -> UniqFM LocalReg LocalInfo -> Int -> DUniqSupply -> WasmCodeGenState (w :: WasmType)

-- | Target platform
[wasmPlatform] :: WasmCodeGenState (w :: WasmType) -> Platform

-- | Defined symbols with <a>SymDefault</a> visibility.
[defaultSyms] :: WasmCodeGenState (w :: WasmType) -> SymSet

-- | Function types, defined or not. There may exist a function whose type
--   is unknown (e.g. as a function pointer), in that case we fall back to
--   () -&gt; (), it's imperfect but works with wasm-ld.
[funcTypes] :: WasmCodeGenState (w :: WasmType) -> SymMap ([SomeWasmType], [SomeWasmType])

-- | Defined function bodies.
[funcBodies] :: WasmCodeGenState (w :: WasmType) -> SymMap (FuncBody w)

-- | Defined data sections.
[dataSections] :: WasmCodeGenState (w :: WasmType) -> SymMap DataSection

-- | ctors in the current compilation unit.
[ctors] :: WasmCodeGenState (w :: WasmType) -> [SymName]
[localRegs] :: WasmCodeGenState (w :: WasmType) -> UniqFM LocalReg LocalInfo
[localRegsCount] :: WasmCodeGenState (w :: WasmType) -> Int
[wasmDUniqSupply] :: WasmCodeGenState (w :: WasmType) -> DUniqSupply
initialWasmCodeGenState :: forall (w :: WasmType). Platform -> DUniqSupply -> WasmCodeGenState w
newtype WasmCodeGenM (w :: WasmType) a
WasmCodeGenM :: State (WasmCodeGenState w) a -> WasmCodeGenM (w :: WasmType) a
wasmGetsM :: forall (w :: WasmType) a. (WasmCodeGenState w -> a) -> WasmCodeGenM w a
wasmPlatformM :: forall (w :: WasmType). WasmCodeGenM w Platform
wasmWordTypeM :: forall (w :: WasmType). WasmCodeGenM w (WasmTypeTag w)
wasmWordCmmTypeM :: forall (w :: WasmType). WasmCodeGenM w CmmType
wasmStateM :: forall (w :: WasmType) a. (WasmCodeGenState w -> (# a, WasmCodeGenState w #)) -> WasmCodeGenM w a
wasmModifyM :: forall (w :: WasmType). (WasmCodeGenState w -> WasmCodeGenState w) -> WasmCodeGenM w ()
wasmExecM :: forall (w :: WasmType) a. WasmCodeGenM w a -> WasmCodeGenState w -> WasmCodeGenState w
wasmRunM :: forall (w :: WasmType) a. WasmCodeGenM w a -> WasmCodeGenState w -> (a, WasmCodeGenState w)
data WasmAsmConfig
WasmAsmConfig :: Bool -> Bool -> ~SymSet -> ~SymSet -> WasmAsmConfig
[pic] :: WasmAsmConfig -> Bool
[tailcall] :: WasmAsmConfig -> Bool

-- | Data/function symbols with <a>SymStatic</a> visibility (defined but
--   not visible to other compilation units). When doing PIC codegen,
--   private symbols must be emitted as <tt>MBREL</tt>/<tt>TBREL</tt>
--   relocations in the code section. The public symbols, defined or
--   elsewhere, are all emitted as <tt>GOT</tt> relocations instead.
[mbrelSyms] :: WasmAsmConfig -> ~SymSet

-- | Data/function symbols with <a>SymStatic</a> visibility (defined but
--   not visible to other compilation units). When doing PIC codegen,
--   private symbols must be emitted as <tt>MBREL</tt>/<tt>TBREL</tt>
--   relocations in the code section. The public symbols, defined or
--   elsewhere, are all emitted as <tt>GOT</tt> relocations instead.
[tbrelSyms] :: WasmAsmConfig -> ~SymSet

-- | The default <a>WasmAsmConfig</a> must be extracted from the final
--   <a>WasmCodeGenState</a>.
defaultWasmAsmConfig :: forall (w :: WasmType). WasmCodeGenState w -> WasmAsmConfig
instance GHC.Internal.Base.Applicative (GHC.CmmToAsm.Wasm.Types.WasmCodeGenM w)
instance GHC.Classes.Eq GHC.CmmToAsm.Wasm.Types.SomeWasmType
instance GHC.Classes.Eq GHC.CmmToAsm.Wasm.Types.SymKind
instance GHC.Classes.Eq GHC.CmmToAsm.Wasm.Types.SymName
instance GHC.Internal.Base.Functor (GHC.CmmToAsm.Wasm.Types.WasmCodeGenM w)
instance GHC.Internal.Data.String.IsString GHC.CmmToAsm.Wasm.Types.SymName
instance GHC.Types.Unique.DSM.MonadGetUnique (GHC.CmmToAsm.Wasm.Types.WasmCodeGenM w)
instance GHC.Types.Unique.DSM.MonadUniqDSM (GHC.CmmToAsm.Wasm.Types.WasmCodeGenM w)
instance GHC.Internal.Base.Monad (GHC.CmmToAsm.Wasm.Types.WasmCodeGenM w)
instance GHC.Classes.Ord GHC.CmmToAsm.Wasm.Types.SymName
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Wasm.Types.BrTableInterval
instance GHC.Internal.Show.Show GHC.CmmToAsm.Wasm.Types.BrTableInterval
instance GHC.Internal.Show.Show GHC.CmmToAsm.Wasm.Types.SymName
instance GHC.Internal.Show.Show (GHC.CmmToAsm.Wasm.Types.WasmTypeTag t)
instance GHC.Internal.Data.Type.Equality.TestEquality GHC.CmmToAsm.Wasm.Types.WasmTypeTag
instance GHC.Types.Unique.Uniquable GHC.CmmToAsm.Wasm.Types.SymName

module GHC.Wasm.ControlFlow

-- | Representation of WebAssembly control flow. Normally written as <tt>
--   WasmControl s e pre post </tt> Type parameter <tt>s</tt> is the type
--   of (unspecified) statements. It might be instantiated with an open Cmm
--   block or with a sequence of Wasm instructions. Parameter <tt>e</tt> is
--   the type of expressions. Parameter <tt>pre</tt> represents the values
--   that are expected on the WebAssembly stack when the code runs, and
--   <tt>post</tt> represents the state of the stack on completion.
data WasmControl a b (c :: [WasmType]) (d :: [WasmType])
[WasmPush] :: forall (t :: WasmType) b a (c :: [WasmType]). WasmTypeTag t -> b -> WasmControl a b c (t ': c)
[WasmBlock] :: forall (c :: [WasmType]) (d :: [WasmType]) a b. WasmFunctionType c d -> WasmControl a b c d -> WasmControl a b c d
[WasmLoop] :: forall (c :: [WasmType]) (d :: [WasmType]) a b. WasmFunctionType c d -> WasmControl a b c d -> WasmControl a b c d
[WasmIfTop] :: forall (pre :: [WasmType]) (d :: [WasmType]) a b. WasmFunctionType pre d -> WasmControl a b pre d -> WasmControl a b pre d -> WasmControl a b ('I32 ': pre) d
[WasmBr] :: forall a b (c :: [WasmType]) (d :: [WasmType]). Int -> WasmControl a b c d
[WasmFallthrough] :: forall a b (c :: [WasmType]) (d :: [WasmType]). WasmControl a b c d
[WasmBrTable] :: forall b a (c :: [WasmType]) (d :: [WasmType]). b -> BrTableInterval -> [Int] -> Int -> WasmControl a b c d
[WasmTailCall] :: forall b a (c :: [WasmType]) (d :: [WasmType]). b -> WasmControl a b c d
[WasmActions] :: forall a b (c :: [WasmType]). a -> WasmControl a b c c
[WasmSeq] :: forall a b (c :: [WasmType]) (mid :: [WasmType]) (d :: [WasmType]). WasmControl a b c mid -> WasmControl a b mid d -> WasmControl a b c d
(<>) :: forall s e (pre :: [WasmType]) (mid :: [WasmType]) (post :: [WasmType]). WasmControl s e pre mid -> WasmControl s e mid post -> WasmControl s e pre post
pattern WasmIf :: WasmFunctionType pre post -> e -> WasmControl s e pre post -> WasmControl s e pre post -> WasmControl s e pre post
data BrTableInterval
BrTableInterval :: Integer -> Integer -> BrTableInterval
[bti_lo] :: BrTableInterval -> Integer
[bti_count] :: BrTableInterval -> Integer

-- | Module : GHC.Wasm.ControlFlow Description : Representation of
--   control-flow portion of the WebAssembly instruction set
inclusiveInterval :: Integer -> Integer -> BrTableInterval

-- | WebAssembly type of a WebAssembly value that WebAssembly code could
--   either expect on the evaluation stack or leave on the evaluation
--   stack.
data WasmType

-- | Singleton type useful for programming with <a>WasmType</a> at the type
--   level.
data WasmTypeTag (a :: WasmType)
[TagI32] :: WasmTypeTag 'I32
[TagI64] :: WasmTypeTag 'I64
[TagF32] :: WasmTypeTag 'F32
[TagF64] :: WasmTypeTag 'F64

-- | List of WebAssembly types used to describe the sequence of WebAssembly
--   values that a block of code may expect on the stack or leave on the
--   stack.
data TypeList (a :: [WasmType])
[TypeListNil] :: TypeList ('[] :: [WasmType])
[TypeListCons] :: forall (t :: WasmType) (ts :: [WasmType]). WasmTypeTag t -> TypeList ts -> TypeList (t ': ts)

-- | The type of a WebAssembly function, loop, block, or conditional. This
--   type says what values the code expects to pop off the stack and what
--   values it promises to push. The WebAssembly standard requires that
--   this type appear explicitly in the code.
data WasmFunctionType (pre :: [WasmType]) (post :: [WasmType])
WasmFunctionType :: TypeList pre -> TypeList post -> WasmFunctionType (pre :: [WasmType]) (post :: [WasmType])
[ft_pops] :: WasmFunctionType (pre :: [WasmType]) (post :: [WasmType]) -> TypeList pre
[ft_pushes] :: WasmFunctionType (pre :: [WasmType]) (post :: [WasmType]) -> TypeList post

module GHC.CmmToAsm.Utils

-- | Returns the info table associated with the CmmDecl's entry point, if
--   any.
topInfoTable :: GenCmmDecl a (LabelMap i) (ListGraph b) -> Maybe i

-- | Return the list of BlockIds in a CmmDecl that are entry points for
--   this proc (i.e. they may be jumped to from outside this proc).
entryBlocks :: GenCmmDecl a (LabelMap i) (ListGraph b) -> [BlockId]

module GHC.CmmToAsm.Types
type NatCmm instr = GenCmmGroup RawCmmStatics LabelMap RawCmmStatics ListGraph instr
type NatCmmDecl statics instr = GenCmmDecl statics LabelMap RawCmmStatics ListGraph instr
type NatBasicBlock instr = GenBasicBlock instr
data GenBasicBlock i
BasicBlock :: BlockId -> [i] -> GenBasicBlock i

-- | The branch block id is that of the first block in the branch, which is
--   that branch's entry point
blockId :: GenBasicBlock i -> BlockId
newtype ListGraph i
ListGraph :: [GenBasicBlock i] -> ListGraph i
type RawCmmStatics = GenCmmStatics 'True
type RawCmmDecl = GenCmmDecl RawCmmStatics LabelMap RawCmmStatics CmmGraph

module GHC.CmmToAsm.Ppr

-- | Get bytes of a Double representation
doubleToBytes :: Double -> [Word8]

-- | Get bytes of a Float representation
floatToBytes :: Float -> [Word8]
pprASCII :: IsLine doc => ByteString -> doc

-- | Emit a ".string" directive
pprString :: IsLine doc => ByteString -> doc

-- | Emit a ".incbin" directive
--   
--   A NULL byte is added after the binary data.
pprFileEmbed :: IsLine doc => FilePath -> doc
pprSectionHeader :: IsLine doc => NCGConfig -> Section -> doc


-- | The LLVM Type System.
module GHC.Llvm.Types

-- | A global mutable variable. Maybe defined or external
data LMGlobal
LMGlobal :: LlvmVar -> Maybe LlvmStatic -> LMGlobal

-- | Returns the variable of the <a>LMGlobal</a>
[getGlobalVar] :: LMGlobal -> LlvmVar

-- | Return the value of the <a>LMGlobal</a>
[getGlobalValue] :: LMGlobal -> Maybe LlvmStatic

-- | A String in LLVM
type LMString = FastString

-- | A type alias
type LlvmAlias = (LMString, LlvmType)

-- | Llvm Types
data LlvmType

-- | An integer with a given width in bits.
LMInt :: Int -> LlvmType

-- | 32 bit floating point
LMFloat :: LlvmType

-- | 64 bit floating point
LMDouble :: LlvmType

-- | 80 bit (x86 only) floating point
LMFloat80 :: LlvmType

-- | 128 bit floating point
LMFloat128 :: LlvmType

-- | A pointer to a <a>LlvmType</a>
LMPointer :: LlvmType -> LlvmType

-- | An array of <a>LlvmType</a>
LMArray :: Int -> LlvmType -> LlvmType

-- | A vector of <a>LlvmType</a>
LMVector :: Int -> LlvmType -> LlvmType

-- | A <a>LlvmVar</a> can represent a label (address)
LMLabel :: LlvmType

-- | Void type
LMVoid :: LlvmType

-- | Packed structure type
LMStruct :: [LlvmType] -> LlvmType

-- | Unpacked structure type
LMStructU :: [LlvmType] -> LlvmType

-- | A type alias
LMAlias :: LlvmAlias -> LlvmType

-- | LLVM Metadata
LMMetadata :: LlvmType

-- | Function type, used to create pointers to functions
LMFunction :: LlvmFunctionDecl -> LlvmType
ppLlvmType :: IsLine doc => LlvmType -> doc

-- | Pretty-print a short name for a scalar or vector type, e.g.
--   <tt>"i16"</tt> or <tt>"v4f32"</tt>.
ppLlvmTypeShort :: LlvmType -> String
ppParams :: IsLine doc => LlvmParameterListType -> [LlvmParameter] -> doc

-- | An LLVM section definition. If Nothing then let LLVM decide the
--   section
type LMSection = Maybe LMString
type LMAlign = Maybe Int
data LMConst

-- | Mutable global variable
Global :: LMConst

-- | Constant global variable
Constant :: LMConst

-- | Alias of another variable
Alias :: LMConst

-- | LLVM Variables
data LlvmVar

-- | Variables with a global scope.
LMGlobalVar :: LMString -> LlvmType -> LlvmLinkageType -> LMSection -> LMAlign -> LMConst -> LlvmVar

-- | Variables local to a function or parameters.
LMLocalVar :: Unique -> LlvmType -> LlvmVar

-- | Named local variables. Sometimes we need to be able to explicitly name
--   variables (e.g for function arguments).
LMNLocalVar :: LMString -> LlvmType -> LlvmVar

-- | A constant variable
LMLitVar :: LlvmLit -> LlvmVar

-- | Llvm Literal Data.
--   
--   These can be used inline in expressions.
data LlvmLit

-- | Refers to an integer constant (i64 42).
LMIntLit :: Integer -> LlvmType -> LlvmLit

-- | Floating point literal
LMFloatLit :: Double -> LlvmType -> LlvmLit

-- | Literal NULL, only applicable to pointer types
LMNullLit :: LlvmType -> LlvmLit

-- | Vector literal
LMVectorLit :: [LlvmLit] -> LlvmLit

-- | Undefined value, random bit pattern. Useful for optimisations.
LMUndefLit :: LlvmType -> LlvmLit

-- | Llvm Static Data.
--   
--   These represent the possible global level variables and constants.
data LlvmStatic

-- | A comment in a static section
LMComment :: LMString -> LlvmStatic

-- | A static variant of a literal value
LMStaticLit :: LlvmLit -> LlvmStatic

-- | For uninitialised data
LMUninitType :: LlvmType -> LlvmStatic

-- | Defines a static <a>LMString</a>
LMStaticStr :: LMString -> LlvmType -> LlvmStatic

-- | A static array
LMStaticArray :: [LlvmStatic] -> LlvmType -> LlvmStatic

-- | A static structure type
LMStaticStruc :: [LlvmStatic] -> LlvmType -> LlvmStatic

-- | A static structure type
LMStaticStrucU :: [LlvmStatic] -> LlvmType -> LlvmStatic

-- | A pointer to other data
LMStaticPointer :: LlvmVar -> LlvmStatic

-- | Truncate
LMTrunc :: LlvmStatic -> LlvmType -> LlvmStatic

-- | Pointer to Pointer conversion
LMBitc :: LlvmStatic -> LlvmType -> LlvmStatic

-- | Pointer to Integer conversion
LMPtoI :: LlvmStatic -> LlvmType -> LlvmStatic

-- | Constant addition operation
LMAdd :: LlvmStatic -> LlvmStatic -> LlvmStatic

-- | Constant subtraction operation
LMSub :: LlvmStatic -> LlvmStatic -> LlvmStatic
garbageLit :: LlvmType -> Maybe LlvmLit

-- | Return the <a>LlvmType</a> of the <a>LlvmVar</a>
getVarType :: LlvmVar -> LlvmType

-- | Return the <a>LlvmType</a> of a <a>LlvmLit</a>
getLitType :: LlvmLit -> LlvmType

-- | Return the <a>LlvmType</a> of the <a>LlvmStatic</a>
getStatType :: LlvmStatic -> LlvmType

-- | Return the <a>LlvmLinkageType</a> for a <a>LlvmVar</a>
getLink :: LlvmVar -> LlvmLinkageType

-- | Add a pointer indirection to the supplied type. <a>LMLabel</a> and
--   <a>LMVoid</a> cannot be lifted.
pLift :: LlvmType -> LlvmType

-- | Lift a variable to <a>LMPointer</a> type.
pVarLift :: LlvmVar -> LlvmVar

-- | Remove the pointer indirection of the supplied type. Only
--   <a>LMPointer</a> constructors can be lowered.
pLower :: LlvmType -> LlvmType

-- | Lower a variable of <a>LMPointer</a> type.
pVarLower :: LlvmVar -> LlvmVar

-- | Test if the given <a>LlvmType</a> is an integer
isInt :: LlvmType -> Bool

-- | Test if the given <a>LlvmType</a> is a floating point type
isFloat :: LlvmType -> Bool

-- | Test if the given <a>LlvmType</a> is an <a>LMPointer</a> construct
isPointer :: LlvmType -> Bool

-- | Test if the given <a>LlvmType</a> is an <a>LMVector</a> construct
isVector :: LlvmType -> Bool

-- | Test if a <a>LlvmVar</a> is global.
isGlobal :: LlvmVar -> Bool

-- | Width in bits of an <a>LlvmType</a>, returns 0 if not applicable
llvmWidthInBits :: Platform -> LlvmType -> Int
i128 :: LlvmType
i64 :: LlvmType
i32 :: LlvmType
i16 :: LlvmType
i8 :: LlvmType
i1 :: LlvmType
i8Ptr :: LlvmType

-- | The target architectures word size
llvmWord :: Platform -> LlvmType

-- | The target architectures word size
llvmWordPtr :: Platform -> LlvmType

-- | An LLVM Function
data LlvmFunctionDecl
LlvmFunctionDecl :: LMString -> LlvmLinkageType -> LlvmCallConvention -> LlvmType -> LlvmParameterListType -> [LlvmParameter] -> LMAlign -> LlvmFunctionDecl

-- | Unique identifier of the function
[decName] :: LlvmFunctionDecl -> LMString

-- | LinkageType of the function
[funcLinkage] :: LlvmFunctionDecl -> LlvmLinkageType

-- | The calling convention of the function
[funcCc] :: LlvmFunctionDecl -> LlvmCallConvention

-- | Type of the returned value
[decReturnType] :: LlvmFunctionDecl -> LlvmType

-- | Indicates if this function uses varargs
[decVarargs] :: LlvmFunctionDecl -> LlvmParameterListType

-- | Parameter types and attributes
[decParams] :: LlvmFunctionDecl -> [LlvmParameter]

-- | Function align value, must be power of 2
[funcAlign] :: LlvmFunctionDecl -> LMAlign
type LlvmFunctionDecls = [LlvmFunctionDecl]
type LlvmParameter = (LlvmType, [LlvmParamAttr])

-- | LLVM Parameter Attributes.
--   
--   Parameter attributes are used to communicate additional information
--   about the result or parameters of a function
data LlvmParamAttr

-- | This indicates to the code generator that the parameter or return
--   value should be zero-extended to a 32-bit value by the caller (for a
--   parameter) or the callee (for a return value).
ZeroExt :: LlvmParamAttr

-- | This indicates to the code generator that the parameter or return
--   value should be sign-extended to a 32-bit value by the caller (for a
--   parameter) or the callee (for a return value).
SignExt :: LlvmParamAttr

-- | This indicates that this parameter or return value should be treated
--   in a special target-dependent fashion during while emitting code for a
--   function call or return (usually, by putting it in a register as
--   opposed to memory).
InReg :: LlvmParamAttr

-- | This indicates that the pointer parameter should really be passed by
--   value to the function.
ByVal :: LlvmParamAttr

-- | This indicates that the pointer parameter specifies the address of a
--   structure that is the return value of the function in the source
--   program.
SRet :: LlvmParamAttr

-- | This indicates that the pointer does not alias any global or any other
--   parameter.
NoAlias :: LlvmParamAttr

-- | This indicates that the callee does not make any copies of the pointer
--   that outlive the callee itself
NoCapture :: LlvmParamAttr

-- | This indicates that the pointer parameter can be excised using the
--   trampoline intrinsics.
Nest :: LlvmParamAttr
ppLlvmParamAttr :: IsLine doc => LlvmParamAttr -> doc

-- | Llvm Function Attributes.
--   
--   Function attributes are set to communicate additional information
--   about a function. Function attributes are considered to be part of the
--   function, not of the function type, so functions with different
--   parameter attributes can have the same function type. Functions can
--   have multiple attributes.
--   
--   Descriptions taken from
--   <a>http://llvm.org/docs/LangRef.html#fnattrs</a>
data LlvmFuncAttr

-- | This attribute indicates that the inliner should attempt to inline
--   this function into callers whenever possible, ignoring any active
--   inlining size threshold for this caller.
AlwaysInline :: LlvmFuncAttr

-- | This attribute indicates that the source code contained a hint that
--   inlining this function is desirable (such as the "inline" keyword in
--   C/C++). It is just a hint; it imposes no requirements on the inliner.
InlineHint :: LlvmFuncAttr

-- | This attribute indicates that the inliner should never inline this
--   function in any situation. This attribute may not be used together
--   with the alwaysinline attribute.
NoInline :: LlvmFuncAttr

-- | This attribute suggests that optimization passes and code generator
--   passes make choices that keep the code size of this function low, and
--   otherwise do optimizations specifically to reduce code size.
OptSize :: LlvmFuncAttr

-- | This function attribute indicates that the function never returns
--   normally. This produces undefined behavior at runtime if the function
--   ever does dynamically return.
NoReturn :: LlvmFuncAttr

-- | This function attribute indicates that the function never returns with
--   an unwind or exceptional control flow. If the function does unwind,
--   its runtime behavior is undefined.
NoUnwind :: LlvmFuncAttr

-- | This attribute indicates that the function computes its result (or
--   decides to unwind an exception) based strictly on its arguments,
--   without dereferencing any pointer arguments or otherwise accessing any
--   mutable state (e.g. memory, control registers, etc) visible to caller
--   functions. It does not write through any pointer arguments (including
--   byval arguments) and never changes any state visible to callers. This
--   means that it cannot unwind exceptions by calling the C++ exception
--   throwing methods, but could use the unwind instruction.
ReadNone :: LlvmFuncAttr

-- | This attribute indicates that the function does not write through any
--   pointer arguments (including byval arguments) or otherwise modify any
--   state (e.g. memory, control registers, etc) visible to caller
--   functions. It may dereference pointer arguments and read state that
--   may be set in the caller. A readonly function always returns the same
--   value (or unwinds an exception identically) when called with the same
--   set of arguments and global state. It cannot unwind an exception by
--   calling the C++ exception throwing methods, but may use the unwind
--   instruction.
ReadOnly :: LlvmFuncAttr

-- | This attribute indicates that the function should emit a stack
--   smashing protector. It is in the form of a "canary"—a random value
--   placed on the stack before the local variables that's checked upon
--   return from the function to see if it has been overwritten. A
--   heuristic is used to determine if a function needs stack protectors or
--   not.
--   
--   If a function that has an ssp attribute is inlined into a function
--   that doesn't have an ssp attribute, then the resulting function will
--   have an ssp attribute.
Ssp :: LlvmFuncAttr

-- | This attribute indicates that the function should always emit a stack
--   smashing protector. This overrides the ssp function attribute.
--   
--   If a function that has an sspreq attribute is inlined into a function
--   that doesn't have an sspreq attribute or which has an ssp attribute,
--   then the resulting function will have an sspreq attribute.
SspReq :: LlvmFuncAttr

-- | This attribute indicates that the code generator should not use a red
--   zone, even if the target-specific ABI normally permits it.
NoRedZone :: LlvmFuncAttr

-- | This attributes disables implicit floating point instructions.
NoImplicitFloat :: LlvmFuncAttr

-- | This attribute disables prologue / epilogue emission for the function.
--   This can have very system-specific consequences.
Naked :: LlvmFuncAttr
ppLlvmFuncAttr :: IsLine doc => LlvmFuncAttr -> doc

-- | Different types to call a function.
data LlvmCallType

-- | Normal call, allocate a new stack frame.
StdCall :: LlvmCallType

-- | Tail call, perform the call in the current stack frame.
TailCall :: LlvmCallType

-- | Different calling conventions a function can use.
data LlvmCallConvention

-- | The C calling convention. This calling convention (the default if no
--   other calling convention is specified) matches the target C calling
--   conventions. This calling convention supports varargs function calls
--   and tolerates some mismatch in the declared prototype and implemented
--   declaration of the function (as does normal C).
CC_Ccc :: LlvmCallConvention

-- | This calling convention attempts to make calls as fast as possible
--   (e.g. by passing things in registers). This calling convention allows
--   the target to use whatever tricks it wants to produce fast code for
--   the target, without having to conform to an externally specified ABI
--   (Application Binary Interface). Implementations of this convention
--   should allow arbitrary tail call optimization to be supported. This
--   calling convention does not support varargs and requires the prototype
--   of al callees to exactly match the prototype of the function
--   definition.
CC_Fastcc :: LlvmCallConvention

-- | This calling convention attempts to make code in the caller as
--   efficient as possible under the assumption that the call is not
--   commonly executed. As such, these calls often preserve all registers
--   so that the call does not break any live ranges in the caller side.
--   This calling convention does not support varargs and requires the
--   prototype of all callees to exactly match the prototype of the
--   function definition.
CC_Coldcc :: LlvmCallConvention

-- | The GHC-specific <tt>registerised</tt> calling convention.
CC_Ghc :: LlvmCallConvention

-- | Any calling convention may be specified by number, allowing
--   target-specific calling conventions to be used. Target specific
--   calling conventions start at 64.
CC_Ncc :: Int -> LlvmCallConvention

-- | X86 Specific <a>StdCall</a> convention. LLVM includes a specific alias
--   for it rather than just using CC_Ncc.
CC_X86_Stdcc :: LlvmCallConvention
ppLlvmCallConvention :: IsLine doc => LlvmCallConvention -> doc

-- | Functions can have a fixed amount of parameters, or a variable amount.
data LlvmParameterListType
FixedArgs :: LlvmParameterListType
VarArgs :: LlvmParameterListType

-- | Linkage type of a symbol.
--   
--   The description of the constructors is copied from the Llvm Assembly
--   Language Reference Manual
--   <a>http://www.llvm.org/docs/LangRef.html#linkage</a>, because they
--   correspond to the Llvm linkage types.
data LlvmLinkageType

-- | Global values with internal linkage are only directly accessible by
--   objects in the current module. In particular, linking code into a
--   module with an internal global value may cause the internal to be
--   renamed as necessary to avoid collisions. Because the symbol is
--   internal to the module, all references can be updated. This
--   corresponds to the notion of the <tt>static</tt> keyword in C.
Internal :: LlvmLinkageType

-- | Globals with <tt>linkonce</tt> linkage are merged with other globals
--   of the same name when linkage occurs. This is typically used to
--   implement inline functions, templates, or other code which must be
--   generated in each translation unit that uses it. Unreferenced linkonce
--   globals are allowed to be discarded.
LinkOnce :: LlvmLinkageType

-- | <tt>weak</tt> linkage is exactly the same as linkonce linkage, except
--   that unreferenced weak globals may not be discarded. This is used for
--   globals that may be emitted in multiple translation units, but that
--   are not guaranteed to be emitted into every translation unit that uses
--   them. One example of this are common globals in C, such as <tt>int
--   X;</tt> at global scope.
Weak :: LlvmLinkageType

-- | <tt>appending</tt> linkage may only be applied to global variables of
--   pointer to array type. When two global variables with appending
--   linkage are linked together, the two global arrays are appended
--   together. This is the Llvm, typesafe, equivalent of having the system
--   linker append together <tt>sections</tt> with identical names when .o
--   files are linked.
Appending :: LlvmLinkageType

-- | The semantics of this linkage follow the ELF model: the symbol is weak
--   until linked, if not linked, the symbol becomes null instead of being
--   an undefined reference.
ExternWeak :: LlvmLinkageType

-- | The symbol participates in linkage and can be used to resolve external
--   symbol references.
ExternallyVisible :: LlvmLinkageType

-- | Alias for <a>ExternallyVisible</a> but with explicit textual form in
--   LLVM assembly.
External :: LlvmLinkageType

-- | Symbol is private to the module and should not appear in the symbol
--   table
Private :: LlvmLinkageType
ppLlvmLinkageType :: IsLine doc => LlvmLinkageType -> doc

-- | Llvm binary operators machine operations.
data LlvmMachOp

-- | add two integer, floating point or vector values.
LM_MO_Add :: LlvmMachOp

-- | subtract two ...
LM_MO_Sub :: LlvmMachOp

-- | multiply ..
LM_MO_Mul :: LlvmMachOp

-- | unsigned integer or vector division.
LM_MO_UDiv :: LlvmMachOp

-- | signed integer ..
LM_MO_SDiv :: LlvmMachOp

-- | unsigned integer or vector remainder (mod)
LM_MO_URem :: LlvmMachOp

-- | signed ...
LM_MO_SRem :: LlvmMachOp

-- | add two floating point or vector values.
LM_MO_FAdd :: LlvmMachOp

-- | subtract two ...
LM_MO_FSub :: LlvmMachOp

-- | multiply ...
LM_MO_FMul :: LlvmMachOp

-- | divide ...
LM_MO_FDiv :: LlvmMachOp

-- | remainder ...
LM_MO_FRem :: LlvmMachOp

-- | Left shift
LM_MO_Shl :: LlvmMachOp

-- | Logical shift right Shift right, filling with zero
LM_MO_LShr :: LlvmMachOp

-- | Arithmetic shift right The most significant bits of the result will be
--   equal to the sign bit of the left operand.
LM_MO_AShr :: LlvmMachOp

-- | AND bitwise logical operation.
LM_MO_And :: LlvmMachOp

-- | OR bitwise logical operation.
LM_MO_Or :: LlvmMachOp

-- | XOR bitwise logical operation.
LM_MO_Xor :: LlvmMachOp
ppLlvmMachOp :: IsLine doc => LlvmMachOp -> doc

-- | Llvm compare operations.
data LlvmCmpOp

-- | Equal (Signed and Unsigned)
LM_CMP_Eq :: LlvmCmpOp

-- | Not equal (Signed and Unsigned)
LM_CMP_Ne :: LlvmCmpOp

-- | Unsigned greater than
LM_CMP_Ugt :: LlvmCmpOp

-- | Unsigned greater than or equal
LM_CMP_Uge :: LlvmCmpOp

-- | Unsigned less than
LM_CMP_Ult :: LlvmCmpOp

-- | Unsigned less than or equal
LM_CMP_Ule :: LlvmCmpOp

-- | Signed greater than
LM_CMP_Sgt :: LlvmCmpOp

-- | Signed greater than or equal
LM_CMP_Sge :: LlvmCmpOp

-- | Signed less than
LM_CMP_Slt :: LlvmCmpOp

-- | Signed less than or equal
LM_CMP_Sle :: LlvmCmpOp

-- | Float equal
LM_CMP_Feq :: LlvmCmpOp

-- | Float not equal
LM_CMP_Fne :: LlvmCmpOp

-- | Float greater than
LM_CMP_Fgt :: LlvmCmpOp

-- | Float greater than or equal
LM_CMP_Fge :: LlvmCmpOp

-- | Float less than
LM_CMP_Flt :: LlvmCmpOp

-- | Float less than or equal
LM_CMP_Fle :: LlvmCmpOp
ppLlvmCmpOp :: IsLine doc => LlvmCmpOp -> doc

-- | Llvm cast operations.
data LlvmCastOp

-- | Integer truncate
LM_Trunc :: LlvmCastOp

-- | Integer extend (zero fill)
LM_Zext :: LlvmCastOp

-- | Integer extend (sign fill)
LM_Sext :: LlvmCastOp

-- | Float truncate
LM_Fptrunc :: LlvmCastOp

-- | Float extend
LM_Fpext :: LlvmCastOp

-- | Float to unsigned Integer
LM_Fptoui :: LlvmCastOp

-- | Float to signed Integer
LM_Fptosi :: LlvmCastOp

-- | Unsigned Integer to Float
LM_Uitofp :: LlvmCastOp

-- | Signed Int to Float
LM_Sitofp :: LlvmCastOp

-- | Pointer to Integer
LM_Ptrtoint :: LlvmCastOp

-- | Integer to Pointer
LM_Inttoptr :: LlvmCastOp

-- | Cast between types where no bit manipulation is needed
LM_Bitcast :: LlvmCastOp
ppLlvmCastOp :: IsLine doc => LlvmCastOp -> doc

-- | Convert a Haskell Double to an LLVM hex encoded floating point form.
--   In Llvm float literals can be printed in a big-endian hexadecimal
--   format, regardless of underlying architecture.
--   
--   See Note [LLVM Float Types].
ppDouble :: IsLine doc => Platform -> Double -> doc
narrowFp :: Double -> Float
widenFp :: Float -> Double
ppFloat :: IsLine doc => Platform -> Float -> doc
ppCommaJoin :: IsLine doc => (a -> doc) -> [a] -> doc
ppSpaceJoin :: IsLine doc => (a -> doc) -> [a] -> doc
instance GHC.Classes.Eq GHC.Llvm.Types.LMConst
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmCallConvention
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmCallType
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmCastOp
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmCmpOp
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmFuncAttr
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmFunctionDecl
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmLinkageType
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmLit
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmMachOp
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmParamAttr
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmParameterListType
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmType
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmVar
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmCallConvention
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmCastOp
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmCmpOp
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmFuncAttr
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmLinkageType
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmMachOp
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmParamAttr
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmType
instance GHC.Internal.Show.Show GHC.Llvm.Types.LlvmCallType
instance GHC.Internal.Show.Show GHC.Llvm.Types.LlvmParameterListType

module GHC.Llvm.MetaData

-- | A reference to an un-named metadata node.
newtype MetaId
MetaId :: Int -> MetaId
ppMetaId :: IsLine doc => MetaId -> doc

-- | LLVM metadata expressions
data MetaExpr
MetaStr :: !LMString -> MetaExpr
MetaLit :: !LlvmLit -> MetaExpr
MetaNode :: !MetaId -> MetaExpr
MetaVar :: !LlvmVar -> MetaExpr
MetaStruct :: [MetaExpr] -> MetaExpr

-- | Associates some metadata with a specific label for attaching to an
--   instruction.
data MetaAnnot
MetaAnnot :: LMString -> MetaExpr -> MetaAnnot

-- | Metadata declarations. Metadata can only be declared in global scope.
data MetaDecl

-- | Named metadata. Only used for communicating module information to
--   LLVM. ('!name = !{ [!&lt;n&gt;] }' form).
MetaNamed :: !LMString -> [MetaId] -> MetaDecl

-- | Metadata node declaration. ('!0 = metadata !{ &lt;metadata
--   expression&gt; }' form).
MetaUnnamed :: !MetaId -> !MetaExpr -> MetaDecl
data ModuleFlagBehavior
MFBError :: ModuleFlagBehavior
MFBWarning :: ModuleFlagBehavior
MFBRequire :: ModuleFlagBehavior
MFBOverride :: ModuleFlagBehavior
MFBAppend :: ModuleFlagBehavior
MFBAppendUnique :: ModuleFlagBehavior
MFBMax :: ModuleFlagBehavior
MFBMin :: ModuleFlagBehavior
data ModuleFlag
ModuleFlag :: ModuleFlagBehavior -> LMString -> MetaExpr -> ModuleFlag
[mfBehavior] :: ModuleFlag -> ModuleFlagBehavior
[mfName] :: ModuleFlag -> LMString
[mfValue] :: ModuleFlag -> MetaExpr
moduleFlagToMetaExpr :: ModuleFlag -> MetaExpr
instance GHC.Internal.Enum.Enum GHC.Llvm.MetaData.MetaId
instance GHC.Classes.Eq GHC.Llvm.MetaData.MetaAnnot
instance GHC.Classes.Eq GHC.Llvm.MetaData.MetaExpr
instance GHC.Classes.Eq GHC.Llvm.MetaData.MetaId
instance GHC.Classes.Ord GHC.Llvm.MetaData.MetaId
instance GHC.Utils.Outputable.Outputable GHC.Llvm.MetaData.MetaId


-- | The LLVM abstract syntax.
module GHC.Llvm.Syntax

-- | Block labels
type LlvmBlockId = Unique

-- | A block of LLVM code.
data LlvmBlock
LlvmBlock :: LlvmBlockId -> [LlvmStatement] -> LlvmBlock

-- | The code label for this block
[blockLabel] :: LlvmBlock -> LlvmBlockId

-- | A list of LlvmStatement's representing the code for this block. This
--   list must end with a control flow statement.
[blockStmts] :: LlvmBlock -> [LlvmStatement]
type LlvmBlocks = [LlvmBlock]

-- | An LLVM Module. This is a top level container in LLVM.
data LlvmModule
LlvmModule :: [LMString] -> [LlvmAlias] -> [MetaDecl] -> [LMGlobal] -> LlvmFunctionDecls -> LlvmFunctions -> LlvmModule

-- | Comments to include at the start of the module.
[modComments] :: LlvmModule -> [LMString]

-- | LLVM Alias type definitions.
[modAliases] :: LlvmModule -> [LlvmAlias]

-- | LLVM meta data.
[modMeta] :: LlvmModule -> [MetaDecl]

-- | Global variables to include in the module.
[modGlobals] :: LlvmModule -> [LMGlobal]

-- | LLVM Functions used in this module but defined in other modules.
[modFwdDecls] :: LlvmModule -> LlvmFunctionDecls

-- | LLVM Functions defined in this module.
[modFuncs] :: LlvmModule -> LlvmFunctions

-- | An LLVM Function
data LlvmFunction
LlvmFunction :: LlvmFunctionDecl -> [LMString] -> [LlvmFuncAttr] -> LMSection -> Maybe LlvmStatic -> LlvmBlocks -> LlvmFunction

-- | The signature of this declared function.
[funcDecl] :: LlvmFunction -> LlvmFunctionDecl

-- | The functions arguments
[funcArgs] :: LlvmFunction -> [LMString]

-- | The function attributes.
[funcAttrs] :: LlvmFunction -> [LlvmFuncAttr]

-- | The section to put the function into,
[funcSect] :: LlvmFunction -> LMSection

-- | Prefix data
[funcPrefix] :: LlvmFunction -> Maybe LlvmStatic

-- | The body of the functions.
[funcBody] :: LlvmFunction -> LlvmBlocks
type LlvmFunctions = [LlvmFunction]
type SingleThreaded = Bool

-- | LLVM ordering types for synchronization purposes. (Introduced in LLVM
--   3.0). Please see the LLVM documentation for a better description.
data LlvmSyncOrdering

-- | Some partial order of operations exists.
SyncUnord :: LlvmSyncOrdering

-- | A single total order for operations at a single address exists.
SyncMonotonic :: LlvmSyncOrdering

-- | Acquire synchronization operation.
SyncAcquire :: LlvmSyncOrdering

-- | Release synchronization operation.
SyncRelease :: LlvmSyncOrdering

-- | Acquire + Release synchronization operation.
SyncAcqRel :: LlvmSyncOrdering

-- | Full sequential Consistency operation.
SyncSeqCst :: LlvmSyncOrdering

-- | LLVM atomic operations. Please see the <tt>atomicrmw</tt> instruction
--   in the LLVM documentation for a complete description.
data LlvmAtomicOp
LAO_Xchg :: LlvmAtomicOp
LAO_Add :: LlvmAtomicOp
LAO_Sub :: LlvmAtomicOp
LAO_And :: LlvmAtomicOp
LAO_Nand :: LlvmAtomicOp
LAO_Or :: LlvmAtomicOp
LAO_Xor :: LlvmAtomicOp
LAO_Max :: LlvmAtomicOp
LAO_Min :: LlvmAtomicOp
LAO_Umax :: LlvmAtomicOp
LAO_Umin :: LlvmAtomicOp

-- | Llvm Statements
data LlvmStatement

-- | Assign an expression to a variable: * dest: Variable to assign to *
--   source: Source expression
Assignment :: LlvmVar -> LlvmExpression -> LlvmStatement

-- | Memory fence operation
Fence :: Bool -> LlvmSyncOrdering -> LlvmStatement

-- | Always branch to the target label
Branch :: LlvmVar -> LlvmStatement

-- | Branch to label targetTrue if cond is true otherwise to label
--   targetFalse * cond: condition that will be tested, must be of type i1
--   * targetTrue: label to branch to if cond is true * targetFalse: label
--   to branch to if cond is false
BranchIf :: LlvmVar -> LlvmVar -> LlvmVar -> LlvmStatement

-- | Comment Plain comment.
Comment :: [LMString] -> LlvmStatement

-- | Set a label on this position. * name: Identifier of this label, unique
--   for this module
MkLabel :: LlvmBlockId -> LlvmStatement

-- | Store variable value in pointer ptr. If value is of type t then ptr
--   must be of type t*. * value: Variable/Constant to store. * ptr:
--   Location to store the value in
Store :: LlvmVar -> LlvmVar -> LMAlign -> [MetaAnnot] -> LlvmStatement

-- | Multiway branch * scrutinee: Variable or constant which must be of
--   integer type that is determines which arm is chosen. * def: The
--   default label if there is no match in target. * target: A list of
--   (value,label) where the value is an integer constant and label the
--   corresponding label to jump to if the scrutinee matches the value.
Switch :: LlvmVar -> LlvmVar -> [(LlvmVar, LlvmVar)] -> LlvmStatement

-- | Return a result. * result: The variable or constant to return
Return :: Maybe LlvmVar -> LlvmStatement

-- | An instruction for the optimizer that the code following is not
--   reachable
Unreachable :: LlvmStatement

-- | Raise an expression to a statement (if don't want result or want to
--   use Llvm unnamed values.
Expr :: LlvmExpression -> LlvmStatement

-- | A nop LLVM statement. Useful as its often more efficient to use this
--   then to wrap LLvmStatement in a Just or [].
Nop :: LlvmStatement

-- | Llvm Expressions
data LlvmExpression

-- | Allocate amount * sizeof(tp) bytes on the stack * tp: LlvmType to
--   reserve room for * amount: The nr of tp's which must be allocated
Alloca :: LlvmType -> Int -> LlvmExpression

-- | Perform the machine operator op on the operands left and right * op:
--   operator * left: left operand * right: right operand
LlvmOp :: LlvmMachOp -> LlvmVar -> LlvmVar -> LlvmExpression

-- | Perform a compare operation on the operands left and right * op:
--   operator * left: left operand * right: right operand
Compare :: LlvmCmpOp -> LlvmVar -> LlvmVar -> LlvmExpression

-- | Extract a scalar element from a vector * val: The vector * idx: The
--   index of the scalar within the vector
Extract :: LlvmVar -> LlvmVar -> LlvmExpression

-- | Extract a scalar element from a structure * val: The structure * idx:
--   The index of the scalar within the structure Corresponds to
--   "extractvalue" instruction.
ExtractV :: LlvmVar -> Int -> LlvmExpression

-- | Insert a scalar element into a vector * val: The source vector * elt:
--   The scalar to insert * index: The index at which to insert the scalar
Insert :: LlvmVar -> LlvmVar -> LlvmVar -> LlvmExpression

-- | Shuffle two vectors into a destination vector using given indices
Shuffle :: LlvmVar -> LlvmVar -> [Int] -> LlvmExpression

-- | Allocate amount * sizeof(tp) bytes on the heap * tp: LlvmType to
--   reserve room for * amount: The nr of tp's which must be allocated
Malloc :: LlvmType -> Int -> LlvmExpression

-- | Load the value at location ptr
Load :: LlvmVar -> LMAlign -> LlvmExpression

-- | Atomic load of the value at location ptr
ALoad :: LlvmSyncOrdering -> SingleThreaded -> LlvmVar -> LlvmExpression

-- | Navigate in a structure, selecting elements * inbound: Is the pointer
--   inbounds? (computed pointer doesn't overflow) * ptr: Location of the
--   structure * indexes: A list of indexes to select the correct value.
GetElemPtr :: Bool -> LlvmVar -> [LlvmVar] -> LlvmExpression

-- | Cast the variable from to the to type. This is an abstraction of three
--   cast operators in Llvm, inttoptr, ptrtoint and bitcast. * cast: Cast
--   type * from: Variable to cast * to: type to cast to
Cast :: LlvmCastOp -> LlvmVar -> LlvmType -> LlvmExpression

-- | Atomic read-modify-write operation * op: Atomic operation * addr:
--   Address to modify * operand: Operand to operation * ordering: Ordering
--   requirement
AtomicRMW :: LlvmAtomicOp -> LlvmVar -> LlvmVar -> LlvmSyncOrdering -> LlvmExpression

-- | Compare-and-exchange operation * addr: Address to modify * old:
--   Expected value * new: New value * suc_ord: Ordering required in
--   success case * fail_ord: Ordering required in failure case, can be no
--   stronger than suc_ord
--   
--   Result is an <tt>i1</tt>, true if store was successful.
CmpXChg :: LlvmVar -> LlvmVar -> LlvmVar -> LlvmSyncOrdering -> LlvmSyncOrdering -> LlvmExpression

-- | Call a function. The result is the value of the expression. *
--   tailJumps: CallType to signal if the function should be tail called *
--   fnptrval: An LLVM value containing a pointer to a function to be
--   invoked. Can be indirect. Should be LMFunction type. * args: Concrete
--   arguments for the parameters * attrs: A list of function attributes
--   for the call. Only NoReturn, NoUnwind, ReadOnly and ReadNone are valid
--   here.
Call :: LlvmCallType -> LlvmVar -> [LlvmVar] -> [LlvmFuncAttr] -> LlvmExpression

-- | Call a function as above but potentially taking metadata as arguments.
--   * tailJumps: CallType to signal if the function should be tail called
--   * fnptrval: An LLVM value containing a pointer to a function to be
--   invoked. Can be indirect. Should be LMFunction type. * args: Arguments
--   that may include metadata. * attrs: A list of function attributes for
--   the call. Only NoReturn, NoUnwind, ReadOnly and ReadNone are valid
--   here.
CallM :: LlvmCallType -> LlvmVar -> [MetaExpr] -> [LlvmFuncAttr] -> LlvmExpression

-- | Merge variables from different basic blocks which are predecessors of
--   this basic block in a new variable of type tp. * tp: type of the
--   merged variable, must match the types of the predecessor variables. *
--   predecessors: A list of variables and the basic block that they
--   originate from.
Phi :: LlvmType -> [(LlvmVar, LlvmVar)] -> LlvmExpression

-- | Inline assembly expression. Syntax is very similar to the style used
--   by GCC. * assembly: Actual inline assembly code. * constraints:
--   Operand constraints. * return ty: Return type of function. * vars: Any
--   variables involved in the assembly code. * sideeffect: Does the
--   expression have side effects not visible from the constraints list. *
--   alignstack: Should the stack be conservatively aligned before this
--   expression is executed.
Asm :: LMString -> LMString -> LlvmType -> [LlvmVar] -> Bool -> Bool -> LlvmExpression

-- | A LLVM expression with metadata attached to it.
MExpr :: [MetaAnnot] -> LlvmExpression -> LlvmExpression
instance GHC.Classes.Eq GHC.Llvm.Syntax.LlvmAtomicOp
instance GHC.Classes.Eq GHC.Llvm.Syntax.LlvmExpression
instance GHC.Classes.Eq GHC.Llvm.Syntax.LlvmStatement
instance GHC.Classes.Eq GHC.Llvm.Syntax.LlvmSyncOrdering
instance GHC.Internal.Show.Show GHC.Llvm.Syntax.LlvmAtomicOp
instance GHC.Internal.Show.Show GHC.Llvm.Syntax.LlvmSyncOrdering


-- | Pretty print LLVM IR Code.
module GHC.Llvm.Ppr

-- | Print out a whole LLVM module.
ppLlvmModule :: IsDoc doc => LlvmCgConfig -> LlvmModule -> doc

-- | Print out a multi-line comment, can be inside a function or on its own
ppLlvmComments :: IsDoc doc => [LMString] -> doc

-- | Print out a comment, can be inside a function or on its own
ppLlvmComment :: IsLine doc => LMString -> doc

-- | Print out a list of global mutable variable definitions
ppLlvmGlobals :: IsDoc doc => LlvmCgConfig -> [LMGlobal] -> doc

-- | Print out a global mutable variable definition
ppLlvmGlobal :: IsLine doc => LlvmCgConfig -> LMGlobal -> doc

-- | Print out a list of LLVM type aliases.
ppLlvmAliases :: IsDoc doc => [LlvmAlias] -> doc

-- | Print out an LLVM type alias.
ppLlvmAlias :: IsLine doc => LlvmAlias -> doc

-- | Print out a list of LLVM metadata.
ppLlvmMetas :: IsDoc doc => LlvmCgConfig -> [MetaDecl] -> doc

-- | Print out an LLVM metadata definition.
ppLlvmMeta :: IsLine doc => LlvmCgConfig -> MetaDecl -> doc

-- | Print out a list of function declaration.
ppLlvmFunctionDecls :: IsDoc doc => LlvmFunctionDecls -> doc

-- | Print out a function declaration. Declarations define the function
--   type but don't define the actual body of the function.
ppLlvmFunctionDecl :: IsDoc doc => LlvmFunctionDecl -> doc

-- | Print out a list of function definitions.
ppLlvmFunctions :: IsDoc doc => LlvmCgConfig -> LlvmFunctions -> doc

-- | Print out a function definition.
ppLlvmFunction :: IsDoc doc => LlvmCgConfig -> LlvmFunction -> doc
ppVar :: IsLine doc => LlvmCgConfig -> LlvmVar -> doc

-- | Print a literal value. No type.
ppLit :: IsLine doc => LlvmCgConfig -> LlvmLit -> doc
ppTypeLit :: IsLine doc => LlvmCgConfig -> LlvmLit -> doc

-- | Return the variable name or value of the <a>LlvmVar</a> in Llvm IR
--   textual representation (e.g. <tt>@x</tt>, <tt>%y</tt> or <tt>42</tt>).
ppName :: IsLine doc => LlvmCgConfig -> LlvmVar -> doc

-- | Return the variable name or value of the <a>LlvmVar</a> in a plain
--   textual representation (e.g. <tt>x</tt>, <tt>y</tt> or <tt>42</tt>).
ppPlainName :: IsLine doc => LlvmCgConfig -> LlvmVar -> doc


-- | This module supplies bindings to generate Llvm IR from Haskell
--   (<a>http://www.llvm.org/docs/LangRef.html</a>).
--   
--   Note: this module is developed in a demand driven way. It is no
--   complete LLVM binding library in Haskell, but enough to generate code
--   for GHC.
--   
--   This code is derived from code taken from the Essential Haskell
--   Compiler (EHC) project.
module GHC.Llvm

-- | An LLVM Module. This is a top level container in LLVM.
data LlvmModule
LlvmModule :: [LMString] -> [LlvmAlias] -> [MetaDecl] -> [LMGlobal] -> LlvmFunctionDecls -> LlvmFunctions -> LlvmModule

-- | Comments to include at the start of the module.
[modComments] :: LlvmModule -> [LMString]

-- | LLVM Alias type definitions.
[modAliases] :: LlvmModule -> [LlvmAlias]

-- | LLVM meta data.
[modMeta] :: LlvmModule -> [MetaDecl]

-- | Global variables to include in the module.
[modGlobals] :: LlvmModule -> [LMGlobal]

-- | LLVM Functions used in this module but defined in other modules.
[modFwdDecls] :: LlvmModule -> LlvmFunctionDecls

-- | LLVM Functions defined in this module.
[modFuncs] :: LlvmModule -> LlvmFunctions

-- | An LLVM Function
data LlvmFunction
LlvmFunction :: LlvmFunctionDecl -> [LMString] -> [LlvmFuncAttr] -> LMSection -> Maybe LlvmStatic -> LlvmBlocks -> LlvmFunction

-- | The signature of this declared function.
[funcDecl] :: LlvmFunction -> LlvmFunctionDecl

-- | The functions arguments
[funcArgs] :: LlvmFunction -> [LMString]

-- | The function attributes.
[funcAttrs] :: LlvmFunction -> [LlvmFuncAttr]

-- | The section to put the function into,
[funcSect] :: LlvmFunction -> LMSection

-- | Prefix data
[funcPrefix] :: LlvmFunction -> Maybe LlvmStatic

-- | The body of the functions.
[funcBody] :: LlvmFunction -> LlvmBlocks

-- | An LLVM Function
data LlvmFunctionDecl
LlvmFunctionDecl :: LMString -> LlvmLinkageType -> LlvmCallConvention -> LlvmType -> LlvmParameterListType -> [LlvmParameter] -> LMAlign -> LlvmFunctionDecl

-- | Unique identifier of the function
[decName] :: LlvmFunctionDecl -> LMString

-- | LinkageType of the function
[funcLinkage] :: LlvmFunctionDecl -> LlvmLinkageType

-- | The calling convention of the function
[funcCc] :: LlvmFunctionDecl -> LlvmCallConvention

-- | Type of the returned value
[decReturnType] :: LlvmFunctionDecl -> LlvmType

-- | Indicates if this function uses varargs
[decVarargs] :: LlvmFunctionDecl -> LlvmParameterListType

-- | Parameter types and attributes
[decParams] :: LlvmFunctionDecl -> [LlvmParameter]

-- | Function align value, must be power of 2
[funcAlign] :: LlvmFunctionDecl -> LMAlign
type LlvmFunctions = [LlvmFunction]
type LlvmFunctionDecls = [LlvmFunctionDecl]

-- | Llvm Statements
data LlvmStatement

-- | Assign an expression to a variable: * dest: Variable to assign to *
--   source: Source expression
Assignment :: LlvmVar -> LlvmExpression -> LlvmStatement

-- | Memory fence operation
Fence :: Bool -> LlvmSyncOrdering -> LlvmStatement

-- | Always branch to the target label
Branch :: LlvmVar -> LlvmStatement

-- | Branch to label targetTrue if cond is true otherwise to label
--   targetFalse * cond: condition that will be tested, must be of type i1
--   * targetTrue: label to branch to if cond is true * targetFalse: label
--   to branch to if cond is false
BranchIf :: LlvmVar -> LlvmVar -> LlvmVar -> LlvmStatement

-- | Comment Plain comment.
Comment :: [LMString] -> LlvmStatement

-- | Set a label on this position. * name: Identifier of this label, unique
--   for this module
MkLabel :: LlvmBlockId -> LlvmStatement

-- | Store variable value in pointer ptr. If value is of type t then ptr
--   must be of type t*. * value: Variable/Constant to store. * ptr:
--   Location to store the value in
Store :: LlvmVar -> LlvmVar -> LMAlign -> [MetaAnnot] -> LlvmStatement

-- | Multiway branch * scrutinee: Variable or constant which must be of
--   integer type that is determines which arm is chosen. * def: The
--   default label if there is no match in target. * target: A list of
--   (value,label) where the value is an integer constant and label the
--   corresponding label to jump to if the scrutinee matches the value.
Switch :: LlvmVar -> LlvmVar -> [(LlvmVar, LlvmVar)] -> LlvmStatement

-- | Return a result. * result: The variable or constant to return
Return :: Maybe LlvmVar -> LlvmStatement

-- | An instruction for the optimizer that the code following is not
--   reachable
Unreachable :: LlvmStatement

-- | Raise an expression to a statement (if don't want result or want to
--   use Llvm unnamed values.
Expr :: LlvmExpression -> LlvmStatement

-- | A nop LLVM statement. Useful as its often more efficient to use this
--   then to wrap LLvmStatement in a Just or [].
Nop :: LlvmStatement

-- | Llvm Expressions
data LlvmExpression

-- | Allocate amount * sizeof(tp) bytes on the stack * tp: LlvmType to
--   reserve room for * amount: The nr of tp's which must be allocated
Alloca :: LlvmType -> Int -> LlvmExpression

-- | Perform the machine operator op on the operands left and right * op:
--   operator * left: left operand * right: right operand
LlvmOp :: LlvmMachOp -> LlvmVar -> LlvmVar -> LlvmExpression

-- | Perform a compare operation on the operands left and right * op:
--   operator * left: left operand * right: right operand
Compare :: LlvmCmpOp -> LlvmVar -> LlvmVar -> LlvmExpression

-- | Extract a scalar element from a vector * val: The vector * idx: The
--   index of the scalar within the vector
Extract :: LlvmVar -> LlvmVar -> LlvmExpression

-- | Extract a scalar element from a structure * val: The structure * idx:
--   The index of the scalar within the structure Corresponds to
--   "extractvalue" instruction.
ExtractV :: LlvmVar -> Int -> LlvmExpression

-- | Insert a scalar element into a vector * val: The source vector * elt:
--   The scalar to insert * index: The index at which to insert the scalar
Insert :: LlvmVar -> LlvmVar -> LlvmVar -> LlvmExpression

-- | Shuffle two vectors into a destination vector using given indices
Shuffle :: LlvmVar -> LlvmVar -> [Int] -> LlvmExpression

-- | Allocate amount * sizeof(tp) bytes on the heap * tp: LlvmType to
--   reserve room for * amount: The nr of tp's which must be allocated
Malloc :: LlvmType -> Int -> LlvmExpression

-- | Load the value at location ptr
Load :: LlvmVar -> LMAlign -> LlvmExpression

-- | Atomic load of the value at location ptr
ALoad :: LlvmSyncOrdering -> SingleThreaded -> LlvmVar -> LlvmExpression

-- | Navigate in a structure, selecting elements * inbound: Is the pointer
--   inbounds? (computed pointer doesn't overflow) * ptr: Location of the
--   structure * indexes: A list of indexes to select the correct value.
GetElemPtr :: Bool -> LlvmVar -> [LlvmVar] -> LlvmExpression

-- | Cast the variable from to the to type. This is an abstraction of three
--   cast operators in Llvm, inttoptr, ptrtoint and bitcast. * cast: Cast
--   type * from: Variable to cast * to: type to cast to
Cast :: LlvmCastOp -> LlvmVar -> LlvmType -> LlvmExpression

-- | Atomic read-modify-write operation * op: Atomic operation * addr:
--   Address to modify * operand: Operand to operation * ordering: Ordering
--   requirement
AtomicRMW :: LlvmAtomicOp -> LlvmVar -> LlvmVar -> LlvmSyncOrdering -> LlvmExpression

-- | Compare-and-exchange operation * addr: Address to modify * old:
--   Expected value * new: New value * suc_ord: Ordering required in
--   success case * fail_ord: Ordering required in failure case, can be no
--   stronger than suc_ord
--   
--   Result is an <tt>i1</tt>, true if store was successful.
CmpXChg :: LlvmVar -> LlvmVar -> LlvmVar -> LlvmSyncOrdering -> LlvmSyncOrdering -> LlvmExpression

-- | Call a function. The result is the value of the expression. *
--   tailJumps: CallType to signal if the function should be tail called *
--   fnptrval: An LLVM value containing a pointer to a function to be
--   invoked. Can be indirect. Should be LMFunction type. * args: Concrete
--   arguments for the parameters * attrs: A list of function attributes
--   for the call. Only NoReturn, NoUnwind, ReadOnly and ReadNone are valid
--   here.
Call :: LlvmCallType -> LlvmVar -> [LlvmVar] -> [LlvmFuncAttr] -> LlvmExpression

-- | Call a function as above but potentially taking metadata as arguments.
--   * tailJumps: CallType to signal if the function should be tail called
--   * fnptrval: An LLVM value containing a pointer to a function to be
--   invoked. Can be indirect. Should be LMFunction type. * args: Arguments
--   that may include metadata. * attrs: A list of function attributes for
--   the call. Only NoReturn, NoUnwind, ReadOnly and ReadNone are valid
--   here.
CallM :: LlvmCallType -> LlvmVar -> [MetaExpr] -> [LlvmFuncAttr] -> LlvmExpression

-- | Merge variables from different basic blocks which are predecessors of
--   this basic block in a new variable of type tp. * tp: type of the
--   merged variable, must match the types of the predecessor variables. *
--   predecessors: A list of variables and the basic block that they
--   originate from.
Phi :: LlvmType -> [(LlvmVar, LlvmVar)] -> LlvmExpression

-- | Inline assembly expression. Syntax is very similar to the style used
--   by GCC. * assembly: Actual inline assembly code. * constraints:
--   Operand constraints. * return ty: Return type of function. * vars: Any
--   variables involved in the assembly code. * sideeffect: Does the
--   expression have side effects not visible from the constraints list. *
--   alignstack: Should the stack be conservatively aligned before this
--   expression is executed.
Asm :: LMString -> LMString -> LlvmType -> [LlvmVar] -> Bool -> Bool -> LlvmExpression

-- | A LLVM expression with metadata attached to it.
MExpr :: [MetaAnnot] -> LlvmExpression -> LlvmExpression
type LlvmBlocks = [LlvmBlock]

-- | A block of LLVM code.
data LlvmBlock
LlvmBlock :: LlvmBlockId -> [LlvmStatement] -> LlvmBlock

-- | The code label for this block
[blockLabel] :: LlvmBlock -> LlvmBlockId

-- | A list of LlvmStatement's representing the code for this block. This
--   list must end with a control flow statement.
[blockStmts] :: LlvmBlock -> [LlvmStatement]

-- | Block labels
type LlvmBlockId = Unique

-- | LLVM Parameter Attributes.
--   
--   Parameter attributes are used to communicate additional information
--   about the result or parameters of a function
data LlvmParamAttr

-- | This indicates to the code generator that the parameter or return
--   value should be zero-extended to a 32-bit value by the caller (for a
--   parameter) or the callee (for a return value).
ZeroExt :: LlvmParamAttr

-- | This indicates to the code generator that the parameter or return
--   value should be sign-extended to a 32-bit value by the caller (for a
--   parameter) or the callee (for a return value).
SignExt :: LlvmParamAttr

-- | This indicates that this parameter or return value should be treated
--   in a special target-dependent fashion during while emitting code for a
--   function call or return (usually, by putting it in a register as
--   opposed to memory).
InReg :: LlvmParamAttr

-- | This indicates that the pointer parameter should really be passed by
--   value to the function.
ByVal :: LlvmParamAttr

-- | This indicates that the pointer parameter specifies the address of a
--   structure that is the return value of the function in the source
--   program.
SRet :: LlvmParamAttr

-- | This indicates that the pointer does not alias any global or any other
--   parameter.
NoAlias :: LlvmParamAttr

-- | This indicates that the callee does not make any copies of the pointer
--   that outlive the callee itself
NoCapture :: LlvmParamAttr

-- | This indicates that the pointer parameter can be excised using the
--   trampoline intrinsics.
Nest :: LlvmParamAttr
type LlvmParameter = (LlvmType, [LlvmParamAttr])

-- | LLVM atomic operations. Please see the <tt>atomicrmw</tt> instruction
--   in the LLVM documentation for a complete description.
data LlvmAtomicOp
LAO_Xchg :: LlvmAtomicOp
LAO_Add :: LlvmAtomicOp
LAO_Sub :: LlvmAtomicOp
LAO_And :: LlvmAtomicOp
LAO_Nand :: LlvmAtomicOp
LAO_Or :: LlvmAtomicOp
LAO_Xor :: LlvmAtomicOp
LAO_Max :: LlvmAtomicOp
LAO_Min :: LlvmAtomicOp
LAO_Umax :: LlvmAtomicOp
LAO_Umin :: LlvmAtomicOp

-- | LLVM ordering types for synchronization purposes. (Introduced in LLVM
--   3.0). Please see the LLVM documentation for a better description.
data LlvmSyncOrdering

-- | Some partial order of operations exists.
SyncUnord :: LlvmSyncOrdering

-- | A single total order for operations at a single address exists.
SyncMonotonic :: LlvmSyncOrdering

-- | Acquire synchronization operation.
SyncAcquire :: LlvmSyncOrdering

-- | Release synchronization operation.
SyncRelease :: LlvmSyncOrdering

-- | Acquire + Release synchronization operation.
SyncAcqRel :: LlvmSyncOrdering

-- | Full sequential Consistency operation.
SyncSeqCst :: LlvmSyncOrdering

-- | Different calling conventions a function can use.
data LlvmCallConvention

-- | The C calling convention. This calling convention (the default if no
--   other calling convention is specified) matches the target C calling
--   conventions. This calling convention supports varargs function calls
--   and tolerates some mismatch in the declared prototype and implemented
--   declaration of the function (as does normal C).
CC_Ccc :: LlvmCallConvention

-- | This calling convention attempts to make calls as fast as possible
--   (e.g. by passing things in registers). This calling convention allows
--   the target to use whatever tricks it wants to produce fast code for
--   the target, without having to conform to an externally specified ABI
--   (Application Binary Interface). Implementations of this convention
--   should allow arbitrary tail call optimization to be supported. This
--   calling convention does not support varargs and requires the prototype
--   of al callees to exactly match the prototype of the function
--   definition.
CC_Fastcc :: LlvmCallConvention

-- | This calling convention attempts to make code in the caller as
--   efficient as possible under the assumption that the call is not
--   commonly executed. As such, these calls often preserve all registers
--   so that the call does not break any live ranges in the caller side.
--   This calling convention does not support varargs and requires the
--   prototype of all callees to exactly match the prototype of the
--   function definition.
CC_Coldcc :: LlvmCallConvention

-- | The GHC-specific <tt>registerised</tt> calling convention.
CC_Ghc :: LlvmCallConvention

-- | Any calling convention may be specified by number, allowing
--   target-specific calling conventions to be used. Target specific
--   calling conventions start at 64.
CC_Ncc :: Int -> LlvmCallConvention

-- | X86 Specific <a>StdCall</a> convention. LLVM includes a specific alias
--   for it rather than just using CC_Ncc.
CC_X86_Stdcc :: LlvmCallConvention

-- | Different types to call a function.
data LlvmCallType

-- | Normal call, allocate a new stack frame.
StdCall :: LlvmCallType

-- | Tail call, perform the call in the current stack frame.
TailCall :: LlvmCallType

-- | Functions can have a fixed amount of parameters, or a variable amount.
data LlvmParameterListType
FixedArgs :: LlvmParameterListType
VarArgs :: LlvmParameterListType

-- | Linkage type of a symbol.
--   
--   The description of the constructors is copied from the Llvm Assembly
--   Language Reference Manual
--   <a>http://www.llvm.org/docs/LangRef.html#linkage</a>, because they
--   correspond to the Llvm linkage types.
data LlvmLinkageType

-- | Global values with internal linkage are only directly accessible by
--   objects in the current module. In particular, linking code into a
--   module with an internal global value may cause the internal to be
--   renamed as necessary to avoid collisions. Because the symbol is
--   internal to the module, all references can be updated. This
--   corresponds to the notion of the <tt>static</tt> keyword in C.
Internal :: LlvmLinkageType

-- | Globals with <tt>linkonce</tt> linkage are merged with other globals
--   of the same name when linkage occurs. This is typically used to
--   implement inline functions, templates, or other code which must be
--   generated in each translation unit that uses it. Unreferenced linkonce
--   globals are allowed to be discarded.
LinkOnce :: LlvmLinkageType

-- | <tt>weak</tt> linkage is exactly the same as linkonce linkage, except
--   that unreferenced weak globals may not be discarded. This is used for
--   globals that may be emitted in multiple translation units, but that
--   are not guaranteed to be emitted into every translation unit that uses
--   them. One example of this are common globals in C, such as <tt>int
--   X;</tt> at global scope.
Weak :: LlvmLinkageType

-- | <tt>appending</tt> linkage may only be applied to global variables of
--   pointer to array type. When two global variables with appending
--   linkage are linked together, the two global arrays are appended
--   together. This is the Llvm, typesafe, equivalent of having the system
--   linker append together <tt>sections</tt> with identical names when .o
--   files are linked.
Appending :: LlvmLinkageType

-- | The semantics of this linkage follow the ELF model: the symbol is weak
--   until linked, if not linked, the symbol becomes null instead of being
--   an undefined reference.
ExternWeak :: LlvmLinkageType

-- | The symbol participates in linkage and can be used to resolve external
--   symbol references.
ExternallyVisible :: LlvmLinkageType

-- | Alias for <a>ExternallyVisible</a> but with explicit textual form in
--   LLVM assembly.
External :: LlvmLinkageType

-- | Symbol is private to the module and should not appear in the symbol
--   table
Private :: LlvmLinkageType

-- | Llvm Function Attributes.
--   
--   Function attributes are set to communicate additional information
--   about a function. Function attributes are considered to be part of the
--   function, not of the function type, so functions with different
--   parameter attributes can have the same function type. Functions can
--   have multiple attributes.
--   
--   Descriptions taken from
--   <a>http://llvm.org/docs/LangRef.html#fnattrs</a>
data LlvmFuncAttr

-- | This attribute indicates that the inliner should attempt to inline
--   this function into callers whenever possible, ignoring any active
--   inlining size threshold for this caller.
AlwaysInline :: LlvmFuncAttr

-- | This attribute indicates that the source code contained a hint that
--   inlining this function is desirable (such as the "inline" keyword in
--   C/C++). It is just a hint; it imposes no requirements on the inliner.
InlineHint :: LlvmFuncAttr

-- | This attribute indicates that the inliner should never inline this
--   function in any situation. This attribute may not be used together
--   with the alwaysinline attribute.
NoInline :: LlvmFuncAttr

-- | This attribute suggests that optimization passes and code generator
--   passes make choices that keep the code size of this function low, and
--   otherwise do optimizations specifically to reduce code size.
OptSize :: LlvmFuncAttr

-- | This function attribute indicates that the function never returns
--   normally. This produces undefined behavior at runtime if the function
--   ever does dynamically return.
NoReturn :: LlvmFuncAttr

-- | This function attribute indicates that the function never returns with
--   an unwind or exceptional control flow. If the function does unwind,
--   its runtime behavior is undefined.
NoUnwind :: LlvmFuncAttr

-- | This attribute indicates that the function computes its result (or
--   decides to unwind an exception) based strictly on its arguments,
--   without dereferencing any pointer arguments or otherwise accessing any
--   mutable state (e.g. memory, control registers, etc) visible to caller
--   functions. It does not write through any pointer arguments (including
--   byval arguments) and never changes any state visible to callers. This
--   means that it cannot unwind exceptions by calling the C++ exception
--   throwing methods, but could use the unwind instruction.
ReadNone :: LlvmFuncAttr

-- | This attribute indicates that the function does not write through any
--   pointer arguments (including byval arguments) or otherwise modify any
--   state (e.g. memory, control registers, etc) visible to caller
--   functions. It may dereference pointer arguments and read state that
--   may be set in the caller. A readonly function always returns the same
--   value (or unwinds an exception identically) when called with the same
--   set of arguments and global state. It cannot unwind an exception by
--   calling the C++ exception throwing methods, but may use the unwind
--   instruction.
ReadOnly :: LlvmFuncAttr

-- | This attribute indicates that the function should emit a stack
--   smashing protector. It is in the form of a "canary"—a random value
--   placed on the stack before the local variables that's checked upon
--   return from the function to see if it has been overwritten. A
--   heuristic is used to determine if a function needs stack protectors or
--   not.
--   
--   If a function that has an ssp attribute is inlined into a function
--   that doesn't have an ssp attribute, then the resulting function will
--   have an ssp attribute.
Ssp :: LlvmFuncAttr

-- | This attribute indicates that the function should always emit a stack
--   smashing protector. This overrides the ssp function attribute.
--   
--   If a function that has an sspreq attribute is inlined into a function
--   that doesn't have an sspreq attribute or which has an ssp attribute,
--   then the resulting function will have an sspreq attribute.
SspReq :: LlvmFuncAttr

-- | This attribute indicates that the code generator should not use a red
--   zone, even if the target-specific ABI normally permits it.
NoRedZone :: LlvmFuncAttr

-- | This attributes disables implicit floating point instructions.
NoImplicitFloat :: LlvmFuncAttr

-- | This attribute disables prologue / epilogue emission for the function.
--   This can have very system-specific consequences.
Naked :: LlvmFuncAttr

-- | Llvm compare operations.
data LlvmCmpOp

-- | Equal (Signed and Unsigned)
LM_CMP_Eq :: LlvmCmpOp

-- | Not equal (Signed and Unsigned)
LM_CMP_Ne :: LlvmCmpOp

-- | Unsigned greater than
LM_CMP_Ugt :: LlvmCmpOp

-- | Unsigned greater than or equal
LM_CMP_Uge :: LlvmCmpOp

-- | Unsigned less than
LM_CMP_Ult :: LlvmCmpOp

-- | Unsigned less than or equal
LM_CMP_Ule :: LlvmCmpOp

-- | Signed greater than
LM_CMP_Sgt :: LlvmCmpOp

-- | Signed greater than or equal
LM_CMP_Sge :: LlvmCmpOp

-- | Signed less than
LM_CMP_Slt :: LlvmCmpOp

-- | Signed less than or equal
LM_CMP_Sle :: LlvmCmpOp

-- | Float equal
LM_CMP_Feq :: LlvmCmpOp

-- | Float not equal
LM_CMP_Fne :: LlvmCmpOp

-- | Float greater than
LM_CMP_Fgt :: LlvmCmpOp

-- | Float greater than or equal
LM_CMP_Fge :: LlvmCmpOp

-- | Float less than
LM_CMP_Flt :: LlvmCmpOp

-- | Float less than or equal
LM_CMP_Fle :: LlvmCmpOp

-- | Llvm binary operators machine operations.
data LlvmMachOp

-- | add two integer, floating point or vector values.
LM_MO_Add :: LlvmMachOp

-- | subtract two ...
LM_MO_Sub :: LlvmMachOp

-- | multiply ..
LM_MO_Mul :: LlvmMachOp

-- | unsigned integer or vector division.
LM_MO_UDiv :: LlvmMachOp

-- | signed integer ..
LM_MO_SDiv :: LlvmMachOp

-- | unsigned integer or vector remainder (mod)
LM_MO_URem :: LlvmMachOp

-- | signed ...
LM_MO_SRem :: LlvmMachOp

-- | add two floating point or vector values.
LM_MO_FAdd :: LlvmMachOp

-- | subtract two ...
LM_MO_FSub :: LlvmMachOp

-- | multiply ...
LM_MO_FMul :: LlvmMachOp

-- | divide ...
LM_MO_FDiv :: LlvmMachOp

-- | remainder ...
LM_MO_FRem :: LlvmMachOp

-- | Left shift
LM_MO_Shl :: LlvmMachOp

-- | Logical shift right Shift right, filling with zero
LM_MO_LShr :: LlvmMachOp

-- | Arithmetic shift right The most significant bits of the result will be
--   equal to the sign bit of the left operand.
LM_MO_AShr :: LlvmMachOp

-- | AND bitwise logical operation.
LM_MO_And :: LlvmMachOp

-- | OR bitwise logical operation.
LM_MO_Or :: LlvmMachOp

-- | XOR bitwise logical operation.
LM_MO_Xor :: LlvmMachOp

-- | Llvm cast operations.
data LlvmCastOp

-- | Integer truncate
LM_Trunc :: LlvmCastOp

-- | Integer extend (zero fill)
LM_Zext :: LlvmCastOp

-- | Integer extend (sign fill)
LM_Sext :: LlvmCastOp

-- | Float truncate
LM_Fptrunc :: LlvmCastOp

-- | Float extend
LM_Fpext :: LlvmCastOp

-- | Float to unsigned Integer
LM_Fptoui :: LlvmCastOp

-- | Float to signed Integer
LM_Fptosi :: LlvmCastOp

-- | Unsigned Integer to Float
LM_Uitofp :: LlvmCastOp

-- | Signed Int to Float
LM_Sitofp :: LlvmCastOp

-- | Pointer to Integer
LM_Ptrtoint :: LlvmCastOp

-- | Integer to Pointer
LM_Inttoptr :: LlvmCastOp

-- | Cast between types where no bit manipulation is needed
LM_Bitcast :: LlvmCastOp

-- | LLVM Variables
data LlvmVar

-- | Variables with a global scope.
LMGlobalVar :: LMString -> LlvmType -> LlvmLinkageType -> LMSection -> LMAlign -> LMConst -> LlvmVar

-- | Variables local to a function or parameters.
LMLocalVar :: Unique -> LlvmType -> LlvmVar

-- | Named local variables. Sometimes we need to be able to explicitly name
--   variables (e.g for function arguments).
LMNLocalVar :: LMString -> LlvmType -> LlvmVar

-- | A constant variable
LMLitVar :: LlvmLit -> LlvmVar

-- | Llvm Static Data.
--   
--   These represent the possible global level variables and constants.
data LlvmStatic

-- | A comment in a static section
LMComment :: LMString -> LlvmStatic

-- | A static variant of a literal value
LMStaticLit :: LlvmLit -> LlvmStatic

-- | For uninitialised data
LMUninitType :: LlvmType -> LlvmStatic

-- | Defines a static <a>LMString</a>
LMStaticStr :: LMString -> LlvmType -> LlvmStatic

-- | A static array
LMStaticArray :: [LlvmStatic] -> LlvmType -> LlvmStatic

-- | A static structure type
LMStaticStruc :: [LlvmStatic] -> LlvmType -> LlvmStatic

-- | A static structure type
LMStaticStrucU :: [LlvmStatic] -> LlvmType -> LlvmStatic

-- | A pointer to other data
LMStaticPointer :: LlvmVar -> LlvmStatic

-- | Truncate
LMTrunc :: LlvmStatic -> LlvmType -> LlvmStatic

-- | Pointer to Pointer conversion
LMBitc :: LlvmStatic -> LlvmType -> LlvmStatic

-- | Pointer to Integer conversion
LMPtoI :: LlvmStatic -> LlvmType -> LlvmStatic

-- | Constant addition operation
LMAdd :: LlvmStatic -> LlvmStatic -> LlvmStatic

-- | Constant subtraction operation
LMSub :: LlvmStatic -> LlvmStatic -> LlvmStatic

-- | Llvm Literal Data.
--   
--   These can be used inline in expressions.
data LlvmLit

-- | Refers to an integer constant (i64 42).
LMIntLit :: Integer -> LlvmType -> LlvmLit

-- | Floating point literal
LMFloatLit :: Double -> LlvmType -> LlvmLit

-- | Literal NULL, only applicable to pointer types
LMNullLit :: LlvmType -> LlvmLit

-- | Vector literal
LMVectorLit :: [LlvmLit] -> LlvmLit

-- | Undefined value, random bit pattern. Useful for optimisations.
LMUndefLit :: LlvmType -> LlvmLit

-- | Llvm Types
data LlvmType

-- | An integer with a given width in bits.
LMInt :: Int -> LlvmType

-- | 32 bit floating point
LMFloat :: LlvmType

-- | 64 bit floating point
LMDouble :: LlvmType

-- | 80 bit (x86 only) floating point
LMFloat80 :: LlvmType

-- | 128 bit floating point
LMFloat128 :: LlvmType

-- | A pointer to a <a>LlvmType</a>
LMPointer :: LlvmType -> LlvmType

-- | An array of <a>LlvmType</a>
LMArray :: Int -> LlvmType -> LlvmType

-- | A vector of <a>LlvmType</a>
LMVector :: Int -> LlvmType -> LlvmType

-- | A <a>LlvmVar</a> can represent a label (address)
LMLabel :: LlvmType

-- | Void type
LMVoid :: LlvmType

-- | Packed structure type
LMStruct :: [LlvmType] -> LlvmType

-- | Unpacked structure type
LMStructU :: [LlvmType] -> LlvmType

-- | A type alias
LMAlias :: LlvmAlias -> LlvmType

-- | LLVM Metadata
LMMetadata :: LlvmType

-- | Function type, used to create pointers to functions
LMFunction :: LlvmFunctionDecl -> LlvmType

-- | A type alias
type LlvmAlias = (LMString, LlvmType)

-- | A global mutable variable. Maybe defined or external
data LMGlobal
LMGlobal :: LlvmVar -> Maybe LlvmStatic -> LMGlobal

-- | Returns the variable of the <a>LMGlobal</a>
[getGlobalVar] :: LMGlobal -> LlvmVar

-- | Return the value of the <a>LMGlobal</a>
[getGlobalValue] :: LMGlobal -> Maybe LlvmStatic

-- | A String in LLVM
type LMString = FastString

-- | An LLVM section definition. If Nothing then let LLVM decide the
--   section
type LMSection = Maybe LMString
type LMAlign = Maybe Int
data LMConst

-- | Mutable global variable
Global :: LMConst

-- | Constant global variable
Constant :: LMConst

-- | Alias of another variable
Alias :: LMConst
i64 :: LlvmType
i32 :: LlvmType
i16 :: LlvmType
i8 :: LlvmType
i1 :: LlvmType
i8Ptr :: LlvmType

-- | The target architectures word size
llvmWord :: Platform -> LlvmType

-- | The target architectures word size
llvmWordPtr :: Platform -> LlvmType

-- | LLVM metadata expressions
data MetaExpr
MetaStr :: !LMString -> MetaExpr
MetaLit :: !LlvmLit -> MetaExpr
MetaNode :: !MetaId -> MetaExpr
MetaVar :: !LlvmVar -> MetaExpr
MetaStruct :: [MetaExpr] -> MetaExpr

-- | Associates some metadata with a specific label for attaching to an
--   instruction.
data MetaAnnot
MetaAnnot :: LMString -> MetaExpr -> MetaAnnot

-- | Metadata declarations. Metadata can only be declared in global scope.
data MetaDecl

-- | Named metadata. Only used for communicating module information to
--   LLVM. ('!name = !{ [!&lt;n&gt;] }' form).
MetaNamed :: !LMString -> [MetaId] -> MetaDecl

-- | Metadata node declaration. ('!0 = metadata !{ &lt;metadata
--   expression&gt; }' form).
MetaUnnamed :: !MetaId -> !MetaExpr -> MetaDecl

-- | A reference to an un-named metadata node.
newtype MetaId
MetaId :: Int -> MetaId
data ModuleFlagBehavior
MFBError :: ModuleFlagBehavior
MFBWarning :: ModuleFlagBehavior
MFBRequire :: ModuleFlagBehavior
MFBOverride :: ModuleFlagBehavior
MFBAppend :: ModuleFlagBehavior
MFBAppendUnique :: ModuleFlagBehavior
MFBMax :: ModuleFlagBehavior
MFBMin :: ModuleFlagBehavior
data ModuleFlag
ModuleFlag :: ModuleFlagBehavior -> LMString -> MetaExpr -> ModuleFlag
[mfBehavior] :: ModuleFlag -> ModuleFlagBehavior
[mfName] :: ModuleFlag -> LMString
[mfValue] :: ModuleFlag -> MetaExpr
moduleFlagToMetaExpr :: ModuleFlag -> MetaExpr

-- | Test if a <a>LlvmVar</a> is global.
isGlobal :: LlvmVar -> Bool

-- | Return the <a>LlvmType</a> of a <a>LlvmLit</a>
getLitType :: LlvmLit -> LlvmType

-- | Return the <a>LlvmType</a> of the <a>LlvmVar</a>
getVarType :: LlvmVar -> LlvmType

-- | Return the <a>LlvmLinkageType</a> for a <a>LlvmVar</a>
getLink :: LlvmVar -> LlvmLinkageType

-- | Return the <a>LlvmType</a> of the <a>LlvmStatic</a>
getStatType :: LlvmStatic -> LlvmType

-- | Lift a variable to <a>LMPointer</a> type.
pVarLift :: LlvmVar -> LlvmVar

-- | Lower a variable of <a>LMPointer</a> type.
pVarLower :: LlvmVar -> LlvmVar

-- | Add a pointer indirection to the supplied type. <a>LMLabel</a> and
--   <a>LMVoid</a> cannot be lifted.
pLift :: LlvmType -> LlvmType

-- | Remove the pointer indirection of the supplied type. Only
--   <a>LMPointer</a> constructors can be lowered.
pLower :: LlvmType -> LlvmType

-- | Test if the given <a>LlvmType</a> is an integer
isInt :: LlvmType -> Bool

-- | Test if the given <a>LlvmType</a> is a floating point type
isFloat :: LlvmType -> Bool

-- | Test if the given <a>LlvmType</a> is an <a>LMPointer</a> construct
isPointer :: LlvmType -> Bool

-- | Test if the given <a>LlvmType</a> is an <a>LMVector</a> construct
isVector :: LlvmType -> Bool

-- | Width in bits of an <a>LlvmType</a>, returns 0 if not applicable
llvmWidthInBits :: Platform -> LlvmType -> Int
ppVar :: IsLine doc => LlvmCgConfig -> LlvmVar -> doc

-- | Print a literal value. No type.
ppLit :: IsLine doc => LlvmCgConfig -> LlvmLit -> doc
ppTypeLit :: IsLine doc => LlvmCgConfig -> LlvmLit -> doc

-- | Return the variable name or value of the <a>LlvmVar</a> in Llvm IR
--   textual representation (e.g. <tt>@x</tt>, <tt>%y</tt> or <tt>42</tt>).
ppName :: IsLine doc => LlvmCgConfig -> LlvmVar -> doc

-- | Return the variable name or value of the <a>LlvmVar</a> in a plain
--   textual representation (e.g. <tt>x</tt>, <tt>y</tt> or <tt>42</tt>).
ppPlainName :: IsLine doc => LlvmCgConfig -> LlvmVar -> doc

-- | Print out a whole LLVM module.
ppLlvmModule :: IsDoc doc => LlvmCgConfig -> LlvmModule -> doc

-- | Print out a multi-line comment, can be inside a function or on its own
ppLlvmComments :: IsDoc doc => [LMString] -> doc

-- | Print out a comment, can be inside a function or on its own
ppLlvmComment :: IsLine doc => LMString -> doc

-- | Print out a list of global mutable variable definitions
ppLlvmGlobals :: IsDoc doc => LlvmCgConfig -> [LMGlobal] -> doc

-- | Print out a global mutable variable definition
ppLlvmGlobal :: IsLine doc => LlvmCgConfig -> LMGlobal -> doc

-- | Print out a list of function declaration.
ppLlvmFunctionDecls :: IsDoc doc => LlvmFunctionDecls -> doc

-- | Print out a function declaration. Declarations define the function
--   type but don't define the actual body of the function.
ppLlvmFunctionDecl :: IsDoc doc => LlvmFunctionDecl -> doc

-- | Print out a list of function definitions.
ppLlvmFunctions :: IsDoc doc => LlvmCgConfig -> LlvmFunctions -> doc

-- | Print out a function definition.
ppLlvmFunction :: IsDoc doc => LlvmCgConfig -> LlvmFunction -> doc

-- | Print out an LLVM type alias.
ppLlvmAlias :: IsLine doc => LlvmAlias -> doc

-- | Print out a list of LLVM type aliases.
ppLlvmAliases :: IsDoc doc => [LlvmAlias] -> doc

-- | Print out a list of LLVM metadata.
ppLlvmMetas :: IsDoc doc => LlvmCgConfig -> [MetaDecl] -> doc

-- | Print out an LLVM metadata definition.
ppLlvmMeta :: IsLine doc => LlvmCgConfig -> MetaDecl -> doc


-- | Formats on this architecture A Format is a combination of width and
--   class
--   
--   TODO: Signed vs unsigned?
--   
--   TODO: This module is currently shared by all architectures because
--   NCGMonad need to know about it to make a VReg. It would be better to
--   have architecture specific formats, and do the overloading properly.
--   eg SPARC doesn't care about FF80.
module GHC.CmmToAsm.Format
data Format
II8 :: Format
II16 :: Format
II32 :: Format
II64 :: Format
FF32 :: Format
FF64 :: Format
VecFormat :: !Length -> !ScalarFormat -> Format
pattern IntegerFormat :: Format
data ScalarFormat
FmtInt8 :: ScalarFormat
FmtInt16 :: ScalarFormat
FmtInt32 :: ScalarFormat
FmtInt64 :: ScalarFormat
FmtFloat :: ScalarFormat
FmtDouble :: ScalarFormat

-- | Get the integer format of this width.
intFormat :: Width -> Format

-- | Get the float format of this width.
floatFormat :: Width -> Format

-- | Check if a format represent an integer value.
isIntFormat :: Format -> Bool
isIntScalarFormat :: ScalarFormat -> Bool
intScalarFormat :: Width -> ScalarFormat

-- | Check if a format represents a floating point value.
isFloatFormat :: Format -> Bool
vecFormat :: CmmType -> Format

-- | Check if a format represents a vector
isVecFormat :: Format -> Bool

-- | Convert a Cmm type to a Format.
cmmTypeFormat :: CmmType -> Format

-- | Get the Width of a Format.
formatToWidth :: Format -> Width
scalarWidth :: ScalarFormat -> Width
formatInBytes :: Format -> Int
isFloatScalarFormat :: ScalarFormat -> Bool
isFloatOrFloatVecFormat :: Format -> Bool
floatScalarFormat :: Width -> ScalarFormat
scalarFormatFormat :: ScalarFormat -> Format

-- | A typed virtual register: a virtual register, together with the
--   specific format we are using it at.
data VirtualRegWithFormat
VirtualRegWithFormat :: {-# UNPACK #-} !VirtualReg -> !Format -> VirtualRegWithFormat
[virtualRegWithFormat_reg] :: VirtualRegWithFormat -> {-# UNPACK #-} !VirtualReg
[virtualRegWithFormat_format] :: VirtualRegWithFormat -> !Format

-- | A typed register: a register, together with the specific format we are
--   using it at.
data RegWithFormat
RegWithFormat :: {-# UNPACK #-} !Reg -> !Format -> RegWithFormat
[regWithFormat_reg] :: RegWithFormat -> {-# UNPACK #-} !Reg
[regWithFormat_format] :: RegWithFormat -> !Format

-- | Take all the virtual registers from this set.
takeVirtualRegs :: UniqSet RegWithFormat -> UniqSet VirtualReg

-- | Take all the real registers from this set.
takeRealRegs :: UniqSet RegWithFormat -> UniqSet RealReg
instance GHC.Classes.Eq GHC.CmmToAsm.Format.Format
instance GHC.Classes.Eq GHC.CmmToAsm.Format.ScalarFormat
instance GHC.Classes.Ord GHC.CmmToAsm.Format.Format
instance GHC.Classes.Ord GHC.CmmToAsm.Format.ScalarFormat
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Format.Format
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Format.RegWithFormat
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Format.VirtualRegWithFormat
instance GHC.Internal.Show.Show GHC.CmmToAsm.Format.Format
instance GHC.Internal.Show.Show GHC.CmmToAsm.Format.RegWithFormat
instance GHC.Internal.Show.Show GHC.CmmToAsm.Format.ScalarFormat
instance GHC.Types.Unique.Uniquable GHC.CmmToAsm.Format.RegWithFormat


-- | Deal with Cmm registers
module GHC.CmmToLlvm.Regs

-- | Get the LlvmVar function argument storing the real register
lmGlobalRegArg :: Platform -> GlobalRegUse -> LlvmVar

-- | Get the LlvmVar function variable storing the real register
lmGlobalRegVar :: Platform -> GlobalRegUse -> LlvmVar

-- | A list of STG Registers that should always be considered alive
alwaysLive :: Platform -> [GlobalRegUse]

-- | STG Type Based Alias Analysis hierarchy
stgTBAA :: [(Unique, LMString, Maybe Unique)]

-- | Id values The <a>rootN</a> node is the root (there can be more than
--   one) of the TBAA hierarchy and as of LLVM 4.0 should *only* be
--   referenced by other nodes. It should never occur in any LLVM
--   instruction statement.
baseN :: Unique

-- | Id values The <a>rootN</a> node is the root (there can be more than
--   one) of the TBAA hierarchy and as of LLVM 4.0 should *only* be
--   referenced by other nodes. It should never occur in any LLVM
--   instruction statement.
stackN :: Unique

-- | Id values The <a>rootN</a> node is the root (there can be more than
--   one) of the TBAA hierarchy and as of LLVM 4.0 should *only* be
--   referenced by other nodes. It should never occur in any LLVM
--   instruction statement.
heapN :: Unique

-- | Id values The <a>rootN</a> node is the root (there can be more than
--   one) of the TBAA hierarchy and as of LLVM 4.0 should *only* be
--   referenced by other nodes. It should never occur in any LLVM
--   instruction statement.
rxN :: Unique

-- | Id values The <a>rootN</a> node is the root (there can be more than
--   one) of the TBAA hierarchy and as of LLVM 4.0 should *only* be
--   referenced by other nodes. It should never occur in any LLVM
--   instruction statement.
topN :: Unique

-- | The TBAA metadata identifier
tbaa :: LMString

-- | Get the correct TBAA metadata information for this register type
getTBAA :: GlobalReg -> Unique

module GHC.CmmToAsm.X86.RegInfo
mkVirtualReg :: Unique -> Format -> VirtualReg
regDotColor :: Platform -> RealReg -> SDoc


-- | The assignment of virtual registers to stack slots
module GHC.CmmToAsm.Reg.Linear.StackMap

-- | Identifier for a stack slot.
type StackSlot = Int
data StackMap
StackMap :: !Int -> UniqFM Unique StackSlot -> StackMap

-- | The slots that are still available to be allocated.
[stackMapNextFreeSlot] :: StackMap -> !Int

-- | Assignment of vregs to stack slots.
[stackMapAssignment] :: StackMap -> UniqFM Unique StackSlot

-- | An empty stack map, with all slots available.
emptyStackMap :: StackMap

-- | If this vreg unique already has a stack assignment then return the
--   slot number, otherwise allocate a new slot, and update the map.
getStackSlotFor :: StackMap -> Format -> Unique -> (StackMap, Int)

-- | Return the number of stack slots that were allocated
getStackUse :: StackMap -> Int

module GHC.CmmToAsm.RV64.Regs

-- | First integer register number. <tt>zero</tt> register.
x0RegNo :: RegNo

-- | return address register
x1RegNo :: RegNo

-- | return address register
raRegNo :: RegNo
x5RegNo :: RegNo
t0RegNo :: RegNo
x7RegNo :: RegNo
t2RegNo :: RegNo
x28RegNo :: RegNo
t3RegNo :: RegNo

-- | Last integer register number. Used as TMP (IP) register.
x31RegNo :: RegNo

-- | Last integer register number. Used as TMP (IP) register.
t6RegNo :: RegNo

-- | Last integer register number. Used as TMP (IP) register.
tmpRegNo :: RegNo

-- | First floating point register.
d0RegNo :: RegNo

-- | First floating point register.
ft0RegNo :: RegNo
d7RegNo :: RegNo
ft7RegNo :: RegNo

-- | Last floating point register.
d31RegNo :: RegNo
x10RegNo :: RegNo
a0RegNo :: RegNo
x17RegNo :: RegNo
a7RegNo :: RegNo
d10RegNo :: RegNo
fa0RegNo :: RegNo
d17RegNo :: RegNo
fa7RegNo :: RegNo
zeroReg :: Reg
raReg :: Reg

-- | Not to be confused with the <a>CmmReg</a> <a>spReg</a>
spMachReg :: Reg
tmpReg :: Reg

-- | All machine register numbers.
allMachRegNos :: [RegNo]

-- | Registers available to the register allocator.
--   
--   These are all registers minus those with a fixed role in RISCV ABI
--   (zero, lr, sp, gp, tp, fp, tmp) and GHC RTS (Base, Sp, Hp, HpLim,
--   R1..R8, F1..F6, D1..D6.)
allocatableRegs :: Platform -> [RealReg]

-- | Integer argument registers according to the calling convention
allGpArgRegs :: [Reg]

-- | Floating point argument registers according to the calling convention
allFpArgRegs :: [Reg]

-- | Addressing modes
data AddrMode

-- | A register plus some immediate integer, e.g. <tt>8(sp)</tt> or
--   <tt>-16(sp)</tt>. The offset needs to fit into 12bits.
AddrRegImm :: Reg -> Imm -> AddrMode

-- | A register
AddrReg :: Reg -> AddrMode
data Imm
ImmInt :: Int -> Imm
ImmInteger :: Integer -> Imm
ImmCLbl :: CLabel -> Imm
ImmLit :: FastString -> Imm
ImmIndex :: CLabel -> Int -> Imm
ImmFloat :: Rational -> Imm
ImmDouble :: Rational -> Imm
ImmConstantSum :: Imm -> Imm -> Imm
ImmConstantDiff :: Imm -> Imm -> Imm

-- | Map <a>CmmLit</a> to <a>Imm</a>
--   
--   N.B. this is a partial function, because not all <a>CmmLit</a>s have
--   an immediate representation.
litToImm :: CmmLit -> Imm

-- | regSqueeze_class reg Calculate the maximum number of register colors
--   that could be denied to a node of this class due to having this reg as
--   a neighbour.
virtualRegSqueeze :: RegClass -> VirtualReg -> Int
realRegSqueeze :: RegClass -> RealReg -> Int
mkVirtualReg :: Unique -> Format -> VirtualReg
classOfRealReg :: RealReg -> RegClass
regDotColor :: RealReg -> SDoc
instance GHC.Classes.Eq GHC.CmmToAsm.RV64.Regs.AddrMode
instance GHC.Classes.Eq GHC.CmmToAsm.RV64.Regs.Imm
instance GHC.Internal.Show.Show GHC.CmmToAsm.RV64.Regs.AddrMode
instance GHC.Internal.Show.Show GHC.CmmToAsm.RV64.Regs.Imm


-- | Functions to implement the <tt>FR</tt> (as in "free regs") type class.
--   
--   For LLVM GHC calling convention (used registers), see
--   <a>https://github.com/llvm/llvm-project/blob/6ab900f8746e7d8e24afafb5886a40801f6799f4/llvm/lib/Target/RISCV/RISCVISelLowering.cpp#L13638-L13685</a>
module GHC.CmmToAsm.Reg.Linear.RV64

-- | Set corresponding register bit to 0
allocateReg :: HasCallStack => RealReg -> FreeRegs -> FreeRegs

-- | Get all free <a>RealReg</a>s (i.e. those where the corresponding bit
--   is 1)
getFreeRegs :: RegClass -> FreeRegs -> [RealReg]

-- | Set bits of all allocatable registers to 1
initFreeRegs :: Platform -> FreeRegs

-- | Set corresponding register bit to 1
releaseReg :: HasCallStack => RealReg -> FreeRegs -> FreeRegs

-- | Bitmaps to indicate which registers are free (currently unused)
--   
--   The bit index represents the <a>RegNo</a>, in case of floating point
--   registers with an offset of 32. The register is free when the bit is
--   set.
data FreeRegs
FreeRegs :: !Word32 -> !Word32 -> FreeRegs
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Linear.RV64.FreeRegs
instance GHC.Internal.Show.Show GHC.CmmToAsm.Reg.Linear.RV64.FreeRegs

module GHC.CmmToAsm.PPC.Regs

-- | regSqueeze_class reg Calculate the maximum number of register colors
--   that could be denied to a node of this class due to having this reg as
--   a neighbour.
virtualRegSqueeze :: RegClass -> VirtualReg -> Int
realRegSqueeze :: RegClass -> RealReg -> Int
mkVirtualReg :: Unique -> Format -> VirtualReg
regDotColor :: RealReg -> SDoc
data Imm
ImmInt :: Int -> Imm
ImmInteger :: Integer -> Imm
ImmCLbl :: CLabel -> Imm
ImmLit :: FastString -> Imm
ImmIndex :: CLabel -> Int -> Imm
ImmFloat :: Rational -> Imm
ImmDouble :: Rational -> Imm
ImmConstantSum :: Imm -> Imm -> Imm
ImmConstantDiff :: Imm -> Imm -> Imm
LO :: Imm -> Imm
HI :: Imm -> Imm
HA :: Imm -> Imm
HIGHERA :: Imm -> Imm
HIGHESTA :: Imm -> Imm
strImmLit :: FastString -> Imm
litToImm :: CmmLit -> Imm
data AddrMode
AddrRegReg :: Reg -> Reg -> AddrMode
AddrRegImm :: Reg -> Imm -> AddrMode
addrOffset :: AddrMode -> Int -> Maybe AddrMode
spRel :: Platform -> Int -> AddrMode
argRegs :: RegNo -> [Reg]
allArgRegs :: [Reg]
callClobberedRegs :: Platform -> [Reg]
allMachRegNos :: [RegNo]
classOfRealReg :: RealReg -> RegClass
toRegNo :: Reg -> RegNo
allFPArgRegs :: Platform -> [Reg]
fits16Bits :: Integral a => a -> Bool
makeImmediate :: Integral a => Width -> Bool -> a -> Maybe Imm
fReg :: Int -> RegNo
r0 :: Reg
sp :: Reg
toc :: Reg
r3 :: Reg
r4 :: Reg
r11 :: Reg
r12 :: Reg
r30 :: Reg
tmpReg :: Platform -> Reg
f1 :: Reg
allocatableRegs :: Platform -> [RealReg]


-- | Free regs map for PowerPC
module GHC.CmmToAsm.Reg.Linear.PPC
data FreeRegs
FreeRegs :: !Word32 -> !Word32 -> FreeRegs
noFreeRegs :: FreeRegs
releaseReg :: RealReg -> FreeRegs -> FreeRegs
initFreeRegs :: Platform -> FreeRegs
getFreeRegs :: RegClass -> FreeRegs -> [RealReg]
allocateReg :: RealReg -> FreeRegs -> FreeRegs
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Linear.PPC.FreeRegs
instance GHC.Internal.Show.Show GHC.CmmToAsm.Reg.Linear.PPC.FreeRegs


-- | Constants describing the DWARF format. Most of this simply mirrors
--   /usr/include/dwarf.h.
module GHC.CmmToAsm.Dwarf.Constants

-- | Language ID used for Haskell.
dW_LANG_Haskell :: Word
dW_TAG_array_type :: Word
dW_TAG_lexical_block :: Word
dW_TAG_pointer_type :: Word
dW_TAG_compile_unit :: Word
dW_TAG_structure_type :: Word
dW_TAG_typedef :: Word
dW_TAG_subroutine_type :: Word
dW_TAG_subrange_type :: Word
dW_TAG_base_type :: Word
dW_TAG_file_type :: Word
dW_TAG_subprogram :: Word
dW_TAG_variable :: Word
dW_TAG_auto_variable :: Word
dW_TAG_arg_variable :: Word
dW_TAG_ghc_src_note :: Word
dW_AT_name :: Word
dW_AT_stmt_list :: Word
dW_AT_low_pc :: Word
dW_AT_high_pc :: Word
dW_AT_language :: Word
dW_AT_comp_dir :: Word
dW_AT_producer :: Word
dW_AT_external :: Word
dW_AT_frame_base :: Word
dW_AT_use_UTF8 :: Word
dW_AT_linkage_name :: Word
dW_AT_ghc_tick_parent :: Word
dW_AT_ghc_span_file :: Word
dW_AT_ghc_span_start_line :: Word
dW_AT_ghc_span_start_col :: Word
dW_AT_ghc_span_end_line :: Word
dW_AT_ghc_span_end_col :: Word
dW_CHILDREN_no :: Word8
dW_CHILDREN_yes :: Word8
dW_FORM_addr :: Word
dW_FORM_data2 :: Word
dW_FORM_data4 :: Word
dW_FORM_string :: Word
dW_FORM_flag :: Word
dW_FORM_block1 :: Word
dW_FORM_ref_addr :: Word
dW_FORM_ref4 :: Word
dW_FORM_flag_present :: Word
dW_ATE_address :: Word
dW_ATE_boolean :: Word
dW_ATE_float :: Word
dW_ATE_signed :: Word
dW_ATE_signed_char :: Word
dW_ATE_unsigned :: Word
dW_ATE_unsigned_char :: Word
dW_CFA_set_loc :: Word8
dW_CFA_undefined :: Word8
dW_CFA_same_value :: Word8
dW_CFA_def_cfa :: Word8
dW_CFA_def_cfa_offset :: Word8
dW_CFA_def_cfa_expression :: Word8
dW_CFA_expression :: Word8
dW_CFA_offset_extended_sf :: Word8
dW_CFA_def_cfa_sf :: Word8
dW_CFA_def_cfa_offset_sf :: Word8
dW_CFA_val_offset :: Word8
dW_CFA_val_expression :: Word8
dW_CFA_offset :: Word8
dW_OP_addr :: Word8
dW_OP_deref :: Word8
dW_OP_consts :: Word8
dW_OP_minus :: Word8
dW_OP_mul :: Word8
dW_OP_plus :: Word8
dW_OP_lit0 :: Word8
dW_OP_breg0 :: Word8
dW_OP_call_frame_cfa :: Word8
dwarfInfoSection :: IsDoc doc => Platform -> doc
dwarfAbbrevSection :: IsDoc doc => Platform -> doc
dwarfLineSection :: IsDoc doc => Platform -> doc
dwarfFrameSection :: IsDoc doc => Platform -> doc
dwarfGhcSection :: IsDoc doc => Platform -> doc
dwarfARangesSection :: IsDoc doc => Platform -> doc
dwarfSection :: IsDoc doc => Platform -> String -> doc
dwarfInfoLabel :: IsLine doc => doc
dwarfAbbrevLabel :: IsLine doc => doc
dwarfLineLabel :: IsLine doc => doc
dwarfFrameLabel :: IsLine doc => doc

-- | Mapping of registers to DWARF register numbers
dwarfRegNo :: Platform -> Reg -> Word8

-- | Virtual register number to use for return address.
dwarfReturnRegNo :: Platform -> Word8

module GHC.CmmToAsm.Instr

-- | Common things that we can do with instructions, on all architectures.
--   These are used by the shared parts of the native code generator,
--   specifically the register allocators.
class Instruction instr

-- | Get the registers that are being used by this instruction. regUsage
--   doesn't need to do any trickery for jumps and such. Just state
--   precisely the regs read and written by that insn. The consequences of
--   control flow transfers, as far as register allocation goes, are taken
--   care of by the register allocator.
regUsageOfInstr :: Instruction instr => Platform -> instr -> RegUsage

-- | Apply a given mapping to all the register references in this
--   instruction.
patchRegsOfInstr :: Instruction instr => Platform -> instr -> (Reg -> Reg) -> instr

-- | Checks whether this instruction is a jump/branch instruction. One that
--   can change the flow of control in a way that the register allocator
--   needs to worry about.
isJumpishInstr :: Instruction instr => instr -> Bool

-- | Give the possible *local block* destinations of this jump instruction.
--   Must be defined for all jumpish instructions.
jumpDestsOfInstr :: Instruction instr => instr -> [BlockId]

-- | Check if the instr always transfers control flow to the given block.
--   Used by code layout to eliminate jumps that can be replaced by fall
--   through.
canFallthroughTo :: Instruction instr => instr -> BlockId -> Bool

-- | Change the destination of this jump instruction. Used in the linear
--   allocator when adding fixup blocks for join points.
patchJumpInstr :: Instruction instr => instr -> (BlockId -> BlockId) -> instr

-- | An instruction to spill a register into a spill slot.
mkSpillInstr :: Instruction instr => NCGConfig -> RegWithFormat -> Int -> Int -> [instr]

-- | An instruction to reload a register from a spill slot.
mkLoadInstr :: Instruction instr => NCGConfig -> RegWithFormat -> Int -> Int -> [instr]

-- | See if this instruction is telling us the current C stack delta
takeDeltaInstr :: Instruction instr => instr -> Maybe Int

-- | Check whether this instruction is some meta thing inserted into the
--   instruction stream for other purposes.
--   
--   Not something that has to be treated as a real machine instruction and
--   have its registers allocated.
--   
--   eg, comments, delta, ldata, etc.
isMetaInstr :: Instruction instr => instr -> Bool

-- | Copy the value in a register to another one. Must work for all
--   register classes.
mkRegRegMoveInstr :: Instruction instr => NCGConfig -> Format -> Reg -> Reg -> instr

-- | Take the source and destination from this reg -&gt; reg move
--   instruction or Nothing if it's not one
takeRegRegMoveInstr :: Instruction instr => Platform -> instr -> Maybe (Reg, Reg)

-- | Make an unconditional jump instruction. For architectures with branch
--   delay slots, its ok to put a NOP after the jump. Don't fill the delay
--   slot with an instruction that references regs or you'll confuse the
--   linear allocator.
mkJumpInstr :: Instruction instr => BlockId -> [instr]
mkStackAllocInstr :: Instruction instr => Platform -> Int -> [instr]
mkStackDeallocInstr :: Instruction instr => Platform -> Int -> [instr]

-- | Pretty-print an instruction
pprInstr :: Instruction instr => Platform -> instr -> SDoc
mkComment :: Instruction instr => FastString -> [instr]

-- | Holds a list of source and destination registers used by a particular
--   instruction.
--   
--   Machine registers that are pre-allocated to stgRegs are filtered out,
--   because they are uninteresting from a register allocation standpoint.
--   (We wouldn't want them to end up on the free list!)
--   
--   As far as we are concerned, the fixed registers simply don't exist
--   (for allocation purposes, anyway).
data RegUsage
RU :: [RegWithFormat] -> [RegWithFormat] -> RegUsage
[reads] :: RegUsage -> [RegWithFormat]
[writes] :: RegUsage -> [RegWithFormat]

-- | No regs read or written to.
noUsage :: RegUsage
instance GHC.Internal.Show.Show GHC.CmmToAsm.Instr.RegUsage

module GHC.CmmToAsm.RV64.Instr

-- | Stack frame header size in bytes.
--   
--   The stack frame header is made of the values that are always saved
--   (regardless of the context.) It consists of the saved return address
--   and a pointer to the previous frame. Thus, its size is two stack frame
--   slots which equals two addresses/words (2 * 8 byte).
stackFrameHeaderSize :: Int

-- | All registers are 8 byte wide.
spillSlotSize :: Int

-- | The number of bytes that the stack pointer should be aligned to.
stackAlign :: Int

-- | The number of spill slots available without allocating more.
maxSpillSlots :: NCGConfig -> Int

-- | Convert a spill slot number to a *byte* offset.
spillSlotToOffset :: Int -> Int

-- | Get the registers that are being used by this instruction. regUsage
--   doesn't need to do any trickery for jumps and such. Just state
--   precisely the regs read and written by that insn. The consequences of
--   control flow transfers, as far as register allocation goes, are taken
--   care of by the register allocator.
--   
--   RegUsage = RU [<a>regs</a>] [<a>regs</a>]
regUsageOfInstr :: Platform -> Instr -> RegUsage

-- | Caller-saved registers (according to calling convention)
--   
--   These registers may be clobbered after a jump.
callerSavedRegisters :: [Reg]

-- | Apply a given mapping to all the register references in this
--   instruction.
patchRegsOfInstr :: Instr -> (Reg -> Reg) -> Instr

-- | Checks whether this instruction is a jump/branch instruction.
--   
--   One that can change the flow of control in a way that the register
--   allocator needs to worry about.
isJumpishInstr :: Instr -> Bool
canFallthroughTo :: Instr -> BlockId -> Bool

-- | Get the <a>BlockId</a>s of the jump destinations (if any)
jumpDestsOfInstr :: Instr -> [BlockId]

-- | Change the destination of this (potential) jump instruction.
--   
--   Used in the linear allocator when adding fixup blocks for join points.
patchJumpInstr :: Instr -> (BlockId -> BlockId) -> Instr

-- | Generate instructions to spill a register into a spill slot.
mkSpillInstr :: HasCallStack => NCGConfig -> RegWithFormat -> Int -> Int -> [Instr]

-- | Generate instructions to load a register from a spill slot.
mkLoadInstr :: NCGConfig -> RegWithFormat -> Int -> Int -> [Instr]

-- | See if this instruction is telling us the current C stack delta
takeDeltaInstr :: Instr -> Maybe Int

-- | Not real instructions. Just meta data
isMetaInstr :: Instr -> Bool

-- | Copy the value in a register to another one.
--   
--   Must work for all register classes.
mkRegRegMoveInstr :: Reg -> Reg -> Instr

-- | Take the source and destination from this (potential) reg -&gt; reg
--   move instruction
--   
--   We have to be a bit careful here: A <a>MOV</a> can also mean an
--   implicit conversion. This case is filtered out.
takeRegRegMoveInstr :: Instr -> Maybe (Reg, Reg)

-- | Make an unconditional jump instruction.
mkJumpInstr :: BlockId -> [Instr]

-- | Decrement <tt>sp</tt> to allocate stack space.
--   
--   The stack grows downwards, so we decrement the stack pointer by
--   <tt>n</tt> (bytes). This is dual to <a>mkStackDeallocInstr</a>.
--   <tt>sp</tt> is the RISCV stack pointer, not to be confused with the
--   STG stack pointer.
mkStackAllocInstr :: Platform -> Int -> [Instr]

-- | Increment SP to deallocate stack space.
--   
--   The stack grows downwards, so we increment the stack pointer by
--   <tt>n</tt> (bytes). This is dual to <a>mkStackAllocInstr</a>.
--   <tt>sp</tt> is the RISCV stack pointer, not to be confused with the
--   STG stack pointer.
mkStackDeallocInstr :: Platform -> Int -> [Instr]
moveSp :: Int -> [Instr]
allocMoreStack :: Platform -> Int -> NatCmmDecl statics Instr -> UniqDSM (NatCmmDecl statics Instr, [(BlockId, BlockId)])
data Instr

-- | Comment pseudo-op
COMMENT :: SDoc -> Instr

-- | Multi-line comment pseudo-op
MULTILINE_COMMENT :: SDoc -> Instr

-- | Annotated instruction. Should print <a>instr</a> # <a>doc</a>
ANN :: SDoc -> Instr -> Instr

-- | Location pseudo-op <tt>.loc</tt> (file, line, col, name)
LOCATION :: Int -> Int -> Int -> LexicalFastString -> Instr

-- | Static data spat out during code generation.
LDATA :: Section -> RawCmmStatics -> Instr

-- | Start a new basic block.
--   
--   Useful during codegen, removed later. Preceding instruction should be
--   a jump, as per the invariants for a BasicBlock (see Cmm).
NEWBLOCK :: BlockId -> Instr

-- | Specify current stack offset for benefit of subsequent passes
DELTA :: Int -> Instr

-- | Push a minimal stack frame consisting of the return address (RA) and
--   the frame pointer (FP).
PUSH_STACK_FRAME :: Instr

-- | Pop the minimal stack frame of prior <a>PUSH_STACK_FRAME</a>.
POP_STACK_FRAME :: Instr

-- | Arithmetic addition (both integer and floating point)
--   
--   <pre>
--   rd = rs1 + rs2
--   </pre>
ADD :: Operand -> Operand -> Operand -> Instr

-- | Arithmetic subtraction (both integer and floating point)
--   
--   <pre>
--   rd = rs1 - rs2
--   </pre>
SUB :: Operand -> Operand -> Operand -> Instr

-- | Logical AND (integer only)
--   
--   <pre>
--   rd = rs1 &amp; rs2
--   </pre>
AND :: Operand -> Operand -> Operand -> Instr

-- | Logical OR (integer only)
--   
--   <pre>
--   rd = rs1 | rs2
--   </pre>
OR :: Operand -> Operand -> Operand -> Instr

-- | Logical left shift (zero extened, integer only)
--   
--   <pre>
--   rd = rs1 &lt;&lt; rs2
--   </pre>
SLL :: Operand -> Operand -> Operand -> Instr

-- | Logical right shift (zero extened, integer only)
--   
--   <pre>
--   rd = rs1 &gt;&gt; rs2
--   </pre>
SRL :: Operand -> Operand -> Operand -> Instr

-- | Arithmetic right shift (sign-extened, integer only)
--   
--   <pre>
--   rd = rs1 &gt;&gt; rs2
--   </pre>
SRA :: Operand -> Operand -> Operand -> Instr

-- | Store to memory (both, integer and floating point)
STR :: Format -> Operand -> Operand -> Instr

-- | Load from memory (sign-extended, integer and floating point)
LDR :: Format -> Operand -> Operand -> Instr

-- | Load from memory (unsigned, integer and floating point)
LDRU :: Format -> Operand -> Operand -> Instr

-- | Arithmetic multiplication (both, integer and floating point)
--   
--   <pre>
--   rd = rn × rm
--   </pre>
MUL :: Operand -> Operand -> Operand -> Instr

-- | Negation (both, integer and floating point)
--   
--   <pre>
--   rd = -op2
--   </pre>
NEG :: Operand -> Operand -> Instr

-- | Division (both, integer and floating point)
--   
--   <pre>
--   rd = rn ÷ rm
--   </pre>
DIV :: Operand -> Operand -> Operand -> Instr

-- | Remainder (integer only, signed)
--   
--   <pre>
--   rd = rn % rm
--   </pre>
REM :: Operand -> Operand -> Operand -> Instr

-- | Remainder (integer only, unsigned)
--   
--   <pre>
--   rd = |rn % rm|
--   </pre>
REMU :: Operand -> Operand -> Operand -> Instr

-- | High part of a multiplication that doesn't fit into 64bits (integer
--   only)
--   
--   E.g. for a multiplication with 64bits width: <tt>rd = (rs1 * rs2)
--   &gt;&gt; 64</tt>.
MULH :: Operand -> Operand -> Operand -> Instr

-- | Unsigned division (integer only)
--   
--   <pre>
--   rd = |rn ÷ rm|
--   </pre>
DIVU :: Operand -> Operand -> Operand -> Instr

-- | XOR (integer only)
--   
--   <pre>
--   rd = rn ⊕ op2
--   </pre>
XOR :: Operand -> Operand -> Operand -> Instr

-- | ORI with immediate (integer only)
--   
--   <pre>
--   rd = rn | op2
--   </pre>
ORI :: Operand -> Operand -> Operand -> Instr

-- | OR with immediate (integer only)
--   
--   <pre>
--   rd = rn ⊕ op2
--   </pre>
XORI :: Operand -> Operand -> Operand -> Instr

-- | Move to register (integer and floating point)
--   
--   <tt>rd = rn</tt> or <tt>rd = #imm</tt>
MOV :: Operand -> Operand -> Instr

-- | Pseudo-op for conditional setting of a register.
--   
--   <pre>
--   if(o2 cond o3) op &lt;- 1 else op &lt;- 0
--   </pre>
CSET :: Operand -> Operand -> Operand -> Cond -> Instr

-- | A jump instruction with data for switch/jump tables
J_TBL :: [Maybe BlockId] -> Maybe CLabel -> Reg -> Instr

-- | Unconditional jump (no linking)
B :: Target -> Instr

-- | Unconditional jump, links return address (sets
--   <tt>ra</tt>/<tt>x1</tt>)
BL :: Reg -> [Reg] -> Instr

-- | branch with condition (integer only)
BCOND :: Cond -> Operand -> Operand -> Target -> Instr

-- | Fence instruction
--   
--   Memory barrier.
FENCE :: FenceType -> FenceType -> Instr

-- | Floating point conversion
FCVT :: FcvtVariant -> Operand -> Operand -> Instr

-- | Floating point ABSolute value
FABS :: Operand -> Operand -> Instr

-- | Min dest = min(r1)
FMIN :: Operand -> Operand -> Operand -> Instr

-- | Max
FMAX :: Operand -> Operand -> Operand -> Instr

-- | Floating-point fused multiply-add instructions
--   
--   <ul>
--   <li>fmadd : d = r1 * r2 + r3</li>
--   <li>fnmsub: d = r1 * r2 - r3</li>
--   <li>fmsub : d = - r1 * r2 + r3</li>
--   <li>fnmadd: d = - r1 * r2 - r3</li>
--   </ul>
FMA :: FMASign -> Operand -> Operand -> Operand -> Operand -> Instr

-- | Operand of a FENCE instruction (<tt>r</tt>, <tt>w</tt> or <tt>rw</tt>)
data FenceType
FenceRead :: FenceType
FenceWrite :: FenceType
FenceReadWrite :: FenceType

-- | Variant of a floating point conversion instruction
data FcvtVariant
FloatToFloat :: FcvtVariant
IntToFloat :: FcvtVariant
FloatToInt :: FcvtVariant
instrCon :: Instr -> String
data Target
TBlock :: BlockId -> Target
TReg :: Reg -> Target
data Operand

-- | register
OpReg :: Width -> Reg -> Operand

-- | immediate value
OpImm :: Imm -> Operand

-- | memory reference
OpAddr :: AddrMode -> Operand
operandFromReg :: Reg -> Operand
operandFromRegNo :: RegNo -> Operand
zero :: Operand
ra :: Operand
sp :: Operand
gp :: Operand
tp :: Operand
fp :: Operand
tmp :: Operand
x0 :: Operand
x1 :: Operand
x2 :: Operand
x3 :: Operand
x4 :: Operand
x5 :: Operand
x6 :: Operand
x7 :: Operand
x8 :: Operand
x9 :: Operand
x10 :: Operand
x11 :: Operand
x12 :: Operand
x13 :: Operand
x14 :: Operand
x15 :: Operand
x16 :: Operand
x17 :: Operand
x18 :: Operand
x19 :: Operand
x20 :: Operand
x21 :: Operand
x22 :: Operand
x23 :: Operand
x24 :: Operand
x25 :: Operand
x26 :: Operand
x27 :: Operand
x28 :: Operand
x29 :: Operand
x30 :: Operand
x31 :: Operand
d0 :: Operand
d1 :: Operand
d2 :: Operand
d3 :: Operand
d4 :: Operand
d5 :: Operand
d6 :: Operand
d7 :: Operand
d8 :: Operand
d9 :: Operand
d10 :: Operand
d11 :: Operand
d12 :: Operand
d13 :: Operand
d14 :: Operand
d15 :: Operand
d16 :: Operand
d17 :: Operand
d18 :: Operand
d19 :: Operand
d20 :: Operand
d21 :: Operand
d22 :: Operand
d23 :: Operand
d24 :: Operand
d25 :: Operand
d26 :: Operand
d27 :: Operand
d28 :: Operand
d29 :: Operand
d30 :: Operand
d31 :: Operand
fitsIn12bitImm :: (Num a, Ord a) => a -> Bool
intMin12bit :: Num a => a
intMax12bit :: Num a => a
fitsIn32bits :: (Num a, Ord a, Bits a) => a -> Bool
isNbitEncodeable :: Int -> Integer -> Bool
isEncodeableInWidth :: Width -> Integer -> Bool
isIntOp :: Operand -> Bool
isFloatOp :: Operand -> Bool
isFloatReg :: Reg -> Bool
instance GHC.Classes.Eq GHC.CmmToAsm.RV64.Instr.Operand
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Instr.RegUsage
instance GHC.Internal.Show.Show GHC.CmmToAsm.RV64.Instr.Operand


-- | Minimum viable implementation of jump short-cutting: No short-cutting.
--   
--   The functions here simply implement the no-short-cutting case.
--   Implementing the real behaviour would be a great optimization in
--   future.
module GHC.CmmToAsm.RV64.RegInfo

-- | Extract BlockId
--   
--   Never <a>Nothing</a> for Riscv64 NCG.
getJumpDestBlockId :: JumpDest -> Maybe BlockId
canShortcut :: Instr -> Maybe JumpDest
shortcutStatics :: (BlockId -> Maybe JumpDest) -> RawCmmStatics -> RawCmmStatics
shortcutJump :: (BlockId -> Maybe JumpDest) -> Instr -> Instr
newtype JumpDest
DestBlockId :: BlockId -> JumpDest
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.RV64.RegInfo.JumpDest

module GHC.CmmToAsm.RV64.Ppr
pprNatCmmDecl :: IsDoc doc => NCGConfig -> NatCmmDecl RawCmmStatics Instr -> doc

-- | Pretty-print an <a>Instr</a>
--   
--   This function is partial and will panic if the <a>Instr</a> is not
--   supported. This can happen due to invalid operands or unexpected meta
--   instructions.
pprInstr :: IsDoc doc => Platform -> Instr -> doc

module GHC.CmmToAsm.CFG

-- | A control flow graph where edges have been annotated with a weight.
--   Implemented as IntMap (IntMap &lt;edgeData&gt;) We must uphold the
--   invariant that for each edge A -&gt; B we must have: A entry B in the
--   outer map. A entry B in the map we get when looking up A. Maintaining
--   this invariant is useful as any failed lookup now indicates an actual
--   error in code which might go unnoticed for a while otherwise.
type CFG = EdgeInfoMap EdgeInfo
data CfgEdge
CfgEdge :: !BlockId -> !BlockId -> !EdgeInfo -> CfgEdge
[edgeFrom] :: CfgEdge -> !BlockId
[edgeTo] :: CfgEdge -> !BlockId
[edgeInfo] :: CfgEdge -> !EdgeInfo

-- | Information about edges
data EdgeInfo
EdgeInfo :: !TransitionSource -> !EdgeWeight -> EdgeInfo
[transitionSource] :: EdgeInfo -> !TransitionSource
[edgeWeight] :: EdgeInfo -> !EdgeWeight
newtype EdgeWeight
EdgeWeight :: Double -> EdgeWeight
[weightToDouble] :: EdgeWeight -> Double

-- | Can we trace back a edge to a specific Cmm Node or has it been
--   introduced during assembly codegen. We use this to maintain some
--   information which would otherwise be lost during the Cmm &lt;-&gt; asm
--   transition. See also Note [Inverting conditions]
data TransitionSource
CmmSource :: CmmNode O C -> BranchInfo -> TransitionSource
[trans_cmmNode] :: TransitionSource -> CmmNode O C
[trans_info] :: TransitionSource -> BranchInfo
AsmCodeGen :: TransitionSource

-- | Adds a edge with the given weight to the cfg If there already existed
--   an edge it is overwritten. `addWeightEdge from to weight cfg`
addWeightEdge :: BlockId -> BlockId -> EdgeWeight -> CFG -> CFG

-- | Adds a new edge, overwrites existing edges if present
addEdge :: BlockId -> BlockId -> EdgeInfo -> CFG -> CFG
delEdge :: BlockId -> BlockId -> CFG -> CFG

-- | Insert a block in the control flow between two other blocks. We pass a
--   list of tuples (A,B,C) where * A -&gt; C: Old edge * A -&gt; B -&gt; C
--   : New Arc, where B is the new block. It's possible that a block has
--   two jumps to the same block in the assembly code. However we still
--   only store a single edge for these cases. We assign the old edge info
--   to the edge A -&gt; B and assign B -&gt; C the weight of an
--   unconditional jump.
addNodesBetween :: Weights -> CFG -> [(BlockId, BlockId, BlockId)] -> CFG
shortcutWeightMap :: LabelMap (Maybe BlockId) -> CFG -> CFG
reverseEdges :: CFG -> CFG

-- | Filter the CFG with a custom function f. Parameters are `f from to
--   edgeInfo`
filterEdges :: (BlockId -> BlockId -> EdgeInfo -> Bool) -> CFG -> CFG

-- | Sometimes we insert a block which should unconditionally be executed
--   after a given block. This function updates the CFG for these cases. So
--   we get A -&gt; B =&gt; A -&gt; A' -&gt; B -&gt; C =&gt; -&gt; C
addImmediateSuccessor :: Weights -> BlockId -> BlockId -> CFG -> CFG

-- | Convenience function, generate edge info based on weight not
--   originating from cmm.
mkWeightInfo :: EdgeWeight -> EdgeInfo

-- | Adjust the weight between the blocks using the given function. If
--   there is no such edge returns the original map.
adjustEdgeWeight :: CFG -> (EdgeWeight -> EdgeWeight) -> BlockId -> BlockId -> CFG

-- | Set the weight between the blocks to the given weight. If there is no
--   such edge returns the original map.
setEdgeWeight :: CFG -> EdgeWeight -> BlockId -> BlockId -> CFG

-- | Returns a unordered list of all edges with info
infoEdgeList :: CFG -> [CfgEdge]

-- | Returns a unordered list of all edges without weights
edgeList :: CFG -> [Edge]

-- | Get successors of a given node with edge weights.
getSuccessorEdges :: HasDebugCallStack => CFG -> BlockId -> [(BlockId, EdgeInfo)]

-- | Get successors of a given node without edge weights.
getSuccessors :: HasDebugCallStack => CFG -> BlockId -> [BlockId]

-- | Destinations from bid ordered by weight (descending)
getSuccEdgesSorted :: CFG -> BlockId -> [(BlockId, EdgeInfo)]
getEdgeInfo :: BlockId -> BlockId -> CFG -> Maybe EdgeInfo
getCfgNodes :: CFG -> [BlockId]

-- | Is this block part of this graph?
hasNode :: CFG -> BlockId -> Bool

-- | Determine loop membership of blocks based on SCC analysis This is
--   faster but only gives yes/no answers.
loopMembers :: HasDebugCallStack => CFG -> LabelMap Bool
loopLevels :: CFG -> BlockId -> LabelMap Int

-- | Determine loop membership of blocks based on Dominator analysis. This
--   is slower but gives loop levels instead of just loop membership.
--   However it only detects natural loops. Irreducible control flow is not
--   recognized even if it loops. But that is rare enough that we don't
--   have to care about that special case.
loopInfo :: HasDebugCallStack => CFG -> BlockId -> LoopInfo
getCfg :: Platform -> Weights -> CmmGraph -> CFG

-- | Generate weights for a Cmm proc based on some simple heuristics.
getCfgProc :: Platform -> Weights -> RawCmmDecl -> CFG
pprEdgeWeights :: CFG -> SDoc

-- | Check if the nodes in the cfg and the set of blocks are the same. In a
--   case of a mismatch we panic and show the difference.
sanityCheckCfg :: CFG -> LabelSet -> SDoc -> Bool
optimizeCFG :: Bool -> Weights -> RawCmmDecl -> CFG -> CFG

-- | We take in a CFG which has on its edges weights which are relative
--   only to other edges originating from the same node.
--   
--   We return a CFG for which each edge represents a GLOBAL weight. This
--   means edge weights are comparable across the whole graph.
--   
--   For irreducible control flow results might be imprecise, otherwise
--   they are reliable.
--   
--   The algorithm is based on the Paper "Static Branch Prediction and
--   Program Profile Analysis" by Y Wu, JR Larus The only big change is
--   that we go over the nodes in the body of loops in reverse post order.
--   Which is required for diamond control flow to work probably.
--   
--   We also apply a few prediction heuristics (based on the same paper)
--   
--   The returned result represents frequences. For blocks it's the
--   expected number of executions and for edges is the number of
--   traversals.
mkGlobalWeights :: HasDebugCallStack => BlockId -> CFG -> (LabelMap Double, LabelMap (LabelMap Double))
instance GHC.Internal.Enum.Enum GHC.CmmToAsm.CFG.EdgeWeight
instance GHC.Classes.Eq GHC.CmmToAsm.CFG.BranchInfo
instance GHC.Classes.Eq GHC.CmmToAsm.CFG.CfgEdge
instance GHC.Classes.Eq GHC.CmmToAsm.CFG.EdgeInfo
instance GHC.Classes.Eq GHC.CmmToAsm.CFG.EdgeWeight
instance GHC.Classes.Eq GHC.CmmToAsm.CFG.TransitionSource
instance GHC.Internal.Real.Fractional GHC.CmmToAsm.CFG.EdgeWeight
instance GHC.Cmm.Dataflow.Graph.NonLocal GHC.CmmToAsm.CFG.BlockNode
instance GHC.Internal.Num.Num GHC.CmmToAsm.CFG.EdgeWeight
instance GHC.Classes.Ord GHC.CmmToAsm.CFG.CfgEdge
instance GHC.Classes.Ord GHC.CmmToAsm.CFG.EdgeWeight
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.CFG.BranchInfo
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.CFG.CfgEdge
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.CFG.EdgeInfo
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.CFG.EdgeWeight
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.CFG.LoopInfo
instance GHC.Internal.Real.Real GHC.CmmToAsm.CFG.EdgeWeight

module GHC.CmmToAsm.AArch64.Regs
allMachRegNos :: [RegNo]
allocatableRegs :: Platform -> [RealReg]
allGpArgRegs :: [Reg]
allFpArgRegs :: [Reg]
data AddrMode
AddrRegReg :: Reg -> Reg -> AddrMode
AddrRegImm :: Reg -> Imm -> AddrMode
AddrReg :: Reg -> AddrMode
data Imm
ImmInt :: Int -> Imm
ImmInteger :: Integer -> Imm
ImmCLbl :: CLabel -> Imm
ImmLit :: FastString -> Imm
ImmIndex :: CLabel -> Int -> Imm
ImmFloat :: Rational -> Imm
ImmDouble :: Rational -> Imm
ImmConstantSum :: Imm -> Imm -> Imm
ImmConstantDiff :: Imm -> Imm -> Imm
strImmLit :: FastString -> Imm
litToImm :: CmmLit -> Imm

-- | regSqueeze_class reg Calculate the maximum number of register colors
--   that could be denied to a node of this class due to having this reg as
--   a neighbour.
virtualRegSqueeze :: RegClass -> VirtualReg -> Int
realRegSqueeze :: RegClass -> RealReg -> Int
mkVirtualReg :: Unique -> Format -> VirtualReg
classOfRealReg :: RealReg -> RegClass
regDotColor :: RealReg -> SDoc
instance GHC.Classes.Eq GHC.CmmToAsm.AArch64.Regs.AddrMode
instance GHC.Classes.Eq GHC.CmmToAsm.AArch64.Regs.Imm
instance GHC.Internal.Show.Show GHC.CmmToAsm.AArch64.Regs.AddrMode
instance GHC.Internal.Show.Show GHC.CmmToAsm.AArch64.Regs.Imm


-- | Hard wired things related to registers. This is module is preventing
--   the native code generator being able to emit code for non-host
--   architectures.
--   
--   TODO: Do a better job of the overloading, and eliminate this module.
--   We'd probably do better with a Register type class, and hook this to
--   Instruction somehow.
--   
--   TODO: We should also make arch specific versions of
--   RegAlloc.Graph.TrivColorable
module GHC.CmmToAsm.Reg.Target
targetVirtualRegSqueeze :: Platform -> RegClass -> VirtualReg -> Int
targetRealRegSqueeze :: Platform -> RegClass -> RealReg -> Int
targetClassOfRealReg :: Platform -> RealReg -> RegClass
targetMkVirtualReg :: Platform -> Unique -> Format -> VirtualReg
targetRegDotColor :: Platform -> RealReg -> SDoc
targetClassOfReg :: Platform -> Reg -> RegClass
mapRegFormatSet :: HasDebugCallStack => (Reg -> Reg) -> UniqSet RegWithFormat -> UniqSet RegWithFormat

module GHC.CmmToAsm.Reg.Liveness

-- | Map from some kind of register to a.
--   
--   While we give the type for keys as Reg which is the common case
--   sometimes we end up using VirtualReq or naked Uniques. See Note
--   [UniqFM and the register allocator]
type RegMap a = UniqFM Reg a
emptyRegMap :: RegMap a
type BlockMap a = LabelMap a

-- | A top level thing which carries liveness information.
type LiveCmmDecl statics instr = GenCmmDecl statics LiveInfo [SCC LiveBasicBlock instr]

-- | The register allocator also wants to use SPILL/RELOAD meta
--   instructions, so we'll keep those here.
data InstrSR instr

-- | A real machine instruction
Instr :: !instr -> InstrSR instr

-- | spill this reg to a stack slot
SPILL :: !RegWithFormat -> !Int -> InstrSR instr

-- | reload this reg from a stack slot
RELOAD :: !Int -> !RegWithFormat -> InstrSR instr

-- | An instruction with liveness information.
data LiveInstr instr
LiveInstr :: InstrSR instr -> Maybe Liveness -> LiveInstr instr

-- | Liveness information. The regs which die are ones which are no longer
--   live in the *next* instruction in this sequence. (NB. if the
--   instruction is a jump, these registers might still be live at the jump
--   target(s) - you have to check the liveness at the destination block to
--   find out).
data Liveness
Liveness :: UniqSet RegWithFormat -> UniqSet RegWithFormat -> UniqSet RegWithFormat -> Liveness

-- | registers born in this instruction (written to for first time).
[liveBorn] :: Liveness -> UniqSet RegWithFormat

-- | registers that died because they were read for the last time.
[liveDieRead] :: Liveness -> UniqSet RegWithFormat

-- | registers that died because they were clobbered by something.
[liveDieWrite] :: Liveness -> UniqSet RegWithFormat

-- | Stash regs live on entry to each basic block in the info part of the
--   cmm code.
data LiveInfo
LiveInfo :: LabelMap RawCmmStatics -> [BlockId] -> BlockMap (UniqSet RegWithFormat) -> BlockMap IntSet -> LiveInfo

-- | A basic block with liveness information.
type LiveBasicBlock instr = GenBasicBlock LiveInstr instr

-- | map a function across all the basic blocks in this code
mapBlockTop :: (LiveBasicBlock instr -> LiveBasicBlock instr) -> LiveCmmDecl statics instr -> LiveCmmDecl statics instr

-- | map a function across all the basic blocks in this code (monadic
--   version)
mapBlockTopM :: Monad m => (LiveBasicBlock instr -> m (LiveBasicBlock instr)) -> LiveCmmDecl statics instr -> m (LiveCmmDecl statics instr)
mapSCCM :: Monad m => (a -> m b) -> SCC a -> m (SCC b)
mapGenBlockTop :: (GenBasicBlock i -> GenBasicBlock i) -> GenCmmDecl d h (ListGraph i) -> GenCmmDecl d h (ListGraph i)

-- | map a function across all the basic blocks in this code (monadic
--   version)
mapGenBlockTopM :: Monad m => (GenBasicBlock i -> m (GenBasicBlock i)) -> GenCmmDecl d h (ListGraph i) -> m (GenCmmDecl d h (ListGraph i))

-- | Map over instruction type in <a>LiveCmmDecl</a>
mapLiveCmmDecl :: (instr -> b) -> LiveCmmDecl statics instr -> LiveCmmDecl statics b

-- | Pretty-print a <a>LiveCmmDecl</a>
pprLiveCmmDecl :: (OutputableP Platform statics, Instruction instr) => Platform -> LiveCmmDecl statics instr -> SDoc

-- | Strip away liveness information, yielding NatCmmDecl
stripLive :: (OutputableP Platform statics, Instruction instr) => NCGConfig -> LiveCmmDecl statics instr -> NatCmmDecl statics instr

-- | Strip away liveness information from a basic block, and make real
--   spill instructions out of SPILL, RELOAD pseudos along the way.
stripLiveBlock :: Instruction instr => NCGConfig -> LiveBasicBlock instr -> NatBasicBlock instr

-- | Slurp out the list of register conflicts and reg-reg moves from this
--   top level thing. Slurping of conflicts and moves is wrapped up
--   together so we don't have to make two passes over the same code when
--   we want to build the graph.
slurpConflicts :: Instruction instr => Platform -> LiveCmmDecl statics instr -> (Bag (UniqSet RegWithFormat), Bag (Reg, Reg))

-- | For spill/reloads
--   
--   SPILL v1, slot1 ... RELOAD slot1, v2
--   
--   If we can arrange that v1 and v2 are allocated to the same hreg it's
--   more likely the spill/reload instrs can be cleaned and replaced by a
--   nop reg-reg move.
slurpReloadCoalesce :: forall statics instr. Instruction instr => LiveCmmDecl statics instr -> Bag (Reg, Reg)

-- | Erase Delta instructions.
eraseDeltasLive :: Instruction instr => LiveCmmDecl statics instr -> LiveCmmDecl statics instr

-- | Patch the registers in this code according to this register mapping.
--   also erase reg -&gt; reg moves when the reg is the same. also erase
--   reg -&gt; reg moves when the destination dies in this instr.
patchEraseLive :: (Instruction instr, HasDebugCallStack) => Platform -> (Reg -> Reg) -> LiveCmmDecl statics instr -> LiveCmmDecl statics instr

-- | Patch registers in this LiveInstr, including the liveness information.
patchRegsLiveInstr :: (Instruction instr, HasDebugCallStack) => Platform -> (Reg -> Reg) -> LiveInstr instr -> LiveInstr instr

-- | If we've compute liveness info for this code already we have to
--   reverse the SCCs in each top to get them back to the right order so we
--   can do it again.
reverseBlocksInTops :: LiveCmmDecl statics instr -> LiveCmmDecl statics instr
regLiveness :: Instruction instr => Platform -> LiveCmmDecl statics instr -> UniqDSM (LiveCmmDecl statics instr)

-- | Convert a NatCmmDecl to a LiveCmmDecl, with liveness information
cmmTopLiveness :: Instruction instr => Maybe CFG -> Platform -> NatCmmDecl statics instr -> UniqDSM (LiveCmmDecl statics instr)
instance GHC.Internal.Base.Functor GHC.CmmToAsm.Reg.Liveness.InstrSR
instance GHC.Internal.Base.Functor GHC.CmmToAsm.Reg.Liveness.LiveInstr
instance GHC.CmmToAsm.Instr.Instruction instr => GHC.CmmToAsm.Instr.Instruction (GHC.CmmToAsm.Reg.Liveness.InstrSR instr)
instance GHC.Utils.Outputable.Outputable instr => GHC.Utils.Outputable.Outputable (GHC.CmmToAsm.Reg.Liveness.InstrSR instr)
instance GHC.Utils.Outputable.Outputable instr => GHC.Utils.Outputable.Outputable (GHC.CmmToAsm.Reg.Liveness.LiveInstr instr)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.CmmToAsm.Reg.Liveness.LiveInfo
instance GHC.Utils.Outputable.OutputableP env instr => GHC.Utils.Outputable.OutputableP env (GHC.CmmToAsm.Reg.Liveness.LiveInstr instr)


-- | Put common type definitions here to break recursive module
--   dependencies.
module GHC.CmmToAsm.Reg.Linear.Base

-- | Used to store the register assignment on entry to a basic block. We
--   use this to handle join points, where multiple branch instructions
--   target a particular label. We have to insert fixup code to make the
--   register assignments from the different sources match up.
data BlockAssignment freeRegs

-- | Find the register mapping for a specific BlockId.
lookupBlockAssignment :: BlockId -> BlockAssignment freeRegs -> Maybe (freeRegs, RegMap Loc)

-- | Lookup which register a virtual register was first assigned to.
lookupFirstUsed :: VirtualReg -> BlockAssignment freeRegs -> Maybe RealReg

-- | An initial empty <a>BlockAssignment</a>
emptyBlockAssignment :: BlockAssignment freeRegs

-- | Add new register mappings for a specific block.
updateBlockAssignment :: BlockId -> (freeRegs, RegMap Loc) -> BlockAssignment freeRegs -> BlockAssignment freeRegs

-- | Where a vreg is currently stored A temporary can be marked as living
--   in both a register and memory (InBoth), for example if it was recently
--   loaded from a spill location. This makes it cheap to spill (no save
--   instruction required), but we have to be careful to turn this into
--   InReg if the value in the register is changed.
data Loc

-- | vreg is in a register
InReg :: {-# UNPACK #-} !RealRegUsage -> Loc

-- | vreg is held in stack slots
InMem :: {-# UNPACK #-} !StackSlot -> Loc

-- | vreg is held in both a register and stack slots
InBoth :: {-# UNPACK #-} !RealRegUsage -> {-# UNPACK #-} !StackSlot -> Loc

-- | Get the reg numbers stored in this Loc.
regsOfLoc :: Loc -> [RealRegUsage]

-- | A <a>RealReg</a>, together with the specific <a>Format</a> it is used
--   at.
data RealRegUsage
RealRegUsage :: !RealReg -> !Format -> RealRegUsage
[realReg] :: RealRegUsage -> !RealReg
[realRegFormat] :: RealRegUsage -> !Format

-- | Reasons why instructions might be inserted by the spiller. Used when
--   generating stats for -ddrop-asm-stats.
data SpillReason

-- | vreg was spilled to a slot so we could use its current hreg for
--   another vreg
SpillAlloc :: !Unique -> SpillReason

-- | vreg was moved because its hreg was clobbered
SpillClobber :: !Unique -> SpillReason

-- | vreg was loaded from a spill slot
SpillLoad :: !Unique -> SpillReason

-- | reg-reg move inserted during join to targets
SpillJoinRR :: !Unique -> SpillReason

-- | reg-mem move inserted during join to targets
SpillJoinRM :: !Unique -> SpillReason

-- | Used to carry interesting stats out of the register allocator.
data RegAllocStats
RegAllocStats :: UniqFM Unique [Int] -> [(BlockId, BlockId, BlockId)] -> RegAllocStats
[ra_spillInstrs] :: RegAllocStats -> UniqFM Unique [Int]

-- | (from,fixup,to) : We inserted fixup code between from and to
[ra_fixupList] :: RegAllocStats -> [(BlockId, BlockId, BlockId)]

-- | The register allocator state
data RA_State freeRegs
RA_State :: BlockAssignment freeRegs -> !freeRegs -> RegMap Loc -> Int -> StackMap -> DUniqSupply -> [SpillReason] -> !NCGConfig -> [(BlockId, BlockId, BlockId)] -> RA_State freeRegs

-- | the current mapping from basic blocks to the register assignments at
--   the beginning of that block.
[ra_blockassig] :: RA_State freeRegs -> BlockAssignment freeRegs

-- | free machine registers
[ra_freeregs] :: RA_State freeRegs -> !freeRegs

-- | assignment of temps to locations
[ra_assig] :: RA_State freeRegs -> RegMap Loc

-- | current stack delta
[ra_delta] :: RA_State freeRegs -> Int

-- | free stack slots for spilling
[ra_stack] :: RA_State freeRegs -> StackMap

-- | unique supply for generating names for join point fixup blocks.
[ra_us] :: RA_State freeRegs -> DUniqSupply

-- | Record why things were spilled, for -ddrop-asm-stats. Just keep a list
--   here instead of a map of regs -&gt; reasons. We don't want to slow
--   down the allocator if we're not going to emit the stats.
[ra_spills] :: RA_State freeRegs -> [SpillReason]

-- | Native code generator configuration
[ra_config] :: RA_State freeRegs -> !NCGConfig

-- | (from,fixup,to) : We inserted fixup code between from and to
[ra_fixups] :: RA_State freeRegs -> [(BlockId, BlockId, BlockId)]
instance GHC.Classes.Eq GHC.CmmToAsm.Reg.Linear.Base.Loc
instance GHC.Classes.Eq GHC.CmmToAsm.Reg.Linear.Base.ReadingOrWriting
instance GHC.Classes.Eq GHC.CmmToAsm.Reg.Linear.Base.RealRegUsage
instance GHC.Classes.Ord GHC.CmmToAsm.Reg.Linear.Base.Loc
instance GHC.Classes.Ord GHC.CmmToAsm.Reg.Linear.Base.ReadingOrWriting
instance GHC.Classes.Ord GHC.CmmToAsm.Reg.Linear.Base.RealRegUsage
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Linear.Base.Loc
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Linear.Base.RealRegUsage
instance GHC.Internal.Show.Show GHC.CmmToAsm.Reg.Linear.Base.Loc
instance GHC.Internal.Show.Show GHC.CmmToAsm.Reg.Linear.Base.RealRegUsage

module GHC.CmmToAsm.Reg.Linear.Stats

-- | Build a map of how many times each reg was alloced, clobbered, loaded
--   etc.
binSpillReasons :: [SpillReason] -> UniqFM Unique [Int]

-- | Count reg-reg moves remaining in this code.
countRegRegMovesNat :: Instruction instr => Platform -> NatCmmDecl statics instr -> Int

-- | Pretty print some RegAllocStats
pprStats :: Instruction instr => Platform -> [NatCmmDecl statics instr] -> [RegAllocStats] -> SDoc


-- | State monad for the linear register allocator.
module GHC.CmmToAsm.Reg.Linear.State

-- | The register allocator state
data RA_State freeRegs
RA_State :: BlockAssignment freeRegs -> !freeRegs -> RegMap Loc -> Int -> StackMap -> DUniqSupply -> [SpillReason] -> !NCGConfig -> [(BlockId, BlockId, BlockId)] -> RA_State freeRegs

-- | the current mapping from basic blocks to the register assignments at
--   the beginning of that block.
[ra_blockassig] :: RA_State freeRegs -> BlockAssignment freeRegs

-- | free machine registers
[ra_freeregs] :: RA_State freeRegs -> !freeRegs

-- | assignment of temps to locations
[ra_assig] :: RA_State freeRegs -> RegMap Loc

-- | current stack delta
[ra_delta] :: RA_State freeRegs -> Int

-- | free stack slots for spilling
[ra_stack] :: RA_State freeRegs -> StackMap

-- | unique supply for generating names for join point fixup blocks.
[ra_us] :: RA_State freeRegs -> DUniqSupply

-- | Record why things were spilled, for -ddrop-asm-stats. Just keep a list
--   here instead of a map of regs -&gt; reasons. We don't want to slow
--   down the allocator if we're not going to emit the stats.
[ra_spills] :: RA_State freeRegs -> [SpillReason]

-- | Native code generator configuration
[ra_config] :: RA_State freeRegs -> !NCGConfig

-- | (from,fixup,to) : We inserted fixup code between from and to
[ra_fixups] :: RA_State freeRegs -> [(BlockId, BlockId, BlockId)]

-- | The register allocator monad type.
data RegM freeRegs a

-- | Run a computation in the RegM register allocator monad.
runR :: NCGConfig -> BlockAssignment freeRegs -> freeRegs -> RegMap Loc -> StackMap -> DUniqSupply -> RegM freeRegs a -> (BlockAssignment freeRegs, StackMap, RegAllocStats, a, DUniqSupply)
spillR :: Instruction instr => RegWithFormat -> Unique -> RegM freeRegs ([instr], Int)
loadR :: Instruction instr => RegWithFormat -> Int -> RegM freeRegs [instr]
getFreeRegsR :: RegM freeRegs freeRegs
setFreeRegsR :: freeRegs -> RegM freeRegs ()
getAssigR :: RegM freeRegs (RegMap Loc)
setAssigR :: RegMap Loc -> RegM freeRegs ()
getBlockAssigR :: RegM freeRegs (BlockAssignment freeRegs)
setBlockAssigR :: BlockAssignment freeRegs -> RegM freeRegs ()
setDeltaR :: Int -> RegM freeRegs ()
getDeltaR :: RegM freeRegs Int
getUniqueR :: RegM freeRegs Unique

-- | Get native code generator configuration
getConfig :: RegM a NCGConfig

-- | Get target platform from native code generator configuration
getPlatform :: RegM a Platform

-- | Record that a spill instruction was inserted, for profiling.
recordSpill :: SpillReason -> RegM freeRegs ()

-- | Record a created fixup block
recordFixupBlock :: BlockId -> BlockId -> BlockId -> RegM freeRegs ()
instance GHC.Internal.Base.Applicative (GHC.CmmToAsm.Reg.Linear.State.RegM freeRegs)
instance GHC.Internal.Base.Functor (GHC.CmmToAsm.Reg.Linear.State.RegM freeRegs)
instance GHC.Internal.Base.Monad (GHC.CmmToAsm.Reg.Linear.State.RegM freeRegs)

module GHC.CmmToAsm.Reg.Graph.SpillCost

-- | Records the expected cost to spill some register.
type SpillCostRecord = (VirtualReg, Int, Int, Int)

-- | Add two spill cost records.
plusSpillCostRecord :: SpillCostRecord -> SpillCostRecord -> SpillCostRecord

-- | Show a spill cost record, including the degree from the graph and
--   final calculated spill cost.
pprSpillCostRecord :: (VirtualReg -> RegClass) -> (Reg -> SDoc) -> Graph VirtualReg RegClass RealReg -> SpillCostRecord -> SDoc

-- | Map of <a>SpillCostRecord</a>
type SpillCostInfo = UniqFM VirtualReg SpillCostRecord

-- | An empty map of spill costs.
zeroSpillCostInfo :: SpillCostInfo

-- | Add two spill cost infos.
plusSpillCostInfo :: SpillCostInfo -> SpillCostInfo -> SpillCostInfo

-- | Slurp out information used for determining spill costs.
--   
--   For each vreg, the number of times it was written to, read from, and
--   the number of instructions it was live on entry to (lifetime)
slurpSpillCostInfo :: Instruction instr => Platform -> Maybe CFG -> LiveCmmDecl statics instr -> SpillCostInfo

-- | Choose a node to spill from this graph
chooseSpill :: SpillCostInfo -> Graph VirtualReg RegClass RealReg -> VirtualReg

-- | Extract a map of register lifetimes from a <a>SpillCostInfo</a>.
lifeMapFromSpillCostInfo :: SpillCostInfo -> UniqFM VirtualReg (VirtualReg, Int)


-- | Clean out unneeded spill/reload instructions.
--   
--   Handling of join points ~~~~~~~~~~~~~~~~~~~~~~~
--   
--   <pre>
--   B1:                          B2:
--    ...                          ...
--       RELOAD SLOT(0), %r1          RELOAD SLOT(0), %r1
--       ... A ...                    ... B ...
--       jump B3                      jump B3
--   
--                B3: ... C ...
--                    RELOAD SLOT(0), %r1
--                    ...
--   
--   </pre>
--   
--   The Plan ~~~~~~~~
--   
--   As long as %r1 hasn't been written to in A, B or C then we don't need
--   the reload in B3.
--   
--   What we really care about here is that on the entry to B3, %r1 will
--   always have the same value that is in SLOT(0) (ie, %r1 is _valid_)
--   
--   This also works if the reloads in B1/B2 were spills instead, because
--   spilling %r1 to a slot makes that slot have the same value as %r1.
module GHC.CmmToAsm.Reg.Graph.SpillClean

-- | Clean out unneeded spill/reloads from this top level thing.
cleanSpills :: Instruction instr => NCGConfig -> LiveCmmDecl statics instr -> LiveCmmDecl statics instr
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Graph.SpillClean.Store
instance GHC.Types.Unique.Uniquable GHC.CmmToAsm.Reg.Graph.SpillClean.Store


-- | When there aren't enough registers to hold all the vregs we have to
--   spill some of those vregs to slots on the stack. This module is used
--   modify the code to use those slots.
module GHC.CmmToAsm.Reg.Graph.Spill

-- | Spill all these virtual regs to stack slots.
--   
--   Bumps the number of required stack slots if required.
--   
--   TODO: See if we can split some of the live ranges instead of just
--   globally spilling the virtual reg. This might make the spill cleaner's
--   job easier.
--   
--   TODO: On CISCy x86 and x86_64 we don't necessarily have to add a mov
--   instruction when making spills. If an instr is using a spilled virtual
--   we may be able to address the spill slot directly.
regSpill :: Instruction instr => Platform -> [LiveCmmDecl statics instr] -> UniqSet Int -> Int -> UniqSet VirtualReg -> UniqDSM ([LiveCmmDecl statics instr], UniqSet Int, Int, SpillStats)

-- | Spiller statistics. Tells us what registers were spilled.
data SpillStats
SpillStats :: UniqFM Reg (Reg, Int, Int) -> SpillStats
[spillStoreLoad] :: SpillStats -> UniqFM Reg (Reg, Int, Int)

-- | Add a spill/reload count to a stats record for a register.
accSpillSL :: (Reg, Int, Int) -> (Reg, Int, Int) -> (Reg, Int, Int)
instance GHC.Types.Unique.DSM.MonadGetUnique GHC.CmmToAsm.Reg.Graph.Spill.SpillM
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Graph.Spill.SpillStats


-- | Register coalescing.
module GHC.CmmToAsm.Reg.Graph.Coalesce

-- | Do register coalescing on this top level thing
--   
--   For Reg -&gt; Reg moves, if the first reg dies at the same time the
--   second reg is born then the mov only serves to join live ranges. The
--   two regs can be renamed to be the same and the move instruction safely
--   erased.
regCoalesce :: Instruction instr => Platform -> [LiveCmmDecl statics instr] -> UniqSM [LiveCmmDecl statics instr]

-- | Slurp out mov instructions that only serve to join live ranges.
--   
--   During a mov, if the source reg dies and the destination reg is born
--   then we can rename the two regs to the same thing and eliminate the
--   move.
slurpJoinMovs :: Instruction instr => Platform -> LiveCmmDecl statics instr -> Bag (Reg, Reg)


-- | Carries interesting info for debugging / profiling of the graph
--   coloring register allocator.
module GHC.CmmToAsm.Reg.Graph.Stats

-- | Holds interesting statistics from the register allocator.
data RegAllocStats statics instr
RegAllocStatsStart :: [LiveCmmDecl statics instr] -> Graph VirtualReg RegClass RealReg -> SpillCostInfo -> !Platform -> RegAllocStats statics instr

-- | Initial code, with liveness.
[raLiveCmm] :: RegAllocStats statics instr -> [LiveCmmDecl statics instr]

-- | The initial, uncolored graph.
[raGraph] :: RegAllocStats statics instr -> Graph VirtualReg RegClass RealReg

-- | Information to help choose which regs to spill.
[raSpillCosts] :: RegAllocStats statics instr -> SpillCostInfo

-- | Target platform
[raPlatform] :: RegAllocStats statics instr -> !Platform
RegAllocStatsSpill :: [LiveCmmDecl statics instr] -> Graph VirtualReg RegClass RealReg -> UniqFM VirtualReg VirtualReg -> SpillStats -> SpillCostInfo -> [LiveCmmDecl statics instr] -> !Platform -> RegAllocStats statics instr

-- | Code we tried to allocate registers for.
[raCode] :: RegAllocStats statics instr -> [LiveCmmDecl statics instr]

-- | The initial, uncolored graph.
[raGraph] :: RegAllocStats statics instr -> Graph VirtualReg RegClass RealReg

-- | The regs that were coalesced.
[raCoalesced] :: RegAllocStats statics instr -> UniqFM VirtualReg VirtualReg

-- | Spiller stats.
[raSpillStats] :: RegAllocStats statics instr -> SpillStats

-- | Information to help choose which regs to spill.
[raSpillCosts] :: RegAllocStats statics instr -> SpillCostInfo

-- | Code with spill instructions added.
[raSpilled] :: RegAllocStats statics instr -> [LiveCmmDecl statics instr]

-- | Target platform
[raPlatform] :: RegAllocStats statics instr -> !Platform
RegAllocStatsColored :: [LiveCmmDecl statics instr] -> Graph VirtualReg RegClass RealReg -> Graph VirtualReg RegClass RealReg -> UniqFM VirtualReg VirtualReg -> [LiveCmmDecl statics instr] -> [LiveCmmDecl statics instr] -> [LiveCmmDecl statics instr] -> [NatCmmDecl statics instr] -> (Int, Int, Int) -> !Platform -> RegAllocStats statics instr

-- | Code we tried to allocate registers for.
[raCode] :: RegAllocStats statics instr -> [LiveCmmDecl statics instr]

-- | The initial, uncolored graph.
[raGraph] :: RegAllocStats statics instr -> Graph VirtualReg RegClass RealReg

-- | Coalesced and colored graph.
[raGraphColored] :: RegAllocStats statics instr -> Graph VirtualReg RegClass RealReg

-- | The regs that were coalesced.
[raCoalesced] :: RegAllocStats statics instr -> UniqFM VirtualReg VirtualReg

-- | Code with coalescings applied.
[raCodeCoalesced] :: RegAllocStats statics instr -> [LiveCmmDecl statics instr]

-- | Code with vregs replaced by hregs.
[raPatched] :: RegAllocStats statics instr -> [LiveCmmDecl statics instr]

-- | Code with unneeded spill/reloads cleaned out.
[raSpillClean] :: RegAllocStats statics instr -> [LiveCmmDecl statics instr]

-- | Final code.
[raFinal] :: RegAllocStats statics instr -> [NatCmmDecl statics instr]

-- | Spill/reload/reg-reg moves present in this code.
[raSRMs] :: RegAllocStats statics instr -> (Int, Int, Int)

-- | Target platform
[raPlatform] :: RegAllocStats statics instr -> !Platform

-- | Do all the different analysis on this list of RegAllocStats
pprStats :: [RegAllocStats statics instr] -> Graph VirtualReg RegClass RealReg -> SDoc

-- | Dump a table of how many spill loads / stores were inserted for each
--   vreg.
pprStatsSpills :: [RegAllocStats statics instr] -> SDoc

-- | Dump a table of how long vregs tend to live for in the initial code.
pprStatsLifetimes :: [RegAllocStats statics instr] -> SDoc

-- | Dump a table of how many conflicts vregs tend to have in the initial
--   code.
pprStatsConflict :: [RegAllocStats statics instr] -> SDoc

-- | For every vreg, dump how many conflicts it has, and its lifetime. Good
--   for making a scatter plot.
pprStatsLifeConflict :: [RegAllocStats statics instr] -> Graph VirtualReg RegClass RealReg -> SDoc

-- | Count spill<i>reload</i>reg-reg moves. Lets us see how well the
--   register allocator has done.
countSRMs :: Instruction instr => Platform -> LiveCmmDecl statics instr -> (Int, Int, Int)
addSRM :: (Int, Int, Int) -> (Int, Int, Int) -> (Int, Int, Int)
instance GHC.Internal.Base.Functor (GHC.CmmToAsm.Reg.Graph.Stats.RegAllocStats statics)
instance (GHC.Utils.Outputable.OutputableP GHC.Platform.Platform statics, GHC.Utils.Outputable.OutputableP GHC.Platform.Platform instr) => GHC.Utils.Outputable.Outputable (GHC.CmmToAsm.Reg.Graph.Stats.RegAllocStats statics instr)


-- | Graph coloring register allocator.
module GHC.CmmToAsm.Reg.Graph

-- | The top level of the graph coloring register allocator.
regAlloc :: (OutputableP Platform statics, Instruction instr) => NCGConfig -> UniqFM RegClass (UniqSet RealReg) -> UniqSet Int -> Int -> [LiveCmmDecl statics instr] -> Maybe CFG -> UniqDSM ([NatCmmDecl statics instr], Maybe Int, [RegAllocStats statics instr])

module GHC.CmmToAsm.Reg.Linear.AArch64

-- | Armv6 | Armv7-A | Armv8-A AArch64 | | SIMD extension | NEON | NEON |
--   |===========================================================================|
--   | - Operates on 32-bit | - Separate reg. bank, | - Separate reg. bank,
--   | | GP ARM registers | 32x64-bit NEON regs | 32x128-bit NEON regs | |
--   - 8-bit<i>16-bit integer | - 8</i>16<i>32</i>64-bit int | -
--   8<i>16</i>32/64-bit int | | | - Single precision fp | - Single
--   precision fp | | | | - Double precision fp | | | | - Single/Double fp
--   are | | | | IEEE compliant | | - 2x16-bit/4x8-bit ops | - Up to
--   16x8-bit ops | - Up to 16x8-bit ops | | per instruction | per
--   instruction | per instruction |
--   '---------------------------------------------------------------------------'
data FreeRegs
FreeRegs :: !Word32 -> !Word32 -> FreeRegs
noFreeRegs :: FreeRegs
showBits :: Word32 -> String
allocateReg :: HasDebugCallStack => RealReg -> FreeRegs -> FreeRegs
getFreeRegs :: RegClass -> FreeRegs -> [RealReg]
initFreeRegs :: Platform -> FreeRegs
releaseReg :: HasDebugCallStack => RealReg -> FreeRegs -> FreeRegs
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Linear.AArch64.FreeRegs
instance GHC.Internal.Show.Show GHC.CmmToAsm.Reg.Linear.AArch64.FreeRegs

module GHC.CmmToAsm.AArch64.Instr

-- | LR and FP (8 byte each) are the prologue of each stack frame
stackFrameHeaderSize :: Int

-- | All registers are 8 byte wide.
spillSlotSize :: Int

-- | The number of bytes that the stack pointer should be aligned to.
stackAlign :: Int

-- | The number of spill slots available without allocating more.
maxSpillSlots :: NCGConfig -> Int

-- | Convert a spill slot number to a *byte* offset, with no sign.
spillSlotToOffset :: NCGConfig -> Int -> Int
regUsageOfInstr :: Platform -> Instr -> RegUsage

-- | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
--   16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 |
--   30 | 31 | | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 42
--   | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57
--   | 58 | 59 | 60 | 61 | 62 | 63 | |== General Purpose registers
--   ==================================================================================================================================|
--   | <a>argument passing -------------</a> | IR | <a>tmp registers
--   --------</a> | IP0| IP1| PL | <a>callee saved ------------</a> | FP |
--   LR | SP | | <a>free registers
--   --------------------------------------------------------------------</a>
--   | BR | Sp | Hp | R1 | R2 | R3 | R4 | R5 | R6 | SL | -- | -- | -- | |==
--   SIMD/FP Registers
--   ==========================================================================================================================================|
--   | <a>argument passing -------------</a> | <a>callee saved (lower 64
--   bits) ---</a> | <a>caller saved ----------------------</a> | | <a>free
--   registers -------------</a> | F1 | F2 | F3 | F4 | D1 | D2 | D3 | D4 |
--   <a>free registers
--   -----------------------------------------------------</a> |
--   '---------------------------------------------------------------------------------------------------------------------------------------------------------------'
--   IR: Indirect result location register, IP: Intra-procedure register,
--   PL: Platform register, FP: Frame pointer, LR: Link register, SP: Stack
--   pointer BR: Base, SL: SpLim
--   
--   TODO: The zero register is currently mapped to -1 but should get it's
--   own separate number.
callerSavedRegisters :: [Reg]

-- | Apply a given mapping to all the register references in this
--   instruction.
patchRegsOfInstr :: Instr -> (Reg -> Reg) -> Instr

-- | Checks whether this instruction is a jump/branch instruction. One that
--   can change the flow of control in a way that the register allocator
--   needs to worry about.
isJumpishInstr :: Instr -> Bool

-- | Checks whether this instruction is a jump/branch instruction. One that
--   can change the flow of control in a way that the register allocator
--   needs to worry about.
jumpDestsOfInstr :: Instr -> [BlockId]
canFallthroughTo :: Instr -> BlockId -> Bool

-- | Change the destination of this jump instruction. Used in the linear
--   allocator when adding fixup blocks for join points.
patchJumpInstr :: Instr -> (BlockId -> BlockId) -> Instr

-- | An instruction to spill a register into a spill slot.
mkSpillInstr :: HasCallStack => NCGConfig -> RegWithFormat -> Int -> Int -> [Instr]
mkLoadInstr :: NCGConfig -> RegWithFormat -> Int -> Int -> [Instr]

-- | See if this instruction is telling us the current C stack delta
takeDeltaInstr :: Instr -> Maybe Int
isMetaInstr :: Instr -> Bool

-- | Copy the value in a register to another one. Must work for all
--   register classes.
mkRegRegMoveInstr :: Format -> Reg -> Reg -> Instr

-- | Take the source and destination registers from a move instruction of
--   same register class (<a>RegClass</a>).
--   
--   The idea is to identify moves that can be eliminated by the register
--   allocator: If the source register serves no special purpose, one could
--   continue using it; saving one move instruction. For this, the register
--   kinds (classes) must be the same (no conversion involved.)
takeRegRegMoveInstr :: Instr -> Maybe (Reg, Reg)

-- | Make an unconditional jump instruction.
mkJumpInstr :: BlockId -> [Instr]
mkStackAllocInstr :: Platform -> Int -> [Instr]
mkStackDeallocInstr :: Platform -> Int -> [Instr]
allocMoreStack :: Platform -> Int -> NatCmmDecl statics Instr -> UniqDSM (NatCmmDecl statics Instr, [(BlockId, BlockId)])
data Instr
COMMENT :: SDoc -> Instr
MULTILINE_COMMENT :: SDoc -> Instr
ANN :: SDoc -> Instr -> Instr
LOCATION :: Int -> Int -> Int -> String -> Instr
NEWBLOCK :: BlockId -> Instr
DELTA :: Int -> Instr
SXTB :: Operand -> Operand -> Instr
UXTB :: Operand -> Operand -> Instr
SXTH :: Operand -> Operand -> Instr
UXTH :: Operand -> Operand -> Instr

-- | SXTW Operand Operand | SXTX Operand Operand
PUSH_STACK_FRAME :: Instr
POP_STACK_FRAME :: Instr

-- | ADC Operand Operand Operand -- rd = rn + rm + C | ADCS ...
ADD :: Operand -> Operand -> Operand -> Instr

-- | ADDS Operand Operand Operand -- rd = rn + rm | ADR ... | ADRP ...
CMP :: Operand -> Operand -> Instr
CMN :: Operand -> Operand -> Instr

-- | MADD ... | MNEG ...
MSUB :: Operand -> Operand -> Operand -> Operand -> Instr
MUL :: Operand -> Operand -> Operand -> Instr
NEG :: Operand -> Operand -> Instr

-- | NEGS ... | NGC ... | NGCS ... | SBC ... | SBCS ...
SDIV :: Operand -> Operand -> Operand -> Instr

-- | SMADDL ... | SMNEGL ... | SMSUBL ...
SMULH :: Operand -> Operand -> Operand -> Instr
SMULL :: Operand -> Operand -> Operand -> Instr
SUB :: Operand -> Operand -> Operand -> Instr

-- | SUBS ...
UDIV :: Operand -> Operand -> Operand -> Instr

-- | UMADDL ... -- Xd = Xa + Wn × Wm | UMNEGL ... -- Xd = - Wn × Wm |
--   UMSUBL ... -- Xd = Xa - Wn × Wm
UMULH :: Operand -> Operand -> Operand -> Instr
UMULL :: Operand -> Operand -> Operand -> Instr
SBFM :: Operand -> Operand -> Operand -> Operand -> Instr
UBFM :: Operand -> Operand -> Operand -> Operand -> Instr
SBFX :: Operand -> Operand -> Operand -> Operand -> Instr
UBFX :: Operand -> Operand -> Operand -> Operand -> Instr
CLZ :: Operand -> Operand -> Instr
RBIT :: Operand -> Operand -> Instr
REV :: Operand -> Operand -> Instr
REV16 :: Operand -> Operand -> Instr

-- | REV32 Operand Operand -- rd = reverseBytes32(rn) - 64bit operands
--   only! -- 0xAABBCCDD_EEFFGGHH -&gt; 0XDDCCBBAA_HHGGFFEE
AND :: Operand -> Operand -> Operand -> Instr
ASR :: Operand -> Operand -> Operand -> Instr
EOR :: Operand -> Operand -> Operand -> Instr
LSL :: Operand -> Operand -> Operand -> Instr
LSR :: Operand -> Operand -> Operand -> Instr
MOV :: Operand -> Operand -> Instr
MOVK :: Operand -> Operand -> Instr

-- | MOVN Operand Operand
MOVZ :: Operand -> Operand -> Instr
MVN :: Operand -> Operand -> Instr
ORR :: Operand -> Operand -> Operand -> Instr
STR :: Format -> Operand -> Operand -> Instr
STLR :: Format -> Operand -> Operand -> Instr
LDR :: Format -> Operand -> Operand -> Instr
LDAR :: Format -> Operand -> Operand -> Instr
CSET :: Operand -> Cond -> Instr
CBZ :: Operand -> Target -> Instr
CBNZ :: Operand -> Target -> Instr
J :: Target -> Instr
B :: Target -> Instr
BL :: Target -> [Reg] -> Instr
BCOND :: Cond -> Target -> Instr
DMBISH :: DMBISHFlags -> Instr
FMOV :: Operand -> Operand -> Instr
FCVT :: Operand -> Operand -> Instr
SCVTF :: Operand -> Operand -> Instr
FCVTZS :: Operand -> Operand -> Instr
FABS :: Operand -> Operand -> Instr
FMIN :: Operand -> Operand -> Operand -> Instr
FMAX :: Operand -> Operand -> Operand -> Instr
FSQRT :: Operand -> Operand -> Instr

-- | Floating-point fused multiply-add instructions
--   
--   <ul>
--   <li>fmadd : d = r1 * r2 + r3</li>
--   <li>fnmsub: d = r1 * r2 - r3</li>
--   <li>fmsub : d = - r1 * r2 + r3</li>
--   <li>fnmadd: d = - r1 * r2 - r3</li>
--   </ul>
FMA :: FMASign -> Operand -> Operand -> Operand -> Operand -> Instr
data DMBISHFlags
DmbLoad :: DMBISHFlags
DmbLoadStore :: DMBISHFlags
instrCon :: Instr -> String
data Target
TBlock :: BlockId -> Target
TLabel :: CLabel -> Target
TReg :: Reg -> Target
data ExtMode
EUXTB :: ExtMode
EUXTH :: ExtMode
EUXTW :: ExtMode
EUXTX :: ExtMode
ESXTB :: ExtMode
ESXTH :: ExtMode
ESXTW :: ExtMode
ESXTX :: ExtMode
data ShiftMode
SLSL :: ShiftMode
SLSR :: ShiftMode
SASR :: ShiftMode
SROR :: ShiftMode
type ExtShift = Int
type RegShift = Int
data Operand
OpReg :: Width -> Reg -> Operand
OpRegExt :: Width -> Reg -> ExtMode -> ExtShift -> Operand
OpRegShift :: Width -> Reg -> ShiftMode -> RegShift -> Operand
OpImm :: Imm -> Operand
OpImmShift :: Imm -> ShiftMode -> RegShift -> Operand
OpAddr :: AddrMode -> Operand
opReg :: Width -> Reg -> Operand
sp :: Operand
ip0 :: Operand
_x :: Int -> Operand
x0 :: Operand
x1 :: Operand
x2 :: Operand
x3 :: Operand
x4 :: Operand
x5 :: Operand
x6 :: Operand
x7 :: Operand
x8 :: Operand
x9 :: Operand
x10 :: Operand
x11 :: Operand
x12 :: Operand
x13 :: Operand
x14 :: Operand
x15 :: Operand
x16 :: Operand
x17 :: Operand
x18 :: Operand
x19 :: Operand
x20 :: Operand
x21 :: Operand
x22 :: Operand
x23 :: Operand
x24 :: Operand
x25 :: Operand
x26 :: Operand
x27 :: Operand
x28 :: Operand
x29 :: Operand
x30 :: Operand
x31 :: Operand
_d :: Int -> Operand
d0 :: Operand
d1 :: Operand
d2 :: Operand
d3 :: Operand
d4 :: Operand
d5 :: Operand
d6 :: Operand
d7 :: Operand
d8 :: Operand
d9 :: Operand
d10 :: Operand
d11 :: Operand
d12 :: Operand
d13 :: Operand
d14 :: Operand
d15 :: Operand
d16 :: Operand
d17 :: Operand
d18 :: Operand
d19 :: Operand
d20 :: Operand
d21 :: Operand
d22 :: Operand
d23 :: Operand
d24 :: Operand
d25 :: Operand
d26 :: Operand
d27 :: Operand
d28 :: Operand
d29 :: Operand
d30 :: Operand
d31 :: Operand
opRegUExt :: Width -> Reg -> Operand
opRegSExt :: Width -> Reg -> Operand
instance GHC.Classes.Eq GHC.CmmToAsm.AArch64.Instr.DMBISHFlags
instance GHC.Classes.Eq GHC.CmmToAsm.AArch64.Instr.ExtMode
instance GHC.Classes.Eq GHC.CmmToAsm.AArch64.Instr.Operand
instance GHC.Classes.Eq GHC.CmmToAsm.AArch64.Instr.ShiftMode
instance GHC.Classes.Eq GHC.CmmToAsm.AArch64.Instr.Target
instance GHC.Classes.Ord GHC.CmmToAsm.AArch64.Instr.Target
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Instr.RegUsage
instance GHC.Internal.Show.Show GHC.CmmToAsm.AArch64.Instr.DMBISHFlags
instance GHC.Internal.Show.Show GHC.CmmToAsm.AArch64.Instr.ExtMode
instance GHC.Internal.Show.Show GHC.CmmToAsm.AArch64.Instr.Operand
instance GHC.Internal.Show.Show GHC.CmmToAsm.AArch64.Instr.ShiftMode

module GHC.CmmToAsm.AArch64.RegInfo
data JumpDest
DestBlockId :: BlockId -> JumpDest
getJumpDestBlockId :: JumpDest -> Maybe BlockId
canShortcut :: Instr -> Maybe JumpDest
shortcutStatics :: (BlockId -> Maybe JumpDest) -> RawCmmStatics -> RawCmmStatics
shortcutJump :: (BlockId -> Maybe JumpDest) -> Instr -> Instr
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.AArch64.RegInfo.JumpDest

module GHC.CmmToAsm.AArch64.Ppr
pprNatCmmDecl :: IsDoc doc => NCGConfig -> NatCmmDecl RawCmmStatics Instr -> doc
pprInstr :: IsDoc doc => Platform -> Instr -> doc
pprBasicBlock :: IsDoc doc => Platform -> Bool -> LabelMap RawCmmStatics -> NatBasicBlock Instr -> doc

module GHC.Cmm.Utils
primRepCmmType :: Platform -> PrimRep -> CmmType
slotCmmType :: Platform -> SlotTy -> CmmType
typeCmmType :: Platform -> NvUnaryType -> CmmType
typeForeignHint :: NvUnaryType -> ForeignHint
primRepForeignHint :: PrimRep -> ForeignHint
zeroCLit :: Platform -> CmmLit
mkIntCLit :: Platform -> Int -> CmmLit
mkWordCLit :: Platform -> Integer -> CmmLit
packHalfWordsCLit :: Platform -> StgHalfWord -> StgHalfWord -> CmmLit

-- | We make a top-level decl for the string, and return a label pointing
--   to it
mkByteStringCLit :: forall (raw :: Bool) info stmt. CLabel -> ByteString -> (CmmLit, GenCmmDecl (GenCmmStatics raw) info stmt)

-- | We make a top-level decl for the embedded binary file, and return a
--   label pointing to it
mkFileEmbedLit :: forall (raw :: Bool) info stmt. CLabel -> FilePath -> Int -> (CmmLit, GenCmmDecl (GenCmmStatics raw) info stmt)

-- | Build a data-segment data block
mkDataLits :: forall (raw :: Bool) info stmt. Section -> CLabel -> [CmmLit] -> GenCmmDecl (GenCmmStatics raw) info stmt
mkRODataLits :: forall (raw :: Bool) info stmt. CLabel -> [CmmLit] -> GenCmmDecl (GenCmmStatics raw) info stmt
mkStgWordCLit :: Platform -> StgWord -> CmmLit
mkIntExpr :: Platform -> Int -> CmmExpr
zeroExpr :: Platform -> CmmExpr
mkLblExpr :: CLabel -> CmmExpr
cmmRegOff :: CmmReg -> Int -> CmmExpr
cmmOffset :: Platform -> CmmExpr -> Int -> CmmExpr
cmmLabelOff :: CLabel -> Int -> CmmLit
cmmOffsetLit :: CmmLit -> Int -> CmmLit
cmmOffsetExpr :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmRegOffB :: CmmReg -> ByteOff -> CmmExpr
cmmOffsetB :: Platform -> CmmExpr -> ByteOff -> CmmExpr
cmmLabelOffB :: CLabel -> ByteOff -> CmmLit
cmmOffsetLitB :: CmmLit -> ByteOff -> CmmLit
cmmOffsetExprB :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmRegOffW :: Platform -> CmmReg -> WordOff -> CmmExpr
cmmOffsetW :: Platform -> CmmExpr -> WordOff -> CmmExpr
cmmLabelOffW :: Platform -> CLabel -> WordOff -> CmmLit
cmmOffsetLitW :: Platform -> CmmLit -> WordOff -> CmmLit
cmmOffsetExprW :: Platform -> CmmExpr -> CmmExpr -> CmmExpr

-- | Useful for creating an index into an array, with a statically known
--   offset. The type is the element type; used for making the multiplier
cmmIndex :: Platform -> Width -> CmmExpr -> Int -> CmmExpr

-- | Useful for creating an index into an array, with an unknown offset.
cmmIndexExpr :: Platform -> Width -> CmmExpr -> CmmExpr -> CmmExpr
cmmLoadIndex :: Platform -> CmmType -> CmmExpr -> Int -> CmmExpr
cmmLoadIndexW :: Platform -> CmmExpr -> Int -> CmmType -> CmmExpr

-- | Load a naturally-aligned non-pointer word.
cmmLoadBWord :: Platform -> CmmExpr -> CmmExpr

-- | Load a naturally-aligned GC pointer.
cmmLoadGCWord :: Platform -> CmmExpr -> CmmExpr
cmmNegate :: Platform -> CmmExpr -> CmmExpr
cmmULtWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmUGeWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmUGtWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmUShrWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmSLtWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmNeWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmEqWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmOrWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmAndWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmSubWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmAddWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmMulWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmQuotWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmToWord :: Platform -> CmmExpr -> CmmExpr
cmmMkAssign :: Platform -> CmmExpr -> Unique -> (CmmNode O O, CmmExpr)
baseExpr :: Platform -> CmmExpr
spExpr :: Platform -> CmmExpr
hpExpr :: Platform -> CmmExpr
spLimExpr :: Platform -> CmmExpr
hpLimExpr :: Platform -> CmmExpr
currentTSOExpr :: Platform -> CmmExpr
currentNurseryExpr :: Platform -> CmmExpr
cccsExpr :: Platform -> CmmExpr
cmmTagMask :: Platform -> CmmExpr
cmmPointerMask :: Platform -> CmmExpr
cmmUntag :: Platform -> CmmExpr -> CmmExpr
cmmIsTagged :: Platform -> CmmExpr -> CmmExpr
cmmIsNotTagged :: Platform -> CmmExpr -> CmmExpr
cmmConstrTag1 :: Platform -> CmmExpr -> CmmExpr
mAX_PTR_TAG :: Platform -> Int
tAG_MASK :: Platform -> Int

-- | Returns True if the two STG registers overlap on the specified
--   platform, in the sense that writing to one will clobber the other.
--   This includes the case that the two registers are the same STG
--   register. See Note [Overlapping global registers] for details.
regsOverlap :: Platform -> CmmReg -> CmmReg -> Bool
globalRegsOverlap :: Platform -> GlobalReg -> GlobalReg -> Bool

-- | Returns True if the STG register is used by the expression, in the
--   sense that a store to the register might affect the value of the
--   expression.
--   
--   We must check for overlapping registers and not just equal registers
--   here, otherwise CmmSink may incorrectly reorder assignments that
--   conflict due to overlap. See #10521 and Note [Overlapping global
--   registers].
regUsedIn :: Platform -> CmmReg -> CmmExpr -> Bool
globalRegUsedIn :: Platform -> GlobalReg -> CmmExpr -> Bool
mkLiveness :: Platform -> [LocalReg] -> Liveness
modifyGraph :: forall (n :: Extensibility -> Extensibility -> Type) (n' :: Extensibility -> Extensibility -> Type). (Graph n C C -> Graph n' C C) -> GenCmmGraph n -> GenCmmGraph n'
ofBlockMap :: BlockId -> LabelMap CmmBlock -> CmmGraph
toBlockMap :: CmmGraph -> LabelMap CmmBlock
ofBlockList :: BlockId -> [CmmBlock] -> CmmGraph
toBlockList :: CmmGraph -> [CmmBlock]

-- | like <a>toBlockList</a>, but the entry block always comes first
toBlockListEntryFirst :: CmmGraph -> [CmmBlock]

-- | Like <a>toBlockListEntryFirst</a>, but we strive to ensure that we
--   order blocks so that the false case of a conditional jumps to the next
--   block in the output list of blocks. This matches the way OldCmm blocks
--   were output since in OldCmm the false case was a fallthrough, whereas
--   in Cmm conditional branches have both true and false successors. Block
--   ordering can make a big difference in performance in the LLVM backend.
--   Note that we rely crucially on the order of successors returned for
--   CmmCondBranch by the NonLocal instance for CmmNode defined in
--   <a>GHC.Cmm.Node</a>. -GBM
toBlockListEntryFirstFalseFallthrough :: CmmGraph -> [CmmBlock]
foldlGraphBlocks :: (a -> CmmBlock -> a) -> a -> CmmGraph -> a
mapGraphNodes :: (CmmNode C O -> CmmNode C O, CmmNode O O -> CmmNode O O, CmmNode O C -> CmmNode O C) -> CmmGraph -> CmmGraph
mapGraphNodes1 :: (forall (e :: Extensibility) (x :: Extensibility). () => CmmNode e x -> CmmNode e x) -> CmmGraph -> CmmGraph

-- | Extract all tick annotations from the given block
blockTicks :: Block CmmNode C C -> [CmmTickish]

module GHC.StgToCmm.Closure
type DynTag = Int
tagForCon :: Platform -> DataCon -> DynTag
isSmallFamily :: Platform -> Int -> Bool

-- | Assumes that there is at most one <a>PrimRep</a> of the type. This
--   assumption holds after unarise. See Note [Post-unarisation invariants]
--   in GHC.Stg.Unarise. See Note [VoidRep] in GHC.Types.RepType.
idPrimRep1 :: Id -> PrimOrVoidRep
idPrimRepU :: Id -> PrimRep
isGcPtrRep :: PrimRep -> Bool

-- | Assumes that Ids have one PrimRep, which holds after unarisation. See
--   Note [Post-unarisation invariants] in GHC.Stg.Unarise.
addIdReps :: [NonVoid Id] -> [NonVoid (PrimRep, Id)]

-- | Assumes that arguments have one PrimRep, which holds after
--   unarisation. See Note [Post-unarisation invariants] in
--   GHC.Stg.Unarise.
addArgReps :: [NonVoid StgArg] -> [NonVoid (PrimRep, StgArg)]
newtype NonVoid a
NonVoid :: a -> NonVoid a
fromNonVoid :: NonVoid a -> a
nonVoidIds :: [Id] -> [NonVoid Id]
nonVoidStgArgs :: [StgArg] -> [NonVoid StgArg]

-- | Used in places where some invariant ensures that all these Ids are
--   non-void; e.g. constructor field binders in case expressions. See Note
--   [Post-unarisation invariants] in <a>GHC.Stg.Unarise</a>.
assertNonVoidIds :: [Id] -> [NonVoid Id]

-- | Used in places where some invariant ensures that all these arguments
--   are non-void; e.g. constructor arguments. See Note [Post-unarisation
--   invariants] in <a>GHC.Stg.Unarise</a>.
assertNonVoidStgArgs :: [StgArg] -> [NonVoid StgArg]

-- | Information about an identifier, from the code generator's point of
--   view. Every identifier is bound to a LambdaFormInfo in the
--   environment, which gives the code generator enough info to be able to
--   tail call or return that identifier.
data LambdaFormInfo

-- | StandardFormInfo tells whether this thunk has one of a small number of
--   standard forms
data StandardFormInfo
mkLFThunk :: Type -> TopLevelFlag -> [Id] -> UpdateFlag -> LambdaFormInfo
mkLFReEntrant :: TopLevelFlag -> [Id] -> [Id] -> ArgDescr -> LambdaFormInfo
mkConLFInfo :: DataCon -> LambdaFormInfo
mkSelectorLFInfo :: Id -> Int -> Bool -> LambdaFormInfo
mkApLFInfo :: Id -> UpdateFlag -> Arity -> LambdaFormInfo

-- | The <a>LambdaFormInfo</a> of an imported Id. See Note [The LFInfo of
--   Imported Ids]
importedIdLFInfo :: Id -> LambdaFormInfo
mkLFArgument :: Id -> LambdaFormInfo
mkLFLetNoEscape :: LambdaFormInfo
mkLFStringLit :: LambdaFormInfo

-- | Return the tag in the low order bits of a variable bound to this
--   LambdaForm
lfDynTag :: Platform -> LambdaFormInfo -> DynTag
isLFThunk :: LambdaFormInfo -> Bool
isLFReEntrant :: LambdaFormInfo -> Bool
lfUpdatable :: LambdaFormInfo -> Bool
data CgLoc
CmmLoc :: CmmExpr -> CgLoc
LneLoc :: BlockId -> [LocalReg] -> CgLoc
data CallMethod

-- | No args, not a function
EnterIt :: CallMethod
JumpToIt :: BlockId -> [LocalReg] -> CallMethod
ReturnIt :: CallMethod
InferedReturnIt :: CallMethod
SlowCall :: CallMethod
DirectEntry :: CLabel -> RepArity -> CallMethod
nodeMustPointToIt :: Profile -> LambdaFormInfo -> Bool
isKnownFun :: LambdaFormInfo -> Bool
funTag :: Platform -> ClosureInfo -> DynTag
tagForArity :: Platform -> RepArity -> DynTag
getCallMethod :: StgToCmmConfig -> Name -> Id -> LambdaFormInfo -> RepArity -> CgLoc -> Maybe SelfLoopInfo -> CallMethod
data ClosureInfo
mkClosureInfo :: Profile -> Bool -> Id -> LambdaFormInfo -> Int -> Int -> String -> ClosureInfo

-- | Convert from <a>ClosureInfo</a> to <a>CmmInfoTable</a>.
mkCmmInfo :: ClosureInfo -> Id -> CostCentreStack -> CmmInfoTable
closureLFInfo :: ClosureInfo -> LambdaFormInfo
closureName :: ClosureInfo -> Id
closureInfoLabel :: ClosureInfo -> CLabel
staticClosureLabel :: Platform -> ClosureInfo -> CLabel
closureSlowEntryLabel :: Platform -> ClosureInfo -> CLabel
closureLocalEntryLabel :: Platform -> ClosureInfo -> CLabel
closureUpdReqd :: ClosureInfo -> Bool
closureReEntrant :: ClosureInfo -> Bool
closureFunInfo :: ClosureInfo -> Maybe (RepArity, ArgDescr)
isToplevClosure :: ClosureInfo -> Bool
blackHoleOnEntry :: ClosureInfo -> Bool
isStaticClosure :: ClosureInfo -> Bool
mkDataConInfoTable :: Profile -> DataCon -> ConInfoTableLocation -> Bool -> Int -> Int -> CmmInfoTable
cafBlackHoleInfoTable :: CmmInfoTable
indStaticInfoTable :: CmmInfoTable
staticClosureNeedsLink :: Bool -> CmmInfoTable -> Bool

-- | Get the info table label for a *thunk*.
mkClosureInfoTableLabel :: Platform -> Id -> LambdaFormInfo -> CLabel
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.StgToCmm.Closure.NonVoid a)
instance GHC.Utils.Outputable.Outputable GHC.StgToCmm.Closure.CallMethod
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.StgToCmm.Closure.NonVoid a)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.StgToCmm.Closure.CgLoc
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.StgToCmm.Closure.NonVoid a)

module GHC.StgToCmm.ArgRep
data ArgRep
P :: ArgRep
N :: ArgRep
L :: ArgRep
V :: ArgRep
F :: ArgRep
D :: ArgRep
V16 :: ArgRep
V32 :: ArgRep
V64 :: ArgRep
toArgRep :: Platform -> PrimRep -> ArgRep
toArgRepOrV :: Platform -> PrimOrVoidRep -> ArgRep
argRepSizeW :: Platform -> ArgRep -> WordOff
argRepString :: ArgRep -> String
isNonV :: ArgRep -> Bool
idArgRep :: Platform -> Id -> ArgRep
slowCallPattern :: [ArgRep] -> (FastString, RepArity)
instance GHC.Classes.Eq GHC.StgToCmm.ArgRep.ArgRep
instance GHC.Classes.Ord GHC.StgToCmm.ArgRep.ArgRep
instance GHC.Utils.Outputable.Outputable GHC.StgToCmm.ArgRep.ArgRep

module GHC.Stg.InferTags.Rewrite
rewriteTopBinds :: Module -> UniqSupply -> [GenStgTopBinding 'InferTaggedBinders] -> [TgStgTopBinding]
rewriteOpApp :: InferStgExpr -> RM TgStgExpr
instance GHC.Internal.Base.Applicative GHC.Stg.InferTags.Rewrite.RM
instance GHC.Internal.Base.Functor GHC.Stg.InferTags.Rewrite.RM
instance GHC.Internal.Base.Monad GHC.Stg.InferTags.Rewrite.RM
instance GHC.Types.Unique.Supply.MonadUnique GHC.Stg.InferTags.Rewrite.RM

module GHC.Stg.InferTags
inferTags :: StgPprOpts -> Bool -> Logger -> Module -> [CgStgTopBinding] -> IO ([TgStgTopBinding], NameEnv TagSig)

module GHC.StgToCmm.CgUtils

-- | Fixup global registers so that they assign to locations within the
--   RegTable if they aren't pinned for the current target.
fixStgRegisters :: Platform -> RawCmmDecl -> RawCmmDecl
baseRegOffset :: Platform -> GlobalReg -> Int
get_Regtable_addr_from_offset :: Platform -> Int -> CmmExpr
regTableOffset :: Platform -> Int -> CmmExpr

-- | We map STG registers onto appropriate CmmExprs. Either they map to
--   real machine registers or stored as offsets from BaseReg. Given a
--   GlobalReg, get_GlobalReg_addr always produces the register table
--   address for it.
get_GlobalReg_addr :: Platform -> GlobalReg -> CmmExpr

-- | The Stream instantiation used for code generation. Note the underlying
--   monad is <tt>UniqDSMT IO</tt>, where <tt>UniqDSMT</tt> is a
--   transformer that propagates a deterministic unique supply (essentially
--   an incrementing counter) from which new uniques are deterministically
--   created during the code generation stages following StgToCmm. See Note
--   [Object determinism].
type CgStream = Stream UniqDSMT IO


-- | Base LLVM Code Generation module
--   
--   Contains functions useful through out the code generator.
module GHC.CmmToLlvm.Base
type LlvmCmmDecl = GenCmmDecl [LlvmData] Maybe RawCmmStatics ListGraph LlvmStatement
type LlvmBasicBlock = GenBasicBlock LlvmStatement

-- | Global registers live on proc entry
type LiveGlobalRegs = [GlobalReg]
type LiveGlobalRegUses = [GlobalRegUse]

-- | Unresolved code. Of the form: (data label, data type, unresolved data)
type LlvmUnresData = (CLabel, Section, LlvmType, [UnresStatic])

-- | Top level LLVM Data (globals and type aliases)
type LlvmData = ([LMGlobal], [LlvmType])

-- | An unresolved Label.
--   
--   Labels are unresolved when we haven't yet determined if they are
--   defined in the module we are currently compiling, or an external one.
type UnresLabel = CmmLit
type UnresStatic = Either UnresLabel LlvmStatic

-- | The Llvm monad. Wraps <tt>LlvmEnv</tt> state as well as the
--   <tt>IO</tt> monad
data LlvmM a

-- | Get initial Llvm environment.
runLlvm :: Logger -> LlvmCgConfig -> LlvmVersion -> BufHandle -> DUniqSupply -> LlvmM a -> IO (a, DUniqSupply)

-- | Clear variables from the environment for a subcomputation
withClearVars :: LlvmM a -> LlvmM a

-- | Lookup variables or functions in the environment.
varLookup :: Uniquable key => key -> LlvmM (Maybe LlvmType)

-- | Insert variables or functions into the environment.
varInsert :: Uniquable key => key -> LlvmType -> LlvmM ()

-- | Set a register as allocated on the stack
markStackReg :: GlobalReg -> LlvmM ()

-- | Check whether a register is allocated on the stack
checkStackReg :: GlobalReg -> LlvmM Bool

-- | Lookup variables or functions in the environment.
funLookup :: Uniquable key => key -> LlvmM (Maybe LlvmType)

-- | Insert variables or functions into the environment.
funInsert :: Uniquable key => key -> LlvmType -> LlvmM ()

-- | Get the LLVM version we are generating code for
getLlvmVer :: LlvmM LlvmVersion

-- | Dumps the document if the corresponding flag has been set by the user
dumpIfSetLlvm :: DumpFlag -> String -> DumpFormat -> SDoc -> LlvmM ()

-- | Prints the given contents to the output handle
renderLlvm :: HDoc -> SDoc -> LlvmM ()

-- | Marks a variable as "used"
markUsedVar :: LlvmVar -> LlvmM ()

-- | Return all variables marked as "used" so far
getUsedVars :: LlvmM [LlvmVar]

-- | Here we pre-initialise some functions that are used internally by GHC
--   so as to make sure they have the most general type in the case that
--   user code also uses these functions but with a different type than GHC
--   internally. (Main offender is treating return type as <tt>void</tt>
--   instead of 'void *'). Fixes #5486.
ghcInternalFunctions :: LlvmM ()

-- | Get target platform
getPlatform :: LlvmM Platform
getConfig :: LlvmM LlvmCgConfig

-- | Allocate a new global unnamed metadata identifier
getMetaUniqueId :: LlvmM MetaId

-- | Sets metadata node for a given unique
setUniqMeta :: Unique -> MetaId -> LlvmM ()

-- | Gets metadata node for given unique
getUniqMeta :: Unique -> LlvmM (Maybe MetaId)

-- | Lifting of IO actions. Not exported, as we want to encapsulate IO.
liftIO :: IO a -> LlvmM a

-- | Lifting of UniqDSMT actions. Gives access to the deterministic unique
--   supply being threaded through by LlvmM.
liftUDSMT :: UniqDSMT IO a -> LlvmM a

-- | Translate a basic CmmType to an LlvmType.
cmmToLlvmType :: CmmType -> LlvmType

-- | Translate a Cmm Float Width to a LlvmType.
widthToLlvmFloat :: Width -> LlvmType

-- | Translate a Cmm Bit Width to a LlvmType.
widthToLlvmInt :: Width -> LlvmType

-- | Llvm Function type for Cmm function
llvmFunTy :: LiveGlobalRegUses -> LlvmM LlvmType

-- | Llvm Function signature
llvmFunSig :: LiveGlobalRegUses -> CLabel -> LlvmLinkageType -> LlvmM LlvmFunctionDecl

-- | A Function's arguments
llvmFunArgs :: Platform -> LiveGlobalRegUses -> [LlvmVar]

-- | Llvm standard fun attributes
llvmStdFunAttrs :: [LlvmFuncAttr]

-- | Alignment to use for functions
llvmFunAlign :: Platform -> LMAlign

-- | Alignment to use for into tables
llvmInfAlign :: Platform -> LMAlign

-- | Pointer width
llvmPtrBits :: Platform -> Int

-- | Convert a list of types to a list of function parameters (each with no
--   parameter attributes)
tysToParams :: [LlvmType] -> [LlvmParameter]

-- | Section to use for a function
llvmFunSection :: LlvmCgConfig -> LMString -> LMSection

-- | Return a list of "padding" registers for LLVM function calls.
--   
--   When we generate LLVM function signatures, we can't just make any
--   register alive on function entry. Instead, we need to insert fake
--   arguments of the same register class until we are sure that one of
--   them is mapped to the register we want alive. E.g. to ensure that F5
--   is alive, we may need to insert fake arguments mapped to F1, F2, F3
--   and F4.
--   
--   Invariant: Cmm FPR regs with number "n" maps to real registers with
--   number "n" If the calling convention uses registers in a different
--   order or if the invariant doesn't hold, this code probably won't be
--   correct.
padLiveArgs :: Platform -> LiveGlobalRegUses -> LiveGlobalRegUses
isFPR :: GlobalReg -> Bool
lookupRegUse :: GlobalReg -> [GlobalRegUse] -> Maybe GlobalRegUse

-- | Pretty print a <a>CLabel</a>.
strCLabel_llvm :: CLabel -> LlvmM LMString

-- | Create/get a pointer to a global value. Might return an alias if the
--   value in question hasn't been defined yet. We especially make no
--   guarantees on the type of the returned pointer.
getGlobalPtr :: LMString -> LlvmM LlvmVar

-- | Generate definitions for aliases forward-referenced by
--   <tt>getGlobalPtr</tt>.
--   
--   Must be called at a point where we are sure that no new global
--   definitions will be generated anymore!
generateExternDecls :: LlvmM ([LMGlobal], [LlvmType])

-- | Here we take a global variable definition, rename it with a
--   <tt>$def</tt> suffix, and generate the appropriate alias.
aliasify :: LMGlobal -> LlvmM [LMGlobal]

-- | Derive the definition label. It has an identified structure type.
llvmDefLabel :: LMString -> LMString
instance GHC.Internal.Base.Applicative GHC.CmmToLlvm.Base.LlvmM
instance GHC.Internal.Base.Functor GHC.CmmToLlvm.Base.LlvmM
instance GHC.Utils.Logger.HasLogger GHC.CmmToLlvm.Base.LlvmM
instance GHC.Types.Unique.DSM.MonadGetUnique GHC.CmmToLlvm.Base.LlvmM
instance GHC.Internal.Base.Monad GHC.CmmToLlvm.Base.LlvmM


-- | Handle conversion of CmmProc to LLVM code.
module GHC.CmmToLlvm.CodeGen

-- | Top-level of the LLVM proc Code generator
genLlvmProc :: RawCmmDecl -> LlvmM [LlvmCmmDecl]
instance GHC.Classes.Eq GHC.CmmToLlvm.CodeGen.Signage
instance GHC.Internal.Base.Monoid GHC.CmmToLlvm.CodeGen.LlvmAccum
instance GHC.Internal.Base.Semigroup GHC.CmmToLlvm.CodeGen.LlvmAccum
instance GHC.Internal.Show.Show GHC.CmmToLlvm.CodeGen.Signage

module GHC.Cmm.UniqueRenamer
detRenameCmmGroup :: DetUniqFM -> DCmmGroup -> (DetUniqFM, CmmGroup)
detRenameIPEMap :: DetUniqFM -> InfoTableProvMap -> (DetUniqFM, InfoTableProvMap)

-- | Get a unique from a monad that can access a unique supply.
--   
--   Crucially, because <a>MonadGetUnique</a> doesn't allow you to get the
--   <tt>UniqSupply</tt> (unlike <tt>MonadUnique</tt>), an instance such as
--   <a>UniqDSM</a> can use a deterministic unique supply to return
--   deterministic uniques without allowing for the <tt>UniqSupply</tt> to
--   be shared.
class Monad m => MonadGetUnique (m :: Type -> Type)
getUniqueM :: MonadGetUnique m => m Unique

-- | A mapping from non-deterministic uniques to deterministic uniques, to
--   rename local symbols with the end goal of producing deterministic
--   object files. See Note [Renaming uniques deterministically]
data DetUniqFM
emptyDetUFM :: DetUniqFM
instance GHC.Utils.Outputable.Outputable GHC.Cmm.UniqueRenamer.DetUniqFM

module GHC.Cmm.Switch.Implement

-- | Traverses the <a>CmmGraph</a>, making sure that <a>CmmSwitch</a> are
--   suitable for code generation.
cmmImplementSwitchPlans :: Platform -> CmmGraph -> UniqDSM CmmGraph

module GHC.Cmm.Opt
constantFoldNode :: forall (e :: Extensibility) (x :: Extensibility). Platform -> CmmNode e x -> CmmNode e x
constantFoldExpr :: Platform -> CmmExpr -> CmmExpr
cmmMachOpFold :: Platform -> MachOp -> [CmmExpr] -> CmmExpr
cmmMachOpFoldM :: Platform -> MachOp -> [CmmExpr] -> Maybe CmmExpr


-- | Utilities for dealing with constructors/destructors.
module GHC.Cmm.InitFini
data InitOrFini
IsInitArray :: InitOrFini
IsFiniArray :: InitOrFini
isInitOrFiniArray :: RawCmmDecl -> Maybe (InitOrFini, [CLabel])


-- | Handle conversion of CmmData to LLVM code.
module GHC.CmmToLlvm.Data

-- | Pass a CmmStatic section to an equivalent Llvm code.
genLlvmData :: (Section, RawCmmStatics) -> LlvmM LlvmData

-- | Handle static data
genData :: CmmStatic -> LlvmM LlvmStatic


-- | Pretty print helpers for the LLVM Code generator.
module GHC.CmmToLlvm.Ppr

-- | Pretty print LLVM code The HDoc we return is used to produce the final
--   LLVM file, with the SDoc being returned alongside for use when
--   <tt>Opt_D_dump_llvm</tt> is set as we can't (currently) dump HDocs.
pprLlvmCmmDecl :: LlvmCmmDecl -> LlvmM (HDoc, SDoc)

-- | Pretty print LLVM data code
pprLlvmData :: IsDoc doc => LlvmCgConfig -> LlvmData -> doc

-- | The section we are putting info tables and their entry code into,
--   should be unique since we process the assembly pattern matching this.
infoSection :: String


-- | This is the top-level module in the LLVM code generator.
module GHC.CmmToLlvm
data LlvmVersion
llvmVersionList :: LlvmVersion -> [Int]

-- | Top-level of the LLVM Code generator
llvmCodeGen :: Logger -> LlvmCgConfig -> Handle -> DUniqSupply -> CgStream RawCmmGroup a -> IO a

-- | Read in assembly file and process
llvmFixupAsm :: Platform -> FilePath -> FilePath -> IO ()

module GHC.CmmToC
cmmToC :: Platform -> RawCmmGroup -> SDoc
instance GHC.Internal.Base.Applicative GHC.CmmToC.TE
instance GHC.Classes.Eq GHC.CmmToC.Fixity
instance GHC.Internal.Base.Functor GHC.CmmToC.TE
instance GHC.Internal.Base.Monad GHC.CmmToC.TE
instance GHC.Internal.Show.Show GHC.CmmToC.Fixity

module GHC.Cmm.Info
mkEmptyContInfoTable :: CLabel -> CmmInfoTable
cmmToRawCmm :: Logger -> Profile -> CgStream CmmGroupSRTs a -> IO (CgStream RawCmmGroup a)

-- | Value of the srt field of an info table when using an StgLargeSRT
srtEscape :: Platform -> StgHalfWord

-- | Takes a closure pointer and returns the info table pointer
closureInfoPtr :: Platform -> DoAlignSanitisation -> CmmExpr -> CmmExpr

-- | Takes an info pointer (the first word of a closure) and returns its
--   entry code
entryCode :: Platform -> CmmExpr -> CmmExpr

-- | Takes a closure pointer, and return the *zero-indexed* constructor tag
--   obtained from the info table This lives in the SRT field of the info
--   table (constructors don't need SRTs).
getConstrTag :: Profile -> DoAlignSanitisation -> CmmExpr -> CmmExpr

-- | Takes a closure pointer, and return the closure type obtained from the
--   info table
cmmGetClosureType :: Profile -> DoAlignSanitisation -> CmmExpr -> CmmExpr

-- | Takes an info pointer (the first word of a closure) and returns a
--   pointer to the first word of the standard-form info table, excluding
--   the entry-code word (if present)
infoTable :: Profile -> CmmExpr -> CmmExpr

-- | Takes an info table pointer (from infoTable) and returns the constr
--   tag field of the info table (same as the srt_bitmap field)
infoTableConstrTag :: Profile -> CmmExpr -> CmmExpr

-- | Takes an info table pointer (from infoTable) and returns the
--   srt_bitmap field of the info table
infoTableSrtBitmap :: Profile -> CmmExpr -> CmmExpr

-- | Takes an info table pointer (from infoTable) and returns the closure
--   type field of the info table.
infoTableClosureType :: Profile -> CmmExpr -> CmmExpr
infoTablePtrs :: Profile -> CmmExpr -> CmmExpr
infoTableNonPtrs :: Profile -> CmmExpr -> CmmExpr

-- | Takes the info pointer of a function, and returns a pointer to the
--   first word of the StgFunInfoExtra struct in the info table.
funInfoTable :: Profile -> CmmExpr -> CmmExpr

-- | Takes the info pointer of a function, returns the function's arity
funInfoArity :: Profile -> CmmExpr -> CmmExpr
stdInfoTableSizeW :: Profile -> WordOff
fixedInfoTableSizeW :: WordOff
profInfoTableSizeW :: WordOff
maxStdInfoTableSizeW :: WordOff
maxRetInfoTableSizeW :: WordOff
stdInfoTableSizeB :: Profile -> ByteOff
conInfoTableSizeB :: Profile -> Int

-- | Byte offset of the SRT bitmap half-word which is in the
--   *higher-addressed* part of the type_lit
stdSrtBitmapOffset :: Profile -> ByteOff

-- | Byte offset of the closure type half-word
stdClosureTypeOffset :: Profile -> ByteOff
stdPtrsOffset :: Profile -> ByteOff
stdNonPtrsOffset :: Profile -> ByteOff

module GHC.CmmToAsm.PPC.Instr
data Instr
COMMENT :: FastString -> Instr
LOCATION :: Int -> Int -> Int -> String -> Instr
LDATA :: Section -> RawCmmStatics -> Instr
NEWBLOCK :: BlockId -> Instr
DELTA :: Int -> Instr
LD :: Format -> Reg -> AddrMode -> Instr
LDFAR :: Format -> Reg -> AddrMode -> Instr
LDR :: Format -> Reg -> AddrMode -> Instr
LA :: Format -> Reg -> AddrMode -> Instr
ST :: Format -> Reg -> AddrMode -> Instr
STFAR :: Format -> Reg -> AddrMode -> Instr
STU :: Format -> Reg -> AddrMode -> Instr
STC :: Format -> Reg -> AddrMode -> Instr
LIS :: Reg -> Imm -> Instr
LI :: Reg -> Imm -> Instr
MR :: Reg -> Reg -> Instr
CMP :: Format -> Reg -> RI -> Instr
CMPL :: Format -> Reg -> RI -> Instr
BCC :: Cond -> BlockId -> Maybe Bool -> Instr
BCCFAR :: Cond -> BlockId -> Maybe Bool -> Instr
JMP :: CLabel -> [RegWithFormat] -> Instr
MTCTR :: Reg -> Instr
BCTR :: [Maybe BlockId] -> Maybe CLabel -> [RegWithFormat] -> Instr
BL :: CLabel -> [Reg] -> Instr
BCTRL :: [Reg] -> Instr
ADD :: Reg -> Reg -> RI -> Instr
ADDO :: Reg -> Reg -> Reg -> Instr
ADDC :: Reg -> Reg -> Reg -> Instr
ADDE :: Reg -> Reg -> Reg -> Instr
ADDZE :: Reg -> Reg -> Instr
ADDIS :: Reg -> Reg -> Imm -> Instr
SUBF :: Reg -> Reg -> Reg -> Instr
SUBFO :: Reg -> Reg -> Reg -> Instr
SUBFC :: Reg -> Reg -> RI -> Instr
SUBFE :: Reg -> Reg -> Reg -> Instr
MULL :: Format -> Reg -> Reg -> RI -> Instr
MULLO :: Format -> Reg -> Reg -> Reg -> Instr
MFOV :: Format -> Reg -> Instr
MULHU :: Format -> Reg -> Reg -> Reg -> Instr
DIV :: Format -> Bool -> Reg -> Reg -> Reg -> Instr
AND :: Reg -> Reg -> RI -> Instr
ANDC :: Reg -> Reg -> Reg -> Instr
NAND :: Reg -> Reg -> Reg -> Instr
OR :: Reg -> Reg -> RI -> Instr
ORIS :: Reg -> Reg -> Imm -> Instr
XOR :: Reg -> Reg -> RI -> Instr
XORIS :: Reg -> Reg -> Imm -> Instr
EXTS :: Format -> Reg -> Reg -> Instr
CNTLZ :: Format -> Reg -> Reg -> Instr
NEG :: Reg -> Reg -> Instr
NOT :: Reg -> Reg -> Instr
SL :: Format -> Reg -> Reg -> RI -> Instr
SR :: Format -> Reg -> Reg -> RI -> Instr
SRA :: Format -> Reg -> Reg -> RI -> Instr
RLWINM :: Reg -> Reg -> Int -> Int -> Int -> Instr
CLRLI :: Format -> Reg -> Reg -> Int -> Instr
CLRRI :: Format -> Reg -> Reg -> Int -> Instr
FADD :: Format -> Reg -> Reg -> Reg -> Instr
FSUB :: Format -> Reg -> Reg -> Reg -> Instr
FMUL :: Format -> Reg -> Reg -> Reg -> Instr
FDIV :: Format -> Reg -> Reg -> Reg -> Instr
FABS :: Reg -> Reg -> Instr
FNEG :: Reg -> Reg -> Instr

-- | Fused multiply-add instructions.
--   
--   <ul>
--   <li>FMADD: <tt>rd = (ra * rb) + rd</tt></li>
--   <li>FMSUB: <tt>rd = ra * rb - rd</tt></li>
--   <li>FNMADD: <tt>rd = -(ra * rb + rd)</tt></li>
--   <li>FNMSUB: <tt>rd = -(ra * rb - rd)</tt></li>
--   </ul>
FMADD :: FMASign -> Format -> Reg -> Reg -> Reg -> Reg -> Instr
FCMP :: Reg -> Reg -> Instr
FCTIWZ :: Reg -> Reg -> Instr
FCTIDZ :: Reg -> Reg -> Instr
FCFID :: Reg -> Reg -> Instr
FRSP :: Reg -> Reg -> Instr
CRNOR :: Int -> Int -> Int -> Instr
MFCR :: Reg -> Instr
MFLR :: Reg -> Instr
FETCHPC :: Reg -> Instr
HWSYNC :: Instr
ISYNC :: Instr
LWSYNC :: Instr
NOP :: Instr
data RI
RIReg :: Reg -> RI
RIImm :: Imm -> RI
archWordFormat :: Bool -> Format

-- | The size of a minimal stackframe header including minimal parameter
--   save area.
stackFrameHeaderSize :: Platform -> Int

-- | The number of spill slots available without allocating more.
maxSpillSlots :: NCGConfig -> Int
allocMoreStack :: Platform -> Int -> NatCmmDecl statics Instr -> UniqDSM (NatCmmDecl statics Instr, [(BlockId, BlockId)])
makeFarBranches :: Platform -> LabelMap RawCmmStatics -> [NatBasicBlock Instr] -> UniqDSM [NatBasicBlock Instr]

-- | Make an unconditional jump instruction.
mkJumpInstr :: BlockId -> [Instr]
mkLoadInstr :: NCGConfig -> RegWithFormat -> Int -> Int -> [Instr]

-- | An instruction to spill a register into a spill slot.
mkSpillInstr :: NCGConfig -> RegWithFormat -> Int -> Int -> [Instr]

-- | Change the destination of this jump instruction. Used in the linear
--   allocator when adding fixup blocks for join points.
patchJumpInstr :: Instr -> (BlockId -> BlockId) -> Instr

-- | Apply a given mapping to all the register references in this
--   instruction.
patchRegsOfInstr :: Instr -> (Reg -> Reg) -> Instr

-- | Checks whether this instruction is a jump/branch instruction. One that
--   can change the flow of control in a way that the register allocator
--   needs to worry about.
jumpDestsOfInstr :: Instr -> [BlockId]
canFallthroughTo :: Instr -> BlockId -> Bool

-- | Take the source and destination from this reg -&gt; reg move
--   instruction or Nothing if it's not one
takeRegRegMoveInstr :: Instr -> Maybe (Reg, Reg)

-- | See if this instruction is telling us the current C stack delta
takeDeltaInstr :: Instr -> Maybe Int

-- | Copy the value in a register to another one. Must work for all
--   register classes.
mkRegRegMoveInstr :: Format -> Reg -> Reg -> Instr
mkStackAllocInstr :: Platform -> Int -> [Instr]
mkStackDeallocInstr :: Platform -> Int -> [Instr]

-- | Get the registers that are being used by this instruction. regUsage
--   doesn't need to do any trickery for jumps and such. Just state
--   precisely the regs read and written by that insn. The consequences of
--   control flow transfers, as far as register allocation goes, are taken
--   care of by the register allocator.
regUsageOfInstr :: Platform -> Instr -> RegUsage

-- | Checks whether this instruction is a jump/branch instruction. One that
--   can change the flow of control in a way that the register allocator
--   needs to worry about.
isJumpishInstr :: Instr -> Bool
isMetaInstr :: Instr -> Bool

module GHC.CmmToAsm.PPC.RegInfo
data JumpDest
DestBlockId :: BlockId -> JumpDest
getJumpDestBlockId :: JumpDest -> Maybe BlockId
canShortcut :: Instr -> Maybe JumpDest
shortcutJump :: (BlockId -> Maybe JumpDest) -> Instr -> Instr
shortcutStatics :: (BlockId -> Maybe JumpDest) -> RawCmmStatics -> RawCmmStatics
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.PPC.RegInfo.JumpDest

module GHC.CmmToAsm.PPC.Ppr
pprNatCmmDecl :: IsDoc doc => NCGConfig -> NatCmmDecl RawCmmStatics Instr -> doc
pprInstr :: IsDoc doc => Platform -> Instr -> doc

module GHC.Cmm.DebugBlock

-- | Debug information about a block of code. Ticks scope over nested
--   blocks.
data DebugBlock
DebugBlock :: !Label -> !Label -> !CLabel -> !Bool -> !Maybe DebugBlock -> ![CmmTickish] -> !Maybe CmmTickish -> !Maybe Int -> [UnwindPoint] -> ![DebugBlock] -> DebugBlock

-- | Entry label of containing proc
[dblProcedure] :: DebugBlock -> !Label

-- | Hoopl label
[dblLabel] :: DebugBlock -> !Label

-- | Output label
[dblCLabel] :: DebugBlock -> !CLabel

-- | Has an info table?
[dblHasInfoTbl] :: DebugBlock -> !Bool

-- | The parent of this proc. See Note [Splitting DebugBlocks]
[dblParent] :: DebugBlock -> !Maybe DebugBlock

-- | Ticks defined in this block
[dblTicks] :: DebugBlock -> ![CmmTickish]

-- | Best source tick covering block
[dblSourceTick] :: DebugBlock -> !Maybe CmmTickish

-- | Output position relative to other blocks. <tt>Nothing</tt> means the
--   block was optimized out
[dblPosition] :: DebugBlock -> !Maybe Int
[dblUnwind] :: DebugBlock -> [UnwindPoint]

-- | Nested blocks
[dblBlocks] :: DebugBlock -> ![DebugBlock]

-- | Extract debug data from a group of procedures. We will prefer source
--   notes that come from the given module (presumably the module that we
--   are currently compiling).
cmmDebugGen :: ModLocation -> RawCmmGroup -> [DebugBlock]
cmmDebugLabels :: (BlockId -> Bool) -> (i -> Bool) -> GenCmmGroup d g (ListGraph i) -> [Label]

-- | Sets position and unwind table fields in the debug block tree
--   according to native generated code.
cmmDebugLink :: [Label] -> LabelMap [UnwindPoint] -> [DebugBlock] -> [DebugBlock]

-- | Converts debug blocks into a label map for easier lookups
debugToMap :: [DebugBlock] -> LabelMap DebugBlock

-- | Maps registers to expressions that yield their "old" values further up
--   the stack. Most interesting for the stack pointer <tt>Sp</tt>, but
--   might be useful to document saved registers, too. Note that a
--   register's value will be <a>Nothing</a> when the register's previous
--   value cannot be reconstructed.
type UnwindTable = Map GlobalReg Maybe UnwindExpr

-- | A label associated with an <a>UnwindTable</a>
data UnwindPoint
UnwindPoint :: !CLabel -> !UnwindTable -> UnwindPoint

-- | Expressions, used for unwind information
data UnwindExpr

-- | literal value
UwConst :: !Int -> UnwindExpr

-- | register plus offset
UwReg :: !GlobalRegUse -> !Int -> UnwindExpr

-- | pointer dereferencing
UwDeref :: UnwindExpr -> UnwindExpr
UwLabel :: CLabel -> UnwindExpr
UwPlus :: UnwindExpr -> UnwindExpr -> UnwindExpr
UwMinus :: UnwindExpr -> UnwindExpr -> UnwindExpr
UwTimes :: UnwindExpr -> UnwindExpr -> UnwindExpr

-- | Conversion of Cmm expressions to unwind expressions. We check for
--   unsupported operator usages and simplify the expression as far as
--   possible.
toUnwindExpr :: Platform -> CmmExpr -> UnwindExpr
pprUnwindTable :: IsLine doc => Platform -> UnwindTable -> doc
instance GHC.Classes.Eq GHC.Cmm.DebugBlock.UnwindExpr
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.DebugBlock.DebugBlock
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.DebugBlock.UnwindExpr
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.DebugBlock.UnwindPoint

module GHC.CmmToAsm.X86.Instr
data Instr
COMMENT :: FastString -> Instr
LOCATION :: Int -> Int -> Int -> String -> Instr
LDATA :: Section -> (Alignment, RawCmmStatics) -> Instr
NEWBLOCK :: BlockId -> Instr
UNWIND :: CLabel -> UnwindTable -> Instr
DELTA :: Int -> Instr

-- | X86 scalar move instruction.
--   
--   When used at a vector format, only moves the lower 64 bits of data;
--   the rest of the data in the destination may either be zeroed or
--   preserved, depending on the specific format and operands.
MOV :: Format -> Operand -> Operand -> Instr

-- | MOVD/MOVQ SSE2 instructions (bitcast between a general purpose
--   register and a float register). Format is input format, output format
--   is calculated in the <a>movdOutFormat</a> function.
MOVD :: Format -> Operand -> Operand -> Instr
CMOV :: Cond -> Format -> Operand -> Reg -> Instr

-- | The format argument is the size of operand 1 (the number of bits we
--   keep) We always zero *all* high bits, even though this isn't how the
--   actual instruction works. The code generator also seems to rely on
--   this behaviour and it's faster to execute on many cpus as well so for
--   now I'm just documenting the fact.
MOVZxL :: Format -> Operand -> Operand -> Instr
MOVSxL :: Format -> Operand -> Operand -> Instr
LEA :: Format -> Operand -> Operand -> Instr
ADD :: Format -> Operand -> Operand -> Instr
ADC :: Format -> Operand -> Operand -> Instr
SUB :: Format -> Operand -> Operand -> Instr
SBB :: Format -> Operand -> Operand -> Instr
MUL :: Format -> Operand -> Operand -> Instr
MUL2 :: Format -> Operand -> Instr
IMUL :: Format -> Operand -> Operand -> Instr
IMUL2 :: Format -> Operand -> Instr
DIV :: Format -> Operand -> Instr
IDIV :: Format -> Operand -> Instr
ADD_CC :: Format -> Operand -> Operand -> Instr
SUB_CC :: Format -> Operand -> Operand -> Instr
AND :: Format -> Operand -> Operand -> Instr
OR :: Format -> Operand -> Operand -> Instr
XOR :: Format -> Operand -> Operand -> Instr

-- | AVX bitwise logical XOR operation
VXOR :: Format -> Operand -> Reg -> Reg -> Instr
NOT :: Format -> Operand -> Instr
NEGI :: Format -> Operand -> Instr
BSWAP :: Format -> Reg -> Instr
SHL :: Format -> Operand -> Operand -> Instr
SAR :: Format -> Operand -> Operand -> Instr
SHR :: Format -> Operand -> Operand -> Instr
SHRD :: Format -> Operand -> Operand -> Operand -> Instr
SHLD :: Format -> Operand -> Operand -> Operand -> Instr
BT :: Format -> Imm -> Operand -> Instr
NOP :: Instr
X87Store :: Format -> AddrMode -> Instr
CVTSS2SD :: Reg -> Reg -> Instr
CVTSD2SS :: Reg -> Reg -> Instr
CVTTSS2SIQ :: Format -> Operand -> Reg -> Instr
CVTTSD2SIQ :: Format -> Operand -> Reg -> Instr
CVTSI2SS :: Format -> Operand -> Reg -> Instr
CVTSI2SD :: Format -> Operand -> Reg -> Instr

-- | FMA3 fused multiply-add operations.
FMA3 :: Format -> FMASign -> FMAPermutation -> Operand -> Reg -> Reg -> Instr
FDIV :: Format -> Operand -> Operand -> Instr
SQRT :: Format -> Operand -> Reg -> Instr
TEST :: Format -> Operand -> Operand -> Instr
CMP :: Format -> Operand -> Operand -> Instr
SETCC :: Cond -> Operand -> Instr
PUSH :: Format -> Operand -> Instr
POP :: Format -> Operand -> Instr
JMP :: Operand -> [RegWithFormat] -> Instr
JXX :: Cond -> BlockId -> Instr
JXX_GBL :: Cond -> Imm -> Instr
JMP_TBL :: Operand -> [Maybe JumpDest] -> Section -> CLabel -> Instr

-- | X86 call instruction
CALL :: Either Imm Reg -> [RegWithFormat] -> Instr
CLTD :: Format -> Instr
FETCHGOT :: Reg -> Instr
FETCHPC :: Reg -> Instr
POPCNT :: Format -> Operand -> Reg -> Instr
LZCNT :: Format -> Operand -> Reg -> Instr
TZCNT :: Format -> Operand -> Reg -> Instr
BSF :: Format -> Operand -> Reg -> Instr
BSR :: Format -> Operand -> Reg -> Instr
PDEP :: Format -> Operand -> Operand -> Reg -> Instr
PEXT :: Format -> Operand -> Operand -> Reg -> Instr
PREFETCH :: PrefetchVariant -> Format -> Operand -> Instr
LOCK :: Instr -> Instr
XADD :: Format -> Operand -> Operand -> Instr
CMPXCHG :: Format -> Operand -> Operand -> Instr
XCHG :: Format -> Operand -> Reg -> Instr
MFENCE :: Instr
VBROADCAST :: Format -> Operand -> Reg -> Instr
VEXTRACT :: Format -> Imm -> Reg -> Operand -> Instr
INSERTPS :: Format -> Imm -> Operand -> Reg -> Instr

-- | SSE2 unaligned move of floating-point vectors
MOVU :: Format -> Operand -> Operand -> Instr

-- | AVX unaligned move of floating-point vectors
VMOVU :: Format -> Operand -> Operand -> Instr

-- | SSE2 move between memory and low-part of an xmm register
MOVL :: Format -> Operand -> Operand -> Instr

-- | SSE move between memory and high-part of an xmm register
MOVH :: Format -> Operand -> Operand -> Instr

-- | SSE2 unaligned move of integer vectors
MOVDQU :: Format -> Operand -> Operand -> Instr

-- | AVX unaligned move of integer vectors
VMOVDQU :: Format -> Operand -> Operand -> Instr
PXOR :: Format -> Operand -> Reg -> Instr
VPXOR :: Format -> Reg -> Reg -> Reg -> Instr
VADD :: Format -> Operand -> Reg -> Reg -> Instr
VSUB :: Format -> Operand -> Reg -> Reg -> Instr
VMUL :: Format -> Operand -> Reg -> Reg -> Instr
VDIV :: Format -> Operand -> Reg -> Reg -> Instr
SHUF :: Format -> Imm -> Operand -> Reg -> Instr
VSHUF :: Format -> Imm -> Operand -> Reg -> Reg -> Instr
PSHUFD :: Format -> Imm -> Operand -> Reg -> Instr
VPSHUFD :: Format -> Imm -> Operand -> Reg -> Instr

-- | Move two 32-bit floats from the high part of an xmm register to the
--   low part of another xmm register.
MOVHLPS :: Format -> Reg -> Reg -> Instr
UNPCKL :: Format -> Operand -> Reg -> Instr
PUNPCKLQDQ :: Format -> Operand -> Reg -> Instr
PSLLDQ :: Format -> Operand -> Reg -> Instr
PSRLDQ :: Format -> Operand -> Reg -> Instr
MINMAX :: MinOrMax -> MinMaxType -> Format -> Operand -> Operand -> Instr
VMINMAX :: MinOrMax -> MinMaxType -> Format -> Operand -> Reg -> Reg -> Instr
data Operand
OpReg :: Reg -> Operand
OpImm :: Imm -> Operand
OpAddr :: AddrMode -> Operand
data PrefetchVariant
NTA :: PrefetchVariant
Lvl0 :: PrefetchVariant
Lvl1 :: PrefetchVariant
Lvl2 :: PrefetchVariant
data FMAPermutation
FMA132 :: FMAPermutation
FMA213 :: FMAPermutation
FMA231 :: FMAPermutation
data JumpDest
DestBlockId :: BlockId -> JumpDest
DestImm :: Imm -> JumpDest
getJumpDestBlockId :: JumpDest -> Maybe BlockId
canShortcut :: Instr -> Maybe JumpDest
shortcutStatics :: (BlockId -> Maybe JumpDest) -> (Alignment, RawCmmStatics) -> (Alignment, RawCmmStatics)
shortcutJump :: (BlockId -> Maybe JumpDest) -> Instr -> Instr
allocMoreStack :: Platform -> Int -> NatCmmDecl statics Instr -> UniqDSM (NatCmmDecl statics Instr, [(BlockId, BlockId)])
maxSpillSlots :: NCGConfig -> Int
archWordFormat :: Bool -> Format

-- | Check whether an instruction represents a reg-reg move. The register
--   allocator attempts to eliminate reg-&gt;reg moves whenever it can, by
--   assigning the src and dest temporaries to the same real register.
takeRegRegMoveInstr :: Platform -> Instr -> Maybe (Reg, Reg)

-- | Returns which registers are read and written as a (read, written)
--   pair.
regUsageOfInstr :: Platform -> Instr -> RegUsage

-- | See if this instruction is telling us the current C stack delta
takeDeltaInstr :: Instr -> Maybe Int

-- | Make a spill reload instruction.
mkLoadInstr :: HasDebugCallStack => NCGConfig -> RegWithFormat -> Int -> Int -> [Instr]

-- | Make an unconditional branch instruction.
mkJumpInstr :: BlockId -> [Instr]
mkStackAllocInstr :: Platform -> Int -> [Instr]
mkStackDeallocInstr :: Platform -> Int -> [Instr]

-- | Make a spill instruction.
mkSpillInstr :: HasDebugCallStack => NCGConfig -> RegWithFormat -> Int -> Int -> [Instr]

-- | Make a reg-reg move instruction.
mkRegRegMoveInstr :: HasDebugCallStack => NCGConfig -> Format -> Reg -> Reg -> Instr

-- | A move instruction for moving the entire contents of an operand at the
--   given <a>Format</a>.
movInstr :: HasDebugCallStack => NCGConfig -> Format -> Operand -> Operand -> Instr
jumpDestsOfInstr :: Instr -> [BlockId]
canFallthroughTo :: Instr -> BlockId -> Bool

-- | Applies the supplied function to all registers in instructions.
--   Typically used to change virtual registers to real registers.
patchRegsOfInstr :: HasDebugCallStack => Platform -> Instr -> (Reg -> Reg) -> Instr
patchJumpInstr :: Instr -> (BlockId -> BlockId) -> Instr
isMetaInstr :: Instr -> Bool
isJumpishInstr :: Instr -> Bool
movdOutFormat :: Format -> Format

-- | <tt>MIN</tt> or <tt>MAX</tt>
data MinOrMax
Min :: MinOrMax
Max :: MinOrMax

-- | What kind of min<i>max operation: signed or unsigned vector integer
--   min</i>max, or (scalar or vector) floating point min/max?
data MinMaxType
IntVecMinMax :: Bool -> MinMaxType
[minMaxSigned] :: MinMaxType -> Bool
FloatMinMax :: MinMaxType
instance GHC.Classes.Eq GHC.CmmToAsm.X86.Instr.MinMaxType
instance GHC.Classes.Eq GHC.CmmToAsm.X86.Instr.MinOrMax
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.X86.Instr.JumpDest
instance GHC.Internal.Show.Show GHC.CmmToAsm.X86.Instr.MinMaxType
instance GHC.Internal.Show.Show GHC.CmmToAsm.X86.Instr.MinOrMax

module GHC.CmmToAsm.X86.Ppr
pprNatCmmDecl :: IsDoc doc => NCGConfig -> NatCmmDecl (Alignment, RawCmmStatics) Instr -> doc
pprInstr :: IsDoc doc => Platform -> Instr -> doc

module GHC.CmmToAsm.Reg.Linear.FreeRegs
class Show freeRegs => FR freeRegs
frAllocateReg :: FR freeRegs => Platform -> RealReg -> freeRegs -> freeRegs
frGetFreeRegs :: FR freeRegs => Platform -> RegClass -> freeRegs -> [RealReg]
frInitFreeRegs :: FR freeRegs => Platform -> freeRegs
frReleaseReg :: FR freeRegs => Platform -> RealReg -> freeRegs -> freeRegs
allFreeRegs :: FR freeRegs => Platform -> freeRegs -> [RealReg]
maxSpillSlots :: NCGConfig -> Int
instance GHC.CmmToAsm.Reg.Linear.FreeRegs.FR GHC.CmmToAsm.Reg.Linear.RV64.FreeRegs
instance GHC.CmmToAsm.Reg.Linear.FreeRegs.FR GHC.CmmToAsm.Reg.Linear.AArch64.FreeRegs
instance GHC.CmmToAsm.Reg.Linear.FreeRegs.FR GHC.CmmToAsm.Reg.Linear.PPC.FreeRegs
instance GHC.CmmToAsm.Reg.Linear.FreeRegs.FR GHC.CmmToAsm.Reg.Linear.X86_64.FreeRegs
instance GHC.CmmToAsm.Reg.Linear.FreeRegs.FR GHC.CmmToAsm.Reg.Linear.X86.FreeRegs


-- | Handles joining of a jump instruction to its targets.
module GHC.CmmToAsm.Reg.Linear.JoinToTargets

-- | For a jump instruction at the end of a block, generate fixup code so
--   its vregs are in the correct regs for its destination.
joinToTargets :: (FR freeRegs, Instruction instr) => BlockMap (UniqSet RegWithFormat) -> BlockId -> instr -> RegM freeRegs ([NatBasicBlock instr], instr)

module GHC.CmmToAsm.Reg.Linear
regAlloc :: Instruction instr => NCGConfig -> LiveCmmDecl statics instr -> UniqDSM (NatCmmDecl statics instr, Maybe Int, Maybe RegAllocStats)

module GHC.CmmToAsm.Monad

-- | A Native Code Generator implementation is parametrised over * The type
--   of static data (typically related to <tt>CmmStatics</tt>) * The type
--   of instructions * The type of jump destinations
data NcgImpl statics instr jumpDest
NcgImpl :: !NCGConfig -> (RawCmmDecl -> NatM [NatCmmDecl statics instr]) -> (instr -> Maybe (NatCmmDecl statics instr)) -> (jumpDest -> Maybe BlockId) -> (instr -> Maybe jumpDest) -> ((BlockId -> Maybe jumpDest) -> statics -> statics) -> ((BlockId -> Maybe jumpDest) -> instr -> instr) -> (NatCmmDecl statics instr -> SDoc) -> (NatCmmDecl statics instr -> HDoc) -> Int -> [RealReg] -> (Int -> NatCmmDecl statics instr -> UniqDSM (NatCmmDecl statics instr, [(BlockId, BlockId)])) -> (Platform -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> UniqDSM [NatBasicBlock instr]) -> ([instr] -> [UnwindPoint]) -> (Maybe CFG -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> [NatBasicBlock instr]) -> NcgImpl statics instr jumpDest
[ncgConfig] :: NcgImpl statics instr jumpDest -> !NCGConfig
[cmmTopCodeGen] :: NcgImpl statics instr jumpDest -> RawCmmDecl -> NatM [NatCmmDecl statics instr]
[generateJumpTableForInstr] :: NcgImpl statics instr jumpDest -> instr -> Maybe (NatCmmDecl statics instr)

-- | Given a jump destination, if it refers to a block, return the block id
--   of the destination.
[getJumpDestBlockId] :: NcgImpl statics instr jumpDest -> jumpDest -> Maybe BlockId

-- | Does this jump always jump to a single destination and is
--   shortcutable?
--   
--   We use this to determine whether the given instruction is a
--   shortcutable jump to some destination - See Note [supporting
--   shortcutting] Note that if we return a destination here we *most*
--   support the relevant shortcutting in shortcutStatics for jump tables
--   and shortcutJump for the instructions itself.
[canShortcut] :: NcgImpl statics instr jumpDest -> instr -> Maybe jumpDest

-- | Replace references to blockIds with other destinations - used to
--   update jump tables.
[shortcutStatics] :: NcgImpl statics instr jumpDest -> (BlockId -> Maybe jumpDest) -> statics -> statics

-- | Change the jump destination(s) of an instruction.
--   
--   Rewrites the destination of a jump instruction to another destination,
--   if the given function returns a new jump destination for the
--   <a>BlockId</a> of the original destination.
--   
--   For instance, for a mapping <tt>block_a -&gt; dest_b</tt> and a
--   instruction <tt>goto block_a</tt> we would rewrite the instruction to
--   <tt>goto dest_b</tt>
[shortcutJump] :: NcgImpl statics instr jumpDest -> (BlockId -> Maybe jumpDest) -> instr -> instr

-- | <a>Module</a> is only for printing internal labels. See Note [Internal
--   proc labels] in CLabel.
[pprNatCmmDeclS] :: NcgImpl statics instr jumpDest -> NatCmmDecl statics instr -> SDoc
[pprNatCmmDeclH] :: NcgImpl statics instr jumpDest -> NatCmmDecl statics instr -> HDoc
[maxSpillSlots] :: NcgImpl statics instr jumpDest -> Int
[allocatableRegs] :: NcgImpl statics instr jumpDest -> [RealReg]

-- | The list of block ids records the redirected jumps to allow us to
--   update the CFG.
[ncgAllocMoreStack] :: NcgImpl statics instr jumpDest -> Int -> NatCmmDecl statics instr -> UniqDSM (NatCmmDecl statics instr, [(BlockId, BlockId)])
[ncgMakeFarBranches] :: NcgImpl statics instr jumpDest -> Platform -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> UniqDSM [NatBasicBlock instr]

-- | given the instruction sequence of a block, produce a list of the
--   block's <a>UnwindPoint</a>s See Note [What is this unwinding
--   business?] in <a>GHC.Cmm.DebugBlock</a> and Note [Unwinding
--   information in the NCG] in this module.
[extractUnwindPoints] :: NcgImpl statics instr jumpDest -> [instr] -> [UnwindPoint]

-- | Turn the sequence of <tt>jcc l1; jmp l2</tt> into <tt>jncc l2;
--   &lt;block_l1&gt;</tt> when possible.
[invertCondBranches] :: NcgImpl statics instr jumpDest -> Maybe CFG -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> [NatBasicBlock instr]
data NatM_State
NatM_State :: DUniqSupply -> Int -> [CLabel] -> Maybe Reg -> NCGConfig -> DwarfFiles -> LabelMap DebugBlock -> CFG -> NatM_State
[natm_us] :: NatM_State -> DUniqSupply

-- | Stack offset for unwinding information
[natm_delta] :: NatM_State -> Int
[natm_imports] :: NatM_State -> [CLabel]
[natm_pic] :: NatM_State -> Maybe Reg
[natm_config] :: NatM_State -> NCGConfig
[natm_fileid] :: NatM_State -> DwarfFiles
[natm_debug_map] :: NatM_State -> LabelMap DebugBlock

-- | Having a CFG with additional information is essential for some
--   operations. However we can't reconstruct all information once we
--   generated instructions. So instead we update the CFG as we go.
[natm_cfg] :: NatM_State -> CFG
mkNatM_State :: DUniqSupply -> Int -> NCGConfig -> DwarfFiles -> LabelMap DebugBlock -> CFG -> NatM_State
data NatM a
initNat :: NatM_State -> NatM a -> (a, NatM_State)
addImportNat :: CLabel -> NatM ()

-- | Record that we added a block between <tt>from</tt> and <tt>old</tt>.
addNodeBetweenNat :: BlockId -> BlockId -> BlockId -> NatM ()

-- | Place <a>succ</a> after <tt>block</tt> and change any edges block
--   -&gt; X to <a>succ</a> -&gt; X
addImmediateSuccessorNat :: BlockId -> BlockId -> NatM ()
updateCfgNat :: (CFG -> CFG) -> NatM ()
getUniqueNat :: NatM Unique
setDeltaNat :: Int -> NatM ()

-- | Get native code generator configuration
getConfig :: NatM NCGConfig

-- | Get target platform from native code generator configuration
getPlatform :: NatM Platform
getDeltaNat :: NatM Int
getThisModuleNat :: NatM Module
getBlockIdNat :: NatM BlockId
getNewLabelNat :: NatM CLabel
getNewRegNat :: Format -> NatM Reg
getPicBaseMaybeNat :: NatM (Maybe Reg)
getPicBaseNat :: Format -> NatM Reg

-- | Get CFG edge weights
getCfgWeights :: NatM Weights
getFileId :: FastString -> NatM Int
getDebugBlock :: Label -> NatM (Maybe DebugBlock)
type DwarfFiles = UniqFM FastString (FastString, Int)

-- | Two 32-bit regs used as a single virtual 64-bit register
data Reg64
Reg64 :: !Reg -> !Reg -> Reg64

-- | Two 32-bit regs used as a single virtual 64-bit register and the code
--   to set them appropriately
data RegCode64 code
RegCode64 :: code -> !Reg -> !Reg -> RegCode64 code

-- | Return a virtual 64-bit register
getNewReg64 :: NatM Reg64

-- | Convert a 64-bit LocalReg into two virtual 32-bit regs.
--   
--   Used to handle 64-bit "registers" on 32-bit architectures
localReg64 :: HasDebugCallStack => LocalReg -> Reg64
instance GHC.Internal.Base.Applicative GHC.CmmToAsm.Monad.NatM
instance GHC.Internal.Base.Functor GHC.CmmToAsm.Monad.NatM
instance GHC.Unit.Module.HasModule GHC.CmmToAsm.Monad.NatM
instance GHC.Types.Unique.DSM.MonadGetUnique GHC.CmmToAsm.Monad.NatM
instance GHC.Internal.Base.Monad GHC.CmmToAsm.Monad.NatM

module GHC.CmmToAsm.PIC
cmmMakeDynamicReference :: CmmMakeDynamicReferenceM m => NCGConfig -> ReferenceKind -> CLabel -> m CmmExpr
class Monad m => CmmMakeDynamicReferenceM (m :: Type -> Type)
addImport :: CmmMakeDynamicReferenceM m => CLabel -> m ()
data ReferenceKind
DataReference :: ReferenceKind
CallReference :: ReferenceKind
JumpReference :: ReferenceKind
needImportedSymbols :: NCGConfig -> Bool
pprImportedSymbol :: NCGConfig -> CLabel -> HDoc
pprGotDeclaration :: NCGConfig -> HDoc
initializePicBase_ppc :: Arch -> OS -> Reg -> [NatCmmDecl RawCmmStatics Instr] -> NatM [NatCmmDecl RawCmmStatics Instr]
initializePicBase_x86 :: OS -> Reg -> [NatCmmDecl (Alignment, RawCmmStatics) Instr] -> NatM [NatCmmDecl (Alignment, RawCmmStatics) Instr]
instance GHC.CmmToAsm.PIC.CmmMakeDynamicReferenceM GHC.CmmToAsm.Monad.NatM
instance GHC.Classes.Eq GHC.CmmToAsm.PIC.ReferenceKind

module GHC.CmmToAsm.X86.CodeGen
cmmTopCodeGen :: RawCmmDecl -> NatM [NatCmmDecl (Alignment, RawCmmStatics) Instr]
generateJumpTableForInstr :: NCGConfig -> Instr -> Maybe (NatCmmDecl (Alignment, RawCmmStatics) Instr)
extractUnwindPoints :: [Instr] -> [UnwindPoint]

-- | This works on the invariant that all jumps in the given blocks are
--   required. Starting from there we try to make a few more jumps
--   redundant by reordering them. We depend on the information in the CFG
--   to do so so without a given CFG we do nothing.
invertCondBranches :: Maybe CFG -> LabelMap a -> [NatBasicBlock Instr] -> [NatBasicBlock Instr]

-- | <a>InstrBlock</a>s are the insn sequences generated by the insn
--   selectors. They are really trees of insns to facilitate fast
--   appending, where a left-to-right traversal yields the insns in the
--   correct order.
type InstrBlock = OrdList Instr
instance GHC.Classes.Eq GHC.CmmToAsm.X86.CodeGen.Padding
instance GHC.Classes.Eq GHC.CmmToAsm.X86.CodeGen.StackRef
instance GHC.Internal.Base.Monoid GHC.CmmToAsm.X86.CodeGen.LoadArgs
instance GHC.Classes.Ord GHC.CmmToAsm.X86.CodeGen.Padding
instance GHC.Classes.Ord GHC.CmmToAsm.X86.CodeGen.StackRef
instance GHC.Internal.Base.Semigroup GHC.CmmToAsm.X86.CodeGen.LoadArgs
instance GHC.Internal.Show.Show GHC.CmmToAsm.X86.CodeGen.Padding
instance GHC.Internal.Show.Show GHC.CmmToAsm.X86.CodeGen.RawStackArg
instance GHC.Internal.Show.Show GHC.CmmToAsm.X86.CodeGen.StackArg
instance GHC.Internal.Show.Show GHC.CmmToAsm.X86.CodeGen.StackRef


-- | Native code generator for x86 and x86-64 architectures
module GHC.CmmToAsm.X86
ncgX86_64 :: NCGConfig -> NcgImpl (Alignment, RawCmmStatics) Instr JumpDest
ncgX86 :: NCGConfig -> NcgImpl (Alignment, RawCmmStatics) Instr JumpDest
instance GHC.CmmToAsm.Instr.Instruction GHC.CmmToAsm.X86.Instr.Instr

module GHC.CmmToAsm.RV64.CodeGen
cmmTopCodeGen :: RawCmmDecl -> NatM [NatCmmDecl RawCmmStatics Instr]

-- | Generate jump table data (if required)
--   
--   The idea is to emit one table entry per case. The entry is the
--   relative address of the block to jump to (relative to the table's
--   first entry / table's own label.) The calculation itself is done by
--   the linker.
generateJumpTableForInstr :: NCGConfig -> Instr -> Maybe (NatCmmDecl RawCmmStatics Instr)
makeFarBranches :: Platform -> LabelMap RawCmmStatics -> [NatBasicBlock Instr] -> UniqDSM [NatBasicBlock Instr]


-- | Native code generator for RiscV64 architectures
module GHC.CmmToAsm.RV64
ncgRV64 :: NCGConfig -> NcgImpl RawCmmStatics Instr JumpDest
instance GHC.CmmToAsm.Instr.Instruction GHC.CmmToAsm.RV64.Instr.Instr

module GHC.CmmToAsm.PPC.CodeGen

-- | <a>InstrBlock</a>s are the insn sequences generated by the insn
--   selectors. They are really trees of insns to facilitate fast
--   appending, where a left-to-right traversal (pre-order?) yields the
--   insns in the correct order.
cmmTopCodeGen :: RawCmmDecl -> NatM [NatCmmDecl RawCmmStatics Instr]
generateJumpTableForInstr :: NCGConfig -> Instr -> Maybe (NatCmmDecl RawCmmStatics Instr)

-- | <a>InstrBlock</a>s are the insn sequences generated by the insn
--   selectors. They are really trees of insns to facilitate fast
--   appending, where a left-to-right traversal yields the insns in the
--   correct order.
type InstrBlock = OrdList Instr


-- | Native code generator for PPC architectures
module GHC.CmmToAsm.PPC
ncgPPC :: NCGConfig -> NcgImpl RawCmmStatics Instr JumpDest
instance GHC.CmmToAsm.Instr.Instruction GHC.CmmToAsm.PPC.Instr.Instr

module GHC.Cmm.GenericOpt
cmmToCmm :: NCGConfig -> RawCmmDecl -> (RawCmmDecl, [CLabel])
instance GHC.Internal.Base.Applicative GHC.Cmm.GenericOpt.CmmOptM
instance GHC.CmmToAsm.PIC.CmmMakeDynamicReferenceM GHC.Cmm.GenericOpt.CmmOptM
instance GHC.Internal.Base.Functor GHC.Cmm.GenericOpt.CmmOptM
instance GHC.Internal.Base.Monad GHC.Cmm.GenericOpt.CmmOptM

module GHC.CmmToAsm.BlockLayout
sequenceTop :: Instruction instr => NcgImpl statics instr jumpDest -> Maybe CFG -> NatCmmDecl statics instr -> UniqDSM (NatCmmDecl statics instr)
backendMaintainsCfg :: Platform -> Bool
instance GHC.Classes.Eq GHC.CmmToAsm.BlockLayout.BlockChain
instance GHC.Classes.Ord GHC.CmmToAsm.BlockLayout.BlockChain
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.BlockLayout.BlockChain

module GHC.Driver.Config.CmmToAsm

-- | Initialize the native code generator configuration from the DynFlags
initNCGConfig :: DynFlags -> Module -> NCGConfig

module GHC.CmmToAsm.Dwarf.Types

-- | Individual dwarf records. Each one will be encoded as an entry in the
--   <tt>.debug_info</tt> section.
data DwarfInfo
DwarfCompileUnit :: [DwarfInfo] -> String -> String -> String -> CLabel -> CLabel -> DwarfInfo
[dwChildren] :: DwarfInfo -> [DwarfInfo]
[dwName] :: DwarfInfo -> String
[dwProducer] :: DwarfInfo -> String
[dwCompDir] :: DwarfInfo -> String
[dwLowLabel] :: DwarfInfo -> CLabel
[dwHighLabel] :: DwarfInfo -> CLabel
DwarfSubprogram :: [DwarfInfo] -> String -> CLabel -> Maybe CLabel -> DwarfInfo
[dwChildren] :: DwarfInfo -> [DwarfInfo]
[dwName] :: DwarfInfo -> String
[dwLabel] :: DwarfInfo -> CLabel

-- | label of DIE belonging to the parent tick
[dwParent] :: DwarfInfo -> Maybe CLabel
DwarfBlock :: [DwarfInfo] -> CLabel -> Maybe CLabel -> DwarfInfo
[dwChildren] :: DwarfInfo -> [DwarfInfo]
[dwLabel] :: DwarfInfo -> CLabel
[dwMarker] :: DwarfInfo -> Maybe CLabel
DwarfSrcNote :: RealSrcSpan -> DwarfInfo
[dwSrcSpan] :: DwarfInfo -> RealSrcSpan

-- | Generate assembly for DWARF data
pprDwarfInfo :: IsDoc doc => Platform -> Bool -> DwarfInfo -> doc

-- | Abbreviation declaration. This explains the binary encoding we use for
--   representing <a>DwarfInfo</a>. Be aware that this must be updated
--   along with <a>pprDwarfInfo</a>.
pprAbbrevDecls :: IsDoc doc => Platform -> Bool -> doc

-- | A DWARF address range. This is used by the debugger to quickly locate
--   which compilation unit a given address belongs to. This type assumes a
--   non-segmented address-space.
data DwarfARange
DwarfARange :: CLabel -> CLabel -> DwarfARange
[dwArngStartLabel] :: DwarfARange -> CLabel
[dwArngEndLabel] :: DwarfARange -> CLabel

-- | Print assembler directives corresponding to a DWARF
--   <tt>.debug_aranges</tt> address table entry.
pprDwarfARanges :: IsDoc doc => Platform -> [DwarfARange] -> Unique -> doc

-- | Information about unwind instructions for a procedure. This
--   corresponds to a "Common Information Entry" (CIE) in DWARF.
data DwarfFrame
DwarfFrame :: CLabel -> UnwindTable -> [DwarfFrameProc] -> DwarfFrame
[dwCieLabel] :: DwarfFrame -> CLabel
[dwCieInit] :: DwarfFrame -> UnwindTable
[dwCieProcs] :: DwarfFrame -> [DwarfFrameProc]

-- | Unwind instructions for an individual procedure. Corresponds to a
--   "Frame Description Entry" (FDE) in DWARF.
data DwarfFrameProc
DwarfFrameProc :: CLabel -> Bool -> [DwarfFrameBlock] -> DwarfFrameProc
[dwFdeProc] :: DwarfFrameProc -> CLabel
[dwFdeHasInfo] :: DwarfFrameProc -> Bool

-- | List of blocks. Order must match asm!
[dwFdeBlocks] :: DwarfFrameProc -> [DwarfFrameBlock]

-- | Unwind instructions for a block. Will become part of the containing
--   FDE.
data DwarfFrameBlock
DwarfFrameBlock :: Bool -> [UnwindPoint] -> DwarfFrameBlock
[dwFdeBlkHasInfo] :: DwarfFrameBlock -> Bool

-- | these unwind points must occur in the same order as they occur in the
--   block
[dwFdeUnwind] :: DwarfFrameBlock -> [UnwindPoint]

-- | Header for the <tt>.debug_frame</tt> section. Here we emit the "Common
--   Information Entry" record that establishes general call frame
--   parameters and the default stack layout.
pprDwarfFrame :: IsDoc doc => Platform -> DwarfFrame -> doc

-- | Assembly for a single byte of constant DWARF data
pprByte :: IsDoc doc => Word8 -> doc

-- | Assembly for a two-byte constant integer
pprHalf :: IsDoc doc => Word16 -> doc

-- | Assembly for 4 bytes of dynamic DWARF data
pprData4' :: IsDoc doc => Line doc -> doc

-- | Assembly for a DWARF word of dynamic data. This means 32 bit, as we
--   are generating 32 bit DWARF.
pprDwWord :: IsDoc doc => Line doc -> doc

-- | Assembly for a machine word of dynamic data. Depends on the
--   architecture we are currently generating code for.
pprWord :: IsDoc doc => Platform -> Line doc -> doc

-- | Prints a number in "little endian base 128" format. The idea is to
--   optimize for small numbers by stopping once all further bytes would be
--   0. The highest bit in every byte signals whether there are further
--   bytes to read.
pprLEBWord :: IsDoc doc => Word -> doc

-- | Same as <tt>pprLEBWord</tt>, but for a signed number
pprLEBInt :: IsDoc doc => Int -> doc

-- | Align assembly at (machine) word boundary
wordAlign :: IsDoc doc => Platform -> doc

-- | Generate an offset into another section. This is tricky because this
--   is handled differently depending on platform: Mac Os expects us to
--   calculate the offset using assembler arithmetic. Linux expects us to
--   just reference the target directly, and will figure out on their own
--   that we actually need an offset. Finally, Windows has a special
--   directive to refer to relative offsets. Fun.
sectionOffset :: IsDoc doc => Platform -> Line doc -> Line doc -> doc
instance GHC.Internal.Enum.Enum GHC.CmmToAsm.Dwarf.Types.DwarfAbbrev
instance GHC.Classes.Eq GHC.CmmToAsm.Dwarf.Types.DwarfAbbrev
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.CmmToAsm.Dwarf.Types.DwarfFrameBlock

module GHC.CmmToAsm.Dwarf

-- | Generate DWARF/debug information
dwarfGen :: IsDoc doc => String -> NCGConfig -> ModLocation -> DUniqSupply -> [DebugBlock] -> (doc, DUniqSupply)

module GHC.CmmToAsm.AArch64.CodeGen
cmmTopCodeGen :: RawCmmDecl -> NatM [NatCmmDecl RawCmmStatics Instr]
generateJumpTableForInstr :: NCGConfig -> Instr -> Maybe (NatCmmDecl RawCmmStatics Instr)
makeFarBranches :: Platform -> LabelMap RawCmmStatics -> [NatBasicBlock Instr] -> UniqDSM [NatBasicBlock Instr]


-- | Native code generator for AArch64 architectures
module GHC.CmmToAsm.AArch64
ncgAArch64 :: NCGConfig -> NcgImpl RawCmmStatics Instr JumpDest
instance GHC.CmmToAsm.Instr.Instruction GHC.CmmToAsm.AArch64.Instr.Instr

module GHC.Cmm.Dataflow
type C = 'Closed
type O = 'Open

-- | A sequence of nodes. May be any of four shapes (O<i>O, O</i>C, C<i>O,
--   C</i>C). Open at the entry means single entry, mutatis mutandis for
--   exit. A closed<i>closed block is a </i>basic/ block and can't be
--   extended further. Clients should avoid manipulating blocks and should
--   stick to either nodes or graphs.
data Block (n :: Extensibility -> Extensibility -> Type) (e :: Extensibility) (x :: Extensibility)
lastNode :: forall n (x :: Extensibility). Block n x C -> n O C
entryLabel :: forall (x :: Extensibility). NonLocal thing => thing C x -> Label

-- | Folds backward over all nodes of an open-open block. Strict in the
--   accumulator.
foldNodesBwdOO :: (node O O -> f -> f) -> Block node O O -> f -> f

-- | Folds backward over all the nodes of an open-open block and allows
--   rewriting them. The accumulator is both the block of nodes and
--   <tt>f</tt> (usually dataflow facts). Strict in both accumulated parts.
foldRewriteNodesBwdOO :: forall f node. (node O O -> f -> UniqDSM (Block node O O, f)) -> Block node O O -> f -> UniqDSM (Block node O O, f)
data DataflowLattice a
DataflowLattice :: a -> JoinFun a -> DataflowLattice a
[fact_bot] :: DataflowLattice a -> a
[fact_join] :: DataflowLattice a -> JoinFun a
newtype OldFact a
OldFact :: a -> OldFact a
newtype NewFact a
NewFact :: a -> NewFact a

-- | The result of joining OldFact and NewFact.
data JoinedFact a

-- | Result is different than OldFact.
Changed :: !a -> JoinedFact a

-- | Result is the same as OldFact.
NotChanged :: !a -> JoinedFact a
type TransferFun f = CmmBlock -> FactBase f -> FactBase f

-- | Function for rewriting and analysis combined. To be used with
--   <tt>rewriteCmm</tt>.
--   
--   Currently set to work with <tt>UniqDSM</tt> monad, but we could
--   probably abstract that away (if we do that, we might want to
--   specialize the fixpoint algorithms to the particular monads through
--   SPECIALIZE).
type RewriteFun f = CmmBlock -> FactBase f -> UniqDSM (CmmBlock, FactBase f)
type family Fact (x :: Extensibility) f
type FactBase f = LabelMap f
getFact :: DataflowLattice f -> Label -> FactBase f -> f

-- | Returns the joined facts for each label.
mkFactBase :: DataflowLattice f -> [(Label, f)] -> FactBase f
analyzeCmmFwd :: forall (node :: Extensibility -> Extensibility -> Type) f. NonLocal node => DataflowLattice f -> TransferFun' node f -> GenCmmGraph node -> FactBase f -> FactBase f
analyzeCmmBwd :: forall (node :: Extensibility -> Extensibility -> Type) f. NonLocal node => DataflowLattice f -> TransferFun' node f -> GenCmmGraph node -> FactBase f -> FactBase f
rewriteCmmBwd :: forall (node :: Extensibility -> Extensibility -> Type) f. NonLocal node => DataflowLattice f -> RewriteFun' node f -> GenCmmGraph node -> FactBase f -> UniqDSM (GenCmmGraph node, FactBase f)
changedIf :: Bool -> a -> JoinedFact a

-- | Returns the result of joining the facts from all the successors of the
--   provided node or block.
joinOutFacts :: forall n f (e :: Extensibility). NonLocal n => DataflowLattice f -> n e C -> FactBase f -> f
joinFacts :: DataflowLattice f -> [f] -> f


-- | Annotate a CmmGraph with ThreadSanitizer instrumentation calls.
module GHC.Cmm.ThreadSanitizer
annotateTSAN :: Platform -> CmmGraph -> UniqSM CmmGraph

module GHC.Cmm.Liveness
type CmmLocalLive = CmmLive LocalReg

-- | Calculated liveness info for a CmmGraph
cmmLocalLiveness :: Platform -> CmmGraph -> BlockEntryLiveness LocalReg
cmmLocalLivenessL :: Platform -> CmmGraph -> BlockEntryLivenessL
cmmGlobalLiveness :: Platform -> CmmGraph -> BlockEntryLiveness GlobalRegUse

-- | The dataflow lattice
liveLattice :: Ord r => DataflowLattice (CmmLive r)

-- | The dataflow lattice
liveLatticeL :: DataflowLattice LRegSet
gen_kill :: (DefinerOfRegs r n, UserOfRegs r n) => Platform -> n -> CmmLive r -> CmmLive r
gen_killL :: (DefinerOfRegs LocalReg n, UserOfRegs LocalReg n) => Platform -> n -> LRegSet -> LRegSet

module GHC.Cmm.Sink
cmmSink :: Platform -> CmmGraph -> CmmGraph

module GHC.Cmm.ProcPoint
type ProcPointSet = LabelSet
data Status
ReachedBy :: ProcPointSet -> Status
ProcPoint :: Status
callProcPoints :: CmmGraph -> ProcPointSet
minimalProcPointSet :: Platform -> ProcPointSet -> CmmGraph -> UniqDSM ProcPointSet
splitAtProcPoints :: Platform -> CLabel -> ProcPointSet -> ProcPointSet -> LabelMap Status -> CmmDecl -> UniqDSM [CmmDecl]
procPointAnalysis :: ProcPointSet -> CmmGraph -> LabelMap Status
attachContInfoTables :: ProcPointSet -> CmmDecl -> CmmDecl
instance GHC.Utils.Outputable.Outputable GHC.Cmm.ProcPoint.Status

module GHC.Cmm.Lint
cmmLint :: (OutputableP Platform d, OutputableP Platform h) => Platform -> GenCmmGroup d h CmmGraph -> Maybe SDoc
cmmLintGraph :: Platform -> CmmGraph -> Maybe SDoc
instance GHC.Internal.Base.Applicative GHC.Cmm.Lint.CmmLint
instance GHC.Internal.Base.Functor GHC.Cmm.Lint.CmmLint
instance GHC.Internal.Base.Monad GHC.Cmm.Lint.CmmLint

module GHC.Cmm.Dominators

-- | <h1>Dominator sets</h1>
--   
--   Node X dominates node Y if and only if every path from the entry to Y
--   includes X. Node Y technically dominates itself, but it is never
--   included in the *representation* of its dominator set.
--   
--   A dominator set is represented as a linked list in which each node
--   points to its *immediate* dominator, which is its parent in the
--   dominator tree. In many circumstances the immediate dominator will be
--   the only dominator of interest.
data DominatorSet
ImmediateDominator :: Label -> DominatorSet -> DominatorSet

-- | Label of the immediate dominator.
[ds_label] :: DominatorSet -> Label

-- | Set of nodes dominating the immediate dominator.
[ds_parent] :: DominatorSet -> DominatorSet
EntryNode :: DominatorSet

-- | The result of dominator analysis. Also includes a reverse postorder
--   numbering, which is needed for dominator analysis and for other
--   (downstream) analyses.
--   
--   Invariant: Dominators, graph, and RP numberings include only
--   *reachable* blocks.
data GraphWithDominators (node :: Extensibility -> Extensibility -> Type)
GraphWithDominators :: GenCmmGraph node -> LabelMap DominatorSet -> LabelMap RPNum -> GraphWithDominators (node :: Extensibility -> Extensibility -> Type)
[gwd_graph] :: GraphWithDominators (node :: Extensibility -> Extensibility -> Type) -> GenCmmGraph node
[gwd_dominators] :: GraphWithDominators (node :: Extensibility -> Extensibility -> Type) -> LabelMap DominatorSet
[gwd_rpnumbering] :: GraphWithDominators (node :: Extensibility -> Extensibility -> Type) -> LabelMap RPNum

-- | Reverse postorder number of a node in a CFG
data RPNum

-- | Call this function with a <a>CmmGraph</a> to get back the results of a
--   dominator analysis of that graph (as well as a reverse postorder
--   numbering). The result also includes the subgraph of the original
--   graph that contains only the reachable blocks.
graphWithDominators :: forall (node :: Extensibility -> Extensibility -> Type). (NonLocal node, HasDebugCallStack) => GenCmmGraph node -> GraphWithDominators node

-- | <h1>Utility functions</h1>
--   
--   Call <a>graphMap</a> to get the mapping from <a>Label</a> to
--   <a>Block</a> that is embedded in every <a>CmmGraph</a>.
graphMap :: forall (n :: Extensibility -> Extensibility -> Type). GenCmmGraph n -> LabelMap (Block n C C)

-- | Use <a>gwdRPNumber</a> on the result of the dominator analysis to get
--   a mapping from the <a>Label</a> of each reachable block to the reverse
--   postorder number of that block.
gwdRPNumber :: forall (node :: Extensibility -> Extensibility -> Type). HasDebugCallStack => GraphWithDominators node -> Label -> RPNum

-- | Use <a>gwdDominatorsOf</a> on the result of the dominator analysis to
--   get a mapping from the <a>Label</a> of each reachable block to the
--   dominator set (and the immediate dominator) of that block. The
--   implementation is space-efficient: intersecting dominator sets share
--   the representation of their intersection.
gwdDominatorsOf :: forall (node :: Extensibility -> Extensibility -> Type). HasDebugCallStack => GraphWithDominators node -> Label -> DominatorSet
gwdDominatorTree :: forall (node :: Extensibility -> Extensibility -> Type). GraphWithDominators node -> Tree Label

-- | Use to tell if the given label is in the given dominator set. Which is
--   to say, does the bloc with with given label _properly_ and
--   _non-vacuously_ dominate the node whose dominator set this is?
--   
--   Takes linear time in the height of the dominator tree, but uses space
--   efficiently.
dominatorsMember :: Label -> DominatorSet -> Bool

-- | Intersect two dominator sets to produce a third dominator set. This
--   function takes time linear in the size of the sets. As such it is
--   inefficient and should be used only for things like visualizations or
--   linters.
intersectDominators :: DominatorSet -> DominatorSet -> DominatorSet
instance GHC.Classes.Eq GHC.Cmm.Dominators.DominatorSet
instance GHC.Classes.Eq GHC.Cmm.Dominators.RPNum
instance GHC.Classes.Ord GHC.Cmm.Dominators.RPNum
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Dominators.DominatorSet
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Dominators.RPNum
instance GHC.Internal.Show.Show GHC.Cmm.Dominators.RPNum


-- | Test a Cmm control-flow graph for reducibility. And provide a function
--   that, when given an arbitrary control-flow graph, returns an
--   equivalent, reducible control-flow graph. The equivalent graph is
--   obtained by "splitting" (copying) nodes of the original graph. The
--   resulting equivalent graph has the same dynamic behavior as the
--   original, but it is larger.
--   
--   Documentation uses the language of control-flow analysis, in which a
--   basic block is called a "node." These "nodes" are <a>CmmBlock</a>s or
--   equivalent; they have nothing to do with a <a>CmmNode</a>.
--   
--   For more on reducibility and related analyses and algorithms, see Note
--   [Reducibility resources]
module GHC.Cmm.Reducibility

-- | Represents the result of a reducibility analysis.
data Reducibility
Reducible :: Reducibility
Irreducible :: Reducibility

-- | Given a graph, say whether the graph is reducible. The graph must be
--   bundled with a dominator analysis and a reverse postorder numbering,
--   as these results are needed to perform the test.
reducibility :: forall (node :: Extensibility -> Extensibility -> Type). NonLocal node => GraphWithDominators node -> Reducibility

-- | Given a graph, return an equivalent reducible graph, by "splitting"
--   (copying) nodes if necessary. The input graph must be bundled with a
--   dominator analysis and a reverse postorder numbering. The computation
--   is monadic because when a node is split, the new copy needs a fresh
--   label.
--   
--   Use this function whenever a downstream algorithm needs a reducible
--   control-flow graph.
asReducible :: GraphWithDominators CmmNode -> UniqDSM (GraphWithDominators CmmNode)
instance GHC.Classes.Eq GHC.Cmm.Reducibility.Reducibility
instance GHC.Data.Graph.Collapse.PureSupernode GHC.Cmm.Reducibility.CmmSuper
instance GHC.Internal.Base.Semigroup GHC.Cmm.Reducibility.CmmSuper
instance GHC.Internal.Show.Show GHC.Cmm.Reducibility.Reducibility
instance GHC.Data.Graph.Collapse.Supernode GHC.Cmm.Reducibility.CmmSuper GHC.Data.Graph.Collapse.NullCollapseViz

module GHC.Wasm.ControlFlow.FromCmm

-- | Convert a Cmm CFG to WebAssembly's structured control flow.
structuredControl :: forall expr stmt m. MonadUniqDSM m => Platform -> (Label -> CmmExpr -> m expr) -> (Label -> CmmActions -> m stmt) -> CmmGraph -> m (WasmControl stmt expr ('[] :: [WasmType]) '[ 'I32])
instance GHC.Utils.Outputable.Outputable GHC.Wasm.ControlFlow.FromCmm.ContainingSyntax
instance GHC.Utils.Outputable.Outputable GHC.Wasm.ControlFlow.FromCmm.Context

module GHC.CmmToAsm.Wasm.FromCmm

-- | Calculate the natural alignment size given the platform word type.
alignmentFromWordType :: forall (w :: WasmType). WasmTypeTag w -> Alignment
globalInfoFromCmmGlobalReg :: forall (w :: WasmType). WasmTypeTag w -> GlobalReg -> Maybe GlobalInfo
supportedCmmGlobalRegs :: [GlobalReg]

-- | Invoked for each <a>RawCmmGroup</a>.
onCmmGroup :: forall (w :: WasmType). RawCmmGroup -> WasmCodeGenM w ()

module GHC.CmmToAsm.Wasm.Asm
asmTellEverything :: forall (w :: WasmType). WasmTypeTag w -> WasmCodeGenState w -> WasmAsmM ()

-- | Default indent level is none
execWasmAsmM :: WasmAsmConfig -> WasmAsmM a -> Builder
instance GHC.Internal.Base.Applicative GHC.CmmToAsm.Wasm.Asm.WasmAsmM
instance GHC.Internal.Base.Functor GHC.CmmToAsm.Wasm.Asm.WasmAsmM
instance GHC.Internal.Base.Monad GHC.CmmToAsm.Wasm.Asm.WasmAsmM
instance GHC.Internal.Base.Monoid a => GHC.Internal.Base.Monoid (GHC.CmmToAsm.Wasm.Asm.WasmAsmM a)
instance GHC.Internal.Base.Semigroup a => GHC.Internal.Base.Semigroup (GHC.CmmToAsm.Wasm.Asm.WasmAsmM a)

module GHC.Cmm.ContFlowOpt
cmmCfgOpts :: Bool -> CmmGraph -> CmmGraph
cmmCfgOptsProc :: Bool -> CmmDecl -> CmmDecl
removeUnreachableBlocksProc :: Platform -> CmmDecl -> CmmDecl
replaceLabels :: LabelMap BlockId -> CmmGraph -> CmmGraph

module GHC.CmmToAsm.Wasm
ncgWasm :: NCGConfig -> Logger -> Platform -> ToolSettings -> ModLocation -> Handle -> CgStream RawCmmGroup a -> UniqDSMT IO a


-- | Note [Native code generator] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--   
--   The native-code generator has machine-independent and
--   machine-dependent modules.
--   
--   This module (<a>GHC.CmmToAsm</a>) is the top-level machine-independent
--   module. Before entering machine-dependent land, we do some
--   machine-independent optimisations (defined below) on the
--   <tt>CmmStmts</tt>s. (Which ideally would be folded into CmmOpt ...)
--   
--   We convert to the machine-specific <a>Instr</a> datatype with
--   <tt>cmmCodeGen</tt>, assuming an infinite supply of registers. We then
--   use a (mostly) machine-independent register allocator to rejoin
--   reality. Obviously, <tt>regAlloc</tt> has machine-specific helper
--   functions (see the used register allocator for details).
--   
--   Finally, we order the basic blocks of the function so as to minimise
--   the number of jumps between blocks, by utilising fallthrough wherever
--   possible.
--   
--   The machine-dependent bits are generally contained under
--   GHC<i>CmmToAsm</i><a>Arch</a>/* and generally breaks down as follows:
--   
--   <ul>
--   <li><a>Regs</a>: Everything about the target platform's machine
--   registers (and immediate operands, and addresses, which tend to
--   intermingle/interact with registers).</li>
--   <li><a>Instr</a>: Includes the <a>Instr</a> datatype plus a miscellany
--   of other things (e.g., <tt>targetDoubleSize</tt>,
--   <tt>smStablePtrTable</tt>, ...)</li>
--   <li><a>CodeGen</a>: is where <tt>Cmm</tt> stuff turns into machine
--   instructions.</li>
--   <li><a>Ppr</a>: <a>pprInstr</a> turns an <a>Instr</a> into text (well,
--   really a <a>SDoc</a>).</li>
--   </ul>
--   
--   The register allocators lives under GHC.CmmToAsm.Reg.*, there is both
--   a Linear and a Graph based register allocator. Both of which have
--   their own notes describing them. They are mostly platform independent
--   but there are some platform specific files encoding architecture
--   details under Reg<i><a>Allocator</a></i><a>Arch.hs</a>
--   
--   <ul>
--   <li>}</li>
--   </ul>
module GHC.CmmToAsm
nativeCodeGen :: Logger -> ToolSettings -> NCGConfig -> ModLocation -> Handle -> CgStream RawCmmGroup a -> UniqDSMT IO a

-- | Complete native code generation phase for a single top-level chunk of
--   Cmm. Dumping the output of each stage along the way. Global conflict
--   graph and NGC stats
cmmNativeGen :: forall statics instr jumpDest. (Instruction instr, OutputableP Platform statics, Outputable jumpDest) => Logger -> NcgImpl statics instr jumpDest -> DUniqSupply -> DwarfFiles -> LabelMap DebugBlock -> RawCmmDecl -> Int -> IO (DUniqSupply, DwarfFiles, [NatCmmDecl statics instr], [CLabel], Maybe [RegAllocStats statics instr], Maybe [RegAllocStats], LabelMap [UnwindPoint], Maybe CFG)

-- | A Native Code Generator implementation is parametrised over * The type
--   of static data (typically related to <tt>CmmStatics</tt>) * The type
--   of instructions * The type of jump destinations
data NcgImpl statics instr jumpDest
NcgImpl :: !NCGConfig -> (RawCmmDecl -> NatM [NatCmmDecl statics instr]) -> (instr -> Maybe (NatCmmDecl statics instr)) -> (jumpDest -> Maybe BlockId) -> (instr -> Maybe jumpDest) -> ((BlockId -> Maybe jumpDest) -> statics -> statics) -> ((BlockId -> Maybe jumpDest) -> instr -> instr) -> (NatCmmDecl statics instr -> SDoc) -> (NatCmmDecl statics instr -> HDoc) -> Int -> [RealReg] -> (Int -> NatCmmDecl statics instr -> UniqDSM (NatCmmDecl statics instr, [(BlockId, BlockId)])) -> (Platform -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> UniqDSM [NatBasicBlock instr]) -> ([instr] -> [UnwindPoint]) -> (Maybe CFG -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> [NatBasicBlock instr]) -> NcgImpl statics instr jumpDest
[ncgConfig] :: NcgImpl statics instr jumpDest -> !NCGConfig
[cmmTopCodeGen] :: NcgImpl statics instr jumpDest -> RawCmmDecl -> NatM [NatCmmDecl statics instr]
[generateJumpTableForInstr] :: NcgImpl statics instr jumpDest -> instr -> Maybe (NatCmmDecl statics instr)

-- | Given a jump destination, if it refers to a block, return the block id
--   of the destination.
[getJumpDestBlockId] :: NcgImpl statics instr jumpDest -> jumpDest -> Maybe BlockId

-- | Does this jump always jump to a single destination and is
--   shortcutable?
--   
--   We use this to determine whether the given instruction is a
--   shortcutable jump to some destination - See Note [supporting
--   shortcutting] Note that if we return a destination here we *most*
--   support the relevant shortcutting in shortcutStatics for jump tables
--   and shortcutJump for the instructions itself.
[canShortcut] :: NcgImpl statics instr jumpDest -> instr -> Maybe jumpDest

-- | Replace references to blockIds with other destinations - used to
--   update jump tables.
[shortcutStatics] :: NcgImpl statics instr jumpDest -> (BlockId -> Maybe jumpDest) -> statics -> statics

-- | Change the jump destination(s) of an instruction.
--   
--   Rewrites the destination of a jump instruction to another destination,
--   if the given function returns a new jump destination for the
--   <a>BlockId</a> of the original destination.
--   
--   For instance, for a mapping <tt>block_a -&gt; dest_b</tt> and a
--   instruction <tt>goto block_a</tt> we would rewrite the instruction to
--   <tt>goto dest_b</tt>
[shortcutJump] :: NcgImpl statics instr jumpDest -> (BlockId -> Maybe jumpDest) -> instr -> instr

-- | <a>Module</a> is only for printing internal labels. See Note [Internal
--   proc labels] in CLabel.
[pprNatCmmDeclS] :: NcgImpl statics instr jumpDest -> NatCmmDecl statics instr -> SDoc
[pprNatCmmDeclH] :: NcgImpl statics instr jumpDest -> NatCmmDecl statics instr -> HDoc
[maxSpillSlots] :: NcgImpl statics instr jumpDest -> Int
[allocatableRegs] :: NcgImpl statics instr jumpDest -> [RealReg]

-- | The list of block ids records the redirected jumps to allow us to
--   update the CFG.
[ncgAllocMoreStack] :: NcgImpl statics instr jumpDest -> Int -> NatCmmDecl statics instr -> UniqDSM (NatCmmDecl statics instr, [(BlockId, BlockId)])
[ncgMakeFarBranches] :: NcgImpl statics instr jumpDest -> Platform -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> UniqDSM [NatBasicBlock instr]

-- | given the instruction sequence of a block, produce a list of the
--   block's <a>UnwindPoint</a>s See Note [What is this unwinding
--   business?] in <a>GHC.Cmm.DebugBlock</a> and Note [Unwinding
--   information in the NCG] in this module.
[extractUnwindPoints] :: NcgImpl statics instr jumpDest -> [instr] -> [UnwindPoint]

-- | Turn the sequence of <tt>jcc l1; jmp l2</tt> into <tt>jncc l2;
--   &lt;block_l1&gt;</tt> when possible.
[invertCondBranches] :: NcgImpl statics instr jumpDest -> Maybe CFG -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> [NatBasicBlock instr]

module GHC.Cmm.CommonBlockElim
elimCommonBlocks :: CmmGraph -> CmmGraph

module GHC.Cmm.CallConv
data ParamLocation
RegisterParam :: GlobalReg -> ParamLocation
StackParam :: ByteOff -> ParamLocation

-- | Given a list of arguments, and a function that tells their types,
--   return a list showing where each argument is passed
assignArgumentsPos :: Profile -> ByteOff -> Convention -> (a -> CmmType) -> [a] -> (ByteOff, [(a, ParamLocation)])
assignStack :: Platform -> ByteOff -> (a -> CmmType) -> [a] -> (ByteOff, [(a, ParamLocation)])

-- | A set of global registers that cover the machine registers used for
--   argument passing.
--   
--   See Note [realArgRegsCover].
realArgRegsCover :: Platform -> GlobalArgRegs -> [GlobalReg]

-- | Like "realArgRegsCover", but always includes the node.
--   
--   See Note [realArgRegsCover].
allArgRegsCover :: Platform -> GlobalArgRegs -> [GlobalReg]
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CallConv.ParamLocation

module GHC.Cmm.Graph

-- | CmmAGraph is a chunk of code consisting of:
--   
--   <ul>
--   <li>ordinary statements (assignments, stores etc.)</li>
--   <li>jumps</li>
--   <li>labels</li>
--   <li>out-of-line labelled blocks</li>
--   </ul>
--   
--   The semantics is that control falls through labels and out-of-line
--   blocks. Everything after a jump up to the next label is by definition
--   unreachable code, and will be discarded.
--   
--   Two CmmAGraphs can be stuck together with <a>*</a>, with the meaning
--   that control flows from the first to the second.
--   
--   A <a>CmmAGraph</a> can be turned into a <a>CmmGraph</a> (closed at
--   both ends) by providing a label for the entry point and a tick scope;
--   see <a>labelAGraph</a>.
type CmmAGraph = OrdList CgStmt

-- | Unlabeled graph with tick scope
type CmmAGraphScoped = (CmmAGraph, CmmTickScope)
data CgStmt
CgLabel :: BlockId -> CmmTickScope -> CgStmt
CgStmt :: CmmNode O O -> CgStmt
CgLast :: CmmNode O C -> CgStmt
CgFork :: BlockId -> CmmAGraph -> CmmTickScope -> CgStmt
(<*>) :: CmmAGraph -> CmmAGraph -> CmmAGraph
catAGraphs :: [CmmAGraph] -> CmmAGraph

-- | creates a sequence "goto id; id:" as an AGraph
mkLabel :: BlockId -> CmmTickScope -> CmmAGraph

-- | creates an open AGraph from a given node
mkMiddle :: CmmNode O O -> CmmAGraph

-- | creates a closed AGraph from a given node
mkLast :: CmmNode O C -> CmmAGraph

-- | A labelled code block; should end in a last node
outOfLine :: BlockId -> CmmAGraphScoped -> CmmAGraph

-- | allocate a fresh label for the entry point
lgraphOfAGraph :: CmmAGraphScoped -> UniqDSM DCmmGraph

-- | use the given BlockId as the label of the entry point
labelAGraph :: BlockId -> CmmAGraphScoped -> DCmmGraph
stackStubExpr :: Width -> CmmExpr
mkNop :: CmmAGraph
mkAssign :: CmmReg -> CmmExpr -> CmmAGraph

-- | Assumes natural alignment
mkStore :: CmmExpr -> CmmExpr -> CmmAGraph
mkUnsafeCall :: ForeignTarget -> [CmmFormal] -> [CmmActual] -> CmmAGraph
mkFinalCall :: Profile -> CmmExpr -> CCallConv -> [CmmExpr] -> UpdFrameOffset -> CmmAGraph
mkCallReturnsTo :: Profile -> CmmExpr -> Convention -> [CmmExpr] -> BlockId -> ByteOff -> UpdFrameOffset -> [CmmExpr] -> CmmAGraph
mkJumpReturnsTo :: Profile -> CmmExpr -> Convention -> [CmmExpr] -> BlockId -> ByteOff -> UpdFrameOffset -> CmmAGraph
mkJump :: Profile -> Convention -> CmmExpr -> [CmmExpr] -> UpdFrameOffset -> CmmAGraph
mkJumpExtra :: Profile -> Convention -> CmmExpr -> [CmmExpr] -> UpdFrameOffset -> [CmmExpr] -> CmmAGraph

-- | A jump where the caller says what the live GlobalRegs are. Used for
--   low-level hand-written Cmm.
mkRawJump :: Profile -> CmmExpr -> UpdFrameOffset -> [GlobalRegUse] -> CmmAGraph
mkCbranch :: CmmExpr -> BlockId -> BlockId -> Maybe Bool -> CmmAGraph
mkSwitch :: CmmExpr -> SwitchTargets -> CmmAGraph
mkReturn :: Profile -> CmmExpr -> [CmmExpr] -> UpdFrameOffset -> CmmAGraph
mkComment :: FastString -> CmmAGraph
mkCallEntry :: Profile -> Convention -> [CmmFormal] -> [CmmFormal] -> (Int, [GlobalRegUse], CmmAGraph)
mkBranch :: BlockId -> CmmAGraph

-- | Construct a <a>CmmUnwind</a> node for the given register and unwinding
--   expression.
mkUnwind :: GlobalReg -> CmmExpr -> CmmAGraph
copyInOflow :: Profile -> Convention -> Area -> [CmmFormal] -> [CmmFormal] -> (Int, [GlobalRegUse], CmmAGraph)
copyOutOflow :: Profile -> Convention -> Transfer -> Area -> [CmmExpr] -> UpdFrameOffset -> [CmmExpr] -> (Int, [GlobalRegUse], CmmAGraph)
noExtraStack :: [CmmExpr]
toCall :: CmmExpr -> Maybe BlockId -> UpdFrameOffset -> ByteOff -> ByteOff -> [GlobalRegUse] -> CmmAGraph
data Transfer
Call :: Transfer
JumpRet :: Transfer
Jump :: Transfer
Ret :: Transfer
instance GHC.Classes.Eq GHC.Cmm.Graph.Transfer

module GHC.StgToCmm.Monad
data FCode a
initC :: IO CgState
initFCodeState :: Platform -> FCodeState
runC :: StgToCmmConfig -> FCodeState -> CgState -> FCode a -> (a, CgState)
fixC :: (a -> FCode a) -> FCode a
newUnique :: FCode Unique
emitLabel :: BlockId -> FCode ()
emit :: CmmAGraph -> FCode ()
emitDecl :: DCmmDecl -> FCode ()
emitProcWithConvention :: Convention -> Maybe CmmInfoTable -> CLabel -> [CmmFormal] -> CmmAGraphScoped -> FCode ()
emitProcWithStackFrame :: Convention -> Maybe CmmInfoTable -> CLabel -> [CmmFormal] -> [CmmFormal] -> CmmAGraphScoped -> Bool -> FCode ()
emitOutOfLine :: BlockId -> CmmAGraphScoped -> FCode ()
emitAssign :: CmmReg -> CmmExpr -> FCode ()

-- | Assumes natural alignment.
emitStore :: CmmExpr -> CmmExpr -> FCode ()
emitStore' :: AlignmentSpec -> CmmExpr -> CmmExpr -> FCode ()
emitComment :: FastString -> FCode ()
emitTick :: CmmTickish -> FCode ()
emitUnwind :: [(GlobalReg, Maybe CmmExpr)] -> FCode ()
newTemp :: MonadGetUnique m => CmmType -> m LocalReg
getCmm :: FCode a -> FCode (a, DCmmGroup)
aGraphToGraph :: CmmAGraphScoped -> FCode DCmmGraph
getPlatform :: FCode Platform
getProfile :: FCode Profile
getCodeR :: FCode a -> FCode (a, CmmAGraph)
getCode :: FCode a -> FCode CmmAGraph

-- | Generate code into a fresh tick (sub-)scope and gather generated code
getCodeScoped :: FCode a -> FCode (a, CmmAGraphScoped)
getHeapUsage :: (VirtualHpOffset -> FCode a) -> FCode a
getContext :: FCode SDocContext
mkCmmIfThenElse :: CmmExpr -> CmmAGraph -> CmmAGraph -> FCode CmmAGraph
mkCmmIfThen :: CmmExpr -> CmmAGraph -> FCode CmmAGraph
mkCmmIfGoto :: CmmExpr -> BlockId -> FCode CmmAGraph
mkCmmIfThenElse' :: CmmExpr -> CmmAGraph -> CmmAGraph -> Maybe Bool -> FCode CmmAGraph
mkCmmIfThen' :: CmmExpr -> CmmAGraph -> Maybe Bool -> FCode CmmAGraph
mkCmmIfGoto' :: CmmExpr -> BlockId -> Maybe Bool -> FCode CmmAGraph
mkCall :: CmmExpr -> (Convention, Convention) -> [CmmFormal] -> [CmmExpr] -> UpdFrameOffset -> [CmmExpr] -> FCode CmmAGraph
mkCmmCall :: CmmExpr -> [CmmFormal] -> [CmmExpr] -> UpdFrameOffset -> FCode CmmAGraph
forkClosureBody :: FCode () -> FCode ()
forkLneBody :: FCode a -> FCode a
forkAlts :: [FCode a] -> FCode [a]
forkAltPair :: FCode a -> FCode a -> FCode (a, a)
codeOnly :: FCode () -> FCode ()

-- | A *zero-indexed* constructor tag
type ConTagZ = Int

-- | A Sequel tells what to do with the result of this expression
data Sequel

-- | Return result(s) to continuation found on the stack.
Return :: Sequel
AssignTo :: [LocalReg] -> Bool -> Sequel
data ReturnKind
AssignedDirectly :: ReturnKind
ReturnedTo :: BlockId -> ByteOff -> ReturnKind
withSequel :: Sequel -> FCode a -> FCode a
getSequel :: FCode Sequel
data SelfLoopInfo
MkSelfLoopInfo :: !Id -> !RepArity -> ![LocalReg] -> !BlockId -> SelfLoopInfo
[sli_id] :: SelfLoopInfo -> !Id

-- | always equal to <a>idFunRepArity</a> of sli_id, i.e. unarised arity,
--   including void arguments
[sli_arity] :: SelfLoopInfo -> !RepArity

-- | Excludes void arguments (LocalReg is never void)
[sli_registers] :: SelfLoopInfo -> ![LocalReg]
[sli_header_block] :: SelfLoopInfo -> !BlockId
setTickyCtrLabel :: CLabel -> FCode a -> FCode a
getTickyCtrLabel :: FCode CLabel

-- | Places blocks generated by the given code into a fresh (sub-)scope.
--   This will make sure that Cmm annotations in our scope will apply to
--   the Cmm blocks generated therein - but not the other way around.
tickScope :: FCode a -> FCode a

-- | The current tick scope. We will assign this to generated blocks.
getTickScope :: FCode CmmTickScope
withUpdFrameOff :: UpdFrameOffset -> FCode a -> FCode a
getUpdFrameOff :: FCode UpdFrameOffset
data HeapUsage
HeapUsage :: VirtualHpOffset -> VirtualHpOffset -> HeapUsage
[virtHp] :: HeapUsage -> VirtualHpOffset
[realHp] :: HeapUsage -> VirtualHpOffset
type VirtualHpOffset = WordOff
initHpUsage :: HeapUsage
getHpUsage :: FCode HeapUsage
setHpUsage :: HeapUsage -> FCode ()
heapHWM :: HeapUsage -> VirtualHpOffset
setVirtHp :: VirtualHpOffset -> FCode ()
getVirtHp :: FCode VirtualHpOffset
setRealHp :: VirtualHpOffset -> FCode ()
getModuleName :: FCode Module
getState :: FCode CgState
setState :: CgState -> FCode ()
getSelfLoop :: FCode (Maybe SelfLoopInfo)
withSelfLoop :: SelfLoopInfo -> FCode a -> FCode a
getStgToCmmConfig :: FCode StgToCmmConfig
data CgIdInfo
CgIdInfo :: Id -> LambdaFormInfo -> CgLoc -> CgIdInfo

-- | Id that this is the info for
[cg_id] :: CgIdInfo -> Id
[cg_lf] :: CgIdInfo -> LambdaFormInfo

-- | <a>CmmExpr</a> for the *tagged* value
[cg_loc] :: CgIdInfo -> CgLoc
getBinds :: FCode CgBindings
setBinds :: CgBindings -> FCode ()
data StgToCmmConfig
StgToCmmConfig :: !Profile -> Module -> !TempDir -> !SDocContext -> !Bool -> !Maybe Word -> !Int -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> (FMASign -> Bool) -> !Bool -> !Bool -> Maybe String -> !Bool -> !Bool -> !Bool -> StgToCmmConfig

-- | Current profile
[stgToCmmProfile] :: StgToCmmConfig -> !Profile

-- | The module being compiled. This field kept lazy for Cmm/Parser.y which
--   preloads it with a panic
[stgToCmmThisModule] :: StgToCmmConfig -> Module

-- | Temp Dir for files used in compilation
[stgToCmmTmpDir] :: StgToCmmConfig -> !TempDir

-- | Context for StgToCmm phase
[stgToCmmContext] :: StgToCmmConfig -> !SDocContext

-- | Whether we wish to output debug information
[stgToCmmEmitDebugInfo] :: StgToCmmConfig -> !Bool

-- | Threshold at which Binary literals (e.g. strings) are either dumped to
--   a file and a CmmFileEmbed literal is emitted (over threshold), or
--   become a CmmString Literal (under or at threshold). CmmFileEmbed is
--   only supported with the NCG, thus a Just means two things: We have a
--   threshold, and will be using the NCG. Conversely, a Nothing implies we
--   are not using NCG and disables CmmFileEmbed. See Note [Embedding large
--   binary blobs] in GHC.CmmToAsm.Ppr, and <tt>cgTopBinding</tt> in
--   GHC.StgToCmm.
[stgToCmmBinBlobThresh] :: StgToCmmConfig -> !Maybe Word

-- | Max size, in bytes, of inline array allocations.
[stgToCmmMaxInlAllocSize] :: StgToCmmConfig -> !Int

-- | Ticky profiling enabled (cf <tt>-ticky</tt>)
[stgToCmmDoTicky] :: StgToCmmConfig -> !Bool

-- | True indicates ticky prof traces allocs of each named thing in
--   addition to allocs _by_ that thing
[stgToCmmTickyAllocd] :: StgToCmmConfig -> !Bool

-- | True indicates ticky uses name-specific counters for join-points
--   (let-no-escape)
[stgToCmmTickyLNE] :: StgToCmmConfig -> !Bool

-- | True indicates ticky uses name-specific counters for dynamic thunks
[stgToCmmTickyDynThunk] :: StgToCmmConfig -> !Bool

-- | True indicates ticky will count number of avoided tag checks by tag
--   inference.
[stgToCmmTickyTag] :: StgToCmmConfig -> !Bool

-- | Loopification enabled (cf <tt>-floopification</tt>)
[stgToCmmLoopification] :: StgToCmmConfig -> !Bool

-- | Insert alignment check (cf <tt>-falignment-sanitisation</tt>)
[stgToCmmAlignCheck] :: StgToCmmConfig -> !Bool
[stgToCmmFastPAPCalls] :: StgToCmmConfig -> !Bool

-- | Check if cost-centre profiling is enabled
[stgToCmmSCCProfiling] :: StgToCmmConfig -> !Bool
[stgToCmmEagerBlackHole] :: StgToCmmConfig -> !Bool

-- | Push <tt>stg_orig_thunk_info</tt> frames during thunk update.
[stgToCmmOrigThunkInfo] :: StgToCmmConfig -> !Bool

-- | true means generate C Stub for IPE map, See Note [Mapping Info Tables
--   to Source Positions]
[stgToCmmInfoTableMap] :: StgToCmmConfig -> !Bool

-- | Include info tables with fallback source locations in the info table
--   map
[stgToCmmInfoTableMapWithFallback] :: StgToCmmConfig -> !Bool

-- | Include info tables for STACK closures in the info table map
[stgToCmmInfoTableMapWithStack] :: StgToCmmConfig -> !Bool

-- | true means omit heap checks when no allocation is performed
[stgToCmmOmitYields] :: StgToCmmConfig -> !Bool

-- | true means don't generate interface programs (implied by -O0)
[stgToCmmOmitIfPragmas] :: StgToCmmConfig -> !Bool

-- | true if <tt>-fPIC</tt>
[stgToCmmPIC] :: StgToCmmConfig -> !Bool

-- | true if <tt>-fPIE</tt>
[stgToCmmPIE] :: StgToCmmConfig -> !Bool

-- | true if <tt>-fexternal-dynamic-refs</tt>, meaning generate code for
--   linking against dynamic libraries
[stgToCmmExtDynRefs] :: StgToCmmConfig -> !Bool

-- | decides whether to check array bounds in StgToCmm.Prim or not
[stgToCmmDoBoundsCheck] :: StgToCmmConfig -> !Bool

-- | Verify tag inference predictions.
[stgToCmmDoTagCheck] :: StgToCmmConfig -> !Bool

-- | Enable deterministic code generation (more precisely, the
--   deterministic unique-renaming pass in StgToCmm)
[stgToCmmObjectDeterminism] :: StgToCmmConfig -> !Bool

-- | Allowed to emit 64-bit arithmetic operations
[stgToCmmAllowArith64] :: StgToCmmConfig -> !Bool

-- | Allowed to emit 64-bit division operations
[stgToCmmAllowQuot64] :: StgToCmmConfig -> !Bool

-- | Allowed to generate QuotRem instructions
[stgToCmmAllowQuotRemInstr] :: StgToCmmConfig -> !Bool

-- | Allowed to generate QuotRem
[stgToCmmAllowQuotRem2] :: StgToCmmConfig -> !Bool

-- | Allowed to generate AddWordC, SubWordC, Add2, etc.
[stgToCmmAllowExtendedAddSubInstrs] :: StgToCmmConfig -> !Bool

-- | Allowed to generate IntMul2 instruction
[stgToCmmAllowIntMul2Instr] :: StgToCmmConfig -> !Bool

-- | Allowed to generate WordMul2 instruction
[stgToCmmAllowWordMul2Instr] :: StgToCmmConfig -> !Bool

-- | Allowed to generate FMA instruction
[stgToCmmAllowFMAInstr] :: StgToCmmConfig -> FMASign -> Bool

-- | Disable use of precomputed standard thunks.
[stgToCmmTickyAP] :: StgToCmmConfig -> !Bool

-- | Save a foreign call target to a Cmm local, see Note [Saving foreign
--   call target to local] for details
[stgToCmmSaveFCallTargetToLocal] :: StgToCmmConfig -> !Bool

-- | Error (if any) to raise when vector instructions are used, see
--   <tt>StgToCmm.Prim.checkVecCompatibility</tt>
[stgToCmmVecInstrsErr] :: StgToCmmConfig -> Maybe String

-- | check for Advanced Vector Extensions
[stgToCmmAvx] :: StgToCmmConfig -> !Bool

-- | check for Advanced Vector Extensions 2
[stgToCmmAvx2] :: StgToCmmConfig -> !Bool

-- | check for Advanced Vector 512-bit Extensions
[stgToCmmAvx512f] :: StgToCmmConfig -> !Bool
data CgState
MkCgState :: CmmAGraph -> OrdList DCmmDecl -> CgBindings -> HeapUsage -> UniqSupply -> CgState
[cgs_stmts] :: CgState -> CmmAGraph
[cgs_tops] :: CgState -> OrdList DCmmDecl
[cgs_binds] :: CgState -> CgBindings
[cgs_hp_usg] :: CgState -> HeapUsage
[cgs_uniqs] :: CgState -> UniqSupply
instance GHC.Internal.Base.Applicative GHC.StgToCmm.Monad.FCode
instance GHC.Internal.Base.Functor GHC.StgToCmm.Monad.FCode
instance GHC.Internal.Base.Monad GHC.StgToCmm.Monad.FCode
instance GHC.Types.Unique.DSM.MonadGetUnique GHC.StgToCmm.Monad.FCode
instance GHC.Types.Unique.Supply.MonadUnique GHC.StgToCmm.Monad.FCode
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.StgToCmm.Monad.CgIdInfo

module GHC.StgToCmm.InfoTableProv
emitIpeBufferListNode :: Module -> [InfoProvEnt] -> DUniqSupply -> FCode DUniqSupply

module GHC.StgToCmm.Hpc
mkTickBox :: Platform -> Module -> Int -> CmmAGraph


-- | Our extended FCode monad.
module GHC.StgToCmm.ExtCode

-- | Does a computation in the FCode monad, with a current environment and
--   a list of local declarations. Returns the resulting list of
--   declarations.
data CmmParse a
unEC :: CmmParse a -> String -> Env -> Decls -> FCode (Decls, a)

-- | The environment contains variable definitions or blockids.
data Named

-- | Holds CmmLit(CmmLabel ..) which gives the label type, eg, RtsLabel,
--   ForeignLabel, CmmLabel etc.
VarN :: CmmExpr -> Named

-- | A function name from this unit
FunN :: UnitId -> Named

-- | A blockid of some code or data.
LabelN :: BlockId -> Named

-- | An environment of named things.
type Env = UniqFM FastString Named

-- | Takes the variable declarations and imports from the monad and makes
--   an environment, which is looped back into the computation. In this
--   way, we can have embedded declarations that scope over the whole
--   procedure, and imports that scope over the entire module. Discards the
--   local declaration contained within decl'
loopDecls :: CmmParse a -> CmmParse a

-- | Get the current environment from the monad.
getEnv :: CmmParse Env

-- | Set context name for a sub-parse
withName :: String -> CmmParse a -> CmmParse a

-- | Get the current context name from the monad
getName :: CmmParse String

-- | Create a fresh local variable of a given type.
newLocal :: CmmType -> FastString -> CmmParse LocalReg

-- | Allocate a fresh label.
newLabel :: FastString -> CmmParse BlockId
newBlockId :: MonadGetUnique m => m BlockId

-- | Add a local function to the environment.
newFunctionName :: FastString -> UnitId -> ExtCode

-- | Add an imported foreign label to the list of local declarations. If
--   this is done at the start of the module the declaration will scope
--   over the whole module.
newImport :: (FastString, CLabel) -> CmmParse ()

-- | Lookup the BlockId bound to the label with this name. If one hasn't
--   been bound yet, create a fresh one based on the Unique of the name.
lookupLabel :: FastString -> CmmParse BlockId

-- | Lookup the location of a named variable. Unknown names are treated as
--   if they had been 'import'ed from the runtime system. This saves us a
--   lot of bother in the RTS sources, at the expense of deferring some
--   errors to link time.
lookupName :: FastString -> CmmParse CmmExpr

-- | Lift an FCode computation into the CmmParse monad
code :: FCode a -> CmmParse a
emit :: CmmAGraph -> CmmParse ()
emitLabel :: BlockId -> CmmParse ()
emitAssign :: CmmReg -> CmmExpr -> CmmParse ()
emitStore :: Maybe MemoryOrdering -> CmmExpr -> CmmExpr -> CmmParse ()
getCode :: CmmParse a -> CmmParse CmmAGraph
getCodeR :: CmmParse a -> CmmParse (a, CmmAGraph)
getCodeScoped :: CmmParse a -> CmmParse (a, CmmAGraphScoped)
emitOutOfLine :: BlockId -> CmmAGraphScoped -> CmmParse ()
withUpdFrameOff :: UpdFrameOffset -> CmmParse () -> CmmParse ()
getUpdFrameOff :: CmmParse UpdFrameOffset
getProfile :: CmmParse Profile
getPlatform :: CmmParse Platform
getContext :: CmmParse SDocContext
instance GHC.Internal.Base.Applicative GHC.StgToCmm.ExtCode.CmmParse
instance GHC.Internal.Base.Functor GHC.StgToCmm.ExtCode.CmmParse
instance GHC.Internal.Base.Monad GHC.StgToCmm.ExtCode.CmmParse
instance GHC.Types.Unique.DSM.MonadGetUnique GHC.StgToCmm.ExtCode.CmmParse
instance GHC.Types.Unique.Supply.MonadUnique GHC.StgToCmm.ExtCode.CmmParse

module GHC.StgToCmm.Env
data CgIdInfo
mkCgIdInfo :: Id -> LambdaFormInfo -> CmmExpr -> CgIdInfo
litIdInfo :: Platform -> Id -> LambdaFormInfo -> CmmLit -> CgIdInfo
lneIdInfo :: Platform -> Id -> [NonVoid Id] -> CgIdInfo
rhsIdInfo :: Id -> LambdaFormInfo -> FCode (CgIdInfo, LocalReg)
mkRhsInit :: Platform -> LocalReg -> LambdaFormInfo -> CmmExpr -> CmmAGraph

-- | Returns a <a>CmmExpr</a> for the *tagged* pointer
idInfoToAmode :: CgIdInfo -> CmmExpr
addBindC :: CgIdInfo -> FCode ()
addBindsC :: [CgIdInfo] -> FCode ()
bindArgsToRegs :: [NonVoid Id] -> FCode [LocalReg]
bindToReg :: NonVoid Id -> LambdaFormInfo -> FCode LocalReg
rebindToReg :: NonVoid Id -> FCode LocalReg
bindArgToReg :: NonVoid Id -> FCode LocalReg
idToReg :: Platform -> NonVoid Id -> LocalReg
getCgIdInfo :: Id -> FCode CgIdInfo

-- | Retrieve cg info for a name if it already exists.
getCgInfo_maybe :: Name -> FCode (Maybe CgIdInfo)
maybeLetNoEscape :: CgIdInfo -> Maybe (BlockId, [LocalReg])

module GHC.StgToCmm.Lit
cgLit :: Literal -> FCode CmmExpr
mkSimpleLit :: Platform -> Literal -> CmmLit

-- | Make a global definition for the string, and return its label
newStringCLit :: String -> FCode CmmLit
newByteStringCLit :: ByteString -> FCode CmmLit

module GHC.StgToCmm.Utils

-- | Emit a data-segment data block
emitDataLits :: CLabel -> [CmmLit] -> FCode ()

-- | Emit a read-only data block
emitRODataLits :: CLabel -> [CmmLit] -> FCode ()
emitDataCon :: CLabel -> CmmInfoTable -> CostCentreStack -> [CmmLit] -> FCode ()
emitRtsCall :: UnitId -> FastString -> [(CmmExpr, ForeignHint)] -> Bool -> FCode ()
emitRtsCallWithResult :: LocalReg -> ForeignHint -> UnitId -> FastString -> [(CmmExpr, ForeignHint)] -> Bool -> FCode ()
emitRtsCallGen :: [(LocalReg, ForeignHint)] -> CLabel -> [(CmmExpr, ForeignHint)] -> Bool -> FCode ()
emitBarf :: String -> FCode ()
assignTemp :: CmmExpr -> FCode LocalReg
newTemp :: MonadGetUnique m => CmmType -> m LocalReg
newUnboxedTupleRegs :: Type -> FCode ([LocalReg], [ForeignHint])
emitMultiAssign :: [LocalReg] -> [CmmExpr] -> FCode ()
emitCmmLitSwitch :: CmmExpr -> [(Literal, CmmAGraphScoped)] -> CmmAGraphScoped -> FCode ()
emitSwitch :: CmmExpr -> [(ConTagZ, CmmAGraphScoped)] -> Maybe CmmAGraphScoped -> ConTagZ -> ConTagZ -> FCode ()
tagToClosure :: Platform -> TyCon -> CmmExpr -> CmmExpr
mkTaggedObjectLoad :: Platform -> LocalReg -> LocalReg -> ByteOff -> DynTag -> CmmAGraph

-- | Returns <a>True</a> if this global register is stored in a
--   caller-saves machine register.
callerSaves :: Platform -> GlobalReg -> Bool
callerSaveVolatileRegs :: Platform -> (CmmAGraph, CmmAGraph)

-- | We map STG registers onto appropriate CmmExprs. Either they map to
--   real machine registers or stored as offsets from BaseReg. Given a
--   GlobalReg, get_GlobalReg_addr always produces the register table
--   address for it.
get_GlobalReg_addr :: Platform -> GlobalReg -> CmmExpr
callerSaveGlobalReg :: Platform -> GlobalReg -> CmmAGraph
callerRestoreGlobalReg :: Platform -> GlobalReg -> CmmAGraph
cmmAndWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmOrWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmNegate :: Platform -> CmmExpr -> CmmExpr
cmmEqWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmNeWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmUGtWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmSubWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmMulWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmAddWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmUShrWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmOffsetExprW :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmOffsetExprB :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmRegOffW :: Platform -> CmmReg -> WordOff -> CmmExpr
cmmRegOffB :: CmmReg -> ByteOff -> CmmExpr
cmmLabelOffW :: Platform -> CLabel -> WordOff -> CmmLit
cmmLabelOffB :: CLabel -> ByteOff -> CmmLit
cmmOffsetW :: Platform -> CmmExpr -> WordOff -> CmmExpr
cmmOffsetB :: Platform -> CmmExpr -> ByteOff -> CmmExpr
cmmOffsetLitW :: Platform -> CmmLit -> WordOff -> CmmLit
cmmOffsetLitB :: CmmLit -> ByteOff -> CmmLit
cmmLoadIndexW :: Platform -> CmmExpr -> Int -> CmmType -> CmmExpr
cmmConstrTag1 :: Platform -> CmmExpr -> CmmExpr
cmmUntag :: Platform -> CmmExpr -> CmmExpr
cmmIsTagged :: Platform -> CmmExpr -> CmmExpr

-- | <tt>addToMem rep ptr n</tt> adds <tt>n</tt> to the integer pointed-to
--   by <tt>ptr</tt>.
addToMem :: CmmType -> CmmExpr -> Int -> CmmAGraph

-- | <tt>addToMemE rep ptr n</tt> adds <tt>n</tt> to the integer pointed-to
--   by <tt>ptr</tt>.
addToMemE :: CmmType -> CmmExpr -> CmmExpr -> CmmAGraph
addToMemLblE :: CmmType -> CLabel -> CmmExpr -> CmmAGraph
addToMemLbl :: CmmType -> CLabel -> Int -> CmmAGraph
emitAtomicRead :: MemoryOrdering -> LocalReg -> CmmExpr -> FCode ()
emitAtomicWrite :: MemoryOrdering -> CmmExpr -> CmmExpr -> FCode ()
whenUpdRemSetEnabled :: FCode a -> FCode ()

-- | Emit code to add an entry to a now-overwritten pointer to the update
--   remembered set.
emitUpdRemSetPush :: CmmExpr -> FCode ()
emitUpdRemSetPushThunk :: CmmExpr -> FCode ()

-- | Convert source information collected about identifiers in <a>Debug</a>
--   to entries suitable for placing into the info table provenance table.
--   
--   The initial stats given to this function will (or should) only contain
--   stats for stack info tables skipped during <tt>generateCgIPEStub</tt>.
--   As the fold progresses, counts of tables per closure type will be
--   accumulated.
convertInfoProvMap :: StgToCmmConfig -> Module -> InfoTableProvMap -> IPEStats -> [CmmInfoTable] -> (IPEStats, [InfoProvEnt])

-- | A bare bones InfoProvEnt for things which don't have a good source
--   location
cmmInfoTableToInfoProvEnt :: Module -> CmmInfoTable -> InfoProvEnt
data IPEStats
IPEStats :: !Int -> !IntMap Int -> !Int -> !Int -> IPEStats
[ipe_total] :: IPEStats -> !Int
[ipe_closure_types] :: IPEStats -> !IntMap Int
[ipe_fallback] :: IPEStats -> !Int
[ipe_skipped] :: IPEStats -> !Int
closureIpeStats :: Int -> IPEStats
fallbackIpeStats :: IPEStats
skippedIpeStats :: IPEStats
instance GHC.Internal.Base.Monoid GHC.StgToCmm.Utils.IPEStats
instance GHC.Utils.Outputable.Outputable GHC.StgToCmm.Utils.IPEStats
instance GHC.Internal.Base.Semigroup GHC.StgToCmm.Utils.IPEStats

module GHC.StgToCmm.TagCheck

-- | Call barf if we failed to predict a tag correctly. This is immensely
--   useful when debugging issues in tag inference as it will result in a
--   program abort when we encounter an invalid call/heap object, rather
--   than leaving it be and segfaulting arbitrary or producing invalid
--   results. We check if either: * A tag is present * Or the object is a
--   25 (for which zero is the proper tag)
emitTagAssertion :: String -> CmmExpr -> FCode ()
emitArgTagCheck :: SDoc -> [CbvMark] -> [Id] -> FCode ()
checkArg :: SDoc -> CbvMark -> StgArg -> FCode ()
whenCheckTags :: FCode () -> FCode ()
checkArgStatic :: SDoc -> StrictnessMark -> StgArg -> FCode ()

-- | Check all arguments marked as cbv for the presence of a tag *at
--   runtime*.
checkFunctionArgTags :: SDoc -> Id -> [Id] -> FCode ()

-- | Check all required-tagged arguments of a constructor are tagged *at
--   compile time*.
checkConArgsStatic :: SDoc -> DataCon -> [StgArg] -> FCode ()
checkConArgsDyn :: SDoc -> DataCon -> [StgArg] -> FCode ()

module GHC.StgToCmm.Ticky
withNewTickyCounterFun :: Bool -> Id -> [NonVoid Id] -> [NonVoid Id] -> FCode a -> FCode a
withNewTickyCounterLNE :: Id -> [NonVoid Id] -> FCode a -> FCode a
withNewTickyCounterThunk :: Bool -> Bool -> Id -> [NonVoid Id] -> FCode a -> FCode a
withNewTickyCounterStdThunk :: Bool -> Id -> [StgArg] -> FCode a -> FCode a
withNewTickyCounterCon :: Id -> DataCon -> ConstructorNumber -> FCode a -> FCode a
emitTickyCounterTag :: Unique -> NonVoid Id -> FCode CLabel
tickyDynAlloc :: Maybe Id -> SMRep -> LambdaFormInfo -> FCode ()
tickyAllocHeap :: Bool -> VirtualHpOffset -> FCode ()
tickyAllocPrim :: CmmExpr -> CmmExpr -> CmmExpr -> FCode ()
tickyAllocThunk :: CmmExpr -> CmmExpr -> FCode ()
tickyAllocPAP :: CmmExpr -> CmmExpr -> FCode ()
tickyHeapCheck :: FCode ()
tickyStackCheck :: FCode ()
tickyDirectCall :: RepArity -> [StgArg] -> FCode ()
tickyPushUpdateFrame :: FCode ()
tickyUpdateFrameOmitted :: FCode ()
tickyEnterDynCon :: FCode ()
tickyEnterFun :: ClosureInfo -> FCode ()
tickyEnterThunk :: ClosureInfo -> FCode ()
tickyEnterLNE :: FCode ()
tickyUpdateBhCaf :: ClosureInfo -> FCode ()
tickyUnboxedTupleReturn :: RepArity -> FCode ()
tickyReturnOldCon :: RepArity -> FCode ()
tickyReturnNewCon :: RepArity -> FCode ()
tickyKnownCallTooFewArgs :: FCode ()
tickyKnownCallExact :: FCode ()
tickyKnownCallExtraArgs :: FCode ()
tickySlowCall :: LambdaFormInfo -> [StgArg] -> FCode ()
tickySlowCallPat :: [StgArg] -> FCode ()

-- | Predicted a pointer would be tagged correctly (GHC will crash if not
--   so no miss case)
tickyTagged :: FCode ()

-- | Pass a boolean expr indicating if tag was present.
tickyUntagged :: CmmExpr -> FCode ()

-- | Called when for `case v of ...` we can avoid entering v based on tag
--   inference information.
tickyTagSkip :: Unique -> Id -> FCode ()
instance GHC.Utils.Json.ToJson GHC.StgToCmm.Ticky.TickyClosureType

module GHC.StgToCmm.Layout
mkArgDescr :: Platform -> [Id] -> ArgDescr

-- | <tt>emitCall conv fun args</tt> makes a call to the entry-code of
--   <tt>fun</tt>, using the call/return convention <tt>conv</tt>, passing
--   <tt>args</tt>, and returning the results to the current sequel.
emitCall :: (Convention, Convention) -> CmmExpr -> [CmmExpr] -> FCode ReturnKind

-- | Return multiple values to the sequel
--   
--   If the sequel is <tt>Return</tt>
--   
--   <pre>
--   return (x,y)
--   </pre>
--   
--   If the sequel is <tt>AssignTo [p,q]</tt>
--   
--   <pre>
--   p=x; q=y;
--   </pre>
emitReturn :: [CmmExpr] -> FCode ReturnKind
adjustHpBackwards :: FCode ()
emitClosureProcAndInfoTable :: Bool -> Id -> LambdaFormInfo -> CmmInfoTable -> [NonVoid Id] -> ((Int, LocalReg, [LocalReg]) -> FCode ()) -> FCode ()
emitClosureAndInfoTable :: Platform -> CmmInfoTable -> Convention -> [LocalReg] -> FCode () -> FCode ()
slowCall :: CmmExpr -> [StgArg] -> FCode ReturnKind
directCall :: Convention -> CLabel -> RepArity -> [StgArg] -> FCode ReturnKind
data FieldOffOrPadding a
FieldOff :: NonVoid a -> ByteOff -> FieldOffOrPadding a
Padding :: ByteOff -> ByteOff -> FieldOffOrPadding a

-- | Used to tell the various <tt>mkVirtHeapOffsets</tt> functions what
--   kind of header the object has. This will be accounted for in the
--   offsets of the fields returned.
data ClosureHeader
NoHeader :: ClosureHeader
StdHeader :: ClosureHeader
ThunkHeader :: ClosureHeader
mkVirtHeapOffsets :: Profile -> ClosureHeader -> [NonVoid (PrimRep, a)] -> (WordOff, WordOff, [(NonVoid a, ByteOff)])
mkVirtHeapOffsetsWithPadding :: Profile -> ClosureHeader -> [NonVoid (PrimRep, a)] -> (WordOff, WordOff, [FieldOffOrPadding a])

-- | Just like mkVirtHeapOffsets, but for constructors
mkVirtConstrOffsets :: Profile -> [NonVoid (PrimRep, a)] -> (WordOff, WordOff, [(NonVoid a, ByteOff)])

-- | Just like mkVirtConstrOffsets, but used when we don't have the actual
--   arguments. Useful when e.g. generating info tables; we just need to
--   know sizes of pointer and non-pointer fields.
mkVirtConstrSizes :: Profile -> [PrimRep] -> (WordOff, WordOff)
getHpRelOffset :: VirtualHpOffset -> FCode CmmExpr
data ArgRep
P :: ArgRep
N :: ArgRep
L :: ArgRep
V :: ArgRep
F :: ArgRep
D :: ArgRep
V16 :: ArgRep
V32 :: ArgRep
V64 :: ArgRep
toArgRep :: Platform -> PrimRep -> ArgRep
toArgRepOrV :: Platform -> PrimOrVoidRep -> ArgRep
idArgRep :: Platform -> Id -> ArgRep
argRepSizeW :: Platform -> ArgRep -> WordOff
getArgAmode :: NonVoid StgArg -> FCode CmmExpr
getNonVoidArgAmodes :: [StgArg] -> FCode [CmmExpr]


-- | Provides the heuristics for when it's beneficial to lambda lift
--   bindings. Most significantly, this employs a cost model to estimate
--   impact on heap allocations, by looking at an STG expression's
--   <a>Skeleton</a>.
module GHC.Stg.Lift.Analysis

-- | Captures details of the syntax tree relevant to the cost model, such
--   as closures, multi-shot lambdas and case expressions.
data Skeleton
ClosureSk :: !Id -> !DIdSet -> !Skeleton -> Skeleton
RhsSk :: !Card -> !Skeleton -> Skeleton
AltSk :: !Skeleton -> !Skeleton -> Skeleton
BothSk :: !Skeleton -> !Skeleton -> Skeleton
NilSk :: Skeleton

-- | The type used in binder positions in <tt>GenStgExpr</tt>s.
data BinderInfo

-- | Let(-no-escape)-bound thing with a flag indicating whether it occurs
--   as an argument or in a nullary application (see
--   <a>GHC.Stg.Lift.Analysis#arg_occs</a>).
BindsClosure :: !Id -> !Bool -> BinderInfo

-- | Every other kind of binder
BoringBinder :: !Id -> BinderInfo

-- | Gets the bound <a>Id</a> out a <a>BinderInfo</a>.
binderInfoBndr :: BinderInfo -> Id
type LlStgBinding = GenStgBinding 'LiftLams
type LlStgExpr = GenStgExpr 'LiftLams
type LlStgRhs = GenStgRhs 'LiftLams
type LlStgAlt = GenStgAlt 'LiftLams

-- | Tags every binder with its <a>BinderInfo</a> and let bindings with
--   their <a>Skeleton</a>s.
tagSkeletonTopBind :: CgStgBinding -> LlStgBinding

-- | Combines several heuristics to decide whether to lambda-lift a given
--   <tt>let</tt>-binding to top-level. See
--   <a>GHC.Stg.Lift.Analysis#when</a> for details.
goodToLift :: StgLiftConfig -> TopLevelFlag -> RecFlag -> (DIdSet -> DIdSet) -> [(BinderInfo, LlStgRhs)] -> Skeleton -> Maybe DIdSet

-- | <tt>closureGrowth expander sizer f fvs</tt> computes the closure
--   growth in words as a result of lifting <tt>f</tt> to top-level. If
--   there was any growing closure under a multi-shot lambda, the result
--   will be <a>infinity</a>. Also see <a>GHC.Stg.Lift.Analysis#clogro</a>.
closureGrowth :: (DIdSet -> DIdSet) -> (Id -> Int) -> IdSet -> DIdSet -> Skeleton -> IntWithInf


-- | Implements a selective lambda lifter, running late in the optimisation
--   pipeline.
--   
--   If you are interested in the cost model that is employed to decide
--   whether to lift a binding or not, look at
--   <a>GHC.Stg.Lift.Analysis</a>. <a>GHC.Stg.Lift.Monad</a> contains the
--   transformation monad that hides away some plumbing of the
--   transformation.
module GHC.Stg.Lift
data StgLiftConfig
StgLiftConfig :: !Profile -> !Maybe Int -> !Maybe Int -> !Bool -> StgLiftConfig
[c_targetProfile] :: StgLiftConfig -> !Profile

-- | Maximum number of arguments after lambda lifting a recursive function.
[c_liftLamsRecArgs] :: StgLiftConfig -> !Maybe Int

-- | Maximum number of arguments after lambda lifting non-recursive
--   function.
[c_liftLamsNonRecArgs] :: StgLiftConfig -> !Maybe Int

-- | Lambda lift even when this turns a known call into an unknown call.
[c_liftLamsKnown] :: StgLiftConfig -> !Bool

-- | Lambda lifts bindings to top-level deemed worth lifting (see
--   <a>goodToLift</a>).
--   
--   (Mostly) textbook instance of the lambda lifting transformation,
--   selecting which bindings to lambda lift by consulting
--   <a>goodToLift</a>.
stgLiftLams :: Module -> StgLiftConfig -> UniqSupply -> [InStgTopBinding] -> [OutStgTopBinding]


-- | Bytecode assembler types
module GHC.ByteCode.Types
data CompiledByteCode
CompiledByteCode :: FlatBag UnlinkedBCO -> ItblEnv -> [FFIInfo] -> AddrEnv -> Maybe ModBreaks -> ![SptEntry] -> CompiledByteCode

-- | Bunch of interpretable bindings
[bc_bcos] :: CompiledByteCode -> FlatBag UnlinkedBCO

-- | Mapping from DataCons to their info tables
[bc_itbls] :: CompiledByteCode -> ItblEnv

-- | ffi blocks we allocated
[bc_ffis] :: CompiledByteCode -> [FFIInfo]

-- | top-level strings (heap allocated)
[bc_strs] :: CompiledByteCode -> AddrEnv

-- | breakpoint info (Nothing if breakpoints are disabled)
[bc_breaks] :: CompiledByteCode -> Maybe ModBreaks

-- | Static pointer table entries which should be loaded along with the
--   BCOs. See Note [Grand plan for static forms] in
--   <a>GHC.Iface.Tidy.StaticPtrTable</a>.
[bc_spt_entries] :: CompiledByteCode -> ![SptEntry]
seqCompiledByteCode :: CompiledByteCode -> ()

-- | Wrapper for a <a>ByteArray#</a>. The phantom type tells what elements
--   are stored in the <a>ByteArray#</a>. Creating a <a>ByteArray#</a> can
--   be achieved using <tt>UArray'</tt>s API, where the underlying
--   <a>ByteArray#</a> can be unpacked.
data BCOByteArray a
BCOByteArray :: !ByteArray# -> BCOByteArray a
[getBCOByteArray] :: BCOByteArray a -> !ByteArray#
mkBCOByteArray :: UArray Int a -> BCOByteArray a
newtype FFIInfo
FFIInfo :: RemotePtr C_ffi_cif -> FFIInfo
newtype RegBitmap
RegBitmap :: Word32 -> RegBitmap
[unRegBitmap] :: RegBitmap -> Word32
data NativeCallType
NativePrimCall :: NativeCallType
NativeTupleReturn :: NativeCallType
data NativeCallInfo
NativeCallInfo :: !NativeCallType -> !WordOff -> !GlobalRegSet -> !WordOff -> NativeCallInfo
[nativeCallType] :: NativeCallInfo -> !NativeCallType
[nativeCallSize] :: NativeCallInfo -> !WordOff
[nativeCallRegs] :: NativeCallInfo -> !GlobalRegSet
[nativeCallStackSpillSize] :: NativeCallInfo -> !WordOff
voidTupleReturnInfo :: NativeCallInfo
voidPrimCallInfo :: NativeCallInfo
newtype ByteOff
ByteOff :: Int -> ByteOff
newtype WordOff
WordOff :: Int -> WordOff
newtype HalfWord
HalfWord :: Word -> HalfWord
data UnlinkedBCO
UnlinkedBCO :: !Name -> {-# UNPACK #-} !Int -> !BCOByteArray Word16 -> !BCOByteArray Word -> !FlatBag BCONPtr -> !FlatBag BCOPtr -> UnlinkedBCO
[unlinkedBCOName] :: UnlinkedBCO -> !Name
[unlinkedBCOArity] :: UnlinkedBCO -> {-# UNPACK #-} !Int
[unlinkedBCOInstrs] :: UnlinkedBCO -> !BCOByteArray Word16
[unlinkedBCOBitmap] :: UnlinkedBCO -> !BCOByteArray Word
[unlinkedBCOLits] :: UnlinkedBCO -> !FlatBag BCONPtr
[unlinkedBCOPtrs] :: UnlinkedBCO -> !FlatBag BCOPtr
data BCOPtr
BCOPtrName :: !Name -> BCOPtr
BCOPtrPrimOp :: !PrimOp -> BCOPtr
BCOPtrBCO :: !UnlinkedBCO -> BCOPtr

-- | a pointer to a breakpoint's module's BreakArray in GHCi's memory
BCOPtrBreakArray :: ForeignRef BreakArray -> BCOPtr
data BCONPtr
BCONPtrWord :: {-# UNPACK #-} !Word -> BCONPtr
BCONPtrLbl :: !FastString -> BCONPtr
BCONPtrItbl :: !Name -> BCONPtr

-- | A reference to a top-level string literal; see Note [Generating code
--   for top-level string literal bindings] in GHC.StgToByteCode.
BCONPtrAddr :: !Name -> BCONPtr

-- | Only used internally in the assembler in an intermediate
--   representation; should never appear in a fully-assembled UnlinkedBCO.
--   Also see Note [Allocating string literals] in GHC.ByteCode.Asm.
BCONPtrStr :: !ByteString -> BCONPtr
type ItblEnv = NameEnv (Name, ItblPtr)
newtype ItblPtr
ItblPtr :: RemotePtr StgInfoTable -> ItblPtr
type AddrEnv = NameEnv (Name, AddrPtr)
newtype AddrPtr
AddrPtr :: RemotePtr () -> AddrPtr

-- | Information about a breakpoint that we know at code-generation time In
--   order to be used, this needs to be hydrated relative to the current
--   HscEnv by <tt>hydrateCgBreakInfo</tt>. Everything here can be fully
--   forced and that's critical for preventing space leaks (see #22530)
data CgBreakInfo
CgBreakInfo :: ![IfaceTvBndr] -> ![Maybe (IfaceIdBndr, Word)] -> !IfaceType -> CgBreakInfo

-- | Type variables in scope at the breakpoint
[cgb_tyvars] :: CgBreakInfo -> ![IfaceTvBndr]
[cgb_vars] :: CgBreakInfo -> ![Maybe (IfaceIdBndr, Word)]
[cgb_resty] :: CgBreakInfo -> !IfaceType

-- | All the information about the breakpoints for a module
data ModBreaks
ModBreaks :: ForeignRef BreakArray -> !Array BreakIndex SrcSpan -> !Array BreakIndex [OccName] -> !Array BreakIndex [String] -> !Array BreakIndex (RemotePtr CostCentre) -> IntMap CgBreakInfo -> RemotePtr ModuleName -> ModBreaks

-- | The array of flags, one per breakpoint, indicating which breakpoints
--   are enabled.
[modBreaks_flags] :: ModBreaks -> ForeignRef BreakArray

-- | An array giving the source span of each breakpoint.
[modBreaks_locs] :: ModBreaks -> !Array BreakIndex SrcSpan

-- | An array giving the names of the free variables at each breakpoint.
[modBreaks_vars] :: ModBreaks -> !Array BreakIndex [OccName]

-- | An array giving the names of the declarations enclosing each
--   breakpoint. See Note [Field modBreaks_decls]
[modBreaks_decls] :: ModBreaks -> !Array BreakIndex [String]

-- | Array pointing to cost centre for each breakpoint
[modBreaks_ccs] :: ModBreaks -> !Array BreakIndex (RemotePtr CostCentre)

-- | info about each breakpoint from the bytecode generator
[modBreaks_breakInfo] :: ModBreaks -> IntMap CgBreakInfo
[modBreaks_module] :: ModBreaks -> RemotePtr ModuleName

-- | Breakpoint index
type BreakIndex = Int

-- | Construct an empty ModBreaks
emptyModBreaks :: ModBreaks

-- | C CostCentre type
data CCostCentre

-- | Store elements in a flattened representation.
--   
--   A <a>FlatBag</a> is a data structure that stores an ordered list of
--   elements in a flat structure, avoiding the overhead of a linked list.
--   Use this data structure, if the code requires the following
--   properties:
--   
--   <ul>
--   <li>Elements are stored in a long-lived object, and benefit from a
--   flattened representation.</li>
--   <li>The <a>FlatBag</a> will be traversed but not extended or
--   filtered.</li>
--   <li>The number of elements should be known.</li>
--   <li>Sharing of the empty case improves memory behaviour.</li>
--   </ul>
--   
--   A <tt>FlagBag</tt> aims to have as little overhead as possible to
--   store its elements. To achieve that, it distinguishes between the
--   empty case, singleton, tuple and general case. Thus, we only pay for
--   the additional three words of an <tt>Array</tt> if we have at least
--   three elements.
data FlatBag a

-- | Calculate the size of
sizeFlatBag :: FlatBag a -> Word

-- | Convert a <a>SizedSeq</a> into its flattened representation. A
--   'FlatBag a' is more memory efficient than '[a]', if no further
--   modification is necessary.
fromSizedSeq :: SizedSeq a -> FlatBag a

-- | Get all elements that are stored in the <a>FlatBag</a>.
elemsFlatBag :: FlatBag a -> [a]
instance GHC.Internal.Bits.Bits GHC.ByteCode.Types.RegBitmap
instance GHC.Internal.Enum.Enum GHC.ByteCode.Types.ByteOff
instance GHC.Internal.Enum.Enum GHC.ByteCode.Types.HalfWord
instance GHC.Internal.Enum.Enum GHC.ByteCode.Types.RegBitmap
instance GHC.Internal.Enum.Enum GHC.ByteCode.Types.WordOff
instance GHC.Classes.Eq GHC.ByteCode.Types.ByteOff
instance GHC.Classes.Eq GHC.ByteCode.Types.HalfWord
instance GHC.Classes.Eq GHC.ByteCode.Types.NativeCallType
instance GHC.Classes.Eq GHC.ByteCode.Types.RegBitmap
instance GHC.Classes.Eq GHC.ByteCode.Types.WordOff
instance GHC.Internal.Bits.FiniteBits GHC.ByteCode.Types.RegBitmap
instance GHC.Internal.Real.Integral GHC.ByteCode.Types.ByteOff
instance GHC.Internal.Real.Integral GHC.ByteCode.Types.HalfWord
instance GHC.Internal.Real.Integral GHC.ByteCode.Types.RegBitmap
instance GHC.Internal.Real.Integral GHC.ByteCode.Types.WordOff
instance Control.DeepSeq.NFData GHC.ByteCode.Types.AddrPtr
instance Control.DeepSeq.NFData GHC.ByteCode.Types.BCONPtr
instance Control.DeepSeq.NFData GHC.ByteCode.Types.BCOPtr
instance Control.DeepSeq.NFData GHC.ByteCode.Types.FFIInfo
instance Control.DeepSeq.NFData GHC.ByteCode.Types.ItblPtr
instance Control.DeepSeq.NFData GHC.ByteCode.Types.UnlinkedBCO
instance GHC.Internal.Num.Num GHC.ByteCode.Types.ByteOff
instance GHC.Internal.Num.Num GHC.ByteCode.Types.HalfWord
instance GHC.Internal.Num.Num GHC.ByteCode.Types.RegBitmap
instance GHC.Internal.Num.Num GHC.ByteCode.Types.WordOff
instance GHC.Classes.Ord GHC.ByteCode.Types.ByteOff
instance GHC.Classes.Ord GHC.ByteCode.Types.HalfWord
instance GHC.Classes.Ord GHC.ByteCode.Types.RegBitmap
instance GHC.Classes.Ord GHC.ByteCode.Types.WordOff
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.ByteOff
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.CgBreakInfo
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.CompiledByteCode
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.HalfWord
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.NativeCallInfo
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.RegBitmap
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.UnlinkedBCO
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.WordOff
instance GHC.Internal.Real.Real GHC.ByteCode.Types.ByteOff
instance GHC.Internal.Real.Real GHC.ByteCode.Types.HalfWord
instance GHC.Internal.Real.Real GHC.ByteCode.Types.RegBitmap
instance GHC.Internal.Real.Real GHC.ByteCode.Types.WordOff
instance GHC.Internal.Show.Show GHC.ByteCode.Types.ByteOff
instance GHC.Internal.Show.Show GHC.ByteCode.Types.FFIInfo
instance GHC.Internal.Show.Show GHC.ByteCode.Types.HalfWord
instance GHC.Internal.Show.Show GHC.ByteCode.Types.ItblPtr
instance GHC.Internal.Show.Show GHC.ByteCode.Types.RegBitmap
instance GHC.Internal.Show.Show GHC.ByteCode.Types.WordOff

module GHC.Linker.Types
newtype Loader
Loader :: MVar (Maybe LoaderState) -> Loader
[loader_state] :: Loader -> MVar (Maybe LoaderState)
data LoaderState
LoaderState :: !LinkerEnv -> !LinkableSet -> !LinkableSet -> !PkgsLoaded -> ![(FilePath, String)] -> LoaderState

-- | Current global mapping from Names to their true values
[linker_env] :: LoaderState -> !LinkerEnv

-- | The currently loaded interpreted modules (home package)
[bcos_loaded] :: LoaderState -> !LinkableSet

-- | And the currently-loaded compiled modules (home package)
[objs_loaded] :: LoaderState -> !LinkableSet

-- | The currently-loaded packages; always object code haskell libraries,
--   system libraries, transitive dependencies
[pkgs_loaded] :: LoaderState -> !PkgsLoaded

-- | We need to remember the name of previous temporary DLL/.so libraries
--   so we can link them (see #10322)
[temp_sos] :: LoaderState -> ![(FilePath, String)]
uninitializedLoader :: IO Loader
modifyClosureEnv :: LoaderState -> (ClosureEnv -> ClosureEnv) -> LoaderState
data LinkerEnv
LinkerEnv :: !ClosureEnv -> !ItblEnv -> !AddrEnv -> LinkerEnv

-- | Current global mapping from closure Names to their true values
[closure_env] :: LinkerEnv -> !ClosureEnv

-- | The current global mapping from RdrNames of DataCons to info table
--   addresses. When a new LinkablePart is linked into the running image,
--   or an existing module in the image is replaced, the itbl_env must be
--   updated appropriately.
[itbl_env] :: LinkerEnv -> !ItblEnv

-- | Like <a>closure_env</a> and <a>itbl_env</a>, but for top-level 'Addr#'
--   literals, see Note [Generating code for top-level string literal
--   bindings] in GHC.StgToByteCode.
[addr_env] :: LinkerEnv -> !AddrEnv
filterLinkerEnv :: (Name -> Bool) -> LinkerEnv -> LinkerEnv
type ClosureEnv = NameEnv (Name, ForeignHValue)
emptyClosureEnv :: ClosureEnv
extendClosureEnv :: ClosureEnv -> [(Name, ForeignHValue)] -> ClosureEnv
type LinkableSet = ModuleEnv Linkable
mkLinkableSet :: [Linkable] -> LinkableSet

-- | Union of LinkableSets.
--   
--   In case of conflict, keep the most recent Linkable (as per
--   linkableTime)
unionLinkableSet :: LinkableSet -> LinkableSet -> LinkableSet
type ObjFile = FilePath

-- | An entry to be inserted into a module's static pointer table. See Note
--   [Grand plan for static forms] in <a>GHC.Iface.Tidy.StaticPtrTable</a>.
data SptEntry
SptEntry :: Id -> Fingerprint -> SptEntry
data LibrarySpec
Objects :: [FilePath] -> LibrarySpec
Archive :: FilePath -> LibrarySpec
DLL :: String -> LibrarySpec
DLLPath :: FilePath -> LibrarySpec
Framework :: String -> LibrarySpec
data LoadedPkgInfo
LoadedPkgInfo :: !UnitId -> ![LibrarySpec] -> ![LibrarySpec] -> ![RemotePtr LoadedDLL] -> UniqDSet UnitId -> LoadedPkgInfo
[loaded_pkg_uid] :: LoadedPkgInfo -> !UnitId
[loaded_pkg_hs_objs] :: LoadedPkgInfo -> ![LibrarySpec]
[loaded_pkg_non_hs_objs] :: LoadedPkgInfo -> ![LibrarySpec]

-- | See Note [Looking up symbols in the relevant objects]
[loaded_pkg_hs_dlls] :: LoadedPkgInfo -> ![RemotePtr LoadedDLL]
[loaded_pkg_trans_deps] :: LoadedPkgInfo -> UniqDSet UnitId
type PkgsLoaded = UniqDFM UnitId LoadedPkgInfo

-- | Information we can use to dynamically link modules into the compiler
data Linkable
Linkable :: !UTCTime -> !Module -> NonEmpty LinkablePart -> Linkable

-- | Time at which this linkable was built (i.e. when the bytecodes were
--   produced, or the mod date on the files)
[linkableTime] :: Linkable -> !UTCTime

-- | The linkable module itself
[linkableModule] :: Linkable -> !Module

-- | Files and chunks of code to link.
[linkableParts] :: Linkable -> NonEmpty LinkablePart

-- | Objects which have yet to be linked by the compiler
data LinkablePart
DotO :: ObjFile -> LinkableObjectSort -> LinkablePart

-- | Static archive file (.a)
DotA :: FilePath -> LinkablePart

-- | Dynamically linked library file (.so, .dll, .dylib)
DotDLL :: FilePath -> LinkablePart

-- | Serialised core which we can turn into BCOs (or object files), or used
--   by some other backend See Note [Interface Files with Core Definitions]
CoreBindings :: WholeCoreBindings -> LinkablePart
LazyBCOs :: CompiledByteCode -> [FilePath] -> LinkablePart

-- | A byte-code object, lives only in memory.
BCOs :: CompiledByteCode -> LinkablePart

-- | Classify the provenance of <tt>.o</tt> products.
data LinkableObjectSort

-- | The object is the final product for a module. When linking splices,
--   its file extension will be adapted to the interpreter's way if needed.
ModuleObject :: LinkableObjectSort

-- | The object was created from generated code for foreign stubs or
--   foreign sources added by the user. Its file extension must be
--   preserved, since there are no objects for alternative ways available.
ForeignObject :: LinkableObjectSort

-- | Return true if the linkable only consists of native code (no BCO)
linkableIsNativeCodeOnly :: Linkable -> Bool

-- | List the native objects (.o) of a linkable
linkableObjs :: Linkable -> [FilePath]

-- | List the native libraries (.so/.dll) of a linkable
linkableLibs :: Linkable -> [LinkablePart]

-- | List the paths of the native objects and libraries (.o<i>.so</i>.dll)
linkableFiles :: Linkable -> [FilePath]

-- | List the BCOs parts of a linkable.
--   
--   This excludes the LazyBCOs and the CoreBindings parts
linkableBCOs :: Linkable -> [CompiledByteCode]

-- | List the native linkable parts (.o<i>.so</i>.dll) of a linkable
linkableNativeParts :: Linkable -> [LinkablePart]

-- | Split linkable parts into (native code parts, BCOs parts)
linkablePartitionParts :: Linkable -> ([LinkablePart], [LinkablePart])

-- | Get the FilePath of linkable part (if applicable)
linkablePartPath :: LinkablePart -> Maybe FilePath

-- | Retrieve the compiled byte-code from the linkable part.
--   
--   Contrary to linkableBCOs, this includes byte-code from LazyBCOs.
linkablePartAllBCOs :: LinkablePart -> [CompiledByteCode]

-- | Is the part a native object or library? (.o<i>.so</i>.dll)
isNativeCode :: LinkablePart -> Bool

-- | Is the part a native library? (.so/.dll)
isNativeLib :: LinkablePart -> Bool

-- | Transform the <a>LinkablePart</a> list in this <a>Linkable</a> to
--   contain only byte code without <a>LazyBCOs</a>. If no
--   <a>LinkablePart</a> remains, return <a>Nothing</a>.
linkableFilterByteCode :: Linkable -> Maybe Linkable

-- | Transform the <a>LinkablePart</a> list in this <a>Linkable</a> to
--   contain only object code files (.o, .a, .so) without <a>LazyBCOs</a>.
--   If no <a>LinkablePart</a> remains, return <a>Nothing</a>.
linkableFilterNative :: Linkable -> Maybe Linkable

-- | Split the <a>LinkablePart</a> lists in each <a>Linkable</a> into only
--   object code files (.o, .a, .so) and only byte code, without
--   <a>LazyBCOs</a>, and return two lists containing the nonempty
--   <a>Linkable</a>s for each.
partitionLinkables :: [Linkable] -> ([Linkable], [Linkable])
instance GHC.Utils.Outputable.Outputable GHC.Linker.Types.LibrarySpec
instance GHC.Utils.Outputable.Outputable GHC.Linker.Types.Linkable
instance GHC.Utils.Outputable.Outputable GHC.Linker.Types.LinkablePart
instance GHC.Utils.Outputable.Outputable GHC.Linker.Types.LoadedPkgInfo

module GHC.Unit.Module.ModGuts

-- | A ModGuts is carried through the compiler, accumulating stuff as it
--   goes There is only one ModGuts at any time, the one for the module
--   being compiled right now. Once it is compiled, a <tt>ModIface</tt> and
--   <tt>ModDetails</tt> are extracted and the ModGuts is discarded.
data ModGuts
ModGuts :: !Module -> HscSource -> SrcSpan -> ![AvailInfo] -> !Dependencies -> ![Usage] -> !Bool -> !GlobalRdrEnv -> !FixityEnv -> ![TyCon] -> !DefaultEnv -> ![ClsInst] -> ![FamInst] -> ![PatSyn] -> ![CoreRule] -> !CoreProgram -> !ForeignStubs -> ![(ForeignSrcLang, FilePath)] -> !Warnings GhcRn -> [Annotation] -> CompleteMatches -> !HpcInfo -> !Maybe ModBreaks -> InstEnv -> FamInstEnv -> !NameSet -> SafeHaskellMode -> Bool -> !Maybe Docs -> ModGuts

-- | Module being compiled
[mg_module] :: ModGuts -> !Module

-- | Whether it's an hs-boot module
[mg_hsc_src] :: ModGuts -> HscSource

-- | For error messages from inner passes
[mg_loc] :: ModGuts -> SrcSpan

-- | What it exports
[mg_exports] :: ModGuts -> ![AvailInfo]

-- | What it depends on, directly or otherwise
[mg_deps] :: ModGuts -> !Dependencies

-- | What was used? Used for interfaces.
[mg_usages] :: ModGuts -> ![Usage]

-- | Did we run a TH splice?
[mg_used_th] :: ModGuts -> !Bool

-- | Top-level lexical environment
[mg_rdr_env] :: ModGuts -> !GlobalRdrEnv

-- | Fixities declared in this module. Used for creating interface files.
[mg_fix_env] :: ModGuts -> !FixityEnv

-- | TyCons declared in this module (includes TyCons for classes)
[mg_tcs] :: ModGuts -> ![TyCon]

-- | Class defaults exported from this module
[mg_defaults] :: ModGuts -> !DefaultEnv

-- | Class instances declared in this module
[mg_insts] :: ModGuts -> ![ClsInst]

-- | Family instances declared in this module
[mg_fam_insts] :: ModGuts -> ![FamInst]

-- | Pattern synonyms declared in this module
[mg_patsyns] :: ModGuts -> ![PatSyn]

-- | Before the core pipeline starts, contains See Note [Overall plumbing
--   for rules] in <a>GHC.Core.Rules</a>
[mg_rules] :: ModGuts -> ![CoreRule]

-- | Bindings for this module
[mg_binds] :: ModGuts -> !CoreProgram

-- | Foreign exports declared in this module
[mg_foreign] :: ModGuts -> !ForeignStubs

-- | Files to be compiled with the C compiler
[mg_foreign_files] :: ModGuts -> ![(ForeignSrcLang, FilePath)]

-- | Warnings declared in the module
[mg_warns] :: ModGuts -> !Warnings GhcRn

-- | Annotations declared in this module
[mg_anns] :: ModGuts -> [Annotation]

-- | Complete Matches
[mg_complete_matches] :: ModGuts -> CompleteMatches

-- | Coverage tick boxes in the module
[mg_hpc_info] :: ModGuts -> !HpcInfo

-- | Breakpoints for the module
[mg_modBreaks] :: ModGuts -> !Maybe ModBreaks

-- | Class instance environment for <i>home-package</i> modules (including
--   this one); c.f. <tt>tcg_inst_env</tt>
[mg_inst_env] :: ModGuts -> InstEnv

-- | Type-family instance environment for <i>home-package</i> modules
--   (including this one); c.f. <tt>tcg_fam_inst_env</tt>
[mg_fam_inst_env] :: ModGuts -> FamInstEnv
[mg_boot_exports] :: ModGuts -> !NameSet

-- | Safe Haskell mode
[mg_safe_haskell] :: ModGuts -> SafeHaskellMode

-- | Do we need to trust our own package for Safe Haskell? See Note [Trust
--   Own Package] in <a>GHC.Rename.Names</a>
[mg_trust_pkg] :: ModGuts -> Bool

-- | Documentation.
[mg_docs] :: ModGuts -> !Maybe Docs
mg_mnwib :: ModGuts -> ModuleNameWithIsBoot

-- | A restricted form of <a>ModGuts</a> for code generation purposes
data CgGuts
CgGuts :: !Module -> [TyCon] -> CoreProgram -> [CostCentre] -> !ForeignStubs -> ![(ForeignSrcLang, FilePath)] -> !Set UnitId -> !Maybe ModBreaks -> [SptEntry] -> CgGuts

-- | Module being compiled
[cg_module] :: CgGuts -> !Module

-- | Algebraic data types (including ones that started life as classes);
--   generate constructors and info tables. Includes newtypes, just for the
--   benefit of External Core
[cg_tycons] :: CgGuts -> [TyCon]

-- | The tidied main bindings, including previously-implicit bindings for
--   record and class selectors, and data constructor wrappers. But *not*
--   data constructor workers; reason: we regard them as part of the
--   code-gen of tycons
[cg_binds] :: CgGuts -> CoreProgram
[cg_ccs] :: CgGuts -> [CostCentre]

-- | Foreign export stubs
[cg_foreign] :: CgGuts -> !ForeignStubs
[cg_foreign_files] :: CgGuts -> ![(ForeignSrcLang, FilePath)]

-- | Dependent packages, used to generate #includes for C code gen
[cg_dep_pkgs] :: CgGuts -> !Set UnitId

-- | Module breakpoints
[cg_modBreaks] :: CgGuts -> !Maybe ModBreaks

-- | Static pointer table entries for static forms defined in the module.
--   See Note [Grand plan for static forms] in
--   <a>GHC.Iface.Tidy.StaticPtrTable</a>
[cg_spt_entries] :: CgGuts -> [SptEntry]


-- | Functions for collecting together and applying rewrite rules to a
--   module. The <a>CoreRule</a> datatype itself is declared elsewhere.
module GHC.Core.Rules

-- | The main rule matching function. Attempts to apply all (active)
--   supplied rules to this instance of an application in a given context,
--   returning the rule applied and the resulting expression if successful.
lookupRule :: RuleOpts -> InScopeEnv -> (Activation -> Bool) -> Id -> [CoreExpr] -> [CoreRule] -> Maybe (CoreRule, CoreExpr)
matchExprs :: InScopeEnv -> [Var] -> [CoreExpr] -> [CoreExpr] -> Maybe (BindWrapper, [CoreExpr])

-- | Gathers a collection of <a>CoreRule</a>s. Maps (the name of) an
--   <a>Id</a> to its rules
type RuleBase = NameEnv [CoreRule]

-- | A full rule environment which we can apply rules from. Like a
--   <a>RuleBase</a>, but it also includes the set of visible orphans we
--   use to filter out orphan rules which are not visible (even though we
--   can see them...) See Note [Orphans] in GHC.Core
data RuleEnv
RuleEnv :: !RuleBase -> !RuleBase -> !RuleBase -> !ModuleSet -> RuleEnv
[re_local_rules] :: RuleEnv -> !RuleBase
[re_home_rules] :: RuleEnv -> !RuleBase
[re_eps_rules] :: RuleEnv -> !RuleBase
[re_visible_orphs] :: RuleEnv -> !ModuleSet
mkRuleEnv :: ModGuts -> RuleBase -> RuleBase -> RuleEnv
emptyRuleEnv :: RuleEnv
updExternalPackageRules :: RuleEnv -> RuleBase -> RuleEnv
addLocalRules :: RuleEnv -> [CoreRule] -> RuleEnv
updLocalRules :: RuleEnv -> [CoreRule] -> RuleEnv
emptyRuleBase :: RuleBase
mkRuleBase :: [CoreRule] -> RuleBase
extendRuleBaseList :: RuleBase -> [CoreRule] -> RuleBase
pprRuleBase :: RuleBase -> SDoc

-- | Report partial matches for rules beginning with the specified string
--   for the purposes of error reporting
ruleCheckProgram :: RuleOpts -> CompilerPhase -> String -> (Id -> [CoreRule]) -> CoreProgram -> SDoc
extendRuleInfo :: RuleInfo -> [CoreRule] -> RuleInfo
addRuleInfo :: RuleInfo -> RuleInfo -> RuleInfo
addIdSpecialisations :: Id -> [CoreRule] -> Id
addRulesToId :: RuleBase -> Id -> Id

-- | Gather all the rules for locally bound identifiers from the supplied
--   bindings
rulesOfBinds :: [CoreBind] -> [CoreRule]
getRules :: RuleEnv -> Id -> [CoreRule]
pprRulesForUser :: [CoreRule] -> SDoc

-- | Used to make <a>CoreRule</a> for an <a>Id</a> defined in the module
--   being compiled. See also <a>CoreRule</a>
mkRule :: Module -> Bool -> Bool -> RuleName -> Activation -> Name -> [CoreBndr] -> [CoreExpr] -> CoreExpr -> CoreRule
mkSpecRule :: DynFlags -> Module -> Bool -> Activation -> SDoc -> Id -> [CoreBndr] -> [CoreExpr] -> CoreExpr -> CoreRule

-- | Find the "top" free names of several expressions. Such names are
--   either:
--   
--   <ol>
--   <li>The function finally being applied to in an application chain (if
--   that name is a GlobalId: see <a>GHC.Types.Var#globalvslocal</a>),
--   or</li>
--   <li>The <tt>TyCon</tt> if the expression is a <a>Type</a></li>
--   </ol>
--   
--   This is used for the fast-match-check for rules; if the top names
--   don't match, the rest can't
roughTopNames :: [CoreExpr] -> [Maybe Name]

module GHC.Core.Opt.Simplify.Monad
data TopEnvConfig
TopEnvConfig :: !Int -> !Int -> TopEnvConfig
[te_history_size] :: TopEnvConfig -> !Int
[te_tick_factor] :: TopEnvConfig -> !Int
data SimplM result
initSmpl :: Logger -> IO RuleEnv -> TopEnvConfig -> Int -> SimplM a -> IO (a, SimplCount)
traceSmpl :: String -> SDoc -> SimplM ()
getSimplRules :: SimplM RuleEnv

-- | A monad for generating unique identifiers
class Monad m => MonadUnique (m :: Type -> Type)

-- | Get a new UniqueSupply
getUniqueSupplyM :: MonadUnique m => m UniqSupply

-- | Get a new unique identifier
getUniqueM :: MonadUnique m => m Unique

-- | Get an infinite list of new unique identifiers
getUniquesM :: MonadUnique m => m [Unique]
newId :: FastString -> Mult -> Type -> SimplM Id

-- | Make a join id with given type and arity but without call-by-value
--   annotations.
newJoinId :: [Var] -> Type -> SimplM Id
data SimplCount
tick :: Tick -> SimplM ()
freeTick :: Tick -> SimplM ()
checkedTick :: Tick -> SimplM ()
getSimplCount :: SimplM SimplCount
zeroSimplCount :: Bool -> SimplCount
pprSimplCount :: SimplCount -> SDoc
plusSimplCount :: SimplCount -> SimplCount -> SimplCount
isZeroSimplCount :: SimplCount -> Bool
instance GHC.Internal.Base.Applicative GHC.Core.Opt.Simplify.Monad.SimplM
instance GHC.Internal.Base.Functor GHC.Core.Opt.Simplify.Monad.SimplM
instance GHC.Utils.Logger.HasLogger GHC.Core.Opt.Simplify.Monad.SimplM
instance GHC.Internal.Control.Monad.IO.Class.MonadIO GHC.Core.Opt.Simplify.Monad.SimplM
instance GHC.Internal.Base.Monad GHC.Core.Opt.Simplify.Monad.SimplM
instance GHC.Types.Unique.Supply.MonadUnique GHC.Core.Opt.Simplify.Monad.SimplM

module GHC.Core.Opt.Simplify.Env
data SimplMode
SimplMode :: !CompilerPhase -> ![String] -> !Bool -> !Bool -> !Bool -> !Bool -> !UnfoldingOpts -> !Bool -> !Bool -> !FloatEnable -> !Bool -> !ArityOpts -> !RuleOpts -> !Bool -> !Bool -> !OptCoercionOpts -> SimplMode
[sm_phase] :: SimplMode -> !CompilerPhase

-- | Name(s) of the phase
[sm_names] :: SimplMode -> ![String]

-- | Whether RULES are enabled
[sm_rules] :: SimplMode -> !Bool

-- | Whether inlining is enabled
[sm_inline] :: SimplMode -> !Bool

-- | Whether eta-expansion is enabled
[sm_eta_expand] :: SimplMode -> !Bool

-- | Do we swizzle casts past lambdas?
[sm_cast_swizzle] :: SimplMode -> !Bool

-- | Unfolding options
[sm_uf_opts] :: SimplMode -> !UnfoldingOpts

-- | Whether case-of-case is enabled
[sm_case_case] :: SimplMode -> !Bool

-- | Whether pre-inlining is enabled
[sm_pre_inline] :: SimplMode -> !Bool

-- | Whether to enable floating out
[sm_float_enable] :: SimplMode -> !FloatEnable
[sm_do_eta_reduction] :: SimplMode -> !Bool
[sm_arity_opts] :: SimplMode -> !ArityOpts
[sm_rule_opts] :: SimplMode -> !RuleOpts
[sm_case_folding] :: SimplMode -> !Bool
[sm_case_merge] :: SimplMode -> !Bool

-- | Coercion optimiser options
[sm_co_opt_opts] :: SimplMode -> !OptCoercionOpts
updMode :: (SimplMode -> SimplMode) -> SimplEnv -> SimplEnv
smPedanticBottoms :: SimplMode -> Bool
smPlatform :: SimplMode -> Platform
data SimplEnv
SimplEnv :: !SimplMode -> !(FamInstEnv, FamInstEnv) -> TvSubstEnv -> CvSubstEnv -> SimplIdSubst -> !UnVarSet -> !InScopeSet -> !Int -> !Int -> SimplEnv
[seMode] :: SimplEnv -> !SimplMode
[seFamEnvs] :: SimplEnv -> !(FamInstEnv, FamInstEnv)
[seTvSubst] :: SimplEnv -> TvSubstEnv
[seCvSubst] :: SimplEnv -> CvSubstEnv
[seIdSubst] :: SimplEnv -> SimplIdSubst

-- | Fast OutVarSet tracking which recursive RHSs we are analysing. See
--   Note [Eta reduction in recursive RHSs] in GHC.Core.Opt.Arity.
[seRecIds] :: SimplEnv -> !UnVarSet
[seInScope] :: SimplEnv -> !InScopeSet
[seCaseDepth] :: SimplEnv -> !Int
[seInlineDepth] :: SimplEnv -> !Int
pprSimplEnv :: SimplEnv -> SDoc
seArityOpts :: SimplEnv -> ArityOpts
seCaseCase :: SimplEnv -> Bool
seCaseFolding :: SimplEnv -> Bool
seCaseMerge :: SimplEnv -> Bool
seCastSwizzle :: SimplEnv -> Bool
seDoEtaReduction :: SimplEnv -> Bool
seEtaExpand :: SimplEnv -> Bool
seFloatEnable :: SimplEnv -> FloatEnable
seInline :: SimplEnv -> Bool
seNames :: SimplEnv -> [String]
seOptCoercionOpts :: SimplEnv -> OptCoercionOpts
sePedanticBottoms :: SimplEnv -> Bool
sePhase :: SimplEnv -> CompilerPhase
sePlatform :: SimplEnv -> Platform
sePreInline :: SimplEnv -> Bool
seRuleOpts :: SimplEnv -> RuleOpts
seRules :: SimplEnv -> Bool
seUnfoldingOpts :: SimplEnv -> UnfoldingOpts
mkSimplEnv :: SimplMode -> (FamInstEnv, FamInstEnv) -> SimplEnv
extendIdSubst :: SimplEnv -> Id -> SimplSR -> SimplEnv
extendCvIdSubst :: SimplEnv -> Id -> OutExpr -> SimplEnv
extendTvSubst :: SimplEnv -> TyVar -> Type -> SimplEnv
extendCvSubst :: SimplEnv -> CoVar -> Coercion -> SimplEnv
zapSubstEnv :: SimplEnv -> SimplEnv
setSubstEnv :: SimplEnv -> TvSubstEnv -> CvSubstEnv -> SimplIdSubst -> SimplEnv
bumpCaseDepth :: SimplEnv -> SimplEnv
getInScope :: SimplEnv -> InScopeSet
setInScopeFromE :: SimplEnv -> SimplEnv -> SimplEnv
setInScopeFromF :: SimplEnv -> SimplFloats -> SimplEnv
setInScopeSet :: SimplEnv -> InScopeSet -> SimplEnv
modifyInScope :: SimplEnv -> CoreBndr -> SimplEnv
addNewInScopeIds :: SimplEnv -> [CoreBndr] -> SimplEnv
getSimplRules :: SimplM RuleEnv
enterRecGroupRHSs :: SimplEnv -> [OutBndr] -> (SimplEnv -> SimplM (r, SimplEnv)) -> SimplM (r, SimplEnv)
reSimplifying :: SimplEnv -> Bool

-- | A substitution result.
data SimplSR
DoneEx :: OutExpr -> JoinPointHood -> SimplSR
DoneId :: OutId -> SimplSR
ContEx :: TvSubstEnv -> CvSubstEnv -> SimplIdSubst -> InExpr -> SimplSR
mkContEx :: SimplEnv -> InExpr -> SimplSR
substId :: SimplEnv -> InId -> SimplSR
lookupRecBndr :: SimplEnv -> InId -> OutId
simplNonRecBndr :: SimplEnv -> InBndr -> SimplM (SimplEnv, OutBndr)
simplNonRecJoinBndr :: SimplEnv -> InBndr -> Mult -> OutType -> SimplM (SimplEnv, OutBndr)
simplRecBndrs :: SimplEnv -> [InBndr] -> SimplM SimplEnv
simplRecJoinBndrs :: SimplEnv -> [InBndr] -> Mult -> OutType -> SimplM SimplEnv
simplBinder :: SimplEnv -> InBndr -> SimplM (SimplEnv, OutBndr)
simplBinders :: SimplEnv -> [InBndr] -> SimplM (SimplEnv, [OutBndr])
substTy :: HasDebugCallStack => SimplEnv -> Type -> Type
substTyVar :: SimplEnv -> TyVar -> Type
getSubst :: SimplEnv -> Subst
substCo :: SimplEnv -> Coercion -> Coercion
substCoVar :: SimplEnv -> CoVar -> Coercion
data SimplFloats
SimplFloats :: LetFloats -> JoinFloats -> InScopeSet -> SimplFloats
[sfLetFloats] :: SimplFloats -> LetFloats
[sfJoinFloats] :: SimplFloats -> JoinFloats
[sfInScope] :: SimplFloats -> InScopeSet
emptyFloats :: SimplEnv -> SimplFloats
isEmptyFloats :: SimplFloats -> Bool
mkRecFloats :: SimplFloats -> SimplFloats
mkFloatBind :: SimplEnv -> OutBind -> (SimplFloats, SimplEnv)
addLetFloats :: SimplFloats -> LetFloats -> SimplFloats
addJoinFloats :: SimplFloats -> JoinFloats -> SimplFloats
addFloats :: SimplFloats -> SimplFloats -> SimplFloats
extendFloats :: SimplFloats -> OutBind -> SimplFloats
wrapFloats :: SimplFloats -> OutExpr -> OutExpr
isEmptyJoinFloats :: JoinFloats -> Bool
isEmptyLetFloats :: LetFloats -> Bool
doFloatFromRhs :: FloatEnable -> TopLevelFlag -> RecFlag -> Bool -> SimplFloats -> OutExpr -> Bool
getTopFloatBinds :: SimplFloats -> [CoreBind]
data LetFloats
data FloatEnable
FloatDisabled :: FloatEnable
FloatNestedOnly :: FloatEnable
FloatEnabled :: FloatEnable
letFloatBinds :: LetFloats -> [CoreBind]
emptyLetFloats :: LetFloats
unitLetFloat :: OutBind -> LetFloats
addLetFlts :: LetFloats -> LetFloats -> LetFloats
mapLetFloats :: LetFloats -> ((Id, CoreExpr) -> (Id, CoreExpr)) -> LetFloats
type JoinFloat = OutBind
type JoinFloats = OrdList JoinFloat
emptyJoinFloats :: JoinFloats
wrapJoinFloats :: JoinFloats -> OutExpr -> OutExpr
wrapJoinFloatsX :: SimplFloats -> OutExpr -> (SimplFloats, OutExpr)
unitJoinFloat :: OutBind -> JoinFloats
addJoinFlts :: JoinFloats -> JoinFloats -> JoinFloats
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Env.FloatFlag
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Env.LetFloats
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Env.SimplFloats
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Env.SimplMode
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Env.SimplSR

module GHC.Core.Opt.Simplify.Inline
couldBeSmallEnoughToInline :: UnfoldingOpts -> Int -> CoreExpr -> Bool
smallEnoughToInline :: UnfoldingOpts -> Unfolding -> Bool
activeUnfolding :: SimplMode -> Id -> Bool
callSiteInline :: SimplEnv -> Logger -> Id -> Bool -> [ArgSummary] -> CallCtxt -> Maybe CoreExpr
data CallCtxt
BoringCtxt :: CallCtxt
RhsCtxt :: RecFlag -> CallCtxt
DiscArgCtxt :: CallCtxt
RuleArgCtxt :: CallCtxt
ValAppCtxt :: CallCtxt
CaseCtxt :: CallCtxt

module GHC.Core.Opt.LiberateCase

-- | Options for the liberate case pass.
data LibCaseOpts
LibCaseOpts :: !Maybe Int -> !UnfoldingOpts -> LibCaseOpts

-- | Bomb-out size for deciding if potential liberatees are too big.
[lco_threshold] :: LibCaseOpts -> !Maybe Int

-- | Unfolding options
[lco_unfolding_opts] :: LibCaseOpts -> !UnfoldingOpts
liberateCase :: LibCaseOpts -> CoreProgram -> CoreProgram

module GHC.Driver.Config.Core.Opt.LiberateCase

-- | Initialize configuration for the liberate case Core optimization pass.
initLiberateCaseOpts :: DynFlags -> LibCaseOpts


-- | Info about modules in the "home" unit
module GHC.Unit.Home.ModInfo

-- | Information about modules in the package being compiled
data HomeModInfo
HomeModInfo :: !ModIface -> ModDetails -> !HomeModLinkable -> HomeModInfo

-- | The basic loaded interface file: every loaded module has one of these,
--   even if it is imported from another package
[hm_iface] :: HomeModInfo -> !ModIface

-- | Extra information that has been created from the <a>ModIface</a> for
--   the module, typically during typechecking
[hm_details] :: HomeModInfo -> ModDetails

-- | The actual artifact we would like to link to access things in this
--   module. See Note [Home module build products]
--   
--   <a>hm_linkable</a> might be empty:
--   
--   <ol>
--   <li>If this is an .hs-boot module</li>
--   <li>Temporarily during compilation if we pruned away the old linkable
--   because it was out of date.</li>
--   </ol>
--   
--   When re-linking a module (<a>HscNoRecomp</a>), we construct the
--   <a>HomeModInfo</a> by building a new <a>ModDetails</a> from the old
--   <a>ModIface</a> (only).
[hm_linkable] :: HomeModInfo -> !HomeModLinkable
data HomeModLinkable
HomeModLinkable :: !Maybe Linkable -> !Maybe Linkable -> HomeModLinkable
[homeMod_bytecode] :: HomeModLinkable -> !Maybe Linkable
[homeMod_object] :: HomeModLinkable -> !Maybe Linkable
homeModInfoObject :: HomeModInfo -> Maybe Linkable
homeModInfoByteCode :: HomeModInfo -> Maybe Linkable
emptyHomeModInfoLinkable :: HomeModLinkable
justBytecode :: Linkable -> HomeModLinkable
justObjects :: Linkable -> HomeModLinkable
bytecodeAndObjects :: Linkable -> Linkable -> HomeModLinkable

-- | Helps us find information about modules in the home package
type HomePackageTable = DModuleNameEnv HomeModInfo

-- | Constructs an empty HomePackageTable
emptyHomePackageTable :: HomePackageTable
lookupHpt :: HomePackageTable -> ModuleName -> Maybe HomeModInfo
eltsHpt :: HomePackageTable -> [HomeModInfo]

-- | Like <tt>concatMap f . <a>eltsHpt</a></tt>, but filters out all
--   <a>HomeModInfo</a> for which <tt>f</tt> returns the empty list before
--   doing the sort inherent to <a>eltsUDFM</a>.
concatHpt :: (HomeModInfo -> [a]) -> HomePackageTable -> [a]
filterHpt :: (HomeModInfo -> Bool) -> HomePackageTable -> HomePackageTable
allHpt :: (HomeModInfo -> Bool) -> HomePackageTable -> Bool
anyHpt :: (HomeModInfo -> Bool) -> HomePackageTable -> Bool
mapHpt :: (HomeModInfo -> HomeModInfo) -> HomePackageTable -> HomePackageTable
delFromHpt :: HomePackageTable -> ModuleName -> HomePackageTable
addToHpt :: HomePackageTable -> ModuleName -> HomeModInfo -> HomePackageTable
addHomeModInfoToHpt :: HomeModInfo -> HomePackageTable -> HomePackageTable
addListToHpt :: HomePackageTable -> [(ModuleName, HomeModInfo)] -> HomePackageTable
lookupHptDirectly :: HomePackageTable -> Unique -> Maybe HomeModInfo
lookupHptByModule :: HomePackageTable -> Module -> Maybe HomeModInfo
listToHpt :: [(ModuleName, HomeModInfo)] -> HomePackageTable
listHMIToHpt :: [HomeModInfo] -> HomePackageTable
pprHPT :: HomePackageTable -> SDoc
instance GHC.Utils.Outputable.Outputable GHC.Unit.Home.ModInfo.HomeModLinkable

module GHC.Unit.Module.Status

-- | Action to perform in backend compilation
data HscBackendAction

-- | Update the boot and signature file results.
HscUpdate :: ModIface -> HscBackendAction

-- | Recompile this module.
HscRecomp :: CgGuts -> !ModLocation -> !PartialModIface -> !Maybe Fingerprint -> HscBackendAction

-- | Information for the code generator.
[hscs_guts] :: HscBackendAction -> CgGuts

-- | Module info
[hscs_mod_location] :: HscBackendAction -> !ModLocation

-- | Partial interface
[hscs_partial_iface] :: HscBackendAction -> !PartialModIface

-- | Old interface hash for this compilation, if an old interface file
--   exists. Pass to <tt>hscMaybeWriteIface</tt> when writing the interface
--   to avoid updating the existing interface when the interface isn't
--   changed.
[hscs_old_iface_hash] :: HscBackendAction -> !Maybe Fingerprint

-- | Status of a module in incremental compilation
data HscRecompStatus

-- | Nothing to do because code already exists.
HscUpToDate :: ModIface -> HomeModLinkable -> HscRecompStatus

-- | Recompilation of module, or update of interface is required.
--   Optionally pass the old interface hash to avoid updating the existing
--   interface when it has not changed.
HscRecompNeeded :: Maybe Fingerprint -> HscRecompStatus
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.Status.HscBackendAction

module GHC.StgToJS.StaticPtr
initStaticPtrs :: [SptEntry] -> G JStgStat


-- | JavaScript code generator
module GHC.StgToJS.CodeGen

-- | Code generator for JavaScript
stgToJS :: Logger -> StgToJSConfig -> [CgStgTopBinding] -> Module -> [SptEntry] -> ForeignStubs -> CollectedCCs -> FilePath -> IO ()

module GHC.StgToJS

-- | Code generator for JavaScript
stgToJS :: Logger -> StgToJSConfig -> [CgStgTopBinding] -> Module -> [SptEntry] -> ForeignStubs -> CollectedCCs -> FilePath -> IO ()


-- | Code generation for the Static Pointer Table
--   
--   (c) 2014 I/O Tweag
--   
--   Each module that uses <tt>static</tt> keyword declares an
--   initialization function of the form hs_spt_init_&lt;module&gt;() which
--   is emitted into the _stub.c file and annotated with
--   <b>attribute</b>((constructor)) so that it gets executed at startup
--   time.
--   
--   The function's purpose is to call hs_spt_insert to insert the static
--   pointers of this module in the hashtable of the RTS, and it looks
--   something like this:
--   
--   <pre>
--   static void hs_hpc_init_Main(void) __attribute__((constructor));
--   static void hs_hpc_init_Main(void) {
--   
--     static StgWord64 k0[2] = {16252233372134256ULL,7370534374096082ULL};
--     extern StgPtr Main_r2wb_closure;
--     hs_spt_insert(k0, &amp;Main_r2wb_closure);
--   
--     static StgWord64 k1[2] = {12545634534567898ULL,5409674567544151ULL};
--     extern StgPtr Main_r2wc_closure;
--     hs_spt_insert(k1, &amp;Main_r2wc_closure);
--   
--   }
--   </pre>
--   
--   where the constants are fingerprints produced from the static forms.
--   
--   The linker must find the definitions matching the <tt>extern StgPtr
--   <a>name</a></tt> declarations. For this to work, the identifiers of
--   static pointers need to be exported. This is done in <a>newLvlVar</a>.
--   
--   There is also a finalization function for the time when the module is
--   unloaded.
--   
--   <pre>
--   static void hs_hpc_fini_Main(void) __attribute__((destructor));
--   static void hs_hpc_fini_Main(void) {
--   
--     static StgWord64 k0[2] = {16252233372134256ULL,7370534374096082ULL};
--     hs_spt_remove(k0);
--   
--     static StgWord64 k1[2] = {12545634534567898ULL,5409674567544151ULL};
--     hs_spt_remove(k1);
--   
--   }
--   </pre>
module GHC.Iface.Tidy.StaticPtrTable

-- | Replaces all bindings of the form
--   
--   <pre>
--   b = /\ ... -&gt; makeStatic location value
--   </pre>
--   
--   with
--   
--   <pre>
--   b = /\ ... -&gt;
--     StaticPtr key (StaticPtrInfo "pkg key" "module" location) value
--   </pre>
--   
--   where a distinct key is generated for each binding.
--   
--   It also yields the C stub that inserts these bindings into the static
--   pointer table.
sptCreateStaticBinds :: StaticPtrOpts -> Module -> CoreProgram -> IO ([SptEntry], Maybe CStub, CoreProgram)

-- | <tt>sptModuleInitCode module fps</tt> is a C stub to insert the static
--   entries of <tt>module</tt> into the static pointer table.
--   
--   <tt>fps</tt> is a list associating each binding corresponding to a
--   static entry with its fingerprint.
sptModuleInitCode :: Platform -> Module -> [SptEntry] -> CStub
data StaticPtrOpts
StaticPtrOpts :: !Platform -> !Bool -> !MkStringIds -> !DataCon -> !DataCon -> StaticPtrOpts

-- | Target platform
[opt_platform] :: StaticPtrOpts -> !Platform

-- | Generate CStub or not
[opt_gen_cstub] :: StaticPtrOpts -> !Bool

-- | Ids for `unpackCString[Utf8]#`
[opt_mk_string] :: StaticPtrOpts -> !MkStringIds

-- | <tt>StaticPtrInfo</tt> datacon
[opt_static_ptr_info_datacon] :: StaticPtrOpts -> !DataCon

-- | <tt>StaticPtr</tt> datacon
[opt_static_ptr_datacon] :: StaticPtrOpts -> !DataCon


-- | Functions for converting Core things to interface file things.
module GHC.CoreToIface
toIfaceTvBndr :: TyVar -> IfaceTvBndr
toIfaceTvBndrs :: [TyVar] -> [IfaceTvBndr]
toIfaceIdBndr :: Id -> IfaceIdBndr
toIfaceBndr :: Var -> IfaceBndr
toIfaceTopBndr :: Id -> IfaceTopBndrInfo
toIfaceForAllBndr :: VarBndr TyCoVar flag -> VarBndr IfaceBndr flag
toIfaceForAllBndrs :: [VarBndr TyCoVar vis] -> [VarBndr IfaceBndr vis]
toIfaceTyVar :: TyVar -> IfLclName
toIfaceType :: Type -> IfaceType
toIfaceTypeX :: VarSet -> Type -> IfaceType
toIfaceKind :: Type -> IfaceType
toIfaceTcArgs :: TyCon -> [Type] -> IfaceAppArgs
toIfaceTyCon :: TyCon -> IfaceTyCon
toIfaceTyCon_name :: Name -> IfaceTyCon
toIfaceTyLit :: TyLit -> IfaceTyLit
tidyToIfaceType :: TidyEnv -> Type -> IfaceType
tidyToIfaceContext :: TidyEnv -> ThetaType -> IfaceContext
tidyToIfaceTcArgs :: TidyEnv -> TyCon -> [Type] -> IfaceAppArgs
toIfaceCoercion :: Coercion -> IfaceCoercion
toIfaceCoercionX :: VarSet -> Coercion -> IfaceCoercion
patSynToIfaceDecl :: PatSyn -> IfaceDecl
toIfaceExpr :: CoreExpr -> IfaceExpr
toIfaceBang :: TidyEnv -> HsImplBang -> IfaceBang
toIfaceSrcBang :: HsSrcBang -> IfaceSrcBang
toIfaceLetBndr :: Id -> IfaceLetBndr
toIfaceIdDetails :: IdDetails -> IfaceIdDetails
toIfaceIdInfo :: IdInfo -> IfaceIdInfo
toIfUnfolding :: Bool -> Unfolding -> Maybe IfaceInfoItem
toIfaceTickish :: CoreTickish -> IfaceTickish
toIfaceBind :: Bind Id -> IfaceBinding IfaceLetBndr
toIfaceTopBind :: Bind Id -> IfaceBindingX IfaceMaybeRhs IfaceTopBndrInfo
toIfaceAlt :: CoreAlt -> IfaceAlt
toIfaceCon :: AltCon -> IfaceConAlt
toIfaceApp :: Expr CoreBndr -> [Arg CoreBndr] -> IfaceExpr
toIfaceVar :: Id -> IfaceExpr
toIfaceLFInfo :: Name -> LambdaFormInfo -> IfaceLFInfo
dehydrateCgBreakInfo :: [TyVar] -> [Maybe (Id, Word)] -> Type -> CgBreakInfo


-- | Module for constructing interface declaration values from the
--   corresponding <a>TyThing</a>s.
module GHC.Iface.Decl
coAxiomToIfaceDecl :: forall (br :: BranchFlag). CoAxiom br -> IfaceDecl
tyThingToIfaceDecl :: Bool -> TyThing -> IfaceDecl
toIfaceBooleanFormula :: BooleanFormula IfLclName -> IfaceBooleanFormula

module GHC.Types.TyThing.Ppr

-- | Pretty-prints a <a>TyThing</a>.
pprTyThing :: ShowSub -> TyThing -> SDoc

-- | Pretty-prints a <a>TyThing</a> in context: that is, if the entity is a
--   data constructor, record selector, or class method, then the entity's
--   parent declaration is pretty-printed with irrelevant parts omitted.
pprTyThingInContext :: ShowSub -> TyThing -> SDoc

-- | Pretty-prints a <a>TyThing</a> with its defining location.
pprTyThingLoc :: TyThing -> SDoc

-- | Like <a>pprTyThingInContext</a>, but adds the defining location.
pprTyThingInContextLoc :: TyThing -> SDoc

-- | Pretty-prints the <a>TyThing</a> header. For functions and data
--   constructors the function is equivalent to <a>pprTyThing</a> but for
--   type constructors and classes it prints only the header part of the
--   declaration.
pprTyThingHdr :: TyThing -> SDoc

-- | Pretty-prints a <a>FamInst</a> (type/data family instance) with its
--   defining location.
pprFamInst :: FamInst -> SDoc

module GHC.Tc.Errors.Ppr
pprTypeDoesNotHaveFixedRuntimeRep :: Type -> FixedRuntimeRepProvenance -> SDoc
pprScopeError :: RdrName -> NotInScopeError -> SDoc
tidySkolemInfo :: TidyEnv -> SkolemInfo -> SkolemInfo
tidySkolemInfoAnon :: TidyEnv -> SkolemInfoAnon -> SkolemInfoAnon
pprHsDocContext :: HsDocContext -> SDoc
inHsDocContext :: HsDocContext -> SDoc
data TcRnMessageOpts
TcRnMessageOpts :: !Bool -> !IfaceMessageOpts -> TcRnMessageOpts

-- | Whether we show the error context or not
[tcOptsShowContext] :: TcRnMessageOpts -> !Bool
[tcOptsIfaceOpts] :: TcRnMessageOpts -> !IfaceMessageOpts
pprTyThingUsedWrong :: WrongThingSort -> TcTyThing -> Name -> SDoc
pprUntouchableVariable :: TcTyVar -> Implication -> SDoc
mismatchMsg_ExpectedActuals :: MismatchMsg -> Maybe (Type, Type)
messageWithInfoDiagnosticMessage :: UnitState -> ErrInfo -> Bool -> DecoratedSDoc -> DecoratedSDoc
messageWithHsDocContext :: TcRnMessageOpts -> HsDocContext -> DecoratedSDoc -> DecoratedSDoc
instance GHC.Types.Error.Diagnostic GHC.Tc.Errors.Types.TcRnMessage
instance GHC.Types.Error.HasDefaultDiagnosticOpts GHC.Tc.Errors.Types.TcRnMessageOpts
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Types.ImportError
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Types.SolverReportErrCtxt


-- | Zonking types within the typechecker.
--   
--   Distinct from the final zonking pass in <a>GHC.Tc.Zonk.Type</a>; see
--   Note [Module structure for zonking] in GHC.Tc.Zonk.Type.
module GHC.Tc.Zonk.TcType
zonkTcType :: TcType -> ZonkM TcType
zonkTcTypes :: [TcType] -> ZonkM [TcType]
zonkScaledTcType :: Scaled TcType -> ZonkM (Scaled TcType)
zonkTcTyVar :: TcTyVar -> ZonkM TcType
zonkTcTyVars :: [TcTyVar] -> ZonkM [TcType]
zonkTcTyVarToTcTyVar :: HasDebugCallStack => TcTyVar -> ZonkM TcTyVar
zonkTcTyVarsToTcTyVars :: HasDebugCallStack => [TcTyVar] -> ZonkM [TcTyVar]
zonkInvisTVBinder :: VarBndr TcTyVar spec -> ZonkM (VarBndr TcTyVar spec)
zonkCo :: Coercion -> ZonkM Coercion
zonkTcTyCon :: TcTyCon -> ZonkM TcTyCon
zonkTcTypeAndFV :: TcType -> ZonkM DTyCoVarSet
zonkTyCoVarsAndFV :: TyCoVarSet -> ZonkM TyCoVarSet
zonkTyCoVarsAndFVList :: [TyCoVar] -> ZonkM [TyCoVar]
zonkDTyCoVarSetAndFV :: DTyCoVarSet -> ZonkM DTyCoVarSet

-- | zonkId is used *during* typechecking just to zonk the <tt>Id'</tt>s
--   type
zonkId :: TcId -> ZonkM TcId
zonkCoVar :: CoVar -> ZonkM CoVar
zonkTyCoVar :: TyCoVar -> ZonkM TcType
zonkTyCoVarKind :: TyCoVar -> ZonkM TyCoVar
zonkTyCoVarBndrKind :: VarBndr TyCoVar flag -> ZonkM (VarBndr TyCoVar flag)
zonkSkolemInfo :: SkolemInfo -> ZonkM SkolemInfo
zonkSkolemInfoAnon :: SkolemInfoAnon -> ZonkM SkolemInfoAnon
zonkCt :: Ct -> ZonkM Ct
zonkWC :: WantedConstraints -> ZonkM WantedConstraints
zonkSimples :: Cts -> ZonkM Cts
zonkImplication :: Implication -> ZonkM Implication
tcInitTidyEnv :: ZonkM TidyEnv

-- | Get a <a>TidyEnv</a> that includes mappings for all vars free in the
--   given type. Useful when tidying open types.
tcInitOpenTidyEnv :: [TyCoVar] -> ZonkM TidyEnv
tidyCt :: TidyEnv -> Ct -> Ct
tidyEvVar :: TidyEnv -> EvVar -> EvVar
tidyDelayedError :: TidyEnv -> DelayedError -> DelayedError
zonkTidyTcType :: TidyEnv -> TcType -> ZonkM (TidyEnv, TcType)
zonkTidyTcTypes :: TidyEnv -> [TcType] -> ZonkM (TidyEnv, [TcType])
zonkTidyOrigin :: TidyEnv -> CtOrigin -> ZonkM (TidyEnv, CtOrigin)
zonkTidyOrigins :: TidyEnv -> [CtOrigin] -> ZonkM (TidyEnv, [CtOrigin])
zonkTidyFRRInfos :: TidyEnv -> [FixedRuntimeRepErrorInfo] -> ZonkM (TidyEnv, [FixedRuntimeRepErrorInfo])

-- | Write into a currently-empty MetaTyVar.
--   
--   Works with both type and kind variables.
writeMetaTyVar :: HasDebugCallStack => TcTyVar -> TcType -> ZonkM ()

-- | Write into the <a>MetaDetails</a> mutable references of a
--   <a>MetaTv</a>.
writeMetaTyVarRef :: HasDebugCallStack => TcTyVar -> TcRef MetaDetails -> TcType -> ZonkM ()

-- | Check that a coercion is appropriate for filling a hole. (The hole
--   itself is needed only for printing.) Always returns the checked
--   coercion, but this return value is necessary so that the input
--   coercion is forced only when the output is forced.
checkCoercionHole :: CoVar -> Coercion -> ZonkM Coercion

module GHC.Driver.Errors.Ppr
instance GHC.Types.Error.Diagnostic GHC.Driver.Errors.Types.DriverMessage
instance GHC.Types.Error.Diagnostic GHC.Driver.Errors.Types.GhcMessage
instance GHC.Types.Error.HasDefaultDiagnosticOpts GHC.Driver.Errors.Types.DriverMessageOpts
instance GHC.Types.Error.HasDefaultDiagnosticOpts GHC.Driver.Errors.Types.GhcMessageOpts


-- | Source errors
module GHC.Types.SourceError

-- | A source error is an error that is caused by one or more errors in the
--   source code. A <a>SourceError</a> is thrown by many functions in the
--   compilation pipeline. Inside GHC these errors are merely printed via
--   <tt>log_action</tt>, but API clients may treat them differently, for
--   example, insert them into a list box. If you want the default
--   behaviour, use the idiom:
--   
--   <pre>
--   handleSourceError printExceptionAndWarnings $ do
--     ... api calls that may fail ...
--   </pre>
--   
--   The <a>SourceError</a>s error messages can be accessed via
--   <a>srcErrorMessages</a>. This list may be empty if the compiler failed
--   due to <tt>-Werror</tt> (<tt>Opt_WarnIsError</tt>).
--   
--   See <tt>printExceptionAndWarnings</tt> for more information on what to
--   take care of when writing a custom error handler.
newtype SourceError
SourceError :: Messages GhcMessage -> SourceError
mkSrcErr :: Messages GhcMessage -> SourceError
srcErrorMessages :: SourceError -> Messages GhcMessage
throwErrors :: MonadIO io => Messages GhcMessage -> io a
throwOneError :: MonadIO io => MsgEnvelope GhcMessage -> io a

-- | Perform the given action and call the exception handler if the action
--   throws a <a>SourceError</a>. See <a>SourceError</a> for more
--   information.
handleSourceError :: MonadCatch m => (SourceError -> m a) -> m a -> m a
instance GHC.Internal.Exception.Type.Exception GHC.Types.SourceError.SourceError
instance GHC.Internal.Show.Show GHC.Types.SourceError.SourceError


-- | Parsing the top of a Haskell source file to get its module name,
--   imports and options.
--   
--   (c) Simon Marlow 2005 (c) Lemmih 2006
module GHC.Parser.Header

-- | Parse the imports of a source file.
--   
--   Throws a <a>SourceError</a> if parsing fails.
getImports :: ParserOpts -> Bool -> StringBuffer -> FilePath -> FilePath -> IO (Either (Messages PsMessage) ([(RawPkgQual, Located ModuleName)], [(RawPkgQual, Located ModuleName)], Bool, Located ModuleName))
mkPrelImports :: ModuleName -> SrcSpan -> Bool -> [LImportDecl GhcPs] -> [LImportDecl GhcPs]

-- | Parse OPTIONS and LANGUAGE pragmas of the source file.
--   
--   Throws a <a>SourceError</a> if flag parsing fails (including
--   unsupported flags.)
getOptionsFromFile :: ParserOpts -> FilePath -> IO (Messages PsMessage, [Located String])

-- | Parse OPTIONS and LANGUAGE pragmas of the source file.
--   
--   Throws a <a>SourceError</a> if flag parsing fails (including
--   unsupported flags.)
getOptions :: ParserOpts -> StringBuffer -> FilePath -> (Messages PsMessage, [Located String])
toArgs :: RealSrcLoc -> String -> Either String [Located String]

-- | Complain about non-dynamic flags in OPTIONS pragmas.
--   
--   Throws a <a>SourceError</a> if the input list is non-empty claiming
--   that the input flags are unknown.
checkProcessArgsResult :: MonadIO m => [Located String] -> m ()

module GHC.Driver.Errors

-- | Given a bag of diagnostics, turn them into an exception if any has
--   <a>SevError</a>, or print them out otherwise.
printOrThrowDiagnostics :: Logger -> GhcMessageOpts -> DiagOpts -> Messages GhcMessage -> IO ()
printMessages :: Diagnostic a => Logger -> DiagnosticOpts a -> DiagOpts -> Messages a -> IO ()

-- | Convert a <tt>PsError</tt> into a wrapped <a>DriverMessage</a>; use it
--   for dealing with parse errors when the driver is doing dependency
--   analysis. Defined here to avoid module loops between
--   GHC.Driver.Error.Types and GHC.Driver.Error.Ppr
mkDriverPsHeaderMessage :: MsgEnvelope PsMessage -> MsgEnvelope DriverMessage


-- | Functions for initialising error message printing configuration from
--   the GHC session flags.
module GHC.Driver.Config.Diagnostic

-- | Initialise the general configuration for printing diagnostic messages
--   For example, this configuration controls things like whether warnings
--   are treated like errors.
initDiagOpts :: DynFlags -> DiagOpts

-- | Initialise the configuration for printing specific diagnostic messages
initPrintConfig :: DynFlags -> DiagnosticOpts GhcMessage
initPsMessageOpts :: DynFlags -> DiagnosticOpts PsMessage
initDsMessageOpts :: DynFlags -> DiagnosticOpts DsMessage
initTcMessageOpts :: DynFlags -> DiagnosticOpts TcRnMessage
initDriverMessageOpts :: DynFlags -> DiagnosticOpts DriverMessage
initIfaceMessageOpts :: DynFlags -> DiagnosticOpts IfaceMessage


-- | Command-line parser
--   
--   This is an abstract command-line parser used by DynFlags.
--   
--   (c) The University of Glasgow 2005
module GHC.Driver.CmdLine
processArgs :: Monad m => [Flag m] -> [Located String] -> (FilePath -> EwM m [Located String]) -> m ([Located String], [Err], Warns)

-- | Parse a response file into arguments.
parseResponseFile :: forall (m :: Type -> Type). MonadIO m => FilePath -> EwM m [Located String]
data OptKind (m :: Type -> Type)
NoArg :: EwM m () -> OptKind (m :: Type -> Type)
HasArg :: (String -> EwM m ()) -> OptKind (m :: Type -> Type)
SepArg :: (String -> EwM m ()) -> OptKind (m :: Type -> Type)
Prefix :: (String -> EwM m ()) -> OptKind (m :: Type -> Type)
OptPrefix :: (String -> EwM m ()) -> OptKind (m :: Type -> Type)
OptIntSuffix :: (Maybe Int -> EwM m ()) -> OptKind (m :: Type -> Type)
IntSuffix :: (Int -> EwM m ()) -> OptKind (m :: Type -> Type)
Word64Suffix :: (Word64 -> EwM m ()) -> OptKind (m :: Type -> Type)
FloatSuffix :: (Float -> EwM m ()) -> OptKind (m :: Type -> Type)
PassFlag :: (String -> EwM m ()) -> OptKind (m :: Type -> Type)
AnySuffix :: (String -> EwM m ()) -> OptKind (m :: Type -> Type)

-- | GHC flag modes describing when a flag has an effect.
data GhcFlagMode

-- | The flag only affects the non-interactive GHC
OnlyGhc :: GhcFlagMode

-- | The flag only affects the interactive GHC
OnlyGhci :: GhcFlagMode

-- | The flag affects multiple ghc modes
AllModes :: GhcFlagMode

-- | This flag should not be seen in cli completion
HiddenFlag :: GhcFlagMode
data Flag (m :: Type -> Type)
Flag :: String -> OptKind m -> GhcFlagMode -> Flag (m :: Type -> Type)
[flagName] :: Flag (m :: Type -> Type) -> String
[flagOptKind] :: Flag (m :: Type -> Type) -> OptKind m
[flagGhcMode] :: Flag (m :: Type -> Type) -> GhcFlagMode
defFlag :: forall (m :: Type -> Type). String -> OptKind m -> Flag m
defGhcFlag :: forall (m :: Type -> Type). String -> OptKind m -> Flag m
defGhciFlag :: forall (m :: Type -> Type). String -> OptKind m -> Flag m
defHiddenFlag :: forall (m :: Type -> Type). String -> OptKind m -> Flag m
hoistFlag :: (forall a. () => m a -> n a) -> Flag m -> Flag n
errorsToGhcException :: [(String, String)] -> GhcException

-- | A command-line error message
newtype Err
Err :: Located String -> Err
[errMsg] :: Err -> Located String

-- | A command-line warning message and the reason it arose
--   
--   This used to be own type, but now it's just <tt><a>MsgEnvelope</a>
--   <a>DriverMessage</a></tt>.
type Warn = Located DriverMessage
warnsToMessages :: DiagOpts -> [Warn] -> Messages DriverMessage
data EwM (m :: Type -> Type) a
runEwM :: EwM m a -> m (Errs, Warns, a)
addErr :: forall (m :: Type -> Type). Monad m => String -> EwM m ()
addWarn :: forall (m :: Type -> Type). Monad m => String -> EwM m ()
addFlagWarn :: forall (m :: Type -> Type). Monad m => DriverMessage -> EwM m ()
getArg :: forall (m :: Type -> Type). Monad m => EwM m String
getCurLoc :: forall (m :: Type -> Type). Monad m => EwM m SrcSpan
liftEwM :: Monad m => m a -> EwM m a
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Applicative (GHC.Driver.CmdLine.EwM m)
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (GHC.Driver.CmdLine.EwM m)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (GHC.Driver.CmdLine.EwM m)
instance GHC.Internal.Control.Monad.IO.Class.MonadIO m => GHC.Internal.Control.Monad.IO.Class.MonadIO (GHC.Driver.CmdLine.EwM m)


-- | Bytecode instruction definitions
module GHC.ByteCode.Instr
data BCInstr
STKCHECK :: !Word -> BCInstr
PUSH_L :: !WordOff -> BCInstr
PUSH_LL :: !WordOff -> !WordOff -> BCInstr
PUSH_LLL :: !WordOff -> !WordOff -> !WordOff -> BCInstr
PUSH8 :: !ByteOff -> BCInstr
PUSH16 :: !ByteOff -> BCInstr
PUSH32 :: !ByteOff -> BCInstr
PUSH8_W :: !ByteOff -> BCInstr
PUSH16_W :: !ByteOff -> BCInstr
PUSH32_W :: !ByteOff -> BCInstr
PUSH_G :: Name -> BCInstr
PUSH_PRIMOP :: PrimOp -> BCInstr
PUSH_BCO :: ProtoBCO Name -> BCInstr
PUSH_ALTS :: ProtoBCO Name -> ArgRep -> BCInstr
PUSH_ALTS_TUPLE :: ProtoBCO Name -> !NativeCallInfo -> ProtoBCO Name -> BCInstr
PUSH_PAD8 :: BCInstr
PUSH_PAD16 :: BCInstr
PUSH_PAD32 :: BCInstr
PUSH_UBX8 :: Literal -> BCInstr
PUSH_UBX16 :: Literal -> BCInstr
PUSH_UBX32 :: Literal -> BCInstr
PUSH_UBX :: Literal -> !WordOff -> BCInstr
PUSH_ADDR :: Name -> BCInstr
PUSH_APPLY_N :: BCInstr
PUSH_APPLY_V :: BCInstr
PUSH_APPLY_F :: BCInstr
PUSH_APPLY_D :: BCInstr
PUSH_APPLY_L :: BCInstr
PUSH_APPLY_P :: BCInstr
PUSH_APPLY_PP :: BCInstr
PUSH_APPLY_PPP :: BCInstr
PUSH_APPLY_PPPP :: BCInstr
PUSH_APPLY_PPPPP :: BCInstr
PUSH_APPLY_PPPPPP :: BCInstr
SLIDE :: !WordOff -> !WordOff -> BCInstr
ALLOC_AP :: !HalfWord -> BCInstr
ALLOC_AP_NOUPD :: !HalfWord -> BCInstr
ALLOC_PAP :: !HalfWord -> !HalfWord -> BCInstr
MKAP :: !WordOff -> !HalfWord -> BCInstr
MKPAP :: !WordOff -> !HalfWord -> BCInstr
UNPACK :: !WordOff -> BCInstr
PACK :: DataCon -> !WordOff -> BCInstr
LABEL :: LocalLabel -> BCInstr
TESTLT_I :: !Int -> LocalLabel -> BCInstr
TESTEQ_I :: !Int -> LocalLabel -> BCInstr
TESTLT_W :: !Word -> LocalLabel -> BCInstr
TESTEQ_W :: !Word -> LocalLabel -> BCInstr
TESTLT_I64 :: !Int64 -> LocalLabel -> BCInstr
TESTEQ_I64 :: !Int64 -> LocalLabel -> BCInstr
TESTLT_I32 :: !Int32 -> LocalLabel -> BCInstr
TESTEQ_I32 :: !Int32 -> LocalLabel -> BCInstr
TESTLT_I16 :: !Int16 -> LocalLabel -> BCInstr
TESTEQ_I16 :: !Int16 -> LocalLabel -> BCInstr
TESTLT_I8 :: !Int8 -> LocalLabel -> BCInstr
TESTEQ_I8 :: !Int16 -> LocalLabel -> BCInstr
TESTLT_W64 :: !Word64 -> LocalLabel -> BCInstr
TESTEQ_W64 :: !Word64 -> LocalLabel -> BCInstr
TESTLT_W32 :: !Word32 -> LocalLabel -> BCInstr
TESTEQ_W32 :: !Word32 -> LocalLabel -> BCInstr
TESTLT_W16 :: !Word16 -> LocalLabel -> BCInstr
TESTEQ_W16 :: !Word16 -> LocalLabel -> BCInstr
TESTLT_W8 :: !Word8 -> LocalLabel -> BCInstr
TESTEQ_W8 :: !Word8 -> LocalLabel -> BCInstr
TESTLT_F :: !Float -> LocalLabel -> BCInstr
TESTEQ_F :: !Float -> LocalLabel -> BCInstr
TESTLT_D :: !Double -> LocalLabel -> BCInstr
TESTEQ_D :: !Double -> LocalLabel -> BCInstr
TESTLT_P :: !Word16 -> LocalLabel -> BCInstr
TESTEQ_P :: !Word16 -> LocalLabel -> BCInstr
CASEFAIL :: BCInstr
JMP :: LocalLabel -> BCInstr
CCALL :: !WordOff -> RemotePtr C_ffi_cif -> !Word16 -> BCInstr
PRIMCALL :: BCInstr
SWIZZLE :: !WordOff -> !Int -> BCInstr
ENTER :: BCInstr
RETURN :: ArgRep -> BCInstr
RETURN_TUPLE :: BCInstr
BRK_FUN :: ForeignRef BreakArray -> RemotePtr ModuleName -> !Word16 -> RemotePtr ModuleName -> !Word16 -> RemotePtr CostCentre -> BCInstr
data ProtoBCO a
ProtoBCO :: a -> [BCInstr] -> [StgWord] -> Word -> Int -> Either [CgStgAlt] CgStgRhs -> [FFIInfo] -> ProtoBCO a
[protoBCOName] :: ProtoBCO a -> a
[protoBCOInstrs] :: ProtoBCO a -> [BCInstr]
[protoBCOBitmap] :: ProtoBCO a -> [StgWord]
[protoBCOBitmapSize] :: ProtoBCO a -> Word
[protoBCOArity] :: ProtoBCO a -> Int
[protoBCOExpr] :: ProtoBCO a -> Either [CgStgAlt] CgStgRhs
[protoBCOFFIs] :: ProtoBCO a -> [FFIInfo]
bciStackUse :: BCInstr -> Word

-- | A local block label (e.g. identifying a case alternative).
newtype LocalLabel
LocalLabel :: Word32 -> LocalLabel
[getLocalLabel] :: LocalLabel -> Word32
instance GHC.Classes.Eq GHC.ByteCode.Instr.LocalLabel
instance GHC.Classes.Ord GHC.ByteCode.Instr.LocalLabel
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Instr.BCInstr
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Instr.LocalLabel
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.ByteCode.Instr.ProtoBCO a)


-- | PrimOp's Ids
module GHC.Builtin.PrimOps.Ids

-- | Get primop id.
--   
--   Retrieve it from <a>primOpIds</a> cache.
primOpId :: PrimOp -> Id

-- | All the primop ids, as a list
allThePrimOpIds :: [Id]


-- | Constant Folder
module GHC.Core.Opt.ConstantFold
primOpRules :: Name -> PrimOp -> Maybe CoreRule
builtinRules :: [CoreRule]

-- | Match the scrutinee of a case and potentially return a new scrutinee
--   and a function to apply to each literal alternative.
caseRules :: Platform -> CoreExpr -> Maybe (CoreExpr, AltCon -> Maybe AltCon, Id -> CoreExpr)

-- | Case rules
--   
--   It's important that occurrence info are present, hence the use of In*
--   types.
caseRules2 :: InExpr -> InId -> [InAlt] -> Maybe (InExpr, InId, [InAlt])
instance GHC.Internal.Base.Alternative GHC.Core.Opt.ConstantFold.RuleM
instance GHC.Internal.Base.Applicative GHC.Core.Opt.ConstantFold.RuleM
instance GHC.Internal.Base.Functor GHC.Core.Opt.ConstantFold.RuleM
instance GHC.Internal.Control.Monad.Fail.MonadFail GHC.Core.Opt.ConstantFold.RuleM
instance GHC.Internal.Base.MonadPlus GHC.Core.Opt.ConstantFold.RuleM
instance GHC.Internal.Base.Monad GHC.Core.Opt.ConstantFold.RuleM

module GHC.Unit.External

-- | Information about the currently loaded external packages. This is
--   mutable because packages will be demand-loaded during a compilation
--   run as required.
newtype ExternalUnitCache
ExternalUnitCache :: IORef ExternalPackageState -> ExternalUnitCache
[euc_eps] :: ExternalUnitCache -> IORef ExternalPackageState
initExternalUnitCache :: IO ExternalUnitCache
eucEPS :: ExternalUnitCache -> IO ExternalPackageState

-- | Information about other packages that we have slurped in by reading
--   their interface files
data ExternalPackageState
EPS :: !InstalledModuleEnv ModuleNameWithIsBoot -> !PackageIfaceTable -> InstalledModuleEnv (UniqDSet ModuleName) -> !PackageTypeEnv -> !ModuleEnv (IO Linkable) -> !PackageInstEnv -> !PackageFamInstEnv -> !PackageRuleBase -> !PackageAnnEnv -> !PackageCompleteMatches -> !ModuleEnv FamInstEnv -> !EpsStats -> ExternalPackageState

-- | In OneShot mode (only), home-package modules accumulate in the
--   external package state, and are sucked in lazily. For these home-pkg
--   modules (only) we need to record which are boot modules. We set this
--   field after loading all the explicitly-imported interfaces, but before
--   doing anything else
--   
--   The <a>ModuleName</a> part is not necessary, but it's useful for debug
--   prints, and it's convenient because this field comes direct from
--   <a>imp_dep_mods</a>
[eps_is_boot] :: ExternalPackageState -> !InstalledModuleEnv ModuleNameWithIsBoot

-- | The <a>ModIface</a>s for modules in external packages whose interfaces
--   we have opened. The declarations in these interface files are held in
--   the <tt>eps_decls</tt>, <a>eps_inst_env</a>, <a>eps_fam_inst_env</a>
--   and <tt>eps_rules</tt> fields of this record, not in the
--   <a>mi_decls</a> fields of the interface we have sucked in.
--   
--   What <i>is</i> in the PIT is:
--   
--   <ul>
--   <li>The Module</li>
--   <li>Fingerprint info</li>
--   <li>Its exports</li>
--   <li>Fixities</li>
--   <li>Deprecations and warnings</li>
--   </ul>
[eps_PIT] :: ExternalPackageState -> !PackageIfaceTable

-- | Cache for <a>mi_free_holes</a>. Ordinarily, we can rely on the
--   <a>eps_PIT</a> for this information, EXCEPT that when we do dependency
--   analysis, we need to look at the <tt>Dependencies</tt> of our imports
--   to determine what their precise free holes are
--   (<tt>moduleFreeHolesPrecise</tt>). We don't want to repeatedly reread
--   in the interface for every import, so cache it here. When the PIT gets
--   filled in we can drop these entries.
[eps_free_holes] :: ExternalPackageState -> InstalledModuleEnv (UniqDSet ModuleName)

-- | Result of typechecking all the external package interface files we
--   have sucked in. The domain of the mapping is external-package modules
[eps_PTE] :: ExternalPackageState -> !PackageTypeEnv

-- | If an interface was written with <tt>-fwrite-if-simplified-core</tt>,
--   this will contain an IO action that compiles bytecode from core
--   bindings.
--   
--   See Note [Interface Files with Core Definitions]
[eps_iface_bytecode] :: ExternalPackageState -> !ModuleEnv (IO Linkable)

-- | The total <a>InstEnv</a> accumulated from all the external-package
--   modules
[eps_inst_env] :: ExternalPackageState -> !PackageInstEnv

-- | The total <a>FamInstEnv</a> accumulated from all the external-package
--   modules
[eps_fam_inst_env] :: ExternalPackageState -> !PackageFamInstEnv

-- | The total <tt>RuleEnv</tt> accumulated from all the external-package
--   modules
[eps_rule_base] :: ExternalPackageState -> !PackageRuleBase

-- | The total <a>AnnEnv</a> accumulated from all the external-package
--   modules
[eps_ann_env] :: ExternalPackageState -> !PackageAnnEnv

-- | The total <a>CompleteMatches</a> accumulated from all the
--   external-package modules
[eps_complete_matches] :: ExternalPackageState -> !PackageCompleteMatches

-- | The family instances accumulated from external packages, keyed off the
--   module that declared them
[eps_mod_fam_inst_env] :: ExternalPackageState -> !ModuleEnv FamInstEnv

-- | Statistics about what was loaded from external packages
[eps_stats] :: ExternalPackageState -> !EpsStats
initExternalPackageState :: ExternalPackageState

-- | Accumulated statistics about what we are putting into the
--   <a>ExternalPackageState</a>. "In" means stuff that is just <i>read</i>
--   from interface files, "Out" means actually sucked in and type-checked
data EpsStats
EpsStats :: !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> EpsStats
[n_ifaces_in] :: EpsStats -> !Int
[n_decls_in] :: EpsStats -> !Int
[n_decls_out] :: EpsStats -> !Int
[n_rules_in] :: EpsStats -> !Int
[n_rules_out] :: EpsStats -> !Int
[n_insts_in] :: EpsStats -> !Int
[n_insts_out] :: EpsStats -> !Int

-- | Add stats for one newly-read interface
addEpsInStats :: EpsStats -> Int -> Int -> Int -> EpsStats
type PackageTypeEnv = TypeEnv

-- | Helps us find information about modules in the imported packages
type PackageIfaceTable = ModuleEnv ModIface
type PackageInstEnv = InstEnv
type PackageFamInstEnv = FamInstEnv
type PackageRuleBase = RuleBase
type PackageCompleteMatches = CompleteMatches

-- | Constructs an empty PackageIfaceTable
emptyPackageIfaceTable :: PackageIfaceTable

module GHC.Unit.Env
data UnitEnv
UnitEnv :: {-# UNPACK #-} !ExternalUnitCache -> UnitId -> !HomeUnitGraph -> !Platform -> !GhcNameVersion -> UnitEnv

-- | Information about the currently loaded external packages. This is
--   mutable because packages will be demand-loaded during a compilation
--   run as required.
[ue_eps] :: UnitEnv -> {-# UNPACK #-} !ExternalUnitCache
[ue_current_unit] :: UnitEnv -> UnitId
[ue_home_unit_graph] :: UnitEnv -> !HomeUnitGraph

-- | Platform
[ue_platform] :: UnitEnv -> !Platform

-- | GHC name/version (used for dynamic library suffix)
[ue_namever] :: UnitEnv -> !GhcNameVersion
initUnitEnv :: UnitId -> HomeUnitGraph -> GhcNameVersion -> Platform -> IO UnitEnv
ueEPS :: UnitEnv -> IO ExternalPackageState

-- | Get home-unit
--   
--   Unsafe because the home-unit may not be set
unsafeGetHomeUnit :: UnitEnv -> HomeUnit
updateHug :: (HomeUnitGraph -> HomeUnitGraph) -> UnitEnv -> UnitEnv
updateHpt_lazy :: (HomePackageTable -> HomePackageTable) -> UnitEnv -> UnitEnv
updateHpt :: (HomePackageTable -> HomePackageTable) -> UnitEnv -> UnitEnv
ue_units :: HasDebugCallStack => UnitEnv -> UnitState
ue_currentHomeUnitEnv :: HasDebugCallStack => UnitEnv -> HomeUnitEnv
ue_setUnits :: UnitState -> UnitEnv -> UnitEnv
ue_setUnitFlags :: HasDebugCallStack => UnitId -> DynFlags -> UnitEnv -> UnitEnv
ue_unit_dbs :: UnitEnv -> Maybe [UnitDatabase UnitId]
ue_all_home_unit_ids :: UnitEnv -> Set UnitId
ue_setUnitDbs :: Maybe [UnitDatabase UnitId] -> UnitEnv -> UnitEnv
ue_hpt :: HasDebugCallStack => UnitEnv -> HomePackageTable
ue_homeUnit :: UnitEnv -> Maybe HomeUnit
ue_unsafeHomeUnit :: UnitEnv -> HomeUnit
ue_setFlags :: HasDebugCallStack => DynFlags -> UnitEnv -> UnitEnv
ue_setActiveUnit :: UnitId -> UnitEnv -> UnitEnv
ue_currentUnit :: UnitEnv -> UnitId
ue_findHomeUnitEnv :: HasDebugCallStack => UnitId -> UnitEnv -> HomeUnitEnv
ue_updateHomeUnitEnv :: (HomeUnitEnv -> HomeUnitEnv) -> UnitId -> UnitEnv -> UnitEnv
ue_unitHomeUnit :: UnitId -> UnitEnv -> HomeUnit
ue_unitFlags :: HasDebugCallStack => UnitId -> UnitEnv -> DynFlags

-- | Rename a unit id in the internal unit env.
--   
--   <tt><a>ue_renameUnitId</a> oldUnit newUnit UnitEnv</tt>, it is assumed
--   that the <tt>oldUnit</tt> exists in the map, otherwise we panic. The
--   <a>DynFlags</a> associated with the home unit will have its field
--   <a>homeUnitId</a> set to <tt>newUnit</tt>.
ue_renameUnitId :: HasDebugCallStack => UnitId -> UnitId -> UnitEnv -> UnitEnv
ue_transitiveHomeDeps :: UnitId -> UnitEnv -> [UnitId]
type HomeUnitGraph = UnitEnvGraph HomeUnitEnv
data HomeUnitEnv
HomeUnitEnv :: !UnitState -> !Maybe [UnitDatabase UnitId] -> DynFlags -> HomePackageTable -> !Maybe HomeUnit -> HomeUnitEnv

-- | External units
[homeUnitEnv_units] :: HomeUnitEnv -> !UnitState

-- | Stack of unit databases for the target platform.
--   
--   This field is populated with the result of <a>initUnits</a>.
--   
--   <a>Nothing</a> means the databases have never been read from disk.
--   
--   Usually we don't reload the databases from disk if they are cached,
--   even if the database flags changed!
[homeUnitEnv_unit_dbs] :: HomeUnitEnv -> !Maybe [UnitDatabase UnitId]

-- | The dynamic flag settings
[homeUnitEnv_dflags] :: HomeUnitEnv -> DynFlags

-- | The home package table describes already-compiled home-package
--   modules, <i>excluding</i> the module we are compiling right now. (In
--   one-shot mode the current module is the only home-package module, so
--   homeUnitEnv_hpt is empty. All other modules count as
--   "external-package" modules. However, even in GHCi mode, hi-boot
--   interfaces are demand-loaded into the external-package table.)
--   
--   <a>homeUnitEnv_hpt</a> is not mutable because we only demand-load
--   external packages; the home package is eagerly loaded, module by
--   module, by the compilation manager.
--   
--   The HPT may contain modules compiled earlier by <tt>--make</tt> but
--   not actually below the current module in the dependency graph.
--   
--   (This changes a previous invariant: changed Jan 05.)
[homeUnitEnv_hpt] :: HomeUnitEnv -> HomePackageTable

-- | Home-unit
[homeUnitEnv_home_unit] :: HomeUnitEnv -> !Maybe HomeUnit
mkHomeUnitEnv :: DynFlags -> HomePackageTable -> Maybe HomeUnit -> HomeUnitEnv
lookupHugByModule :: Module -> HomeUnitGraph -> Maybe HomeModInfo
hugElts :: HomeUnitGraph -> [(UnitId, HomeUnitEnv)]
lookupHug :: HomeUnitGraph -> UnitId -> ModuleName -> Maybe HomeModInfo
addHomeModInfoToHug :: HomeModInfo -> HomeUnitGraph -> HomeUnitGraph
newtype UnitEnvGraph v
UnitEnvGraph :: Map UnitEnvGraphKey v -> UnitEnvGraph v
[unitEnv_graph] :: UnitEnvGraph v -> Map UnitEnvGraphKey v
type UnitEnvGraphKey = UnitId
unitEnv_insert :: UnitEnvGraphKey -> v -> UnitEnvGraph v -> UnitEnvGraph v
unitEnv_delete :: UnitEnvGraphKey -> UnitEnvGraph v -> UnitEnvGraph v
unitEnv_adjust :: (v -> v) -> UnitEnvGraphKey -> UnitEnvGraph v -> UnitEnvGraph v
unitEnv_new :: Map UnitEnvGraphKey v -> UnitEnvGraph v
unitEnv_singleton :: UnitEnvGraphKey -> v -> UnitEnvGraph v
unitEnv_map :: (v -> v) -> UnitEnvGraph v -> UnitEnvGraph v
unitEnv_member :: UnitEnvGraphKey -> UnitEnvGraph v -> Bool
unitEnv_lookup_maybe :: UnitEnvGraphKey -> UnitEnvGraph v -> Maybe v
unitEnv_lookup :: UnitEnvGraphKey -> UnitEnvGraph v -> v
unitEnv_keys :: UnitEnvGraph v -> Set UnitEnvGraphKey
unitEnv_elts :: UnitEnvGraph v -> [(UnitEnvGraphKey, v)]
unitEnv_hpts :: UnitEnvGraph HomeUnitEnv -> [HomePackageTable]
unitEnv_foldWithKey :: (b -> UnitEnvGraphKey -> a -> b) -> b -> UnitEnvGraph a -> b
unitEnv_union :: (a -> a -> a) -> UnitEnvGraph a -> UnitEnvGraph a -> UnitEnvGraph a
unitEnv_mapWithKey :: (UnitEnvGraphKey -> v -> b) -> UnitEnvGraph v -> UnitEnvGraph b
assertUnitEnvInvariant :: HasDebugCallStack => UnitEnv -> UnitEnv

-- | Lookup <a>UnitInfo</a> for every preload unit from the UnitState and
--   for every unit used to instantiate the home unit.
preloadUnitsInfo :: UnitEnv -> MaybeErr UnitErr [UnitInfo]

-- | Lookup <a>UnitInfo</a> for every preload unit from the UnitState, for
--   every unit used to instantiate the home unit, and for every unit
--   explicitly passed in the given list of UnitId.
preloadUnitsInfo' :: UnitEnv -> [UnitId] -> MaybeErr UnitErr [UnitInfo]

-- | Test if the module comes from the home unit
isUnitEnvInstalledModule :: UnitEnv -> InstalledModule -> Bool
instance GHC.Internal.Data.Foldable.Foldable GHC.Unit.Env.UnitEnvGraph
instance GHC.Internal.Base.Functor GHC.Unit.Env.UnitEnvGraph
instance GHC.Utils.Outputable.Outputable GHC.Unit.Env.HomeUnitEnv
instance GHC.Utils.Outputable.Outputable (GHC.Unit.Env.UnitEnvGraph GHC.Unit.Env.HomeUnitEnv)
instance GHC.Internal.Data.Traversable.Traversable GHC.Unit.Env.UnitEnvGraph

module GHC.Unit.Finder.Types
data FinderCache
FinderCache :: (UnitEnv -> IO ()) -> (InstalledModuleWithIsBoot -> InstalledFindResult -> IO ()) -> (InstalledModuleWithIsBoot -> IO (Maybe InstalledFindResult)) -> (FilePath -> IO Fingerprint) -> FinderCache

-- | remove all the home modules from the cache; package modules are
--   assumed to not move around during a session; also flush the file hash
--   cache.
[flushFinderCaches] :: FinderCache -> UnitEnv -> IO ()

-- | Add a found location to the cache for the module.
[addToFinderCache] :: FinderCache -> InstalledModuleWithIsBoot -> InstalledFindResult -> IO ()

-- | Look for a location in the cache.
[lookupFinderCache] :: FinderCache -> InstalledModuleWithIsBoot -> IO (Maybe InstalledFindResult)

-- | Look for the hash of a file in the cache. This should add it to the
--   cache. If the file doesn't exist, raise an IOException.
[lookupFileCache] :: FinderCache -> FilePath -> IO Fingerprint

-- | The <a>FinderCache</a> maps modules to the result of searching for
--   that module. It records the results of searching for modules along the
--   search path. On <tt>:load</tt>, we flush the entire contents of this
--   cache.
type FinderCacheState = InstalledModuleEnv InstalledFindResult
type FileCacheState = Map FilePath Fingerprint

-- | The result of searching for an imported module.
--   
--   NB: FindResult manages both user source-import lookups (which can
--   result in <a>Module</a>) as well as direct imports for interfaces
--   (which always result in <a>InstalledModule</a>).
data FindResult

-- | The module was found
Found :: ModLocation -> Module -> FindResult

-- | The requested unit was not found
NoPackage :: Unit -> FindResult

-- | _Error_: both in multiple packages
FoundMultiple :: [(Module, ModuleOrigin)] -> FindResult

-- | Not found
NotFound :: [FilePath] -> Maybe Unit -> [Unit] -> [Unit] -> [UnusableUnit] -> [ModuleSuggestion] -> FindResult

-- | Places where I looked
[fr_paths] :: FindResult -> [FilePath]

-- | Just p =&gt; module is in this unit's manifest, but couldn't find the
--   .hi file
[fr_pkg] :: FindResult -> Maybe Unit

-- | Module is in these units, but the *module* is hidden
[fr_mods_hidden] :: FindResult -> [Unit]

-- | Module is in these units, but the *unit* is hidden
[fr_pkgs_hidden] :: FindResult -> [Unit]

-- | Module is in these units, but it is unusable
[fr_unusables] :: FindResult -> [UnusableUnit]

-- | Possible mis-spelled modules
[fr_suggestions] :: FindResult -> [ModuleSuggestion]
data InstalledFindResult
InstalledFound :: ModLocation -> InstalledModule -> InstalledFindResult
InstalledNoPackage :: UnitId -> InstalledFindResult
InstalledNotFound :: [OsPath] -> Maybe UnitId -> InstalledFindResult

-- | Locations and information the finder cares about.
--   
--   Should be taken from <tt>DynFlags</tt> via <tt>initFinderOpts</tt>.
data FinderOpts
FinderOpts :: [OsPath] -> Bool -> Bool -> Ways -> Bool -> Maybe OsPath -> Maybe FastString -> Set ModuleName -> Map ModuleName ModuleName -> Maybe OsPath -> OsString -> Maybe OsPath -> OsString -> OsString -> Maybe OsPath -> OsString -> OsString -> Maybe OsPath -> FinderOpts

-- | Where are we allowed to look for Modules and Source files
[finder_importPaths] :: FinderOpts -> [OsPath]

-- | When looking up a home module:
--   
--   <ul>
--   <li><a>True</a>: search interface files (e.g. in '-c' mode)</li>
--   <li><a>False</a>: search source files (e.g. in '--make' mode)</li>
--   </ul>
[finder_lookupHomeInterfaces] :: FinderOpts -> Bool

-- | Don't check that an imported interface file actually exists if it can
--   only be at one location. The interface will be reported as
--   <a>InstalledFound</a> even if the file doesn't exist, so this is only
--   useful in specific cases (e.g. to generate dependencies with `ghc -M`)
[finder_bypassHiFileCheck] :: FinderOpts -> Bool
[finder_ways] :: FinderOpts -> Ways

-- | If we encounter unknown modules, should we suggest modules that have a
--   similar name.
[finder_enableSuggestions] :: FinderOpts -> Bool
[finder_workingDirectory] :: FinderOpts -> Maybe OsPath
[finder_thisPackageName] :: FinderOpts -> Maybe FastString
[finder_hiddenModules] :: FinderOpts -> Set ModuleName
[finder_reexportedModules] :: FinderOpts -> Map ModuleName ModuleName
[finder_hieDir] :: FinderOpts -> Maybe OsPath
[finder_hieSuf] :: FinderOpts -> OsString
[finder_hiDir] :: FinderOpts -> Maybe OsPath
[finder_hiSuf] :: FinderOpts -> OsString
[finder_dynHiSuf] :: FinderOpts -> OsString
[finder_objectDir] :: FinderOpts -> Maybe OsPath
[finder_objectSuf] :: FinderOpts -> OsString
[finder_dynObjectSuf] :: FinderOpts -> OsString
[finder_stubDir] :: FinderOpts -> Maybe OsPath

module GHC.Driver.Config.Finder

-- | Locations and information the finder cares about.
--   
--   Should be taken from <tt>DynFlags</tt> via <tt>initFinderOpts</tt>.
data FinderOpts
FinderOpts :: [OsPath] -> Bool -> Bool -> Ways -> Bool -> Maybe OsPath -> Maybe FastString -> Set ModuleName -> Map ModuleName ModuleName -> Maybe OsPath -> OsString -> Maybe OsPath -> OsString -> OsString -> Maybe OsPath -> OsString -> OsString -> Maybe OsPath -> FinderOpts

-- | Where are we allowed to look for Modules and Source files
[finder_importPaths] :: FinderOpts -> [OsPath]

-- | When looking up a home module:
--   
--   <ul>
--   <li><a>True</a>: search interface files (e.g. in '-c' mode)</li>
--   <li><a>False</a>: search source files (e.g. in '--make' mode)</li>
--   </ul>
[finder_lookupHomeInterfaces] :: FinderOpts -> Bool

-- | Don't check that an imported interface file actually exists if it can
--   only be at one location. The interface will be reported as
--   <a>InstalledFound</a> even if the file doesn't exist, so this is only
--   useful in specific cases (e.g. to generate dependencies with `ghc -M`)
[finder_bypassHiFileCheck] :: FinderOpts -> Bool
[finder_ways] :: FinderOpts -> Ways

-- | If we encounter unknown modules, should we suggest modules that have a
--   similar name.
[finder_enableSuggestions] :: FinderOpts -> Bool
[finder_workingDirectory] :: FinderOpts -> Maybe OsPath
[finder_thisPackageName] :: FinderOpts -> Maybe FastString
[finder_hiddenModules] :: FinderOpts -> Set ModuleName
[finder_reexportedModules] :: FinderOpts -> Map ModuleName ModuleName
[finder_hieDir] :: FinderOpts -> Maybe OsPath
[finder_hieSuf] :: FinderOpts -> OsString
[finder_hiDir] :: FinderOpts -> Maybe OsPath
[finder_hiSuf] :: FinderOpts -> OsString
[finder_dynHiSuf] :: FinderOpts -> OsString
[finder_objectDir] :: FinderOpts -> Maybe OsPath
[finder_objectSuf] :: FinderOpts -> OsString
[finder_dynObjectSuf] :: FinderOpts -> OsString
[finder_stubDir] :: FinderOpts -> Maybe OsPath

-- | Create a new <a>FinderOpts</a> from DynFlags.
initFinderOpts :: DynFlags -> FinderOpts

module GHC.Types.Name.Ppr

-- | Creates some functions that work out the best ways to format names for
--   the user according to a set of heuristics.
mkNamePprCtx :: Outputable info => PromotionTickContext -> UnitEnv -> GlobalRdrEnvX info -> NamePprCtx

-- | Creates a function for formatting modules based on two heuristics: (1)
--   if the module is the current module, don't qualify, and (2) if there
--   is only one exposed package which exports this module, don't qualify.
mkQualModule :: UnitState -> Maybe HomeUnit -> QueryQualifyModule

-- | Creates a function for formatting packages based on two heuristics:
--   (1) don't qualify if the package in question is "main", and (2) only
--   qualify with a unit id if the package ID would be ambiguous.
mkQualPackage :: UnitState -> QueryQualifyPackage

-- | A function which only qualifies package names if necessary; but
--   qualifies all other identifiers.
pkgQual :: UnitState -> NamePprCtx


-- | Types used by the runtime interpreter
module GHC.Runtime.Interpreter.Types

-- | Interpreter
data Interp
Interp :: !InterpInstance -> !Loader -> !MVar (UniqFM FastString (Ptr ())) -> Interp

-- | Interpreter instance (internal, external)
[interpInstance] :: Interp -> !InterpInstance

-- | Interpreter loader
[interpLoader] :: Interp -> !Loader

-- | LookupSymbol cache
[interpLookupSymbolCache] :: Interp -> !MVar (UniqFM FastString (Ptr ()))
data InterpInstance

-- | External interpreter
ExternalInterp :: !ExtInterp -> InterpInstance

-- | Internal interpreter
InternalInterp :: InterpInstance
data InterpProcess
InterpProcess :: !Pipe -> !ProcessHandle -> !MVar () -> InterpProcess

-- | Pipe to communicate with the server
[interpPipe] :: InterpProcess -> !Pipe

-- | Process handle of the server
[interpHandle] :: InterpProcess -> !ProcessHandle

-- | Lock to prevent concurrent access to the stream
[interpLock] :: InterpProcess -> !MVar ()
data ExtInterp
ExtIServ :: !IServ -> ExtInterp
ExtJS :: !JSInterp -> ExtInterp
ExtWasm :: !WasmInterp -> ExtInterp
type ExtInterpStatusVar d = MVar InterpStatus ExtInterpInstance d

-- | Common field between native external interpreter and the JS one
data ExtInterpInstance c
ExtInterpInstance :: {-# UNPACK #-} !InterpProcess -> !MVar [HValueRef] -> !c -> ExtInterpInstance c

-- | External interpreter process and its pipe (communication channel)
[instProcess] :: ExtInterpInstance c -> {-# UNPACK #-} !InterpProcess

-- | Values that need to be freed before the next command is sent.
--   Finalizers for ForeignRefs can append values to this list
--   asynchronously.
[instPendingFrees] :: ExtInterpInstance c -> !MVar [HValueRef]

-- | Instance specific extra fields
[instExtra] :: ExtInterpInstance c -> !c

-- | External interpreter
--   
--   The external interpreter is spawned lazily (on first use) to avoid
--   slowing down sessions that don't require it. The contents of the MVar
--   reflects the state of the interpreter (running or not).
data ExtInterpState cfg details
ExtInterpState :: !cfg -> !ExtInterpStatusVar details -> ExtInterpState cfg details
[interpConfig] :: ExtInterpState cfg details -> !cfg
[interpStatus] :: ExtInterpState cfg details -> !ExtInterpStatusVar details

-- | Status of an external interpreter
data InterpStatus inst

-- | Not spawned yet
InterpPending :: InterpStatus inst

-- | Running
InterpRunning :: !inst -> InterpStatus inst
type IServ = ExtInterpState IServConfig ()

-- | Configuration needed to spawn an external interpreter
data IServConfig
IServConfig :: !String -> ![String] -> !Bool -> !Bool -> !Maybe (CreateProcess -> IO ProcessHandle) -> IO () -> IServConfig

-- | External program to run
[iservConfProgram] :: IServConfig -> !String

-- | Command-line options
[iservConfOpts] :: IServConfig -> ![String]

-- | Use Profiling way
[iservConfProfiled] :: IServConfig -> !Bool

-- | Use Dynamic way
[iservConfDynamic] :: IServConfig -> !Bool

-- | Hook
[iservConfHook] :: IServConfig -> !Maybe (CreateProcess -> IO ProcessHandle)

-- | Trace action executed after spawn
[iservConfTrace] :: IServConfig -> IO ()
type JSInterp = ExtInterpState JSInterpConfig JSInterpExtra
data JSInterpExtra
JSInterpExtra :: !Handle -> !FinderCache -> !FinderOpts -> !MVar JSState -> !UnitId -> JSInterpExtra

-- | Stdin for the process
[instStdIn] :: JSInterpExtra -> !Handle
[instFinderCache] :: JSInterpExtra -> !FinderCache
[instFinderOpts] :: JSInterpExtra -> !FinderOpts

-- | Mutable state
[instJSState] :: JSInterpExtra -> !MVar JSState

-- | GHCi unit-id
[instGhciUnitId] :: JSInterpExtra -> !UnitId
data JSInterpConfig
JSInterpConfig :: !NodeJsSettings -> !FilePath -> !TmpFs -> !TempDir -> !Logger -> !StgToJSConfig -> !UnitEnv -> !FinderOpts -> !FinderCache -> JSInterpConfig

-- | NodeJS settings
[jsInterpNodeConfig] :: JSInterpConfig -> !NodeJsSettings

-- | Path to "ghc-interp.js" script
[jsInterpScript] :: JSInterpConfig -> !FilePath
[jsInterpTmpFs] :: JSInterpConfig -> !TmpFs
[jsInterpTmpDir] :: JSInterpConfig -> !TempDir
[jsInterpLogger] :: JSInterpConfig -> !Logger
[jsInterpCodegenCfg] :: JSInterpConfig -> !StgToJSConfig
[jsInterpUnitEnv] :: JSInterpConfig -> !UnitEnv
[jsInterpFinderOpts] :: JSInterpConfig -> !FinderOpts
[jsInterpFinderCache] :: JSInterpConfig -> !FinderCache
data JSState
JSState :: !LinkPlan -> !Bool -> JSState

-- | Linker state of the interpreter
[jsLinkState] :: JSState -> !LinkPlan

-- | Is the Haskell server started?
[jsServerStarted] :: JSState -> !Bool

-- | NodeJs configuration
data NodeJsSettings
NodeJsSettings :: FilePath -> Maybe FilePath -> [String] -> Integer -> NodeJsSettings

-- | location of node.js program
[nodeProgram] :: NodeJsSettings -> FilePath

-- | value of NODE_PATH environment variable (search path for Node modules;
--   GHCJS used to provide some)
[nodePath] :: NodeJsSettings -> Maybe FilePath

-- | extra arguments to pass to node.js
[nodeExtraArgs] :: NodeJsSettings -> [String]

-- | keep node.js (TH, GHCJSi) processes alive if they don't use more than
--   this
[nodeKeepAliveMaxMem] :: NodeJsSettings -> Integer
defaultNodeJsSettings :: NodeJsSettings
type WasmInterp = ExtInterpState WasmInterpConfig ()
data WasmInterpConfig
WasmInterpConfig :: !FilePath -> FilePath -> ![String] -> !Platform -> !Bool -> !String -> !UnitState -> WasmInterpConfig

-- | Location of dyld.mjs script
[wasmInterpDyLD] :: WasmInterpConfig -> !FilePath

-- | wasi-sdk sysroot libdir containing libc.so, etc
[wasmInterpLibDir] :: WasmInterpConfig -> FilePath

-- | Additional command line arguments for iserv
[wasmInterpOpts] :: WasmInterpConfig -> ![String]
[wasmInterpTargetPlatform] :: WasmInterpConfig -> !Platform

-- | Are we profiling yet?
[wasmInterpProfiled] :: WasmInterpConfig -> !Bool

-- | Shared lib filename common suffix sans .so, e.g. p-ghc9.13.20241001
[wasmInterpHsSoSuffix] :: WasmInterpConfig -> !String
[wasmInterpUnitState] :: WasmInterpConfig -> !UnitState

module GHC.Runtime.Interpreter.Wasm
spawnWasmInterp :: WasmInterpConfig -> IO (ExtInterpInstance ())

module GHC.Runtime.Interpreter.Process

-- | A <tt>Message a</tt> is a message that returns a value of type
--   <tt>a</tt>. These are requests sent from GHC to the server.
data Message a

-- | Exit the iserv process
[Shutdown] :: Message ()
[RtsRevertCAFs] :: Message ()
[InitLinker] :: Message ()
[LookupSymbol] :: String -> Message (Maybe (RemotePtr ()))
[LookupSymbolInDLL] :: RemotePtr LoadedDLL -> String -> Message (Maybe (RemotePtr ()))
[LookupClosure] :: String -> Message (Maybe HValueRef)
[LoadDLL] :: String -> Message (Either String (RemotePtr LoadedDLL))
[LoadArchive] :: String -> Message ()
[LoadObj] :: String -> Message ()
[UnloadObj] :: String -> Message ()
[AddLibrarySearchPath] :: String -> Message (RemotePtr ())
[RemoveLibrarySearchPath] :: RemotePtr () -> Message Bool
[ResolveObjs] :: Message Bool
[FindSystemLibrary] :: String -> Message (Maybe String)

-- | Create a set of BCO objects, and return HValueRefs to them See
--   <tt>createBCOs</tt> in compiler<i>GHC</i>Runtime/Interpreter.hs. NB:
--   this has a custom Binary behavior, see Note [Parallelize CreateBCOs
--   serialization]
[CreateBCOs] :: [ResolvedBCO] -> Message [HValueRef]

-- | Release <a>HValueRef</a>s
[FreeHValueRefs] :: [HValueRef] -> Message ()

-- | Add entries to the Static Pointer Table
[AddSptEntry] :: Fingerprint -> HValueRef -> Message ()

-- | Malloc some data and return a <a>RemotePtr</a> to it
[MallocData] :: ByteString -> Message (RemotePtr ())
[MallocStrings] :: [ByteString] -> Message [RemotePtr ()]

-- | Calls <a>prepareForeignCall</a>
[PrepFFI] :: [FFIType] -> FFIType -> Message (RemotePtr C_ffi_cif)

-- | Free data previously created by <a>PrepFFI</a>
[FreeFFI] :: RemotePtr C_ffi_cif -> Message ()

-- | Create an info table for a constructor
[MkConInfoTable] :: Bool -> Int -> Int -> Int -> Int -> ByteString -> Message (RemotePtr StgInfoTable)

-- | Evaluate a statement
[EvalStmt] :: EvalOpts -> EvalExpr HValueRef -> Message (EvalStatus_ [HValueRef] [HValueRef])

-- | Resume evaluation of a statement after a breakpoint
[ResumeStmt] :: EvalOpts -> RemoteRef (ResumeContext [HValueRef]) -> Message (EvalStatus_ [HValueRef] [HValueRef])

-- | Abandon evaluation of a statement after a breakpoint
[AbandonStmt] :: RemoteRef (ResumeContext [HValueRef]) -> Message ()

-- | Evaluate something of type <tt>IO String</tt>
[EvalString] :: HValueRef -> Message (EvalResult String)

-- | Evaluate something of type <tt>String -&gt; IO String</tt>
[EvalStringToString] :: HValueRef -> String -> Message (EvalResult String)

-- | Evaluate something of type <tt>IO ()</tt>
[EvalIO] :: HValueRef -> Message (EvalResult ())

-- | Create a set of CostCentres with the same module name
[MkCostCentres] :: String -> [(String, String)] -> Message [RemotePtr CostCentre]

-- | Show a <a>CostCentreStack</a> as a <tt>[String]</tt>
[CostCentreStackInfo] :: RemotePtr CostCentreStack -> Message [String]

-- | Create a new array of breakpoint flags
[NewBreakArray] :: Int -> Message (RemoteRef BreakArray)

-- | Set how many times a breakpoint should be ignored also used for
--   enable/disable
[SetupBreakpoint] :: RemoteRef BreakArray -> Int -> Int -> Message ()

-- | Query the status of a breakpoint (True <a>=</a> enabled)
[BreakpointStatus] :: RemoteRef BreakArray -> Int -> Message Bool

-- | Get a reference to a free variable at a breakpoint
[GetBreakpointVar] :: HValueRef -> Int -> Message (Maybe HValueRef)

-- | Start a new TH module, return a state token that should be
[StartTH] :: Message (RemoteRef (IORef QState))

-- | Evaluate a TH computation.
--   
--   Returns a ByteString, because we have to force the result before
--   returning it to ensure there are no errors lurking in it. The TH types
--   don't have NFData instances, and even if they did, we have to
--   serialize the value anyway, so we might as well serialize it to force
--   it.
[RunTH] :: RemoteRef (IORef QState) -> HValueRef -> THResultType -> Maybe Loc -> Message (QResult ByteString)

-- | Run the given mod finalizers.
[RunModFinalizers] :: RemoteRef (IORef QState) -> [RemoteRef (Q ())] -> Message (QResult ())

-- | Remote interface to GHC.Exts.Heap.getClosureData. This is used by the
--   GHCi debugger to inspect values in the heap for :print and type
--   reconstruction.
[GetClosure] :: HValueRef -> Message (GenClosure HValueRef)

-- | Evaluate something. This is used to support :force in GHCi.
[Seq] :: HValueRef -> Message (EvalStatus_ () ())

-- | Resume forcing a free variable in a breakpoint (#2950)
[ResumeSeq] :: RemoteRef (ResumeContext ()) -> Message (EvalStatus_ () ())

-- | Allocate a string for a breakpoint module name. This uses an empty
--   dummy type because <tt>ModuleName</tt> isn't available here.
[NewBreakModule] :: String -> Message (RemotePtr BreakModule)
data DelayedResponse (a :: k)
DelayedResponse :: DelayedResponse (a :: k)

-- | Send a message to the interpreter that expects a response (locks the
--   interpreter while until the response is received)
sendMessage :: Binary a => ExtInterpInstance d -> Message a -> IO a

-- | Send a message to the interpreter process that doesn't expect a
--   response (locks the interpreter while sending)
sendMessageNoResponse :: ExtInterpInstance d -> Message () -> IO ()

-- | Send a message to the interpreter process whose response is expected
--   later
--   
--   This is useful to avoid forgetting to receive the value and to ensure
--   that the type of the response isn't lost. Use receiveDelayedResponse
--   to read it. (locks the interpreter until the response is received
--   using <a>receiveDelayedResponse</a>)
sendMessageDelayedResponse :: ExtInterpInstance d -> Message a -> IO (DelayedResponse a)

-- | Expect a delayed result to be received now
receiveDelayedResponse :: Binary a => ExtInterpInstance d -> DelayedResponse a -> IO a

-- | Send any value (requires locked interpreter)
sendAnyValue :: Binary a => ExtInterpInstance d -> a -> IO ()

-- | Expect a value to be received (requires locked interpreter)
receiveAnyValue :: ExtInterpInstance d -> Get a -> IO a

-- | Wait for a Template Haskell message (requires locked interpreter)
receiveTHMessage :: ExtInterpInstance d -> IO THMsg

module GHC.Runtime.Context

-- | Interactive context, recording information about the state of the
--   context in which statements are executed in a GHCi session.
data InteractiveContext
InteractiveContext :: DynFlags -> Int -> [InteractiveImport] -> [TyThing] -> IcGlobalRdrEnv -> (InstEnv, [FamInst]) -> FixityEnv -> DefaultEnv -> [Resume] -> Name -> Name -> Maybe FilePath -> !Plugins -> InteractiveContext

-- | The <a>DynFlags</a> used to evaluate interactive expressions and
--   statements.
[ic_dflags] :: InteractiveContext -> DynFlags

-- | Each GHCi stmt or declaration brings some new things into scope. We
--   give them names like interactive:Ghci9.T, where the ic_index is the
--   '9'. The ic_mod_index is incremented whenever we add something to
--   ic_tythings See Note [The interactive package]
[ic_mod_index] :: InteractiveContext -> Int

-- | The GHCi top-level scope (icReaderEnv) is extended with these imports
--   
--   This field is only stored here so that the client can retrieve it with
--   GHC.getContext. GHC itself doesn't use it, but does reset it to empty
--   sometimes (such as before a GHC.load). The context is set with
--   GHC.setContext.
[ic_imports] :: InteractiveContext -> [InteractiveImport]

-- | TyThings defined by the user, in reverse order of definition (ie most
--   recent at the front). Also used in GHC.Tc.Module.runTcInteractive to
--   fill the type checker environment. See Note [ic_tythings]
[ic_tythings] :: InteractiveContext -> [TyThing]

-- | Essentially the cached <a>GlobalRdrEnv</a>.
--   
--   The GlobalRdrEnv contains everything in scope at the command line,
--   both imported and everything in ic_tythings, with the correct
--   shadowing.
--   
--   The IcGlobalRdrEnv contains extra data to allow efficient
--   recalculation when the set of imports change. See Note [icReaderEnv
--   recalculation]
[ic_gre_cache] :: InteractiveContext -> IcGlobalRdrEnv

-- | All instances and family instances created during this session. These
--   are grabbed en masse after each update to be sure that proper
--   overlapping is retained. That is, rather than re-check the overlapping
--   each time we update the context, we just take the results from the
--   instance code that already does that.
[ic_instances] :: InteractiveContext -> (InstEnv, [FamInst])

-- | Fixities declared in let statements
[ic_fix_env] :: InteractiveContext -> FixityEnv

-- | The current default classes and types, set by 'default' declarations
[ic_default] :: InteractiveContext -> DefaultEnv

-- | The stack of breakpoint contexts
[ic_resume] :: InteractiveContext -> [Resume]

-- | The monad that GHCi is executing in
[ic_monad] :: InteractiveContext -> Name

-- | The function that is used for printing results of expressions in ghci
--   and -e mode.
[ic_int_print] :: InteractiveContext -> Name

-- | virtual CWD of the program
[ic_cwd] :: InteractiveContext -> Maybe FilePath

-- | Cache of loaded plugins. We store them here to avoid having to load
--   them every time we switch to the interactive context.
[ic_plugins] :: InteractiveContext -> !Plugins
data InteractiveImport

-- | Bring the exports of a particular module (filtered by an import decl)
--   into scope
IIDecl :: ImportDecl GhcPs -> InteractiveImport

-- | Bring into scope the entire top-level envt of of this module,
--   including the things imported into it.
IIModule :: ModuleName -> InteractiveImport

-- | Constructs an empty InteractiveContext.
emptyInteractiveContext :: DynFlags -> InteractiveContext

-- | extendInteractiveContext is called with new TyThings recently defined
--   to update the InteractiveContext to include them. By putting new
--   things first, unqualified use will pick the most recently defined
--   thing with a given name, while still keeping the old names in scope in
--   their qualified form (Ghci1.foo).
extendInteractiveContext :: InteractiveContext -> [TyThing] -> InstEnv -> [FamInst] -> DefaultEnv -> FixityEnv -> InteractiveContext
extendInteractiveContextWithIds :: InteractiveContext -> [Id] -> InteractiveContext
setInteractivePrintName :: InteractiveContext -> Name -> InteractiveContext
substInteractiveContext :: InteractiveContext -> Subst -> InteractiveContext
replaceImportEnv :: IcGlobalRdrEnv -> GlobalRdrEnv -> IcGlobalRdrEnv
icReaderEnv :: InteractiveContext -> GlobalRdrEnv

-- | Add <tt>TyThings</tt> to the <a>GlobalRdrEnv</a>, earlier ones in the
--   list shadowing later ones, and shadowing existing entries in the
--   <a>GlobalRdrEnv</a>.
icExtendGblRdrEnv :: Bool -> GlobalRdrEnv -> [TyThing] -> GlobalRdrEnv
icInteractiveModule :: InteractiveContext -> Module

-- | This function returns the list of visible TyThings (useful for e.g.
--   showBindings).
--   
--   It picks only those TyThings that are not shadowed by later
--   definitions on the interpreter, to not clutter :showBindings with
--   shadowed ids, which would show up as Ghci9.foo.
--   
--   Some TyThings define many names; we include them if _any_ name is
--   still available unqualified.
icInScopeTTs :: InteractiveContext -> [TyThing]

-- | Get the NamePprCtx function based on the flags and this
--   InteractiveContext
icNamePprCtx :: UnitEnv -> InteractiveContext -> NamePprCtx
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Context.InteractiveImport

module GHC.Core.Lint.Interactive
interactiveInScope :: InteractiveContext -> [Var]


-- | Linking Haskell units
module GHC.Linker.Unit

-- | Linker flags collected from units
data UnitLinkOpts
UnitLinkOpts :: [String] -> [String] -> [String] -> UnitLinkOpts

-- | Haskell libraries (as a list of "-lHSfoo...")
[hsLibs] :: UnitLinkOpts -> [String]

-- | External libraries (as a list of "-lfoo...")
[extraLibs] :: UnitLinkOpts -> [String]

-- | Extra linker options
[otherFlags] :: UnitLinkOpts -> [String]
collectLinkOpts :: GhcNameVersion -> Ways -> [UnitInfo] -> UnitLinkOpts
collectArchives :: GhcNameVersion -> Ways -> UnitInfo -> IO [FilePath]

-- | Find all the link options in these and the preload packages, returning
--   (package hs lib options, extra library options, other flags)
getUnitLinkOpts :: GhcNameVersion -> Ways -> UnitEnv -> [UnitId] -> IO UnitLinkOpts
getLibs :: GhcNameVersion -> Ways -> UnitEnv -> [UnitId] -> IO [(String, String)]
instance GHC.Internal.Show.Show GHC.Linker.Unit.UnitLinkOpts

module GHC.Driver.Env.Types

-- | The Hsc monad: Passing an environment and diagnostic state
newtype Hsc a
Hsc :: (HscEnv -> Messages GhcMessage -> IO (a, Messages GhcMessage)) -> Hsc a

-- | HscEnv is like <a>Session</a>, except that some of the fields are
--   immutable. An HscEnv is used to compile a single module from plain
--   Haskell source code (after preprocessing) to either C, assembly or
--   C--. It's also used to store the dynamic linker state to allow for
--   multiple linkers in the same address space. Things like the module
--   graph don't change during a single compilation.
--   
--   Historical note: "hsc" used to be the name of the compiler binary,
--   when there was a separate driver and compiler. To compile a single
--   module, the driver would invoke hsc on the source code... so nowadays
--   we think of hsc as the layer of the compiler that deals with compiling
--   a single module.
data HscEnv
HscEnv :: DynFlags -> [Target] -> ModuleGraph -> InteractiveContext -> {-# UNPACK #-} !NameCache -> {-# UNPACK #-} !FinderCache -> KnotVars (IORef TypeEnv) -> Maybe Interp -> !Plugins -> UnitEnv -> !Logger -> !Hooks -> !TmpFs -> !LlvmConfigCache -> HscEnv

-- | The dynamic flag settings
[hsc_dflags] :: HscEnv -> DynFlags

-- | The targets (or roots) of the current session
[hsc_targets] :: HscEnv -> [Target]

-- | The module graph of the current session
[hsc_mod_graph] :: HscEnv -> ModuleGraph

-- | The context for evaluating interactive statements
[hsc_IC] :: HscEnv -> InteractiveContext

-- | Global Name cache so that each Name gets a single Unique. Also track
--   the origin of the Names.
[hsc_NC] :: HscEnv -> {-# UNPACK #-} !NameCache

-- | The cached result of performing finding in the file system
[hsc_FC] :: HscEnv -> {-# UNPACK #-} !FinderCache

-- | Used for one-shot compilation only, to initialise the
--   <tt>IfGblEnv</tt>. See <a>tcg_type_env_var</a> for <a>TcGblEnv</a>.
--   See also Note [hsc_type_env_var hack]
[hsc_type_env_vars] :: HscEnv -> KnotVars (IORef TypeEnv)

-- | target code interpreter (if any) to use for TH and GHCi. See Note
--   [Target code interpreter]
[hsc_interp] :: HscEnv -> Maybe Interp

-- | Plugins
[hsc_plugins] :: HscEnv -> !Plugins

-- | Unit environment (unit state, home unit, etc.).
--   
--   Initialized from the databases cached in <tt>hsc_unit_dbs</tt> and
--   from the DynFlags.
[hsc_unit_env] :: HscEnv -> UnitEnv

-- | Logger with its flags.
--   
--   Don't forget to update the logger flags if the logging related
--   DynFlags change. Or better, use hscSetFlags setter which does it.
[hsc_logger] :: HscEnv -> !Logger

-- | Hooks
[hsc_hooks] :: HscEnv -> !Hooks

-- | Temporary files
[hsc_tmpfs] :: HscEnv -> !TmpFs

-- | LLVM configuration cache.
[hsc_llvm_config] :: HscEnv -> !LlvmConfigCache
instance GHC.Internal.Base.Applicative GHC.Driver.Env.Types.Hsc
instance GHC.Driver.DynFlags.ContainsDynFlags GHC.Driver.Env.Types.HscEnv
instance GHC.Internal.Base.Functor GHC.Driver.Env.Types.Hsc
instance GHC.Driver.DynFlags.HasDynFlags GHC.Driver.Env.Types.Hsc
instance GHC.Utils.Logger.HasLogger GHC.Driver.Env.Types.Hsc
instance GHC.Internal.Base.Monad GHC.Driver.Env.Types.Hsc
instance GHC.Internal.Control.Monad.IO.Class.MonadIO GHC.Driver.Env.Types.Hsc

module GHC.Driver.Env

-- | The Hsc monad: Passing an environment and diagnostic state
newtype Hsc a
Hsc :: (HscEnv -> Messages GhcMessage -> IO (a, Messages GhcMessage)) -> Hsc a

-- | HscEnv is like <a>Session</a>, except that some of the fields are
--   immutable. An HscEnv is used to compile a single module from plain
--   Haskell source code (after preprocessing) to either C, assembly or
--   C--. It's also used to store the dynamic linker state to allow for
--   multiple linkers in the same address space. Things like the module
--   graph don't change during a single compilation.
--   
--   Historical note: "hsc" used to be the name of the compiler binary,
--   when there was a separate driver and compiler. To compile a single
--   module, the driver would invoke hsc on the source code... so nowadays
--   we think of hsc as the layer of the compiler that deals with compiling
--   a single module.
data HscEnv
HscEnv :: DynFlags -> [Target] -> ModuleGraph -> InteractiveContext -> {-# UNPACK #-} !NameCache -> {-# UNPACK #-} !FinderCache -> KnotVars (IORef TypeEnv) -> Maybe Interp -> !Plugins -> UnitEnv -> !Logger -> !Hooks -> !TmpFs -> !LlvmConfigCache -> HscEnv

-- | The dynamic flag settings
[hsc_dflags] :: HscEnv -> DynFlags

-- | The targets (or roots) of the current session
[hsc_targets] :: HscEnv -> [Target]

-- | The module graph of the current session
[hsc_mod_graph] :: HscEnv -> ModuleGraph

-- | The context for evaluating interactive statements
[hsc_IC] :: HscEnv -> InteractiveContext

-- | Global Name cache so that each Name gets a single Unique. Also track
--   the origin of the Names.
[hsc_NC] :: HscEnv -> {-# UNPACK #-} !NameCache

-- | The cached result of performing finding in the file system
[hsc_FC] :: HscEnv -> {-# UNPACK #-} !FinderCache

-- | Used for one-shot compilation only, to initialise the
--   <tt>IfGblEnv</tt>. See <a>tcg_type_env_var</a> for <a>TcGblEnv</a>.
--   See also Note [hsc_type_env_var hack]
[hsc_type_env_vars] :: HscEnv -> KnotVars (IORef TypeEnv)

-- | target code interpreter (if any) to use for TH and GHCi. See Note
--   [Target code interpreter]
[hsc_interp] :: HscEnv -> Maybe Interp

-- | Plugins
[hsc_plugins] :: HscEnv -> !Plugins

-- | Unit environment (unit state, home unit, etc.).
--   
--   Initialized from the databases cached in <tt>hsc_unit_dbs</tt> and
--   from the DynFlags.
[hsc_unit_env] :: HscEnv -> UnitEnv

-- | Logger with its flags.
--   
--   Don't forget to update the logger flags if the logging related
--   DynFlags change. Or better, use hscSetFlags setter which does it.
[hsc_logger] :: HscEnv -> !Logger

-- | Hooks
[hsc_hooks] :: HscEnv -> !Hooks

-- | Temporary files
[hsc_tmpfs] :: HscEnv -> !TmpFs

-- | LLVM configuration cache.
[hsc_llvm_config] :: HscEnv -> !LlvmConfigCache

-- | Update Flags
hscUpdateFlags :: (DynFlags -> DynFlags) -> HscEnv -> HscEnv

-- | Set Flags
hscSetFlags :: HasDebugCallStack => DynFlags -> HscEnv -> HscEnv
hsc_home_unit :: HscEnv -> HomeUnit
hsc_home_unit_maybe :: HscEnv -> Maybe HomeUnit
hsc_units :: HasDebugCallStack => HscEnv -> UnitState
hsc_HPT :: HscEnv -> HomePackageTable
hsc_HUE :: HscEnv -> HomeUnitEnv
hsc_HUG :: HscEnv -> HomeUnitGraph
hsc_all_home_unit_ids :: HscEnv -> Set UnitId

-- | Update the LogFlags of the Log in hsc_logger from the DynFlags in
--   hsc_dflags. You need to call this when DynFlags are modified.
hscUpdateLoggerFlags :: HscEnv -> HscEnv
hscUpdateHUG :: (HomeUnitGraph -> HomeUnitGraph) -> HscEnv -> HscEnv
hscUpdateHPT_lazy :: (HomePackageTable -> HomePackageTable) -> HscEnv -> HscEnv
hscUpdateHPT :: (HomePackageTable -> HomePackageTable) -> HscEnv -> HscEnv
hscSetActiveHomeUnit :: HasDebugCallStack => HomeUnit -> HscEnv -> HscEnv
hscSetActiveUnitId :: HasDebugCallStack => UnitId -> HscEnv -> HscEnv
hscActiveUnitId :: HscEnv -> UnitId
runHsc :: HscEnv -> Hsc a -> IO a
runHsc' :: HscEnv -> Hsc a -> IO (a, Messages GhcMessage)

-- | Switches in the DynFlags and Plugins from the InteractiveContext
mkInteractiveHscEnv :: HscEnv -> HscEnv

-- | A variant of runHsc that switches in the DynFlags and Plugins from the
--   InteractiveContext before running the Hsc computation.
runInteractiveHsc :: HscEnv -> Hsc a -> IO a

-- | Retrieve the ExternalPackageState cache.
hscEPS :: HscEnv -> IO ExternalPackageState

-- | Retrieve the target code interpreter
--   
--   Fails if no target code interpreter is available
hscInterp :: HscEnv -> Interp
hptCompleteSigs :: HscEnv -> CompleteMatches

-- | Find all the instance declarations (of classes and families) from the
--   Home Package Table filtered by the provided predicate function. Used
--   in <tt>tcRnImports</tt>, to select the instances that are in the
--   transitive closure of imports from the currently compiled module.
hptAllInstances :: HscEnv -> (InstEnv, [FamInst])

-- | Find instances visible from the given set of imports
hptInstancesBelow :: HscEnv -> UnitId -> ModuleNameWithIsBoot -> (InstEnv, [FamInst])

-- | Get annotations from modules "below" this one (in the dependency
--   sense)
hptAnns :: HscEnv -> Maybe (UnitId, ModuleNameWithIsBoot) -> [Annotation]
hptAllThings :: (HomeModInfo -> [a]) -> HscEnv -> [a]

-- | Get things from modules "below" this one (in the dependency sense) C.f
--   Inst.hptInstances
hptSomeThingsBelowUs :: (HomeModInfo -> [a]) -> Bool -> HscEnv -> UnitId -> ModuleNameWithIsBoot -> [a]

-- | Get rules from modules "below" this one (in the dependency sense)
hptRules :: HscEnv -> UnitId -> ModuleNameWithIsBoot -> [CoreRule]

-- | Deal with gathering annotations in from all possible places and
--   combining them into a single <a>AnnEnv</a>
prepareAnnotations :: HscEnv -> Maybe ModGuts -> IO AnnEnv

-- | Discard the contents of the InteractiveContext, but keep the DynFlags
--   and the loaded plugins. It will also keep ic_int_print and ic_monad if
--   their names are from external packages.
discardIC :: HscEnv -> HscEnv

-- | Find the <a>TyThing</a> for the given <a>Name</a> by using all the
--   resources at our disposal: the compiled modules in the
--   <a>HomePackageTable</a> and the compiled modules in other packages
--   that live in <a>PackageTypeEnv</a>. Note that this does NOT look up
--   the <a>TyThing</a> in the module being compiled: you have to do that
--   yourself, if desired
lookupType :: HscEnv -> Name -> IO (Maybe TyThing)

-- | Find the <a>ModIface</a> for a <a>Module</a>, searching in both the
--   loaded home and external package module information
lookupIfaceByModule :: HomeUnitGraph -> PackageIfaceTable -> Module -> Maybe ModIface
mainModIs :: HomeUnitEnv -> Module


-- | Module finder
module GHC.Unit.Finder

-- | The result of searching for an imported module.
--   
--   NB: FindResult manages both user source-import lookups (which can
--   result in <a>Module</a>) as well as direct imports for interfaces
--   (which always result in <a>InstalledModule</a>).
data FindResult

-- | The module was found
Found :: ModLocation -> Module -> FindResult

-- | The requested unit was not found
NoPackage :: Unit -> FindResult

-- | _Error_: both in multiple packages
FoundMultiple :: [(Module, ModuleOrigin)] -> FindResult

-- | Not found
NotFound :: [FilePath] -> Maybe Unit -> [Unit] -> [Unit] -> [UnusableUnit] -> [ModuleSuggestion] -> FindResult

-- | Places where I looked
[fr_paths] :: FindResult -> [FilePath]

-- | Just p =&gt; module is in this unit's manifest, but couldn't find the
--   .hi file
[fr_pkg] :: FindResult -> Maybe Unit

-- | Module is in these units, but the *module* is hidden
[fr_mods_hidden] :: FindResult -> [Unit]

-- | Module is in these units, but the *unit* is hidden
[fr_pkgs_hidden] :: FindResult -> [Unit]

-- | Module is in these units, but it is unusable
[fr_unusables] :: FindResult -> [UnusableUnit]

-- | Possible mis-spelled modules
[fr_suggestions] :: FindResult -> [ModuleSuggestion]
data InstalledFindResult
InstalledFound :: ModLocation -> InstalledModule -> InstalledFindResult
InstalledNoPackage :: UnitId -> InstalledFindResult
InstalledNotFound :: [OsPath] -> Maybe UnitId -> InstalledFindResult

-- | Locations and information the finder cares about.
--   
--   Should be taken from <tt>DynFlags</tt> via <tt>initFinderOpts</tt>.
data FinderOpts
FinderOpts :: [OsPath] -> Bool -> Bool -> Ways -> Bool -> Maybe OsPath -> Maybe FastString -> Set ModuleName -> Map ModuleName ModuleName -> Maybe OsPath -> OsString -> Maybe OsPath -> OsString -> OsString -> Maybe OsPath -> OsString -> OsString -> Maybe OsPath -> FinderOpts

-- | Where are we allowed to look for Modules and Source files
[finder_importPaths] :: FinderOpts -> [OsPath]

-- | When looking up a home module:
--   
--   <ul>
--   <li><a>True</a>: search interface files (e.g. in '-c' mode)</li>
--   <li><a>False</a>: search source files (e.g. in '--make' mode)</li>
--   </ul>
[finder_lookupHomeInterfaces] :: FinderOpts -> Bool

-- | Don't check that an imported interface file actually exists if it can
--   only be at one location. The interface will be reported as
--   <a>InstalledFound</a> even if the file doesn't exist, so this is only
--   useful in specific cases (e.g. to generate dependencies with `ghc -M`)
[finder_bypassHiFileCheck] :: FinderOpts -> Bool
[finder_ways] :: FinderOpts -> Ways

-- | If we encounter unknown modules, should we suggest modules that have a
--   similar name.
[finder_enableSuggestions] :: FinderOpts -> Bool
[finder_workingDirectory] :: FinderOpts -> Maybe OsPath
[finder_thisPackageName] :: FinderOpts -> Maybe FastString
[finder_hiddenModules] :: FinderOpts -> Set ModuleName
[finder_reexportedModules] :: FinderOpts -> Map ModuleName ModuleName
[finder_hieDir] :: FinderOpts -> Maybe OsPath
[finder_hieSuf] :: FinderOpts -> OsString
[finder_hiDir] :: FinderOpts -> Maybe OsPath
[finder_hiSuf] :: FinderOpts -> OsString
[finder_dynHiSuf] :: FinderOpts -> OsString
[finder_objectDir] :: FinderOpts -> Maybe OsPath
[finder_objectSuf] :: FinderOpts -> OsString
[finder_dynObjectSuf] :: FinderOpts -> OsString
[finder_stubDir] :: FinderOpts -> Maybe OsPath
data FinderCache
FinderCache :: (UnitEnv -> IO ()) -> (InstalledModuleWithIsBoot -> InstalledFindResult -> IO ()) -> (InstalledModuleWithIsBoot -> IO (Maybe InstalledFindResult)) -> (FilePath -> IO Fingerprint) -> FinderCache

-- | remove all the home modules from the cache; package modules are
--   assumed to not move around during a session; also flush the file hash
--   cache.
[flushFinderCaches] :: FinderCache -> UnitEnv -> IO ()

-- | Add a found location to the cache for the module.
[addToFinderCache] :: FinderCache -> InstalledModuleWithIsBoot -> InstalledFindResult -> IO ()

-- | Look for a location in the cache.
[lookupFinderCache] :: FinderCache -> InstalledModuleWithIsBoot -> IO (Maybe InstalledFindResult)

-- | Look for the hash of a file in the cache. This should add it to the
--   cache. If the file doesn't exist, raise an IOException.
[lookupFileCache] :: FinderCache -> FilePath -> IO Fingerprint
initFinderCache :: IO FinderCache

-- | Locate a module that was imported by the user. We have the module's
--   name, and possibly a package name. Without a package name, this
--   function will use the search path and the known exposed packages to
--   find the module, if a package is specified then only that package is
--   searched for the module.
findImportedModule :: HscEnv -> ModuleName -> PkgQual -> IO FindResult

-- | Locate a plugin module requested by the user, for a compiler plugin.
--   This consults the same set of exposed packages as
--   <a>findImportedModule</a>, unless <tt>-hide-all-plugin-packages</tt>
--   or <tt>-plugin-package</tt> are specified.
findPluginModule :: FinderCache -> FinderOpts -> UnitState -> Maybe HomeUnit -> ModuleName -> IO FindResult

-- | Locate a specific <a>Module</a>. The purpose of this function is to
--   create a <a>ModLocation</a> for a given <a>Module</a>, that is to find
--   out where the files associated with this module live. It is used when
--   reading the interface for a module mentioned by another interface, for
--   example (a "system import").
findExactModule :: FinderCache -> FinderOpts -> UnitEnvGraph FinderOpts -> UnitState -> Maybe HomeUnit -> InstalledModule -> IO InstalledFindResult
findHomeModule :: FinderCache -> FinderOpts -> HomeUnit -> ModuleName -> IO FindResult
findExposedPackageModule :: FinderCache -> FinderOpts -> UnitState -> ModuleName -> PkgQual -> IO FindResult
mkHomeModLocation :: FinderOpts -> ModuleName -> OsPath -> ModLocation
mkHomeModLocation2 :: FinderOpts -> ModuleName -> OsPath -> FileExt -> ModLocation
mkHiOnlyModLocation :: FinderOpts -> FileExt -> FileExt -> OsPath -> OsPath -> ModLocation

-- | Constructs the filename of a .hi file for a given source file. Does
--   <i>not</i> check whether the .hi file exists
mkHiPath :: FinderOpts -> OsPath -> OsPath -> OsPath

-- | Constructs the filename of a .o file for a given source file. Does
--   <i>not</i> check whether the .o file exists
mkObjPath :: FinderOpts -> OsPath -> OsPath -> OsPath
addModuleToFinder :: FinderCache -> ModuleWithIsBoot -> ModLocation -> IO ()
addHomeModuleToFinder :: FinderCache -> HomeUnit -> ModuleNameWithIsBoot -> ModLocation -> IO Module

-- | Compute the file name of a header file for foreign stubs, using either
--   the directory explicitly specified in the command line option
--   <tt>-stubdir</tt>, or the directory of the module's source file.
--   
--   When compiling bytecode from interface Core bindings,
--   <tt>ModLocation</tt> does not contain a source file path, so the
--   header isn't written. This doesn't have an impact, since we cannot
--   support headers importing Haskell symbols defined in bytecode for TH
--   whatsoever at the moment.
mkStubPaths :: FinderOpts -> ModuleName -> ModLocation -> Maybe OsPath
findObjectLinkableMaybe :: Module -> ModLocation -> IO (Maybe Linkable)
findObjectLinkable :: Module -> FilePath -> UTCTime -> IO Linkable

module GHC.Iface.Errors
badIfaceFile :: String -> SDoc -> SDoc
cannotFindInterface :: UnitState -> Maybe HomeUnit -> Profile -> ModuleName -> InstalledFindResult -> MissingInterfaceError
cantFindInstalledErr :: UnitState -> Maybe HomeUnit -> Profile -> ModuleName -> InstalledFindResult -> CantFindInstalled
cannotFindModule :: HscEnv -> ModuleName -> FindResult -> MissingInterfaceError

module GHC.Driver.Monad

-- | A monad that has all the features needed by GHC API calls.
--   
--   In short, a GHC monad
--   
--   <ul>
--   <li>allows embedding of IO actions,</li>
--   <li>can log warnings,</li>
--   <li>allows handling of (extensible) exceptions, and</li>
--   <li>maintains a current session.</li>
--   </ul>
--   
--   If you do not use <a>Ghc</a> or <a>GhcT</a>, make sure to call
--   <a>initGhcMonad</a> before any call to the GHC API functions can
--   occur.
class (Functor m, ExceptionMonad m, HasDynFlags m, HasLogger m) => GhcMonad (m :: Type -> Type)
getSession :: GhcMonad m => m HscEnv
setSession :: GhcMonad m => HscEnv -> m ()

-- | A minimal implementation of a <a>GhcMonad</a>. If you need a custom
--   monad, e.g., to maintain additional state consider wrapping this monad
--   or using <a>GhcT</a>.
newtype Ghc a
Ghc :: (Session -> IO a) -> Ghc a
[unGhc] :: Ghc a -> Session -> IO a

-- | A monad transformer to add GHC specific features to another monad.
--   
--   Note that the wrapped monad must support IO and handling of
--   exceptions.
newtype GhcT (m :: Type -> Type) a
GhcT :: (Session -> m a) -> GhcT (m :: Type -> Type) a
[unGhcT] :: GhcT (m :: Type -> Type) a -> Session -> m a
liftGhcT :: m a -> GhcT m a

-- | Reflect a computation in the <a>Ghc</a> monad into the <a>IO</a>
--   monad.
--   
--   You can use this to call functions returning an action in the
--   <a>Ghc</a> monad inside an <a>IO</a> action. This is needed for some
--   (too restrictive) callback arguments of some library functions:
--   
--   <pre>
--   libFunc :: String -&gt; (Int -&gt; IO a) -&gt; IO a
--   ghcFunc :: Int -&gt; Ghc a
--   
--   ghcFuncUsingLibFunc :: String -&gt; Ghc a -&gt; Ghc a
--   ghcFuncUsingLibFunc str =
--     reifyGhc $ \s -&gt;
--       libFunc $ \i -&gt; do
--         reflectGhc (ghcFunc i) s
--   </pre>
reflectGhc :: Ghc a -> Session -> IO a
reifyGhc :: (Session -> IO a) -> Ghc a

-- | Grabs the DynFlags from the Session
getSessionDynFlags :: GhcMonad m => m DynFlags
liftIO :: MonadIO m => IO a -> m a

-- | The Session is a handle to the complete state of a compilation
--   session. A compilation session consists of a set of modules
--   constituting the current program or library, the context for
--   interactive evaluation, and various caches.
data Session
Session :: !IORef HscEnv -> Session

-- | Call the argument with the current session.
withSession :: GhcMonad m => (HscEnv -> m a) -> m a

-- | Set the current session to the result of applying the current session
--   to the argument.
modifySession :: GhcMonad m => (HscEnv -> HscEnv) -> m ()

-- | Set the current session to the result of applying the current session
--   to the argument.
modifySessionM :: GhcMonad m => (HscEnv -> m HscEnv) -> m ()

-- | Call an action with a temporarily modified Session.
withTempSession :: GhcMonad m => (HscEnv -> HscEnv) -> m a -> m a

-- | Modify the logger
modifyLogger :: GhcMonad m => (Logger -> Logger) -> m ()

-- | Push a log hook on the stack
pushLogHookM :: GhcMonad m => (LogAction -> LogAction) -> m ()

-- | Pop a log hook from the stack
popLogHookM :: GhcMonad m => m ()
pushJsonLogHookM :: GhcMonad m => (LogJsonAction -> LogJsonAction) -> m ()
popJsonLogHookM :: GhcMonad m => m ()

-- | Put a log message
putLogMsgM :: GhcMonad m => MessageClass -> SrcSpan -> SDoc -> m ()

-- | Put a log message
putMsgM :: GhcMonad m => SDoc -> m ()

-- | Time an action
withTimingM :: GhcMonad m => SDoc -> (b -> ()) -> m b -> m b

-- | A monad that allows logging of diagnostics.
logDiagnostics :: GhcMonad m => Messages GhcMessage -> m ()

-- | Print the all diagnostics in a <a>SourceError</a>. Useful inside
--   exception handlers.
printException :: (HasLogger m, MonadIO m, HasDynFlags m) => SourceError -> m ()

-- | A function called to log warnings and errors.
type WarnErrLogger = forall (m :: Type -> Type). (HasDynFlags m, MonadIO m, HasLogger m) => Maybe SourceError -> m ()
defaultWarnErrLogger :: WarnErrLogger
instance GHC.Internal.Base.Applicative GHC.Driver.Monad.Ghc
instance GHC.Internal.Base.Applicative m => GHC.Internal.Base.Applicative (GHC.Driver.Monad.GhcT m)
instance GHC.Internal.Base.Functor GHC.Driver.Monad.Ghc
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (GHC.Driver.Monad.GhcT m)
instance GHC.Driver.Monad.GhcMonad GHC.Driver.Monad.Ghc
instance GHC.Utils.Exception.ExceptionMonad m => GHC.Driver.Monad.GhcMonad (GHC.Driver.Monad.GhcT m)
instance GHC.Driver.DynFlags.HasDynFlags GHC.Driver.Monad.Ghc
instance GHC.Internal.Control.Monad.IO.Class.MonadIO m => GHC.Driver.DynFlags.HasDynFlags (GHC.Driver.Monad.GhcT m)
instance GHC.Utils.Logger.HasLogger GHC.Driver.Monad.Ghc
instance GHC.Internal.Control.Monad.IO.Class.MonadIO m => GHC.Utils.Logger.HasLogger (GHC.Driver.Monad.GhcT m)
instance Control.Monad.Catch.MonadCatch GHC.Driver.Monad.Ghc
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (GHC.Driver.Monad.GhcT m)
instance GHC.Internal.Control.Monad.Fail.MonadFail GHC.Driver.Monad.Ghc
instance GHC.Internal.Control.Monad.Fail.MonadFail m => GHC.Internal.Control.Monad.Fail.MonadFail (GHC.Driver.Monad.GhcT m)
instance GHC.Internal.Control.Monad.Fix.MonadFix GHC.Driver.Monad.Ghc
instance GHC.Internal.Control.Monad.Fix.MonadFix m => GHC.Internal.Control.Monad.Fix.MonadFix (GHC.Driver.Monad.GhcT m)
instance GHC.Internal.Base.Monad GHC.Driver.Monad.Ghc
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (GHC.Driver.Monad.GhcT m)
instance GHC.Internal.Control.Monad.IO.Class.MonadIO GHC.Driver.Monad.Ghc
instance GHC.Internal.Control.Monad.IO.Class.MonadIO m => GHC.Internal.Control.Monad.IO.Class.MonadIO (GHC.Driver.Monad.GhcT m)
instance Control.Monad.Catch.MonadMask GHC.Driver.Monad.Ghc
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (GHC.Driver.Monad.GhcT m)
instance Control.Monad.Catch.MonadThrow GHC.Driver.Monad.Ghc
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (GHC.Driver.Monad.GhcT m)

module GHC.Core.Opt.Monad
data FloatOutSwitches
FloatOutSwitches :: Maybe Int -> Bool -> Bool -> Bool -> Bool -> FloatOutSwitches

-- | Just n <a>=</a> float lambdas to top level, if doing so will abstract
--   over n or fewer value variables Nothing <a>=</a> float all lambdas to
--   top level, regardless of how many free variables Just 0 is the vanilla
--   case: float a lambda iff it has no free vars
[floatOutLambdas] :: FloatOutSwitches -> Maybe Int

-- | True <a>=</a> float constants to top level, even if they do not escape
--   a lambda
[floatOutConstants] :: FloatOutSwitches -> Bool

-- | True <a>=</a> float out over-saturated applications based on arity
--   information. See Note [Floating over-saturated applications] in
--   GHC.Core.Opt.SetLevels
[floatOutOverSatApps] :: FloatOutSwitches -> Bool

-- | Allow floating to the top level only.
[floatToTopLevelOnly] :: FloatOutSwitches -> Bool

-- | Float join points to top level if possible See Note [Floating join
--   point bindings] in GHC.Core.Opt.SetLevels
[floatJoinsToTop] :: FloatOutSwitches -> Bool

-- | The monad used by Core-to-Core passes to register simplification
--   statistics. Also used to have common state (in the form of
--   UniqueSupply) for generating Uniques.
data CoreM a
runCoreM :: HscEnv -> RuleBase -> Char -> Module -> NamePprCtx -> SrcSpan -> CoreM a -> IO (a, SimplCount)

-- | Adjust the dyn flags passed to the argument action
mapDynFlagsCoreM :: (DynFlags -> DynFlags) -> CoreM a -> CoreM a

-- | Drop the single count of the argument action so it doesn't effect the
--   total.
dropSimplCount :: CoreM a -> CoreM a
getHscEnv :: CoreM HscEnv
getModule :: HasModule m => m Module
initRuleEnv :: ModGuts -> CoreM RuleEnv
getExternalRuleBase :: CoreM RuleBase
getDynFlags :: HasDynFlags m => m DynFlags
getPackageFamInstEnv :: CoreM PackageFamInstEnv
getInteractiveContext :: CoreM InteractiveContext
getUniqTag :: CoreM Char
getNamePprCtx :: CoreM NamePprCtx
getSrcSpanM :: CoreM SrcSpan
addSimplCount :: SimplCount -> CoreM ()
liftIO :: MonadIO m => IO a -> m a

-- | Lift an <a>IO</a> operation into <a>CoreM</a> while consuming its
--   <a>SimplCount</a>
liftIOWithCount :: IO (SimplCount, a) -> CoreM a

-- | Get all annotations of a given type. This happens lazily, that is no
--   deserialization will take place until the [a] is actually demanded and
--   the [a] can also be empty (the UniqFM is not filtered).
--   
--   This should be done once at the start of a Core-to-Core pass that uses
--   annotations.
--   
--   See Note [Annotations]
getAnnotations :: Typeable a => ([Word8] -> a) -> ModGuts -> CoreM (ModuleEnv [a], NameEnv [a])

-- | Get at most one annotation of a given type per annotatable item.
getFirstAnnotations :: Typeable a => ([Word8] -> a) -> ModGuts -> CoreM (ModuleEnv a, NameEnv a)

-- | Output a message to the screen
putMsg :: SDoc -> CoreM ()

-- | Output a String message to the screen
putMsgS :: String -> CoreM ()

-- | Output an error to the screen. Does not cause the compiler to die.
errorMsg :: SDoc -> CoreM ()
msg :: MessageClass -> SDoc -> CoreM ()

-- | Output a fatal error to the screen. Does not cause the compiler to
--   die.
fatalErrorMsg :: SDoc -> CoreM ()

-- | Output a fatal error to the screen. Does not cause the compiler to
--   die.
fatalErrorMsgS :: String -> CoreM ()

-- | Outputs a debugging message at verbosity level of <tt>-v</tt> or
--   higher
debugTraceMsg :: SDoc -> CoreM ()

-- | Output a string debugging message at verbosity level of <tt>-v</tt> or
--   higher
debugTraceMsgS :: String -> CoreM ()
instance GHC.Internal.Base.Alternative GHC.Core.Opt.Monad.CoreM
instance GHC.Internal.Base.Applicative GHC.Core.Opt.Monad.CoreM
instance GHC.Internal.Base.Functor GHC.Core.Opt.Monad.CoreM
instance GHC.Driver.DynFlags.HasDynFlags GHC.Core.Opt.Monad.CoreM
instance GHC.Utils.Logger.HasLogger GHC.Core.Opt.Monad.CoreM
instance GHC.Unit.Module.HasModule GHC.Core.Opt.Monad.CoreM
instance GHC.Internal.Base.Monad GHC.Core.Opt.Monad.CoreM
instance GHC.Internal.Control.Monad.IO.Class.MonadIO GHC.Core.Opt.Monad.CoreM
instance GHC.Internal.Base.MonadPlus GHC.Core.Opt.Monad.CoreM
instance GHC.Types.Unique.Supply.MonadUnique GHC.Core.Opt.Monad.CoreM
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Monad.FloatOutSwitches

module GHC.Core.Opt.Specialise

-- | Specialise calls to type-class overloaded functions occurring in a
--   program.
specProgram :: ModGuts -> CoreM ModGuts
specUnfolding :: SimpleOpts -> [Var] -> (CoreExpr -> CoreExpr) -> [CoreArg] -> Unfolding -> Unfolding
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Specialise.CallInfo
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Specialise.CallInfoSet
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Specialise.DictBind
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Specialise.FloatedDictBinds
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Specialise.SpecArg
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Specialise.SpecEnv
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Specialise.UsageDetails

module GHC.Core.Opt.SpecConstr
specConstrProgram :: ModGuts -> CoreM ModGuts
data SpecConstrAnnotation
NoSpecConstr :: SpecConstrAnnotation
ForceSpecConstr :: SpecConstrAnnotation
newtype SpecFailWarning
SpecFailForcedArgCount :: Name -> SpecFailWarning
[spec_failed_fun_name] :: SpecFailWarning -> Name
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SpecConstr.ArgOcc
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SpecConstr.Call
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SpecConstr.CallPat
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SpecConstr.HowBound
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SpecConstr.ScUsage
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SpecConstr.SpecFailWarning
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SpecConstr.Value

module GHC.Core.Opt.SetLevels
setLevels :: FloatOutSwitches -> CoreProgram -> UniqSupply -> [LevelledBind]
data Level
Level :: Int -> Int -> Level
tOP_LEVEL :: Level
type LevelledBind = TaggedBind FloatSpec
type LevelledExpr = TaggedExpr FloatSpec
type LevelledBndr = TaggedBndr FloatSpec
data FloatSpec
FloatMe :: Level -> FloatSpec
StayPut :: Level -> FloatSpec
floatSpecLevel :: FloatSpec -> Level
incMinorLvl :: Level -> Level
ltMajLvl :: Level -> Level -> Bool
ltLvl :: Level -> Level -> Bool
isTopLvl :: Level -> Bool
instance GHC.Classes.Eq GHC.Core.Opt.SetLevels.Level
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SetLevels.FloatSpec
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SetLevels.Level

module GHC.Core.Opt.FloatOut
floatOutwards :: Logger -> FloatOutSwitches -> UniqSupply -> CoreProgram -> IO CoreProgram
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.FloatOut.FloatBinds


-- | Adds cost-centers to call sites selected with the
--   <tt>-fprof-caller=...</tt> flag.
module GHC.Core.Opt.CallerCC
addCallerCostCentres :: ModGuts -> CoreM ModGuts
data CallerCcFilter
CallerCcFilter :: Maybe ModuleName -> NamePattern -> CallerCcFilter
[ccfModuleName] :: CallerCcFilter -> Maybe ModuleName
[ccfFuncName] :: CallerCcFilter -> NamePattern
data NamePattern
PChar :: Char -> NamePattern -> NamePattern
PWildcard :: NamePattern -> NamePattern
PEnd :: NamePattern
parseCallerCcFilter :: String -> Either String CallerCcFilter


-- | Dynamic flags
--   
--   Most flags are dynamic flags, which means they can change from
--   compilation to compilation using <tt>OPTIONS_GHC</tt> pragmas, and in
--   a multi-session GHC each session can be using different dynamic flags.
--   Dynamic flags can also be set at the prompt in GHCi.
--   
--   (c) The University of Glasgow 2005
module GHC.Driver.Session

-- | Debugging flags
data DumpFlag
Opt_D_dump_cmm :: DumpFlag
Opt_D_dump_cmm_from_stg :: DumpFlag
Opt_D_dump_cmm_raw :: DumpFlag
Opt_D_dump_cmm_verbose_by_proc :: DumpFlag
Opt_D_dump_cmm_verbose :: DumpFlag
Opt_D_dump_cmm_cfg :: DumpFlag
Opt_D_dump_cmm_cbe :: DumpFlag
Opt_D_dump_cmm_switch :: DumpFlag
Opt_D_dump_cmm_proc :: DumpFlag
Opt_D_dump_cmm_sp :: DumpFlag
Opt_D_dump_cmm_sink :: DumpFlag
Opt_D_dump_cmm_caf :: DumpFlag
Opt_D_dump_cmm_procmap :: DumpFlag
Opt_D_dump_cmm_split :: DumpFlag
Opt_D_dump_cmm_info :: DumpFlag
Opt_D_dump_cmm_cps :: DumpFlag
Opt_D_dump_cmm_thread_sanitizer :: DumpFlag

-- | Dump the cfg used for block layout.
Opt_D_dump_cfg_weights :: DumpFlag
Opt_D_dump_asm :: DumpFlag
Opt_D_dump_asm_native :: DumpFlag
Opt_D_dump_asm_liveness :: DumpFlag
Opt_D_dump_asm_regalloc :: DumpFlag
Opt_D_dump_asm_regalloc_stages :: DumpFlag
Opt_D_dump_asm_conflicts :: DumpFlag
Opt_D_dump_asm_stats :: DumpFlag
Opt_D_dump_c_backend :: DumpFlag
Opt_D_dump_llvm :: DumpFlag
Opt_D_dump_js :: DumpFlag
Opt_D_dump_core_stats :: DumpFlag
Opt_D_dump_deriv :: DumpFlag
Opt_D_dump_ds :: DumpFlag
Opt_D_dump_ds_preopt :: DumpFlag
Opt_D_dump_foreign :: DumpFlag
Opt_D_dump_inlinings :: DumpFlag
Opt_D_dump_verbose_inlinings :: DumpFlag
Opt_D_dump_rule_firings :: DumpFlag
Opt_D_dump_rule_rewrites :: DumpFlag
Opt_D_dump_simpl_trace :: DumpFlag
Opt_D_dump_occur_anal :: DumpFlag
Opt_D_dump_parsed :: DumpFlag
Opt_D_dump_parsed_ast :: DumpFlag
Opt_D_dump_rn :: DumpFlag
Opt_D_dump_rn_ast :: DumpFlag
Opt_D_dump_simpl :: DumpFlag
Opt_D_dump_simpl_iterations :: DumpFlag
Opt_D_dump_spec :: DumpFlag
Opt_D_dump_spec_constr :: DumpFlag
Opt_D_dump_prep :: DumpFlag
Opt_D_dump_late_cc :: DumpFlag

-- | Initial STG (CoreToStg output)
Opt_D_dump_stg_from_core :: DumpFlag

-- | STG after unarise
Opt_D_dump_stg_unarised :: DumpFlag

-- | STG (after stg2stg)
Opt_D_dump_stg_cg :: DumpFlag

-- | Result of tag inference analysis.
Opt_D_dump_stg_tags :: DumpFlag

-- | Final STG (before cmm gen)
Opt_D_dump_stg_final :: DumpFlag
Opt_D_dump_call_arity :: DumpFlag
Opt_D_dump_exitify :: DumpFlag
Opt_D_dump_dmdanal :: DumpFlag
Opt_D_dump_dmd_signatures :: DumpFlag
Opt_D_dump_cpranal :: DumpFlag
Opt_D_dump_cpr_signatures :: DumpFlag
Opt_D_dump_tc :: DumpFlag
Opt_D_dump_tc_ast :: DumpFlag
Opt_D_dump_hie :: DumpFlag
Opt_D_dump_types :: DumpFlag
Opt_D_dump_rules :: DumpFlag
Opt_D_dump_cse :: DumpFlag
Opt_D_dump_float_out :: DumpFlag
Opt_D_dump_float_in :: DumpFlag
Opt_D_dump_liberate_case :: DumpFlag
Opt_D_dump_static_argument_transformation :: DumpFlag
Opt_D_dump_worker_wrapper :: DumpFlag
Opt_D_dump_rn_trace :: DumpFlag
Opt_D_dump_rn_stats :: DumpFlag
Opt_D_dump_opt_cmm :: DumpFlag
Opt_D_dump_simpl_stats :: DumpFlag
Opt_D_dump_cs_trace :: DumpFlag
Opt_D_dump_tc_trace :: DumpFlag
Opt_D_dump_ec_trace :: DumpFlag
Opt_D_dump_if_trace :: DumpFlag
Opt_D_dump_splices :: DumpFlag
Opt_D_th_dec_file :: DumpFlag
Opt_D_dump_BCOs :: DumpFlag
Opt_D_dump_ticked :: DumpFlag
Opt_D_dump_rtti :: DumpFlag
Opt_D_source_stats :: DumpFlag
Opt_D_verbose_stg2stg :: DumpFlag
Opt_D_dump_hi :: DumpFlag
Opt_D_dump_hi_diffs :: DumpFlag
Opt_D_dump_mod_cycles :: DumpFlag
Opt_D_dump_mod_map :: DumpFlag
Opt_D_dump_timings :: DumpFlag
Opt_D_dump_view_pattern_commoning :: DumpFlag
Opt_D_verbose_core2core :: DumpFlag
Opt_D_dump_debug :: DumpFlag
Opt_D_dump_json :: DumpFlag
Opt_D_ppr_debug :: DumpFlag
Opt_D_no_debug_output :: DumpFlag
Opt_D_dump_faststrings :: DumpFlag
Opt_D_faststring_stats :: DumpFlag
Opt_D_ipe_stats :: DumpFlag

-- | Enumerates the simple on-or-off dynamic flags
data GeneralFlag

-- | Append dump output to files instead of stdout.
Opt_DumpToFile :: GeneralFlag

-- | Use foo.ways.<a>dumpFlag</a> instead of foo.<a>dumpFlag</a>
Opt_DumpWithWays :: GeneralFlag
Opt_D_dump_minimal_imports :: GeneralFlag
Opt_DoCoreLinting :: GeneralFlag
Opt_DoLinearCoreLinting :: GeneralFlag
Opt_DoStgLinting :: GeneralFlag
Opt_DoCmmLinting :: GeneralFlag
Opt_DoAsmLinting :: GeneralFlag
Opt_DoAnnotationLinting :: GeneralFlag
Opt_DoBoundsChecking :: GeneralFlag
Opt_NoLlvmMangler :: GeneralFlag
Opt_FastLlvm :: GeneralFlag
Opt_NoTypeableBinds :: GeneralFlag
Opt_DistinctConstructorTables :: GeneralFlag
Opt_InfoTableMap :: GeneralFlag
Opt_InfoTableMapWithFallback :: GeneralFlag
Opt_InfoTableMapWithStack :: GeneralFlag
Opt_WarnIsError :: GeneralFlag
Opt_ShowWarnGroups :: GeneralFlag
Opt_HideSourcePaths :: GeneralFlag
Opt_PrintExplicitForalls :: GeneralFlag
Opt_PrintExplicitKinds :: GeneralFlag
Opt_PrintExplicitCoercions :: GeneralFlag
Opt_PrintExplicitRuntimeReps :: GeneralFlag
Opt_PrintEqualityRelations :: GeneralFlag
Opt_PrintAxiomIncomps :: GeneralFlag
Opt_PrintUnicodeSyntax :: GeneralFlag
Opt_PrintExpandedSynonyms :: GeneralFlag
Opt_PrintPotentialInstances :: GeneralFlag
Opt_PrintRedundantPromotionTicks :: GeneralFlag
Opt_PrintTypecheckerElaboration :: GeneralFlag
Opt_CallArity :: GeneralFlag
Opt_Exitification :: GeneralFlag
Opt_Strictness :: GeneralFlag
Opt_LateDmdAnal :: GeneralFlag
Opt_KillAbsence :: GeneralFlag
Opt_KillOneShot :: GeneralFlag
Opt_FullLaziness :: GeneralFlag
Opt_FloatIn :: GeneralFlag

-- | Enable floating out of let-bindings in the simplifier
Opt_LocalFloatOut :: GeneralFlag

-- | Enable floating out of let-bindings at the top level in the simplifier
--   N.B. See Note [RHS Floating]
Opt_LocalFloatOutTopLevel :: GeneralFlag
Opt_LateSpecialise :: GeneralFlag
Opt_Specialise :: GeneralFlag
Opt_SpecialiseAggressively :: GeneralFlag
Opt_CrossModuleSpecialise :: GeneralFlag
Opt_PolymorphicSpecialisation :: GeneralFlag
Opt_InlineGenerics :: GeneralFlag
Opt_InlineGenericsAggressively :: GeneralFlag
Opt_StaticArgumentTransformation :: GeneralFlag
Opt_CSE :: GeneralFlag
Opt_StgCSE :: GeneralFlag
Opt_StgLiftLams :: GeneralFlag
Opt_LiberateCase :: GeneralFlag
Opt_SpecConstr :: GeneralFlag
Opt_SpecConstrKeen :: GeneralFlag
Opt_SpecialiseIncoherents :: GeneralFlag
Opt_DoLambdaEtaExpansion :: GeneralFlag
Opt_DoCleverArgEtaExpansion :: GeneralFlag
Opt_IgnoreAsserts :: GeneralFlag
Opt_DoEtaReduction :: GeneralFlag
Opt_CaseMerge :: GeneralFlag
Opt_CaseFolding :: GeneralFlag
Opt_UnboxStrictFields :: GeneralFlag
Opt_UnboxSmallStrictFields :: GeneralFlag
Opt_DictsCheap :: GeneralFlag
Opt_EnableRewriteRules :: GeneralFlag
Opt_EnableThSpliceWarnings :: GeneralFlag
Opt_RegsGraph :: GeneralFlag
Opt_RegsIterative :: GeneralFlag
Opt_PedanticBottoms :: GeneralFlag
Opt_LlvmFillUndefWithGarbage :: GeneralFlag
Opt_IrrefutableTuples :: GeneralFlag
Opt_CmmSink :: GeneralFlag
Opt_CmmStaticPred :: GeneralFlag
Opt_CmmElimCommonBlocks :: GeneralFlag
Opt_CmmControlFlow :: GeneralFlag
Opt_AsmShortcutting :: GeneralFlag
Opt_OmitYields :: GeneralFlag
Opt_FunToThunk :: GeneralFlag
Opt_DictsStrict :: GeneralFlag

-- | deprecated, no effect and behaviour is now default. Allowed switching
--   of a special demand transformer for dictionary selectors
Opt_DmdTxDictSel :: GeneralFlag
Opt_Loopification :: GeneralFlag

-- | Use the cfg based block layout algorithm.
Opt_CfgBlocklayout :: GeneralFlag

-- | Layout based on last instruction per block.
Opt_WeightlessBlocklayout :: GeneralFlag
Opt_CprAnal :: GeneralFlag
Opt_WorkerWrapper :: GeneralFlag

-- | Do W/W split for unlifting even if we won't unbox anything.
Opt_WorkerWrapperUnlift :: GeneralFlag
Opt_SolveConstantDicts :: GeneralFlag
Opt_AlignmentSanitisation :: GeneralFlag
Opt_CatchNonexhaustiveCases :: GeneralFlag
Opt_NumConstantFolding :: GeneralFlag
Opt_CoreConstantFolding :: GeneralFlag
Opt_FastPAPCalls :: GeneralFlag
Opt_SpecEval :: GeneralFlag
Opt_SpecEvalDictFun :: GeneralFlag
Opt_DoTagInferenceChecks :: GeneralFlag
Opt_SimplPreInlining :: GeneralFlag
Opt_IgnoreInterfacePragmas :: GeneralFlag
Opt_OmitInterfacePragmas :: GeneralFlag
Opt_ExposeAllUnfoldings :: GeneralFlag
Opt_ExposeOverloadedUnfoldings :: GeneralFlag

-- | Keep auto-generated rules even if they seem to have become useless
Opt_KeepAutoRules :: GeneralFlag
Opt_WriteInterface :: GeneralFlag
Opt_WriteHie :: GeneralFlag

-- | render JavaScript pretty-printed instead of minified (compacted)
Opt_DisableJsMinifier :: GeneralFlag

-- | don't link C sources (compiled to JS) with Haskell code (compiled to
--   JS)
Opt_DisableJsCsources :: GeneralFlag
Opt_AutoSccsOnIndividualCafs :: GeneralFlag
Opt_ProfCountEntries :: GeneralFlag
Opt_ProfLateInlineCcs :: GeneralFlag
Opt_ProfLateCcs :: GeneralFlag
Opt_ProfLateOverloadedCcs :: GeneralFlag
Opt_ProfLateoverloadedCallsCCs :: GeneralFlag

-- | Ignore manual SCC annotations
Opt_ProfManualCcs :: GeneralFlag
Opt_Pp :: GeneralFlag
Opt_ForceRecomp :: GeneralFlag
Opt_IgnoreOptimChanges :: GeneralFlag
Opt_IgnoreHpcChanges :: GeneralFlag
Opt_ExcessPrecision :: GeneralFlag
Opt_EagerBlackHoling :: GeneralFlag
Opt_OrigThunkInfo :: GeneralFlag
Opt_NoHsMain :: GeneralFlag
Opt_SplitSections :: GeneralFlag
Opt_StgStats :: GeneralFlag
Opt_HideAllPackages :: GeneralFlag
Opt_HideAllPluginPackages :: GeneralFlag
Opt_PrintBindResult :: GeneralFlag
Opt_Haddock :: GeneralFlag
Opt_HaddockOptions :: GeneralFlag
Opt_BreakOnException :: GeneralFlag
Opt_BreakOnError :: GeneralFlag
Opt_PrintEvldWithShow :: GeneralFlag
Opt_PrintBindContents :: GeneralFlag
Opt_GenManifest :: GeneralFlag
Opt_EmbedManifest :: GeneralFlag
Opt_SharedImplib :: GeneralFlag
Opt_BuildingCabalPackage :: GeneralFlag
Opt_IgnoreDotGhci :: GeneralFlag
Opt_GhciSandbox :: GeneralFlag
Opt_InsertBreakpoints :: GeneralFlag
Opt_GhciHistory :: GeneralFlag
Opt_GhciLeakCheck :: GeneralFlag
Opt_ValidateHie :: GeneralFlag
Opt_LocalGhciHistory :: GeneralFlag
Opt_NoIt :: GeneralFlag
Opt_HelpfulErrors :: GeneralFlag
Opt_DeferTypeErrors :: GeneralFlag
Opt_DeferTypedHoles :: GeneralFlag
Opt_DeferOutOfScopeVariables :: GeneralFlag

-- | <pre>
--   -fPIC
--   </pre>
Opt_PIC :: GeneralFlag

-- | <pre>
--   -fPIE
--   </pre>
Opt_PIE :: GeneralFlag

-- | <pre>
--   -pie
--   </pre>
Opt_PICExecutable :: GeneralFlag
Opt_ExternalDynamicRefs :: GeneralFlag
Opt_Ticky :: GeneralFlag
Opt_Ticky_Allocd :: GeneralFlag
Opt_Ticky_LNE :: GeneralFlag
Opt_Ticky_Dyn_Thunk :: GeneralFlag
Opt_Ticky_Tag :: GeneralFlag

-- | Use regular thunks even when we could use std ap thunks in order to
--   get entry counts
Opt_Ticky_AP :: GeneralFlag
Opt_CmmThreadSanitizer :: GeneralFlag
Opt_RPath :: GeneralFlag
Opt_RelativeDynlibPaths :: GeneralFlag

-- | <pre>
--   -fcompact-unwind
--   </pre>
Opt_CompactUnwind :: GeneralFlag
Opt_Hpc :: GeneralFlag
Opt_FamAppCache :: GeneralFlag
Opt_ExternalInterpreter :: GeneralFlag
Opt_OptimalApplicativeDo :: GeneralFlag
Opt_VersionMacros :: GeneralFlag
Opt_WholeArchiveHsLibs :: GeneralFlag
Opt_SingleLibFolder :: GeneralFlag
Opt_ExposeInternalSymbols :: GeneralFlag
Opt_KeepCAFs :: GeneralFlag
Opt_KeepGoing :: GeneralFlag
Opt_ByteCode :: GeneralFlag
Opt_ByteCodeAndObjectCode :: GeneralFlag
Opt_UnoptimizedCoreForInterpreter :: GeneralFlag
Opt_LinkRts :: GeneralFlag
Opt_ErrorSpans :: GeneralFlag
Opt_DeferDiagnostics :: GeneralFlag

-- | Dump diagnostics as JSON
Opt_DiagnosticsAsJSON :: GeneralFlag
Opt_DiagnosticsShowCaret :: GeneralFlag
Opt_PprCaseAsLet :: GeneralFlag
Opt_PprShowTicks :: GeneralFlag
Opt_ShowHoleConstraints :: GeneralFlag
Opt_ShowValidHoleFits :: GeneralFlag
Opt_SortValidHoleFits :: GeneralFlag
Opt_SortBySizeHoleFits :: GeneralFlag
Opt_SortBySubsumHoleFits :: GeneralFlag
Opt_AbstractRefHoleFits :: GeneralFlag
Opt_UnclutterValidHoleFits :: GeneralFlag
Opt_ShowTypeAppOfHoleFits :: GeneralFlag
Opt_ShowTypeAppVarsOfHoleFits :: GeneralFlag
Opt_ShowDocsOfHoleFits :: GeneralFlag
Opt_ShowTypeOfHoleFits :: GeneralFlag
Opt_ShowProvOfHoleFits :: GeneralFlag
Opt_ShowMatchesOfHoleFits :: GeneralFlag
Opt_ShowLoadedModules :: GeneralFlag
Opt_HexWordLiterals :: GeneralFlag
Opt_SuppressCoercions :: GeneralFlag
Opt_SuppressCoercionTypes :: GeneralFlag
Opt_SuppressVarKinds :: GeneralFlag
Opt_SuppressModulePrefixes :: GeneralFlag
Opt_SuppressTypeApplications :: GeneralFlag
Opt_SuppressIdInfo :: GeneralFlag
Opt_SuppressUnfoldings :: GeneralFlag
Opt_SuppressTypeSignatures :: GeneralFlag
Opt_SuppressUniques :: GeneralFlag
Opt_SuppressStgExts :: GeneralFlag
Opt_SuppressStgReps :: GeneralFlag
Opt_SuppressTicks :: GeneralFlag

-- | Suppress timestamps in dumps
Opt_SuppressTimestamps :: GeneralFlag

-- | Suppress per binding Core size stats in dumps
Opt_SuppressCoreSizes :: GeneralFlag
Opt_ShowErrorContext :: GeneralFlag
Opt_ObjectDeterminism :: GeneralFlag
Opt_AutoLinkPackages :: GeneralFlag
Opt_ImplicitImportQualified :: GeneralFlag
Opt_KeepHscppFiles :: GeneralFlag
Opt_KeepHiDiffs :: GeneralFlag
Opt_KeepHcFiles :: GeneralFlag
Opt_KeepSFiles :: GeneralFlag
Opt_KeepTmpFiles :: GeneralFlag
Opt_KeepRawTokenStream :: GeneralFlag
Opt_KeepLlvmFiles :: GeneralFlag
Opt_KeepHiFiles :: GeneralFlag
Opt_KeepOFiles :: GeneralFlag
Opt_BuildDynamicToo :: GeneralFlag
Opt_WriteIfSimplifiedCore :: GeneralFlag
Opt_UseBytecodeRatherThanObjects :: GeneralFlag
Opt_DistrustAllPackages :: GeneralFlag
Opt_PackageTrust :: GeneralFlag
Opt_PluginTrustworthy :: GeneralFlag
Opt_G_NoStateHack :: GeneralFlag
Opt_G_NoOptCoercion :: GeneralFlag
data WarningFlag
Opt_WarnDuplicateExports :: WarningFlag
Opt_WarnDuplicateConstraints :: WarningFlag
Opt_WarnRedundantConstraints :: WarningFlag
Opt_WarnHiShadows :: WarningFlag
Opt_WarnImplicitPrelude :: WarningFlag
Opt_WarnIncompletePatterns :: WarningFlag
Opt_WarnIncompleteUniPatterns :: WarningFlag
Opt_WarnIncompletePatternsRecUpd :: WarningFlag
Opt_WarnOverflowedLiterals :: WarningFlag
Opt_WarnEmptyEnumerations :: WarningFlag
Opt_WarnMissingFields :: WarningFlag
Opt_WarnMissingImportList :: WarningFlag
Opt_WarnMissingMethods :: WarningFlag
Opt_WarnMissingSignatures :: WarningFlag
Opt_WarnMissingLocalSignatures :: WarningFlag
Opt_WarnNameShadowing :: WarningFlag
Opt_WarnOverlappingPatterns :: WarningFlag
Opt_WarnTypeDefaults :: WarningFlag
Opt_WarnMonomorphism :: WarningFlag
Opt_WarnUnusedTopBinds :: WarningFlag
Opt_WarnUnusedLocalBinds :: WarningFlag
Opt_WarnUnusedPatternBinds :: WarningFlag
Opt_WarnUnusedImports :: WarningFlag
Opt_WarnUnusedMatches :: WarningFlag
Opt_WarnUnusedTypePatterns :: WarningFlag
Opt_WarnUnusedForalls :: WarningFlag
Opt_WarnUnusedRecordWildcards :: WarningFlag
Opt_WarnRedundantBangPatterns :: WarningFlag
Opt_WarnRedundantRecordWildcards :: WarningFlag
Opt_WarnDeprecatedFlags :: WarningFlag
Opt_WarnMissingMonadFailInstances :: WarningFlag
Opt_WarnSemigroup :: WarningFlag
Opt_WarnDodgyExports :: WarningFlag
Opt_WarnDodgyImports :: WarningFlag
Opt_WarnOrphans :: WarningFlag
Opt_WarnAutoOrphans :: WarningFlag
Opt_WarnIdentities :: WarningFlag
Opt_WarnTabs :: WarningFlag
Opt_WarnUnrecognisedPragmas :: WarningFlag
Opt_WarnMisplacedPragmas :: WarningFlag
Opt_WarnDodgyForeignImports :: WarningFlag
Opt_WarnUnusedDoBind :: WarningFlag
Opt_WarnWrongDoBind :: WarningFlag
Opt_WarnAlternativeLayoutRuleTransitional :: WarningFlag
Opt_WarnUnsafe :: WarningFlag
Opt_WarnSafe :: WarningFlag
Opt_WarnTrustworthySafe :: WarningFlag
Opt_WarnMissedSpecs :: WarningFlag
Opt_WarnAllMissedSpecs :: WarningFlag
Opt_WarnUnsupportedCallingConventions :: WarningFlag
Opt_WarnUnsupportedLlvmVersion :: WarningFlag
Opt_WarnMissedExtraSharedLib :: WarningFlag
Opt_WarnInlineRuleShadowing :: WarningFlag
Opt_WarnTypedHoles :: WarningFlag
Opt_WarnPartialTypeSignatures :: WarningFlag
Opt_WarnMissingExportedSignatures :: WarningFlag
Opt_WarnUntickedPromotedConstructors :: WarningFlag
Opt_WarnDerivingTypeable :: WarningFlag
Opt_WarnDeferredTypeErrors :: WarningFlag
Opt_WarnDeferredOutOfScopeVariables :: WarningFlag
Opt_WarnNonCanonicalMonadInstances :: WarningFlag
Opt_WarnNonCanonicalMonadFailInstances :: WarningFlag
Opt_WarnNonCanonicalMonoidInstances :: WarningFlag
Opt_WarnMissingPatternSynonymSignatures :: WarningFlag
Opt_WarnUnrecognisedWarningFlags :: WarningFlag
Opt_WarnSimplifiableClassConstraints :: WarningFlag
Opt_WarnCPPUndef :: WarningFlag
Opt_WarnUnbangedStrictPatterns :: WarningFlag
Opt_WarnMissingHomeModules :: WarningFlag
Opt_WarnPartialFields :: WarningFlag
Opt_WarnMissingExportList :: WarningFlag
Opt_WarnInaccessibleCode :: WarningFlag
Opt_WarnStarIsType :: WarningFlag
Opt_WarnStarBinder :: WarningFlag
Opt_WarnImplicitKindVars :: WarningFlag
Opt_WarnSpaceAfterBang :: WarningFlag
Opt_WarnMissingDerivingStrategies :: WarningFlag
Opt_WarnPrepositiveQualifiedModule :: WarningFlag
Opt_WarnUnusedPackages :: WarningFlag
Opt_WarnInferredSafeImports :: WarningFlag
Opt_WarnMissingSafeHaskellMode :: WarningFlag
Opt_WarnCompatUnqualifiedImports :: WarningFlag
Opt_WarnDerivingDefaults :: WarningFlag
Opt_WarnInvalidHaddock :: WarningFlag
Opt_WarnOperatorWhitespaceExtConflict :: WarningFlag
Opt_WarnOperatorWhitespace :: WarningFlag
Opt_WarnAmbiguousFields :: WarningFlag
Opt_WarnImplicitLift :: WarningFlag
Opt_WarnMissingKindSignatures :: WarningFlag
Opt_WarnMissingPolyKindSignatures :: WarningFlag
Opt_WarnMissingExportedPatternSynonymSignatures :: WarningFlag
Opt_WarnRedundantStrictnessFlags :: WarningFlag
Opt_WarnForallIdentifier :: WarningFlag
Opt_WarnUnicodeBidirectionalFormatCharacters :: WarningFlag
Opt_WarnGADTMonoLocalBinds :: WarningFlag
Opt_WarnTypeEqualityOutOfScope :: WarningFlag
Opt_WarnTypeEqualityRequiresOperators :: WarningFlag
Opt_WarnLoopySuperclassSolve :: WarningFlag
Opt_WarnTermVariableCapture :: WarningFlag
Opt_WarnMissingRoleAnnotations :: WarningFlag
Opt_WarnImplicitRhsQuantification :: WarningFlag
Opt_WarnIncompleteExportWarnings :: WarningFlag
Opt_WarnIncompleteRecordSelectors :: WarningFlag
Opt_WarnBadlyStagedTypes :: WarningFlag
Opt_WarnInconsistentFlags :: WarningFlag
Opt_WarnDataKindsTC :: WarningFlag
Opt_WarnDeprecatedTypeAbstractions :: WarningFlag
Opt_WarnDefaultedExceptionContext :: WarningFlag
Opt_WarnViewPatternSignatures :: WarningFlag

-- | The reason <i>why</i> a <a>Diagnostic</a> was emitted in the first
--   place. Diagnostic messages are born within GHC with a very precise
--   reason, which can be completely statically-computed (i.e. this is an
--   error or a warning no matter what), or influenced by the specific
--   state of the <tt>DynFlags</tt> at the moment of the creation of a new
--   <a>Diagnostic</a>. For example, a parsing error is <i>always</i> going
--   to be an error, whereas a 'WarningWithoutFlag Opt_WarnUnusedImports'
--   might turn into an error due to '-Werror' or
--   '-Werror=warn-unused-imports'. Interpreting a <a>DiagnosticReason</a>
--   together with its associated <a>Severity</a> gives us the full
--   picture.
data DiagnosticReason

-- | Born as a warning.
WarningWithoutFlag :: DiagnosticReason

-- | Warning was enabled with the flag.
WarningWithFlags :: !NonEmpty WarningFlag -> DiagnosticReason

-- | Warning was enabled with a custom category.
WarningWithCategory :: !WarningCategory -> DiagnosticReason

-- | Born as an error.
ErrorWithoutFlag :: DiagnosticReason

-- | The single warning case <a>DiagnosticReason</a> is very common.
pattern WarningWithFlag :: WarningFlag -> DiagnosticReason
data Language
Haskell98 :: Language
Haskell2010 :: Language
GHC2021 :: Language
GHC2024 :: Language
type FatalMessager = String -> IO ()
newtype FlushOut
FlushOut :: IO () -> FlushOut

-- | What kind of {-# SCC #-} to add automatically
data ProfAuto

-- | no SCC annotations added
NoProfAuto :: ProfAuto

-- | top-level and nested functions are annotated
ProfAutoAll :: ProfAuto

-- | top-level functions annotated only
ProfAutoTop :: ProfAuto

-- | exported functions annotated only
ProfAutoExports :: ProfAuto

-- | annotate call-sites
ProfAutoCalls :: ProfAuto
glasgowExtsFlags :: [Extension]
hasPprDebug :: DynFlags -> Bool
hasNoDebugOutput :: DynFlags -> Bool
hasNoStateHack :: DynFlags -> Bool
hasNoOptCoercion :: DynFlags -> Bool

-- | Test whether a <a>DumpFlag</a> is set
dopt :: DumpFlag -> DynFlags -> Bool

-- | Set a <a>DumpFlag</a>
dopt_set :: DynFlags -> DumpFlag -> DynFlags

-- | Unset a <a>DumpFlag</a>
dopt_unset :: DynFlags -> DumpFlag -> DynFlags

-- | Test whether a <a>GeneralFlag</a> is set
--   
--   Note that <a>dynamicNow</a> (i.e., dynamic objects built with
--   `-dynamic-too`) always implicitly enables Opt_PIC,
--   Opt_ExternalDynamicRefs, and disables Opt_SplitSections.
gopt :: GeneralFlag -> DynFlags -> Bool

-- | Set a <a>GeneralFlag</a>
gopt_set :: DynFlags -> GeneralFlag -> DynFlags

-- | Unset a <a>GeneralFlag</a>
gopt_unset :: DynFlags -> GeneralFlag -> DynFlags
setGeneralFlag' :: GeneralFlag -> DynFlags -> DynFlags
unSetGeneralFlag' :: GeneralFlag -> DynFlags -> DynFlags

-- | Test whether a <a>WarningFlag</a> is set
wopt :: WarningFlag -> DynFlags -> Bool

-- | Set a <a>WarningFlag</a>
wopt_set :: DynFlags -> WarningFlag -> DynFlags

-- | Unset a <a>WarningFlag</a>
wopt_unset :: DynFlags -> WarningFlag -> DynFlags

-- | Test whether a <a>WarningFlag</a> is set as fatal
wopt_fatal :: WarningFlag -> DynFlags -> Bool

-- | Mark a <a>WarningFlag</a> as fatal (do not set the flag)
wopt_set_fatal :: DynFlags -> WarningFlag -> DynFlags

-- | Mark a <a>WarningFlag</a> as not fatal
wopt_unset_fatal :: DynFlags -> WarningFlag -> DynFlags

-- | Enable all custom warning categories.
wopt_set_all_custom :: DynFlags -> DynFlags

-- | Disable all custom warning categories.
wopt_unset_all_custom :: DynFlags -> DynFlags

-- | Mark all custom warning categories as fatal (do not set the flags).
wopt_set_all_fatal_custom :: DynFlags -> DynFlags

-- | Mark all custom warning categories as non-fatal.
wopt_unset_all_fatal_custom :: DynFlags -> DynFlags

-- | Set a custom <a>WarningCategory</a>
wopt_set_custom :: DynFlags -> WarningCategory -> DynFlags

-- | Unset a custom <a>WarningCategory</a>
wopt_unset_custom :: DynFlags -> WarningCategory -> DynFlags

-- | Mark a custom <a>WarningCategory</a> as fatal (do not set the flag)
wopt_set_fatal_custom :: DynFlags -> WarningCategory -> DynFlags

-- | Mark a custom <a>WarningCategory</a> as not fatal
wopt_unset_fatal_custom :: DynFlags -> WarningCategory -> DynFlags

-- | Are there any custom warning categories enabled?
wopt_any_custom :: DynFlags -> Bool

-- | Test whether a <a>Extension</a> is set
xopt :: Extension -> DynFlags -> Bool

-- | Set a <a>Extension</a>
xopt_set :: DynFlags -> Extension -> DynFlags

-- | Unset a <a>Extension</a>
xopt_unset :: DynFlags -> Extension -> DynFlags

-- | Set or unset a <a>Extension</a>, unless it has been explicitly set or
--   unset before.
xopt_set_unlessExplSpec :: Extension -> (DynFlags -> Extension -> DynFlags) -> DynFlags -> DynFlags
xopt_DuplicateRecordFields :: DynFlags -> DuplicateRecordFields
xopt_FieldSelectors :: DynFlags -> FieldSelectors
lang_set :: DynFlags -> Maybe Language -> DynFlags
data DynamicTooState

-- | Don't try to build dynamic objects too
DT_Dont :: DynamicTooState

-- | Will still try to generate dynamic objects
DT_OK :: DynamicTooState

-- | Currently generating dynamic objects (in the backend)
DT_Dyn :: DynamicTooState
dynamicTooState :: DynFlags -> DynamicTooState
setDynamicNow :: DynFlags -> DynFlags

-- | Indicate if cost-centre profiling is enabled
sccProfilingEnabled :: DynFlags -> Bool

-- | Indicate whether we need to generate source notes
needSourceNotes :: DynFlags -> Bool
data OnOff a
On :: a -> OnOff a
Off :: a -> OnOff a

-- | Contains not only a collection of <a>GeneralFlag</a>s but also a
--   plethora of information relating to the compilation of a single file
--   or GHC session
data DynFlags
DynFlags :: GhcMode -> GhcLink -> !Backend -> {-# UNPACK #-} !GhcNameVersion -> {-# UNPACK #-} !FileSettings -> Platform -> {-# UNPACK #-} !ToolSettings -> {-# UNPACK #-} !PlatformMisc -> [(String, String)] -> TempDir -> Int -> Int -> Int -> Int -> Int -> Maybe String -> [Int] -> Maybe ParMakeCount -> Bool -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Int -> Int -> Int -> !Int -> Int -> Maybe Int -> Maybe Int -> Int -> Maybe Word -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Bool -> Maybe Int -> Int -> [FilePath] -> ModuleName -> Maybe String -> IntWithInf -> IntWithInf -> Int -> Int -> Int -> UnitId -> Maybe UnitId -> [(ModuleName, Module)] -> Maybe FilePath -> Maybe String -> Set ModuleName -> [ReexportedModule] -> Ways -> Maybe (String, Int) -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> String -> String -> String -> String -> String -> String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> DynLibLoader -> !Bool -> FilePath -> Maybe FilePath -> [Option] -> IncludeSpecs -> [String] -> [String] -> [String] -> Maybe String -> RtsOptsEnabled -> Bool -> String -> [ModuleName] -> [(ModuleName, String)] -> [String] -> [ExternalPluginSpec] -> FilePath -> Bool -> Bool -> [ModuleName] -> [String] -> [PackageDBFlag] -> [IgnorePackageFlag] -> [PackageFlag] -> [PackageFlag] -> [TrustFlag] -> Maybe FilePath -> EnumSet DumpFlag -> EnumSet GeneralFlag -> EnumSet WarningFlag -> EnumSet WarningFlag -> WarningCategorySet -> WarningCategorySet -> Maybe Language -> SafeHaskellMode -> Bool -> Bool -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> [OnOff Extension] -> EnumSet Extension -> !UnfoldingOpts -> Int -> Int -> Int -> FlushOut -> Maybe FilePath -> Maybe String -> [String] -> Int -> Int -> Bool -> OverridingBool -> Bool -> OverridingBool -> Bool -> Scheme -> ProfAuto -> [CallerCcFilter] -> Maybe String -> Maybe SseVersion -> Maybe BmiVersion -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Int -> Int -> Int -> Bool -> Maybe Int -> Word64 -> Int -> Weights -> DynFlags
[ghcMode] :: DynFlags -> GhcMode
[ghcLink] :: DynFlags -> GhcLink

-- | The backend to use (if any).
--   
--   Whenever you change the backend, also make sure to set <a>ghcLink</a>
--   to something sensible.
--   
--   <tt>NoBackend</tt> can be used to avoid generating any output,
--   however, note that:
--   
--   <ul>
--   <li>If a program uses Template Haskell the typechecker may need to run
--   code from an imported module. To facilitate this, code generation is
--   enabled for modules imported by modules that use template haskell,
--   using the default backend for the platform. See Note [-fno-code
--   mode].</li>
--   </ul>
[backend] :: DynFlags -> !Backend
[ghcNameVersion] :: DynFlags -> {-# UNPACK #-} !GhcNameVersion
[fileSettings] :: DynFlags -> {-# UNPACK #-} !FileSettings
[targetPlatform] :: DynFlags -> Platform
[toolSettings] :: DynFlags -> {-# UNPACK #-} !ToolSettings
[platformMisc] :: DynFlags -> {-# UNPACK #-} !PlatformMisc
[rawSettings] :: DynFlags -> [(String, String)]
[tmpDir] :: DynFlags -> TempDir

-- | LLVM optimisation level
[llvmOptLevel] :: DynFlags -> Int

-- | Verbosity level: see Note [Verbosity levels]
[verbosity] :: DynFlags -> Int

-- | How much debug information to produce
[debugLevel] :: DynFlags -> Int

-- | Number of simplifier phases
[simplPhases] :: DynFlags -> Int

-- | Max simplifier iterations
[maxSimplIterations] :: DynFlags -> Int
[ruleCheck] :: DynFlags -> Maybe String

-- | Additional demand analysis
[strictnessBefore] :: DynFlags -> [Int]

-- | The number of modules to compile in parallel If unspecified, compile
--   with a single job.
[parMakeCount] :: DynFlags -> Maybe ParMakeCount

-- | Enable RTS timing statistics?
[enableTimeStats] :: DynFlags -> Bool

-- | The heap size to set.
[ghcHeapSize] :: DynFlags -> Maybe Int

-- | Maximum number of bindings from the type envt to show in type error
--   messages
[maxRelevantBinds] :: DynFlags -> Maybe Int

-- | Maximum number of hole fits to show in typed hole error messages
[maxValidHoleFits] :: DynFlags -> Maybe Int

-- | Maximum number of refinement hole fits to show in typed hole error
--   messages
[maxRefHoleFits] :: DynFlags -> Maybe Int

-- | Maximum level of refinement for refinement hole fits in typed hole
--   error messages
[refLevelHoleFits] :: DynFlags -> Maybe Int

-- | Maximum number of unmatched patterns to show in non-exhaustiveness
--   warnings
[maxUncoveredPatterns] :: DynFlags -> Int

-- | Soft limit on the number of models the pattern match checker checks a
--   pattern against. A safe guard against exponential blow-up.
[maxPmCheckModels] :: DynFlags -> Int

-- | Multiplier for simplifier ticks
[simplTickFactor] :: DynFlags -> Int

-- | Whether DmdAnal should optimistically put an Unboxed demand on
--   returned products with at most this number of fields
[dmdUnboxWidth] :: DynFlags -> !Int
[ifCompression] :: DynFlags -> Int

-- | Threshold for SpecConstr
[specConstrThreshold] :: DynFlags -> Maybe Int

-- | Max number of specialisations for any one function
[specConstrCount] :: DynFlags -> Maybe Int

-- | Max number of specialisations for recursive types Not optional;
--   otherwise ForceSpecConstr can diverge.
[specConstrRecursive] :: DynFlags -> Int

-- | Binary literals (e.g. strings) whose size is above this threshold will
--   be dumped in a binary file by the assembler code generator. 0 and
--   Nothing disables this feature. See <a>Config</a>.
[binBlobThreshold] :: DynFlags -> Maybe Word

-- | Threshold for LiberateCase
[liberateCaseThreshold] :: DynFlags -> Maybe Int

-- | Arg count for lambda floating See <a>FloatOutSwitches</a>
[floatLamArgs] :: DynFlags -> Maybe Int

-- | Maximum number of arguments after lambda lifting a recursive function.
[liftLamsRecArgs] :: DynFlags -> Maybe Int

-- | Maximum number of arguments after lambda lifting a non-recursive
--   function.
[liftLamsNonRecArgs] :: DynFlags -> Maybe Int

-- | Lambda lift even when this turns a known call into an unknown call.
[liftLamsKnown] :: DynFlags -> Bool

-- | Align Cmm functions at this boundary or use default.
[cmmProcAlignment] :: DynFlags -> Maybe Int

-- | Simplification history size
[historySize] :: DynFlags -> Int
[importPaths] :: DynFlags -> [FilePath]
[mainModuleNameIs] :: DynFlags -> ModuleName
[mainFunIs] :: DynFlags -> Maybe String

-- | Typechecker maximum stack depth
[reductionDepth] :: DynFlags -> IntWithInf

-- | Number of iterations in the constraints solver Typically only 1 is
--   needed
[solverIterations] :: DynFlags -> IntWithInf

-- | Number of layers of superclass expansion for givens Should be &lt;
--   solverIterations See Note [Expanding Recursive Superclasses and
--   ExpansionFuel]
[givensFuel] :: DynFlags -> Int

-- | Number of layers of superclass expansion for wanteds Should be &lt;
--   givensFuel See Note [Expanding Recursive Superclasses and
--   ExpansionFuel]
[wantedsFuel] :: DynFlags -> Int

-- | Number of layers of superclass expansion for quantified constraints
--   Should be &lt; givensFuel See Note [Expanding Recursive Superclasses
--   and ExpansionFuel]
[qcsFuel] :: DynFlags -> Int

-- | Target home unit-id
[homeUnitId_] :: DynFlags -> UnitId

-- | Id of the unit to instantiate
[homeUnitInstanceOf_] :: DynFlags -> Maybe UnitId

-- | Module instantiations
[homeUnitInstantiations_] :: DynFlags -> [(ModuleName, Module)]
[workingDirectory] :: DynFlags -> Maybe FilePath

-- | What the package is called, use with multiple home units
[thisPackageName] :: DynFlags -> Maybe String
[hiddenModules] :: DynFlags -> Set ModuleName
[reexportedModules] :: DynFlags -> [ReexportedModule]

-- | Target way flags from the command line
[targetWays_] :: DynFlags -> Ways
[splitInfo] :: DynFlags -> Maybe (String, Int)
[objectDir] :: DynFlags -> Maybe String
[dylibInstallName] :: DynFlags -> Maybe String
[hiDir] :: DynFlags -> Maybe String
[hieDir] :: DynFlags -> Maybe String
[stubDir] :: DynFlags -> Maybe String
[dumpDir] :: DynFlags -> Maybe String
[objectSuf_] :: DynFlags -> String
[hcSuf] :: DynFlags -> String
[hiSuf_] :: DynFlags -> String
[hieSuf] :: DynFlags -> String
[dynObjectSuf_] :: DynFlags -> String
[dynHiSuf_] :: DynFlags -> String
[outputFile_] :: DynFlags -> Maybe String
[dynOutputFile_] :: DynFlags -> Maybe String
[outputHi] :: DynFlags -> Maybe String
[dynOutputHi] :: DynFlags -> Maybe String
[dynLibLoader] :: DynFlags -> DynLibLoader

-- | Indicate if we are now generating dynamic output because of
--   -dynamic-too. This predicate is used to query the appropriate fields
--   (outputFile/dynOutputFile, ways, etc.)
[dynamicNow] :: DynFlags -> !Bool

-- | This defaults to 'non-module'. It can be set by <a>setDumpPrefix</a>
--   or 'ghc.GHCi.UI.runStmt' based on where its output is going.
[dumpPrefix] :: DynFlags -> FilePath

-- | Override the <a>dumpPrefix</a> set by <a>setDumpPrefix</a> or
--   'ghc.GHCi.UI.runStmt'. Set by <tt>-ddump-file-prefix</tt>
[dumpPrefixForce] :: DynFlags -> Maybe FilePath
[ldInputs] :: DynFlags -> [Option]
[includePaths] :: DynFlags -> IncludeSpecs
[libraryPaths] :: DynFlags -> [String]
[frameworkPaths] :: DynFlags -> [String]
[cmdlineFrameworks] :: DynFlags -> [String]
[rtsOpts] :: DynFlags -> Maybe String
[rtsOptsEnabled] :: DynFlags -> RtsOptsEnabled
[rtsOptsSuggestions] :: DynFlags -> Bool

-- | Path to store the .mix files
[hpcDir] :: DynFlags -> String

-- | the <tt>-fplugin</tt> flags given on the command line, in *reverse*
--   order that they're specified on the command line.
[pluginModNames] :: DynFlags -> [ModuleName]
[pluginModNameOpts] :: DynFlags -> [(ModuleName, String)]

-- | the <tt>-ffrontend-opt</tt> flags given on the command line, in
--   *reverse* order that they're specified on the command line.
[frontendPluginOpts] :: DynFlags -> [String]

-- | External plugins loaded from shared libraries
[externalPluginSpecs] :: DynFlags -> [ExternalPluginSpec]
[depMakefile] :: DynFlags -> FilePath
[depIncludePkgDeps] :: DynFlags -> Bool
[depIncludeCppDeps] :: DynFlags -> Bool
[depExcludeMods] :: DynFlags -> [ModuleName]
[depSuffixes] :: DynFlags -> [String]

-- | The <tt>-package-db</tt> flags given on the command line, In *reverse*
--   order that they're specified on the command line. This is intended to
--   be applied with the list of "initial" package databases derived from
--   <tt>GHC_PACKAGE_PATH</tt>; see <tt>getUnitDbRefs</tt>.
[packageDBFlags] :: DynFlags -> [PackageDBFlag]

-- | The <tt>-ignore-package</tt> flags from the command line. In *reverse*
--   order that they're specified on the command line.
[ignorePackageFlags] :: DynFlags -> [IgnorePackageFlag]

-- | The <tt>-package</tt> and <tt>-hide-package</tt> flags from the
--   command-line. In *reverse* order that they're specified on the command
--   line.
[packageFlags] :: DynFlags -> [PackageFlag]

-- | The <tt>-plugin-package-id</tt> flags from command line. In *reverse*
--   order that they're specified on the command line.
[pluginPackageFlags] :: DynFlags -> [PackageFlag]

-- | The <tt>-trust</tt> and <tt>-distrust</tt> flags. In *reverse* order
--   that they're specified on the command line.
[trustFlags] :: DynFlags -> [TrustFlag]

-- | Filepath to the package environment file (if overriding default)
[packageEnv] :: DynFlags -> Maybe FilePath
[dumpFlags] :: DynFlags -> EnumSet DumpFlag
[generalFlags] :: DynFlags -> EnumSet GeneralFlag
[warningFlags] :: DynFlags -> EnumSet WarningFlag
[fatalWarningFlags] :: DynFlags -> EnumSet WarningFlag
[customWarningCategories] :: DynFlags -> WarningCategorySet
[fatalCustomWarningCategories] :: DynFlags -> WarningCategorySet
[language] :: DynFlags -> Maybe Language

-- | Safe Haskell mode
[safeHaskell] :: DynFlags -> SafeHaskellMode
[safeInfer] :: DynFlags -> Bool
[safeInferred] :: DynFlags -> Bool
[thOnLoc] :: DynFlags -> SrcSpan
[newDerivOnLoc] :: DynFlags -> SrcSpan
[deriveViaOnLoc] :: DynFlags -> SrcSpan
[overlapInstLoc] :: DynFlags -> SrcSpan
[incoherentOnLoc] :: DynFlags -> SrcSpan
[pkgTrustOnLoc] :: DynFlags -> SrcSpan
[warnSafeOnLoc] :: DynFlags -> SrcSpan
[warnUnsafeOnLoc] :: DynFlags -> SrcSpan
[trustworthyOnLoc] :: DynFlags -> SrcSpan
[extensions] :: DynFlags -> [OnOff Extension]
[extensionFlags] :: DynFlags -> EnumSet Extension

-- | Unfolding control See Note [Discounts and thresholds] in
--   GHC.Core.Unfold
[unfoldingOpts] :: DynFlags -> !UnfoldingOpts
[maxWorkerArgs] :: DynFlags -> Int
[maxForcedSpecArgs] :: DynFlags -> Int
[ghciHistSize] :: DynFlags -> Int
[flushOut] :: DynFlags -> FlushOut
[ghcVersionFile] :: DynFlags -> Maybe FilePath
[haddockOptions] :: DynFlags -> Maybe String

-- | GHCi scripts specified by -ghci-script, in reverse order
[ghciScripts] :: DynFlags -> [String]
[pprUserLength] :: DynFlags -> Int
[pprCols] :: DynFlags -> Int
[useUnicode] :: DynFlags -> Bool
[useColor] :: DynFlags -> OverridingBool
[canUseColor] :: DynFlags -> Bool
[useErrorLinks] :: DynFlags -> OverridingBool
[canUseErrorLinks] :: DynFlags -> Bool
[colScheme] :: DynFlags -> Scheme

-- | what kind of {-# SCC #-} to add automatically
[profAuto] :: DynFlags -> ProfAuto
[callerCcFilters] :: DynFlags -> [CallerCcFilter]
[interactivePrint] :: DynFlags -> Maybe String

-- | Machine dependent flags (-m&lt;blah&gt; stuff)
[sseVersion] :: DynFlags -> Maybe SseVersion
[bmiVersion] :: DynFlags -> Maybe BmiVersion
[avx] :: DynFlags -> Bool
[avx2] :: DynFlags -> Bool
[avx512cd] :: DynFlags -> Bool
[avx512er] :: DynFlags -> Bool
[avx512f] :: DynFlags -> Bool
[avx512pf] :: DynFlags -> Bool

-- | Enable FMA instructions.
[fma] :: DynFlags -> Bool

-- | Max size, in bytes, of inline array allocations.
[maxInlineAllocSize] :: DynFlags -> Int

-- | Only inline memcpy if it generates no more than this many pseudo
--   (roughly: Cmm) instructions.
[maxInlineMemcpyInsns] :: DynFlags -> Int

-- | Only inline memset if it generates no more than this many pseudo
--   (roughly: Cmm) instructions.
[maxInlineMemsetInsns] :: DynFlags -> Int

-- | Reverse the order of error messages in GHC/GHCi
[reverseErrors] :: DynFlags -> Bool

-- | Limit the maximum number of errors to show
[maxErrors] :: DynFlags -> Maybe Int

-- | Unique supply configuration for testing build determinism
[initialUnique] :: DynFlags -> Word64
[uniqueIncrement] :: DynFlags -> Int

-- | Temporary: CFG Edge weights for fast iterations
[cfgWeights] :: DynFlags -> Weights

-- | The type for the -jN argument, specifying that -j on its own
--   represents using the number of machine processors.
data ParMakeCount

-- | Use this many processors (<tt>-j<a>n</a></tt> flag).
ParMakeThisMany :: Int -> ParMakeCount

-- | Use parallelism with as many processors as possible (<tt>-j</tt> flag
--   without an argument).
ParMakeNumProcessors :: ParMakeCount

-- | Use the specific semaphore <tt><a>sem</a></tt> to control parallelism
--   (<tt>-jsem <a>sem</a></tt> flag).
ParMakeSemaphore :: FilePath -> ParMakeCount
outputFile :: DynFlags -> Maybe String
objectSuf :: DynFlags -> String
ways :: DynFlags -> Ways
data FlagSpec flag
FlagSpec :: String -> flag -> (TurnOnFlag -> DynP ()) -> GhcFlagMode -> FlagSpec flag

-- | Flag in string form
[flagSpecName] :: FlagSpec flag -> String

-- | Flag in internal form
[flagSpecFlag] :: FlagSpec flag -> flag

-- | Extra action to run when the flag is found Typically, emit a warning
--   or error
[flagSpecAction] :: FlagSpec flag -> TurnOnFlag -> DynP ()

-- | In which ghc mode the flag has effect
[flagSpecGhcMode] :: FlagSpec flag -> GhcFlagMode
class HasDynFlags (m :: Type -> Type)
getDynFlags :: HasDynFlags m => m DynFlags
class ContainsDynFlags t
extractDynFlags :: ContainsDynFlags t => t -> DynFlags
data RtsOptsEnabled
RtsOptsNone :: RtsOptsEnabled
RtsOptsIgnore :: RtsOptsEnabled
RtsOptsIgnoreAll :: RtsOptsEnabled
RtsOptsSafeOnly :: RtsOptsEnabled
RtsOptsAll :: RtsOptsEnabled

-- | The <a>GhcMode</a> tells us whether we're doing multi-module
--   compilation (controlled via the <a>GHC</a> API) or one-shot
--   (single-module) compilation. This makes a difference primarily to the
--   <a>GHC.Unit.Finder</a>: in one-shot mode we look for interface files
--   for imported modules, but in multi-module mode we look for source
--   files in order to check whether they need to be recompiled.
data GhcMode

-- | <tt>--make</tt>, GHCi, etc.
CompManager :: GhcMode

-- | <pre>
--   ghc -c Foo.hs
--   </pre>
OneShot :: GhcMode

-- | <tt>ghc -M</tt>, see <a>GHC.Unit.Finder</a> for why we need this
MkDepend :: GhcMode
isOneShot :: GhcMode -> Bool

-- | What to do in the link step, if there is one.
data GhcLink

-- | Don't link at all
NoLink :: GhcLink

-- | Link object code into a binary
LinkBinary :: GhcLink

-- | Use the in-memory dynamic linker (works for both bytecode and object
--   code).
LinkInMemory :: GhcLink

-- | Link objects into a dynamic lib (DLL on Windows, DSO on ELF platforms)
LinkDynLib :: GhcLink

-- | Link objects into a static lib
LinkStaticLib :: GhcLink

-- | Link objects into a merged "GHCi object"
LinkMergedObj :: GhcLink
isNoLink :: GhcLink -> Bool

-- | Flags for manipulating packages visibility.
data PackageFlag

-- | <tt>-package</tt>, <tt>-package-id</tt>
ExposePackage :: String -> PackageArg -> ModRenaming -> PackageFlag

-- | <pre>
--   -hide-package
--   </pre>
HidePackage :: String -> PackageFlag

-- | We accept flags which make packages visible, but how they select the
--   package varies; this data type reflects what selection criterion is
--   used.
data PackageArg

-- | <tt>-package</tt>, by <tt>PackageName</tt>
PackageArg :: String -> PackageArg

-- | <tt>-package-id</tt>, by <a>Unit</a>
UnitIdArg :: Unit -> PackageArg

-- | Represents the renaming that may be associated with an exposed
--   package, e.g. the <tt>rns</tt> part of <tt>-package "foo (rns)"</tt>.
--   
--   Here are some example parsings of the package flags (where a string
--   literal is punned to be a <a>ModuleName</a>:
--   
--   <ul>
--   <li><tt>-package foo</tt> is <tt>ModRenaming True []</tt></li>
--   <li><tt>-package foo ()</tt> is <tt>ModRenaming False []</tt></li>
--   <li><tt>-package foo (A)</tt> is <tt>ModRenaming False [(<a>A</a>,
--   <a>A</a>)]</tt></li>
--   <li><tt>-package foo (A as B)</tt> is <tt>ModRenaming False
--   [(<a>A</a>, <a>B</a>)]</tt></li>
--   <li><tt>-package foo with (A as B)</tt> is <tt>ModRenaming True
--   [(<a>A</a>, <a>B</a>)]</tt></li>
--   </ul>
data ModRenaming
ModRenaming :: Bool -> [(ModuleName, ModuleName)] -> ModRenaming

-- | Bring all exposed modules into scope?
[modRenamingWithImplicit] :: ModRenaming -> Bool

-- | Bring module <tt>m</tt> into scope under name <tt>n</tt>.
[modRenamings] :: ModRenaming -> [(ModuleName, ModuleName)]
packageFlagsChanged :: DynFlags -> DynFlags -> Bool

-- | Flags for manipulating the set of non-broken packages.
newtype IgnorePackageFlag

-- | <pre>
--   -ignore-package
--   </pre>
IgnorePackage :: String -> IgnorePackageFlag

-- | Flags for manipulating package trust.
data TrustFlag

-- | <pre>
--   -trust
--   </pre>
TrustPackage :: String -> TrustFlag

-- | <pre>
--   -distrust
--   </pre>
DistrustPackage :: String -> TrustFlag
data PackageDBFlag
PackageDB :: PkgDbRef -> PackageDBFlag
NoUserPackageDB :: PackageDBFlag
NoGlobalPackageDB :: PackageDBFlag
ClearPackageDBs :: PackageDBFlag
data PkgDbRef
GlobalPkgDb :: PkgDbRef
UserPkgDb :: PkgDbRef
PkgDbPath :: FilePath -> PkgDbRef

-- | When invoking external tools as part of the compilation pipeline, we
--   pass these a sequence of options on the command-line. Rather than just
--   using a list of Strings, we use a type that allows us to distinguish
--   between filepaths and 'other stuff'. The reason for this is that this
--   type gives us a handle on transforming filenames, and filenames only,
--   to whatever format they're expected to be on a particular platform.
data Option
FileOption :: String -> String -> Option
Option :: String -> Option
showOpt :: Option -> String
data DynLibLoader
Deployable :: DynLibLoader
SystemDependent :: DynLibLoader

-- | These <tt>-f&lt;blah&gt;</tt> flags can all be reversed with
--   <tt>-fno-&lt;blah&gt;</tt>
fFlags :: [FlagSpec GeneralFlag]

-- | These <tt>-f&lt;blah&gt;</tt> flags can all be reversed with
--   <tt>-fno-&lt;blah&gt;</tt>
fLangFlags :: [FlagSpec Extension]

-- | These -X<a>blah</a> flags can all be reversed with -XNo<a>blah</a>
xFlags :: [FlagSpec Extension]

-- | These <tt>-W&lt;blah&gt;</tt> flags can all be reversed with
--   <tt>-Wno-&lt;blah&gt;</tt>
wWarningFlags :: [FlagSpec WarningFlag]

-- | Resolve any internal inconsistencies in a set of <a>DynFlags</a>.
--   Returns the consistent <a>DynFlags</a> as well as a list of warnings
--   to report to the user.
makeDynFlagsConsistent :: DynFlags -> (DynFlags, [Warn])

-- | Are we building with <tt>-fPIE</tt> or <tt>-fPIC</tt> enabled?
positionIndependent :: DynFlags -> Bool

-- | The set of flags which affect optimisation for the purposes of
--   recompilation avoidance. Specifically, these include flags which
--   affect code generation but not the semantics of the program.
--   
--   See Note [Ignoring some flag changes] in GHC.Iface.Recomp.Flags)
optimisationFlags :: EnumSet GeneralFlag

-- | The set of flags which affect code generation and can change a
--   program's runtime behavior (other than performance). These include
--   flags which affect:
--   
--   <ul>
--   <li>user visible debugging information (e.g. info table
--   provenance)</li>
--   <li>the ability to catch runtime errors (e.g. -fignore-asserts)</li>
--   <li>the runtime result of the program (e.g. -fomit-yields)</li>
--   <li>which code or interface file declarations are emitted</li>
--   </ul>
--   
--   We also considered placing flags which affect asympototic space
--   behavior (e.g. -ffull-laziness) however this would mean that changing
--   optimisation levels would trigger recompilation even with
--   -fignore-optim-changes, regressing #13604.
--   
--   Also, arguably Opt_IgnoreAsserts should be here as well; however, we
--   place it instead in <a>optimisationFlags</a> since it is implied by
--   <tt>-O[12]</tt> and therefore would also break #13604.
--   
--   See #23369.
codeGenFlags :: EnumSet GeneralFlag
setFlagsFromEnvFile :: FilePath -> String -> DynP ()

-- | Pretty-print the difference between 2 DynFlags.
--   
--   For now only their general flags but it could be extended. Useful
--   mostly for debugging.
pprDynFlagsDiff :: DynFlags -> DynFlags -> SDoc

-- | Find the <a>FlagSpec</a> for a <a>WarningFlag</a>.
flagSpecOf :: WarningFlag -> Maybe (FlagSpec WarningFlag)

-- | Get target profile
targetProfile :: DynFlags -> Profile

-- | Is Safe Haskell on in some way (including inference mode)
safeHaskellOn :: DynFlags -> Bool
safeHaskellModeEnabled :: DynFlags -> Bool

-- | Test if Safe Imports are on in some form
safeImportsOn :: DynFlags -> Bool

-- | Is the Safe Haskell safe language in use
safeLanguageOn :: DynFlags -> Bool

-- | Is the Safe Haskell safe inference mode active
safeInferOn :: DynFlags -> Bool

-- | Is the -fpackage-trust mode on
packageTrustOn :: DynFlags -> Bool

-- | Are all direct imports required to be safe for this Safe Haskell mode?
--   Direct imports are when the code explicitly imports a module
safeDirectImpsReq :: DynFlags -> Bool

-- | Are all implicit imports required to be safe for this Safe Haskell
--   mode? Implicit imports are things in the prelude. e.g System.IO when
--   print is used.
safeImplicitImpsReq :: DynFlags -> Bool

-- | A list of unsafe flags under Safe Haskell. Tuple elements are: * name
--   of the flag * function to get srcspan that enabled the flag * function
--   to test if the flag is on * function to turn the flag off
unsafeFlags :: [(Extension, DynFlags -> SrcSpan, DynFlags -> Bool, DynFlags -> DynFlags)]

-- | A list of unsafe flags under Safe Haskell. Tuple elements are: * name
--   of the flag * function to get srcspan that enabled the flag * function
--   to test if the flag is on * function to turn the flag off
unsafeFlagsForInfer :: [(Extension, DynFlags -> SrcSpan, DynFlags -> Bool, DynFlags -> DynFlags)]
data Settings
Settings :: {-# UNPACK #-} !GhcNameVersion -> {-# UNPACK #-} !FileSettings -> Platform -> {-# UNPACK #-} !ToolSettings -> {-# UNPACK #-} !PlatformMisc -> [(String, String)] -> Settings
[sGhcNameVersion] :: Settings -> {-# UNPACK #-} !GhcNameVersion
[sFileSettings] :: Settings -> {-# UNPACK #-} !FileSettings
[sTargetPlatform] :: Settings -> Platform
[sToolSettings] :: Settings -> {-# UNPACK #-} !ToolSettings
[sPlatformMisc] :: Settings -> {-# UNPACK #-} !PlatformMisc
[sRawSettings] :: Settings -> [(String, String)]
sProgramName :: Settings -> String
sProjectVersion :: Settings -> String
sGhcUsagePath :: Settings -> FilePath
sGhciUsagePath :: Settings -> FilePath
sToolDir :: Settings -> Maybe FilePath
sTopDir :: Settings -> FilePath
sGlobalPackageDatabasePath :: Settings -> FilePath
sLdSupportsCompactUnwind :: Settings -> Bool
sLdSupportsFilelist :: Settings -> Bool
sLdIsGnuLd :: Settings -> Bool
sGccSupportsNoPie :: Settings -> Bool
sPgm_L :: Settings -> String
sPgm_P :: Settings -> (String, [Option])
sPgm_F :: Settings -> String
sPgm_c :: Settings -> String
sPgm_cxx :: Settings -> String
sPgm_cpp :: Settings -> (String, [Option])
sPgm_a :: Settings -> (String, [Option])
sPgm_l :: Settings -> (String, [Option])
sPgm_lm :: Settings -> Maybe (String, [Option])
sPgm_windres :: Settings -> String
sPgm_ar :: Settings -> String
sPgm_ranlib :: Settings -> String
sPgm_lo :: Settings -> (String, [Option])
sPgm_lc :: Settings -> (String, [Option])
sPgm_las :: Settings -> (String, [Option])
sPgm_i :: Settings -> String
sOpt_L :: Settings -> [String]
sOpt_P :: Settings -> [String]
sOpt_P_fingerprint :: Settings -> Fingerprint
sOpt_JSP :: Settings -> [String]
sOpt_JSP_fingerprint :: Settings -> Fingerprint
sOpt_CmmP :: Settings -> [String]
sOpt_CmmP_fingerprint :: Settings -> Fingerprint
sOpt_F :: Settings -> [String]
sOpt_c :: Settings -> [String]
sOpt_cxx :: Settings -> [String]
sOpt_a :: Settings -> [String]
sOpt_l :: Settings -> [String]
sOpt_lm :: Settings -> [String]
sOpt_windres :: Settings -> [String]
sOpt_lo :: Settings -> [String]
sOpt_lc :: Settings -> [String]
sOpt_i :: Settings -> [String]
sExtraGccViaCFlags :: Settings -> [String]
sTargetPlatformString :: Settings -> String
sGhcWithInterpreter :: Settings -> Bool
sLibFFI :: Settings -> Bool
sTargetRTSLinkerOnlySupportsSharedLibs :: Settings -> Bool

-- | Settings for what GHC this is.
data GhcNameVersion
GhcNameVersion :: String -> String -> GhcNameVersion
[ghcNameVersion_programName] :: GhcNameVersion -> String
[ghcNameVersion_projectVersion] :: GhcNameVersion -> String

-- | Paths to various files and directories used by GHC, including those
--   that provide more settings.
data FileSettings
FileSettings :: FilePath -> FilePath -> Maybe FilePath -> FilePath -> FilePath -> FileSettings
[fileSettings_ghcUsagePath] :: FileSettings -> FilePath
[fileSettings_ghciUsagePath] :: FileSettings -> FilePath
[fileSettings_toolDir] :: FileSettings -> Maybe FilePath
[fileSettings_topDir] :: FileSettings -> FilePath
[fileSettings_globalPackageDatabase] :: FileSettings -> FilePath

-- | Platform-specific settings formerly hard-coded in Config.hs.
--   
--   These should probably be all be triaged whether they can be computed
--   from other settings or belong in another another place (like
--   <a>Platform</a> above).
data PlatformMisc
PlatformMisc :: String -> Bool -> Bool -> String -> Bool -> PlatformMisc
[platformMisc_targetPlatformString] :: PlatformMisc -> String
[platformMisc_ghcWithInterpreter] :: PlatformMisc -> Bool
[platformMisc_libFFI] :: PlatformMisc -> Bool
[platformMisc_llvmTarget] :: PlatformMisc -> String
[platformMisc_targetRTSLinkerOnlySupportsSharedLibs] :: PlatformMisc -> Bool

-- | "unbuild" a <a>Settings</a> from a <a>DynFlags</a>. This shouldn't be
--   needed in the vast majority of code. But GHCi questionably uses this
--   to produce a default <a>DynFlags</a> from which to compute a flags
--   diff for printing.
settings :: DynFlags -> Settings
programName :: DynFlags -> String
projectVersion :: DynFlags -> String
ghcUsagePath :: DynFlags -> FilePath
ghciUsagePath :: DynFlags -> FilePath
topDir :: DynFlags -> FilePath

-- | The directory for this version of ghc in the user's app directory The
--   appdir used to be in ~/.ghc but to respect the XDG specification we
--   want to move it under $XDG_DATA_HOME/ However, old tooling (like
--   cabal) might still write package environments to the old directory, so
--   we prefer that if a subdirectory of ~/.ghc with the correct target and
--   GHC version suffix exists.
--   
--   i.e. if ~<i>.ghc</i>$UNIQUE_SUBDIR exists we use that otherwise we use
--   $XDG_DATA_HOME/$UNIQUE_SUBDIR
--   
--   UNIQUE_SUBDIR is typically a combination of the target platform and
--   GHC version
versionedAppDir :: String -> ArchOS -> MaybeT IO FilePath
versionedFilePath :: ArchOS -> FilePath
extraGccViaCFlags :: DynFlags -> [String]
globalPackageDatabasePath :: DynFlags -> FilePath
pgm_L :: DynFlags -> String
pgm_P :: DynFlags -> (String, [Option])
pgm_JSP :: DynFlags -> (String, [Option])
pgm_CmmP :: DynFlags -> (String, [Option])
pgm_F :: DynFlags -> String
pgm_c :: DynFlags -> String
pgm_cxx :: DynFlags -> String
pgm_cpp :: DynFlags -> (String, [Option])
pgm_a :: DynFlags -> (String, [Option])
pgm_l :: DynFlags -> (String, [Option])
pgm_lm :: DynFlags -> Maybe (String, [Option])
pgm_windres :: DynFlags -> String
pgm_ar :: DynFlags -> String
pgm_ranlib :: DynFlags -> String
pgm_lo :: DynFlags -> (String, [Option])
pgm_lc :: DynFlags -> (String, [Option])
pgm_las :: DynFlags -> (String, [Option])
pgm_i :: DynFlags -> String
opt_L :: DynFlags -> [String]
opt_P :: DynFlags -> [String]
opt_JSP :: DynFlags -> [String]
opt_CmmP :: DynFlags -> [String]
opt_F :: DynFlags -> [String]
opt_c :: DynFlags -> [String]
opt_cxx :: DynFlags -> [String]
opt_a :: DynFlags -> [String]
opt_l :: DynFlags -> [String]
opt_lm :: DynFlags -> [String]
opt_i :: DynFlags -> [String]
opt_P_signature :: DynFlags -> ([String], Fingerprint)
opt_JSP_signature :: DynFlags -> ([String], Fingerprint)
opt_CmmP_signature :: DynFlags -> Fingerprint
opt_windres :: DynFlags -> [String]
opt_lo :: DynFlags -> [String]
opt_lc :: DynFlags -> [String]
opt_las :: DynFlags -> [String]
updatePlatformConstants :: DynFlags -> Maybe PlatformConstants -> IO DynFlags
addPluginModuleName :: String -> DynFlags -> DynFlags

-- | The normal <a>DynFlags</a>. Note that they are not suitable for use in
--   this form and must be fully initialized by <a>runGhc</a> first.
defaultDynFlags :: Settings -> DynFlags

-- | Used by <a>runGhc</a> to partially initialize a new <a>DynFlags</a>
--   value
initDynFlags :: DynFlags -> IO DynFlags
defaultFatalMessager :: FatalMessager
defaultFlushOut :: FlushOut
setOutputFile :: Maybe String -> DynFlags -> DynFlags
setDynOutputFile :: Maybe String -> DynFlags -> DynFlags
setOutputHi :: Maybe String -> DynFlags -> DynFlags
setDynOutputHi :: Maybe String -> DynFlags -> DynFlags
augmentByWorkingDirectory :: DynFlags -> FilePath -> FilePath

-- | Retrieve the options corresponding to a particular <tt>opt_*</tt>
--   field in the correct order
getOpts :: DynFlags -> (DynFlags -> [a]) -> [a]

-- | Gets the verbosity flag for the current verbosity level. This is fed
--   to other tools, so GHC-specific verbosity flags like
--   <tt>-ddump-most</tt> are not included
getVerbFlags :: DynFlags -> [String]

-- | Sets the <a>DynFlags</a> to be appropriate to the optimisation level
updOptLevel :: Int -> DynFlags -> DynFlags
setTmpDir :: FilePath -> DynFlags -> DynFlags
setUnitId :: String -> DynFlags -> DynFlags
type TurnOnFlag = Bool
turnOn :: TurnOnFlag
turnOff :: TurnOnFlag
impliedGFlags :: [(GeneralFlag, TurnOnFlag, GeneralFlag)]
impliedOffGFlags :: [(GeneralFlag, TurnOnFlag, GeneralFlag)]
impliedXFlags :: [(Extension, TurnOnFlag, Extension)]
newtype CmdLineP s a
CmdLineP :: (forall (m :: Type -> Type). Monad m => StateT s m a) -> CmdLineP s a
runCmdLineP :: CmdLineP s a -> s -> (a, s)
getCmdLineState :: CmdLineP s s
putCmdLineState :: s -> CmdLineP s ()

-- | A helper to parse a set of flags from a list of command-line
--   arguments, handling response files.
processCmdLineP :: forall s m. MonadIO m => [Flag (CmdLineP s)] -> s -> [Located String] -> m (([Located String], [Err], [Warn]), s)

-- | Parse dynamic flags from a list of command line arguments. Returns the
--   parsed <a>DynFlags</a>, the left-over arguments, and a list of
--   warnings. Throws a <a>UsageError</a> if errors occurred during parsing
--   (such as unknown flags or missing arguments).
parseDynamicFlagsCmdLine :: MonadIO m => DynFlags -> [Located String] -> m (DynFlags, [Located String], Messages DriverMessage)

-- | Like <a>parseDynamicFlagsCmdLine</a> but does not allow the package
--   flags (-package, -hide-package, -ignore-package, -hide-all-packages,
--   -package-db). Used to parse flags set in a modules pragma.
parseDynamicFilePragma :: MonadIO m => DynFlags -> [Located String] -> m (DynFlags, [Located String], Messages DriverMessage)

-- | Parses the dynamically set flags for GHC. This is the most general
--   form of the dynamic flag parser that the other methods simply wrap. It
--   allows saying which flags are valid flags and indicating if we are
--   parsing arguments from the command line or from a file pragma.
parseDynamicFlagsFull :: MonadIO m => [Flag (CmdLineP DynFlags)] -> Bool -> DynFlags -> [Located String] -> m (DynFlags, [Located String], Messages DriverMessage)

-- | Produce a list of suggestions for a user provided flag that is
--   invalid.
flagSuggestions :: [String] -> String -> [String]

-- | All dynamic flags option strings without the deprecated ones. These
--   are the user facing strings for enabling and disabling options.
allNonDeprecatedFlags :: [String]
flagsAll :: [Flag (CmdLineP DynFlags)]
flagsDynamic :: [Flag (CmdLineP DynFlags)]
flagsPackage :: [Flag (CmdLineP DynFlags)]

-- | Make a list of flags for shell completion. Filter all available flags
--   into two groups, for interactive GHC vs all other.
flagsForCompletion :: Bool -> [String]
supportedLanguagesAndExtensions :: ArchOS -> [String]

-- | The language extensions implied by the various language variants. When
--   updating this be sure to update the flag documentation in
--   <tt>docs<i>users_guide</i>exts</tt>.
languageExtensions :: Maybe Language -> [Extension]
picCCOpts :: DynFlags -> [String]
picPOpts :: DynFlags -> [String]
pieCCLDOpts :: DynFlags -> [String]
compilerInfo :: DynFlags -> [(String, String)]
wordAlignment :: Platform -> Alignment
setUnsafeGlobalDynFlags :: DynFlags -> IO ()
isSse4_2Enabled :: DynFlags -> Bool
isBmiEnabled :: DynFlags -> Bool
isBmi2Enabled :: DynFlags -> Bool
isAvxEnabled :: DynFlags -> Bool
isAvx2Enabled :: DynFlags -> Bool
isAvx512cdEnabled :: DynFlags -> Bool
isAvx512erEnabled :: DynFlags -> Bool
isAvx512fEnabled :: DynFlags -> Bool
isAvx512pfEnabled :: DynFlags -> Bool
isFmaEnabled :: DynFlags -> Bool

-- | Should we use `-XLinker -rpath` when linking or not? See Note
--   [-fno-use-rpaths]
useXLinkerRPath :: DynFlags -> OS -> Bool

-- | Used to differentiate the scope an include needs to apply to. We have
--   to split the include paths to avoid accidentally forcing recursive
--   includes since -I overrides the system search paths. See #14312.
data IncludeSpecs
IncludeSpecs :: [String] -> [String] -> [String] -> IncludeSpecs
[includePathsQuote] :: IncludeSpecs -> [String]
[includePathsGlobal] :: IncludeSpecs -> [String]

-- | See Note [Implicit include paths]
[includePathsQuoteImplicit] :: IncludeSpecs -> [String]

-- | Append to the list of includes a path that shall be included using
--   `-I` when the C compiler is called. These paths override system search
--   paths.
addGlobalInclude :: IncludeSpecs -> [String] -> IncludeSpecs

-- | Append to the list of includes a path that shall be included using
--   `-iquote` when the C compiler is called. These paths only apply when
--   quoted includes are used. e.g. #include "foo.h"
addQuoteInclude :: IncludeSpecs -> [String] -> IncludeSpecs

-- | Concatenate and flatten the list of global and quoted includes
--   returning just a flat list of paths.
flattenIncludes :: IncludeSpecs -> [String]

-- | These includes are not considered while fingerprinting the flags for
--   iface | See Note [Implicit include paths]
addImplicitQuoteInclude :: IncludeSpecs -> [String] -> IncludeSpecs

-- | Initialize the pretty-printing options
initSDocContext :: DynFlags -> PprStyle -> SDocContext

-- | Initialize the pretty-printing options using the default user style
initDefaultSDocContext :: DynFlags -> SDocContext
initPromotionTickContext :: DynFlags -> PromotionTickContext
instance GHC.Internal.Base.Applicative (GHC.Driver.Session.CmdLineP s)
instance GHC.Internal.Base.Functor (GHC.Driver.Session.CmdLineP s)
instance GHC.Internal.Base.Monad (GHC.Driver.Session.CmdLineP s)

module GHC.SysTools.Tasks
runUnlit :: Logger -> DynFlags -> [Option] -> IO ()

-- | Prepend the working directory to the search path. Note [Filepaths and
--   Multiple Home Units]
augmentImports :: DynFlags -> [FilePath] -> [FilePath]

-- | Discard some harmless warnings from gcc that we can't turn off
cc_filter :: String -> String

-- | See the Note [Preprocessing invocations]
data SourceCodePreprocessor

-- | Use the ordinary C preprocessor
SCPCpp :: SourceCodePreprocessor

-- | Use the Haskell C preprocessor (don't remove C comments, don't break
--   on names including single quotes)
SCPHsCpp :: SourceCodePreprocessor

-- | Use the JavaScript preprocessor (don't remove jsdoc and multiline
--   comments)
SCPJsCpp :: SourceCodePreprocessor

-- | Use the C-- preprocessor (don't emit debug information)
SCPCmmCpp :: SourceCodePreprocessor

-- | Run source code preprocessor. See also Note [Preprocessing
--   invocations] in GHC.SysTools.Cpp
runSourceCodePreprocessor :: Logger -> TmpFs -> DynFlags -> SourceCodePreprocessor -> [Option] -> IO ()
runPp :: Logger -> DynFlags -> [Option] -> IO ()

-- | Run compiler of C-like languages and raw objects (such as gcc or
--   clang).
runCc :: Maybe ForeignSrcLang -> Logger -> TmpFs -> DynFlags -> [Option] -> IO ()
isContainedIn :: String -> String -> Bool

-- | Run the linker with some arguments and return the output
askLd :: Logger -> DynFlags -> [Option] -> IO String
runAs :: Logger -> DynFlags -> [Option] -> IO ()

-- | Run the LLVM Optimiser
runLlvmOpt :: Logger -> DynFlags -> [Option] -> IO ()

-- | Run the LLVM Compiler
runLlvmLlc :: Logger -> DynFlags -> [Option] -> IO ()

-- | Run the LLVM Assembler
runLlvmAs :: Logger -> DynFlags -> [Option] -> IO ()
runEmscripten :: Logger -> DynFlags -> [Option] -> IO ()

-- | Figure out which version of LLVM we are running this session
figureLlvmVersion :: Logger -> DynFlags -> IO (Maybe LlvmVersion)
runMergeObjects :: Logger -> TmpFs -> DynFlags -> [Option] -> IO ()
runAr :: Logger -> DynFlags -> Maybe FilePath -> [Option] -> IO ()
askOtool :: Logger -> ToolSettings -> Maybe FilePath -> [Option] -> IO String
runInstallNameTool :: Logger -> ToolSettings -> [Option] -> IO ()
runRanlib :: Logger -> DynFlags -> [Option] -> IO ()
runWindres :: Logger -> DynFlags -> [Option] -> IO ()
instance GHC.Classes.Eq GHC.SysTools.Tasks.SourceCodePreprocessor

module GHC.Driver.Config.CmmToLlvm

-- | Initialize the Llvm code generator configuration from DynFlags
initLlvmCgConfig :: Logger -> LlvmConfigCache -> DynFlags -> IO LlvmCgConfig

module GHC.Driver.CodeOutput
codeOutput :: Logger -> TmpFs -> LlvmConfigCache -> DynFlags -> UnitState -> Module -> FilePath -> ModLocation -> (a -> ForeignStubs) -> [(ForeignSrcLang, FilePath)] -> Set UnitId -> DUniqSupply -> CgStream RawCmmGroup a -> IO (FilePath, (Bool, Maybe FilePath), [(ForeignSrcLang, FilePath)], a)
outputForeignStubs :: Logger -> TmpFs -> DynFlags -> UnitState -> Module -> ModLocation -> ForeignStubs -> IO (Bool, Maybe FilePath)

-- | Generate code to initialise cost centres
profilingInitCode :: Platform -> Module -> CollectedCCs -> CStub

-- | Generate code to initialise info pointer origin See Note [Mapping Info
--   Tables to Source Positions]
ipInitCode :: Bool -> Platform -> Module -> CStub

module GHC.StgToCmm.Prof
initCostCentres :: CollectedCCs -> FCode ()
ccType :: Platform -> CmmType
ccsType :: Platform -> CmmType
mkCCostCentre :: CostCentre -> CmmLit
mkCCostCentreStack :: CostCentreStack -> CmmLit

-- | Emit info-table provenance declarations and track IPE stats.
--   
--   Note that the stats passed to this function will (rather, should) only
--   ever contain stats for skipped STACK info tables accumulated in
--   <tt>generateCgIPEStub</tt>.
initInfoTableProv :: IPEStats -> [CmmInfoTable] -> InfoTableProvMap -> DUniqSupply -> FCode (Maybe (IPEStats, CStub), DUniqSupply)

-- | Profiling header words in a dynamic closure
dynProfHdr :: Profile -> CmmExpr -> [CmmExpr]

-- | Record the allocation of a closure. The CmmExpr is the cost centre
--   stack to which to attribute the allocation.
profDynAlloc :: SMRep -> CmmExpr -> FCode ()

-- | Record the allocation of a closure (size is given by a CmmExpr) The
--   size must be in words, because the allocation counter in a CCS counts
--   in words.
profAlloc :: CmmExpr -> CmmExpr -> FCode ()

-- | The profiling header words in a static closure
staticProfHdr :: Profile -> CostCentreStack -> [CmmLit]

-- | Initialise the profiling field of an update frame
initUpdFrameProf :: CmmExpr -> FCode ()
enterCostCentreThunk :: CmmExpr -> FCode ()
enterCostCentreFun :: CostCentreStack -> CmmExpr -> FCode ()
costCentreFrom :: Platform -> CmmExpr -> CmmExpr
storeCurCCS :: Platform -> CmmExpr -> CmmAGraph
emitSetCCC :: CostCentre -> Bool -> Bool -> FCode ()
saveCurrentCostCentre :: FCode (Maybe LocalReg)
restoreCurrentCostCentre :: Platform -> Maybe LocalReg -> FCode ()
ldvEnter :: CmmExpr -> FCode ()

-- | Called when a closure is entered, marks the closure as having been
--   "used". The closure is not an "inherently used" one. The closure is
--   not <tt>IND</tt> because that is not considered for LDV profiling.
ldvEnterClosure :: ClosureInfo -> CmmReg -> FCode ()

-- | Initialise the profiling word of a new dynamic closure * When LDV
--   profiling is enabled (era &gt; 0) - Initialise to the LDV word * When
--   eras profiling is enabled (user_era &gt; 0) - Initialise to current
--   user_era
profHeaderCreate :: CmmExpr -> FCode ()

module GHC.StgToCmm.Heap
getVirtHp :: FCode VirtualHpOffset
setVirtHp :: VirtualHpOffset -> FCode ()
setRealHp :: VirtualHpOffset -> FCode ()
getHpRelOffset :: VirtualHpOffset -> FCode CmmExpr
entryHeapCheck :: ClosureInfo -> Maybe LocalReg -> Int -> [LocalReg] -> FCode () -> FCode ()
altHeapCheck :: [LocalReg] -> FCode a -> FCode a
noEscapeHeapCheck :: [LocalReg] -> FCode a -> FCode a
altHeapCheckReturnsTo :: [LocalReg] -> Label -> ByteOff -> FCode a -> FCode a
heapStackCheckGen :: Maybe CmmExpr -> Maybe CmmExpr -> FCode ()

-- | lower-level version for <a>GHC.Cmm.Parser</a>
entryHeapCheck' :: Bool -> CmmExpr -> Int -> [LocalReg] -> FCode () -> FCode ()

-- | Make a static closure, adding on any extra padding needed for CAFs,
--   and adding a static link field if necessary.
mkStaticClosureFields :: Profile -> CmmInfoTable -> CostCentreStack -> CafInfo -> [CmmLit] -> [CmmLit] -> [CmmLit]
mkStaticClosure :: Profile -> CLabel -> CostCentreStack -> [CmmLit] -> [CmmLit] -> [CmmLit] -> [CmmLit] -> [CmmLit] -> [CmmLit]
allocDynClosure :: Maybe Id -> CmmInfoTable -> LambdaFormInfo -> CmmExpr -> CmmExpr -> [(NonVoid StgArg, VirtualHpOffset)] -> FCode CmmExpr
allocDynClosureCmm :: Maybe Id -> CmmInfoTable -> LambdaFormInfo -> CmmExpr -> CmmExpr -> [(CmmExpr, ByteOff)] -> FCode CmmExpr

-- | Low-level heap object allocation.
allocHeapClosure :: SMRep -> CmmExpr -> CmmExpr -> [(CmmExpr, ByteOff)] -> FCode CmmExpr
emitSetDynHdr :: CmmExpr -> CmmExpr -> CmmExpr -> FCode ()

module GHC.Cmm.Info.Build
type CAFSet = Set CAFfyLabel
type CAFEnv = LabelMap CAFSet

-- | For each code block: - collect the references reachable from this code
--   block to FUN, THUNK or RET labels for which <tt>hasCAF == True</tt>
--   
--   This gives us a <a>CAFEnv</a>: a mapping from code block to sets of
--   labels
cafAnal :: Platform -> LabelSet -> CLabel -> CmmGraph -> CAFEnv

-- | Collect possible CAFfy references from a <a>CmmData</a> decl.
cafAnalData :: Platform -> CmmStatics -> CAFSet

-- | Attach SRTs to all info tables in the <a>CmmDecl</a>s, and add SRT
--   declarations to the <a>ModuleSRTInfo</a>.
doSRTs :: CmmConfig -> ModuleSRTInfo -> DUniqSupply -> [(CAFEnv, [CmmDecl])] -> [(CAFSet, CmmDataDecl)] -> IO (ModuleSRTInfo, DUniqSupply, [CmmDeclSRTs])
data ModuleSRTInfo
ModuleSRTInfo :: Module -> Map (Set SRTEntry) SRTEntry -> Map SRTEntry (Set SRTEntry) -> SRTMap -> ModuleSRTInfo

-- | Current module being compiled. Required for calling labelDynamic.
[thisModule] :: ModuleSRTInfo -> Module

-- | previous SRTs we've emitted, so we can de-duplicate. Used to implement
--   the [Common] optimisation.
[dedupSRTs] :: ModuleSRTInfo -> Map (Set SRTEntry) SRTEntry

-- | The reverse mapping, so that we can remove redundant entries. e.g. if
--   we have an SRT [a,b,c], and we know that b points to [c,d], we can
--   omit c and emit [a,b]. Used to implement the [Filter] optimisation.
[flatSRTs] :: ModuleSRTInfo -> Map SRTEntry (Set SRTEntry)
[moduleSRTMap] :: ModuleSRTInfo -> SRTMap
emptySRT :: Module -> ModuleSRTInfo

-- | Maps labels from <a>cafAnal</a> to the final CLabel that will appear
--   in the SRT. - closures with singleton SRTs resolve to their single
--   entry - closures with larger SRTs map to the label for that SRT - CAFs
--   must not map to anything! - if a labels maps to Nothing, we found that
--   this label's SRT is empty, so we don't need to refer to it from other
--   SRTs.
type SRTMap = Map CAFfyLabel Maybe SRTEntry

-- | Given <a>SRTMap</a> of a module, returns the set of non-CAFFY names in
--   the module. Any <tt>Name</tt>s not in the set are CAFFY.
srtMapNonCAFs :: SRTMap -> NonCaffySet
instance GHC.Classes.Eq GHC.Cmm.Info.Build.CAFfyLabel
instance GHC.Classes.Eq GHC.Cmm.Info.Build.SRTEntry
instance GHC.Classes.Eq GHC.Cmm.Info.Build.SomeLabel
instance GHC.Classes.Ord GHC.Cmm.Info.Build.CAFfyLabel
instance GHC.Classes.Ord GHC.Cmm.Info.Build.SRTEntry
instance GHC.Classes.Ord GHC.Cmm.Info.Build.SomeLabel
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.CLabel.CLabel => GHC.Utils.Outputable.OutputableP env GHC.Cmm.Info.Build.CAFfyLabel
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.CLabel.CLabel => GHC.Utils.Outputable.OutputableP env GHC.Cmm.Info.Build.ModuleSRTInfo
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.CLabel.CLabel => GHC.Utils.Outputable.OutputableP env GHC.Cmm.Info.Build.SRTEntry
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.CLabel.CLabel => GHC.Utils.Outputable.OutputableP env GHC.Cmm.Info.Build.SomeLabel

module GHC.StgToCmm.Foreign

-- | Emit code for a foreign call, and return the results to the sequel.
--   Precondition: the length of the arguments list is the same as the
--   arity of the foreign function.
cgForeignCall :: ForeignCall -> Type -> [StgArg] -> Type -> FCode ReturnKind
emitPrimCall :: [CmmFormal] -> CallishMachOp -> [CmmActual] -> FCode ()
emitCCall :: [(CmmFormal, ForeignHint)] -> CmmExpr -> [(CmmActual, ForeignHint)] -> FCode ()
emitCCallNeverReturns :: [(CmmFormal, ForeignHint)] -> CmmExpr -> [(CmmActual, ForeignHint)] -> FCode ()
emitForeignCall :: Safety -> [CmmFormal] -> ForeignTarget -> [CmmActual] -> FCode ReturnKind
emitSaveThreadState :: FCode ()

-- | Produce code to save the current thread state to <tt>CurrentTSO</tt>
saveThreadState :: MonadGetUnique m => Profile -> m CmmAGraph
emitLoadThreadState :: FCode ()

-- | Save STG registers
--   
--   STG registers must be saved around a C call, just in case the STG
--   register is mapped to a caller-saves machine register. Normally we
--   don't need to worry about this the code generator has already loaded
--   any live STG registers into variables for us, but in hand-written
--   low-level Cmm code where we don't know which registers are live, we
--   might have to save them all.
emitSaveRegs :: GlobalArgRegs -> FCode ()

-- | Restore STG registers (see <a>emitSaveRegs</a>)
emitRestoreRegs :: GlobalArgRegs -> FCode ()

-- | Push a subset of STG registers onto the stack, specified by the bitmap
--   
--   Sometimes, a "live" subset of the STG registers needs to be saved on
--   the stack, for example when storing an unboxed tuple to be used in the
--   GHCi bytecode interpreter.
--   
--   The "live registers" bitmap corresponds to the list of registers given
--   by <a>allArgRegsCover</a>, with the least significant bit indicating
--   liveness of the first register in the list.
--   
--   Each register is saved to a stack slot of one or more machine words,
--   even if the register size itself is smaller.
--   
--   The resulting Cmm code looks like this, with a line for each real or
--   virtual register used for returning tuples:
--   
--   ... if((mask &amp; 2) != 0) { Sp_adj(-1); Sp(0) = R2; } if((mask &amp;
--   1) != 0) { Sp_adj(-1); Sp(0) = R1; }
--   
--   See Note [GHCi and native call registers]
emitPushArgRegs :: GlobalArgRegs -> CmmExpr -> FCode ()

-- | Pop a subset of STG registers from the stack (see
--   <a>emitPushArgRegs</a>)
emitPopArgRegs :: GlobalArgRegs -> CmmExpr -> FCode ()

-- | Produce code to load the current thread state from <tt>CurrentTSO</tt>
loadThreadState :: MonadGetUnique m => Profile -> m CmmAGraph
emitOpenNursery :: FCode ()
emitCloseNursery :: FCode ()

module GHC.StgToCmm.Prim
cgOpApp :: StgOp -> [StgArg] -> Type -> FCode ReturnKind
shouldInlinePrimOp :: StgToCmmConfig -> PrimOp -> [CmmExpr] -> Bool

module GHC.Cmm.LayoutStack
cmmLayoutStack :: CmmConfig -> ProcPointSet -> ByteOff -> CmmGraph -> UniqDSM (CmmGraph, LabelMap StackMap)
setInfoTableStackMap :: Platform -> LabelMap StackMap -> CmmDecl -> CmmDecl
instance GHC.Utils.Outputable.Outputable GHC.Cmm.LayoutStack.StackMap
instance GHC.Utils.Outputable.Outputable GHC.Cmm.LayoutStack.StackSlot

module GHC.Cmm.Pipeline

-- | Top level driver for C-- pipeline
--   
--   Converts C-- with an implicit stack and native C-- calls into
--   optimized, CPS converted and native-call-less C--. The latter C-- can
--   be used to generate assembly.
cmmPipeline :: Logger -> CmmConfig -> ModuleSRTInfo -> CmmGroup -> DUniqSupply -> IO ((ModuleSRTInfo, CmmGroupSRTs), DUniqSupply)

module GHC.SysTools
initSysTools :: String -> IO Settings

-- | Copy a file with its permissions. If the destination file already
--   exists, it is replaced atomically. Neither path may refer to an
--   existing directory. No exceptions are thrown if the permissions could
--   not be copied.
copyFile :: FilePath -> FilePath -> IO ()

-- | Copy remaining bytes from the first Handle to the second one
copyHandle :: Handle -> Handle -> IO ()

-- | Copy file after printing the given header
copyWithHeader :: String -> FilePath -> FilePath -> IO ()

-- | When invoking external tools as part of the compilation pipeline, we
--   pass these a sequence of options on the command-line. Rather than just
--   using a list of Strings, we use a type that allows us to distinguish
--   between filepaths and 'other stuff'. The reason for this is that this
--   type gives us a handle on transforming filenames, and filenames only,
--   to whatever format they're expected to be on a particular platform.
data Option
FileOption :: String -> String -> Option
Option :: String -> Option

-- | Expand occurrences of the <tt>$topdir</tt> interpolation in a string.
expandTopDir :: FilePath -> String -> String

module GHC.SysTools.Cpp

-- | Run either the Haskell preprocessor, JavaScript preprocessor or the C
--   preprocessor, as per the <a>CppOpts</a> passed. See Note
--   [Preprocessing invocations].
--   
--   UnitEnv is needed to compute MIN_VERSION macros
--   
--   If you change the macros defined by this function make sure to update
--   the user guide.
doCpp :: Logger -> TmpFs -> DynFlags -> UnitEnv -> CppOpts -> FilePath -> FilePath -> IO ()
data CppOpts
CppOpts :: !SourceCodePreprocessor -> !Bool -> CppOpts
[sourceCodePreprocessor] :: CppOpts -> !SourceCodePreprocessor

-- | Enable generation of LINE pragmas
[cppLinePragmas] :: CppOpts -> !Bool

-- | Find out path to <tt>ghcversion.h</tt> file
getGhcVersionPathName :: DynFlags -> UnitEnv -> IO FilePath
applyCDefs :: DefunctionalizedCDefs -> Logger -> DynFlags -> IO [String]
offsetIncludePaths :: DynFlags -> IncludeSpecs -> IncludeSpecs


-- | Various utilies used in the JS Linker
module GHC.StgToJS.Linker.Utils

-- | Construct the Filename for the "binary" of Haskell code compiled to
--   JavaScript.
jsExeFileName :: DynFlags -> FilePath

-- | Retrieve library directories provided by the <tt>UnitId</tt> in
--   <tt>UnitState</tt>
getInstalledPackageLibDirs :: UnitState -> UnitId -> [ShortText]

-- | Retrieve the names of the libraries provided by <tt>UnitId</tt>
getInstalledPackageHsLibs :: UnitState -> UnitId -> [ShortText]

-- | CPP definitions that are inserted into every .pp file
commonCppDefs :: Bool -> ByteString
decodeModifiedUTF8 :: ByteString -> Maybe FastString


-- | GHCJS linker, collects dependencies from the object files which
--   contain linkable units with dependency information
module GHC.StgToJS.Linker.Linker
jsLinkBinary :: FinderCache -> JSLinkConfig -> StgToJSConfig -> Logger -> TmpFs -> DynFlags -> UnitEnv -> [FilePath] -> [UnitId] -> IO ()

-- | link and write result to disk (jsexe directory)
jsLink :: JSLinkConfig -> StgToJSConfig -> Logger -> TmpFs -> ArchiveCache -> FilePath -> LinkPlan -> IO ()

-- | Embed a JS file into a JS object .o file
--   
--   JS files may contain option pragmas of the form: //#OPTIONS: One of
--   those is //#OPTIONS:CPP. When it is set, we append some common CPP
--   definitions to the file and call cpp on it.
--   
--   Other options (e.g. EMCC additional flags for link time) are stored in
--   the JS object header. See JSOptions.
embedJsFile :: Logger -> DynFlags -> TmpFs -> UnitEnv -> FilePath -> FilePath -> IO ()

-- | Initialize a global object.
--   
--   All global objects have to be declared (staticInfoDecl) first.
staticInitStat :: StaticInfo -> JStat

-- | declare and do first-pass init of a global object (create JS object
--   for heap objects)
staticDeclStat :: StaticInfo -> JStat

-- | Given a <tt>UnitId</tt>, a module name, and a set of symbols in the
--   module, package these into an <tt>ExportedFun</tt>.
mkExportedFuns :: UnitId -> FastString -> [FastString] -> [ExportedFun]

-- | Given a <tt>Module</tt> and a set of symbols in the module, package
--   these into an <tt>ExportedFun</tt>.
mkExportedModFuns :: Module -> [FastString] -> [ExportedFun]
computeLinkDependencies :: StgToJSConfig -> UnitEnv -> LinkSpec -> FinderOpts -> FinderCache -> ArchiveCache -> IO LinkPlan
data LinkSpec
LinkSpec :: [UnitId] -> (ExportedFun -> Bool) -> Set ExportedFun -> [FilePath] -> [FilePath] -> [FilePath] -> LinkSpec
[lks_unit_ids] :: LinkSpec -> [UnitId]

-- | Predicate for exported functions in objects to declare as root
[lks_obj_root_filter] :: LinkSpec -> ExportedFun -> Bool

-- | Extra root functions from loaded units
[lks_extra_roots] :: LinkSpec -> Set ExportedFun

-- | HS objects to link
[lks_objs_hs] :: LinkSpec -> [FilePath]

-- | JS objects to link
[lks_objs_js] :: LinkSpec -> [FilePath]

-- | Cc objects to link
[lks_objs_cc] :: LinkSpec -> [FilePath]
data LinkPlan
LinkPlan :: Map Module LocatedBlockInfo -> Set BlockRef -> !Set FilePath -> !Set FilePath -> !Set FilePath -> LinkPlan

-- | Block information
[lkp_block_info] :: LinkPlan -> Map Module LocatedBlockInfo

-- | Blocks to link
[lkp_dep_blocks] :: LinkPlan -> Set BlockRef

-- | Archives to load JS and Cc sources from (JS code corresponding to
--   Haskell code is handled with blocks above)
[lkp_archives] :: LinkPlan -> !Set FilePath

-- | JS objects to link
[lkp_objs_js] :: LinkPlan -> !Set FilePath

-- | Cc objects to link
[lkp_objs_cc] :: LinkPlan -> !Set FilePath
emptyLinkPlan :: LinkPlan

-- | Given a <tt>base</tt> link plan (assumed to be already linked) and a
--   <tt>new</tt> link plan, compute `(diff, total)` link plans.
--   
--   <ul>
--   <li><tt>diff</tt> is the incremental link plan to get from
--   <tt>base</tt> to <tt>total</tt></li>
--   <li><tt>total</tt> is the total link plan as if <tt>base</tt> and
--   <tt>new</tt> were linked at once</li>
--   </ul>
incrementLinkPlan :: LinkPlan -> LinkPlan -> (LinkPlan, LinkPlan)
data ArchiveCache
newArchiveCache :: IO ArchiveCache
instance GHC.Utils.Outputable.Outputable GHC.StgToJS.Linker.Linker.LinkSpec


-- | JavaScript interpreter
--   
--   See Note [The JS interpreter]
module GHC.Runtime.Interpreter.JS

-- | Spawn a JS interpreter
--   
--   Run NodeJS with "ghc-interp.js" loaded in. Then load GHCi.Server and
--   its deps (including the rts) and run GHCi.Server.defaultServer.
spawnJSInterp :: JSInterpConfig -> IO (ExtInterpInstance JSInterpExtra)

-- | Link JS RTS
jsLinkRts :: Logger -> TmpFs -> TempDir -> StgToJSConfig -> UnitEnv -> ExtInterpInstance JSInterpExtra -> IO ()

-- | Link JS interpreter
jsLinkInterp :: Logger -> TmpFs -> TempDir -> StgToJSConfig -> UnitEnv -> ExtInterpInstance JSInterpExtra -> IO ()

-- | Link an object file using the given functions as roots
jsLinkObject :: Logger -> TmpFs -> TempDir -> StgToJSConfig -> UnitEnv -> ExtInterpInstance JSInterpExtra -> FilePath -> [ExportedFun] -> IO ()

-- | Link object files
jsLinkObjects :: Logger -> TmpFs -> TempDir -> StgToJSConfig -> UnitEnv -> ExtInterpInstance JSInterpExtra -> [FilePath] -> (ExportedFun -> Bool) -> IO ()

-- | Load a JS file in the interpreter
jsLoadFile :: ExtInterpInstance JSInterpExtra -> FilePath -> IO ()

-- | Run JS server
jsRunServer :: ExtInterpInstance JSInterpExtra -> IO ()

-- | Given a <tt>Module</tt> and a set of symbols in the module, package
--   these into an <tt>ExportedFun</tt>.
mkExportedModFuns :: Module -> [FastString] -> [ExportedFun]


-- | Interacting with the iserv interpreter, whether it is running on an
--   external process or in the current process.
module GHC.Runtime.Interpreter

-- | Execute an action of type <tt>IO [a]</tt>, returning
--   <a>ForeignHValue</a>s for each of the results.
evalStmt :: Interp -> EvalOpts -> EvalExpr ForeignHValue -> IO (EvalStatus_ [ForeignHValue] [HValueRef])
data EvalStatus_ a b
EvalComplete :: Word64 -> EvalResult a -> EvalStatus_ a b
EvalBreak :: HValueRef -> Maybe EvalBreakpoint -> RemoteRef (ResumeContext b) -> RemotePtr CostCentreStack -> EvalStatus_ a b
type EvalStatus a = EvalStatus_ a a
data EvalResult a
EvalException :: SerializableException -> EvalResult a
EvalSuccess :: a -> EvalResult a

-- | We can pass simple expressions to EvalStmt, consisting of values and
--   application. This allows us to wrap the statement to be executed in
--   another function, which is used by GHCi to implement :set args and
--   :set prog. It might be worthwhile to extend this little language in
--   the future.
data EvalExpr a
EvalThis :: a -> EvalExpr a
EvalApp :: EvalExpr a -> EvalExpr a -> EvalExpr a
resumeStmt :: Interp -> EvalOpts -> ForeignRef (ResumeContext [HValueRef]) -> IO (EvalStatus_ [ForeignHValue] [HValueRef])
abandonStmt :: Interp -> ForeignRef (ResumeContext [HValueRef]) -> IO ()

-- | Execute an action of type <tt>IO ()</tt>
evalIO :: Interp -> ForeignHValue -> IO ()

-- | Execute an action of type <tt>IO String</tt>
evalString :: Interp -> ForeignHValue -> IO String

-- | Execute an action of type <tt>String -&gt; IO String</tt>
evalStringToIOString :: Interp -> ForeignHValue -> String -> IO String

-- | Allocate and store the given bytes in memory, returning a pointer to
--   the memory in the remote process.
mallocData :: Interp -> ByteString -> IO (RemotePtr ())

-- | Create a set of BCOs that may be mutually recursive.
createBCOs :: Interp -> [ResolvedBCO] -> IO [HValueRef]
addSptEntry :: Interp -> Fingerprint -> ForeignHValue -> IO ()
mkCostCentres :: Interp -> String -> [(String, String)] -> IO [RemotePtr CostCentre]
costCentreStackInfo :: Interp -> RemotePtr CostCentreStack -> IO [String]
newBreakArray :: Interp -> Int -> IO (ForeignRef BreakArray)
newModuleName :: Interp -> ModuleName -> IO (RemotePtr ModuleName)
storeBreakpoint :: Interp -> ForeignRef BreakArray -> Int -> Int -> IO ()
breakpointStatus :: Interp -> ForeignRef BreakArray -> Int -> IO Bool
getBreakpointVar :: Interp -> ForeignHValue -> Int -> IO (Maybe ForeignHValue)
getClosure :: Interp -> ForeignHValue -> IO (GenClosure ForeignHValue)
getModBreaks :: HomeModInfo -> ModBreaks

-- | Send a Seq message to the iserv process to force a value #2950
seqHValue :: Interp -> UnitEnv -> ForeignHValue -> IO (EvalResult ())
evalBreakpointToId :: HomePackageTable -> EvalBreakpoint -> InternalBreakpointId

-- | Interpreter uses Dynamic way
interpreterDynamic :: Interp -> Bool

-- | Interpreter uses Profiling way
interpreterProfiled :: Interp -> Bool
initObjLinker :: Interp -> IO ()
lookupSymbol :: Interp -> FastString -> IO (Maybe (Ptr ()))
lookupSymbolInDLL :: Interp -> RemotePtr LoadedDLL -> FastString -> IO (Maybe (Ptr ()))
lookupClosure :: Interp -> String -> IO (Maybe HValueRef)

-- | loadDLL loads a dynamic library using the OS's native linker (i.e.
--   dlopen() on Unix, LoadLibrary() on Windows). It takes either an
--   absolute pathname to the file, or a relative filename (e.g.
--   "libfoo.so" or "foo.dll"). In the latter case, loadDLL searches the
--   standard locations for the appropriate library.
loadDLL :: Interp -> String -> IO (Either String (RemotePtr LoadedDLL))
loadArchive :: Interp -> String -> IO ()
loadObj :: Interp -> String -> IO ()
unloadObj :: Interp -> String -> IO ()
addLibrarySearchPath :: Interp -> String -> IO (Ptr ())
removeLibrarySearchPath :: Interp -> Ptr () -> IO Bool
resolveObjs :: Interp -> IO SuccessFlag
findSystemLibrary :: Interp -> String -> IO (Maybe String)

-- | Run a command in the interpreter's context. With
--   <tt>-fexternal-interpreter</tt>, the command is serialized and sent to
--   an external iserv process, and the response is deserialized (hence the
--   <tt>Binary</tt> constraint). With <tt>-fno-external-interpreter</tt>
--   we execute the command directly here.
interpCmd :: Binary a => Interp -> Message a -> IO a
withExtInterp :: ExceptionMonad m => ExtInterp -> (forall d. () => ExtInterpInstance d -> m a) -> m a
withExtInterpStatus :: forall {k} m (a :: k). ExtInterp -> (forall d. () => ExtInterpStatusVar d -> m a) -> m a

-- | Grab a lock on the <a>IServ</a> and do something with it. Overloaded
--   because this is used from TcM as well as IO.
withIServ :: ExceptionMonad m => IServ -> (ExtInterpInstance () -> m a) -> m a

-- | Spawn JS interpreter if it isn't already running and execute the given
--   action
--   
--   Update the interpreter state.
withJSInterp :: ExceptionMonad m => JSInterp -> (ExtInterpInstance JSInterpExtra -> m a) -> m a

-- | Stop the interpreter
stopInterp :: Interp -> IO ()
purgeLookupSymbolCache :: Interp -> IO ()
freeReallyRemoteRef :: ExtInterpInstance d -> RemoteRef a -> IO ()
freeHValueRefs :: Interp -> [HValueRef] -> IO ()

-- | Creates a <a>ForeignRef</a> that will automatically release the
--   <a>RemoteRef</a> when it is no longer referenced.
mkFinalizedHValue :: Interp -> RemoteRef a -> IO (ForeignRef a)

-- | Convert a <a>ForeignRef</a> to the value it references directly. This
--   only works when the interpreter is running in the same process as the
--   compiler, so it fails when <tt>-fexternal-interpreter</tt> is on.
wormhole :: Interp -> ForeignRef a -> IO a

-- | Convert an <a>RemoteRef</a> to the value it references directly. This
--   only works when the interpreter is running in the same process as the
--   compiler, so it fails when <tt>-fexternal-interpreter</tt> is on.
wormholeRef :: Interp -> RemoteRef a -> IO a
fromEvalResult :: EvalResult a -> IO a

-- | A <tt>Message a</tt> is a message that returns a value of type
--   <tt>a</tt>. These are requests sent from GHC to the server.
data Message a

-- | Exit the iserv process
[Shutdown] :: Message ()
[RtsRevertCAFs] :: Message ()
[InitLinker] :: Message ()
[LookupSymbol] :: String -> Message (Maybe (RemotePtr ()))
[LookupSymbolInDLL] :: RemotePtr LoadedDLL -> String -> Message (Maybe (RemotePtr ()))
[LookupClosure] :: String -> Message (Maybe HValueRef)
[LoadDLL] :: String -> Message (Either String (RemotePtr LoadedDLL))
[LoadArchive] :: String -> Message ()
[LoadObj] :: String -> Message ()
[UnloadObj] :: String -> Message ()
[AddLibrarySearchPath] :: String -> Message (RemotePtr ())
[RemoveLibrarySearchPath] :: RemotePtr () -> Message Bool
[ResolveObjs] :: Message Bool
[FindSystemLibrary] :: String -> Message (Maybe String)

-- | Create a set of BCO objects, and return HValueRefs to them See
--   <tt>createBCOs</tt> in compiler<i>GHC</i>Runtime/Interpreter.hs. NB:
--   this has a custom Binary behavior, see Note [Parallelize CreateBCOs
--   serialization]
[CreateBCOs] :: [ResolvedBCO] -> Message [HValueRef]

-- | Release <a>HValueRef</a>s
[FreeHValueRefs] :: [HValueRef] -> Message ()

-- | Add entries to the Static Pointer Table
[AddSptEntry] :: Fingerprint -> HValueRef -> Message ()

-- | Malloc some data and return a <a>RemotePtr</a> to it
[MallocData] :: ByteString -> Message (RemotePtr ())
[MallocStrings] :: [ByteString] -> Message [RemotePtr ()]

-- | Calls <a>prepareForeignCall</a>
[PrepFFI] :: [FFIType] -> FFIType -> Message (RemotePtr C_ffi_cif)

-- | Free data previously created by <a>PrepFFI</a>
[FreeFFI] :: RemotePtr C_ffi_cif -> Message ()

-- | Create an info table for a constructor
[MkConInfoTable] :: Bool -> Int -> Int -> Int -> Int -> ByteString -> Message (RemotePtr StgInfoTable)

-- | Evaluate a statement
[EvalStmt] :: EvalOpts -> EvalExpr HValueRef -> Message (EvalStatus_ [HValueRef] [HValueRef])

-- | Resume evaluation of a statement after a breakpoint
[ResumeStmt] :: EvalOpts -> RemoteRef (ResumeContext [HValueRef]) -> Message (EvalStatus_ [HValueRef] [HValueRef])

-- | Abandon evaluation of a statement after a breakpoint
[AbandonStmt] :: RemoteRef (ResumeContext [HValueRef]) -> Message ()

-- | Evaluate something of type <tt>IO String</tt>
[EvalString] :: HValueRef -> Message (EvalResult String)

-- | Evaluate something of type <tt>String -&gt; IO String</tt>
[EvalStringToString] :: HValueRef -> String -> Message (EvalResult String)

-- | Evaluate something of type <tt>IO ()</tt>
[EvalIO] :: HValueRef -> Message (EvalResult ())

-- | Create a set of CostCentres with the same module name
[MkCostCentres] :: String -> [(String, String)] -> Message [RemotePtr CostCentre]

-- | Show a <a>CostCentreStack</a> as a <tt>[String]</tt>
[CostCentreStackInfo] :: RemotePtr CostCentreStack -> Message [String]

-- | Create a new array of breakpoint flags
[NewBreakArray] :: Int -> Message (RemoteRef BreakArray)

-- | Set how many times a breakpoint should be ignored also used for
--   enable/disable
[SetupBreakpoint] :: RemoteRef BreakArray -> Int -> Int -> Message ()

-- | Query the status of a breakpoint (True <a>=</a> enabled)
[BreakpointStatus] :: RemoteRef BreakArray -> Int -> Message Bool

-- | Get a reference to a free variable at a breakpoint
[GetBreakpointVar] :: HValueRef -> Int -> Message (Maybe HValueRef)

-- | Start a new TH module, return a state token that should be
[StartTH] :: Message (RemoteRef (IORef QState))

-- | Evaluate a TH computation.
--   
--   Returns a ByteString, because we have to force the result before
--   returning it to ensure there are no errors lurking in it. The TH types
--   don't have NFData instances, and even if they did, we have to
--   serialize the value anyway, so we might as well serialize it to force
--   it.
[RunTH] :: RemoteRef (IORef QState) -> HValueRef -> THResultType -> Maybe Loc -> Message (QResult ByteString)

-- | Run the given mod finalizers.
[RunModFinalizers] :: RemoteRef (IORef QState) -> [RemoteRef (Q ())] -> Message (QResult ())

-- | Remote interface to GHC.Exts.Heap.getClosureData. This is used by the
--   GHCi debugger to inspect values in the heap for :print and type
--   reconstruction.
[GetClosure] :: HValueRef -> Message (GenClosure HValueRef)

-- | Evaluate something. This is used to support :force in GHCi.
[Seq] :: HValueRef -> Message (EvalStatus_ () ())

-- | Resume forcing a free variable in a breakpoint (#2950)
[ResumeSeq] :: RemoteRef (ResumeContext ()) -> Message (EvalStatus_ () ())

-- | Allocate a string for a breakpoint module name. This uses an empty
--   dummy type because <tt>ModuleName</tt> isn't available here.
[NewBreakModule] :: String -> Message (RemotePtr BreakModule)

module GHC.Linker.MacOS

-- | On macOS we rely on the linkers <tt>-dead_strip_dylibs</tt> flag to
--   remove unused libraries from the dynamic library. We do this to reduce
--   the number of load commands that end up in the dylib, and has been
--   limited to 32K (32768) since macOS Sierra (10.14).
--   
--   <tt>-dead_strip_dylibs</tt> does not dead strip <tt>-rpath</tt>
--   entries, as such passing <tt>-l</tt> and <tt>-rpath</tt> to the linker
--   will result in the unnecessary libraries not being included in the
--   load commands, however the <tt>-rpath</tt> entries are all forced to
--   be included. This can lead to 100s of <tt>-rpath</tt> entries being
--   included when only a handful of libraries end up being truly linked.
--   
--   Thus after building the library, we run a fixup phase where we inject
--   the <tt>-rpath</tt> for each found library (in the given library
--   search paths) into the dynamic library through <tt>-add_rpath</tt>.
--   
--   See Note [Dynamic linking on macOS]
runInjectRPaths :: Logger -> ToolSettings -> [FilePath] -> FilePath -> IO ()
getUnitFrameworkOpts :: UnitEnv -> [UnitId] -> IO [String]
getFrameworkOpts :: FrameworkOpts -> Platform -> [String]
loadFramework :: Interp -> [FilePath] -> FilePath -> IO (Maybe String)

module GHC.Linker.Deps
data LinkDepsOpts
LinkDepsOpts :: !String -> !Bool -> !Bool -> !ModuleGraph -> !UnitEnv -> !SDocContext -> !Bool -> !DiagnosticOpts IfaceMessage -> !Ways -> !FinderCache -> !FinderOpts -> !SDoc -> Module -> IO (MaybeErr MissingInterfaceError ModIface) -> !Module -> IO (Maybe Linkable) -> LinkDepsOpts

-- | Suffix of .o files
[ldObjSuffix] :: LinkDepsOpts -> !String

-- | Always use .dyn_o?
[ldForceDyn] :: LinkDepsOpts -> !Bool

-- | Is the driver in one-shot mode?
[ldOneShotMode] :: LinkDepsOpts -> !Bool
[ldModuleGraph] :: LinkDepsOpts -> !ModuleGraph
[ldUnitEnv] :: LinkDepsOpts -> !UnitEnv

-- | Rendering options for error messages
[ldPprOpts] :: LinkDepsOpts -> !SDocContext

-- | Use bytecode rather than objects
[ldUseByteCode] :: LinkDepsOpts -> !Bool

-- | Options for diagnostics
[ldMsgOpts] :: LinkDepsOpts -> !DiagnosticOpts IfaceMessage

-- | Enabled ways
[ldWays] :: LinkDepsOpts -> !Ways
[ldFinderCache] :: LinkDepsOpts -> !FinderCache
[ldFinderOpts] :: LinkDepsOpts -> !FinderOpts
[ldLoadIface] :: LinkDepsOpts -> !SDoc -> Module -> IO (MaybeErr MissingInterfaceError ModIface)
[ldLoadByteCode] :: LinkDepsOpts -> !Module -> IO (Maybe Linkable)
data LinkDeps
LinkDeps :: [Linkable] -> [Linkable] -> [UnitId] -> UniqDSet UnitId -> LinkDeps
[ldNeededLinkables] :: LinkDeps -> [Linkable]
[ldAllLinkables] :: LinkDeps -> [Linkable]
[ldUnits] :: LinkDeps -> [UnitId]
[ldNeededUnits] :: LinkDeps -> UniqDSet UnitId

-- | Find all the packages and linkables that a set of modules depends on
--   
--   Return the module and package dependencies for the needed modules. See
--   Note [Object File Dependencies]
--   
--   Fails with an IO exception if it can't find enough files
getLinkDeps :: LinkDepsOpts -> Interp -> LoaderState -> SrcSpan -> [Module] -> IO LinkDeps

module GHC.HsToCore.Breakpoints

-- | Initialize memory for breakpoint data that is shared between the
--   bytecode generator and the interpreter.
--   
--   Since GHCi and the RTS need to interact with breakpoint data and the
--   bytecode generator needs to encode this information for each
--   expression, the data is allocated remotely in GHCi's address space and
--   passed to the codegen as foreign pointers.
mkModBreaks :: Interp -> Module -> SizedSeq Tick -> IO ModBreaks


-- | Generate infotables for interpreter-made bytecodes
module GHC.ByteCode.InfoTable
mkITbls :: Interp -> Profile -> [TyCon] -> IO ItblEnv


-- | Bytecode assembler and linker
module GHC.ByteCode.Asm
assembleBCOs :: Interp -> Profile -> FlatBag (ProtoBCO Name) -> [TyCon] -> AddrEnv -> Maybe ModBreaks -> [SptEntry] -> IO CompiledByteCode
assembleOneBCO :: Interp -> Profile -> ProtoBCO Name -> IO UnlinkedBCO

-- | Finds external references. Remember to remove the names defined by
--   this group of BCOs themselves
bcoFreeNames :: UnlinkedBCO -> UniqDSet Name
data SizedSeq a
sizeSS :: SizedSeq a -> Word
ssElts :: SizedSeq a -> [a]
iNTERP_STACK_CHECK_THRESH :: Int
mkNativeCallInfoLit :: Platform -> NativeCallInfo -> Literal
instance GHC.Internal.Base.Applicative GHC.ByteCode.Asm.Assembler
instance GHC.Internal.Base.Functor GHC.ByteCode.Asm.Assembler
instance GHC.Internal.Base.Monad GHC.ByteCode.Asm.Assembler


-- | GHC.StgToByteCode: Generate bytecode from STG
module GHC.StgToByteCode
data UnlinkedBCO
byteCodeGen :: HscEnv -> Module -> [CgStgTopBinding] -> [TyCon] -> Maybe ModBreaks -> [SptEntry] -> IO CompiledByteCode
instance GHC.Internal.Base.Applicative GHC.StgToByteCode.BcM
instance GHC.Classes.Eq GHC.StgToByteCode.Discr
instance GHC.Internal.Base.Functor GHC.StgToByteCode.BcM
instance GHC.Driver.DynFlags.HasDynFlags GHC.StgToByteCode.BcM
instance GHC.Internal.Base.Monad GHC.StgToByteCode.BcM
instance GHC.Classes.Ord GHC.StgToByteCode.Discr
instance GHC.Utils.Outputable.Outputable GHC.StgToByteCode.Discr

module GHC.Linker.Windows
maybeCreateManifest :: Logger -> TmpFs -> DynFlags -> FilePath -> IO [FilePath]

module GHC.Linker.ExtraObj
mkExtraObj :: Logger -> TmpFs -> DynFlags -> UnitState -> Suffix -> String -> IO FilePath
mkExtraObjToLinkIntoBinary :: Logger -> TmpFs -> DynFlags -> UnitState -> IO (Maybe FilePath)
mkNoteObjsToLinkIntoBinary :: Logger -> TmpFs -> DynFlags -> UnitEnv -> [UnitId] -> IO [FilePath]
checkLinkInfo :: Logger -> DynFlags -> UnitEnv -> [UnitId] -> FilePath -> IO Bool

-- | Return the "link info" string
--   
--   See Note [LinkInfo section]
getLinkInfo :: DynFlags -> UnitEnv -> [UnitId] -> IO String
ghcLinkInfoSectionName :: String
ghcLinkInfoNoteName :: String
platformSupportsSavingLinkOpts :: OS -> Bool
haveRtsOptsFlags :: DynFlags -> Bool


-- | This module manages storing the various GHC option flags in a modules
--   interface file as part of the recompilation checking infrastructure.
module GHC.Iface.Recomp.Flags

-- | Produce a fingerprint of a <tt>DynFlags</tt> value. We only base the
--   finger print on important fields in <tt>DynFlags</tt> so that the
--   recompilation checker can use this fingerprint.
--   
--   NB: The <a>Module</a> parameter is the <a>Module</a> recorded by the
--   *interface* file, not the actual <a>Module</a> according to our
--   <a>DynFlags</a>.
fingerprintDynFlags :: HscEnv -> Module -> (WriteBinHandle -> Name -> IO ()) -> IO Fingerprint
fingerprintOptFlags :: DynFlags -> (WriteBinHandle -> Name -> IO ()) -> IO Fingerprint
fingerprintHpcFlags :: DynFlags -> (WriteBinHandle -> Name -> IO ()) -> IO Fingerprint

module GHC.Driver.Config.StgToCmm
initStgToCmmConfig :: DynFlags -> Module -> StgToCmmConfig

module GHC.Driver.GenerateCgIPEStub
generateCgIPEStub :: HscEnv -> Module -> InfoTableProvMap -> (NonCaffySet, ModuleLFInfos, Map CmmInfoTable (Maybe IpeSourceLocation), IPEStats) -> CgStream CmmGroupSRTs CmmCgInfos

-- | Given: * an initial mapping from info tables to possible source
--   locations, * initial <a>IPEStats</a>, * a <a>CmmGroupSRTs</a>,
--   
--   map every info table listed in the <a>CmmProc</a>s of the group to
--   their possible source locations and update <a>IPEStats</a> for skipped
--   stack info tables (in case both -finfo-table-map and
--   -fno-info-table-map-with-stack were given). See: Note [Stacktraces
--   from Info Table Provenance Entries (IPE based stack unwinding)]
--   
--   Note: While it would be cleaner if we could keep the recursion and
--   accumulation internal to this function, this cannot be done without
--   separately traversing stream of <a>CmmGroupSRTs</a> in <a>Main</a>.
--   The initial implementation of this logic did such a thing, and code
--   generation performance suffered considerably as a result (see #23103).
lookupEstimatedTicks :: HscEnv -> Map CmmInfoTable (Maybe IpeSourceLocation) -> IPEStats -> CmmGroupSRTs -> IO (Map CmmInfoTable (Maybe IpeSourceLocation), IPEStats)

module GHC.Driver.Config.Stg.Ppr

-- | Initialize STG pretty-printing options from DynFlags
initStgPprOpts :: DynFlags -> StgPprOpts

module GHC.Driver.Config.Parser

-- | Extracts the flags needed for parsing
initParserOpts :: DynFlags -> ParserOpts

module GHC.Driver.Config.Cmm.Parser
initCmmParserConfig :: DynFlags -> CmmParserConfig

module GHC.Driver.Config.Linker
initFrameworkOpts :: DynFlags -> FrameworkOpts

-- | Initialize linker configuration from DynFlags
initLinkerConfig :: DynFlags -> LinkerConfig


-- | Dynamic linker
module GHC.Linker.Dynamic
linkDynLib :: Logger -> TmpFs -> DynFlags -> UnitEnv -> [String] -> [UnitId] -> IO ()

-- | Some platforms require that we explicitly link against <tt>libm</tt>
--   if any math-y things are used (which we assume to include all
--   programs). See #14022.
libmLinkOpts :: Platform -> [Option]

module GHC.Linker.Static
linkBinary :: Logger -> TmpFs -> DynFlags -> UnitEnv -> [FilePath] -> [UnitId] -> IO ()

-- | Linking a static lib will not really link anything. It will merely
--   produce a static archive of all dependent static libraries. The
--   resulting library will still need to be linked with any remaining link
--   flags.
linkStaticLib :: Logger -> DynFlags -> UnitEnv -> [String] -> [UnitId] -> IO ()

module GHC.Driver.Config.StgToJS

-- | Initialize StgToJS settings from DynFlags
initStgToJSConfig :: DynFlags -> StgToJSConfig

-- | Default linker configuration
initJSLinkConfig :: DynFlags -> JSLinkConfig

module GHC.Driver.Config.HsToCore.Ticks
initTicksConfig :: DynFlags -> TicksConfig
breakpointsAllowed :: DynFlags -> Bool

module GHC.Core.Lint
data LintPassResultConfig
LintPassResultConfig :: !DiagOpts -> !Platform -> !LintFlags -> !Bool -> !SDoc -> ![Var] -> LintPassResultConfig
[lpr_diagOpts] :: LintPassResultConfig -> !DiagOpts
[lpr_platform] :: LintPassResultConfig -> !Platform
[lpr_makeLintFlags] :: LintPassResultConfig -> !LintFlags
[lpr_showLintWarnings] :: LintPassResultConfig -> !Bool
[lpr_passPpr] :: LintPassResultConfig -> !SDoc
[lpr_localsInScope] :: LintPassResultConfig -> ![Var]
data LintFlags
LF :: Bool -> Bool -> StaticPtrCheck -> Bool -> Bool -> Bool -> LintFlags
[lf_check_global_ids] :: LintFlags -> Bool
[lf_check_inline_loop_breakers] :: LintFlags -> Bool

-- | See Note [Checking StaticPtrs]
[lf_check_static_ptrs] :: LintFlags -> StaticPtrCheck

-- | See Note [Linting type synonym applications]
[lf_report_unsat_syns] :: LintFlags -> Bool

-- | See Note [Linting linearity]
[lf_check_linearity] :: LintFlags -> Bool
[lf_check_fixed_rep] :: LintFlags -> Bool
data StaticPtrCheck

-- | Allow <tt>makeStatic</tt> to occur anywhere.
AllowAnywhere :: StaticPtrCheck

-- | Allow <tt>makeStatic</tt> calls at the top-level only.
AllowAtTopLevel :: StaticPtrCheck

-- | Reject any <tt>makeStatic</tt> occurrence.
RejectEverywhere :: StaticPtrCheck
data LintConfig
LintConfig :: !DiagOpts -> !Platform -> !LintFlags -> ![Var] -> LintConfig

-- | Diagnostics opts
[l_diagOpts] :: LintConfig -> !DiagOpts

-- | Target platform
[l_platform] :: LintConfig -> !Platform

-- | Linting the result of this pass
[l_flags] :: LintConfig -> !LintFlags

-- | <a>Id</a>s that should be treated as being in scope
[l_vars] :: LintConfig -> ![Var]
type WarnsAndErrs = (Bag SDoc, Bag SDoc)

-- | Type-check a <a>CoreProgram</a>. See Note [Core Lint guarantee].
lintCoreBindings' :: LintConfig -> CoreProgram -> WarnsAndErrs
lintUnfolding :: Bool -> LintConfig -> SrcLoc -> CoreExpr -> Maybe (Bag SDoc)
lintPassResult :: Logger -> LintPassResultConfig -> CoreProgram -> IO ()
lintExpr :: LintConfig -> CoreExpr -> Maybe (Bag SDoc)

-- | This checks whether a pass correctly looks through debug annotations
--   (<tt>SourceNote</tt>). This works a bit different from other
--   consistency checks: We check this by running the given task twice,
--   noting all differences between the results.
lintAnnots :: SDoc -> (ModGuts -> CoreM ModGuts) -> ModGuts -> CoreM ModGuts
lintAxioms :: Logger -> LintConfig -> SDoc -> [CoAxiom Branched] -> IO ()

-- | Configuration for boilerplate operations at the end of a compilation
--   pass producing Core.
data EndPassConfig
EndPassConfig :: !Bool -> !Maybe LintPassResultConfig -> !NamePprCtx -> !Maybe DumpFlag -> !SDoc -> !SDoc -> EndPassConfig

-- | Whether core bindings should be dumped with the size of what they are
--   binding (i.e. the size of the RHS of the binding).
[ep_dumpCoreSizes] :: EndPassConfig -> !Bool

-- | Whether we should lint the result of this pass.
[ep_lintPassResult] :: EndPassConfig -> !Maybe LintPassResultConfig
[ep_namePprCtx] :: EndPassConfig -> !NamePprCtx
[ep_dumpFlag] :: EndPassConfig -> !Maybe DumpFlag
[ep_prettyPass] :: EndPassConfig -> !SDoc
[ep_passDetails] :: EndPassConfig -> !SDoc
endPassIO :: Logger -> EndPassConfig -> CoreProgram -> [CoreRule] -> IO ()
displayLintResults :: Logger -> Bool -> SDoc -> SDoc -> WarnsAndErrs -> IO ()
dumpPassResult :: Logger -> Bool -> NamePprCtx -> Maybe DumpFlag -> String -> SDoc -> CoreProgram -> [CoreRule] -> IO ()
instance GHC.Internal.Base.Applicative GHC.Core.Lint.LintM
instance GHC.Classes.Eq GHC.Core.Lint.StaticPtrCheck
instance GHC.Internal.Base.Functor GHC.Core.Lint.LintM
instance GHC.Internal.Control.Monad.Fail.MonadFail GHC.Core.Lint.LintM
instance GHC.Internal.Base.Monad GHC.Core.Lint.LintM

module GHC.CoreToStg.Prep
data CorePrepConfig
CorePrepConfig :: !Bool -> Platform -> !Maybe ArityOpts -> !Bool -> !Bool -> CorePrepConfig

-- | Whether to generate a default alternative with <a>`error`</a> in these
--   cases. This is helpful when debugging demand analysis or type checker
--   bugs which can sometimes manifest as segmentation faults.
[cp_catchNonexhaustiveCases] :: CorePrepConfig -> !Bool
[cp_platform] :: CorePrepConfig -> Platform

-- | Configuration for arity analysis (<a>exprEtaExpandArity</a>). See Note
--   [Eta expansion of arguments in CorePrep] When <a>Nothing</a> (e.g.,
--   -O0, -O1), use the cheaper <a>exprArity</a> instead
[cp_arityOpts] :: CorePrepConfig -> !Maybe ArityOpts

-- | Whether to perform speculative evaluation See Note [Controlling
--   Speculative Evaluation]
[cp_specEval] :: CorePrepConfig -> !Bool

-- | Whether to perform speculative evaluation on DFuns
[cp_specEvalDFun] :: CorePrepConfig -> !Bool
data CorePrepPgmConfig
CorePrepPgmConfig :: !EndPassConfig -> !Bool -> CorePrepPgmConfig
[cpPgm_endPassConfig] :: CorePrepPgmConfig -> !EndPassConfig
[cpPgm_generateDebugInfo] :: CorePrepPgmConfig -> !Bool
corePrepPgm :: Logger -> CorePrepConfig -> CorePrepPgmConfig -> Module -> ModLocation -> CoreProgram -> [TyCon] -> IO CoreProgram
corePrepExpr :: Logger -> CorePrepConfig -> CoreExpr -> IO CoreExpr
instance GHC.Classes.Eq GHC.CoreToStg.Prep.BindInfo
instance GHC.Classes.Eq GHC.CoreToStg.Prep.FloatInfo
instance GHC.Utils.Outputable.Outputable GHC.CoreToStg.Prep.ArgInfo
instance GHC.Utils.Outputable.Outputable GHC.CoreToStg.Prep.BindInfo
instance GHC.Utils.Outputable.Outputable GHC.CoreToStg.Prep.FloatInfo
instance GHC.Utils.Outputable.Outputable GHC.CoreToStg.Prep.FloatingBind
instance GHC.Utils.Outputable.Outputable GHC.CoreToStg.Prep.Floats

module GHC.Core.LateCC.TopLevelBinds

-- | Add late cost centres directly to the <a>ModGuts</a>. This is used
--   inside the core pipeline with the -fprof-late-inline flag. It should
--   not be used after tidy, since it does not manually track inserted cost
--   centers. See Note [Collecting late cost centres].
topLevelBindsCCMG :: ModGuts -> CoreM ModGuts

-- | Insert cost centres on top-level bindings in the module, depending on
--   whether or not they satisfy the given predicate.
topLevelBindsCC :: (CoreExpr -> Bool) -> CoreBind -> LateCCM s CoreBind


-- | Adds cost-centers after the core pipline has run.
module GHC.Core.LateCC

-- | Late cost center insertion logic used by the driver
addLateCostCenters :: Logger -> LateCCConfig -> CoreProgram -> IO (CoreProgram, LateCCState (Maybe SrcSpan))

module GHC.Core.Opt.Simplify.Utils
rebuildLam :: SimplEnv -> [OutBndr] -> OutExpr -> SimplCont -> SimplM OutExpr
mkCase :: SimplMode -> OutExpr -> OutId -> OutType -> [OutAlt] -> SimplM OutExpr
prepareAlts :: OutExpr -> InId -> [InAlt] -> SimplM ([AltCon], [InAlt])
tryEtaExpandRhs :: SimplEnv -> BindContext -> OutId -> OutExpr -> SimplM (ArityType, OutExpr)
wantEtaExpansion :: CoreExpr -> Bool
preInlineUnconditionally :: SimplEnv -> TopLevelFlag -> InId -> InExpr -> StaticEnv -> Maybe SimplEnv
postInlineUnconditionally :: SimplEnv -> BindContext -> InId -> OutId -> OutExpr -> Bool
activeRule :: SimplMode -> Activation -> Bool
getUnfoldingInRuleMatch :: SimplEnv -> InScopeEnv
updModeForStableUnfoldings :: Activation -> SimplMode -> SimplMode
updModeForRules :: SimplMode -> SimplMode
data BindContext
BC_Let :: TopLevelFlag -> RecFlag -> BindContext
BC_Join :: RecFlag -> SimplCont -> BindContext
bindContextLevel :: BindContext -> TopLevelFlag
data SimplCont

-- | Stop[e] = e
Stop :: OutType -> CallCtxt -> SubDemand -> SimplCont
CastIt :: OutCoercion -> Bool -> SimplCont -> SimplCont
[sc_co] :: SimplCont -> OutCoercion
[sc_opt] :: SimplCont -> Bool
[sc_cont] :: SimplCont -> SimplCont
ApplyToVal :: DupFlag -> OutType -> InExpr -> StaticEnv -> SimplCont -> SimplCont
[sc_dup] :: SimplCont -> DupFlag
[sc_hole_ty] :: SimplCont -> OutType
[sc_arg] :: SimplCont -> InExpr
[sc_env] :: SimplCont -> StaticEnv
[sc_cont] :: SimplCont -> SimplCont
ApplyToTy :: OutType -> OutType -> SimplCont -> SimplCont
[sc_arg_ty] :: SimplCont -> OutType
[sc_hole_ty] :: SimplCont -> OutType
[sc_cont] :: SimplCont -> SimplCont
Select :: DupFlag -> InId -> [InAlt] -> StaticEnv -> SimplCont -> SimplCont
[sc_dup] :: SimplCont -> DupFlag
[sc_bndr] :: SimplCont -> InId
[sc_alts] :: SimplCont -> [InAlt]
[sc_env] :: SimplCont -> StaticEnv
[sc_cont] :: SimplCont -> SimplCont
StrictBind :: DupFlag -> FromWhat -> InId -> InExpr -> StaticEnv -> SimplCont -> SimplCont
[sc_dup] :: SimplCont -> DupFlag
[sc_from] :: SimplCont -> FromWhat
[sc_bndr] :: SimplCont -> InId
[sc_body] :: SimplCont -> InExpr
[sc_env] :: SimplCont -> StaticEnv
[sc_cont] :: SimplCont -> SimplCont
StrictArg :: DupFlag -> ArgInfo -> OutType -> SimplCont -> SimplCont
[sc_dup] :: SimplCont -> DupFlag
[sc_fun] :: SimplCont -> ArgInfo
[sc_fun_ty] :: SimplCont -> OutType
[sc_cont] :: SimplCont -> SimplCont
TickIt :: CoreTickish -> SimplCont -> SimplCont
data DupFlag
NoDup :: DupFlag
Simplified :: DupFlag
OkToDup :: DupFlag
data FromWhat
FromLet :: FromWhat
FromBeta :: Levity -> FromWhat
type StaticEnv = SimplEnv
isSimplified :: DupFlag -> Bool
contIsStop :: SimplCont -> Bool
contIsDupable :: SimplCont -> Bool
contResultType :: SimplCont -> OutType
contHoleType :: SimplCont -> OutType
contHoleScaling :: SimplCont -> Mult
contIsTrivial :: SimplCont -> Bool
contArgs :: SimplCont -> (Bool, [ArgSummary], SimplCont)
contIsRhs :: SimplCont -> Maybe RecFlag
countArgs :: SimplCont -> Int
mkBoringStop :: OutType -> SimplCont
mkRhsStop :: OutType -> RecFlag -> Demand -> SimplCont
mkLazyArgStop :: OutType -> ArgInfo -> SimplCont
interestingCallContext :: SimplEnv -> SimplCont -> CallCtxt
data ArgInfo
ArgInfo :: OutId -> [ArgSpec] -> RewriteCall -> Bool -> [Demand] -> [Int] -> ArgInfo
[ai_fun] :: ArgInfo -> OutId
[ai_args] :: ArgInfo -> [ArgSpec]
[ai_rewrite] :: ArgInfo -> RewriteCall
[ai_encl] :: ArgInfo -> Bool
[ai_dmds] :: ArgInfo -> [Demand]
[ai_discs] :: ArgInfo -> [Int]
data ArgSpec
ValArg :: Demand -> OutExpr -> OutType -> ArgSpec
[as_dmd] :: ArgSpec -> Demand
[as_arg] :: ArgSpec -> OutExpr
[as_hole_ty] :: ArgSpec -> OutType
TyArg :: OutType -> OutType -> ArgSpec
[as_arg_ty] :: ArgSpec -> OutType
[as_hole_ty] :: ArgSpec -> OutType
CastBy :: OutCoercion -> ArgSpec
data RewriteCall
TryRules :: FullArgCount -> [CoreRule] -> RewriteCall
TryInlining :: RewriteCall
TryNothing :: RewriteCall
mkArgInfo :: SimplEnv -> RuleEnv -> Id -> SimplCont -> ArgInfo
addValArgTo :: ArgInfo -> OutExpr -> OutType -> ArgInfo
addCastTo :: ArgInfo -> OutCoercion -> ArgInfo
addTyArgTo :: ArgInfo -> OutType -> OutType -> ArgInfo
argInfoExpr :: OutId -> [ArgSpec] -> OutExpr
argInfoAppArgs :: [ArgSpec] -> [OutExpr]
pushSimplifiedArgs :: SimplEnv -> [ArgSpec] -> SimplCont -> SimplCont
pushSimplifiedRevArgs :: SimplEnv -> [ArgSpec] -> SimplCont -> SimplCont
isStrictArgInfo :: ArgInfo -> Bool
lazyArgContext :: ArgInfo -> CallCtxt
abstractFloats :: UnfoldingOpts -> TopLevelFlag -> [OutTyVar] -> SimplFloats -> OutExpr -> SimplM ([OutBind], OutExpr)
isExitJoinId :: Var -> Bool
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Utils.ArgInfo
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Utils.ArgSpec
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Utils.DupFlag
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Utils.SimplCont

module GHC.Core.Opt.Simplify.Iteration
simplTopBinds :: SimplEnv -> [InBind] -> SimplM (SimplFloats, SimplEnv)
simplExpr :: SimplEnv -> CoreExpr -> SimplM CoreExpr
simplImpRules :: SimplEnv -> [CoreRule] -> SimplM [CoreRule]

module GHC.Core.Opt.Simplify

-- | Configuration record for <a>simplifyExpr</a>. The values of this
--   datatype are <i>only</i> driven by the demands of that function.
data SimplifyExprOpts
SimplifyExprOpts :: ![FamInst] -> !SimplMode -> !TopEnvConfig -> SimplifyExprOpts
[se_fam_inst] :: SimplifyExprOpts -> ![FamInst]
[se_mode] :: SimplifyExprOpts -> !SimplMode
[se_top_env_cfg] :: SimplifyExprOpts -> !TopEnvConfig

-- | Configuration record for <a>simplifyPgm</a>. The values of this
--   datatype are <i>only</i> driven by the demands of that function.
data SimplifyOpts
SimplifyOpts :: !Bool -> !Int -> !SimplMode -> !Maybe LintPassResultConfig -> !RuleBase -> !TopEnvConfig -> SimplifyOpts
[so_dump_core_sizes] :: SimplifyOpts -> !Bool
[so_iterations] :: SimplifyOpts -> !Int
[so_mode] :: SimplifyOpts -> !SimplMode
[so_pass_result_cfg] :: SimplifyOpts -> !Maybe LintPassResultConfig
[so_hpt_rules] :: SimplifyOpts -> !RuleBase
[so_top_env_cfg] :: SimplifyOpts -> !TopEnvConfig
simplifyExpr :: Logger -> ExternalUnitCache -> SimplifyExprOpts -> CoreExpr -> IO CoreExpr
simplifyPgm :: Logger -> UnitEnv -> NamePprCtx -> SimplifyOpts -> ModGuts -> IO (SimplCount, ModGuts)

module GHC.Core.Opt.Pipeline.Types

-- | A description of the plugin pass itself
type CorePluginPass = ModGuts -> CoreM ModGuts
data CoreToDo

-- | The core-to-core simplifier.
CoreDoSimplify :: !SimplifyOpts -> CoreToDo
CoreDoPluginPass :: String -> CorePluginPass -> CoreToDo
CoreDoFloatInwards :: CoreToDo
CoreDoFloatOutwards :: FloatOutSwitches -> CoreToDo
CoreLiberateCase :: CoreToDo
CoreDoPrintCore :: CoreToDo
CoreDoStaticArgs :: CoreToDo
CoreDoCallArity :: CoreToDo
CoreDoExitify :: CoreToDo
CoreDoDemand :: Bool -> CoreToDo
CoreDoCpr :: CoreToDo
CoreDoWorkerWrapper :: CoreToDo
CoreDoSpecialising :: CoreToDo
CoreDoSpecConstr :: CoreToDo
CoreCSE :: CoreToDo
CoreDoRuleCheck :: CompilerPhase -> String -> CoreToDo
CoreDoNothing :: CoreToDo
CoreDoPasses :: [CoreToDo] -> CoreToDo
CoreDesugar :: CoreToDo
CoreDesugarOpt :: CoreToDo
CoreTidy :: CoreToDo
CorePrep :: CoreToDo
CoreAddCallerCcs :: CoreToDo
CoreAddLateCcs :: CoreToDo
bindsOnlyPass :: (CoreProgram -> CoreM CoreProgram) -> ModGuts -> CoreM ModGuts
pprPassDetails :: CoreToDo -> SDoc
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Pipeline.Types.CoreToDo

module GHC.Driver.Config.Core.Lint
endPass :: CoreToDo -> CoreProgram -> [CoreRule] -> CoreM ()
endPassHscEnvIO :: HscEnv -> NamePprCtx -> CoreToDo -> CoreProgram -> [CoreRule] -> IO ()

-- | Type-check a <a>CoreProgram</a>. See Note [Core Lint guarantee].
lintCoreBindings :: DynFlags -> CoreToDo -> [Var] -> CoreProgram -> WarnsAndErrs
initEndPassConfig :: DynFlags -> [Var] -> NamePprCtx -> CoreToDo -> EndPassConfig
initLintPassResultConfig :: DynFlags -> [Var] -> CoreToDo -> LintPassResultConfig
initLintConfig :: DynFlags -> [Var] -> LintConfig


-- | Various types used during typechecking.
--   
--   Please see <a>GHC.Tc.Utils.Monad</a> as well for operations on these
--   types. You probably want to import it, instead of this module.
--   
--   All the monads exported here are built on top of the same IOEnv monad.
--   The monad functions like a Reader monad in the way it passes the
--   environment around. This is done to allow the environment to be
--   manipulated in a stack like fashion when entering expressions... etc.
--   
--   For state that is global and should be returned at the end (e.g not
--   part of the stack mechanism), you should use a TcRef (= IORef) to
--   store them.
module GHC.Tc.Types
type TcRnIf a b = IOEnv Env a b
type TcRn = TcRnIf TcGblEnv TcLclEnv

-- | Historical "type-checking monad" (now it's just <a>TcRn</a>).
type TcM = TcRn

-- | Historical "renaming monad" (now it's just <a>TcRn</a>).
type RnM = TcRn
type IfM lcl = TcRnIf IfGblEnv lcl
type IfL = IfM IfLclEnv
type IfG = IfM ()

-- | Type alias for <a>IORef</a>; the convention is we'll use this for
--   mutable bits of data in the typechecker which are updated during
--   typechecking and returned at the end.
type TcRef a = IORef a
data Env gbl lcl
Env :: !HscEnv -> {-# UNPACK #-} !Char -> gbl -> lcl -> Env gbl lcl
[env_top] :: Env gbl lcl -> !HscEnv
[env_ut] :: Env gbl lcl -> {-# UNPACK #-} !Char
[env_gbl] :: Env gbl lcl -> gbl
[env_lcl] :: Env gbl lcl -> lcl

-- | <a>TcGblEnv</a> describes the top-level of the module at the point at
--   which the typechecker is finished work. It is this structure that is
--   handed on to the desugarer For state that needs to be updated during
--   the typechecking phase and returned at end, use a <a>TcRef</a> (=
--   <a>IORef</a>).
data TcGblEnv
TcGblEnv :: Module -> Module -> HscSource -> GlobalRdrEnv -> DefaultEnv -> DefaultEnv -> FixityEnv -> TypeEnv -> KnotVars (IORef TypeEnv) -> !InstEnv -> !FamInstEnv -> AnnEnv -> [AvailInfo] -> ImportAvails -> ![ImportUserSpec] -> DefUses -> TcRef [GlobalRdrElt] -> TcRef NameSet -> TcRef Bool -> TcRef Bool -> TcRef ([Linkable], PkgsLoaded) -> TcRef OccSet -> TcRef Integer -> [(Module, Fingerprint)] -> Maybe [(LIE GhcRn, Avails)] -> [LImportDecl GhcRn] -> Maybe (HsGroup GhcRn) -> TcRef [FilePath] -> TcRef [LHsDecl GhcPs] -> TcRef [(ForeignSrcLang, FilePath)] -> TcRef NameSet -> TcRef [(TcLclEnv, ThModFinalizers)] -> TcRef [String] -> TcRef (Map TypeRep Dynamic) -> TcRef (Maybe (ForeignRef (IORef QState))) -> TcRef THDocs -> Bag EvBind -> Maybe Id -> LHsBinds GhcTc -> NameSet -> [LTcSpecPrag] -> Warnings GhcRn -> [Annotation] -> [TyCon] -> NameSet -> [ClsInst] -> [FamInst] -> [LRuleDecl GhcTc] -> [LForeignDecl GhcTc] -> [PatSyn] -> (Maybe (LHsDoc GhcRn), Maybe (XRec GhcRn ModuleName)) -> !AnyHpcUsage -> SelfBootInfo -> Maybe Name -> TcRef Bool -> TcRef (Messages TcRnMessage) -> [TcPluginSolver] -> UniqFM TyCon [TcPluginRewriter] -> [FillDefaulting] -> [HoleFitPlugin] -> RealSrcSpan -> TcRef WantedConstraints -> !CompleteMatches -> TcRef CostCentreState -> TcRef (ModuleEnv Int) -> TcGblEnv

-- | Module being compiled
[tcg_mod] :: TcGblEnv -> Module

-- | If a signature, the backing module See also Note [Identity versus
--   semantic module]
[tcg_semantic_mod] :: TcGblEnv -> Module

-- | What kind of module (regular Haskell, hs-boot, hsig)
[tcg_src] :: TcGblEnv -> HscSource

-- | Top level envt; used during renaming
[tcg_rdr_env] :: TcGblEnv -> GlobalRdrEnv

-- | All class defaults in scope in the module
[tcg_default] :: TcGblEnv -> DefaultEnv

-- | All class defaults exported from the module
[tcg_default_exports] :: TcGblEnv -> DefaultEnv

-- | Just for things in this module
[tcg_fix_env] :: TcGblEnv -> FixityEnv

-- | Global type env for the module we are compiling now. All TyCons and
--   Classes (for this module) end up in here right away, along with their
--   derived constructors, selectors.
--   
--   (Ids defined in this module start in the local envt, though they move
--   to the global envt during zonking)
--   
--   NB: for what "things in this module" means, see Note [The interactive
--   package] in <a>GHC.Runtime.Context</a>
[tcg_type_env] :: TcGblEnv -> TypeEnv
[tcg_type_env_var] :: TcGblEnv -> KnotVars (IORef TypeEnv)

-- | Instance envt for all <i>home-package</i> modules; Includes the dfuns
--   in tcg_insts NB. BangPattern is to fix a leak, see #15111
[tcg_inst_env] :: TcGblEnv -> !InstEnv

-- | Ditto for family instances NB. BangPattern is to fix a leak, see
--   #15111
[tcg_fam_inst_env] :: TcGblEnv -> !FamInstEnv

-- | And for annotations
[tcg_ann_env] :: TcGblEnv -> AnnEnv

-- | What is exported
[tcg_exports] :: TcGblEnv -> [AvailInfo]

-- | Information about what was imported from where, including things bound
--   in this module. Also store Safe Haskell info here about transitive
--   trusted package requirements.
--   
--   There are not many uses of this field, so you can grep for all them.
--   
--   The ImportAvails records information about the following things:
--   
--   <ol>
--   <li>All of the modules you directly imported (tcRnImports)</li>
--   <li>The orphans (only!) of all imported modules in a GHCi session
--   (runTcInteractive)</li>
--   <li>The module that instantiated a signature</li>
--   <li>Each of the signatures that merged in</li>
--   </ol>
--   
--   It is used in the following ways: - imp_orphs is used to determine
--   what orphan modules should be visible in the context
--   (tcVisibleOrphanMods) - imp_finsts is used to determine what family
--   instances should be visible (tcExtendLocalFamInstEnv) - To resolve the
--   meaning of the export list of a module (tcRnExports) - imp_mods is
--   used to compute usage info (mkIfaceTc, deSugar) - imp_trust_own_pkg is
--   used for Safe Haskell in interfaces (mkIfaceTc, as well as in
--   <a>GHC.Driver.Main</a>) - To create the Dependencies field in
--   interface (mkDependencies)
[tcg_imports] :: TcGblEnv -> ImportAvails
[tcg_import_decls] :: TcGblEnv -> ![ImportUserSpec]
[tcg_dus] :: TcGblEnv -> DefUses

-- | INVARIANT: all these GREs were imported; that is, they all have a
--   non-empty gre_imp field.
[tcg_used_gres] :: TcGblEnv -> TcRef [GlobalRdrElt]
[tcg_keep] :: TcGblEnv -> TcRef NameSet

-- | <tt>True</tt> &lt;=&gt; Template Haskell syntax used.
--   
--   We need this so that we can generate a dependency on the Template
--   Haskell package, because the desugarer is going to emit loads of
--   references to TH symbols. The reference is implicit rather than
--   explicit, so we have to zap a mutable variable.
[tcg_th_used] :: TcGblEnv -> TcRef Bool

-- | <tt>True</tt> &lt;=&gt; A Template Haskell splice was used.
--   
--   Splices disable recompilation avoidance (see #481)
[tcg_th_splice_used] :: TcGblEnv -> TcRef Bool

-- | The set of runtime dependencies required by this module See Note
--   [Object File Dependencies]
[tcg_th_needed_deps] :: TcGblEnv -> TcRef ([Linkable], PkgsLoaded)

-- | Allows us to choose unique DFun names.
[tcg_dfun_n] :: TcGblEnv -> TcRef OccSet

-- | A source of unique identities for ZonkAny instances See Note [Any
--   types] in GHC.Builtin.Types, wrinkle (Any4)
[tcg_zany_n] :: TcGblEnv -> TcRef Integer

-- | The requirements we merged with; we always have to recompile if any of
--   these changed.
[tcg_merged] :: TcGblEnv -> [(Module, Fingerprint)]
[tcg_rn_exports] :: TcGblEnv -> Maybe [(LIE GhcRn, Avails)]
[tcg_rn_imports] :: TcGblEnv -> [LImportDecl GhcRn]

-- | Renamed decls, maybe. <tt>Nothing</tt> &lt;=&gt; Don't retain renamed
--   decls.
[tcg_rn_decls] :: TcGblEnv -> Maybe (HsGroup GhcRn)

-- | dependencies from addDependentFile
[tcg_dependent_files] :: TcGblEnv -> TcRef [FilePath]

-- | Top-level declarations from addTopDecls
[tcg_th_topdecls] :: TcGblEnv -> TcRef [LHsDecl GhcPs]

-- | Foreign files emitted from TH.
[tcg_th_foreign_files] :: TcGblEnv -> TcRef [(ForeignSrcLang, FilePath)]

-- | Exact names bound in top-level declarations in tcg_th_topdecls
[tcg_th_topnames] :: TcGblEnv -> TcRef NameSet

-- | Template Haskell module finalizers.
--   
--   They can use particular local environments.
[tcg_th_modfinalizers] :: TcGblEnv -> TcRef [(TcLclEnv, ThModFinalizers)]

-- | Core plugins added by Template Haskell code.
[tcg_th_coreplugins] :: TcGblEnv -> TcRef [String]
[tcg_th_state] :: TcGblEnv -> TcRef (Map TypeRep Dynamic)

-- | Template Haskell state
[tcg_th_remote_state] :: TcGblEnv -> TcRef (Maybe (ForeignRef (IORef QState)))

-- | Docs added in Template Haskell via <tt>putDoc</tt>.
[tcg_th_docs] :: TcGblEnv -> TcRef THDocs
[tcg_ev_binds] :: TcGblEnv -> Bag EvBind
[tcg_tr_module] :: TcGblEnv -> Maybe Id
[tcg_binds] :: TcGblEnv -> LHsBinds GhcTc
[tcg_sigs] :: TcGblEnv -> NameSet
[tcg_imp_specs] :: TcGblEnv -> [LTcSpecPrag]
[tcg_warns] :: TcGblEnv -> Warnings GhcRn
[tcg_anns] :: TcGblEnv -> [Annotation]
[tcg_tcs] :: TcGblEnv -> [TyCon]
[tcg_ksigs] :: TcGblEnv -> NameSet
[tcg_insts] :: TcGblEnv -> [ClsInst]
[tcg_fam_insts] :: TcGblEnv -> [FamInst]
[tcg_rules] :: TcGblEnv -> [LRuleDecl GhcTc]
[tcg_fords] :: TcGblEnv -> [LForeignDecl GhcTc]
[tcg_patsyns] :: TcGblEnv -> [PatSyn]

-- | Maybe Haddock header docs and Maybe located module name
[tcg_hdr_info] :: TcGblEnv -> (Maybe (LHsDoc GhcRn), Maybe (XRec GhcRn ModuleName))

-- | <tt>True</tt> if any part of the prog uses hpc instrumentation. NB.
--   BangPattern is to fix a leak, see #15111
[tcg_hpc] :: TcGblEnv -> !AnyHpcUsage

-- | Whether this module has a corresponding hi-boot file
[tcg_self_boot] :: TcGblEnv -> SelfBootInfo

-- | The Name of the main function, if this module is the main module.
[tcg_main] :: TcGblEnv -> Maybe Name

-- | Has the typechecker inferred this module as -XSafe (Safe Haskell)? See
--   Note [Safe Haskell Overlapping Instances Implementation], although
--   this is used for more than just that failure case.
[tcg_safe_infer] :: TcGblEnv -> TcRef Bool

-- | Unreported reasons why tcg_safe_infer is False. INVARIANT: If this
--   Messages is non-empty, then tcg_safe_infer is False. It may be that
--   tcg_safe_infer is False but this is empty, if no reasons are supplied
--   (#19714), or if those reasons have already been reported by
--   GHC.Driver.Main.markUnsafeInfer
[tcg_safe_infer_reasons] :: TcGblEnv -> TcRef (Messages TcRnMessage)

-- | A list of user-defined type-checking plugins for constraint solving.
[tcg_tc_plugin_solvers] :: TcGblEnv -> [TcPluginSolver]

-- | A collection of all the user-defined type-checking plugins for
--   rewriting type family applications, collated by their type family
--   <a>TyCon</a>s.
[tcg_tc_plugin_rewriters] :: TcGblEnv -> UniqFM TyCon [TcPluginRewriter]

-- | A list of user-defined plugins for type defaulting plugins.
[tcg_defaulting_plugins] :: TcGblEnv -> [FillDefaulting]

-- | A list of user-defined plugins for hole fit suggestions.
[tcg_hf_plugins] :: TcGblEnv -> [HoleFitPlugin]

-- | The RealSrcSpan this module came from
[tcg_top_loc] :: TcGblEnv -> RealSrcSpan

-- | Wanted constraints of static forms. See Note [Constraints in static
--   forms].
[tcg_static_wc] :: TcGblEnv -> TcRef WantedConstraints

-- | Tracking indices for cost centre annotations
[tcg_complete_matches] :: TcGblEnv -> !CompleteMatches
[tcg_cc_st] :: TcGblEnv -> TcRef CostCentreState

-- | See Note [Generating fresh names for FFI wrappers]
[tcg_next_wrapper_num] :: TcGblEnv -> TcRef (ModuleEnv Int)
data TcLclEnv
TcLclEnv :: !TcLclCtxt -> TcRef UsageEnv -> TcRef WantedConstraints -> TcRef (Messages TcRnMessage) -> TcLclEnv
[tcl_lcl_ctxt] :: TcLclEnv -> !TcLclCtxt
[tcl_usage] :: TcLclEnv -> TcRef UsageEnv
[tcl_lie] :: TcLclEnv -> TcRef WantedConstraints
[tcl_errs] :: TcLclEnv -> TcRef (Messages TcRnMessage)
modifyLclCtxt :: (TcLclCtxt -> TcLclCtxt) -> TcLclEnv -> TcLclEnv
data TcLclCtxt
TcLclCtxt :: RealSrcSpan -> [ErrCtxt] -> Bool -> TcLevel -> TcBinderStack -> LocalRdrEnv -> ThStage -> ThBindEnv -> ArrowCtxt -> TcTypeEnv -> TcLclCtxt
[tcl_loc] :: TcLclCtxt -> RealSrcSpan
[tcl_ctxt] :: TcLclCtxt -> [ErrCtxt]
[tcl_in_gen_code] :: TcLclCtxt -> Bool
[tcl_tclvl] :: TcLclCtxt -> TcLevel
[tcl_bndrs] :: TcLclCtxt -> TcBinderStack
[tcl_rdr] :: TcLclCtxt -> LocalRdrEnv
[tcl_th_ctxt] :: TcLclCtxt -> ThStage
[tcl_th_bndrs] :: TcLclCtxt -> ThBindEnv
[tcl_arrow_ctxt] :: TcLclCtxt -> ArrowCtxt
[tcl_env] :: TcLclCtxt -> TcTypeEnv
setLclEnvTcLevel :: TcLevel -> TcLclEnv -> TcLclEnv
getLclEnvTcLevel :: TcLclEnv -> TcLevel
setLclEnvLoc :: RealSrcSpan -> TcLclEnv -> TcLclEnv
getLclEnvLoc :: TcLclEnv -> RealSrcSpan
lclEnvInGeneratedCode :: TcLclEnv -> Bool
data IfGblEnv
IfGblEnv :: SDoc -> KnotVars (IfG TypeEnv) -> IfGblEnv
[if_doc] :: IfGblEnv -> SDoc
[if_rec_types] :: IfGblEnv -> KnotVars (IfG TypeEnv)
data IfLclEnv
IfLclEnv :: !Module -> IsBootInterface -> SDoc -> Maybe NameShape -> Maybe TypeEnv -> FastStringEnv TyVar -> FastStringEnv Id -> IfLclEnv
[if_mod] :: IfLclEnv -> !Module
[if_boot] :: IfLclEnv -> IsBootInterface
[if_loc] :: IfLclEnv -> SDoc
[if_nsubst] :: IfLclEnv -> Maybe NameShape
[if_implicits_env] :: IfLclEnv -> Maybe TypeEnv
[if_tv_env] :: IfLclEnv -> FastStringEnv TyVar
[if_id_env] :: IfLclEnv -> FastStringEnv Id
tcVisibleOrphanMods :: TcGblEnv -> ModuleSet

-- | A <a>RewriteEnv</a> carries the necessary context for performing
--   rewrites (i.e. type family reductions and following filled-in
--   metavariables) in the solver.
data RewriteEnv
RE :: !CtLoc -> !CtFlavour -> !EqRel -> !TcRef RewriterSet -> RewriteEnv

-- | In which context are we rewriting?
--   
--   Type-checking plugins might want to use this location information when
--   emitting new Wanted constraints when rewriting type family
--   applications. This ensures that such Wanted constraints will, when
--   unsolved, give rise to error messages with the correct source
--   location.
[re_loc] :: RewriteEnv -> !CtLoc
[re_flavour] :: RewriteEnv -> !CtFlavour

-- | At what role are we rewriting? See Note [Rewriter EqRels] in
--   GHC.Tc.Solver.Rewrite
[re_eq_rel] :: RewriteEnv -> !EqRel

-- | See Note [Wanteds rewrite Wanteds]
[re_rewriters] :: RewriteEnv -> !TcRef RewriterSet

-- | <a>FrontendResult</a> describes the result of running the frontend of
--   a Haskell module. Currently one always gets a
--   <a>FrontendTypecheck</a>, since running the frontend involves
--   typechecking a program. hs-sig merges are not handled here.
--   
--   This data type really should be in GHC.Driver.Env, but it needs to
--   have a TcGblEnv which is only defined here.
data FrontendResult
FrontendTypecheck :: TcGblEnv -> FrontendResult

-- | Additional context to include in an error message, e.g. "In the type
--   signature ...", "In the ambiguity check for ...", etc.
type ErrCtxt = (Bool, TidyEnv -> ZonkM (TidyEnv, SDoc))

-- | <a>ImportAvails</a> summarises what was imported from where,
--   irrespective of whether the imported things are actually used or not.
--   It is used:
--   
--   <ul>
--   <li>when processing the export list,</li>
--   <li>when constructing usage info for the interface file,</li>
--   <li>to identify the list of directly imported modules for
--   initialisation purposes and for optimised overlap checking of family
--   instances,</li>
--   <li>when figuring out what things are really unused</li>
--   </ul>
data ImportAvails
ImportAvails :: ImportedMods -> InstalledModuleEnv ModuleNameWithIsBoot -> Set UnitId -> Bool -> Set UnitId -> InstalledModuleEnv ModuleNameWithIsBoot -> [ModuleName] -> [Module] -> [Module] -> ImportAvails

-- | Domain is all directly-imported modules
--   
--   See the documentation on ImportedModsVal in
--   <a>GHC.Unit.Module.Imported</a> for the meaning of the fields.
--   
--   We need a full ModuleEnv rather than a ModuleNameEnv here, because we
--   might be importing modules of the same name from different packages.
--   (currently not the case, but might be in the future).
[imp_mods] :: ImportAvails -> ImportedMods

-- | Home-package modules directly imported by the module being compiled.
[imp_direct_dep_mods] :: ImportAvails -> InstalledModuleEnv ModuleNameWithIsBoot

-- | Packages directly needed by the module being compiled
[imp_dep_direct_pkgs] :: ImportAvails -> Set UnitId

-- | Do we require that our own package is trusted? This is to handle
--   efficiently the case where a Safe module imports a Trustworthy module
--   that resides in the same package as it. See Note [Trust Own Package]
--   in <a>GHC.Rename.Names</a>
[imp_trust_own_pkg] :: ImportAvails -> Bool

-- | This records the packages the current module needs to trust for Safe
--   Haskell compilation to succeed. A package is required to be trusted if
--   we are dependent on a trustworthy module in that package. See Note
--   [Tracking Trust Transitively] in <a>GHC.Rename.Names</a>
[imp_trust_pkgs] :: ImportAvails -> Set UnitId

-- | Domain is all modules which have hs-boot files, and whether we should
--   import the boot version of interface file. Only used in one-shot mode
--   to populate eps_is_boot.
[imp_boot_mods] :: ImportAvails -> InstalledModuleEnv ModuleNameWithIsBoot

-- | Signature modules below this one
[imp_sig_mods] :: ImportAvails -> [ModuleName]

-- | Orphan modules below us in the import tree (and maybe including us for
--   imported modules)
[imp_orphs] :: ImportAvails -> [Module]

-- | Family instance modules below us in the import tree (and maybe
--   including us for imported modules)
[imp_finsts] :: ImportAvails -> [Module]
emptyImportAvails :: ImportAvails

-- | Union two ImportAvails
--   
--   This function is a key part of Import handling, basically for each
--   import we create a separate ImportAvails structure and then union them
--   all together with this function.
plusImportAvails :: ImportAvails -> ImportAvails -> ImportAvails

-- | The import specification as written by the user, including the list of
--   explicitly imported names. Used in <tt>ModIface</tt> to allow GHCi to
--   reconstruct the top level environment on demand.
--   
--   This is distinct from <a>ImportSpec</a> because we don't want to store
--   the list of explicitly imported names along with each <a>GRE</a>
--   
--   We don't want to store the entire GlobalRdrEnv for modules that are
--   imported without explicit export lists, as these may grow to be very
--   large. However, GlobalRdrEnvs which are the result of explicit import
--   lists are typically quite small.
--   
--   Why do we not store something like (Maybe (ImportListInterpretation,
--   [IE GhcPs]) in such a case? Because we don't want to store source
--   syntax including annotations in interface files.
data ImportUserSpec
ImpUserSpec :: !ImpDeclSpec -> !ImpUserList -> ImportUserSpec
[ius_decl] :: ImportUserSpec -> !ImpDeclSpec
[ius_imports] :: ImportUserSpec -> !ImpUserList
data ImpUserList

-- | no user import list
ImpUserAll :: ImpUserList
ImpUserExplicit :: !GlobalRdrEnv -> ImpUserList
ImpUserEverythingBut :: !NameSet -> ImpUserList
mkModDeps :: Set (UnitId, ModuleNameWithIsBoot) -> InstalledModuleEnv ModuleNameWithIsBoot
type TcTypeEnv = NameEnv TcTyThing
type TcBinderStack = [TcBinder]
data TcBinder
TcIdBndr :: TcId -> TopLevelFlag -> TcBinder
TcIdBndr_ExpType :: Name -> ExpType -> TopLevelFlag -> TcBinder
TcTvBndr :: Name -> TyVar -> TcBinder

-- | A typecheckable thing available in a local context. Could be
--   <a>AGlobal</a> <a>TyThing</a>, but also lexically scoped variables,
--   etc. See <a>GHC.Tc.Utils.Env</a> for how to retrieve a <a>TyThing</a>
--   given a <a>Name</a>.
data TcTyThing
AGlobal :: TyThing -> TcTyThing
ATcId :: Id -> IdBindingInfo -> TcTyThing
[tct_id] :: TcTyThing -> Id
[tct_info] :: TcTyThing -> IdBindingInfo
ATyVar :: Name -> TcTyVar -> TcTyThing
ATcTyCon :: TyCon -> TcTyThing
APromotionErr :: PromotionErr -> TcTyThing

-- | Matches on either a global <a>TyCon</a> or a <a>TcTyCon</a>.
tcTyThingTyCon_maybe :: TcTyThing -> Maybe TyCon
data PromotionErr
TyConPE :: PromotionErr
ClassPE :: PromotionErr
FamDataConPE :: PromotionErr
ConstrainedDataConPE :: ThetaType -> PromotionErr
PatSynPE :: PromotionErr
RecDataConPE :: PromotionErr
TermVariablePE :: PromotionErr
TypeVariablePE :: PromotionErr

-- | IdBindingInfo describes how an Id is bound.
--   
--   It is used for the following purposes: a) for static forms in
--   <a>checkClosedInStaticForm</a> and b) to figure out when a nested
--   binding can be generalised, in <a>decideGeneralisationPlan</a>.
data IdBindingInfo
NotLetBound :: IdBindingInfo
ClosedLet :: IdBindingInfo
NonClosedLet :: RhsNames -> ClosedTypeId -> IdBindingInfo
type ClosedTypeId = Bool
type RhsNames = NameSet

-- | IsGroupClosed describes a group of mutually-recursive bindings
data IsGroupClosed
IsGroupClosed :: NameEnv RhsNames -> ClosedTypeId -> IsGroupClosed
data SelfBootInfo
NoSelfBoot :: SelfBootInfo
SelfBoot :: ModDetails -> SelfBootInfo
[sb_mds] :: SelfBootInfo -> ModDetails
bootExports :: SelfBootInfo -> NameSet
tcTyThingCategory :: TcTyThing -> String
pprTcTyThingCategory :: TcTyThing -> SDoc
peCategory :: PromotionErr -> String
pprPECategory :: PromotionErr -> SDoc
type CompleteMatch = CompleteMatchX Name
type CompleteMatches = [CompleteMatch]
data ThStage
Splice :: SpliceType -> ThStage
RunSplice :: TcRef [ForeignRef (Q ())] -> ThStage
Comp :: ThStage
Brack :: ThStage -> PendingStuff -> ThStage
data SpliceType
Typed :: SpliceType
Untyped :: SpliceType
data SpliceOrBracket
IsSplice :: SpliceOrBracket
IsBracket :: SpliceOrBracket
data PendingStuff
RnPendingUntyped :: TcRef [PendingRnSplice] -> PendingStuff
RnPendingTyped :: PendingStuff
TcPending :: TcRef [PendingTcSplice] -> TcRef WantedConstraints -> QuoteWrapper -> PendingStuff
topStage :: ThStage
topAnnStage :: ThStage
topSpliceStage :: ThStage
type ThLevel = Int
impLevel :: ThLevel
outerLevel :: ThLevel
thLevel :: ThStage -> ThLevel
data ForeignSrcLang
LangC :: ForeignSrcLang
LangCxx :: ForeignSrcLang
LangObjc :: ForeignSrcLang
LangObjcxx :: ForeignSrcLang
LangAsm :: ForeignSrcLang
LangJs :: ForeignSrcLang
RawObject :: ForeignSrcLang

-- | The current collection of docs that Template Haskell has built up via
--   putDoc.
type THDocs = Map DocLoc HsDoc GhcRn

-- | This is a mirror of Template Haskell's DocLoc, but the TH names are
--   resolved to GHC names.
data DocLoc
DeclDoc :: Name -> DocLoc
ArgDoc :: Name -> Int -> DocLoc
InstDoc :: Name -> DocLoc
ModuleDoc :: DocLoc
type ThBindEnv = NameEnv (TopLevelFlag, ThLevel)
data ArrowCtxt
NoArrowCtxt :: ArrowCtxt
ArrowCtxt :: LocalRdrEnv -> TcRef WantedConstraints -> ArrowCtxt
type TcSigFun = Name -> Maybe TcSigInfo
data TcSigInfo
TcIdSig :: TcIdSig -> TcSigInfo
TcPatSynSig :: TcPatSynSig -> TcSigInfo
data TcIdSig
TcCompleteSig :: TcCompleteSig -> TcIdSig
TcPartialSig :: TcPartialSig -> TcIdSig
data TcCompleteSig
CSig :: TcId -> UserTypeCtxt -> SrcSpan -> TcCompleteSig
[sig_bndr] :: TcCompleteSig -> TcId
[sig_ctxt] :: TcCompleteSig -> UserTypeCtxt
[sig_loc] :: TcCompleteSig -> SrcSpan
data TcPartialSig
PSig :: Name -> LHsSigWcType GhcRn -> UserTypeCtxt -> SrcSpan -> TcPartialSig
[psig_name] :: TcPartialSig -> Name
[psig_hs_ty] :: TcPartialSig -> LHsSigWcType GhcRn
[psig_ctxt] :: TcPartialSig -> UserTypeCtxt
[psig_loc] :: TcPartialSig -> SrcSpan
data TcPatSynSig
PatSig :: Name -> [InvisTVBinder] -> [InvisTVBinder] -> TcThetaType -> [InvisTVBinder] -> TcThetaType -> TcSigmaType -> TcPatSynSig
[patsig_name] :: TcPatSynSig -> Name
[patsig_implicit_bndrs] :: TcPatSynSig -> [InvisTVBinder]
[patsig_univ_bndrs] :: TcPatSynSig -> [InvisTVBinder]
[patsig_req] :: TcPatSynSig -> TcThetaType
[patsig_ex_bndrs] :: TcPatSynSig -> [InvisTVBinder]
[patsig_prov] :: TcPatSynSig -> TcThetaType
[patsig_body_ty] :: TcPatSynSig -> TcSigmaType
data TcIdSigInst
TISI :: TcIdSig -> [(Name, InvisTVBinder)] -> TcThetaType -> TcSigmaType -> [(Name, TcTyVar)] -> Maybe TcType -> TcIdSigInst
[sig_inst_sig] :: TcIdSigInst -> TcIdSig
[sig_inst_skols] :: TcIdSigInst -> [(Name, InvisTVBinder)]
[sig_inst_theta] :: TcIdSigInst -> TcThetaType
[sig_inst_tau] :: TcIdSigInst -> TcSigmaType
[sig_inst_wcs] :: TcIdSigInst -> [(Name, TcTyVar)]
[sig_inst_wcx] :: TcIdSigInst -> Maybe TcType
isPartialSig :: TcIdSigInst -> Bool

-- | No signature or a partial signature
hasCompleteSig :: TcSigFun -> Name -> Bool
tcSigInfoName :: TcSigInfo -> Name
tcIdSigLoc :: TcIdSig -> SrcSpan
completeSigPolyId_maybe :: TcSigInfo -> Maybe TcId
type TcId = Id

-- | A <a>NameShape</a> is a substitution on <a>Name</a>s that can be used
--   to refine the identities of a hole while we are renaming interfaces
--   (see <a>GHC.Iface.Rename</a>). Specifically, a <a>NameShape</a> for
--   <tt>ns_module_name</tt> <tt>A</tt>, defines a mapping from
--   <tt>{A.T}</tt> (for some <a>OccName</a> <tt>T</tt>) to some arbitrary
--   other <a>Name</a>.
--   
--   The most intriguing thing about a <a>NameShape</a>, however, is how
--   it's constructed. A <a>NameShape</a> is *implied* by the exported
--   <a>AvailInfo</a>s of the implementor of an interface: if an
--   implementor of signature <tt>&lt;H&gt;</tt> exports <tt>M.T</tt>, you
--   implicitly define a substitution from <tt>{H.T}</tt> to <tt>M.T</tt>.
--   So a <a>NameShape</a> is computed from the list of <a>AvailInfo</a>s
--   that are exported by the implementation of a module, or successively
--   merged together by the export lists of signatures which are joining
--   together.
--   
--   It's not the most obvious way to go about doing this, but it does seem
--   to work!
--   
--   NB: Can't boot this and put it in NameShape because then we start
--   pulling in too many DynFlags things.
data NameShape
NameShape :: ModuleName -> [AvailInfo] -> OccEnv Name -> NameShape
[ns_mod_name] :: NameShape -> ModuleName
[ns_exports] :: NameShape -> [AvailInfo]
[ns_map] :: NameShape -> OccEnv Name
removeBindingShadowing :: HasOccName a => [a] -> [a]

-- | Get target platform
getPlatform :: TcRnIf a b Platform
data TcPlugin
TcPlugin :: TcPluginM s -> (s -> TcPluginSolver) -> (s -> UniqFM TyCon TcPluginRewriter) -> (s -> TcPluginM ()) -> TcPlugin

-- | Initialize plugin, when entering type-checker.
[tcPluginInit] :: TcPlugin -> TcPluginM s

-- | Solve some constraints.
--   
--   This function will be invoked at two points in the constraint solving
--   process: once to simplify Given constraints, and once to solve Wanted
--   constraints. In the first case (and only in the first case), no Wanted
--   constraints will be passed to the plugin.
--   
--   The plugin can either return a contradiction, or specify that it has
--   solved some constraints (with evidence), and possibly emit additional
--   constraints. These returned constraints must be Givens in the first
--   case, and Wanteds in the second.
--   
--   Use <tt> \ _ _ _ _ -&gt; pure $ TcPluginOk [] [] </tt> if your plugin
--   does not provide this functionality.
[tcPluginSolve] :: TcPlugin -> s -> TcPluginSolver

-- | Rewrite saturated type family applications.
--   
--   The plugin is expected to supply a mapping from type family names to
--   rewriting functions. For each type family <a>TyCon</a>, the plugin
--   should provide a function which takes in the given constraints and
--   arguments of a saturated type family application, and return a
--   possible rewriting. See <a>TcPluginRewriter</a> for the expected shape
--   of such a function.
--   
--   Use <tt> \ _ -&gt; emptyUFM </tt> if your plugin does not provide this
--   functionality.
[tcPluginRewrite] :: TcPlugin -> s -> UniqFM TyCon TcPluginRewriter

-- | Clean up after the plugin, when exiting the type-checker.
[tcPluginStop] :: TcPlugin -> s -> TcPluginM ()

-- | Result of running a solver plugin.
data TcPluginSolveResult
TcPluginSolveResult :: [Ct] -> [(EvTerm, Ct)] -> [Ct] -> TcPluginSolveResult

-- | Insoluble constraints found by the plugin.
--   
--   These constraints will be added to the inert set, and reported as
--   insoluble to the user.
[tcPluginInsolubleCts] :: TcPluginSolveResult -> [Ct]

-- | Solved constraints, together with their evidence.
--   
--   These are removed from the inert set, and the evidence for them is
--   recorded.
[tcPluginSolvedCts] :: TcPluginSolveResult -> [(EvTerm, Ct)]

-- | New constraints that the plugin wishes to emit.
--   
--   These will be added to the work list.
[tcPluginNewCts] :: TcPluginSolveResult -> [Ct]

-- | The plugin found a contradiction. The returned constraints are removed
--   from the inert set, and recorded as insoluble.
--   
--   The returned list of constraints should never be empty.
pattern TcPluginContradiction :: [Ct] -> TcPluginSolveResult

-- | The plugin has not found any contradictions,
--   
--   The first field is for constraints that were solved. The second field
--   contains new work, that should be processed by the constraint solver.
pattern TcPluginOk :: [(EvTerm, Ct)] -> [Ct] -> TcPluginSolveResult
data TcPluginRewriteResult

-- | The plugin does not rewrite the type family application.
TcPluginNoRewrite :: TcPluginRewriteResult

-- | The plugin rewrites the type family application providing a rewriting
--   together with evidence: a <a>Reduction</a>, which contains the
--   rewritten type together with a <tt>Coercion</tt> whose right-hand-side
--   type is the rewritten type.
--   
--   The plugin can also emit additional Wanted constraints.
TcPluginRewriteTo :: !Reduction -> [Ct] -> TcPluginRewriteResult
[tcPluginReduction] :: TcPluginRewriteResult -> !Reduction
[tcRewriterNewWanteds] :: TcPluginRewriteResult -> [Ct]

-- | The <tt>solve</tt> function of a type-checking plugin takes in Given
--   and Wanted constraints, and should return a <a>TcPluginSolveResult</a>
--   indicating which Wanted constraints it could solve, or whether any are
--   insoluble.
type TcPluginSolver = EvBindsVar -> [Ct] -> [Ct] -> TcPluginM TcPluginSolveResult

-- | For rewriting type family applications, a type-checking plugin
--   provides a function of this type for each type family <a>TyCon</a>.
--   
--   The function is provided with the current set of Given constraints,
--   together with the arguments to the type family. The type family
--   application will always be fully saturated.
type TcPluginRewriter = RewriteEnv -> [Ct] -> [TcType] -> TcPluginM TcPluginRewriteResult

-- | <a>TcPluginM</a> is the monad in which type-checking plugins operate.
data TcPluginM a

-- | This function provides an escape for direct access to the <tt>TcM</tt>
--   monad. It should not be used lightly, and the provided
--   <a>TcPluginM</a> API should be favoured instead.
unsafeTcPluginTcM :: TcM a -> TcPluginM a

-- | A plugin for controlling defaulting.
data DefaultingPlugin
DefaultingPlugin :: TcPluginM s -> (s -> FillDefaulting) -> (s -> TcPluginM ()) -> DefaultingPlugin

-- | Initialize plugin, when entering type-checker.
[dePluginInit] :: DefaultingPlugin -> TcPluginM s

-- | Default some types
[dePluginRun] :: DefaultingPlugin -> s -> FillDefaulting

-- | Clean up after the plugin, when exiting the type-checker.
[dePluginStop] :: DefaultingPlugin -> s -> TcPluginM ()

-- | A collection of candidate default types for sets of type variables.
data DefaultingProposal
DefaultingProposal :: [[(TcTyVar, Type)]] -> [Ct] -> DefaultingProposal

-- | The type variable assignments to try.
[deProposals] :: DefaultingProposal -> [[(TcTyVar, Type)]]

-- | The constraints against which defaults are checked.
[deProposalCts] :: DefaultingProposal -> [Ct]
type FillDefaulting = WantedConstraints -> TcPluginM [DefaultingProposal]
type RoleAnnotEnv = NameEnv LRoleAnnotDecl GhcRn
emptyRoleAnnotEnv :: RoleAnnotEnv
mkRoleAnnotEnv :: [LRoleAnnotDecl GhcRn] -> RoleAnnotEnv
lookupRoleAnnot :: RoleAnnotEnv -> Name -> Maybe (LRoleAnnotDecl GhcRn)
getRoleAnnots :: [Name] -> RoleAnnotEnv -> [LRoleAnnotDecl GhcRn]

-- | Check the <a>TcGblEnv</a> for consistency. Currently, only checks
--   axioms, but should check other aspects, too.
lintGblEnv :: Logger -> DynFlags -> TcGblEnv -> TcM ()

-- | An error which might arise during typechecking/renaming.
data TcRnMessage
instance GHC.Internal.Base.Applicative GHC.Tc.Types.TcPluginM
instance GHC.Driver.DynFlags.ContainsDynFlags (GHC.Tc.Types.Env gbl lcl)
instance GHC.Driver.Hooks.ContainsHooks (GHC.Tc.Types.Env gbl lcl)
instance GHC.Utils.Logger.ContainsLogger (GHC.Tc.Types.Env gbl lcl)
instance GHC.Unit.Module.ContainsModule gbl => GHC.Unit.Module.ContainsModule (GHC.Tc.Types.Env gbl lcl)
instance GHC.Unit.Module.ContainsModule GHC.Tc.Types.TcGblEnv
instance GHC.Classes.Eq GHC.Tc.Types.DocLoc
instance GHC.Internal.Base.Functor GHC.Tc.Types.TcPluginM
instance GHC.Internal.Control.Monad.Fail.MonadFail GHC.Tc.Types.TcPluginM
instance GHC.Internal.Base.Monad GHC.Tc.Types.TcPluginM
instance GHC.Classes.Ord GHC.Tc.Types.DocLoc
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.DefaultingProposal


-- | Functions for working with the typechecker environment (setters,
--   getters...).
module GHC.Tc.Utils.Monad

-- | Setup the initial typechecking environment
initTc :: HscEnv -> HscSource -> Bool -> Module -> RealSrcSpan -> TcM r -> IO (Messages TcRnMessage, Maybe r)

-- | Run a <a>TcM</a> action in the context of an existing <tt>GblEnv</tt>.
initTcWithGbl :: HscEnv -> TcGblEnv -> RealSrcSpan -> TcM r -> IO (Messages TcRnMessage, Maybe r)
initTcInteractive :: HscEnv -> TcM a -> IO (Messages TcRnMessage, Maybe a)
initTcRnIf :: Char -> HscEnv -> gbl -> lcl -> TcRnIf gbl lcl a -> IO a
discardResult :: TcM a -> TcM ()
getTopEnv :: TcRnIf gbl lcl HscEnv
updTopEnv :: (HscEnv -> HscEnv) -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
getGblEnv :: TcRnIf gbl lcl gbl
updGblEnv :: (gbl -> gbl) -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
setGblEnv :: gbl' -> TcRnIf gbl' lcl a -> TcRnIf gbl lcl a
getLclEnv :: TcRnIf gbl lcl lcl
updLclEnv :: (lcl -> lcl) -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
updLclCtxt :: (TcLclCtxt -> TcLclCtxt) -> TcRnIf gbl TcLclEnv a -> TcRnIf gbl TcLclEnv a
setLclEnv :: lcl' -> TcRnIf gbl lcl' a -> TcRnIf gbl lcl a
restoreLclEnv :: TcLclEnv -> TcRnIf gbl TcLclEnv a -> TcRnIf gbl TcLclEnv a
updTopFlags :: (DynFlags -> DynFlags) -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
getEnvs :: TcRnIf gbl lcl (gbl, lcl)
setEnvs :: (gbl', lcl') -> TcRnIf gbl' lcl' a -> TcRnIf gbl lcl a
updEnvs :: ((gbl, lcl) -> (gbl, lcl)) -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
restoreEnvs :: (TcGblEnv, TcLclEnv) -> TcRn a -> TcRn a
xoptM :: Extension -> TcRnIf gbl lcl Bool
doptM :: DumpFlag -> TcRnIf gbl lcl Bool
goptM :: GeneralFlag -> TcRnIf gbl lcl Bool
woptM :: WarningFlag -> TcRnIf gbl lcl Bool
setXOptM :: Extension -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
unsetXOptM :: Extension -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
unsetGOptM :: GeneralFlag -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
unsetWOptM :: WarningFlag -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a

-- | Do it flag is true
whenDOptM :: DumpFlag -> TcRnIf gbl lcl () -> TcRnIf gbl lcl ()
whenGOptM :: GeneralFlag -> TcRnIf gbl lcl () -> TcRnIf gbl lcl ()
whenWOptM :: WarningFlag -> TcRnIf gbl lcl () -> TcRnIf gbl lcl ()
whenXOptM :: Extension -> TcRnIf gbl lcl () -> TcRnIf gbl lcl ()
unlessXOptM :: Extension -> TcRnIf gbl lcl () -> TcRnIf gbl lcl ()
getGhcMode :: TcRnIf gbl lcl GhcMode
withoutDynamicNow :: TcRnIf gbl lcl a -> TcRnIf gbl lcl a
getEpsVar :: TcRnIf gbl lcl (TcRef ExternalPackageState)
getEps :: TcRnIf gbl lcl ExternalPackageState

-- | Update the external package state. Returns the second result of the
--   modifier function.
--   
--   This is an atomic operation and forces evaluation of the modified EPS
--   in order to avoid space leaks.
updateEps :: (ExternalPackageState -> (ExternalPackageState, a)) -> TcRnIf gbl lcl a

-- | Update the external package state.
--   
--   This is an atomic operation and forces evaluation of the modified EPS
--   in order to avoid space leaks.
updateEps_ :: (ExternalPackageState -> ExternalPackageState) -> TcRnIf gbl lcl ()
getHpt :: TcRnIf gbl lcl HomePackageTable
getEpsAndHug :: TcRnIf gbl lcl (ExternalPackageState, HomeUnitGraph)
newArrowScope :: TcM a -> TcM a
escapeArrowScope :: TcM a -> TcM a
newUnique :: TcRnIf gbl lcl Unique
newUniqueSupply :: TcRnIf gbl lcl UniqSupply
newName :: OccName -> TcM Name
newNameAt :: OccName -> SrcSpan -> TcM Name
cloneLocalName :: Name -> TcM Name
newSysName :: OccName -> TcRnIf gbl lcl Name
newSysLocalId :: FastString -> Mult -> TcType -> TcRnIf gbl lcl TcId
newSysLocalIds :: FastString -> [Scaled TcType] -> TcRnIf gbl lcl [TcId]
newTcRef :: MonadIO m => a -> m (TcRef a)
readTcRef :: MonadIO m => TcRef a -> m a
writeTcRef :: MonadIO m => TcRef a -> a -> m ()
updTcRef :: MonadIO m => TcRef a -> (a -> a) -> m ()
updTcRefM :: MonadIO m => TcRef a -> (a -> m a) -> m ()
traceTc :: String -> SDoc -> TcRn ()
traceRn :: String -> SDoc -> TcRn ()
traceOptTcRn :: DumpFlag -> SDoc -> TcRn ()

-- | Dump if the given <a>DumpFlag</a> is set.
dumpOptTcRn :: DumpFlag -> String -> DumpFormat -> SDoc -> TcRn ()

-- | Unconditionally dump some trace output
--   
--   Certain tests (T3017, Roles3, T12763 etc.) expect part of the output
--   generated by `-ddump-types` to be in <a>PprUser</a> style. However,
--   generally we want all other debugging output to use <a>PprDump</a>
--   style. We <a>PprUser</a> style if <tt>useUserStyle</tt> is True.
dumpTcRn :: Bool -> DumpFlag -> String -> DumpFormat -> SDoc -> TcRn ()
getNamePprCtx :: TcRn NamePprCtx

-- | Like logInfoTcRn, but for user consumption
printForUserTcRn :: SDoc -> TcRn ()
traceIf :: SDoc -> TcRnIf m n ()
traceOptIf :: DumpFlag -> SDoc -> TcRnIf m n ()
debugTc :: TcM () -> TcM ()
getIsGHCi :: TcRn Bool
getGHCiMonad :: TcRn Name
getInteractivePrintName :: TcRn Name
tcHscSource :: TcRn HscSource
tcIsHsBootOrSig :: TcRn Bool
tcIsHsig :: TcRn Bool
tcSelfBootInfo :: TcRn SelfBootInfo
getGlobalRdrEnv :: TcRn GlobalRdrEnv
getRdrEnvs :: TcRn (GlobalRdrEnv, LocalRdrEnv)
getImports :: TcRn ImportAvails
getFixityEnv :: TcRn FixityEnv
extendFixityEnv :: [(Name, FixItem)] -> RnM a -> RnM a
getDeclaredDefaultTys :: TcRn DefaultEnv
addDependentFiles :: [FilePath] -> TcRn ()
getSrcSpanM :: TcRn SrcSpan
setSrcSpan :: SrcSpan -> TcRn a -> TcRn a
setSrcSpanA :: EpAnn ann -> TcRn a -> TcRn a
addLocM :: HasLoc t => (a -> TcM b) -> GenLocated t a -> TcM b
inGeneratedCode :: TcRn Bool

-- | Mark the inner computation as being done inside generated code.
--   
--   See Note [Error contexts in generated code]
setInGeneratedCode :: TcRn a -> TcRn a
wrapLocM :: HasLoc t => (a -> TcM b) -> GenLocated t a -> TcM (Located b)
wrapLocFstM :: (a -> TcM (b, c)) -> Located a -> TcM (Located b, c)
wrapLocFstMA :: (a -> TcM (b, c)) -> GenLocated (EpAnn ann) a -> TcM (GenLocated (EpAnn ann) b, c)
wrapLocSndM :: (a -> TcM (b, c)) -> Located a -> TcM (b, Located c)
wrapLocSndMA :: (a -> TcM (b, c)) -> GenLocated (EpAnn ann) a -> TcM (b, GenLocated (EpAnn ann) c)
wrapLocM_ :: (a -> TcM ()) -> Located a -> TcM ()
wrapLocMA_ :: (a -> TcM ()) -> LocatedA a -> TcM ()
wrapLocMA :: (a -> TcM b) -> GenLocated (EpAnn ann) a -> TcRn (GenLocated (EpAnn ann) b)
getErrsVar :: TcRn (TcRef (Messages TcRnMessage))
setErrsVar :: TcRef (Messages TcRnMessage) -> TcRn a -> TcRn a
addErr :: TcRnMessage -> TcRn ()
failWith :: TcRnMessage -> TcRn a
failAt :: SrcSpan -> TcRnMessage -> TcRn a
addErrAt :: SrcSpan -> TcRnMessage -> TcRn ()
addErrs :: [(SrcSpan, TcRnMessage)] -> TcRn ()
checkErr :: Bool -> TcRnMessage -> TcRn ()
checkErrAt :: SrcSpan -> Bool -> TcRnMessage -> TcRn ()
addMessages :: Messages TcRnMessage -> TcRn ()
discardWarnings :: TcRn a -> TcRn a
mkDetailedMessage :: ErrInfo -> TcRnMessage -> TcRnMessageDetailed

-- | <tt>tcCollectingUsage thing_inside</tt> runs <tt>thing_inside</tt> and
--   returns the usage information which was collected as part of the
--   execution of <tt>thing_inside</tt>. Careful: <tt>tcCollectingUsage
--   thing_inside</tt> itself does not report any usage information, it's
--   up to the caller to incorporate the returned usage information into
--   the larger context appropriately.
tcCollectingUsage :: TcM a -> TcM (UsageEnv, a)

-- | <tt>tcScalingUsage mult thing_inside</tt> runs <tt>thing_inside</tt>
--   and scales all the usage information by <tt>mult</tt>.
tcScalingUsage :: Mult -> TcM a -> TcM a
tcEmitBindingUsage :: UsageEnv -> TcM ()
recoverM :: TcRn r -> TcRn r -> TcRn r

-- | Drop elements of the input that fail, so the result list can be
--   shorter than the argument list
mapAndRecoverM :: (a -> TcRn b) -> [a] -> TcRn [b]

-- | Apply the function to all elements on the input list If all succeed,
--   return the list of results Otherwise fail, propagating all errors
mapAndReportM :: (a -> TcRn b) -> [a] -> TcRn [b]

-- | The accumulator is not updated if the action fails
foldAndRecoverM :: (b -> a -> TcRn b) -> b -> [a] -> TcRn b
attemptM :: TcRn r -> TcRn (Maybe r)
tryTc :: TcRn a -> TcRn (Maybe a, Messages TcRnMessage)
askNoErrs :: TcRn a -> TcRn (a, Bool)
discardErrs :: TcRn a -> TcRn a
tryTcDiscardingErrs :: TcM r -> TcM r -> TcM r
checkNoErrs :: TcM r -> TcM r
whenNoErrs :: TcM () -> TcM ()
ifErrsM :: TcRn r -> TcRn r -> TcRn r
failIfErrsM :: TcRn ()
getErrCtxt :: TcM [ErrCtxt]
setErrCtxt :: [ErrCtxt] -> TcM a -> TcM a

-- | Add a fixed message to the error context. This message should not do
--   any tidying.
addErrCtxt :: SDoc -> TcM a -> TcM a

-- | Add a message to the error context. This message may do tidying.
addErrCtxtM :: (TidyEnv -> ZonkM (TidyEnv, SDoc)) -> TcM a -> TcM a

-- | Add a fixed landmark message to the error context. A landmark message
--   is always sure to be reported, even if there is a lot of context. It
--   also doesn't count toward the maximum number of contexts reported.
addLandmarkErrCtxt :: SDoc -> TcM a -> TcM a

-- | Variant of <a>addLandmarkErrCtxt</a> that allows for monadic
--   operations and tidying.
addLandmarkErrCtxtM :: (TidyEnv -> ZonkM (TidyEnv, SDoc)) -> TcM a -> TcM a
popErrCtxt :: TcM a -> TcM a
getCtLocM :: CtOrigin -> Maybe TypeOrKind -> TcM CtLoc
setCtLocM :: CtLoc -> TcM a -> TcM a
mkCtLocEnv :: TcLclEnv -> CtLocEnv
addErrTc :: TcRnMessage -> TcM ()
addErrTcM :: (TidyEnv, TcRnMessage) -> TcM ()
failWithTc :: TcRnMessage -> TcM a
failWithTcM :: (TidyEnv, TcRnMessage) -> TcM a
checkTc :: Bool -> TcRnMessage -> TcM ()
checkTcM :: Bool -> (TidyEnv, TcRnMessage) -> TcM ()
failIfTc :: Bool -> TcRnMessage -> TcM ()
failIfTcM :: Bool -> (TidyEnv, TcRnMessage) -> TcM ()
mkErrInfo :: TidyEnv -> [ErrCtxt] -> TcM SDoc
addTcRnDiagnostic :: TcRnMessage -> TcM ()

-- | A variation of <a>addDiagnostic</a> that takes a function to produce a
--   <tt>TcRnDsMessage</tt> given some additional context about the
--   diagnostic.
addDetailedDiagnostic :: (ErrInfo -> TcRnMessage) -> TcM ()
mkTcRnMessage :: SrcSpan -> TcRnMessage -> TcRn (MsgEnvelope TcRnMessage)
reportDiagnostic :: MsgEnvelope TcRnMessage -> TcRn ()
reportDiagnostics :: [MsgEnvelope TcRnMessage] -> TcM ()

-- | Display a warning if a condition is met.
warnIf :: Bool -> TcRnMessage -> TcRn ()

-- | Display a warning if a condition is met.
diagnosticTc :: Bool -> TcRnMessage -> TcM ()

-- | Display a diagnostic if a condition is met.
diagnosticTcM :: Bool -> (TidyEnv, TcRnMessage) -> TcM ()

-- | Display a diagnostic in the current context.
addDiagnosticTc :: TcRnMessage -> TcM ()

-- | Display a diagnostic in a given context.
addDiagnosticTcM :: (TidyEnv, TcRnMessage) -> TcM ()

-- | Display a diagnostic for the current source location, taken from the
--   <a>TcRn</a> monad.
addDiagnostic :: TcRnMessage -> TcRn ()

-- | Display a diagnostic for a given source location.
addDiagnosticAt :: SrcSpan -> TcRnMessage -> TcRn ()
newTcEvBinds :: TcM EvBindsVar

-- | Creates an EvBindsVar incapable of holding any bindings. It still
--   tracks covar usages (see comments on ebv_tcvs in
--   <a>GHC.Tc.Types.Evidence</a>), thus must be made monadically
newNoTcEvBinds :: TcM EvBindsVar
cloneEvBindsVar :: EvBindsVar -> TcM EvBindsVar
addTcEvBind :: EvBindsVar -> EvBind -> TcM ()
addTopEvBinds :: Bag EvBind -> TcM a -> TcM a
getTcEvTyCoVars :: EvBindsVar -> TcM TyCoVarSet
getTcEvBindsMap :: EvBindsVar -> TcM EvBindMap
setTcEvBindsMap :: EvBindsVar -> EvBindMap -> TcM ()
chooseUniqueOccTc :: (OccSet -> OccName) -> TcM OccName
getConstraintVar :: TcM (TcRef WantedConstraints)
setConstraintVar :: TcRef WantedConstraints -> TcM a -> TcM a
emitConstraints :: WantedConstraints -> TcM ()
emitStaticConstraints :: WantedConstraints -> TcM ()
emitSimple :: Ct -> TcM ()
emitSimples :: Cts -> TcM ()
emitImplication :: Implication -> TcM ()
emitImplications :: Bag Implication -> TcM ()
emitDelayedErrors :: Bag DelayedError -> TcM ()
emitHole :: Hole -> TcM ()
emitHoles :: Bag Hole -> TcM ()
emitNotConcreteError :: NotConcreteError -> TcM ()

-- | Throw out any constraints emitted by the thing_inside
discardConstraints :: TcM a -> TcM a
captureConstraints :: TcM a -> TcM (a, WantedConstraints)
tryCaptureConstraints :: TcM a -> TcM (Maybe a, WantedConstraints)

-- | The name says it all. The returned TcLevel is the *inner* TcLevel.
pushLevelAndCaptureConstraints :: TcM a -> TcM (TcLevel, WantedConstraints, a)
pushTcLevelM_ :: TcM a -> TcM a
pushTcLevelM :: TcM a -> TcM (TcLevel, a)
getTcLevel :: TcM TcLevel
setTcLevel :: TcLevel -> TcM a -> TcM a
isTouchableTcM :: TcTyVar -> TcM Bool
getLclTypeEnv :: TcM TcTypeEnv
setLclTypeEnv :: TcLclEnv -> TcM a -> TcM a
traceTcConstraints :: String -> TcM ()
emitNamedTypeHole :: (Name, TcTyVar) -> TcM ()
data IsExtraConstraint
YesExtraConstraint :: IsExtraConstraint
NoExtraConstraint :: IsExtraConstraint
emitAnonTypeHole :: IsExtraConstraint -> TcTyVar -> TcM ()
recordThUse :: TcM ()
recordThSpliceUse :: TcM ()
recordThNeededRuntimeDeps :: [Linkable] -> PkgsLoaded -> TcM ()
keepAlive :: Name -> TcRn ()
getStage :: TcM ThStage
getStageAndBindLevel :: Name -> TcRn (Maybe (TopLevelFlag, ThLevel, ThStage))
setStage :: ThStage -> TcM a -> TcRn a

-- | Adds the given modFinalizers to the global environment and set them to
--   use the current local environment.
addModFinalizersWithLclEnv :: ThModFinalizers -> TcM ()

-- | Mark that safe inference has failed See Note [Safe Haskell Overlapping
--   Instances Implementation] although this is used for more than just
--   that failure case.
recordUnsafeInfer :: Messages TcRnMessage -> TcM ()

-- | Figure out the final correct safe haskell mode
finalSafeMode :: DynFlags -> TcGblEnv -> IO SafeHaskellMode

-- | Switch instances to safe instances if we're in Safe mode.
fixSafeInstances :: SafeHaskellMode -> [ClsInst] -> [ClsInst]
getLocalRdrEnv :: RnM LocalRdrEnv
setLocalRdrEnv :: LocalRdrEnv -> RnM a -> RnM a
mkIfLclEnv :: Module -> SDoc -> IsBootInterface -> IfLclEnv

-- | Run an <a>IfG</a> (top-level interface monad) computation inside an
--   existing <a>TcRn</a> (typecheck-renaming monad) computation by
--   initializing an <a>IfGblEnv</a> based on <a>TcGblEnv</a>.
initIfaceTcRn :: IfG a -> TcRn a
initIfaceCheck :: SDoc -> HscEnv -> IfG a -> IO a
initIfaceLcl :: Module -> SDoc -> IsBootInterface -> IfL a -> IfM lcl a

-- | Initialize interface typechecking, but with a <a>NameShape</a> to
--   apply when typechecking top-level <a>OccName</a>s (see
--   <tt>lookupIfaceTop</tt>)
initIfaceLclWithSubst :: Module -> SDoc -> IsBootInterface -> NameShape -> IfL a -> IfM lcl a

-- | <a>initIfaceLoad</a> can be used when there's no chance that the
--   action will call <tt>typecheckIface</tt> when inside a module loop and
--   hence <tt>tcIfaceGlobal</tt>.
initIfaceLoad :: HscEnv -> IfG a -> IO a

-- | This is used when we are doing to call <tt>typecheckModule</tt> on an
--   <tt>ModIface</tt>, if it's part of a loop with some other modules then
--   we need to use their IORef TypeEnv vars when typechecking but
--   crucially not our own.
initIfaceLoadModule :: HscEnv -> Module -> IfG a -> IO a
getIfModule :: IfL Module
failIfM :: SDoc -> IfL a

-- | Run thing_inside in an interleaved thread. It shares everything with
--   the parent thread, so this is DANGEROUS.
--   
--   It throws an error if the computation fails
--   
--   It's used for lazily type-checking interface signatures, which is
--   pretty benign.
--   
--   See Note [Masking exceptions in forkM]
forkM :: SDoc -> IfL a -> IfL a
setImplicitEnvM :: TypeEnv -> IfL a -> IfL a

-- | A convenient wrapper for taking a <tt>MaybeErr SDoc a</tt> and
--   throwing an exception if it is an error.
withException :: MonadIO m => SDocContext -> m (MaybeErr SDoc a) -> m a
withIfaceErr :: MonadIO m => SDocContext -> m (MaybeErr MissingInterfaceError a) -> m a

-- | Get the next cost centre index associated with a given name.
getCCIndexM :: (gbl -> TcRef CostCentreState) -> FastString -> TcRnIf gbl lcl CostCentreIndex

-- | See <a>getCCIndexM</a>.
getCCIndexTcM :: FastString -> TcM CostCentreIndex

-- | Lift a computation from the dedicated zonking monad <a>ZonkM</a> to
--   the full-fledged <a>TcM</a> monad.
liftZonkM :: ZonkM a -> TcM a
newZonkAnyType :: Kind -> TcM Type
localAndImportedCompleteMatches :: CompleteMatches -> HscEnv -> ExternalPackageState -> CompleteMatches
getCompleteMatchesTcM :: TcM CompleteMatches
instance GHC.Types.Unique.Supply.MonadUnique (GHC.Data.IOEnv.IOEnv (GHC.Tc.Types.Env gbl lcl))
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.Monad.IsExtraConstraint

module GHC.Rename.Unbound
mkUnboundName :: OccName -> Name
mkUnboundNameRdr :: RdrName -> Name
mkUnboundGRE :: OccName -> GlobalRdrElt
mkUnboundGRERdr :: RdrName -> GlobalRdrElt
isUnboundName :: Name -> Bool
reportUnboundName :: RdrName -> RnM Name
reportUnboundName' :: WhatLooking -> RdrName -> RnM Name

-- | Called from the typechecker (<a>GHC.Tc.Errors</a>) when we find an
--   unbound variable
unknownNameSuggestions :: LocalRdrEnv -> WhatLooking -> RdrName -> RnM ([ImportError], [GhcHint])
similarNameSuggestions :: LookingFor -> DynFlags -> GlobalRdrEnv -> LocalRdrEnv -> RdrName -> [SimilarName]

-- | When the name is in scope as field whose selector has been suppressed
--   by NoFieldSelectors, display a helpful message explaining this.
fieldSelectorSuggestions :: GlobalRdrEnv -> RdrName -> [GhcHint]
data WhatLooking
WL_Anything :: WhatLooking
WL_Constructor :: WhatLooking
WL_RecField :: WhatLooking
WL_None :: WhatLooking
data WhereLooking
WL_Anywhere :: WhereLooking
WL_Global :: WhereLooking
WL_LocalTop :: WhereLooking
WL_LocalOnly :: WhereLooking
data LookingFor
LF :: WhatLooking -> WhereLooking -> LookingFor
[lf_which] :: LookingFor -> WhatLooking
[lf_where] :: LookingFor -> WhereLooking
unboundName :: LookingFor -> RdrName -> RnM Name
unboundNameX :: LookingFor -> RdrName -> [GhcHint] -> RnM Name
unboundTermNameInTypes :: LookingFor -> RdrName -> RdrName -> RnM Name
data IsTermInTypes
UnknownTermInTypes :: RdrName -> IsTermInTypes
TermInTypes :: RdrName -> IsTermInTypes
NoTermInTypes :: IsTermInTypes
notInScopeErr :: WhereLooking -> RdrName -> NotInScopeError
nameSpacesRelated :: DynFlags -> WhatLooking -> NameSpace -> NameSpace -> Bool
termNameInType :: LookingFor -> RdrName -> RdrName -> [GhcHint] -> RnM Name
instance GHC.Classes.Eq GHC.Rename.Unbound.WhatLooking

module GHC.Iface.Env
newGlobalBinder :: Module -> OccName -> SrcSpan -> TcRnIf a b Name
newInteractiveBinder :: HscEnv -> OccName -> SrcSpan -> IO Name
externaliseName :: Module -> Name -> TcRnIf m n Name

-- | Look up a top-level name from the current Iface module
lookupIfaceTop :: OccName -> IfL Name

-- | Look up the <a>Name</a> for a given <a>Module</a> and <a>OccName</a>.
--   Consider alternatively using <a>lookupIfaceTop</a> if you're in the
--   <a>IfL</a> monad and <a>Module</a> is simply that of the
--   <a>ModIface</a> you are typechecking.
lookupOrig :: Module -> OccName -> TcRnIf a b Name
lookupNameCache :: NameCache -> Module -> OccName -> IO Name
lookupOrigNameCache :: OrigNameCache -> Module -> OccName -> Maybe Name
newIfaceName :: OccName -> IfL Name
newIfaceNames :: [OccName] -> IfL [Name]
extendIfaceIdEnv :: [Id] -> IfL a -> IfL a
extendIfaceTyVarEnv :: [TyVar] -> IfL a -> IfL a
tcIfaceLclId :: IfLclName -> IfL Id
tcIfaceTyVar :: IfLclName -> IfL TyVar
lookupIfaceVar :: IfaceBndr -> IfL (Maybe TyCoVar)
lookupIfaceTyVar :: IfaceTvBndr -> IfL (Maybe TyVar)
extendIfaceEnvs :: [TyCoVar] -> IfL a -> IfL a

-- | Set the <a>Module</a> of a <a>Name</a>.
setNameModule :: Maybe Module -> Name -> TcRnIf m n Name
ifaceExportNames :: [IfaceExport] -> TcRnIf gbl lcl [AvailInfo]
trace_if :: Logger -> SDoc -> IO ()
trace_hi_diffs :: Logger -> SDoc -> IO ()
allocateGlobalBinder :: NameCache -> Module -> OccName -> SrcSpan -> IO Name

module GHC.Types.Name.Shape

-- | A <a>NameShape</a> is a substitution on <a>Name</a>s that can be used
--   to refine the identities of a hole while we are renaming interfaces
--   (see <a>GHC.Iface.Rename</a>). Specifically, a <a>NameShape</a> for
--   <tt>ns_module_name</tt> <tt>A</tt>, defines a mapping from
--   <tt>{A.T}</tt> (for some <a>OccName</a> <tt>T</tt>) to some arbitrary
--   other <a>Name</a>.
--   
--   The most intriguing thing about a <a>NameShape</a>, however, is how
--   it's constructed. A <a>NameShape</a> is *implied* by the exported
--   <a>AvailInfo</a>s of the implementor of an interface: if an
--   implementor of signature <tt>&lt;H&gt;</tt> exports <tt>M.T</tt>, you
--   implicitly define a substitution from <tt>{H.T}</tt> to <tt>M.T</tt>.
--   So a <a>NameShape</a> is computed from the list of <a>AvailInfo</a>s
--   that are exported by the implementation of a module, or successively
--   merged together by the export lists of signatures which are joining
--   together.
--   
--   It's not the most obvious way to go about doing this, but it does seem
--   to work!
--   
--   NB: Can't boot this and put it in NameShape because then we start
--   pulling in too many DynFlags things.
data NameShape
NameShape :: ModuleName -> [AvailInfo] -> OccEnv Name -> NameShape
[ns_mod_name] :: NameShape -> ModuleName
[ns_exports] :: NameShape -> [AvailInfo]
[ns_map] :: NameShape -> OccEnv Name

-- | Create an empty <a>NameShape</a> (i.e., the renaming that would occur
--   with an implementing module with no exports) for a specific hole
--   <tt>mod_name</tt>.
emptyNameShape :: ModuleName -> NameShape

-- | Create a <a>NameShape</a> corresponding to an implementing module for
--   the hole <tt>mod_name</tt> that exports a list of <a>AvailInfo</a>s.
mkNameShape :: ModuleName -> [AvailInfo] -> NameShape

-- | Given an existing <a>NameShape</a>, merge it with a list of
--   <a>AvailInfo</a>s with Backpack style mix-in linking. This is used
--   solely when merging signatures together: we successively merge the
--   exports of each signature until we have the final, full exports of the
--   merged signature.
--   
--   What makes this operation nontrivial is what we are supposed to do
--   when we want to merge in an export for M.T when we already have an
--   existing export {H.T}. What should happen in this case is that {H.T}
--   should be unified with <tt>M.T</tt>: we've determined a more *precise*
--   identity for the export at <a>OccName</a> <tt>T</tt>.
--   
--   Note that we don't do unrestricted unification: only name holes from
--   <tt>ns_mod_name ns</tt> are flexible. This is because we have a much
--   more restricted notion of shaping than in Backpack'14: we do shaping
--   *as* we do type-checking. Thus, once we shape a signature, its exports
--   are *final* and we're not allowed to refine them further,
extendNameShape :: HscEnv -> NameShape -> [AvailInfo] -> IO (Either HsigShapeMismatchReason NameShape)

-- | The export list associated with this <a>NameShape</a> (i.e., what the
--   exports of an implementing module which induces this <a>NameShape</a>
--   would be.)
nameShapeExports :: NameShape -> [AvailInfo]

-- | Given a <a>Name</a>, substitute it according to the <a>NameShape</a>
--   implied substitution, i.e. map <tt>{A.T}</tt> to <tt>M.T</tt>, if the
--   implementing module exports <tt>M.T</tt>.
substNameShape :: NameShape -> Name -> Name

-- | Like <a>substNameShape</a>, but returns <tt>Nothing</tt> if no
--   substitution works.
maybeSubstNameShape :: NameShape -> Name -> Maybe Name

module GHC.Tc.TyCl.Build
buildDataCon :: FamInstEnvs -> DataConBangOpts -> Name -> Bool -> TyConRepName -> [HsSrcBang] -> [FieldLabel] -> [TyVar] -> [TyCoVar] -> [InvisTVBinder] -> [EqSpec] -> KnotTied ThetaType -> [KnotTied (Scaled Type)] -> KnotTied Type -> KnotTied TyCon -> NameEnv ConTag -> TcRnIf m n DataCon
buildPatSyn :: Name -> Bool -> PatSynMatcher -> PatSynBuilder -> ([InvisTVBinder], ThetaType) -> ([InvisTVBinder], ThetaType) -> [FRRType] -> Type -> [FieldLabel] -> PatSyn
type TcMethInfo = MethInfo
type MethInfo = (Name, Type, Maybe DefMethSpec (SrcSpan, Type))
buildClass :: Name -> [TyConBinder] -> [Role] -> [FunDep TyVar] -> Maybe (KnotTied ThetaType, [ClassATItem], [KnotTied MethInfo], ClassMinimalDef) -> TcRnIf m n Class

-- | Monadic because it makes a Name for the coercion TyCon We pass the
--   Name of the parent TyCon, as well as the TyCon itself, because the
--   latter is part of a knot, whereas the former is not.
mkNewTyConRhs :: Name -> TyCon -> DataCon -> TcRnIf m n AlgTyConRhs
newImplicitBinder :: Name -> (OccName -> OccName) -> TcRnIf m n Name

-- | Make the <a>TyConRepName</a> for this <a>TyCon</a>
newTyConRepName :: Name -> TcRnIf gbl lcl TyConRepName


-- | This module implements interface renaming, which is used to rewrite
--   interface files on the fly when we are doing indefinite typechecking
--   and need instantiations of modules which do not necessarily exist yet.
module GHC.Iface.Rename

-- | What we have is a generalized ModIface, which corresponds to a module
--   that looks like p[A=&lt;A&gt;]:B. We need a *specific* ModIface, e.g.
--   p[A=q():A]:B (or maybe even p[A=&lt;B&gt;]:B) which we load up (either
--   to merge it, or to just use during typechecking).
--   
--   Suppose we have:
--   
--   p[A=&lt;A&gt;]:M ==&gt; p[A=q():A]:M
--   
--   Substitute all occurrences of &lt;A&gt; with q():A (renameHoleModule).
--   Then, for any Name of form {A.T}, replace the Name with the Name
--   according to the exports of the implementing module. This works even
--   for p[A=&lt;B&gt;]:M, since we just read in the exports of B.hi, which
--   is assumed to be ready now.
--   
--   This function takes an optional <a>NameShape</a>, which can be used to
--   further refine the identities in this interface: suppose we read a
--   declaration for {H.T} but we actually know that this should be Foo.T;
--   then we'll also rename this (this is used when loading an interface to
--   merge it into a requirement.)
rnModIface :: HscEnv -> [(ModuleName, Module)] -> Maybe NameShape -> ModIface -> IO (Either (Messages TcRnMessage) ModIface)

-- | Rename just the exports of a <a>ModIface</a>. Useful when we're doing
--   shaping prior to signature merging.
rnModExports :: HscEnv -> [(ModuleName, Module)] -> ModIface -> IO (Either (Messages TcRnMessage) [AvailInfo])
tcRnModIface :: [(ModuleName, Module)] -> Maybe NameShape -> ModIface -> TcM ModIface
tcRnModExports :: [(ModuleName, Module)] -> ModIface -> TcM [AvailInfo]


-- | Typechecking annotations
module GHC.Tc.Gen.Annotation
tcAnnotations :: [LAnnDecl GhcRn] -> TcM [Annotation]
annCtxt :: forall (p :: Pass). OutputableBndrId p => AnnDecl (GhcPass p) -> SDoc

module GHC.Tc.Errors.Hole.Plugin

-- | A plugin for modifying the candidate hole fits *before* they're
--   checked.
type CandPlugin = TypedHole -> [HoleFitCandidate] -> TcM [HoleFitCandidate]

-- | A plugin for modifying hole fits *after* they've been found.
type FitPlugin = TypedHole -> [HoleFit] -> TcM [HoleFit]

-- | A HoleFitPlugin is a pair of candidate and fit plugins.
data HoleFitPlugin
HoleFitPlugin :: CandPlugin -> FitPlugin -> HoleFitPlugin
[candPlugin] :: HoleFitPlugin -> CandPlugin
[fitPlugin] :: HoleFitPlugin -> FitPlugin

-- | HoleFitPluginR adds a TcRef to hole fit plugins so that plugins can
--   track internal state. Note the existential quantification, ensuring
--   that the state cannot be modified from outside the plugin.
data HoleFitPluginR
HoleFitPluginR :: TcM (TcRef s) -> (TcRef s -> HoleFitPlugin) -> (TcRef s -> TcM ()) -> HoleFitPluginR

-- | Initializes the TcRef to be passed to the plugin
[hfPluginInit] :: HoleFitPluginR -> TcM (TcRef s)

-- | The function defining the plugin itself
[hfPluginRun] :: HoleFitPluginR -> TcRef s -> HoleFitPlugin

-- | Cleanup of state, guaranteed to be called even on error
[hfPluginStop] :: HoleFitPluginR -> TcRef s -> TcM ()

module GHC.Rename.Doc
rnHsDoc :: WithHsDocIdentifiers a GhcPs -> RnM (WithHsDocIdentifiers a GhcRn)
rnLHsDoc :: LHsDoc GhcPs -> RnM (LHsDoc GhcRn)
rnLDocDecl :: LDocDecl GhcPs -> RnM (LDocDecl GhcRn)
rnDocDecl :: DocDecl GhcPs -> RnM (DocDecl GhcRn)


-- | Extract docs from the renamer output so they can be serialized.
module GHC.HsToCore.Docs

-- | Extract docs from renamer output. This is monadic since we need to be
--   able to read documentation added from Template Haskell's
--   <tt>putDoc</tt>, which is stored in <a>tcg_th_docs</a>.
extractDocs :: MonadIO m => DynFlags -> TcGblEnv -> m (Maybe Docs)
mkExportsDocs :: [(LIE GhcRn, Avails)] -> UniqMap Name (HsDoc GhcRn)

-- | If we have an explicit export list, we extract the documentation
--   structure from that. Otherwise we use the renamed exports and
--   declarations.
mkDocStructure :: Module -> ImportAvails -> Maybe [(LIE GhcRn, Avails)] -> HsGroup GhcRn -> [AvailInfo] -> OccEnv Name -> DocStructure
mkDocStructureFromExportList :: Module -> ImportAvails -> [(LIE GhcRn, Avails)] -> DocStructure

-- | Figure out the documentation structure by correlating the module
--   exports with the located declarations.
mkDocStructureFromDecls :: OccEnv Name -> [AvailInfo] -> HsGroup GhcRn -> DocStructure

-- | Extract named documentation chunks from the renamed declarations.
--   
--   If there is no explicit export list, we simply return an empty map
--   since there would be no way to link to a named chunk.
getNamedChunks :: forall (pass :: Pass). Bool -> HsGroup (GhcPass pass) -> Map String (HsDoc (GhcPass pass))

-- | Create decl and arg doc-maps by looping through the declarations. For
--   each declaration, find its names, its subordinates, and its doc
--   strings.
mkMaps :: OccEnv Name -> [Name] -> [(LHsDecl GhcRn, [HsDoc GhcRn])] -> (UniqMap Name [HsDoc GhcRn], UniqMap Name (IntMap (HsDoc GhcRn)))
getMainDeclBinder :: OccEnv Name -> HsDecl GhcRn -> [Name]

-- | The "OccEnv Name" is the default method environment for this module
--   Ultimately, the a special "defaultMethodOcc" name is used for the
--   signatures on bindings for default methods. Unfortunately, this name
--   isn't generated until typechecking, so it is not in the renamed AST.
--   We have to look it up from the <a>OccEnv</a> parameter constructed
--   from the typechecked AST. See also Note [default method Name] in
--   GHC.Iface.Recomp
sigNameNoLoc :: (UnXRec a, HasOccName (IdP a)) => OccEnv (IdP a) -> Sig a -> [IdP a]
getInstLoc :: forall (p :: Pass). Anno (IdGhcP p) ~ SrcSpanAnnN => InstDecl (GhcPass p) -> SrcSpan

-- | Get all subordinate declarations inside a declaration, and their docs.
--   A subordinate declaration is something like the associate type or data
--   family of a type class.
subordinates :: OccEnv Name -> Map RealSrcSpan Name -> HsDecl GhcRn -> [(Name, [HsDoc GhcRn], IntMap (HsDoc GhcRn))]

-- | Extract constructor argument docs from inside constructor decls.
conArgDocs :: ConDecl GhcRn -> IntMap (HsDoc GhcRn)
h98ConArgDocs :: HsConDeclH98Details GhcRn -> IntMap (HsDoc GhcRn)
gadtConArgDocs :: HsConDeclGADTDetails GhcRn -> HsType GhcRn -> IntMap (HsDoc GhcRn)
con_arg_docs :: Int -> [HsType GhcRn] -> IntMap (HsDoc GhcRn)
isValD :: HsDecl a -> Bool

-- | All the sub declarations of a class (that we handle), ordered by
--   source location, with documentation attached if it exists.
classDecls :: TyClDecl GhcRn -> [(LHsDecl GhcRn, [HsDoc GhcRn])]

-- | Extract function argument docs from inside top-level decls.
declTypeDocs :: HsDecl GhcRn -> IntMap (HsDoc GhcRn)
nubByName :: (a -> Name) -> [a] -> [a]

-- | Extract function argument docs from inside types.
typeDocs :: HsType GhcRn -> IntMap (HsDoc GhcRn)

-- | Extract function argument docs from inside types.
sigTypeDocs :: HsSigType GhcRn -> IntMap (HsDoc GhcRn)

-- | The top-level declarations of a module that we care about, ordered by
--   source location, with documentation attached if it exists.
topDecls :: HsGroup GhcRn -> [(LHsDecl GhcRn, [HsDoc GhcRn])]

-- | Take all declarations except pragmas, infix decls, rules from an
--   <a>HsGroup</a>.
ungroup :: HsGroup GhcRn -> [LHsDecl GhcRn]

-- | Collect docs and attach them to the right declarations.
--   
--   A declaration may have multiple doc strings attached to it.
--   
--   This is an example.
collectDocs :: UnXRec p => [LHsDecl p] -> [(LHsDecl p, [HsDoc p])]

-- | Filter out declarations that we don't handle in Haddock
filterDecls :: UnXRec p => [(LHsDecl p, doc)] -> [(LHsDecl p, doc)]

-- | Go through all class declarations and filter their sub-declarations
filterClasses :: forall (p :: Pass) doc. IsPass p => [(LHsDecl (GhcPass p), doc)] -> [(LHsDecl (GhcPass p), doc)]

-- | Was this signature given by the user?
isUserSig :: Sig name -> Bool

-- | Take a field of declarations from a data structure and create HsDecls
--   using the given constructor
mkDecls :: (struct -> [GenLocated l decl]) -> (decl -> hsDecl) -> struct -> [GenLocated l hsDecl]

-- | Extracts out individual maps of documentation added via Template
--   Haskell's <tt>putDoc</tt>.
extractTHDocs :: THDocs -> ExtractedTHDocs

-- | Unions together two <tt>ArgDocMaps</tt> (or ArgMaps in haddock-api),
--   such that two maps with values for the same key merge the inner map as
--   well. Left biased so <tt>unionArgMaps a b</tt> prefers <tt>a</tt> over
--   <tt>b</tt>.
unionArgMaps :: UniqMap Name (IntMap b) -> UniqMap Name (IntMap b) -> UniqMap Name (IntMap b)


-- | Definitions for writing <i>plugins</i> for GHC. Plugins can hook into
--   several areas of the compiler. See the <a>Plugin</a> type. These
--   plugins include type-checker plugins, source plugins, and core-to-core
--   plugins.
module GHC.Driver.Plugins
data Plugins
Plugins :: ![StaticPlugin] -> ![ExternalPlugin] -> ![LoadedPlugin] -> !([Linkable], PkgsLoaded) -> Plugins

-- | Static plugins which do not need dynamic loading. These plugins are
--   intended to be added by GHC API users directly to this list.
--   
--   To add dynamically loaded plugins through the GHC API see
--   <tt>addPluginModuleName</tt> instead.
[staticPlugins] :: Plugins -> ![StaticPlugin]

-- | External plugins loaded directly from libraries without loading module
--   interfaces.
[externalPlugins] :: Plugins -> ![ExternalPlugin]

-- | Plugins dynamically loaded after processing arguments. What will be
--   loaded here is directed by DynFlags.pluginModNames. Arguments are
--   loaded from DynFlags.pluginModNameOpts.
--   
--   The purpose of this field is to cache the plugins so they don't have
--   to be loaded each time they are needed. See <a>initializePlugins</a>.
[loadedPlugins] :: Plugins -> ![LoadedPlugin]

-- | The object files required by the loaded plugins See Note [Plugin
--   dependencies]
[loadedPluginDeps] :: Plugins -> !([Linkable], PkgsLoaded)
emptyPlugins :: Plugins

-- | <a>Plugin</a> is the compiler plugin data type. Try to avoid
--   constructing one of these directly, and just modify some fields of
--   <a>defaultPlugin</a> instead: this is to try and preserve source-code
--   compatibility when we add fields to this.
--   
--   Nonetheless, this API is preliminary and highly likely to change in
--   the future.
data Plugin
Plugin :: CorePlugin -> TcPlugin -> DefaultingPlugin -> HoleFitPlugin -> ([CommandLineOption] -> HscEnv -> IO HscEnv) -> LatePlugin -> ([CommandLineOption] -> IO PluginRecompile) -> ([CommandLineOption] -> ModSummary -> ParsedResult -> Hsc ParsedResult) -> ([CommandLineOption] -> TcGblEnv -> HsGroup GhcRn -> TcM (TcGblEnv, HsGroup GhcRn)) -> ([CommandLineOption] -> ModSummary -> TcGblEnv -> TcM TcGblEnv) -> ([CommandLineOption] -> LHsExpr GhcTc -> TcM (LHsExpr GhcTc)) -> (forall lcl. () => [CommandLineOption] -> ModIface -> IfM lcl ModIface) -> Plugin

-- | Modify the Core pipeline that will be used for compilation. This is
--   called as the Core pipeline is built for every module being compiled,
--   and plugins get the opportunity to modify the pipeline in a
--   nondeterministic order.
[installCoreToDos] :: Plugin -> CorePlugin

-- | An optional typechecker plugin, which may modify the behaviour of the
--   constraint solver.
[tcPlugin] :: Plugin -> TcPlugin

-- | An optional defaulting plugin, which may specify the additional
--   type-defaulting rules.
[defaultingPlugin] :: Plugin -> DefaultingPlugin

-- | An optional plugin to handle hole fits, which may re-order or change
--   the list of valid hole fits and refinement hole fits.
[holeFitPlugin] :: Plugin -> HoleFitPlugin

-- | An optional plugin to update <a>HscEnv</a>, right after plugin
--   loading. This can be used to register hooks or tweak any field of
--   <tt>DynFlags</tt> before doing actual work on a module.
[driverPlugin] :: Plugin -> [CommandLineOption] -> HscEnv -> IO HscEnv

-- | A plugin that runs after interface creation and after late cost centre
--   insertion. Useful for transformations that should not impact
--   interfaces or optimization at all.
[latePlugin] :: Plugin -> LatePlugin

-- | Specify how the plugin should affect recompilation.
[pluginRecompile] :: Plugin -> [CommandLineOption] -> IO PluginRecompile

-- | Modify the module when it is parsed. This is called by
--   <a>GHC.Driver.Main</a> when the parser has produced no or only
--   non-fatal errors. Compilation will fail if the messages produced by
--   this function contain any errors.
[parsedResultAction] :: Plugin -> [CommandLineOption] -> ModSummary -> ParsedResult -> Hsc ParsedResult

-- | Modify each group after it is renamed. This is called after each
--   <a>HsGroup</a> has been renamed.
[renamedResultAction] :: Plugin -> [CommandLineOption] -> TcGblEnv -> HsGroup GhcRn -> TcM (TcGblEnv, HsGroup GhcRn)

-- | Modify the module when it is type checked. This is called at the very
--   end of typechecking.
[typeCheckResultAction] :: Plugin -> [CommandLineOption] -> ModSummary -> TcGblEnv -> TcM TcGblEnv

-- | Modify the TH splice or quasiqoute before it is run.
[spliceRunAction] :: Plugin -> [CommandLineOption] -> LHsExpr GhcTc -> TcM (LHsExpr GhcTc)

-- | Modify an interface that have been loaded. This is called by
--   <a>GHC.Iface.Load</a> when an interface is successfully loaded. Not
--   applied to the loading of the plugin interface. Tools that rely on
--   information from modules other than the currently compiled one should
--   implement this function.
[interfaceLoadAction] :: Plugin -> forall lcl. () => [CommandLineOption] -> ModIface -> IfM lcl ModIface

-- | Default plugin: does nothing at all, except for marking that safe
--   inference has failed unless <tt>-fplugin-trustworthy</tt> is passed.
--   For compatibility reason you should base all your plugin definitions
--   on this default value.
defaultPlugin :: Plugin

-- | Command line options gathered from the -PModule.Name:stuff syntax are
--   given to you as this type
type CommandLineOption = String

-- | Errors and warnings produced by the parser
data PsMessages
PsMessages :: Messages PsWarning -> Messages PsError -> PsMessages
[psWarnings] :: PsMessages -> Messages PsWarning
[psErrors] :: PsMessages -> Messages PsError

-- | Result of running the parser and the parser plugin
data ParsedResult
ParsedResult :: HsParsedModule -> PsMessages -> ParsedResult

-- | Parsed module, potentially modified by a plugin
[parsedResultModule] :: ParsedResult -> HsParsedModule

-- | Warnings and errors from parser, potentially modified by a plugin
[parsedResultMessages] :: ParsedResult -> PsMessages

-- | Load external plugins
loadExternalPlugins :: [ExternalPluginSpec] -> IO [ExternalPlugin]
purePlugin :: [CommandLineOption] -> IO PluginRecompile
impurePlugin :: [CommandLineOption] -> IO PluginRecompile
flagRecompile :: [CommandLineOption] -> IO PluginRecompile
data PluginRecompile
ForceRecompile :: PluginRecompile
NoForceRecompile :: PluginRecompile
MaybeRecompile :: Fingerprint -> PluginRecompile
data FrontendPlugin
FrontendPlugin :: FrontendPluginAction -> FrontendPlugin
[frontend] :: FrontendPlugin -> FrontendPluginAction
defaultFrontendPlugin :: FrontendPlugin
type FrontendPluginAction = [String] -> [(String, Maybe Phase)] -> Ghc ()
type CorePlugin = [CommandLineOption] -> [CoreToDo] -> CoreM [CoreToDo]
type TcPlugin = [CommandLineOption] -> Maybe TcPlugin

-- | A renamer plugin which mades the renamed source available in a
--   typechecker plugin.
keepRenamedSource :: [CommandLineOption] -> TcGblEnv -> HsGroup GhcRn -> TcM (TcGblEnv, HsGroup GhcRn)
type DefaultingPlugin = [CommandLineOption] -> Maybe DefaultingPlugin

-- | HoleFitPluginR adds a TcRef to hole fit plugins so that plugins can
--   track internal state. Note the existential quantification, ensuring
--   that the state cannot be modified from outside the plugin.
data HoleFitPluginR
type LatePlugin = HscEnv -> [CommandLineOption] -> (CgGuts, CostCentreState) -> IO (CgGuts, CostCentreState)
data PluginWithArgs
PluginWithArgs :: Plugin -> [CommandLineOption] -> PluginWithArgs

-- | the actual callable plugin
[paPlugin] :: PluginWithArgs -> Plugin

-- | command line arguments for the plugin
[paArguments] :: PluginWithArgs -> [CommandLineOption]
pluginsWithArgs :: Plugins -> [PluginWithArgs]
pluginRecompile' :: PluginWithArgs -> IO PluginRecompile

-- | A plugin with its arguments. The result of loading the plugin.
data LoadedPlugin
LoadedPlugin :: PluginWithArgs -> ModIface -> LoadedPlugin

-- | the actual plugin together with its commandline arguments
[lpPlugin] :: LoadedPlugin -> PluginWithArgs

-- | the module containing the plugin
[lpModule] :: LoadedPlugin -> ModIface
lpModuleName :: LoadedPlugin -> ModuleName

-- | A static plugin with its arguments. For registering compiled-in
--   plugins through the GHC API.
data StaticPlugin
StaticPlugin :: PluginWithArgs -> Bool -> StaticPlugin

-- | the actual plugin together with its commandline arguments
[spPlugin] :: StaticPlugin -> PluginWithArgs

-- | has this plugin been initialised (i.e. driverPlugin has been run)
[spInitialised] :: StaticPlugin -> Bool

-- | External plugin loaded directly from a library without loading module
--   interfaces
data ExternalPlugin
ExternalPlugin :: PluginWithArgs -> String -> String -> ExternalPlugin

-- | Plugin with its arguments
[epPlugin] :: ExternalPlugin -> PluginWithArgs

-- | UnitId
[epUnit] :: ExternalPlugin -> String

-- | Module name
[epModule] :: ExternalPlugin -> String
mapPlugins :: Plugins -> (Plugin -> [CommandLineOption] -> a) -> [a]

-- | Perform an operation by using all of the plugins in turn.
withPlugins :: Monad m => Plugins -> PluginOperation m a -> a -> m a

-- | Perform a constant operation by using all of the plugins in turn.
withPlugins_ :: Monad m => Plugins -> ConstPluginOperation m a -> a -> m ()
instance GHC.Internal.Base.Monoid GHC.Driver.Plugins.PluginRecompile
instance GHC.Utils.Outputable.Outputable GHC.Driver.Plugins.PluginRecompile
instance GHC.Internal.Base.Semigroup GHC.Driver.Plugins.PluginRecompile

module GHC.Driver.Pipeline.Phases
data TPhase res
[T_Unlit] :: PipeEnv -> HscEnv -> FilePath -> TPhase [Char]
[T_FileArgs] :: HscEnv -> FilePath -> TPhase (DynFlags, Messages PsMessage, Messages DriverMessage)
[T_Cpp] :: PipeEnv -> HscEnv -> FilePath -> TPhase [Char]
[T_HsPp] :: PipeEnv -> HscEnv -> FilePath -> FilePath -> TPhase [Char]
[T_HscRecomp] :: PipeEnv -> HscEnv -> FilePath -> HscSource -> TPhase (HscEnv, ModSummary, HscRecompStatus)
[T_Hsc] :: HscEnv -> ModSummary -> TPhase (FrontendResult, Messages GhcMessage)
[T_HscPostTc] :: HscEnv -> ModSummary -> FrontendResult -> Messages GhcMessage -> Maybe Fingerprint -> TPhase HscBackendAction
[T_HscBackend] :: PipeEnv -> HscEnv -> ModuleName -> HscSource -> ModLocation -> HscBackendAction -> TPhase ([FilePath], ModIface, HomeModLinkable, FilePath)
[T_CmmCpp] :: PipeEnv -> HscEnv -> FilePath -> TPhase [Char]
[T_Cmm] :: PipeEnv -> HscEnv -> FilePath -> TPhase ([FilePath], FilePath)
[T_Cc] :: Phase -> PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> TPhase [Char]
[T_As] :: Bool -> PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> TPhase [Char]
[T_Js] :: PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> TPhase [Char]
[T_ForeignJs] :: PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> TPhase [Char]
[T_LlvmOpt] :: PipeEnv -> HscEnv -> FilePath -> TPhase [Char]
[T_LlvmLlc] :: PipeEnv -> HscEnv -> FilePath -> TPhase [Char]
[T_LlvmAs] :: Bool -> PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> TPhase [Char]
[T_LlvmMangle] :: PipeEnv -> HscEnv -> FilePath -> TPhase [Char]
[T_MergeForeign] :: PipeEnv -> HscEnv -> FilePath -> [FilePath] -> TPhase [Char]

-- | A wrapper around the interpretation function for phases.
data PhaseHook
PhaseHook :: (forall a. () => TPhase a -> IO a) -> PhaseHook

module GHC.Driver.Hooks
data Hooks
class HasHooks (m :: Type -> Type)
getHooks :: HasHooks m => m Hooks
class ContainsHooks a
extractHooks :: ContainsHooks a => a -> Hooks

-- | Hooks can be used by GHC API clients to replace parts of the compiler
--   pipeline. If a hook is not installed, GHC uses the default built-in
--   behaviour
emptyHooks :: Hooks
type family DsForeignsHook

-- | Actual type: <tt>Maybe ([LForeignDecl GhcTc] -&gt; DsM (ForeignStubs,
--   OrdList (Id, CoreExpr)))</tt>
dsForeignsHook :: Hooks -> Maybe DsForeignsHook
tcForeignImportsHook :: Hooks -> Maybe ([LForeignDecl GhcRn] -> TcM ([Id], [LForeignDecl GhcTc], Bag GlobalRdrElt))
tcForeignExportsHook :: Hooks -> Maybe ([LForeignDecl GhcRn] -> TcM (LHsBinds GhcTc, [LForeignDecl GhcTc], Bag GlobalRdrElt))
hscFrontendHook :: Hooks -> Maybe (ModSummary -> Hsc FrontendResult)
hscCompileCoreExprHook :: Hooks -> Maybe (HscEnv -> SrcSpan -> CoreExpr -> IO (ForeignHValue, [Linkable], PkgsLoaded))
ghcPrimIfaceHook :: Hooks -> Maybe ModIface
runPhaseHook :: Hooks -> Maybe PhaseHook
runMetaHook :: Hooks -> Maybe (MetaHook TcM)
linkHook :: Hooks -> Maybe (GhcLink -> DynFlags -> Bool -> HomePackageTable -> IO SuccessFlag)
runRnSpliceHook :: Hooks -> Maybe (HsUntypedSplice GhcRn -> RnM (HsUntypedSplice GhcRn))
getValueSafelyHook :: Hooks -> Maybe (HscEnv -> Name -> Type -> IO (Either Type (HValue, [Linkable], PkgsLoaded)))
createIservProcessHook :: Hooks -> Maybe (CreateProcess -> IO ProcessHandle)
stgToCmmHook :: Hooks -> Maybe (StgToCmmConfig -> InfoTableProvMap -> [TyCon] -> CollectedCCs -> [CgStgTopBinding] -> CgStream CmmGroup ModuleLFInfos)
cmmToRawCmmHook :: Hooks -> forall a. () => Maybe (DynFlags -> Maybe Module -> CgStream CmmGroupSRTs a -> IO (CgStream RawCmmGroup a))


-- | Various types used during desugaring.
module GHC.HsToCore.Types

-- | Desugaring monad. See also <tt>TcM</tt>.
type DsM = TcRnIf DsGblEnv DsLclEnv

-- | Local state of the desugarer, extended as we lexically descend
data DsLclEnv
DsLclEnv :: DsMetaEnv -> RealSrcSpan -> Nablas -> Set EvVar -> DsLclEnv

-- | Template Haskell bindings
[dsl_meta] :: DsLclEnv -> DsMetaEnv

-- | To put in pattern-matching error msgs
[dsl_loc] :: DsLclEnv -> RealSrcSpan

-- | See Note [Long-distance information] in <a>GHC.HsToCore.Pmc</a>. The
--   set of reaching values Nablas is augmented as we walk inwards, refined
--   through each pattern match in turn
[dsl_nablas] :: DsLclEnv -> Nablas

-- | See Note [Desugaring non-canonical evidence]: this field collects all
--   un-specialisable evidence variables in scope.
[dsl_unspecables] :: DsLclEnv -> Set EvVar

-- | Global read-only context and state of the desugarer. The statefulness
--   is implemented through <a>IORef</a>s.
data DsGblEnv
DsGblEnv :: Module -> FamInstEnv -> GlobalRdrEnv -> NamePprCtx -> IORef (Messages DsMessage) -> (IfGblEnv, IfLclEnv) -> DsCompleteMatches -> IORef CostCentreState -> IORef (ModuleEnv Int) -> DsGblEnv
[ds_mod] :: DsGblEnv -> Module
[ds_fam_inst_env] :: DsGblEnv -> FamInstEnv
[ds_gbl_rdr_env] :: DsGblEnv -> GlobalRdrEnv
[ds_name_ppr_ctx] :: DsGblEnv -> NamePprCtx
[ds_msgs] :: DsGblEnv -> IORef (Messages DsMessage)
[ds_if_env] :: DsGblEnv -> (IfGblEnv, IfLclEnv)
[ds_complete_matches] :: DsGblEnv -> DsCompleteMatches
[ds_cc_st] :: DsGblEnv -> IORef CostCentreState

-- | See Note [Generating fresh names for FFI wrappers]
[ds_next_wrapper_num] :: DsGblEnv -> IORef (ModuleEnv Int)
type DsMetaEnv = NameEnv DsMetaVal
data DsMetaVal
DsBound :: Id -> DsMetaVal
DsSplice :: HsExpr GhcTc -> DsMetaVal
type CompleteMatches = [CompleteMatch]
instance GHC.Unit.Module.ContainsModule GHC.HsToCore.Types.DsGblEnv

module GHC.Driver.Config.CoreToStg.Prep
initCorePrepConfig :: HscEnv -> IO CorePrepConfig
initCorePrepPgmConfig :: DynFlags -> [Var] -> CorePrepPgmConfig

module GHC.Driver.Config.Core.Opt.Simplify
initSimplifyExprOpts :: DynFlags -> InteractiveContext -> SimplifyExprOpts
initSimplifyOpts :: DynFlags -> [Var] -> Int -> SimplMode -> RuleBase -> SimplifyOpts
initSimplMode :: DynFlags -> CompilerPhase -> String -> SimplMode
initGentleSimplMode :: DynFlags -> SimplMode

module GHC.Driver.Config.Core.Lint.Interactive
lintInteractiveExpr :: SDoc -> HscEnv -> CoreExpr -> IO ()

module GHC.Core.Opt.Pipeline
core2core :: HscEnv -> ModGuts -> IO ModGuts
simplifyExpr :: Logger -> ExternalUnitCache -> SimplifyExprOpts -> CoreExpr -> IO CoreExpr


-- | Bytecode assembler and linker
module GHC.ByteCode.Linker
linkBCO :: Interp -> PkgsLoaded -> LinkerEnv -> NameEnv Int -> UnlinkedBCO -> IO ResolvedBCO
lookupStaticPtr :: Interp -> FastString -> IO (Ptr ())
lookupIE :: Interp -> PkgsLoaded -> ItblEnv -> Name -> IO (Ptr ())
nameToCLabel :: Name -> String -> FastString
linkFail :: String -> String -> IO a


-- | The <tt>GHC.Builtin.Utils</tt> interface to the compiler's prelude
--   knowledge.
--   
--   This module serves as the central gathering point for names which the
--   compiler knows something about. This includes functions for,
--   
--   <ul>
--   <li>discerning whether a <a>Name</a> is known-key</li>
--   <li>given a <a>Unique</a>, looking up its corresponding known-key
--   <a>Name</a></li>
--   </ul>
--   
--   See Note [Known-key names] and Note [About wired-in things] for
--   information about the two types of prelude things in GHC.
module GHC.Builtin.Utils

-- | Is a <a>Name</a> known-key?
isKnownKeyName :: Name -> Bool

-- | Given a <a>Unique</a> lookup its associated <a>Name</a> if it
--   corresponds to a known-key thing.
lookupKnownKeyName :: Unique -> Maybe Name

-- | Given a <a>Unique</a> lookup any associated arbitrary SDoc's to be
--   displayed by GHCi's ':info' command.
lookupKnownNameInfo :: Name -> SDoc

-- | This list is used to ensure that when you say "Prelude.map" in your
--   source code, or in an interface file, you get a Name with the correct
--   known key (See Note [Known-key names] in <a>GHC.Builtin.Names</a>)
knownKeyNames :: [Name]
wiredInIds :: [Id]
ghcPrimIds :: [Id]
ghcPrimExports :: [IfaceExport]
ghcPrimDeclDocs :: Docs
ghcPrimWarns :: Warnings a
ghcPrimFixities :: [(OccName, Fixity)]
maybeCharLikeCon :: DataCon -> Bool
maybeIntLikeCon :: DataCon -> Bool
isNumericClass :: Class -> Bool
isStandardClass :: Class -> Bool

module GHC.StgToCmm.DataCon
cgTopRhsCon :: StgToCmmConfig -> Id -> DataCon -> ConstructorNumber -> [NonVoid StgArg] -> (CgIdInfo, FCode ())
buildDynCon :: Id -> ConstructorNumber -> Bool -> CostCentreStack -> DataCon -> [NonVoid StgArg] -> FCode (CgIdInfo, FCode CmmAGraph)
bindConArgs :: AltCon -> LocalReg -> [NonVoid Id] -> FCode [LocalReg]

module GHC.StgToCmm.Expr
cgExpr :: CgStgExpr -> FCode ReturnKind
cgLit :: Literal -> FCode CmmExpr

module GHC.StgToCmm.Bind
cgTopRhsClosure :: Platform -> RecFlag -> Id -> CostCentreStack -> UpdateFlag -> [Id] -> CgStgExpr -> (CgIdInfo, FCode ())
cgBind :: CgStgBinding -> FCode ()
emitBlackHoleCode :: CmmExpr -> FCode ()
pushUpdateFrame :: CLabel -> CmmExpr -> FCode () -> FCode ()
emitUpdateFrame :: CmmExpr -> CLabel -> CmmExpr -> FCode ()

module GHC.Cmm.Parser
parseCmmFile :: CmmParserConfig -> Module -> HomeUnit -> FilePath -> IO (Messages PsMessage, Messages PsMessage, Maybe (DCmmGroup, [InfoProvEnt]))
data CmmParserConfig
CmmParserConfig :: !ParserOpts -> !PDConfig -> !StgToCmmConfig -> CmmParserConfig
[cmmpParserOpts] :: CmmParserConfig -> !ParserOpts
[cmmpPDConfig] :: CmmParserConfig -> !PDConfig
[cmmpStgToCmmConfig] :: CmmParserConfig -> !StgToCmmConfig

module GHC.StgToCmm
codeGen :: Logger -> TmpFs -> StgToCmmConfig -> InfoTableProvMap -> [TyCon] -> CollectedCCs -> [CgStgTopBinding] -> CgStream CmmGroup (ModuleLFInfos, DetUniqFM)

module GHC.Iface.Ext.Types
type Span = RealSrcSpan

-- | Current version of <tt>.hie</tt> files
hieVersion :: Integer

-- | GHC builds up a wealth of information about Haskell source as it
--   compiles it. <tt>.hie</tt> files are a way of persisting some of this
--   information to disk so that external tools that need to work with
--   haskell source don't need to parse, typecheck, and rename all over
--   again. These files contain:
--   
--   <ul>
--   <li>a simplified AST<ul><li>nodes are annotated with source positions
--   and types</li><li>identifiers are annotated with scope
--   information</li></ul></li>
--   <li>the raw bytes of the initial Haskell source</li>
--   </ul>
--   
--   Besides saving compilation cycles, <tt>.hie</tt> files also offer a
--   more stable interface than the GHC API.
data HieFile
HieFile :: FilePath -> Module -> Array TypeIndex HieTypeFlat -> HieASTs TypeIndex -> [AvailInfo] -> ByteString -> NameEntityInfo -> HieFile

-- | Initial Haskell source file path
[hie_hs_file] :: HieFile -> FilePath

-- | The module this HIE file is for
[hie_module] :: HieFile -> Module

-- | Types referenced in the <a>hie_asts</a>.
--   
--   See Note [Efficient serialization of redundant type info]
[hie_types] :: HieFile -> Array TypeIndex HieTypeFlat

-- | Type-annotated abstract syntax trees
[hie_asts] :: HieFile -> HieASTs TypeIndex

-- | The names that this module exports
[hie_exports] :: HieFile -> [AvailInfo]

-- | Raw bytes of the initial Haskell source
[hie_hs_src] :: HieFile -> ByteString

-- | Entity information for each <a>Name</a> in the <a>hie_asts</a>
[hie_entity_infos] :: HieFile -> NameEntityInfo
type NameEntityInfo = Map Name Set EntityInfo
type TypeIndex = Int

-- | A flattened version of <a>Type</a>.
--   
--   See Note [Efficient serialization of redundant type info]
data HieType a
HTyVarTy :: Name -> HieType a
HAppTy :: a -> HieArgs a -> HieType a
HTyConApp :: IfaceTyCon -> HieArgs a -> HieType a
HForAllTy :: ((Name, a), ForAllTyFlag) -> a -> HieType a
HFunTy :: a -> a -> a -> HieType a

-- | type with constraint: <tt>t1 =&gt; t2</tt> (see <tt>IfaceDFunTy</tt>)
HQualTy :: a -> a -> HieType a
HLitTy :: IfaceTyLit -> HieType a
HCastTy :: a -> HieType a
HCoercionTy :: HieType a
type HieTypeFlat = HieType TypeIndex

-- | Roughly isomorphic to the original core <a>Type</a>.
newtype HieTypeFix
Roll :: HieType HieTypeFix -> HieTypeFix

-- | A list of type arguments along with their respective visibilities (ie.
--   is this an argument that would return <a>True</a> for
--   <tt>isVisibleForAllTyFlag</tt>?).
newtype HieArgs a
HieArgs :: [(Bool, a)] -> HieArgs a
type HiePath = LexicalFastString
pattern HiePath :: FastString -> HiePath

-- | Mapping from filepaths to the corresponding AST
newtype HieASTs a
HieASTs :: Map HiePath (HieAST a) -> HieASTs a
[getAsts] :: HieASTs a -> Map HiePath (HieAST a)
data HieAST a
Node :: SourcedNodeInfo a -> Span -> [HieAST a] -> HieAST a
[sourcedNodeInfo] :: HieAST a -> SourcedNodeInfo a
[nodeSpan] :: HieAST a -> Span
[nodeChildren] :: HieAST a -> [HieAST a]

-- | NodeInfos grouped by source
newtype SourcedNodeInfo a
SourcedNodeInfo :: Map NodeOrigin (NodeInfo a) -> SourcedNodeInfo a
[getSourcedNodeInfo] :: SourcedNodeInfo a -> Map NodeOrigin (NodeInfo a)

-- | Source of node info
data NodeOrigin
SourceInfo :: NodeOrigin
GeneratedInfo :: NodeOrigin

-- | A node annotation
data NodeAnnotation
NodeAnnotation :: !FastString -> !FastString -> NodeAnnotation

-- | name of the AST node constructor
[nodeAnnotConstr] :: NodeAnnotation -> !FastString

-- | name of the AST node Type
[nodeAnnotType] :: NodeAnnotation -> !FastString

-- | The information stored in one AST node.
--   
--   The type parameter exists to provide flexibility in representation of
--   types (see Note [Efficient serialization of redundant type info]).
data NodeInfo a
NodeInfo :: Set NodeAnnotation -> [a] -> NodeIdentifiers a -> NodeInfo a

-- | Annotations
[nodeAnnotations] :: NodeInfo a -> Set NodeAnnotation

-- | The Haskell types of this node, if any.
[nodeType] :: NodeInfo a -> [a]

-- | All the identifiers and their details
[nodeIdentifiers] :: NodeInfo a -> NodeIdentifiers a
pprNodeIdents :: Outputable a => NodeIdentifiers a -> SDoc
pprIdentifier :: Identifier -> SDoc
type Identifier = Either ModuleName Name
type NodeIdentifiers a = Map Identifier IdentifierDetails a

-- | Information associated with every identifier
--   
--   We need to include types with identifiers because sometimes multiple
--   identifiers occur in the same span(Overloaded Record Fields and so on)
data IdentifierDetails a
IdentifierDetails :: Maybe a -> Set ContextInfo -> IdentifierDetails a
[identType] :: IdentifierDetails a -> Maybe a
[identInfo] :: IdentifierDetails a -> Set ContextInfo

-- | Different contexts under which identifiers exist
data ContextInfo

-- | regular variable
Use :: ContextInfo
MatchBind :: ContextInfo

-- | import/export
IEThing :: IEType -> ContextInfo
TyDecl :: ContextInfo

-- | Value binding
ValBind :: BindType -> Scope -> Maybe Span -> ContextInfo

-- | Pattern binding
--   
--   This case is tricky because the bound identifier can be used in two
--   distinct scopes. Consider the following example (with
--   <tt>-XViewPatterns</tt>)
--   
--   <pre>
--   do (b, a, (a -&gt; True)) &lt;- bar
--      foo a
--   </pre>
--   
--   The identifier <tt>a</tt> has two scopes: in the view pattern <tt>(a
--   -&gt; True)</tt> and in the rest of the <tt>do</tt>-block in <tt>foo
--   a</tt>.
PatternBind :: Scope -> Scope -> Maybe Span -> ContextInfo
ClassTyDecl :: Maybe Span -> ContextInfo

-- | Declaration
Decl :: DeclType -> Maybe Span -> ContextInfo

-- | Type variable
TyVarBind :: Scope -> TyVarScope -> ContextInfo

-- | Record field
RecField :: RecFieldContext -> Maybe Span -> ContextInfo

-- | Constraint/Dictionary evidence variable binding
EvidenceVarBind :: EvVarSource -> Scope -> Maybe Span -> ContextInfo

-- | Usage of evidence variable
EvidenceVarUse :: ContextInfo
pprBindSpan :: Maybe Span -> SDoc
data EvVarSource

-- | bound by a pattern match
EvPatternBind :: EvVarSource

-- | bound by a type signature
EvSigBind :: EvVarSource

-- | bound by a hswrapper
EvWrapperBind :: EvVarSource

-- | bound by an implicit variable
EvImplicitBind :: EvVarSource

-- | Bound by some instance of given class
EvInstBind :: Bool -> Name -> EvVarSource
[isSuperInst] :: EvVarSource -> Bool
[cls] :: EvVarSource -> Name

-- | A direct let binding
EvLetBind :: EvBindDeps -> EvVarSource

-- | Eq/Ord instances compare on the converted HieName, as non-exported
--   names may have different uniques after a roundtrip
newtype EvBindDeps
EvBindDeps :: [Name] -> EvBindDeps
[getEvBindDeps] :: EvBindDeps -> [Name]

-- | Types of imports and exports
data IEType
Import :: IEType
ImportAs :: IEType
ImportHiding :: IEType
Export :: IEType
data RecFieldContext
RecFieldDecl :: RecFieldContext
RecFieldAssign :: RecFieldContext
RecFieldMatch :: RecFieldContext
RecFieldOcc :: RecFieldContext
data BindType
RegularBind :: BindType
InstanceBind :: BindType
data DeclType

-- | type or data family
FamDec :: DeclType

-- | type synonym
SynDec :: DeclType

-- | data declaration
DataDec :: DeclType

-- | constructor declaration
ConDec :: DeclType

-- | pattern synonym
PatSynDec :: DeclType

-- | class declaration
ClassDec :: DeclType

-- | instance declaration
InstDec :: DeclType
data Scope
NoScope :: Scope
LocalScope :: Span -> Scope
ModuleScope :: Scope

-- | Scope of a type variable.
--   
--   This warrants a data type apart from <a>Scope</a> because of
--   complexities introduced by features like
--   <tt>-XScopedTypeVariables</tt> and <tt>-XInstanceSigs</tt>. For
--   example, consider:
--   
--   <pre>
--   foo, bar, baz :: forall a. a -&gt; a
--   </pre>
--   
--   Here <tt>a</tt> is in scope in all the definitions of <tt>foo</tt>,
--   <tt>bar</tt>, and <tt>baz</tt>, so we need a list of scopes to keep
--   track of this. Furthermore, this list cannot be computed until we
--   resolve the binding sites of <tt>foo</tt>, <tt>bar</tt>, and
--   <tt>baz</tt>.
--   
--   Consequently, <tt>a</tt> starts with an <tt><a>UnresolvedScope</a>
--   [foo, bar, baz] Nothing</tt> which later gets resolved into a
--   <a>ResolvedScopes</a>.
data TyVarScope
ResolvedScopes :: [Scope] -> TyVarScope

-- | Unresolved scopes should never show up in the final <tt>.hie</tt> file
UnresolvedScope :: [Name] -> Maybe Span -> TyVarScope

-- | <a>Name</a>'s get converted into <a>HieName</a>'s before being written
--   into <tt>.hie</tt> files. See <a>toHieName</a> and
--   <tt>fromHieName</tt> for logic on how to convert between these two
--   types.
data HieName
ExternalName :: !Module -> !OccName -> !SrcSpan -> HieName
LocalName :: !OccName -> !SrcSpan -> HieName
KnownKeyName :: !Unique -> HieName
hieNameOcc :: HieName -> OccName
toHieName :: Name -> HieName

-- | Entity information <a>EntityInfo</a> is a simplified version of
--   <a>TyThing</a> and richer version than <tt>Namespace</tt> in
--   <a>OccName</a>. It state the kind of the entity, such as
--   <tt>Variable</tt>, <tt>TypeVariable</tt>, <tt>DataConstructor</tt>,
--   etc..
data EntityInfo
EntityVariable :: EntityInfo
EntityFunction :: EntityInfo
EntityDataConstructor :: EntityInfo
EntityTypeVariable :: EntityInfo
EntityClassMethod :: EntityInfo
EntityPatternSynonym :: EntityInfo
EntityTypeConstructor :: EntityInfo
EntityTypeClass :: EntityInfo
EntityTypeSynonym :: EntityInfo
EntityTypeFamily :: EntityInfo
EntityRecordField :: EntityInfo

-- | Get the <a>EntityInfo</a> for an <a>Id</a>
idEntityInfo :: Id -> Set EntityInfo

-- | Get the <a>EntityInfo</a> for a <a>TyThing</a>
tyThingEntityInfo :: TyThing -> Set EntityInfo
nameEntityInfo :: Name -> Set EntityInfo
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.BindType
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.ContextInfo
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.DeclType
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.EntityInfo
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.EvBindDeps
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.EvVarSource
instance GHC.Utils.Binary.Binary (GHC.Iface.Ext.Types.HieAST GHC.Iface.Ext.Types.TypeIndex)
instance GHC.Utils.Binary.Binary (GHC.Iface.Ext.Types.HieASTs GHC.Iface.Ext.Types.TypeIndex)
instance GHC.Utils.Binary.Binary (GHC.Iface.Ext.Types.HieArgs GHC.Iface.Ext.Types.TypeIndex)
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.HieFile
instance GHC.Utils.Binary.Binary (GHC.Iface.Ext.Types.HieType GHC.Iface.Ext.Types.TypeIndex)
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.IEType
instance GHC.Utils.Binary.Binary (GHC.Iface.Ext.Types.IdentifierDetails GHC.Iface.Ext.Types.TypeIndex)
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.NameEntityInfo
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.NodeAnnotation
instance GHC.Utils.Binary.Binary (GHC.Iface.Ext.Types.NodeInfo GHC.Iface.Ext.Types.TypeIndex)
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.NodeOrigin
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.RecFieldContext
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.Scope
instance GHC.Utils.Binary.Binary (GHC.Iface.Ext.Types.SourcedNodeInfo GHC.Iface.Ext.Types.TypeIndex)
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.TyVarScope
instance GHC.Internal.Data.Data.Data GHC.Iface.Ext.Types.Scope
instance GHC.Internal.Enum.Enum GHC.Iface.Ext.Types.BindType
instance GHC.Internal.Enum.Enum GHC.Iface.Ext.Types.DeclType
instance GHC.Internal.Enum.Enum GHC.Iface.Ext.Types.EntityInfo
instance GHC.Internal.Enum.Enum GHC.Iface.Ext.Types.IEType
instance GHC.Internal.Enum.Enum GHC.Iface.Ext.Types.NodeOrigin
instance GHC.Internal.Enum.Enum GHC.Iface.Ext.Types.RecFieldContext
instance GHC.Classes.Eq GHC.Iface.Ext.Types.BindType
instance GHC.Classes.Eq GHC.Iface.Ext.Types.ContextInfo
instance GHC.Classes.Eq GHC.Iface.Ext.Types.DeclType
instance GHC.Classes.Eq GHC.Iface.Ext.Types.EntityInfo
instance GHC.Classes.Eq GHC.Iface.Ext.Types.EvBindDeps
instance GHC.Classes.Eq GHC.Iface.Ext.Types.EvVarSource
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Iface.Ext.Types.HieArgs a)
instance GHC.Classes.Eq GHC.Iface.Ext.Types.HieName
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Iface.Ext.Types.HieType a)
instance GHC.Classes.Eq GHC.Iface.Ext.Types.HieTypeFix
instance GHC.Classes.Eq GHC.Iface.Ext.Types.IEType
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Iface.Ext.Types.IdentifierDetails a)
instance GHC.Classes.Eq GHC.Iface.Ext.Types.NodeAnnotation
instance GHC.Classes.Eq GHC.Iface.Ext.Types.NodeOrigin
instance GHC.Classes.Eq GHC.Iface.Ext.Types.RecFieldContext
instance GHC.Classes.Eq GHC.Iface.Ext.Types.Scope
instance GHC.Classes.Eq GHC.Iface.Ext.Types.TyVarScope
instance GHC.Internal.Data.Foldable.Foldable GHC.Iface.Ext.Types.HieAST
instance GHC.Internal.Data.Foldable.Foldable GHC.Iface.Ext.Types.HieASTs
instance GHC.Internal.Data.Foldable.Foldable GHC.Iface.Ext.Types.HieArgs
instance GHC.Internal.Data.Foldable.Foldable GHC.Iface.Ext.Types.HieType
instance GHC.Internal.Data.Foldable.Foldable GHC.Iface.Ext.Types.IdentifierDetails
instance GHC.Internal.Data.Foldable.Foldable GHC.Iface.Ext.Types.NodeInfo
instance GHC.Internal.Data.Foldable.Foldable GHC.Iface.Ext.Types.SourcedNodeInfo
instance GHC.Internal.Base.Functor GHC.Iface.Ext.Types.HieAST
instance GHC.Internal.Base.Functor GHC.Iface.Ext.Types.HieASTs
instance GHC.Internal.Base.Functor GHC.Iface.Ext.Types.HieArgs
instance GHC.Internal.Base.Functor GHC.Iface.Ext.Types.HieType
instance GHC.Internal.Base.Functor GHC.Iface.Ext.Types.IdentifierDetails
instance GHC.Internal.Base.Functor GHC.Iface.Ext.Types.NodeInfo
instance GHC.Internal.Base.Functor GHC.Iface.Ext.Types.SourcedNodeInfo
instance GHC.Internal.Base.Monoid (GHC.Iface.Ext.Types.IdentifierDetails a)
instance GHC.Classes.Ord GHC.Iface.Ext.Types.BindType
instance GHC.Classes.Ord GHC.Iface.Ext.Types.ContextInfo
instance GHC.Classes.Ord GHC.Iface.Ext.Types.DeclType
instance GHC.Classes.Ord GHC.Iface.Ext.Types.EntityInfo
instance GHC.Classes.Ord GHC.Iface.Ext.Types.EvBindDeps
instance GHC.Classes.Ord GHC.Iface.Ext.Types.EvVarSource
instance GHC.Classes.Ord GHC.Iface.Ext.Types.HieName
instance GHC.Classes.Ord GHC.Iface.Ext.Types.IEType
instance GHC.Classes.Ord GHC.Iface.Ext.Types.NodeAnnotation
instance GHC.Classes.Ord GHC.Iface.Ext.Types.NodeOrigin
instance GHC.Classes.Ord GHC.Iface.Ext.Types.RecFieldContext
instance GHC.Classes.Ord GHC.Iface.Ext.Types.Scope
instance GHC.Classes.Ord GHC.Iface.Ext.Types.TyVarScope
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.BindType
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.ContextInfo
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.DeclType
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.EntityInfo
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.EvBindDeps
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.EvVarSource
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Iface.Ext.Types.HieAST a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Iface.Ext.Types.HieASTs a)
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.HieName
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.IEType
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Iface.Ext.Types.IdentifierDetails a)
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.NodeAnnotation
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Iface.Ext.Types.NodeInfo a)
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.NodeOrigin
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.RecFieldContext
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.Scope
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Iface.Ext.Types.SourcedNodeInfo a)
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.TyVarScope
instance GHC.Internal.Base.Semigroup (GHC.Iface.Ext.Types.IdentifierDetails a)
instance GHC.Internal.Show.Show GHC.Iface.Ext.Types.EntityInfo
instance GHC.Internal.Data.Traversable.Traversable GHC.Iface.Ext.Types.HieAST
instance GHC.Internal.Data.Traversable.Traversable GHC.Iface.Ext.Types.HieASTs
instance GHC.Internal.Data.Traversable.Traversable GHC.Iface.Ext.Types.HieArgs
instance GHC.Internal.Data.Traversable.Traversable GHC.Iface.Ext.Types.HieType
instance GHC.Internal.Data.Traversable.Traversable GHC.Iface.Ext.Types.IdentifierDetails
instance GHC.Internal.Data.Traversable.Traversable GHC.Iface.Ext.Types.NodeInfo
instance GHC.Internal.Data.Traversable.Traversable GHC.Iface.Ext.Types.SourcedNodeInfo

module GHC.Iface.Ext.Utils
type RefMap a = Map Identifier [(Span, IdentifierDetails a)]
generateReferencesMap :: Foldable f => f (HieAST a) -> RefMap a
renderHieType :: DynFlags -> HieTypeFix -> String
resolveVisibility :: Type -> [Type] -> [(Bool, Type)]
foldType :: (HieType a -> a) -> HieTypeFix -> a
selectPoint :: HieFile -> (Int, Int) -> Maybe (HieAST Int)
findEvidenceUse :: NodeIdentifiers a -> [Name]
data EvidenceInfo a
EvidenceInfo :: Name -> RealSrcSpan -> a -> Maybe (EvVarSource, Scope, Maybe Span) -> EvidenceInfo a
[evidenceVar] :: EvidenceInfo a -> Name
[evidenceSpan] :: EvidenceInfo a -> RealSrcSpan
[evidenceType] :: EvidenceInfo a -> a
[evidenceDetails] :: EvidenceInfo a -> Maybe (EvVarSource, Scope, Maybe Span)
getEvidenceTreesAtPoint :: HieFile -> RefMap a -> (Int, Int) -> Forest (EvidenceInfo a)
getEvidenceTree :: RefMap a -> Name -> Maybe (Tree (EvidenceInfo a))
hieTypeToIface :: HieTypeFix -> IfaceType
data HieTypeState
HTS :: !TypeMap TypeIndex -> !IntMap HieTypeFlat -> !TypeIndex -> HieTypeState
[tyMap] :: HieTypeState -> !TypeMap TypeIndex
[htyTable] :: HieTypeState -> !IntMap HieTypeFlat
[freshIndex] :: HieTypeState -> !TypeIndex
initialHTS :: HieTypeState
freshTypeIndex :: State HieTypeState TypeIndex
compressTypes :: HieASTs Type -> (HieASTs TypeIndex, Array TypeIndex HieTypeFlat)
recoverFullType :: TypeIndex -> Array TypeIndex HieTypeFlat -> HieTypeFix
getTypeIndex :: Type -> State HieTypeState TypeIndex
resolveTyVarScopes :: Map HiePath (HieAST a) -> Map HiePath (HieAST a)
resolveTyVarScopeLocal :: HieAST a -> Map HiePath (HieAST a) -> HieAST a
getNameBinding :: Name -> Map HiePath (HieAST a) -> Maybe Span
getNameScope :: Name -> Map HiePath (HieAST a) -> Maybe [Scope]
getNameBindingInClass :: Name -> Span -> Map HiePath (HieAST a) -> Maybe Span
getNameScopeAndBinding :: Name -> Map HiePath (HieAST a) -> Maybe ([Scope], Maybe Span)
getScopeFromContext :: ContextInfo -> Maybe [Scope]
getBindSiteFromContext :: ContextInfo -> Maybe Span
flattenAst :: HieAST a -> [HieAST a]
smallestContainingSatisfying :: Span -> (HieAST a -> Bool) -> HieAST a -> Maybe (HieAST a)
selectLargestContainedBy :: Span -> HieAST a -> Maybe (HieAST a)
selectSmallestContaining :: Span -> HieAST a -> Maybe (HieAST a)
definedInAsts :: Map HiePath (HieAST a) -> Name -> Bool
getEvidenceBindDeps :: ContextInfo -> [Name]
isEvidenceBind :: ContextInfo -> Bool
isEvidenceContext :: ContextInfo -> Bool
isEvidenceUse :: ContextInfo -> Bool
isOccurrence :: ContextInfo -> Bool
scopeContainsSpan :: Scope -> Span -> Bool

-- | One must contain the other. Leaf nodes cannot contain anything
combineAst :: HieAST Type -> HieAST Type -> HieAST Type

-- | Insert an AST in a sorted list of disjoint Asts
insertAst :: HieAST Type -> [HieAST Type] -> [HieAST Type]
nodeInfo :: HieAST Type -> NodeInfo Type
emptyNodeInfo :: NodeInfo a
sourcedNodeIdents :: SourcedNodeInfo a -> NodeIdentifiers a
combineSourcedNodeInfo :: SourcedNodeInfo Type -> SourcedNodeInfo Type -> SourcedNodeInfo Type

-- | Merge two nodes together.
--   
--   Precondition and postcondition: elements in <a>nodeType</a> are
--   ordered.
combineNodeInfo :: NodeInfo Type -> NodeInfo Type -> NodeInfo Type

-- | Merge two sorted, disjoint lists of ASTs, combining when necessary.
--   
--   In the absence of position-altering pragmas (ex: <tt># line "file.hs"
--   3</tt>), different nodes in an AST tree should either have disjoint
--   spans (in which case you can say for sure which one comes first) or
--   one span should be completely contained in the other (in which case
--   the contained span corresponds to some child node).
--   
--   However, since Haskell does have position-altering pragmas it
--   <i>is</i> possible for spans to be overlapping. Here is an example of
--   a source file in which <tt>foozball</tt> and <tt>quuuuuux</tt> have
--   overlapping spans:
--   
--   <pre>
--   module Baz where
--   
--   # line 3 "Baz.hs"
--   foozball :: Int
--   foozball = 0
--   
--   # line 3 "Baz.hs"
--   bar, quuuuuux :: Int
--   bar = 1
--   quuuuuux = 2
--   </pre>
--   
--   In these cases, we just do our best to produce sensible
--   <a>HieAST</a>'s. The blame should be laid at the feet of whoever wrote
--   the line pragmas in the first place (usually the C preprocessor...).
mergeAsts :: [HieAST Type] -> [HieAST Type] -> [HieAST Type]
rightOf :: Span -> Span -> Bool
leftOf :: Span -> Span -> Bool
startsRightOf :: Span -> Span -> Bool

-- | combines and sorts ASTs using a merge sort
mergeSortAsts :: [HieAST Type] -> [HieAST Type]
simpleNodeInfo :: FastString -> FastString -> NodeInfo a
locOnly :: forall (m :: Type -> Type) a. Monad m => SrcSpan -> ReaderT NodeOrigin m [HieAST a]
locOnlyE :: forall (m :: Type -> Type) a. Monad m => EpaLocation -> ReaderT NodeOrigin m [HieAST a]
mkScope :: HasLoc a => a -> Scope
combineScopes :: Scope -> Scope -> Scope
mkSourcedNodeInfo :: NodeOrigin -> NodeInfo a -> SourcedNodeInfo a
makeNodeA :: forall (m :: Type -> Type) a ann b. (Monad m, Data a) => a -> EpAnn ann -> ReaderT NodeOrigin m [HieAST b]
makeNode :: forall (m :: Type -> Type) a b. (Monad m, Data a) => a -> SrcSpan -> ReaderT NodeOrigin m [HieAST b]
makeTypeNodeA :: forall (m :: Type -> Type) a. (Monad m, Data a) => a -> SrcSpanAnnA -> Type -> ReaderT NodeOrigin m [HieAST Type]
makeTypeNode :: forall (m :: Type -> Type) a. (Monad m, Data a) => a -> SrcSpan -> Type -> ReaderT NodeOrigin m [HieAST Type]
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Iface.Ext.Utils.EvidenceInfo a)
instance GHC.Internal.Base.Functor GHC.Iface.Ext.Utils.EvidenceInfo
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Iface.Ext.Utils.EvidenceInfo a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Iface.Ext.Utils.EvidenceInfo a)

module GHC.Iface.Ext.Debug
type Diff a = a -> a -> [SDoc]
diffFile :: Diff HieFile
diffAsts :: (Outputable a, Eq a, Ord a) => Diff a -> Diff (Map HiePath (HieAST a))
diffAst :: (Outputable a, Eq a, Ord a) => Diff a -> Diff (HieAST a)
type DiffIdent = Either ModuleName HieName
normalizeIdents :: Ord a => NodeIdentifiers a -> [(DiffIdent, IdentifierDetails a)]
diffList :: Diff a -> Diff [a]
eqDiff :: (Outputable a, Eq a) => Diff a
validAst :: HieAST a -> Either SDoc ()

-- | Look for any identifiers which occur outside of their supposed scopes.
--   Returns a list of error messages.
validateScopes :: Module -> Map HiePath (HieAST a) -> [SDoc]


-- | Binary interface file support.
module GHC.Iface.Binary

-- | Write an interface file.
--   
--   See Note [Deduplication during iface binary serialisation] for
--   details.
writeBinIface :: Profile -> TraceBinIFace -> CompressionIFace -> FilePath -> ModIface -> IO ()

-- | Read an interface file.
--   
--   See Note [Deduplication during iface binary serialisation] for
--   details.
readBinIface :: Profile -> NameCache -> CheckHiWay -> TraceBinIFace -> FilePath -> IO ModIface

-- | Read an interface file header, checking the magic number, version, and
--   way. Returns the hash of the source file and a BinHandle which points
--   at the start of the rest of the interface file data.
readBinIfaceHeader :: Profile -> NameCache -> CheckHiWay -> TraceBinIFace -> FilePath -> IO (Fingerprint, ReadBinHandle)

-- | The compression/deduplication level of <a>ModIface</a> files.
--   
--   A <a>ModIface</a> contains many duplicated symbols and names. To keep
--   interface files small, we deduplicate them during serialisation. It is
--   impossible to write an interface file with *no*
--   compression/deduplication.
--   
--   We support different levels of compression/deduplication, with
--   different trade-offs for run-time performance and memory usage. If you
--   don't have any specific requirements, then <a>SafeExtraCompression</a>
--   is a good default.
data CompressionIFace

-- | Perform the normal compression operations, such as deduplicating
--   <a>Name</a>s and <a>FastString</a>s
NormalCompression :: CompressionIFace

-- | Perform some extra compression steps that have minimal impact on the
--   run-time of <tt>ghc</tt>.
--   
--   This reduces the size of '.hi' files significantly in some cases and
--   reduces overall memory usage in certain scenarios.
SafeExtraCompression :: CompressionIFace

-- | Try to compress as much as possible.
--   
--   Yields the smallest '.hi' files but at the cost of additional
--   run-time.
MaximumCompression :: CompressionIFace
getSymtabName :: SymbolTable Name -> ReadBinHandle -> IO Name
data CheckHiWay
CheckHiWay :: CheckHiWay
IgnoreHiWay :: CheckHiWay
data TraceBinIFace
TraceBinIFace :: (SDoc -> IO ()) -> TraceBinIFace
QuietBinIFace :: TraceBinIFace
getIfaceWithExtFields :: NameCache -> ReadBinHandle -> IO ModIface

-- | Puts the <a>ModIface</a> to the <a>WriteBinHandle</a>.
--   
--   This avoids serialisation of the <a>ModIface</a> if the fields
--   <a>mi_hi_bytes</a> contains a <a>Just</a> value. This field is
--   populated by reading the <a>ModIface</a> using
--   <a>getIfaceWithExtFields</a> and not modifying it in any way
--   afterwards.
putIfaceWithExtFields :: TraceBinIFace -> CompressionIFace -> WriteBinHandle -> ModIface -> IO ()

-- | This performs a get action after reading the dictionary and symbol
--   table. It is necessary to run this before trying to deserialise any
--   Names or FastStrings.
getWithUserData :: Binary a => NameCache -> ReadBinHandle -> IO a

-- | Put a piece of data with an initialised <tt>UserData</tt> field. This
--   is necessary if you want to serialise Names or FastStrings. It also
--   writes a symbol table and the dictionary. This segment should be read
--   using <a>getWithUserData</a>.
putWithUserData :: Binary a => TraceBinIFace -> CompressionIFace -> WriteBinHandle -> a -> IO ()
getSymbolTable :: ReadBinHandle -> NameCache -> IO (SymbolTable Name)
putName :: BinSymbolTable -> WriteBinHandle -> Name -> IO ()
putSymbolTable :: WriteBinHandle -> Int -> UniqFM Name (Int, Name) -> IO ()
data BinSymbolTable
BinSymbolTable :: !FastMutInt -> !IORef (UniqFM Name (Int, Name)) -> BinSymbolTable
[bin_symtab_next] :: BinSymbolTable -> !FastMutInt
[bin_symtab_map] :: BinSymbolTable -> !IORef (UniqFM Name (Int, Name))
initWriteIfaceType :: CompressionIFace -> IO (WriterTable, BinaryWriter IfaceType)
initReadIfaceTypeTable :: ReaderUserData -> IO (ReaderTable IfaceType)

-- | Write all deduplication tables to disk after serialising the main
--   payload.
--   
--   Writes forward pointers to the deduplication tables before writing the
--   payload to allow deserialisation *before* the payload is read again.
putAllTables :: WriteBinHandle -> [WriterTable] -> IO b -> IO ([Int], b)
instance GHC.Internal.Enum.Bounded GHC.Iface.Binary.CompressionIFace
instance GHC.Internal.Enum.Enum GHC.Iface.Binary.CompressionIFace
instance GHC.Classes.Eq GHC.Iface.Binary.CheckHiWay
instance GHC.Classes.Eq GHC.Iface.Binary.CompressionIFace
instance GHC.Classes.Ord GHC.Iface.Binary.CompressionIFace
instance GHC.Utils.Outputable.Outputable GHC.Iface.Binary.CompressionIFace
instance GHC.Internal.Show.Show GHC.Iface.Binary.CompressionIFace


-- | Loading interface files
module GHC.Iface.Load
tcLookupImported_maybe :: Name -> TcM (MaybeErr IfaceMessage TyThing)
importDecl :: Name -> IfM lcl (MaybeErr IfaceMessage TyThing)
checkWiredInTyCon :: TyCon -> TcM ()
ifCheckWiredInThing :: TyThing -> IfL ()

-- | Load interface directly for a fully qualified <a>Module</a>. (This is
--   a fairly rare operation, but in particular it is used to load orphan
--   modules in order to pull their instances into the global package table
--   and to handle some operations in GHCi).
loadModuleInterface :: SDoc -> Module -> TcM ModIface

-- | Load interfaces for a collection of modules.
loadModuleInterfaces :: SDoc -> [Module] -> TcM ()

-- | Load the interface corresponding to an <tt>import</tt> directive in
--   source code. On a failure, fail in the monad with an error message.
loadSrcInterface :: SDoc -> ModuleName -> IsBootInterface -> PkgQual -> RnM ModIface

-- | Like <a>loadSrcInterface</a>, but returns a <a>MaybeErr</a>.
loadSrcInterface_maybe :: SDoc -> ModuleName -> IsBootInterface -> PkgQual -> RnM (MaybeErr MissingInterfaceError ModIface)

-- | Loads the interface for a given Name. Should only be called for an
--   imported name; otherwise loadSysInterface may not find the interface
loadInterfaceForName :: SDoc -> Name -> TcRn ModIface

-- | Loads the interface for a given Module.
loadInterfaceForModule :: SDoc -> Module -> TcRn ModIface
loadInterface :: SDoc -> Module -> WhereFrom -> IfM lcl (MaybeErr MissingInterfaceError ModIface)

-- | Loads a system interface and throws an exception if it fails
loadSysInterface :: SDoc -> Module -> IfM lcl ModIface

-- | Loads a user interface and throws an exception if it fails. The first
--   parameter indicates whether we should import the boot variant of the
--   module
loadUserInterface :: IsBootInterface -> SDoc -> Module -> IfM lcl ModIface
loadPluginInterface :: SDoc -> Module -> IfM lcl ModIface
findAndReadIface :: HscEnv -> SDoc -> InstalledModule -> Module -> IsBootInterface -> IO (MaybeErr MissingInterfaceError (ModIface, ModLocation))

-- | <tt>readIface</tt> tries just the one file.
--   
--   Failed err <a>=</a> file not found, or unreadable, or illegible
--   Succeeded iface <a>=</a> successfully found and parsed
readIface :: DynFlags -> NameCache -> Module -> FilePath -> IO (MaybeErr ReadInterfaceError ModIface)

-- | Write interface file
writeIface :: Logger -> Profile -> CompressionIFace -> FilePath -> ModIface -> IO ()
flagsToIfCompression :: DynFlags -> CompressionIFace

-- | Compute the signatures which must be compiled in order to load the
--   interface for a <a>Module</a>. The output of this function is always a
--   subset of <a>moduleFreeHoles</a>; it is more precise because in
--   signature <tt>p[A=&lt;A&gt;,B=&lt;B&gt;]:B</tt>, although the free
--   holes are A and B, B might not depend on A at all!
--   
--   If this is invoked on a signature, this does NOT include the signature
--   itself; e.g. precise free module holes of
--   <tt>p[A=&lt;A&gt;,B=&lt;B&gt;]:B</tt> never includes B.
moduleFreeHolesPrecise :: SDoc -> Module -> TcRnIf gbl lcl (MaybeErr MissingInterfaceError (UniqDSet ModuleName))
needWiredInHomeIface :: TyThing -> Bool

-- | An <a>IfM</a> function to load the home interface for a wired-in
--   thing, so that we're sure that we see its instance declarations and
--   rules See Note [Loading instances for wired-in things]
loadWiredInHomeIface :: Name -> IfM lcl ()

-- | Reason for loading an interface file
--   
--   Used to figure out whether we want to consider loading hi-boot files
--   or not.
data WhereFrom
ImportByUser :: IsBootInterface -> WhereFrom
ImportBySystem :: WhereFrom
ImportByPlugin :: WhereFrom

-- | Show a ModIface but don't display details; suitable for ModIfaces
--   stored in the EPT.
pprModIfaceSimple :: UnitState -> ModIface -> SDoc
ifaceStats :: ExternalPackageState -> SDoc

-- | Show a ModIface
--   
--   The UnitState is used to pretty-print units
pprModIface :: UnitState -> ModIface -> SDoc

-- | Read binary interface, and print it out
showIface :: Logger -> DynFlags -> UnitState -> NameCache -> FilePath -> IO ()
instance GHC.Utils.Outputable.Outputable GHC.Iface.Load.WhereFrom

module GHC.Tc.Utils.Env

-- | A global typecheckable-thing, essentially anything that has a name.
--   Not to be confused with a <tt>TcTyThing</tt>, which is also a
--   typecheckable thing but in the *local* context. See
--   <a>GHC.Tc.Utils.Env</a> for how to retrieve a <a>TyThing</a> given a
--   <a>Name</a>.
data TyThing
AnId :: Id -> TyThing
AConLike :: ConLike -> TyThing
ATyCon :: TyCon -> TyThing
ACoAxiom :: CoAxiom Branched -> TyThing

-- | A typecheckable thing available in a local context. Could be
--   <a>AGlobal</a> <a>TyThing</a>, but also lexically scoped variables,
--   etc. See <a>GHC.Tc.Utils.Env</a> for how to retrieve a <a>TyThing</a>
--   given a <a>Name</a>.
data TcTyThing
AGlobal :: TyThing -> TcTyThing
ATcId :: Id -> IdBindingInfo -> TcTyThing
[tct_id] :: TcTyThing -> Id
[tct_info] :: TcTyThing -> IdBindingInfo
ATyVar :: Name -> TcTyVar -> TcTyThing
ATcTyCon :: TyCon -> TcTyThing
APromotionErr :: PromotionErr -> TcTyThing
type TcId = Id
data InstInfo a
InstInfo :: ClsInst -> InstBindings a -> InstInfo a
[iSpec] :: InstInfo a -> ClsInst
[iBinds] :: InstInfo a -> InstBindings a
iDFunId :: InstInfo a -> DFunId
pprInstInfoDetails :: forall (a :: Pass). OutputableBndrId a => InstInfo (GhcPass a) -> SDoc
simpleInstInfoClsTy :: InstInfo a -> (Class, Type)
simpleInstInfoTy :: InstInfo a -> Type
simpleInstInfoTyCon :: InstInfo a -> TyCon
data InstBindings a
InstBindings :: [Name] -> LHsBinds a -> [LSig a] -> [Extension] -> Bool -> InstBindings a
[ib_tyvars] :: InstBindings a -> [Name]
[ib_binds] :: InstBindings a -> LHsBinds a
[ib_pragmas] :: InstBindings a -> [LSig a]
[ib_extensions] :: InstBindings a -> [Extension]
[ib_derived] :: InstBindings a -> Bool
tcExtendGlobalEnv :: [TyThing] -> TcM r -> TcM r
tcExtendTyConEnv :: [TyCon] -> TcM r -> TcM r
tcExtendGlobalEnvImplicit :: [TyThing] -> TcM r -> TcM r
setGlobalTypeEnv :: TcGblEnv -> TypeEnv -> TcM TcGblEnv
tcExtendGlobalValEnv :: [Id] -> TcM a -> TcM a
tcTyThBinders :: [TyThing] -> TcM ThBindEnv
tcLookupLocatedGlobal :: LocatedA Name -> TcM TyThing
tcLookupGlobal :: Name -> TcM TyThing
tcLookupGlobalOnly :: Name -> TcM TyThing
tcLookupTyCon :: Name -> TcM TyCon
tcLookupClass :: Name -> TcM Class
tcLookupDataCon :: Name -> TcM DataCon
tcLookupPatSyn :: Name -> TcM PatSyn
tcLookupConLike :: Name -> TcM ConLike
tcLookupRecSelParent :: HsRecUpdParent GhcRn -> TcM RecSelParent
tcLookupLocatedGlobalId :: LocatedA Name -> TcM Id
tcLookupLocatedTyCon :: LocatedN Name -> TcM TyCon
tcLookupLocatedClass :: LocatedA Name -> TcM Class
tcLookupAxiom :: Name -> TcM (CoAxiom Branched)
lookupGlobal :: HscEnv -> Name -> IO TyThing
lookupGlobal_maybe :: HscEnv -> Name -> IO (MaybeErr (Either Name IfaceMessage) TyThing)
addTypecheckedBinds :: TcGblEnv -> [LHsBinds GhcTc] -> TcGblEnv
failIllegalTyCon :: WhatLooking -> Name -> TcM a
failIllegalTyVal :: Name -> TcM a
tcExtendKindEnv :: NameEnv TcTyThing -> TcM r -> TcM r
tcExtendKindEnvList :: [(Name, TcTyThing)] -> TcM r -> TcM r
tcExtendTyVarEnv :: [TyVar] -> TcM r -> TcM r
tcExtendNameTyVarEnv :: [(Name, TcTyVar)] -> TcM r -> TcM r
tcExtendLetEnv :: TopLevelFlag -> TcSigFun -> IsGroupClosed -> [Scaled TcId] -> TcM a -> TcM (a, HsWrapper)
tcExtendSigIds :: TopLevelFlag -> [TcId] -> TcM a -> TcM a
tcExtendRecIds :: [(Name, TcId)] -> TcM a -> TcM a
tcExtendIdEnv :: [TcId] -> TcM a -> TcM a
tcExtendIdEnv1 :: Name -> TcId -> TcM a -> TcM a
tcExtendIdEnv2 :: [(Name, TcId)] -> TcM a -> TcM a
tcExtendBinderStack :: [TcBinder] -> TcM a -> TcM a
tcExtendLocalTypeEnv :: [(Name, TcTyThing)] -> TcLclCtxt -> TcLclCtxt
isTypeClosedLetBndr :: Id -> Bool
tcLookup :: Name -> TcM TcTyThing
tcLookupLocated :: LocatedA Name -> TcM TcTyThing
tcLookupLocalIds :: [Name] -> TcM [TcId]
tcLookupId :: Name -> TcM Id
tcLookupIdMaybe :: Name -> TcM (Maybe Id)
tcLookupTyVar :: Name -> TcM TcTyVar
tcLookupTcTyCon :: HasDebugCallStack => Name -> TcM TcTyCon
tcLookupLcl_maybe :: Name -> TcM (Maybe TcTyThing)
getInLocalScope :: TcM (Name -> Bool)
wrongThingErr :: WrongThingSort -> TcTyThing -> Name -> TcM a
pprBinders :: [Name] -> SDoc
tcAddDataFamConPlaceholders :: [LInstDecl GhcRn] -> TcM a -> TcM a
tcAddPatSynPlaceholders :: [PatSynBind GhcRn GhcRn] -> TcM a -> TcM a
tcAddKindSigPlaceholders :: LHsKind GhcRn -> TcM a -> TcM a
getTypeSigNames :: [LSig GhcRn] -> NameSet
tcExtendRecEnv :: [(Name, TyThing)] -> TcM r -> TcM r
tcLookupInstance :: Class -> [Type] -> TcM ClsInst
tcGetInstEnvs :: TcM InstEnvs
tcExtendRules :: [LRuleDecl GhcTc] -> TcM a -> TcM a
tcGetDefaultTys :: TcM (DefaultEnv, Bool)
data StageCheckReason
StageCheckInstance :: !InstanceWhat -> !PredType -> StageCheckReason
StageCheckSplice :: !Name -> StageCheckReason
checkWellStaged :: StageCheckReason -> ThLevel -> ThLevel -> TcM ()
tcMetaTy :: Name -> TcM Type
thLevel :: ThStage -> ThLevel
topIdLvl :: Id -> ThLevel
isBrackStage :: ThStage -> Bool

-- | Make a name for the dict fun for an instance decl. It's an *external*
--   name, like other top-level names, and hence must be made with
--   newGlobalBinder.
newDFunName :: Class -> [Type] -> SrcSpan -> TcM Name
newFamInstTyConName :: LocatedN Name -> [Type] -> TcM Name
newFamInstAxiomName :: LocatedN Name -> [[Type]] -> TcM Name
mkStableIdFromString :: String -> Type -> SrcSpan -> (OccName -> OccName) -> TcM TcId
mkStableIdFromName :: Name -> Type -> SrcSpan -> (OccName -> OccName) -> TcM TcId

-- | <pre>
--   mkWrapperName ref what nameBase
--   </pre>
--   
--   See Note [Generating fresh names for FFI wrappers] for <tt>ref</tt>'s
--   purpose.
mkWrapperName :: (MonadIO m, HasModule m) => IORef (ModuleEnv Int) -> String -> String -> m FastString
instance GHC.Types.TyThing.MonadThings (GHC.Data.IOEnv.IOEnv (GHC.Tc.Types.Env GHC.Tc.Types.TcGblEnv GHC.Tc.Types.LclEnv.TcLclEnv))
instance GHC.Hs.Extension.OutputableBndrId a => GHC.Utils.Outputable.Outputable (GHC.Tc.Utils.Env.InstInfo (GHC.Hs.Extension.GhcPass a))


-- | Final zonking to <a>Type</a>. See Note [Zonking to Type].
--   
--   Distinct from the intra-typechecker zonking in
--   <a>GHC.Tc.Zonk.TcType</a>; see Note [Module structure for zonking].
module GHC.Tc.Zonk.Type

-- | Zonking monad for a computation that zonks to Type, reading from a
--   <a>ZonkEnv</a> but not extending or modifying it.
--   
--   See Note [Zonking to Type].
type ZonkTcM = ZonkT TcM
zonkTopDecls :: Bag EvBind -> LHsBinds GhcTc -> [LRuleDecl GhcTc] -> [LTcSpecPrag] -> [LForeignDecl GhcTc] -> TcM (TypeEnv, Bag EvBind, LHsBinds GhcTc, [LForeignDecl GhcTc], [LTcSpecPrag], [LRuleDecl GhcTc])
zonkTopExpr :: HsExpr GhcTc -> TcM (HsExpr GhcTc)
zonkTopLExpr :: LHsExpr GhcTc -> TcM (LHsExpr GhcTc)
zonkTopBndrs :: [TcId] -> TcM [Id]
zonkTyVarBindersX :: [VarBndr TcTyVar vis] -> ZonkBndrTcM [VarBndr TyVar vis]
zonkTyVarBinderX :: VarBndr TcTyVar vis -> ZonkBndrTcM (VarBndr TyVar vis)
zonkTyBndrX :: TcTyVar -> ZonkBndrTcM TyVar
zonkTyBndrsX :: [TcTyVar] -> ZonkBndrTcM [TcTyVar]

-- | Confused by zonking? See Note [What is zonking?] in
--   <a>GHC.Tc.Zonk.Type</a>.
zonkTcTypeToType :: TcType -> TcM Type
zonkTcTypeToTypeX :: TcType -> ZonkTcM Type
zonkTcTypesToTypesX :: [TcType] -> ZonkTcM [Type]
zonkScaledTcTypesToTypesX :: [Scaled TcType] -> ZonkTcM [Scaled Type]
zonkTyVarOcc :: HasDebugCallStack => TcTyVar -> ZonkTcM Type
zonkCoToCo :: Coercion -> ZonkTcM Coercion
zonkEvBinds :: Bag EvBind -> ZonkBndrTcM (Bag EvBind)
zonkTcEvBinds :: TcEvBinds -> ZonkBndrTcM TcEvBinds
zonkTcMethInfoToMethInfoX :: TcMethInfo -> ZonkTcM MethInfo
lookupTyVarX :: TcTyVar -> ZonkTcM TyVar

-- | Is a coercion hole filled in?
isFilledCoercionHole :: CoercionHole -> TcM Bool

-- | Retrieve the contents of a coercion hole. Panics if the hole is
--   unfilled
unpackCoercionHole :: CoercionHole -> TcM Coercion

-- | Retrieve the contents of a coercion hole, if it is filled
unpackCoercionHole_maybe :: CoercionHole -> TcM (Maybe Coercion)

-- | Check whether any coercion hole in a RewriterSet is still unsolved.
--   Does this by recursively looking through filled coercion holes until
--   one is found that is not yet filled in, at which point this aborts.
zonkRewriterSet :: RewriterSet -> TcM RewriterSet
zonkCtRewriterSet :: Ct -> TcM Ct
zonkCtEvRewriterSet :: CtEvidence -> TcM CtEvidence
tcInitTidyEnv :: ZonkM TidyEnv

-- | Get a <a>TidyEnv</a> that includes mappings for all vars free in the
--   given type. Useful when tidying open types.
tcInitOpenTidyEnv :: [TyCoVar] -> ZonkM TidyEnv
instance GHC.Internal.Base.Monoid GHC.Tc.Zonk.Type.UnfilledCoercionHoleMonoid
instance GHC.Internal.Base.Semigroup GHC.Tc.Zonk.Type.UnfilledCoercionHoleMonoid


-- | Monadic type operations
--   
--   This module contains monadic operations over types that contain
--   mutable type variables.
module GHC.Tc.Utils.TcMType

-- | Type variable that might be a metavariable
type TcTyVar = Var
type TcKind = Kind
type TcType = Type
type TcTauType = TcType
type TcThetaType = ThetaType
type TcTyVarSet = TyVarSet
newFlexiTyVar :: Kind -> TcM TcTyVar

-- | Create a new flexi ty var with a specific name
newNamedFlexiTyVar :: FastString -> Kind -> TcM TcTyVar
newFlexiTyVarTy :: Kind -> TcM TcType
newFlexiTyVarTys :: Int -> Kind -> TcM [TcType]
newOpenFlexiTyVar :: TcM TcTyVar

-- | Create a tyvar that can be a lifted or unlifted type. Returns
--   <tt>alpha :: TYPE kappa</tt>, where both <tt>alpha</tt> and
--   <tt>kappa</tt> are fresh.
--   
--   Note: you should use <a>newOpenFlexiFRRTyVarTy</a> if you also need to
--   ensure that the representation is concrete, in the sense of Note
--   [Concrete types] in GHC.Tc.Utils.Concrete.
newOpenFlexiTyVarTy :: TcM TcType
newOpenTypeKind :: TcM TcKind

-- | Like <a>newOpenFlexiTyVar</a>, but ensures the type variable has a
--   syntactically fixed RuntimeRep in the sense of Note [Fixed RuntimeRep]
--   in GHC.Tc.Utils.Concrete.
newOpenFlexiFRRTyVar :: FixedRuntimeRepContext -> TcM TcTyVar

-- | See <a>newOpenFlexiFRRTyVar</a>.
newOpenFlexiFRRTyVarTy :: FixedRuntimeRepContext -> TcM TcType
newOpenBoxedTypeKind :: TcM TcKind
newMetaKindVar :: TcM TcKind
newMetaKindVars :: Int -> TcM [TcKind]
newMetaTyVarTyAtLevel :: TcLevel -> TcKind -> TcM TcType
newConcreteTyVarTyAtLevel :: ConcreteTvOrigin -> TcLevel -> TcKind -> TcM TcType
substConcreteTvOrigin :: Subst -> Type -> ConcreteTvOrigin -> ConcreteTvOrigin
newAnonMetaTyVar :: MetaInfo -> Kind -> TcM TcTyVar

-- | Create a new metavariable, of the given kind, which can only be
--   unified with a concrete type.
--   
--   Invariant: the kind must be concrete, as per Note [ConcreteTv]. This
--   is checked with an assertion.
newConcreteTyVar :: HasDebugCallStack => ConcreteTvOrigin -> FastString -> TcKind -> TcM TcTyVar
cloneMetaTyVar :: TcTyVar -> TcM TcTyVar
cloneMetaTyVarWithInfo :: MetaInfo -> TcLevel -> TcTyVar -> TcM TcTyVar
newCycleBreakerTyVar :: TcKind -> TcM TcTyVar
newMultiplicityVar :: TcM TcType
readMetaTyVar :: MonadIO m => TyVar -> m MetaDetails

-- | Write into a currently-empty MetaTyVar.
--   
--   Works with both type and kind variables.
writeMetaTyVar :: HasDebugCallStack => TcTyVar -> TcType -> ZonkM ()

-- | Write into the <a>MetaDetails</a> mutable references of a
--   <a>MetaTv</a>.
writeMetaTyVarRef :: HasDebugCallStack => TcTyVar -> TcRef MetaDetails -> TcType -> ZonkM ()
newTauTvDetailsAtLevel :: TcLevel -> TcM TcTyVarDetails
newMetaDetails :: MetaInfo -> TcM TcTyVarDetails
newMetaTyVarName :: FastString -> TcM Name
isFilledMetaTyVar_maybe :: TcTyVar -> TcM (Maybe Type)
isFilledMetaTyVar :: TyVar -> TcM Bool
isUnfilledMetaTyVar :: TyVar -> TcM Bool
newEvVar :: TcPredType -> TcRnIf gbl lcl EvVar
newEvVars :: TcThetaType -> TcM [EvVar]
newDict :: Class -> [TcType] -> TcM DictId

-- | Create a new Wanted constraint with the given <a>CtLoc</a>.
newWantedWithLoc :: CtLoc -> PredType -> TcM CtEvidence

-- | Create a new Wanted constraint with the given <a>CtOrigin</a>, and
--   location information taken from the <a>TcM</a> environment.
newWanted :: CtOrigin -> Maybe TypeOrKind -> PredType -> TcM CtEvidence

-- | Create new Wanted constraints with the given <a>CtOrigin</a>, and
--   location information taken from the <a>TcM</a> environment.
newWanteds :: CtOrigin -> ThetaType -> TcM [CtEvidence]
cloneWanted :: Ct -> TcM Ct
cloneWC :: WantedConstraints -> TcM WantedConstraints
cloneWantedCtEv :: CtEvidence -> TcM CtEvidence

-- | Emits a new Wanted. Deals with both equalities and non-equalities.
emitWanted :: CtOrigin -> TcPredType -> TcM EvTerm

-- | Emits a new equality constraint
emitWantedEq :: CtOrigin -> TypeOrKind -> Role -> TcType -> TcType -> TcM Coercion

-- | Creates a new EvVar and immediately emits it as a Wanted. No equality
--   predicates here.
emitWantedEvVar :: CtOrigin -> TcPredType -> TcM EvVar
emitWantedEvVars :: CtOrigin -> [TcPredType] -> TcM [EvVar]
emitWantedEqs :: CtOrigin -> [(TcType, TcType)] -> TcM ()
newTcEvBinds :: TcM EvBindsVar

-- | Creates an EvBindsVar incapable of holding any bindings. It still
--   tracks covar usages (see comments on ebv_tcvs in
--   <a>GHC.Tc.Types.Evidence</a>), thus must be made monadically
newNoTcEvBinds :: TcM EvBindsVar
addTcEvBind :: EvBindsVar -> EvBind -> TcM ()

-- | Emit a new wanted expression hole
emitNewExprHole :: RdrName -> Type -> TcM HoleExprRef
newCoercionHole :: CtLoc -> TcPredType -> TcM CoercionHole
newCoercionHoleO :: CtOrigin -> TcPredType -> TcM CoercionHole
newVanillaCoercionHole :: TcPredType -> TcM CoercionHole

-- | Put a value in a coercion hole
fillCoercionHole :: CoercionHole -> Coercion -> TcM ()

-- | Is a coercion hole filled in?
isFilledCoercionHole :: CoercionHole -> TcM Bool

-- | Retrieve the contents of a coercion hole. Panics if the hole is
--   unfilled
unpackCoercionHole :: CoercionHole -> TcM Coercion

-- | Retrieve the contents of a coercion hole, if it is filled
unpackCoercionHole_maybe :: CoercionHole -> TcM (Maybe Coercion)

-- | Check that a coercion is appropriate for filling a hole. (The hole
--   itself is needed only for printing.) Always returns the checked
--   coercion, but this return value is necessary so that the input
--   coercion is forced only when the output is forced.
checkCoercionHole :: CoVar -> Coercion -> ZonkM Coercion

-- | Create a new <a>Implication</a> with as many sensible defaults for its
--   fields as possible. Note that the <a>ic_tclvl</a>, <a>ic_binds</a>,
--   and <a>ic_info</a> fields do <i>not</i> have sensible defaults, so
--   they are initialized with lazy thunks that will <a>panic</a> if
--   forced, so one should take care to initialize these fields after
--   creation.
--   
--   This is monadic to look up the <a>TcLclEnv</a>, which is used to
--   initialize <a>ic_env</a>, and to set the -Winaccessible-code flag. See
--   Note [Avoid -Winaccessible-code when deriving] in
--   <a>GHC.Tc.TyCl.Instance</a>.
newImplication :: TcM Implication
newMetaTyVars :: [TyVar] -> TcM (Subst, [TcTyVar])
newMetaTyVarX :: Subst -> TyVar -> TcM (Subst, TcTyVar)
newMetaTyVarsX :: Subst -> [TyVar] -> TcM (Subst, [TcTyVar])
newMetaTyVarBndrsX :: Subst -> [VarBndr TyVar vis] -> TcM (Subst, [VarBndr TcTyVar vis])
newMetaTyVarTyVarX :: Subst -> TyVar -> TcM (Subst, TcTyVar)
newTyVarTyVar :: Name -> Kind -> TcM TcTyVar
cloneTyVarTyVar :: Name -> Kind -> TcM TcTyVar

-- | Like <a>newMetaTyVarX</a>, but for concrete type variables.
newConcreteTyVarX :: ConcreteTvOrigin -> Subst -> TyVar -> TcM (Subst, TcTyVar)
newPatTyVar :: Name -> Kind -> TcM TcTyVar
newSkolemTyVar :: SkolemInfo -> Name -> Kind -> TcM TcTyVar
newWildCardX :: Subst -> TyVar -> TcM (Subst, TcTyVar)

-- | An expected type to check against during type-checking. See Note
--   [ExpType] in <a>GHC.Tc.Utils.TcMType</a>, where you'll also find
--   manipulators.
data ExpType
Check :: TcType -> ExpType
Infer :: !InferResult -> ExpType
type ExpSigmaType = ExpType
type ExpRhoType = ExpType

-- | Make an <a>ExpType</a> suitable for checking.
mkCheckExpType :: TcType -> ExpType
newInferExpType :: TcM ExpType
newInferExpTypeFRR :: FixedRuntimeRepContext -> TcM ExpTypeFRR

-- | Infer a type using a fresh ExpType See also Note [ExpType] in
--   <a>GHC.Tc.Utils.TcMType</a>
--   
--   Use <a>tcInferFRR</a> if you require the type to have a fixed runtime
--   representation.
tcInfer :: (ExpSigmaType -> TcM a) -> TcM (a, TcSigmaType)

-- | Like <a>tcInfer</a>, except it ensures that the resulting type has a
--   syntactically fixed RuntimeRep as per Note [Fixed RuntimeRep] in
--   GHC.Tc.Utils.Concrete.
tcInferFRR :: FixedRuntimeRepContext -> (ExpSigmaTypeFRR -> TcM a) -> TcM (a, TcSigmaTypeFRR)

-- | Extract a type out of an ExpType. Otherwise, panics.
readExpType :: MonadIO m => ExpType -> m TcType

-- | Extract a type out of an ExpType, if one exists. But one should always
--   exist. Unless you're quite sure you know what you're doing.
readExpType_maybe :: MonadIO m => ExpType -> m (Maybe TcType)

-- | Same as readExpType, but for Scaled ExpTypes
readScaledExpType :: MonadIO m => Scaled ExpType -> m (Scaled Type)

-- | Extracts the expected type if there is one, or generates a new TauTv
--   if there isn't.
expTypeToType :: ExpType -> TcM TcType
scaledExpTypeToType :: Scaled ExpType -> TcM (Scaled TcType)

-- | Returns the expected type when in checking mode.
checkingExpType_maybe :: ExpType -> Maybe TcType

-- | Returns the expected type when in checking mode. Panics if in
--   inference mode.
checkingExpType :: ExpType -> TcType
inferResultToType :: InferResult -> TcM Type
ensureMonoType :: TcType -> TcM ()
promoteTcType :: TcLevel -> TcType -> TcM (TcCoercionN, TcType)

-- | <tt>tcCheckUsage name mult thing_inside</tt> runs
--   <tt>thing_inside</tt>, checks that the usage of <tt>name</tt> is a
--   submultiplicity of <tt>mult</tt>, and removes <tt>name</tt> from the
--   usage environment. See also Note [Coercions returned from tcSubMult]
--   in GHC.Tc.Utils.Unify, which applies to the wrapper returned from this
--   function.
tcCheckUsage :: Name -> Mult -> TcM a -> TcM (a, HsWrapper)

-- | Default a type variable using the given defaulting strategy.
--   
--   See Note [Type variable defaulting options] in GHC.Types.Basic.
defaultTyVar :: DefaultingStrategy -> TcTyVar -> TcM Bool
promoteMetaTyVarTo :: HasDebugCallStack => TcLevel -> TcTyVar -> TcM Bool
promoteTyVarSet :: HasDebugCallStack => TcTyVarSet -> TcM Bool
quantifyTyVars :: SkolemInfo -> NonStandardDefaultingStrategy -> CandidatesQTvs -> TcM [TcTyVar]
isQuantifiableTv :: TcLevel -> TcTyVar -> Bool
zonkAndSkolemise :: SkolemInfo -> TcTyCoVar -> ZonkM TcTyCoVar
skolemiseQuantifiedTyVar :: SkolemInfo -> TcTyVar -> ZonkM TcTyVar
doNotQuantifyTyVars :: CandidatesQTvs -> (TidyEnv -> ZonkM (TidyEnv, UninferrableTyVarCtx)) -> TcM ()

-- | Gathers free variables to use as quantification candidates (in
--   <a>quantifyTyVars</a>). This might output the same var in both sets,
--   if it's used in both a type and a kind. The variables to quantify must
--   have a TcLevel strictly greater than the ambient level. (See Wrinkle
--   in Note [Naughty quantification candidates]) See Note [CandidatesQTvs
--   determinism and order] See Note [Dependent type variables]
candidateQTyVarsOfType :: TcType -> TcM CandidatesQTvs

-- | Like <a>candidateQTyVarsOfType</a>, but consider every free variable
--   to be dependent. This is appropriate when generalizing a *kind*,
--   instead of a type. (That way, -XNoPolyKinds will default the variables
--   to Type.)
candidateQTyVarsOfKind :: TcKind -> TcM CandidatesQTvs

-- | Like <a>candidateQTyVarsOfType</a>, but over a list of types The
--   variables to quantify must have a TcLevel strictly greater than the
--   ambient level. (See Wrinkle in Note [Naughty quantification
--   candidates])
candidateQTyVarsOfTypes :: [Type] -> TcM CandidatesQTvs
candidateQTyVarsOfKinds :: [TcKind] -> TcM CandidatesQTvs
candidateQTyVarsWithBinders :: [TyVar] -> Type -> TcM CandidatesQTvs
data CandidatesQTvs
DV :: DTyVarSet -> DTyVarSet -> CoVarSet -> CandidatesQTvs
[dv_kvs] :: CandidatesQTvs -> DTyVarSet
[dv_tvs] :: CandidatesQTvs -> DTyVarSet
[dv_cvs] :: CandidatesQTvs -> CoVarSet
delCandidates :: CandidatesQTvs -> [Var] -> CandidatesQTvs
candidateKindVars :: CandidatesQTvs -> TyVarSet
partitionCandidates :: CandidatesQTvs -> (TyVar -> Bool) -> (TyVarSet, CandidatesQTvs)

-- | Check that the specified type has a fixed runtime representation.
--   
--   If it isn't, throw a representation-polymorphism error appropriate for
--   the context (as specified by the <a>FixedRuntimeRepProvenance</a>).
--   
--   Unlike the other representation polymorphism checks, which can emit
--   new Wanted constraints to be solved by the constraint solver, this
--   function does not emit any constraints: it has enough information to
--   immediately make a decision.
--   
--   See (1) in Note [Representation polymorphism checking] in
--   GHC.Tc.Utils.Concrete
checkTypeHasFixedRuntimeRep :: FixedRuntimeRepProvenance -> Type -> TcM ()
mkHsDictLet :: TcEvBinds -> LHsExpr GhcTc -> LHsExpr GhcTc
mkHsApp :: forall (id :: Pass). LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
mkHsAppTy :: forall (p :: Pass). LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)

-- | A simple case alternative with a single pattern, no binds, no guards;
--   pre-typechecking
mkHsCaseAlt :: forall (p :: Pass) body. (Anno (GRHS (GhcPass p) (LocatedA (body (GhcPass p)))) ~ EpAnn NoEpAnns, Anno (Match (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcSpanAnnA) => LPat (GhcPass p) -> LocatedA (body (GhcPass p)) -> LMatch (GhcPass p) (LocatedA (body (GhcPass p)))
tcShortCutLit :: HsOverLit GhcRn -> ExpRhoType -> TcM (Maybe (HsOverLit GhcTc))
shortCutLit :: Platform -> OverLitVal -> TcType -> Maybe (HsExpr GhcTc)
hsOverLitName :: OverLitVal -> Name

-- | Returns the type of the whole pattern
conLikeResTy :: ConLike -> [Type] -> Type
instance GHC.Internal.Base.Monoid GHC.Tc.Utils.TcMType.CandidatesQTvs
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcMType.CandidatesQTvs
instance GHC.Internal.Base.Semigroup GHC.Tc.Utils.TcMType.CandidatesQTvs


-- | Checking for representation-polymorphism using the Concrete mechanism.
--   
--   This module contains the logic for enforcing the
--   representation-polymorphism invariants by way of emitting constraints.
module GHC.Tc.Utils.Concrete

-- | Given a type <tt>ty :: ki</tt>, this function ensures that <tt>ty</tt>
--   has a <b>fixed</b> <tt>RuntimeRep</tt>, by emitting a new equality
--   constraint <tt>ki ~ concrete_tv</tt> for a concrete metavariable
--   <tt>concrete_tv</tt>.
--   
--   Returns a coercion <tt>co :: ty ~# concrete_ty</tt> as evidence. If
--   <tt>ty</tt> obviously has a fixed <tt>RuntimeRep</tt>, e.g <tt>ki =
--   IntRep</tt>, then this function immediately returns <a>MRefl</a>,
--   without emitting any constraints.
hasFixedRuntimeRep :: HasDebugCallStack => FixedRuntimeRepContext -> TcType -> TcM (TcCoercionN, TcTypeFRR)

-- | Like <a>hasFixedRuntimeRep</a>, but we perform an eager syntactic
--   check.
--   
--   Throws an error in the <a>TcM</a> monad if the check fails.
--   
--   This is useful if we are not actually going to use the coercion
--   returned from <a>hasFixedRuntimeRep</a>; it would generally be unsound
--   to allow a non-reflexive coercion but not actually make use of it in a
--   cast.
--   
--   The goal is to eliminate all uses of this function and replace them
--   with <a>hasFixedRuntimeRep</a>, making use of the returned coercion.
--   This is what is meant by going from PHASE 1 to PHASE 2, in Note [The
--   Concrete mechanism].
hasFixedRuntimeRep_syntactic :: HasDebugCallStack => FixedRuntimeRepContext -> TcType -> TcM ()

-- | Ensure that the given type <tt>ty</tt> can unify with a concrete type,
--   in the sense of Note [Concrete types].
--   
--   Returns a coercion <tt>co :: ty ~# conc_ty</tt>, where
--   <tt>conc_ty</tt> is concrete.
--   
--   If the type is already syntactically concrete, this immediately
--   returns a reflexive coercion. Otherwise, it creates a new concrete
--   metavariable <tt>concrete_tv</tt> and emits an equality constraint
--   <tt>ty ~# concrete_tv</tt>, to be handled by the constraint solver.
--   
--   Invariant: the kind of the supplied type must be concrete.
--   
--   We assume the provided type is already at the kind-level (this only
--   matters for error messages).
unifyConcrete :: HasDebugCallStack => FastString -> ConcreteTvOrigin -> TcType -> TcM TcMCoercionN

-- | Which type variables of this <a>Id</a> must be concrete when
--   instantiated?
--   
--   See Note [Representation-polymorphism checking built-ins]
idConcreteTvs :: TcId -> ConcreteTyVars

module GHC.Tc.Utils.Instantiate
topSkolemise :: SkolemInfo -> TcSigmaType -> TcM (HsWrapper, [(Name, TcInvisTVBinder)], [EvVar], TcRhoType)
skolemiseRequired :: SkolemInfo -> VisArity -> TcSigmaType -> TcM (VisArity, HsWrapper, [Name], [ForAllTyBinder], [EvVar], TcRhoType)
topInstantiate :: CtOrigin -> TcSigmaType -> TcM (HsWrapper, TcRhoType)
instantiateSigma :: CtOrigin -> ConcreteTyVars -> [TyVar] -> TcThetaType -> TcSigmaType -> TcM ([TcTyVar], HsWrapper, TcSigmaType)
instCall :: CtOrigin -> [TcType] -> TcThetaType -> TcM HsWrapper
instDFunType :: DFunId -> [DFunInstType] -> TcM ([TcType], TcThetaType)
instStupidTheta :: CtOrigin -> TcThetaType -> TcM ()
instTyVarsWith :: CtOrigin -> [TyVar] -> [TcType] -> TcM Subst

-- | Create a new Wanted constraint with the given <a>CtOrigin</a>, and
--   location information taken from the <a>TcM</a> environment.
newWanted :: CtOrigin -> Maybe TypeOrKind -> PredType -> TcM CtEvidence

-- | Create new Wanted constraints with the given <a>CtOrigin</a>, and
--   location information taken from the <a>TcM</a> environment.
newWanteds :: CtOrigin -> ThetaType -> TcM [CtEvidence]
tcInstType :: ([TyVar] -> TcM (Subst, [TcTyVar])) -> Id -> TcM ([(Name, TcTyVar)], TcThetaType, TcType)
tcInstTypeBndrs :: Type -> TcM ([(Name, InvisTVBinder)], TcThetaType, TcType)
tcSkolemiseInvisibleBndrs :: SkolemInfoAnon -> Type -> TcM ([TcTyVar], TcType)

-- | Given a list of <tt>[<a>TyVar</a>]</tt>, skolemize the type variables,
--   returning a substitution mapping the original tyvars to the skolems,
--   and the list of newly bound skolems.
tcInstSkolTyVars :: SkolemInfo -> [TyVar] -> TcM (Subst, [TcTyVar])
tcInstSkolTyVarsX :: SkolemInfo -> Subst -> [TyVar] -> TcM (Subst, [TcTyVar])
tcInstSkolTyVarBndrsX :: SkolemInfo -> Subst -> [VarBndr TyCoVar vis] -> TcM (Subst, [VarBndr TyCoVar vis])
tcSkolDFunType :: Type -> TcM (SkolemInfoAnon, [TcTyVar], TcThetaType, Class, [TcType])
tcSuperSkolTyVars :: TcLevel -> SkolemInfo -> [TyVar] -> (Subst, [TcTyVar])
tcInstSuperSkolTyVarsX :: SkolemInfo -> Subst -> [TyVar] -> TcM (Subst, [TcTyVar])

-- | Give fresh uniques to a bunch of TyVars, but they stay as TyVars,
--   rather than becoming TcTyVars Used in <a>newFamInst</a>, and
--   <a>newClsInst</a>
freshenTyVarBndrs :: [TyVar] -> TcM (Subst, [TyVar])

-- | Give fresh uniques to a bunch of CoVars Used in
--   "GHC.Tc.Instance.Family.newFamInst"
freshenCoVarBndrsX :: Subst -> [CoVar] -> TcM (Subst, [CoVar])
tcInstInvisibleTyBindersN :: Int -> TcKind -> TcM ([TcType], TcKind)

-- | Given ty::forall k1 k2. k, instantiate all the invisible
--   forall-binders returning ty <tt>kk1 </tt>kk2 :: k[kk1<i>k1, kk2</i>k1]
--   Called only to instantiate kinds, in user-written type signatures
tcInstInvisibleTyBinders :: TcType -> TcKind -> TcM (TcType, TcKind)
tcInstInvisibleTyBinder :: Subst -> TyVar -> TcM (Subst, TcType)
newOverloadedLit :: HsOverLit GhcRn -> ExpRhoType -> TcM (HsOverLit GhcTc)
mkOverLit :: forall (p :: Pass). OverLitVal -> TcM (HsLit (GhcPass p))
newClsInst :: Maybe OverlapMode -> Name -> [TyVar] -> ThetaType -> Class -> [Type] -> Maybe (WarningTxt GhcRn) -> TcM ClsInst
newFamInst :: FamFlavor -> CoAxiom Unbranched -> TcM FamInst
tcGetInsts :: TcM [ClsInst]
tcGetInstEnvs :: TcM InstEnvs
getOverlapFlag :: Maybe OverlapMode -> TcM OverlapFlag
tcExtendLocalInstEnv :: [ClsInst] -> TcM a -> TcM a
instCallConstraints :: CtOrigin -> TcThetaType -> TcM HsWrapper

-- | Used when <a>Name</a> is the wired-in name for a wired-in class
--   method, so the caller knows its type for sure, which should be of form
--   
--   <pre>
--   forall a. C a =&gt; &lt;blah&gt;
--   </pre>
--   
--   <a>newMethodFromName</a> is supposed to instantiate just the outer
--   type variable and constraint
newMethodFromName :: CtOrigin -> Name -> [TcRhoType] -> TcM (HsExpr GhcTc)
tcSyntaxName :: CtOrigin -> TcType -> (Name, HsExpr GhcRn) -> TcM (Name, HsExpr GhcTc)

-- | Returns free variables of WantedConstraints as a non-deterministic
--   set. See Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfWC :: WantedConstraints -> TyCoVarSet

-- | Returns free variables of constraints as a non-deterministic set
tyCoVarsOfCt :: Ct -> TcTyCoVarSet

-- | Returns free variables of a bag of constraints as a non-deterministic
--   set. See Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfCts :: Cts -> TcTyCoVarSet


-- | Type subsumption and unification
module GHC.Tc.Utils.Unify
tcWrapResult :: HsExpr GhcRn -> HsExpr GhcTc -> TcSigmaType -> ExpRhoType -> TcM (HsExpr GhcTc)
tcWrapResultO :: CtOrigin -> HsExpr GhcRn -> HsExpr GhcTc -> TcSigmaType -> ExpRhoType -> TcM (HsExpr GhcTc)
tcWrapResultMono :: HsExpr GhcRn -> HsExpr GhcTc -> TcRhoType -> ExpRhoType -> TcM (HsExpr GhcTc)
tcSubType :: CtOrigin -> UserTypeCtxt -> TcSigmaType -> ExpRhoType -> TcM HsWrapper
tcSubTypeSigma :: CtOrigin -> UserTypeCtxt -> TcSigmaType -> TcSigmaType -> TcM HsWrapper
tcSubTypePat :: CtOrigin -> UserTypeCtxt -> ExpSigmaType -> TcSigmaType -> TcM HsWrapper
tcSubTypeDS :: HsExpr GhcRn -> TcRhoType -> TcRhoType -> TcM HsWrapper
tcSubTypeAmbiguity :: UserTypeCtxt -> TcSigmaType -> TcSigmaType -> TcM HsWrapper
tcSubMult :: CtOrigin -> Mult -> Mult -> TcM HsWrapper
tcSubMult' :: CtOrigin -> Mult -> Mult -> TcM MultiplicityCheckCoercions
checkConstraints :: SkolemInfoAnon -> [TcTyVar] -> [EvVar] -> TcM result -> TcM (TcEvBinds, result)
checkTvConstraints :: SkolemInfo -> [TcTyVar] -> TcM result -> TcM result
buildImplicationFor :: TcLevel -> SkolemInfoAnon -> [TcTyVar] -> [EvVar] -> WantedConstraints -> TcM (Bag Implication, TcEvBinds)
buildTvImplication :: SkolemInfoAnon -> [TcTyVar] -> TcLevel -> WantedConstraints -> TcM Implication
emitResidualTvConstraint :: SkolemInfo -> [TcTyVar] -> TcLevel -> WantedConstraints -> TcM ()
data DeepSubsumptionFlag
Deep :: DeepSubsumptionFlag
Shallow :: DeepSubsumptionFlag
getDeepSubsumptionFlag :: TcM DeepSubsumptionFlag
isRhoTyDS :: DeepSubsumptionFlag -> TcType -> Bool
tcSkolemise :: DeepSubsumptionFlag -> UserTypeCtxt -> TcSigmaType -> (TcRhoType -> TcM result) -> TcM (HsWrapper, result)

-- | The wrapper has type: spec_ty ~&gt; expected_ty See Note
--   [Skolemisation] for the differences between tcSkolemiseCompleteSig and
--   tcTopSkolemise
tcSkolemiseCompleteSig :: TcCompleteSig -> ([ExpPatType] -> TcRhoType -> TcM result) -> TcM (HsWrapper, result)
tcSkolemiseExpectedType :: TcSigmaType -> ([ExpPatType] -> TcRhoType -> TcM result) -> TcM (HsWrapper, result)
unifyType :: Maybe TypedThing -> TcTauType -> TcTauType -> TcM TcCoercionN
unifyKind :: Maybe TypedThing -> TcKind -> TcKind -> TcM CoercionN
unifyInvisibleType :: TcTauType -> TcTauType -> TcM TcCoercionN
unifyExpectedType :: HsExpr GhcRn -> TcRhoType -> ExpRhoType -> TcM TcCoercionN
unifyExprType :: HsExpr GhcRn -> TcType -> TcType -> TcM TcCoercionN
unifyTypeAndEmit :: TypeOrKind -> CtOrigin -> TcType -> TcType -> TcM CoercionN
promoteTcType :: TcLevel -> TcType -> TcM (TcCoercionN, TcType)
swapOverTyVars :: Bool -> TcTyVar -> TcTyVar -> Bool
touchabilityAndShapeTest :: TcLevel -> TcTyVar -> TcType -> Bool

-- | checkTopShape checks (TYVAR-TV) Note [Unification preconditions];
--   returns True if these conditions are satisfied. But see the Note for
--   other preconditions, too.
checkTopShape :: MetaInfo -> TcType -> Bool
lhsPriority :: TcTyVar -> Int
data UnifyEnv
UE :: Role -> CtLoc -> RewriterSet -> TcRef (Bag Ct) -> Maybe (TcRef [TcTyVar]) -> UnifyEnv
[u_role] :: UnifyEnv -> Role
[u_loc] :: UnifyEnv -> CtLoc
[u_rewriters] :: UnifyEnv -> RewriterSet
[u_defer] :: UnifyEnv -> TcRef (Bag Ct)
[u_unified] :: UnifyEnv -> Maybe (TcRef [TcTyVar])
updUEnvLoc :: UnifyEnv -> (CtLoc -> CtLoc) -> UnifyEnv
setUEnvRole :: UnifyEnv -> Role -> UnifyEnv
uType :: UnifyEnv -> TcType -> TcType -> TcM CoercionN

-- | Infer a type using a fresh ExpType See also Note [ExpType] in
--   <a>GHC.Tc.Utils.TcMType</a>
--   
--   Use <a>tcInferFRR</a> if you require the type to have a fixed runtime
--   representation.
tcInfer :: (ExpSigmaType -> TcM a) -> TcM (a, TcSigmaType)
matchExpectedListTy :: TcRhoType -> TcM (TcCoercionN, TcRhoType)
matchExpectedTyConApp :: TyCon -> TcRhoType -> TcM (TcCoercionN, [TcSigmaType])
matchExpectedAppTy :: TcRhoType -> TcM (TcCoercion, (TcSigmaType, TcSigmaType))

-- | Use this function to split off arguments types when you have an
--   "expected" type.
--   
--   This function skolemises at each polytype.
--   
--   Invariant: this function only applies the provided function to a list
--   of argument types which all have a syntactically fixed RuntimeRep in
--   the sense of Note [Fixed RuntimeRep] in GHC.Tc.Utils.Concrete. See
--   Note [Return arguments with a fixed RuntimeRep].
matchExpectedFunTys :: ExpectedFunTyOrigin -> UserTypeCtxt -> VisArity -> ExpSigmaType -> ([ExpPatType] -> ExpRhoType -> TcM a) -> TcM (HsWrapper, a)

-- | Breaks apart a function kind into its pieces.
matchExpectedFunKind :: TypedThing -> Arity -> TcKind -> TcM Coercion

-- | <a>matchActualFunTy</a> looks for just one function arrow, returning
--   an uninstantiated sigma-type.
--   
--   Invariant: the returned argument type has a syntactically fixed
--   RuntimeRep in the sense of Note [Fixed RuntimeRep] in
--   GHC.Tc.Utils.Concrete.
--   
--   See Note [Return arguments with a fixed RuntimeRep].
matchActualFunTy :: ExpectedFunTyOrigin -> Maybe TypedThing -> (Arity, TcType) -> TcRhoType -> TcM (HsWrapper, Scaled TcSigmaTypeFRR, TcSigmaType)

-- | Like <a>matchExpectedFunTys</a>, but used when you have an "actual"
--   type, for example in function application.
--   
--   INVARIANT: the returned argument types all have a syntactically fixed
--   RuntimeRep in the sense of Note [Fixed RuntimeRep] in
--   GHC.Tc.Utils.Concrete. See Note [Return arguments with a fixed
--   RuntimeRep].
matchActualFunTys :: ExpectedFunTyOrigin -> CtOrigin -> Arity -> TcSigmaType -> TcM (HsWrapper, [Scaled TcSigmaTypeFRR], TcRhoType)
checkTyEqRhs :: TyEqFlags a -> TcType -> TcM (PuResult a Reduction)
recurseIntoTyConApp :: TyEqFlags a -> TyCon -> [TcType] -> TcM (PuResult a Reduction)
data PuResult a b
PuFail :: CheckTyEqResult -> PuResult a b
PuOK :: Bag a -> b -> PuResult a b
failCheckWith :: CheckTyEqResult -> TcM (PuResult a b)
okCheckRefl :: TcType -> TcM (PuResult a Reduction)
mapCheck :: (x -> TcM (PuResult a Reduction)) -> [x] -> TcM (PuResult a Reductions)

-- | Options describing how to deal with a type equality in the pure
--   unifier. See <a>checkTyEqRhs</a>
data TyEqFlags a
TEF :: Bool -> CanEqLHS -> AreUnifying -> TyEqFamApp a -> CheckTyEqProblem -> TyEqFlags a
[tef_foralls] :: TyEqFlags a -> Bool
[tef_lhs] :: TyEqFlags a -> CanEqLHS
[tef_unifying] :: TyEqFlags a -> AreUnifying
[tef_fam_app] :: TyEqFlags a -> TyEqFamApp a
[tef_occurs] :: TyEqFlags a -> CheckTyEqProblem

-- | What to do when encountering a type-family application while
--   processing a type equality in the pure unifier.
--   
--   See Note [Family applications in canonical constraints]
data TyEqFamApp a
TEFA_Fail :: TyEqFamApp a
TEFA_Recurse :: TyEqFamApp a
TEFA_Break :: FamAppBreaker a -> TyEqFamApp a
data AreUnifying
Unifying :: MetaInfo -> TcLevel -> LevelCheck -> AreUnifying
NotUnifying :: AreUnifying
data LevelCheck
LC_None :: LevelCheck
LC_Check :: LevelCheck
LC_Promote :: Bool -> LevelCheck
type FamAppBreaker a = TcType -> TcM PuResult a Reduction
famAppArgFlags :: TyEqFlags a -> TyEqFlags a
checkPromoteFreeVars :: CheckTyEqProblem -> TcTyVar -> TcLevel -> TyCoVarSet -> TcM CheckTyEqResult
simpleUnifyCheck :: UnifyCheckCaller -> TcTyVar -> TcType -> Bool
data UnifyCheckCaller
UC_OnTheFly :: UnifyCheckCaller
UC_QuickLook :: UnifyCheckCaller
UC_Solver :: UnifyCheckCaller
UC_Defaulting :: UnifyCheckCaller

-- | Fill an <a>InferResult</a> with the given type.
--   
--   If <tt>co = fillInferResult t1 infer_res</tt>, then <tt>co :: t1 ~#
--   t2</tt>, where <tt>t2</tt> is the type stored in the <a>ir_ref</a>
--   field of <tt>infer_res</tt>.
--   
--   This function enforces the following invariants:
--   
--   <ul>
--   <li>Level invariant. The stored type <tt>t2</tt> is at the same level
--   as given by the <a>ir_lvl</a> field.</li>
--   <li>FRR invariant. Whenever the <a>ir_frr</a> field is not
--   <tt>Nothing</tt>, <tt>t2</tt> is guaranteed to have a syntactically
--   fixed RuntimeRep, in the sense of Note [Fixed RuntimeRep] in
--   GHC.Tc.Utils.Concrete.</li>
--   </ul>
fillInferResult :: TcType -> InferResult -> TcM TcCoercionN
instance GHC.Internal.Base.Applicative (GHC.Tc.Utils.Unify.PuResult a)
instance GHC.Internal.Base.Functor (GHC.Tc.Utils.Unify.PuResult a)
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.Unify.AreUnifying
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.Unify.DeepSubsumptionFlag
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.Unify.LevelCheck
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b) => GHC.Utils.Outputable.Outputable (GHC.Tc.Utils.Unify.PuResult a b)
instance GHC.Utils.Outputable.Outputable (GHC.Tc.Utils.Unify.TyEqFamApp a)
instance GHC.Utils.Outputable.Outputable (GHC.Tc.Utils.Unify.TyEqFlags a)

module GHC.Tc.Instance.Typeable

-- | Generate the Typeable bindings for a module. This is the only
--   entry-point of this module and is invoked by the typechecker driver in
--   <tt>tcRnSrcDecls</tt>.
--   
--   See Note [Grand plan for Typeable] in <a>GHC.Tc.Instance.Typeable</a>.
mkTypeableBinds :: TcM TcGblEnv

-- | Is a particular <a>TyCon</a> representable by <tt>Typeable</tt>?.
--   These exclude type families and polytypes.
tyConIsTypeable :: TyCon -> Bool
instance GHC.Internal.Base.Applicative GHC.Tc.Instance.Typeable.KindRepM
instance GHC.Internal.Base.Functor GHC.Tc.Instance.Typeable.KindRepM
instance GHC.Internal.Base.Monad GHC.Tc.Instance.Typeable.KindRepM

module GHC.Runtime.Heap.Inspect

-- | Term reconstruction
--   
--   Given a pointer to a heap object (<a>HValue</a>) and its type, build a
--   <a>Term</a> representation of the object. Subterms (objects in the
--   payload) are also built up to the given <tt>max_depth</tt>. After
--   <tt>max_depth</tt> any subterms will appear as <a>Suspension</a>s. Any
--   thunks found while traversing the object will be forced based on
--   <tt>force</tt> parameter.
--   
--   Types of terms will be refined based on constructors we find during
--   term reconstruction. See <a>cvReconstructType</a> for an overview of
--   how type reconstruction works.
cvObtainTerm :: HscEnv -> Int -> Bool -> RttiType -> ForeignHValue -> IO Term

-- | Fast, breadth-first Type reconstruction
--   
--   Given a heap object (<a>HValue</a>) and its (possibly polymorphic)
--   type (usually obtained in GHCi), try to reconstruct a more monomorphic
--   type of the object. This is used for improving type information in
--   debugger. For example, if we have a polymorphic function:
--   
--   sumNumList :: Num a =&gt; [a] -&gt; a sumNumList [] = 0 sumNumList (x
--   : xs) = x + sumList xs
--   
--   and add a breakpoint to it:
--   
--   ghci&gt; break sumNumList ghci&gt; sumNumList ([0 .. 9] :: [Int])
--   
--   ghci shows us more precise types than just <tt>a</tt>s:
--   
--   Stopped in Main.sumNumList, debugger.hs:3:23-39 _result :: Int = _ x
--   :: Int = 0 xs :: [Int] = _
cvReconstructType :: HscEnv -> Int -> GhciType -> ForeignHValue -> IO (Maybe Type)
improveRTTIType :: HscEnv -> RttiType -> RttiType -> Maybe Subst
data Term
Term :: RttiType -> Either String DataCon -> ForeignHValue -> [Term] -> Term
[ty] :: Term -> RttiType
[dc] :: Term -> Either String DataCon
[val] :: Term -> ForeignHValue
[subTerms] :: Term -> [Term]
Prim :: RttiType -> [Word] -> Term
[ty] :: Term -> RttiType
[valRaw] :: Term -> [Word]
Suspension :: ClosureType -> RttiType -> ForeignHValue -> Maybe Name -> Term
[ctype] :: Term -> ClosureType
[ty] :: Term -> RttiType
[val] :: Term -> ForeignHValue
[bound_to] :: Term -> Maybe Name
NewtypeWrap :: RttiType -> Either String DataCon -> Term -> Term
[ty] :: Term -> RttiType
[dc] :: Term -> Either String DataCon
[wrapped_term] :: Term -> Term
RefWrap :: RttiType -> Term -> Term
[ty] :: Term -> RttiType
[wrapped_term] :: Term -> Term
isFullyEvaluatedTerm :: Term -> Bool
termType :: Term -> RttiType
mapTermType :: (RttiType -> Type) -> Term -> Term
termTyCoVars :: Term -> TyCoVarSet
foldTerm :: TermFold a -> Term -> a
data TermFold a
TermFold :: TermProcessor a a -> (RttiType -> [Word] -> a) -> (ClosureType -> RttiType -> ForeignHValue -> Maybe Name -> a) -> (RttiType -> Either String DataCon -> a -> a) -> (RttiType -> a -> a) -> TermFold a
[fTerm] :: TermFold a -> TermProcessor a a
[fPrim] :: TermFold a -> RttiType -> [Word] -> a
[fSuspension] :: TermFold a -> ClosureType -> RttiType -> ForeignHValue -> Maybe Name -> a
[fNewtypeWrap] :: TermFold a -> RttiType -> Either String DataCon -> a -> a
[fRefWrap] :: TermFold a -> RttiType -> a -> a

-- | Takes a list of custom printers with a explicit recursion knot and a
--   term, and returns the output of the first successful printer, or the
--   default printer
cPprTerm :: Monad m => CustomTermPrinter m -> Term -> m SDoc
cPprTermBase :: Monad m => CustomTermPrinter m
constrClosToName :: HscEnv -> GenClosure a -> IO (Either String Name)
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Heap.Inspect.Term


-- | This module is not used by GHC itself. Rather, it exports all of the
--   functions and types you are likely to need when writing a plugin for
--   GHC. So authors of plugins can probably get away simply with saying
--   "import GHC.Plugins".
--   
--   Particularly interesting modules for plugin writers include
--   <a>GHC.Core</a> and <a>GHC.Core.Opt.Monad</a>.
module GHC.Plugins
emptyFsEnv :: FastStringEnv a
extendFsEnv :: FastStringEnv a -> FastString -> a -> FastStringEnv a
lookupFsEnv :: FastStringEnv a -> FastString -> Maybe a
mkFsEnv :: [(FastString, a)] -> FastStringEnv a

-- | Alter an <a>OccEnv</a>, adding or removing an element at the given
--   key.
alterOccEnv :: (Maybe a -> Maybe a) -> OccEnv a -> OccName -> OccEnv a
avoidClashesOccEnv :: TidyOccEnv -> [OccName] -> TidyOccEnv
clsName :: NameSpace
dataName :: NameSpace

-- | Delete one element from an <a>OccEnv</a>.
delFromOccEnv :: OccEnv a -> OccName -> OccEnv a

-- | Delete multiple elements from an <a>OccEnv</a>.
delListFromOccEnv :: OccEnv a -> [OccName] -> OccEnv a
delTidyOccEnvList :: TidyOccEnv -> [OccName] -> TidyOccEnv
demoteOccName :: OccName -> Maybe OccName
demoteOccTvName :: OccName -> Maybe OccName

-- | Compute whether there is a value keyed by the given <a>OccName</a>.
elemOccEnv :: OccName -> OccEnv a -> Bool
elemOccSet :: OccName -> OccSet -> Bool

-- | The empty <a>OccEnv</a>.
emptyOccEnv :: OccEnv a
emptyOccSet :: OccSet
emptyTidyOccEnv :: TidyOccEnv

-- | Add a single element to an <a>OccEnv</a>.
extendOccEnv :: OccEnv a -> OccName -> a -> OccEnv a

-- | Extend an <a>OccEnv</a> by a list.
--   
--   <a>OccName</a>s later on in the list override earlier <a>OccName</a>s.
extendOccEnvList :: OccEnv a -> [(OccName, a)] -> OccEnv a

-- | Add a single element to an <a>OccEnv</a>, using a different function
--   whether the <a>OccName</a> already exists or not.
extendOccEnv_Acc :: (a -> b -> b) -> (a -> b) -> OccEnv b -> OccName -> a -> OccEnv b
extendOccSet :: OccSet -> OccName -> OccSet
extendOccSetList :: OccSet -> [OccName] -> OccSet
fieldName :: FastString -> NameSpace
fieldOcc_maybe :: OccName -> Maybe FastString

-- | Filter out all elements in an <a>OccEnv</a> using a predicate.
filterOccEnv :: (a -> Bool) -> OccEnv a -> OccEnv a

-- | Force an <a>OccEnv</a> with the provided function.
forceOccEnv :: (a -> ()) -> OccEnv a -> ()
initTidyOccEnv :: [OccName] -> TidyOccEnv
intersectOccEnv_C :: (a -> b -> c) -> OccEnv a -> OccEnv b -> OccEnv c
isDataConNameSpace :: NameSpace -> Bool
isDataOcc :: OccName -> Bool

-- | Test if the <a>OccName</a> is a data constructor that starts with a
--   symbol (e.g. <tt>:</tt>, or <tt>[]</tt>)
isDataSymOcc :: OccName -> Bool
isDefaultMethodOcc :: OccName -> Bool

-- | Test for definitions internally generated by GHC. This predicate is
--   used to suppress printing of internal definitions in some debug prints
isDerivedOccName :: OccName -> Bool
isEmptyOccSet :: OccSet -> Bool
isFieldNameSpace :: NameSpace -> Bool
isFieldOcc :: OccName -> Bool

-- | Test if the <a>OccName</a> is that for any operator (whether it is a
--   data constructor or variable or whatever)
isSymOcc :: OccName -> Bool
isTcClsNameSpace :: NameSpace -> Bool
isTcOcc :: OccName -> Bool

-- | Is this a term variable or field name namespace?
isTermVarOrFieldNameSpace :: NameSpace -> Bool
isTvNameSpace :: NameSpace -> Bool
isTvOcc :: OccName -> Bool

-- | Is an <a>OccName</a> one of a Typeable <tt>TyCon</tt> or
--   <tt>Module</tt> binding? This is needed as these bindings are renamed
--   differently. See Note [Grand plan for Typeable] in
--   <a>GHC.Tc.Instance.Typeable</a>.
isTypeableBindOcc :: OccName -> Bool
isUnderscore :: OccName -> Bool
isValNameSpace :: NameSpace -> Bool

-- | <i>Value</i> <tt>OccNames</tt>s are those that are either in the
--   variable, field name or data constructor namespaces
isValOcc :: OccName -> Bool
isVarNameSpace :: NameSpace -> Bool
isVarOcc :: OccName -> Bool

-- | Look up all the record fields that match with the given
--   <a>FastString</a> in an <a>OccEnv</a>.
lookupFieldsOccEnv :: OccEnv a -> FastString -> [a]

-- | Look an element up in an <a>OccEnv</a>.
lookupOccEnv :: OccEnv a -> OccName -> Maybe a

-- | Lookup an element in an <a>OccEnv</a>, ignoring <a>NameSpace</a>s
--   entirely.
lookupOccEnv_AllNameSpaces :: OccEnv a -> OccName -> [a]

-- | Lookup an element in an <a>OccEnv</a>, looking in the record field
--   namespace for a variable.
lookupOccEnv_WithFields :: OccEnv a -> OccName -> [a]
mainOcc :: OccName

-- | <tt>mapMaybe</tt> for b <a>OccEnv</a>.
mapMaybeOccEnv :: (a -> Maybe b) -> OccEnv a -> OccEnv b

-- | Map over an <a>OccEnv</a> (<a>Functor</a> instance).
mapOccEnv :: (a -> b) -> OccEnv a -> OccEnv b

-- | Remove elements of the first <a>OccEnv</a> that appear in the second
--   <a>OccEnv</a>.
minusOccEnv :: OccEnv a -> OccEnv b -> OccEnv a

-- | Alters (replaces or removes) those elements of the first <a>OccEnv</a>
--   that are mentioned in the second <a>OccEnv</a>.
--   
--   Same idea as <a>differenceWith</a>.
minusOccEnv_C :: (a -> b -> Maybe a) -> OccEnv a -> OccEnv b -> OccEnv a
minusOccEnv_C_Ns :: (UniqFM NameSpace a -> UniqFM NameSpace b -> UniqFM NameSpace a) -> OccEnv a -> OccEnv b -> OccEnv a
mkBuilderOcc :: OccName -> OccName
mkClassDataConOcc :: OccName -> OccName
mkClassOpAuxOcc :: OccName -> OccName
mkClsOcc :: String -> OccName
mkClsOccFS :: FastString -> OccName
mkCon2TagOcc :: OccName -> OccName
mkDFunOcc :: String -> Bool -> OccSet -> OccName
mkDataCOcc :: OccName -> OccName
mkDataConWorkerOcc :: OccName -> OccName
mkDataConWrapperOcc :: OccName -> OccName
mkDataOcc :: String -> OccName
mkDataOccFS :: FastString -> OccName
mkDataTOcc :: OccName -> OccName
mkDefaultMethodOcc :: OccName -> OccName
mkDictOcc :: OccName -> OccName
mkEqPredCoOcc :: OccName -> OccName
mkForeignExportOcc :: OccName -> OccName
mkGen1R :: OccName -> OccName
mkGenR :: OccName -> OccName
mkIPOcc :: OccName -> OccName
mkInstTyCoOcc :: OccName -> OccName

-- | Derive a name for the representation type constructor of a
--   <tt>data</tt>/<tt>newtype</tt> instance.
mkInstTyTcOcc :: String -> OccSet -> OccName
mkLocalOcc :: Unique -> OccName -> OccName
mkMatcherOcc :: OccName -> OccName
mkMaxTagOcc :: OccName -> OccName
mkMethodOcc :: OccName -> OccName
mkNewTyCoOcc :: OccName -> OccName

-- | Create an <a>OccEnv</a> from a list.
--   
--   <a>OccName</a>s later on in the list override earlier <a>OccName</a>s.
mkOccEnv :: [(OccName, a)] -> OccEnv a

-- | Create an <a>OccEnv</a> from a list, combining different values with
--   the same <a>OccName</a> using the combining function.
mkOccEnv_C :: (a -> a -> a) -> [(OccName, a)] -> OccEnv a
mkOccName :: NameSpace -> String -> OccName
mkOccNameFS :: NameSpace -> FastString -> OccName
mkOccSet :: [OccName] -> OccSet
mkRecFieldOcc :: FastString -> String -> OccName
mkRecFieldOccFS :: FastString -> FastString -> OccName
mkRepEqOcc :: OccName -> OccName
mkSpecOcc :: OccName -> OccName
mkSuperDictAuxOcc :: Int -> OccName -> OccName
mkSuperDictSelOcc :: Int -> OccName -> OccName
mkTag2ConOcc :: OccName -> OccName
mkTcOcc :: String -> OccName
mkTcOccFS :: FastString -> OccName
mkTyConRepOcc :: OccName -> OccName
mkTyVarOcc :: String -> OccName
mkTyVarOccFS :: FastString -> OccName
mkVarOcc :: String -> OccName
mkVarOccFS :: FastString -> OccName
mkWorkerOcc :: OccName -> OccName

-- | Fold over an <a>OccEnv</a>. Non-deterministic, unless the folding
--   function is commutative (i.e. <tt>a1 <tt>f</tt> ( a2 <tt>f</tt> b ) ==
--   a2 <tt>f</tt> ( a1 <tt>f</tt> b )</tt> for all <tt>a1</tt>,
--   <tt>a2</tt>, <tt>b</tt>).
nonDetFoldOccEnv :: (a -> b -> b) -> b -> OccEnv a -> b

-- | Obtain the elements of an <a>OccEnv</a>.
--   
--   The resulting order is non-deterministic.
nonDetOccEnvElts :: OccEnv a -> [a]

-- | Mangle field names to avoid duplicate symbols.
--   
--   See Note [Mangling OccNames].
occNameMangledFS :: OccName -> FastString
occNameString :: OccName -> String

-- | Wrap parens around an operator
parenSymOcc :: OccName -> SDoc -> SDoc

-- | Union of two <a>OccEnv</a>s, right-biased.
plusOccEnv :: OccEnv a -> OccEnv a -> OccEnv a

-- | Union of two <a>OccEnv</a>s with a combining function.
plusOccEnv_C :: (a -> a -> a) -> OccEnv a -> OccEnv a -> OccEnv a
ppMainFn :: OccName -> SDoc
pprNameSpace :: NameSpace -> SDoc
pprNameSpaceBrief :: NameSpace -> SDoc
pprNonVarNameSpace :: NameSpace -> SDoc
pprOccEnv :: (a -> SDoc) -> OccEnv a -> SDoc
pprOccName :: IsLine doc => OccName -> doc
promoteOccName :: OccName -> Maybe OccName
recFieldToVarOcc :: HasDebugCallStack => OccName -> OccName
setOccNameSpace :: NameSpace -> OccName -> OccName
srcDataName :: NameSpace

-- | Haskell 98 encourages compilers to suppress warnings about unused
--   names in a pattern if they start with <tt>_</tt>: this implements that
--   test
startsWithUnderscore :: OccName -> Bool

-- | Map over an <a>OccEnv</a> strictly.
strictMapOccEnv :: (a -> b) -> OccEnv a -> OccEnv b
tcClsName :: NameSpace
tcName :: NameSpace
tidyOccName :: TidyOccEnv -> OccName -> (TidyOccEnv, OccName)
trimTidyOccEnv :: TidyOccEnv -> [OccName] -> TidyOccEnv
tvName :: NameSpace
unionManyOccSets :: [OccSet] -> OccSet
unionOccSets :: OccSet -> OccSet -> OccSet

-- | A singleton <a>OccEnv</a>.
unitOccEnv :: OccName -> a -> OccEnv a
unitOccSet :: OccName -> OccSet
varToRecFieldOcc :: HasDebugCallStack => FastString -> OccName -> OccName

-- | A non-deterministic set of FastStrings. See Note [Deterministic
--   UniqFM] in <a>GHC.Types.Unique.DFM</a> for explanation why it's not
--   deterministic and why it matters. Use DFastStringEnv if the set
--   eventually gets converted into a list or folded over in a way where
--   the order changes the generated code.
type FastStringEnv a = UniqFM FastString a

-- | Other names in the compiler add additional information to an OccName.
--   This class provides a consistent way to access the underlying OccName.
class HasOccName name
occName :: HasOccName name => name -> OccName
data NameSpace

-- | A map keyed on <a>OccName</a>. See Note [OccEnv].
data OccEnv a

-- | Occurrence Name
--   
--   In this context that means: "classified (i.e. as a type name, value
--   name, etc) but not qualified and not yet resolved"
data OccName
data OccSet
type TidyOccEnv = UniqFM FastString Int
emptyFsEnv :: FastStringEnv a
extendFsEnv :: FastStringEnv a -> FastString -> a -> FastStringEnv a
lookupFsEnv :: FastStringEnv a -> FastString -> Maybe a
mkFsEnv :: [(FastString, a)] -> FastStringEnv a
getOccFS :: NamedThing a => a -> FastString
getOccString :: NamedThing a => a -> String
getSrcLoc :: NamedThing a => a -> SrcLoc
getSrcSpan :: NamedThing a => a -> SrcSpan
isBuiltInSyntax :: Name -> Bool
isDataConName :: Name -> Bool

-- | Will the <a>Name</a> come from a dynamically linked package?
isDynLinkName :: Platform -> Module -> Name -> Bool
isExternalName :: Name -> Bool
isFieldName :: Name -> Bool
isHoleName :: Name -> Bool
isInternalName :: Name -> Bool
isSumTyConName :: Name -> Bool
isSystemName :: Name -> Bool
isTupleTyConName :: Name -> Bool
isTyConName :: Name -> Bool
isTyVarName :: Name -> Bool

-- | This matches a datacon as well as its worker and promoted tycon.
isUnboxedTupleDataConLikeName :: Name -> Bool
isValName :: Name -> Bool
isVarName :: Name -> Bool
isWiredIn :: NamedThing thing => thing -> Bool
isWiredInName :: Name -> Bool

-- | Make the <a>Name</a> into an internal name, regardless of what it was
--   to begin with
localiseName :: Name -> Name
mkClonedInternalName :: Unique -> Name -> Name
mkDerivedInternalName :: (OccName -> OccName) -> Unique -> Name -> Name

-- | Create a name which definitely originates in the given module
mkExternalName :: Unique -> Module -> OccName -> SrcSpan -> Name

-- | Make a name for a foreign call
mkFCallName :: Unique -> FastString -> Name

-- | Create a name which is (for now at least) local to the current module
--   and hence does not need a <a>Module</a> to disambiguate it from other
--   <a>Name</a>s
mkInternalName :: Unique -> OccName -> SrcSpan -> Name
mkSysTvName :: Unique -> FastString -> Name

-- | Create a name brought into being by the compiler
mkSystemName :: Unique -> OccName -> Name
mkSystemNameAt :: Unique -> OccName -> SrcSpan -> Name
mkSystemVarName :: Unique -> FastString -> Name

-- | Create a name which is actually defined by the compiler itself
mkWiredInName :: Module -> OccName -> Unique -> TyThing -> BuiltInSyntax -> Name

-- | Returns True if the name is external or from the <tt>interactive</tt>
--   package See documentation of <a>nameIsLocalOrFrom</a> function
nameIsExternalOrFrom :: Module -> Name -> Bool

-- | Returns True if the Name comes from some other package: neither this
--   package nor the interactive package.
nameIsFromExternalPackage :: HomeUnit -> Name -> Bool
nameIsHomePackage :: Module -> Name -> Bool
nameIsHomePackageImport :: Module -> Name -> Bool

-- | Returns True if the name is (a) Internal (b) External but from the
--   specified module (c) External but from the <tt>interactive</tt>
--   package
--   
--   The key idea is that False means: the entity is defined in some other
--   module you can find the details (type, fixity, instances) in some
--   interface file those details will be stored in the EPT or HPT
--   
--   True means: the entity is defined in this module or earlier in the
--   GHCi session you can find details (type, fixity, instances) in the
--   TcGblEnv or TcLclEnv
--   
--   The isInteractiveModule part is because successive interactions of a
--   GHCi session each give rise to a fresh module (Ghci1, Ghci2, etc), but
--   they all come from the magic <tt>interactive</tt> package; and all the
--   details are kept in the TcLclEnv, TcGblEnv, NOT in the HPT or EPT. See
--   Note [The interactive package] in <a>GHC.Runtime.Context</a>
nameIsLocalOrFrom :: Module -> Name -> Bool
nameModule :: HasDebugCallStack => Name -> Module
nameModule_maybe :: Name -> Maybe Module
nameNameSpace :: Name -> NameSpace
nameOccName :: Name -> OccName
namePun_maybe :: Name -> Maybe FastString
nameSrcLoc :: Name -> SrcLoc
nameSrcSpan :: Name -> SrcSpan

-- | Get a string representation of a <a>Name</a> that's unique and stable
--   across recompilations. Used for deterministic generation of binds for
--   derived instances. eg.
--   "$aeson_70dylHtv1FFGeai1IoxcQr$Data.Aeson.Types.Internal$String"
nameStableString :: Name -> String
nameUnique :: Name -> Unique
pprDefinedAt :: Name -> SDoc

-- | Print fully qualified name (with unit-id and module, but no unique)
pprFullName :: Module -> Name -> SDoc
pprInfixName :: (Outputable a, NamedThing a) => a -> SDoc
pprModulePrefix :: PprStyle -> Module -> OccName -> SDoc
pprName :: IsLine doc => Name -> doc
pprNameDefnLoc :: Name -> SDoc

-- | Print the string of Name unqualifiedly directly.
pprNameUnqualified :: Name -> SDoc
pprPrefixName :: NamedThing a => a -> SDoc

-- | Print a ticky ticky styled name
--   
--   Module argument is the module to use for internal and system names.
--   When printing the name in a ticky profile, the module name is included
--   even for local things. However, ticky uses the format "x (M)" rather
--   than "M.x". Hence, this function provides a separation from normal
--   styling.
pprTickyName :: Module -> Name -> SDoc
setNameLoc :: Name -> SrcSpan -> Name
setNameUnique :: Name -> Unique -> Name

-- | Compare Names lexicographically This only works for Names that
--   originate in the source code or have been tidied.
stableNameCmp :: Name -> Name -> Ordering
tidyNameOcc :: Name -> OccName -> Name
wiredInNameTyThing_maybe :: Name -> Maybe TyThing

-- | Alter an <a>OccEnv</a>, adding or removing an element at the given
--   key.
alterOccEnv :: (Maybe a -> Maybe a) -> OccEnv a -> OccName -> OccEnv a
avoidClashesOccEnv :: TidyOccEnv -> [OccName] -> TidyOccEnv
clsName :: NameSpace
dataName :: NameSpace

-- | Delete one element from an <a>OccEnv</a>.
delFromOccEnv :: OccEnv a -> OccName -> OccEnv a

-- | Delete multiple elements from an <a>OccEnv</a>.
delListFromOccEnv :: OccEnv a -> [OccName] -> OccEnv a
delTidyOccEnvList :: TidyOccEnv -> [OccName] -> TidyOccEnv
demoteOccName :: OccName -> Maybe OccName
demoteOccTvName :: OccName -> Maybe OccName

-- | Compute whether there is a value keyed by the given <a>OccName</a>.
elemOccEnv :: OccName -> OccEnv a -> Bool
elemOccSet :: OccName -> OccSet -> Bool

-- | The empty <a>OccEnv</a>.
emptyOccEnv :: OccEnv a
emptyOccSet :: OccSet
emptyTidyOccEnv :: TidyOccEnv

-- | Add a single element to an <a>OccEnv</a>.
extendOccEnv :: OccEnv a -> OccName -> a -> OccEnv a

-- | Extend an <a>OccEnv</a> by a list.
--   
--   <a>OccName</a>s later on in the list override earlier <a>OccName</a>s.
extendOccEnvList :: OccEnv a -> [(OccName, a)] -> OccEnv a

-- | Add a single element to an <a>OccEnv</a>, using a different function
--   whether the <a>OccName</a> already exists or not.
extendOccEnv_Acc :: (a -> b -> b) -> (a -> b) -> OccEnv b -> OccName -> a -> OccEnv b
extendOccSet :: OccSet -> OccName -> OccSet
extendOccSetList :: OccSet -> [OccName] -> OccSet
fieldName :: FastString -> NameSpace
fieldOcc_maybe :: OccName -> Maybe FastString

-- | Filter out all elements in an <a>OccEnv</a> using a predicate.
filterOccEnv :: (a -> Bool) -> OccEnv a -> OccEnv a

-- | Force an <a>OccEnv</a> with the provided function.
forceOccEnv :: (a -> ()) -> OccEnv a -> ()
initTidyOccEnv :: [OccName] -> TidyOccEnv
intersectOccEnv_C :: (a -> b -> c) -> OccEnv a -> OccEnv b -> OccEnv c
isDataConNameSpace :: NameSpace -> Bool
isDataOcc :: OccName -> Bool

-- | Test if the <a>OccName</a> is a data constructor that starts with a
--   symbol (e.g. <tt>:</tt>, or <tt>[]</tt>)
isDataSymOcc :: OccName -> Bool
isDefaultMethodOcc :: OccName -> Bool

-- | Test for definitions internally generated by GHC. This predicate is
--   used to suppress printing of internal definitions in some debug prints
isDerivedOccName :: OccName -> Bool
isEmptyOccSet :: OccSet -> Bool
isFieldNameSpace :: NameSpace -> Bool
isFieldOcc :: OccName -> Bool

-- | Test if the <a>OccName</a> is that for any operator (whether it is a
--   data constructor or variable or whatever)
isSymOcc :: OccName -> Bool
isTcClsNameSpace :: NameSpace -> Bool
isTcOcc :: OccName -> Bool

-- | Is this a term variable or field name namespace?
isTermVarOrFieldNameSpace :: NameSpace -> Bool
isTvNameSpace :: NameSpace -> Bool
isTvOcc :: OccName -> Bool

-- | Is an <a>OccName</a> one of a Typeable <tt>TyCon</tt> or
--   <tt>Module</tt> binding? This is needed as these bindings are renamed
--   differently. See Note [Grand plan for Typeable] in
--   <a>GHC.Tc.Instance.Typeable</a>.
isTypeableBindOcc :: OccName -> Bool
isUnderscore :: OccName -> Bool
isValNameSpace :: NameSpace -> Bool

-- | <i>Value</i> <tt>OccNames</tt>s are those that are either in the
--   variable, field name or data constructor namespaces
isValOcc :: OccName -> Bool
isVarNameSpace :: NameSpace -> Bool
isVarOcc :: OccName -> Bool

-- | Look up all the record fields that match with the given
--   <a>FastString</a> in an <a>OccEnv</a>.
lookupFieldsOccEnv :: OccEnv a -> FastString -> [a]

-- | Look an element up in an <a>OccEnv</a>.
lookupOccEnv :: OccEnv a -> OccName -> Maybe a

-- | Lookup an element in an <a>OccEnv</a>, ignoring <a>NameSpace</a>s
--   entirely.
lookupOccEnv_AllNameSpaces :: OccEnv a -> OccName -> [a]

-- | Lookup an element in an <a>OccEnv</a>, looking in the record field
--   namespace for a variable.
lookupOccEnv_WithFields :: OccEnv a -> OccName -> [a]
mainOcc :: OccName

-- | <tt>mapMaybe</tt> for b <a>OccEnv</a>.
mapMaybeOccEnv :: (a -> Maybe b) -> OccEnv a -> OccEnv b

-- | Map over an <a>OccEnv</a> (<a>Functor</a> instance).
mapOccEnv :: (a -> b) -> OccEnv a -> OccEnv b

-- | Remove elements of the first <a>OccEnv</a> that appear in the second
--   <a>OccEnv</a>.
minusOccEnv :: OccEnv a -> OccEnv b -> OccEnv a

-- | Alters (replaces or removes) those elements of the first <a>OccEnv</a>
--   that are mentioned in the second <a>OccEnv</a>.
--   
--   Same idea as <a>differenceWith</a>.
minusOccEnv_C :: (a -> b -> Maybe a) -> OccEnv a -> OccEnv b -> OccEnv a
minusOccEnv_C_Ns :: (UniqFM NameSpace a -> UniqFM NameSpace b -> UniqFM NameSpace a) -> OccEnv a -> OccEnv b -> OccEnv a
mkBuilderOcc :: OccName -> OccName
mkClassDataConOcc :: OccName -> OccName
mkClassOpAuxOcc :: OccName -> OccName
mkClsOcc :: String -> OccName
mkClsOccFS :: FastString -> OccName
mkCon2TagOcc :: OccName -> OccName
mkDFunOcc :: String -> Bool -> OccSet -> OccName
mkDataCOcc :: OccName -> OccName
mkDataConWorkerOcc :: OccName -> OccName
mkDataConWrapperOcc :: OccName -> OccName
mkDataOcc :: String -> OccName
mkDataOccFS :: FastString -> OccName
mkDataTOcc :: OccName -> OccName
mkDefaultMethodOcc :: OccName -> OccName
mkDictOcc :: OccName -> OccName
mkEqPredCoOcc :: OccName -> OccName
mkForeignExportOcc :: OccName -> OccName
mkGen1R :: OccName -> OccName
mkGenR :: OccName -> OccName
mkIPOcc :: OccName -> OccName
mkInstTyCoOcc :: OccName -> OccName

-- | Derive a name for the representation type constructor of a
--   <tt>data</tt>/<tt>newtype</tt> instance.
mkInstTyTcOcc :: String -> OccSet -> OccName
mkLocalOcc :: Unique -> OccName -> OccName
mkMatcherOcc :: OccName -> OccName
mkMaxTagOcc :: OccName -> OccName
mkMethodOcc :: OccName -> OccName
mkNewTyCoOcc :: OccName -> OccName

-- | Create an <a>OccEnv</a> from a list.
--   
--   <a>OccName</a>s later on in the list override earlier <a>OccName</a>s.
mkOccEnv :: [(OccName, a)] -> OccEnv a

-- | Create an <a>OccEnv</a> from a list, combining different values with
--   the same <a>OccName</a> using the combining function.
mkOccEnv_C :: (a -> a -> a) -> [(OccName, a)] -> OccEnv a
mkOccName :: NameSpace -> String -> OccName
mkOccNameFS :: NameSpace -> FastString -> OccName
mkOccSet :: [OccName] -> OccSet
mkRecFieldOcc :: FastString -> String -> OccName
mkRecFieldOccFS :: FastString -> FastString -> OccName
mkRepEqOcc :: OccName -> OccName
mkSpecOcc :: OccName -> OccName
mkSuperDictAuxOcc :: Int -> OccName -> OccName
mkSuperDictSelOcc :: Int -> OccName -> OccName
mkTag2ConOcc :: OccName -> OccName
mkTcOcc :: String -> OccName
mkTcOccFS :: FastString -> OccName
mkTyConRepOcc :: OccName -> OccName
mkTyVarOcc :: String -> OccName
mkTyVarOccFS :: FastString -> OccName
mkVarOcc :: String -> OccName
mkVarOccFS :: FastString -> OccName
mkWorkerOcc :: OccName -> OccName

-- | Fold over an <a>OccEnv</a>. Non-deterministic, unless the folding
--   function is commutative (i.e. <tt>a1 <tt>f</tt> ( a2 <tt>f</tt> b ) ==
--   a2 <tt>f</tt> ( a1 <tt>f</tt> b )</tt> for all <tt>a1</tt>,
--   <tt>a2</tt>, <tt>b</tt>).
nonDetFoldOccEnv :: (a -> b -> b) -> b -> OccEnv a -> b

-- | Obtain the elements of an <a>OccEnv</a>.
--   
--   The resulting order is non-deterministic.
nonDetOccEnvElts :: OccEnv a -> [a]

-- | Mangle field names to avoid duplicate symbols.
--   
--   See Note [Mangling OccNames].
occNameMangledFS :: OccName -> FastString
occNameString :: OccName -> String

-- | Wrap parens around an operator
parenSymOcc :: OccName -> SDoc -> SDoc

-- | Union of two <a>OccEnv</a>s, right-biased.
plusOccEnv :: OccEnv a -> OccEnv a -> OccEnv a

-- | Union of two <a>OccEnv</a>s with a combining function.
plusOccEnv_C :: (a -> a -> a) -> OccEnv a -> OccEnv a -> OccEnv a
ppMainFn :: OccName -> SDoc
pprNameSpace :: NameSpace -> SDoc
pprNameSpaceBrief :: NameSpace -> SDoc
pprNonVarNameSpace :: NameSpace -> SDoc
pprOccEnv :: (a -> SDoc) -> OccEnv a -> SDoc
pprOccName :: IsLine doc => OccName -> doc
promoteOccName :: OccName -> Maybe OccName
recFieldToVarOcc :: HasDebugCallStack => OccName -> OccName
setOccNameSpace :: NameSpace -> OccName -> OccName
srcDataName :: NameSpace

-- | Haskell 98 encourages compilers to suppress warnings about unused
--   names in a pattern if they start with <tt>_</tt>: this implements that
--   test
startsWithUnderscore :: OccName -> Bool

-- | Map over an <a>OccEnv</a> strictly.
strictMapOccEnv :: (a -> b) -> OccEnv a -> OccEnv b
tcClsName :: NameSpace
tcName :: NameSpace
tidyOccName :: TidyOccEnv -> OccName -> (TidyOccEnv, OccName)
trimTidyOccEnv :: TidyOccEnv -> [OccName] -> TidyOccEnv
tvName :: NameSpace
unionManyOccSets :: [OccSet] -> OccSet
unionOccSets :: OccSet -> OccSet -> OccSet

-- | A singleton <a>OccEnv</a>.
unitOccEnv :: OccName -> a -> OccEnv a
unitOccSet :: OccName -> OccSet
varToRecFieldOcc :: HasDebugCallStack => FastString -> OccName -> OccName

-- | A non-deterministic set of FastStrings. See Note [Deterministic
--   UniqFM] in <a>GHC.Types.Unique.DFM</a> for explanation why it's not
--   deterministic and why it matters. Use DFastStringEnv if the set
--   eventually gets converted into a list or folded over in a way where
--   the order changes the generated code.
type FastStringEnv a = UniqFM FastString a

-- | BuiltInSyntax is for things like <tt>(:)</tt>, <tt>[]</tt> and tuples,
--   which have special syntactic forms. They aren't in scope as such.
data BuiltInSyntax
BuiltInSyntax :: BuiltInSyntax
UserSyntax :: BuiltInSyntax

-- | A unique, unambiguous name for something, containing information about
--   where that thing originated.
data Name

-- | A class allowing convenient access to the <a>Name</a> of various
--   datatypes
class NamedThing a
getOccName :: NamedThing a => a -> OccName
getName :: NamedThing a => a -> Name

-- | Other names in the compiler add additional information to an OccName.
--   This class provides a consistent way to access the underlying OccName.
class HasOccName name
occName :: HasOccName name => name -> OccName
data NameSpace

-- | A map keyed on <a>OccName</a>. See Note [OccEnv].
data OccEnv a

-- | Occurrence Name
--   
--   In this context that means: "classified (i.e. as a type name, value
--   name, etc) but not qualified and not yet resolved"
data OccName
data OccSet
type TidyOccEnv = UniqFM FastString Int

-- | Returns an unfolding only if (a) not a strong loop breaker and (b)
--   always active
alwaysActiveUnfoldingFun :: IdUnfoldingFun
asJoinId :: Id -> JoinArity -> JoinId
infixl 1 `asJoinId`
asJoinId_maybe :: Id -> JoinPointHood -> Id
infixl 1 `asJoinId_maybe`

-- | Remove any cbv marks on arguments from a given Id.
asNonWorkerLikeId :: Id -> Id

-- | Turn this id into a WorkerLikeId if possible.
asWorkerLikeId :: Id -> Id
clearOneShotLambda :: Id -> Id
floatifyIdDemandInfo :: Id -> Id

-- | Returns <tt>True</tt> of an <a>Id</a> which may not have a binding,
--   even though it is defined in this module.
hasNoBinding :: Id -> Bool
idArity :: Id -> Arity
idCafInfo :: Id -> CafInfo
infixl 1 `idCafInfo`
idCallArity :: Id -> Arity
idCbvMarkArity :: Id -> Arity
idCbvMarks_maybe :: Id -> Maybe [CbvMark]
idCoreRules :: Id -> [CoreRule]
idCprSig :: Id -> CprSig

-- | Get from either the worker or the wrapper <a>Id</a> to the
--   <a>DataCon</a>. Currently used only in the desugarer.
--   
--   INVARIANT: <tt>idDataCon (dataConWrapId d) = d</tt>: remember,
--   <a>dataConWrapId</a> can return either the wrapper or the worker
idDataCon :: Id -> DataCon
idDemandInfo :: Id -> Demand

-- | Accesses the <tt>Id'</tt>s <a>dmdSigInfo</a>.
idDmdSig :: Id -> DmdSig

-- | This function counts all arguments post-unarisation, which includes
--   arguments with no runtime representation -- see Note [Unarisation and
--   arity]
idFunRepArity :: Id -> RepArity
idHasRules :: Id -> Bool
idInlineActivation :: Id -> Activation
idInlinePragma :: Id -> InlinePragma
idIsFrom :: Module -> Id -> Bool
idJoinArity :: JoinId -> JoinArity

-- | Doesn't return strictness marks
idJoinPointHood :: Var -> JoinPointHood
idLFInfo_maybe :: Id -> Maybe LambdaFormInfo
idMult :: Id -> Mult
idName :: Id -> Name
idOccInfo :: Id -> OccInfo
idOneShotInfo :: Id -> OneShotInfo
idRuleMatchInfo :: Id -> RuleMatchInfo
idScaledType :: Id -> Scaled Type
idSpecialisation :: Id -> RuleInfo
idTagSig_maybe :: Id -> Maybe TagSig
idType :: Id -> Kind

-- | Returns the <a>Id</a>s unfolding, but does not expose the unfolding of
--   a strong loop breaker. See <a>unfoldingInfo</a>.
--   
--   If you really want the unfolding of a strong loopbreaker, call
--   <a>realIdUnfolding</a>.
idUnfolding :: IdUnfoldingFun
idUnique :: Id -> Unique
isClassOpId :: Id -> Bool
isClassOpId_maybe :: Id -> Maybe Class
isConLikeId :: Id -> Bool
isDFunId :: Id -> Bool
isDataConId :: Id -> Bool
isDataConId_maybe :: Id -> Maybe DataCon
isDataConRecordSelector :: Id -> Bool
isDataConWorkId :: Id -> Bool
isDataConWorkId_maybe :: Id -> Maybe DataCon
isDataConWrapId :: Id -> Bool
isDataConWrapId_maybe :: Id -> Maybe DataCon
isDeadBinder :: Id -> Bool

-- | Returns true if an application to n args diverges or throws an
--   exception See Note [Dead ends] in <a>GHC.Types.Demand</a>.
isDeadEndId :: Var -> Bool
isFCallId :: Id -> Bool
isFCallId_maybe :: Id -> Maybe ForeignCall

-- | <a>isImplicitId</a> tells whether an <a>Id</a>s info is implied by
--   other declarations, so we don't need to put its signature in an
--   interface file, even if it's mentioned in some other interface
--   unfolding.
isImplicitId :: Id -> Bool
isJoinId :: Var -> Bool
isNaughtyRecordSelector :: Id -> Bool
isPatSynRecordSelector :: Id -> Bool
isPrimOpId :: Id -> Bool
isPrimOpId_maybe :: Id -> Maybe PrimOp
isRecordSelector :: Id -> Bool

-- | <a>isStrictId</a> says whether either (a) the <a>Id</a> has a strict
--   demand placed on it or (b) definitely has a "strict type", such that
--   it can always be evaluated strictly (i.e an unlifted type) We need to
--   check (b) as well as (a), because when the demand for the given
--   <a>id</a> hasn't been computed yet but <a>id</a> has a strict type, we
--   still want `isStrictId id` to be <a>True</a>. Returns False if the
--   type is levity polymorphic; False is always safe.
isStrictId :: Id -> Bool

-- | An Id for which we might require all callers to pass strict arguments
--   properly tagged + evaluated.
--   
--   See Note [CBV Function Ids]
isWorkerLikeId :: Id -> Bool
localiseId :: Id -> Id
maybeModifyIdInfo :: Maybe IdInfo -> Id -> Id

-- | Create a local <a>Id</a> that is marked as exported. This prevents
--   things attached to it from being removed as dead code. See Note
--   [Exported LocalIds]
mkExportedLocalId :: IdDetails -> Name -> Type -> Id
mkExportedVanillaId :: Name -> Type -> Id

-- | For an explanation of global vs. local <a>Id</a>s, see
--   <a>GHC.Types.Var.Var#globalvslocal</a>
mkGlobalId :: IdDetails -> Name -> Type -> IdInfo -> Id

-- | Make a local CoVar
mkLocalCoVar :: HasDebugCallStack => Name -> Type -> CoVar

-- | For an explanation of global vs. local <a>Id</a>s, see
--   <a>GHC.Types.Var#globalvslocal</a>
mkLocalId :: HasDebugCallStack => Name -> Mult -> Type -> Id

-- | Like <a>mkLocalId</a>, but checks the type to see if it should make a
--   covar
mkLocalIdOrCoVar :: HasDebugCallStack => Name -> Mult -> Type -> Id
mkLocalIdWithInfo :: HasDebugCallStack => Name -> Mult -> Type -> IdInfo -> Id
mkScaledTemplateLocal :: Int -> Scaled Type -> Id

-- | Create a system local <a>Id</a>. These are local <a>Id</a>s (see
--   <a>Var#globalvslocal</a>) that are created by the compiler out of thin
--   air
mkSysLocal :: FastString -> Unique -> Mult -> Type -> Id
mkSysLocalM :: MonadUnique m => FastString -> Mult -> Type -> m Id

-- | Like <a>mkSysLocal</a>, but checks to see if we have a covar type
mkSysLocalOrCoVar :: FastString -> Unique -> Mult -> Type -> Id
mkSysLocalOrCoVarM :: MonadUnique m => FastString -> Mult -> Type -> m Id

-- | Create a <i>template local</i>: a family of system local <a>Id</a>s in
--   bijection with <tt>Int</tt>s, typically used in unfoldings
mkTemplateLocal :: Int -> Type -> Id

-- | Create a template local for a series of types
mkTemplateLocals :: [Type] -> [Id]

-- | Create a template local for a series of type, but start from a
--   specified template local
mkTemplateLocalsNum :: Int -> [Type] -> [Id]

-- | Create a user local <a>Id</a>. These are local <a>Id</a>s (see
--   <a>GHC.Types.Var#globalvslocal</a>) with a name and location that the
--   user might recognize
mkUserLocal :: OccName -> Unique -> Mult -> Type -> SrcSpan -> Id

-- | Like <a>mkUserLocal</a>, but checks if we have a coercion type
mkUserLocalOrCoVar :: OccName -> Unique -> Mult -> Type -> SrcSpan -> Id

-- | Make a global <a>Id</a> without any extra information at all
mkVanillaGlobal :: HasDebugCallStack => Name -> Type -> Id

-- | Make a global <a>Id</a> with no global information but some generic
--   <a>IdInfo</a>
mkVanillaGlobalWithInfo :: HasDebugCallStack => Name -> Type -> IdInfo -> Id

-- | Workers get local names. <a>CoreTidy</a> will externalise these if
--   necessary
mkWorkerId :: Unique -> Id -> Type -> Id
modifyIdInfo :: HasDebugCallStack => (IdInfo -> IdInfo) -> Id -> Id
modifyInlinePragma :: Id -> (InlinePragma -> InlinePragma) -> Id
noUnfoldingFun :: IdUnfoldingFun

-- | Expose the unfolding if there is one, including for loop breakers
realIdUnfolding :: Id -> Unfolding

-- | If the <a>Id</a> is that for a record selector, extract the
--   <a>sel_tycon</a>. Panic otherwise.
recordSelectorTyCon :: Id -> RecSelParent
recordSelectorTyCon_maybe :: Id -> Maybe RecSelParent
scaleIdBy :: Mult -> Id -> Id

-- | Like <a>scaleIdBy</a>, but skips non-Ids. Useful for scaling a mixed
--   list of ids and tyvars.
scaleVarBy :: Mult -> Var -> Var
setCaseBndrEvald :: StrictnessMark -> Id -> Id
setIdArity :: Id -> Arity -> Id
infixl 1 `setIdArity`
setIdCafInfo :: Id -> CafInfo -> Id
setIdCallArity :: Id -> Arity -> Id
infixl 1 `setIdCallArity`

-- | If all marks are NotMarkedStrict we just set nothing.
setIdCbvMarks :: Id -> [CbvMark] -> Id
infixl 1 `setIdCbvMarks`
setIdCprSig :: Id -> CprSig -> Id
infixl 1 `setIdCprSig`
setIdDemandInfo :: Id -> Demand -> Id
infixl 1 `setIdDemandInfo`
setIdDmdSig :: Id -> DmdSig -> Id
infixl 1 `setIdDmdSig`
setIdInfo :: Id -> IdInfo -> Id
setIdLFInfo :: Id -> LambdaFormInfo -> Id
setIdName :: Id -> Name -> Id
setIdOccInfo :: Id -> OccInfo -> Id
infixl 1 `setIdOccInfo`
setIdOneShotInfo :: Id -> OneShotInfo -> Id
infixl 1 `setIdOneShotInfo`
setIdSpecialisation :: Id -> RuleInfo -> Id
infixl 1 `setIdSpecialisation`
setIdTagSig :: Id -> TagSig -> Id

-- | Not only does this set the <a>Id</a> <a>Type</a>, it also evaluates
--   the type to try and reduce space usage
setIdType :: Id -> Type -> Id
setIdUnfolding :: Id -> Unfolding -> Id
infixl 1 `setIdUnfolding`
setIdUnique :: Id -> Unique -> Id
setInlineActivation :: Id -> Activation -> Id
infixl 1 `setInlineActivation`
setInlinePragma :: Id -> InlinePragma -> Id
infixl 1 `setInlinePragma`
setOneShotLambda :: Id -> Id
transferPolyIdInfo :: Id -> [Var] -> Id -> Id
updOneShotInfo :: Id -> OneShotInfo -> Id

-- | Returns an unfolding only if (a) not a strong loop breaker and (b)
--   active in according to is_active
whenActiveUnfoldingFun :: (Activation -> Bool) -> IdUnfoldingFun
zapFragileIdInfo :: Id -> Id
zapIdDmdSig :: Id -> Id
zapIdOccInfo :: Id -> Id
zapIdTailCallInfo :: Id -> Id

-- | Similar to trimUnfolding, but also removes evaldness info.
zapIdUnfolding :: Id -> Id
zapIdUsageEnvInfo :: Id -> Id
zapIdUsageInfo :: Id -> Id
zapIdUsedOnceInfo :: Id -> Id
zapJoinId :: Id -> Id
zapLamIdInfo :: Id -> Id
zapStableUnfolding :: Id -> Id

-- | If it's a local, make it global
globaliseId :: Id -> Id
idDetails :: Id -> IdDetails
idInfo :: HasDebugCallStack => Id -> IdInfo

-- | <tt>isExportedIdVar</tt> means "don't throw this away"
isExportedId :: Var -> Bool
isGlobalId :: Var -> Bool

-- | Is this a value-level (i.e., computationally relevant)
--   <a>Id</a>entifier? Satisfies <tt>isId = not . isTyVar</tt>.
isId :: Var -> Bool
isLocalId :: Var -> Bool
setIdMult :: Id -> Mult -> Id
updateIdTypeAndMult :: (Type -> Type) -> Id -> Id
updateIdTypeAndMultM :: Monad m => (Type -> m Type) -> Id -> m Id
updateIdTypeButNotMult :: (Type -> Type) -> Id -> Id
type IdUnfoldingFun = Id -> Unfolding

-- | Identifier
type Id = Var
type InId = Id
type InVar = Var
type JoinId = Id
type OutId = Id
type OutVar = Var

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var
data JoinPointHood
cloneBndr :: Subst -> Unique -> Var -> (Subst, Var)
cloneBndrs :: MonadUnique m => Subst -> [Var] -> m (Subst, [Var])

-- | Very similar to <a>substBndr</a>, but it always allocates a new
--   <a>Unique</a> for each variable in its output. It substitutes the
--   IdInfo though. Discards non-Stable unfoldings
cloneIdBndr :: Subst -> UniqSupply -> Id -> (Subst, Id)

-- | Applies <a>cloneIdBndr</a> to a number of <a>Id</a>s, accumulating a
--   final substitution from left to right Discards non-Stable unfoldings
cloneIdBndrs :: Subst -> UniqSupply -> [Id] -> (Subst, [Id])

-- | Clone a mutually recursive group of <a>Id</a>s
cloneRecIdBndrs :: MonadUnique m => Subst -> [Id] -> m (Subst, [Id])

-- | De-shadowing the program is sometimes a useful pre-pass. It can be
--   done simply by running over the bindings with an empty substitution,
--   because substitution returns a result that has no-shadowing
--   guaranteed.
--   
--   (Actually, within a single <i>type</i> there might still be shadowing,
--   because <tt>substTy</tt> is a no-op for the empty substitution, but
--   that's probably OK.)
--   
--   <ul>
--   <li><i>Aug 09</i> This function is not used in GHC at the moment, but
--   seems so short and simple that I'm going to leave it here</li>
--   </ul>
deShadowBinds :: CoreProgram -> CoreProgram
delBndr :: Subst -> Var -> Subst
delBndrs :: Subst -> [Var] -> Subst

-- | Add a substitution for an <a>Id</a> to the <a>Subst</a>: you must
--   ensure that the in-scope set is such that TyCoSubst Note [The
--   substitution invariant] holds after extending the substitution like
--   this
extendIdSubst :: Subst -> Id -> CoreExpr -> Subst

-- | Adds multiple <a>Id</a> substitutions to the <a>Subst</a>: see also
--   <a>extendIdSubst</a>
extendIdSubstList :: Subst -> [(Id, CoreExpr)] -> Subst
extendIdSubstWithClone :: Subst -> Id -> Id -> Subst

-- | Add a substitution appropriate to the thing being substituted (whether
--   an expression, type, or coercion). See also <a>extendIdSubst</a>,
--   <a>extendTvSubst</a>, <a>extendCvSubst</a>
extendSubst :: Subst -> Var -> CoreArg -> Subst

-- | Add a substitution as appropriate to each of the terms being
--   substituted (whether expressions, types, or coercions). See also
--   <a>extendSubst</a>.
extendSubstList :: Subst -> [(Var, CoreArg)] -> Subst
extendSubstWithVar :: Subst -> Var -> Var -> Subst

-- | Find the substitution for an <a>Id</a> in the <a>Subst</a> The Id
--   should not be a CoVar
lookupIdSubst :: HasDebugCallStack => Subst -> Id -> CoreExpr
lookupIdSubst_maybe :: HasDebugCallStack => Subst -> Id -> Maybe CoreExpr

-- | Simultaneously substitute for a bunch of variables No left-right
--   shadowing ie the substitution for (x y. e) a1 a2 so neither x nor y
--   scope over a1 a2
mkOpenSubst :: InScopeSet -> [(Var, CoreArg)] -> Subst

-- | Apply a substitution to an entire <a>CoreBind</a>, additionally
--   returning an updated <a>Subst</a> that should be used by subsequent
--   substitutions.
substBind :: HasDebugCallStack => Subst -> CoreBind -> (Subst, CoreBind)

-- | Apply a substitution to an entire <a>CoreBind</a>, additionally
--   returning an updated <a>Subst</a> that should be used by subsequent
--   substitutions.
substBindSC :: HasDebugCallStack => Subst -> CoreBind -> (Subst, CoreBind)

-- | Substitutes a <a>Var</a> for another one according to the <a>Subst</a>
--   given, returning the result and an updated <a>Subst</a> that should be
--   used by subsequent substitutions. <a>IdInfo</a> is preserved by this
--   process, although it is substituted into appropriately.
substBndr :: Subst -> Var -> (Subst, Var)

-- | Applies <a>substBndr</a> to a number of <a>Var</a>s, accumulating a
--   new <a>Subst</a> left-to-right
substBndrs :: Traversable f => Subst -> f Var -> (Subst, f Var)
substDVarSet :: HasDebugCallStack => Subst -> DVarSet -> DVarSet

-- | substExpr applies a substitution to an entire <a>CoreExpr</a>.
--   Remember, you may only apply the substitution <i>once</i>: See Note
--   [Substitutions apply only once] in <a>GHC.Core.TyCo.Subst</a>
--   
--   Do *not* attempt to short-cut in the case of an empty substitution!
--   See Note [Extending the IdSubstEnv]
substExpr :: HasDebugCallStack => Subst -> CoreExpr -> CoreExpr
substExprSC :: HasDebugCallStack => Subst -> CoreExpr -> CoreExpr

-- | Substitute into some <a>IdInfo</a> with regard to the supplied new
--   <a>Id</a>. Discards unfoldings, unless they are Stable
substIdInfo :: Subst -> Id -> IdInfo -> Maybe IdInfo
substIdOcc :: Subst -> Id -> Id
substIdType :: Subst -> Id -> Id

-- | Substitute in a mutually recursive group of <a>Id</a>s
substRecBndrs :: Traversable f => Subst -> f Id -> (Subst, f Id)

-- | Substitutes for the <a>Id</a>s within the <a>RuleInfo</a> given the
--   new function <a>Id</a>
substRuleInfo :: Subst -> Id -> RuleInfo -> RuleInfo
substRulesForImportedIds :: Subst -> [CoreRule] -> [CoreRule]

-- | Drop free vars from the breakpoint if they have a non-variable
--   substitution.
substTickish :: Subst -> CoreTickish -> CoreTickish

-- | Substitutes for the <a>Id</a>s within an unfolding NB: substUnfolding
--   <i>discards</i> any unfolding without without a Stable source. This is
--   usually what we want, but it may be a bit unexpected
substUnfolding :: Subst -> Unfolding -> Unfolding

-- | Substitutes for the <a>Id</a>s within an unfolding NB: substUnfolding
--   <i>discards</i> any unfolding without without a Stable source. This is
--   usually what we want, but it may be a bit unexpected
substUnfoldingSC :: Subst -> Unfolding -> Unfolding
emptySubst :: Subst

-- | Add the <a>Var</a> to the in-scope set
extendSubstInScope :: Subst -> Var -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeList :: Subst -> [Var] -> Subst
extendTCvSubst :: Subst -> TyCoVar -> Type -> Subst

-- | Add a substitution for a <a>TyVar</a> to the <a>Subst</a> The
--   <a>TyVar</a> *must* be a real TyVar, and not a CoVar You must ensure
--   that the in-scope set is such that Note [The substitution invariant]
--   holds after extending the substitution like this.
extendTvSubst :: Subst -> TyVar -> Type -> Subst

-- | Adds multiple <a>TyVar</a> substitutions to the <a>Subst</a>: see also
--   <a>extendTvSubst</a>
extendTvSubstList :: Subst -> [(TyVar, Type)] -> Subst

-- | Find the in-scope set: see Note [The substitution invariant]
getSubstInScope :: Subst -> InScopeSet
isEmptySubst :: Subst -> Bool
isInScope :: Var -> Subst -> Bool
mkEmptySubst :: InScopeSet -> Subst
mkTCvSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> Subst
setInScope :: Subst -> InScopeSet -> Subst

-- | Substitute within a <a>Coercion</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substCo :: HasDebugCallStack => Subst -> Coercion -> Coercion

-- | Substitute within a <a>Type</a> disabling the sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyUnchecked :: Subst -> Type -> Type

-- | Remove all substitutions that might have been built up while
--   preserving the in-scope set originally called zapSubstEnv
zapSubst :: Subst -> Subst

-- | A substitution of <tt>Expr</tt>s for non-coercion <a>Id</a>s
type IdSubstEnv = IdEnv CoreExpr

-- | Type &amp; coercion &amp; id substitution
--   
--   The <a>Subst</a> data type defined in this module contains
--   substitution for tyvar, covar and id. However, operations on
--   IdSubstEnv (mapping from <a>Id</a> to <a>CoreExpr</a>) that require
--   the definition of the <a>Expr</a> data type are defined in
--   GHC.Core.Subst to avoid circular module dependency.
data Subst
Subst :: InScopeSet -> IdSubstEnv -> TvSubstEnv -> CvSubstEnv -> Subst

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type

-- | A set of variables that are in scope at some point.
--   
--   Note that this is a <i>superset</i> of the variables that are
--   currently in scope. See Note [The InScopeSet invariant].
--   
--   "Secrets of the Glasgow Haskell Compiler inliner" Section 3.2 provides
--   the motivation for this abstraction.
data InScopeSet
liftedTypeKind :: Type
unliftedTypeKind :: Type
funTyFlagTyCon :: FunTyFlag -> TyCon
anyFreeVarsOfType :: (TyCoVar -> Bool) -> Type -> Bool
anyFreeVarsOfTypes :: (TyCoVar -> Bool) -> [Type] -> Bool
closeOverKinds :: TyCoVarSet -> TyCoVarSet

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministic set.
closeOverKindsDSet :: DTyVarSet -> DTyVarSet

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministically ordered list.
closeOverKindsList :: [TyVar] -> [TyVar]
coVarsOfType :: Type -> CoVarSet
coVarsOfTypes :: [Type] -> CoVarSet
noFreeVarsOfType :: Type -> Bool
occCheckExpand :: [Var] -> Type -> Maybe Type

-- | Do a topological sort on a list of tyvars, so that binders occur
--   before occurrences E.g. given [ a::k, k::*, b::k ] it'll return a
--   well-scoped list [ k::*, a::k, b::k ]
--   
--   This is a deterministic sorting operation (that is, doesn't depend on
--   Uniques).
--   
--   It is also meant to be stable: that is, variables should not be
--   reordered unnecessarily. This is specified in Note [ScopedSort] See
--   also Note [Ordering of implicit variables] in <a>GHC.Rename.HsType</a>
scopedSort :: [TyCoVar] -> [TyCoVar]
tyCoFVsBndr :: ForAllTyBinder -> FV -> FV

-- | The worker for <a>tyCoFVsOfType</a> and <tt>tyCoFVsOfTypeList</tt>.
--   The previous implementation used <a>unionVarSet</a> which is O(n+m)
--   and can make the function quadratic. It's exported, so that it can be
--   composed with other functions that compute free variables. See Note
--   [FV naming conventions] in <a>GHC.Utils.FV</a>.
--   
--   Eta-expanded because that makes it run faster (apparently) See Note
--   [FV eta expansion] in <a>GHC.Utils.FV</a> for explanation.
tyCoFVsOfType :: Type -> FV
tyCoFVsVarBndr :: Var -> FV -> FV
tyCoFVsVarBndrs :: [Var] -> FV -> FV
tyCoVarsOfType :: Type -> TyCoVarSet

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in a
--   deterministic set. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfTypeDSet :: Type -> DTyCoVarSet

-- | Get the free vars of a type in scoped order
tyCoVarsOfTypeWellScoped :: Type -> [TyVar]
tyCoVarsOfTypes :: [Type] -> TyCoVarSet

-- | Get the free vars of types in scoped order
tyCoVarsOfTypesWellScoped :: [Type] -> [TyVar]

-- | All type constructors occurring in the type; looking through type
--   synonyms, but not newtypes. When it finds a Class, it returns the
--   class TyCon.
tyConsOfType :: Type -> UniqSet TyCon
foldTyCo :: Monoid a => TyCoFolder env a -> env -> (Type -> a, [Type] -> a, Coercion -> a, [Coercion] -> a)

-- | Like <tt>mkTyCoForAllTy</tt>, but does not check the occurrence of the
--   binder See Note [Unused coercion variable in ForAllTy]
mkForAllTy :: ForAllTyBinder -> Type -> Type

-- | Wraps foralls over the type using the provided <a>TyCoVar</a>s from
--   left to right
mkForAllTys :: [ForAllTyBinder] -> Type -> Type
mkFunTy :: HasDebugCallStack => FunTyFlag -> Mult -> Type -> Type -> Type
infixr 3 `mkFunTy`

-- | Wraps foralls over the type using the provided <a>InvisTVBinder</a>s
--   from left to right
mkInvisForAllTys :: [InvisTVBinder] -> Type -> Type
mkInvisFunTy :: HasDebugCallStack => Type -> Type -> Type
infixr 3 `mkInvisFunTy`
mkInvisFunTys :: HasDebugCallStack => [Type] -> Type -> Type
mkPiTy :: HasDebugCallStack => PiTyBinder -> Type -> Type
mkPiTys :: HasDebugCallStack => [PiTyBinder] -> Type -> Type
mkScaledFunTys :: HasDebugCallStack => [Scaled Type] -> Type -> Type
mkTyVarTy :: TyVar -> Type
mkTyVarTys :: [TyVar] -> [Type]
mkVisFunTy :: HasDebugCallStack => Mult -> Type -> Type -> Type

-- | Make nested arrow types | Special, common, case: Arrow type with mult
--   Many
mkVisFunTyMany :: HasDebugCallStack => Type -> Type -> Type
infixr 3 `mkVisFunTyMany`
mkVisFunTysMany :: [Type] -> Type -> Type

-- | A view function that looks through nothing.
noView :: Type -> Maybe Type
tcMkInvisFunTy :: TypeOrConstraint -> Type -> Type -> Type
tcMkScaledFunTys :: [Scaled Type] -> Type -> Type
tcMkVisFunTy :: Mult -> Type -> Type -> Type
typeSize :: Type -> Int
cloneTyVarBndr :: Subst -> TyVar -> Unique -> (Subst, TyVar)
cloneTyVarBndrs :: Subst -> [TyVar] -> UniqSupply -> (Subst, [TyVar])

-- | Composes two substitutions, applying the second one provided first,
--   like in function composition. This function leaves IdSubstEnv
--   untouched because IdSubstEnv is not used during substitution for
--   types.
composeTCvSubst :: Subst -> Subst -> Subst
emptySubst :: Subst
emptyTvSubstEnv :: TvSubstEnv

-- | Add a substitution from a <a>CoVar</a> to a <a>Coercion</a> to the
--   <a>Subst</a>: you must ensure that the in-scope set satisfies Note
--   [The substitution invariant] after extending the substitution like
--   this
extendCvSubst :: Subst -> CoVar -> Coercion -> Subst

-- | Add the <a>Var</a> to the in-scope set
extendSubstInScope :: Subst -> Var -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeList :: Subst -> [Var] -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeSet :: Subst -> VarSet -> Subst
extendTCvSubst :: Subst -> TyCoVar -> Type -> Subst
extendTCvSubstList :: Subst -> [Var] -> [Type] -> Subst
extendTCvSubstWithClone :: Subst -> TyCoVar -> TyCoVar -> Subst
extendTvSubstAndInScope :: Subst -> TyVar -> Type -> Subst
extendTvSubstWithClone :: Subst -> TyVar -> TyVar -> Subst

-- | Find the in-scope set: see Note [The substitution invariant]
getSubstInScope :: Subst -> InScopeSet

-- | Returns the free variables of the types in the range of a substitution
--   as a non-deterministic set.
getSubstRangeTyCoFVs :: Subst -> VarSet
getTvSubstEnv :: Subst -> TvSubstEnv
isEmptySubst :: Subst -> Bool

-- | Checks whether the tyvar and covar environments are empty. This
--   function should be used over <a>isEmptySubst</a> when substituting for
--   types, because types currently do not contain expressions; we can
--   safely disregard the expression environment when deciding whether to
--   skip a substitution. Using <a>isEmptyTCvSubst</a> gives us a
--   non-trivial performance boost (up to 70% less allocation for T18223)
isEmptyTCvSubst :: Subst -> Bool
lookupTyVar :: Subst -> TyVar -> Maybe Type
mkEmptySubst :: InScopeSet -> Subst
mkTCvSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> Subst

-- | Generates the in-scope set for the <tt>TCvSubst</tt> from the types in
--   the incoming environment. No CoVars, please! The InScopeSet is just a
--   thunk so with a bit of luck it'll never be evaluated
mkTvSubstPrs :: [(TyVar, Type)] -> Subst
notElemSubst :: Var -> Subst -> Bool
setInScope :: Subst -> InScopeSet -> Subst

-- | Substitute within a <a>Coercion</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substCo :: HasDebugCallStack => Subst -> Coercion -> Coercion

-- | Substitute within a <a>Coercion</a> disabling sanity checks. The
--   problems that the sanity checks in substCo catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substCoUnchecked to substCo and remove this function. Please
--   don't use in new code.
substCoUnchecked :: Subst -> Coercion -> Coercion

-- | Coercion substitution, see <a>zipTvSubst</a>. Disables sanity checks.
--   The problems that the sanity checks in substCo catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substCoUnchecked to substCo and remove this function.
--   Please don't use in new code.
substCoWithUnchecked :: [TyVar] -> [Type] -> Coercion -> Coercion
substScaledTy :: HasDebugCallStack => Subst -> Scaled Type -> Scaled Type
substScaledTyUnchecked :: HasDebugCallStack => Subst -> Scaled Type -> Scaled Type
substScaledTys :: HasDebugCallStack => Subst -> [Scaled Type] -> [Scaled Type]
substScaledTysUnchecked :: Subst -> [Scaled Type] -> [Scaled Type]

-- | Substitute within a <a>ThetaType</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTheta :: HasDebugCallStack => Subst -> ThetaType -> ThetaType

-- | Substitute within a <a>ThetaType</a> disabling the sanity checks. The
--   problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substThetaUnchecked to substTheta and remove this
--   function. Please don't use in new code.
substThetaUnchecked :: Subst -> ThetaType -> ThetaType

-- | Substitute within a <a>Type</a> after adding the free variables of the
--   type to the in-scope set. This is useful for the case when the free
--   variables aren't already in the in-scope set or easily available. See
--   also Note [The substitution invariant].
substTyAddInScope :: HasDebugCallStack => Subst -> Type -> Type
substTyCoBndr :: Subst -> PiTyBinder -> (Subst, PiTyBinder)

-- | Substitute within a <a>Type</a> disabling the sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyUnchecked :: Subst -> Type -> Type
substTyVar :: Subst -> TyVar -> Type
substTyVarBndr :: HasDebugCallStack => Subst -> TyVar -> (Subst, TyVar)
substTyVarBndrs :: HasDebugCallStack => Subst -> [TyVar] -> (Subst, [TyVar])
substTyVarToTyVar :: HasDebugCallStack => Subst -> TyVar -> TyVar
substTyVars :: Subst -> [TyVar] -> [Type]

-- | Type substitution, see <a>zipTvSubst</a>
substTyWith :: HasDebugCallStack => [TyVar] -> [Type] -> Type -> Type

-- | Type substitution, see <a>zipTvSubst</a>. Disables sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyWithUnchecked :: [TyVar] -> [Type] -> Type -> Type

-- | Substitute within several <a>Type</a>s The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTys :: HasDebugCallStack => Subst -> [Type] -> [Type]

-- | Substitute within several <a>Type</a>s disabling the sanity checks.
--   The problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substTysUnchecked to substTys and remove this
--   function. Please don't use in new code.
substTysUnchecked :: Subst -> [Type] -> [Type]

-- | Type substitution, see <a>zipTvSubst</a>
substTysWith :: HasDebugCallStack => [TyVar] -> [Type] -> [Type] -> [Type]
substVarBndr :: HasDebugCallStack => Subst -> TyCoVar -> (Subst, TyCoVar)
substVarBndrs :: HasDebugCallStack => Subst -> [TyCoVar] -> (Subst, [TyCoVar])
unionSubst :: Subst -> Subst -> Subst

-- | Remove all substitutions that might have been built up while
--   preserving the in-scope set originally called zapSubstEnv
zapSubst :: Subst -> Subst
zipCoEnv :: HasDebugCallStack => [CoVar] -> [Coercion] -> CvSubstEnv
zipTCvSubst :: HasDebugCallStack => [TyCoVar] -> [Type] -> Subst

-- | Generates the in-scope set for the <a>Subst</a> from the types in the
--   incoming environment. No CoVars or Ids, please!
zipTvSubst :: HasDebugCallStack => [TyVar] -> [Type] -> Subst

-- | The InScopeSet is just a thunk so with a bit of luck it'll never be
--   evaluated
zipTyEnv :: HasDebugCallStack => [TyVar] -> [Type] -> TvSubstEnv
tidyForAllTyBinder :: TidyEnv -> VarBndr TyCoVar vis -> (TidyEnv, VarBndr TyCoVar vis)
tidyForAllTyBinders :: TidyEnv -> [VarBndr TyCoVar vis] -> (TidyEnv, [VarBndr TyCoVar vis])

-- | Treat a new <a>TyCoVar</a> as a binder, and give it a fresh tidy name
--   using the environment if one has not already been allocated. See also
--   <a>tidyVarBndr</a> See Note [Tidying is idempotent]
tidyFreeTyCoVarX :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)

-- | Add the free <a>TyVar</a>s to the env in tidy form, so that we can
--   tidy the type they are free in Precondition: input free vars are
--   closed over kinds and This function does a scopedSort, so that tidied
--   variables have tidied kinds. See Note [Tidying is idempotent]
tidyFreeTyCoVars :: TidyEnv -> [TyCoVar] -> TidyEnv
tidyFreeTyCoVarsX :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])
tidyOpenType :: TidyEnv -> Type -> Type
tidyOpenTypeX :: TidyEnv -> Type -> (TidyEnv, Type)
tidyOpenTypes :: TidyEnv -> [Type] -> [Type]

-- | Grabs the free type variables, tidies them and then uses
--   <a>tidyType</a> to work over the type itself
tidyOpenTypesX :: TidyEnv -> [Type] -> (TidyEnv, [Type])

-- | Calls <a>tidyType</a> on a top-level type (i.e. with an empty tidying
--   environment)
tidyTopType :: Type -> Type
tidyTyCoVarOcc :: TidyEnv -> TyCoVar -> TyCoVar

-- | Tidy a Type
--   
--   See Note [Strictness in tidyType and friends]
tidyType :: TidyEnv -> Type -> Type

-- | Tidy a list of Types
--   
--   See Note [Strictness in tidyType and friends]
tidyTypes :: TidyEnv -> [Type] -> [Type]
tidyVarBndr :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)

-- | This tidies up a type for printing in an error message, or in an
--   interface file.
--   
--   It doesn't change the uniques at all, just the print names.
tidyVarBndrs :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])

-- | (mkTyConTy tc) returns (TyConApp tc []) but arranges to share that
--   TyConApp among all calls See Note [Sharing nullary TyConApps] So it's
--   just an alias for tyConNullaryTy!
mkTyConTy :: TyCon -> Type
pattern ManyTy :: Mult
pattern OneTy :: Mult

-- | Given a <a>Type</a> and a list of argument types to which the
--   <a>Type</a> is applied, determine each argument's visibility
--   (<a>Inferred</a>, <a>Specified</a>, or <a>Required</a>).
--   
--   Most of the time, the arguments will be <a>Required</a>, but not
--   always. Consider <tt>f :: forall a. a -&gt; Type</tt>. In <tt>f Type
--   Bool</tt>, the first argument (<tt>Type</tt>) is <a>Specified</a> and
--   the second argument (<tt>Bool</tt>) is <a>Required</a>. It is
--   precisely this sort of higher-rank situation in which
--   <a>appTyForAllTyFlags</a> comes in handy, since <tt>f Type Bool</tt>
--   would be represented in Core using <a>AppTy</a>s. (See also #15792).
appTyForAllTyFlags :: Type -> [Type] -> [ForAllTyFlag]
applyTysX :: HasDebugCallStack => [TyVar] -> Type -> [Type] -> Type
buildSynTyCon :: Name -> [KnotTied TyConBinder] -> Kind -> [Role] -> KnotTied Type -> TyCon

-- | See GHC.Types.Var Note [FunTyFlag]
chooseFunTyFlag :: HasDebugCallStack => Type -> Type -> FunTyFlag

-- | Get the type on the LHS of a coercion induced by a type/data family
--   instance.
coAxNthLHS :: forall (br :: BranchFlag). CoAxiom br -> Int -> Type

-- | Iterates <a>coreView</a> until there is no more to synonym to expand.
--   NB: coreFullView is non-recursive and can be inlined; core_full_view
--   is the recursive one See Note [Inlining coreView].
coreFullView :: Type -> Type

-- | This function strips off the <i>top layer only</i> of a type synonym
--   application (if any) its underlying representation type. Returns
--   <a>Nothing</a> if there is nothing to look through.
--   
--   This function does not look through type family applications.
--   
--   By being non-recursive and inlined, this case analysis gets
--   efficiently joined onto the case analysis that the caller is already
--   doing
coreView :: Type -> Maybe Type
deepUserTypeError_maybe :: Type -> Maybe ErrorMsgType
definitelyLiftedType :: Type -> Bool
definitelyUnliftedType :: Type -> Bool

-- | Drops all ForAllTys
dropForAlls :: Type -> Type

-- | Drops prefix of RuntimeRep constructors in <a>TyConApp</a>s. Useful
--   for e.g. dropping 'LiftedRep arguments of unboxed tuple TyCon
--   applications:
--   
--   dropRuntimeRepArgs [ 'LiftedRep, 'IntRep , String, Int# ] == [String,
--   Int#]
dropRuntimeRepArgs :: [Type] -> [Type]

-- | <tt>expandSynTyConApp_maybe tc tys</tt> expands the RHS of type
--   synonym <tt>tc</tt> instantiated at arguments <tt>tys</tt>, or returns
--   <a>Nothing</a> if <tt>tc</tt> is not a synonym.
expandSynTyConApp_maybe :: TyCon -> [Type] -> Maybe Type

-- | Expand out all type synonyms. Actually, it'd suffice to expand out
--   just the ones that discard type variables (e.g. type Funny a = Int)
--   But we don't know which those are currently, so we just expand all.
--   
--   <a>expandTypeSynonyms</a> only expands out type synonyms mentioned in
--   the type, not in the kinds of any TyCon or TyVar mentioned in the
--   type.
--   
--   Keep this synchronized with <tt>synonymTyConsOfType</tt>
expandTypeSynonyms :: Type -> Type

-- | Given a <a>TyCon</a> and a list of argument types, filter out any
--   <a>Inferred</a> arguments.
filterOutInferredTypes :: TyCon -> [Type] -> [Type]

-- | Given a <a>TyCon</a> and a list of argument types, filter out any
--   invisible (i.e., <a>Inferred</a> or <a>Specified</a>) arguments.
filterOutInvisibleTypes :: TyCon -> [Type] -> [Type]

-- | Extract the function argument type and panic if that is not possible
--   
--   Just like <a>piResultTys</a> but for a single argument Try not to
--   iterate <a>piResultTy</a>, because it's inefficient to substitute one
--   variable at a time; instead use 'piResultTys"
funArgTy :: HasDebugCallStack => Type -> Type

-- | Extract the function result type and panic if that is not possible
funResultTy :: HasDebugCallStack => Type -> Type

-- | Given the components of a FunTy figure out the corresponding TyConApp.
funTyConAppTy_maybe :: FunTyFlag -> Type -> Type -> Type -> Maybe (TyCon, [Type])

-- | If the type is a tyvar, possibly under a cast, returns it, along with
--   the coercion. Thus, the co is :: kind tv ~N kind ty
getCastedTyVar_maybe :: Type -> Maybe (TyVar, CoercionN)

-- | Extract the <a>Levity</a> of a type. For example, <tt>getLevity Int =
--   Lifted</tt>, or <tt>getLevity (Array# Int) = Unlifted</tt>.
--   
--   Panics if this is not possible. Does not look through type family
--   applications.
getLevity :: HasDebugCallStack => Type -> Type

-- | Extracts a list of run-time arguments from a function type, looking
--   through newtypes to the right of arrows.
--   
--   Examples:
--   
--   <pre>
--   newtype Identity a = I a
--   
--   getRuntimeArgTys (Int -&gt; Bool -&gt; Double) == [(Int, FTF_T_T), (Bool, FTF_T_T)]
--   getRuntimeArgTys (Identity Int -&gt; Bool -&gt; Double) == [(Identity Int, FTF_T_T), (Bool, FTF_T_T)]
--   getRuntimeArgTys (Int -&gt; Identity (Bool -&gt; Identity Double)) == [(Int, FTF_T_T), (Bool, FTF_T_T)]
--   getRuntimeArgTys (forall a. Show a =&gt; Identity a -&gt; a -&gt; Int -&gt; Bool)
--            == [(Show a, FTF_C_T), (Identity a, FTF_T_T),(a, FTF_T_T),(Int, FTF_T_T)]
--   </pre>
--   
--   Note that, in the last case, the returned types might mention an
--   out-of-scope type variable. This function is used only when we really
--   care about the <i>kinds</i> of the returned types, so this is OK.
--   
--   <ul>
--   <li>*Warning**: this function can return an infinite list. For
--   example:</li>
--   </ul>
--   
--   <pre>
--   newtype N a = MkN (a -&gt; N a)
--   getRuntimeArgTys (N a) == repeat (a, FTF_T_T)
--   </pre>
getRuntimeArgTys :: Type -> [(Scaled Type, FunTyFlag)]

-- | Extract the RuntimeRep classifier of a type. For instance,
--   <tt>getRuntimeRep_maybe Int = LiftedRep</tt>. Panics if this is not
--   possible.
getRuntimeRep :: HasDebugCallStack => Type -> RuntimeRepType

-- | Attempts to obtain the type variable underlying a <a>Type</a>, and
--   panics with the given message if this is not a type variable type. See
--   also <a>getTyVar_maybe</a>
getTyVar :: HasDebugCallStack => Type -> TyVar

-- | Attempts to obtain the type variable underlying a <a>Type</a>
getTyVar_maybe :: Type -> Maybe TyVar
invisibleTyBndrCount :: Type -> Int
irrelevantMult :: Scaled a -> a

-- | See <a>Type#type_classification</a> for what an algebraic type is.
--   Should only be applied to <i>types</i>, as opposed to e.g. partially
--   saturated type constructors
isAlgType :: Type -> Bool
isAtomicTy :: Type -> Bool

-- | See <a>isBoxedRuntimeRep_maybe</a>.
isBoxedRuntimeRep :: RuntimeRepType -> Bool

-- | See <a>Type#type_classification</a> for what a boxed type is. Panics
--   on representation-polymorphic types; See <a>mightBeUnliftedType</a>
--   for a more approximate predicate that behaves better in the presence
--   of representation polymorphism.
isBoxedType :: Type -> Bool

-- | Is this a char literal? We also look through type synonyms.
isCharLitTy :: Type -> Maybe Char
isCoercionTy :: Type -> Bool
isCoercionTy_maybe :: Type -> Maybe Coercion

-- | Tests whether the given type is concrete, i.e. it whether it consists
--   only of concrete type constructors, concrete type variables, and
--   applications.
--   
--   See Note [Concrete types] in GHC.Tc.Utils.Concrete.
isConcreteType :: Type -> Bool
isConstraintKind :: Kind -> Bool
isConstraintLikeKind :: Kind -> Bool

-- | Check whether a type is a data family type
isDataFamilyAppType :: Type -> Bool
isFamFreeTy :: Type -> Bool

-- | Checks that a kind of the form <a>Type</a>, <tt>Constraint</tt> or
--   <tt>'TYPE r</tt> is concrete. See <a>isConcreteType</a>.
--   
--   <b>Precondition:</b> The type has kind `TYPE blah` or `CONSTRAINT
--   blah`
isFixedRuntimeRepKind :: HasDebugCallStack => Kind -> Bool

-- | Checks whether this is a proper forall (with a named binder)
isForAllTy :: Type -> Bool

-- | Like <a>isForAllTy</a>, but returns True only if it is a covar binder
isForAllTy_co :: Type -> Bool

-- | Like <a>isForAllTy</a>, but returns True only if it is an inferred
--   tyvar binder
isForAllTy_invis_ty :: Type -> Bool

-- | Like <a>isForAllTy</a>, but returns True only if it is a tyvar binder
isForAllTy_ty :: Type -> Bool

-- | Is this a function? Note: `forall {b}. Show b =&gt; b -&gt; IO b` will
--   not be considered a function by this function. It would merely be a
--   forall wrapping a function type.
isFunTy :: Type -> Bool

-- | Is this the type <a>Levity</a>?
isLevityTy :: Type -> Bool

-- | Is a tyvar of type <a>Levity</a>?
isLevityVar :: TyVar -> Bool
isLiftedLevity :: Type -> Bool

-- | Check whether a type of kind <a>RuntimeRep</a> is lifted.
--   
--   <a>isLiftedRuntimeRep</a> is:
--   
--   <ul>
--   <li>True of <tt>LiftedRep :: RuntimeRep</tt></li>
--   <li>False of type variables, type family applications, and of other
--   reps such as <tt>IntRep :: RuntimeRep</tt>.</li>
--   </ul>
isLiftedRuntimeRep :: RuntimeRepType -> Bool

-- | Returns True if the argument is (lifted) Type or Constraint See Note
--   [TYPE and CONSTRAINT] in GHC.Builtin.Types.Prim
isLiftedTypeKind :: Kind -> Bool

-- | <tt>isLinear t</tt> returns <tt>True</tt> of a if <tt>t</tt> is a type
--   of (curried) function where at least one argument is linear (or
--   otherwise non-unrestricted). We use this function to check whether it
--   is safe to eta reduce an Id in CorePrep. It is always safe to return
--   <a>True</a>, because <a>True</a> deactivates the optimisation.
isLinearType :: Type -> Bool

-- | Is this a type literal (symbol, numeric, or char)?
isLitTy :: Type -> Maybe TyLit
isManyTy :: Mult -> Bool

-- | Is this the type <tt>Multiplicity</tt>?
isMultiplicityTy :: Type -> Bool

-- | Is a tyvar of type <tt>Multiplicity</tt>?
isMultiplicityVar :: TyVar -> Bool

-- | Is this a numeric literal. We also look through type synonyms.
isNumLitTy :: Type -> Maybe Integer
isOneTy :: Mult -> Bool

-- | Is this a function or forall?
isPiTy :: Type -> Bool
isPredTy :: HasDebugCallStack => Type -> Bool

-- | Returns true of types that are opaque to Haskell.
isPrimitiveType :: Type -> Bool

-- | Is this a type of kind RuntimeRep? (e.g. LiftedRep)
isRuntimeRepKindedTy :: Type -> Bool

-- | Is this the type <a>RuntimeRep</a>?
isRuntimeRepTy :: Type -> Bool

-- | Is a tyvar of type <a>RuntimeRep</a>?
isRuntimeRepVar :: TyVar -> Bool

-- | Is this a symbol literal. We also look through type synonyms.
isStrLitTy :: Type -> Maybe FastString

-- | Computes whether an argument (or let right hand side) should be
--   computed strictly or lazily, based only on its type. Currently, it's
--   just <a>isUnliftedType</a>. Panics on representation-polymorphic
--   types.
isStrictType :: HasDebugCallStack => Type -> Bool

-- | Does this classify a type allowed to have values? Responds True to
--   things like *, TYPE Lifted, TYPE IntRep, TYPE v, Constraint.
--   
--   True of a kind `TYPE _` or `CONSTRAINT _`
isTYPEorCONSTRAINT :: Kind -> Bool
isTauTy :: Type -> Bool

-- | True <a>=</a> a term of this type cannot be bottom This identifies the
--   types described by Note [NON-BOTTOM-DICTS invariant] in GHC.Core NB:
--   unlifted types are not terminating types! e.g. you can write a term
--   (loop 1)::Int# that diverges.
isTerminatingType :: HasDebugCallStack => Type -> Bool
isTyVarTy :: Type -> Bool

-- | Is this kind equivalent to <tt>TYPE r</tt> (for some unknown r)?
--   
--   This considers <tt>Constraint</tt> to be distinct from <tt>*</tt>.
isTypeLikeKind :: Kind -> Bool
isUnboxedSumType :: Type -> Bool
isUnboxedTupleType :: Type -> Bool
isUnliftedLevity :: Type -> Bool

-- | Check whether a type of kind <a>RuntimeRep</a> is unlifted.
--   
--   <ul>
--   <li>True of definitely unlifted <a>RuntimeRep</a>s such as
--   <tt>UnliftedRep</tt>, <a>IntRep</a>, <a>FloatRep</a>, ...</li>
--   <li>False of <tt>LiftedRep</tt>,</li>
--   <li>False for type variables and type family applications.</li>
--   </ul>
isUnliftedRuntimeRep :: RuntimeRepType -> Bool

-- | Is the given type definitely unlifted? See
--   <a>Type#type_classification</a> for what an unlifted type is.
--   
--   Panics on representation-polymorphic types; See
--   <a>mightBeUnliftedType</a> for a more approximate predicate that
--   behaves better in the presence of representation polymorphism.
isUnliftedType :: HasDebugCallStack => Type -> Bool

-- | Returns True if the kind classifies unlifted types (like 'Int#') and
--   False otherwise. Note that this returns False for
--   representation-polymorphic kinds, which may be specialized to a kind
--   that classifies unlifted types.
isUnliftedTypeKind :: Kind -> Bool

-- | Determine whether a type could be the type of a join point of given
--   total arity, according to the polymorphism rule. A join point cannot
--   be polymorphic in its return type, since given join j <tt>a </tt>b x y
--   z = e1 in e2, the types of e1 and e2 must be the same, and a and b are
--   not in scope for e2. (See Note [The polymorphism rule of join points]
--   in <a>GHC.Core</a>.) Returns False also if the type simply doesn't
--   have enough arguments.
--   
--   Note that we need to know how many arguments (type *and* value) the
--   putative join point takes; for instance, if j :: forall a. a -&gt; Int
--   then j could be a binary join point returning an Int, but it could
--   *not* be a unary join point returning a -&gt; Int.
--   
--   TODO: See Note [Excess polymorphism and join points]
isValidJoinPointType :: JoinArity -> Type -> Bool

-- | Check whether a kind is of the form `TYPE (BoxedRep Lifted)` or `TYPE
--   (BoxedRep Unlifted)`.
--   
--   Returns:
--   
--   <ul>
--   <li>`Just Lifted` for `TYPE (BoxedRep Lifted)` and <a>Type</a>,</li>
--   <li>`Just Unlifted` for `TYPE (BoxedRep Unlifted)` and
--   <tt>UnliftedType</tt>,</li>
--   <li><a>Nothing</a> for anything else, e.g. `TYPE IntRep`, `TYPE
--   (BoxedRep l)`, etc.</li>
--   </ul>
kindBoxedRepLevity_maybe :: Type -> Maybe Levity

-- | Extract the RuntimeRep classifier of a type from its kind. For
--   example, <tt>kindRep * = LiftedRep</tt>; Panics if this is not
--   possible. Treats * and Constraint as the same
kindRep :: HasDebugCallStack => Kind -> RuntimeRepType

-- | Given a kind (TYPE rr) or (CONSTRAINT rr), extract its RuntimeRep
--   classifier rr. For example, <tt>kindRep_maybe * = Just LiftedRep</tt>
--   Returns <a>Nothing</a> if the kind is not of form (TYPE rr)
kindRep_maybe :: HasDebugCallStack => Kind -> Maybe RuntimeRepType

-- | <a>levityType_maybe</a> takes a Type of kind Levity, and returns its
--   levity May not be possible for a type variable or type family
--   application
levityType_maybe :: LevityType -> Maybe Levity

-- | Scale a payload by One
linear :: a -> Scaled a
mapTyCo :: Monad m => TyCoMapper () m -> (Type -> m Type, [Type] -> m [Type], Coercion -> m Coercion, [Coercion] -> m [Coercion])
mapTyCoX :: Monad m => TyCoMapper env m -> (env -> Type -> m Type, env -> [Type] -> m [Type], env -> Coercion -> m Coercion, env -> [Coercion] -> m [Coercion])

-- | Returns:
--   
--   <ul>
--   <li><a>False</a> if the type is <i>guaranteed</i> unlifted or</li>
--   <li><a>True</a> if it lifted, OR we aren't sure (e.g. in a
--   representation-polymorphic case)</li>
--   </ul>
mightBeLiftedType :: Type -> Bool

-- | Returns:
--   
--   <ul>
--   <li><a>False</a> if the type is <i>guaranteed</i> lifted or</li>
--   <li><a>True</a> if it is unlifted, OR we aren't sure (e.g. in a
--   representation-polymorphic case)</li>
--   </ul>
mightBeUnliftedType :: Type -> Bool

-- | Applies a type to another, as in e.g. <tt>k a</tt>
mkAppTy :: Type -> Type -> Type
mkAppTys :: Type -> [Type] -> Type

-- | Given a <a>Levity</a>, apply <a>BoxedRep</a> to it On the fly, rewrite
--   BoxedRep Lifted --&gt; liftedRepTy (a synonym) BoxedRep Unlifted
--   --&gt; unliftedRepTy (ditto) See Note [TYPE and CONSTRAINT] in
--   GHC.Builtin.Types.Prim. See Note [Using synonyms to compress types] in
--   GHC.Core.Type
mkBoxedRepApp_maybe :: LevityType -> Maybe Type

-- | Just like mkTYPEapp
mkCONSTRAINTapp :: RuntimeRepType -> Type

-- | Just like mkTYPEapp_maybe
mkCONSTRAINTapp_maybe :: RuntimeRepType -> Maybe Type

-- | Make a <a>CastTy</a>. The Coercion must be nominal. Checks the
--   Coercion for reflexivity, dropping it if it's reflexive. See <tt>Note
--   [Respecting definitional equality]</tt> in <a>GHC.Core.TyCo.Rep</a>
mkCastTy :: Type -> Coercion -> Type
mkCharLitTy :: Char -> Type
mkCoercionTy :: Coercion -> Type

-- | Given a family instance TyCon and its arg types, return the
--   corresponding family type. E.g:
--   
--   <pre>
--   data family T a
--   data instance T (Maybe b) = MkT b
--   </pre>
--   
--   Where the instance tycon is :RTL, so:
--   
--   <pre>
--   mkFamilyTyConApp :RTL Int  =  T (Maybe Int)
--   </pre>
mkFamilyTyConApp :: TyCon -> [Type] -> Type

-- | This one works out the FunTyFlag from the argument type See
--   GHC.Types.Var Note [FunTyFlag]
mkFunctionType :: HasDebugCallStack => Mult -> Type -> Type -> Type

-- | Like <a>mkTyCoInvForAllTy</a>, but tv should be a tyvar
mkInfForAllTy :: TyVar -> Type -> Type

-- | Like <a>mkTyCoInvForAllTys</a>, but tvs should be a list of tyvar
mkInfForAllTys :: [TyVar] -> Type -> Type
mkNumLitTy :: Integer -> Type
mkScaled :: Mult -> a -> Scaled a

-- | Like mkFunctionType, compute the FunTyFlag from the arguments
mkScaledFunctionTys :: [Scaled Type] -> Type -> Type

-- | Like <a>mkForAllTy</a>, but assumes the variable is dependent and
--   <a>Specified</a>, a common case
mkSpecForAllTy :: TyVar -> Type -> Type

-- | Like <a>mkForAllTys</a>, but assumes all variables are dependent and
--   <a>Specified</a>, a common case
mkSpecForAllTys :: [TyVar] -> Type -> Type
mkStrLitTy :: FastString -> Type
mkTYPEapp :: RuntimeRepType -> Type

-- | Given a <tt>RuntimeRep</tt>, applies <tt>TYPE</tt> to it. On the fly
--   it rewrites TYPE LiftedRep --&gt; liftedTypeKind (a synonym) TYPE
--   UnliftedRep --&gt; unliftedTypeKind (ditto) TYPE ZeroBitRep --&gt;
--   zeroBitTypeKind (ditto) NB: no need to check for TYPE (BoxedRep
--   Lifted), TYPE (BoxedRep Unlifted) because those inner types should
--   already have been rewritten to LiftedRep and UnliftedRep respectively,
--   by mkTyConApp
--   
--   see Note [TYPE and CONSTRAINT] in GHC.Builtin.Types.Prim. See Note
--   [Using synonyms to compress types] in GHC.Core.Type
mkTYPEapp_maybe :: RuntimeRepType -> Maybe Type

-- | Given a `[RuntimeRep]`, apply <tt>TupleRep</tt> to it On the fly,
--   rewrite TupleRep [] -&gt; zeroBitRepTy (a synonym) See Note [TYPE and
--   CONSTRAINT] in GHC.Builtin.Types.Prim. See Note [Using synonyms to
--   compress types] in GHC.Core.Type
mkTupleRepApp_maybe :: Type -> Maybe Type

-- | Make a dependent forall over a TyCoVar
mkTyCoForAllTy :: TyCoVar -> ForAllTyFlag -> Type -> Type

-- | Make a dependent forall over a TyCoVar
mkTyCoForAllTys :: [ForAllTyBinder] -> Type -> Type

-- | Make a dependent forall over an <a>Inferred</a> variable
mkTyCoInvForAllTy :: TyCoVar -> Type -> Type

-- | Like <a>mkForAllTys</a>, but assumes all variables are dependent and
--   <a>Inferred</a>, a common case
mkTyCoInvForAllTys :: [TyCoVar] -> Type -> Type

-- | A key function: builds a <a>TyConApp</a> or <a>FunTy</a> as
--   appropriate to its arguments. Applies its arguments to the constructor
--   from left to right.
mkTyConApp :: TyCon -> [Type] -> Type

-- | Given a list of type-level vars and the free vars of a result kind,
--   makes PiTyBinders, preferring anonymous binders if the variable is, in
--   fact, not dependent. e.g. mkTyConBindersPreferAnon
--   <a>(k:*),(b:k),(c:k)</a> We want (k:*) Named, (b:k) Anon, (c:k) Anon
--   
--   All non-coercion binders are <i>visible</i>.
mkTyConBindersPreferAnon :: [TyVar] -> TyCoVarSet -> [TyConBinder]

-- | Like mkForAllTys, but assumes all variables are dependent and visible
mkVisForAllTys :: [TyVar] -> Type -> Type

-- | Unwrap one <tt>layer</tt> of newtype on a type constructor and its
--   arguments, using an eta-reduced version of the <tt>newtype</tt> if
--   possible. This requires tys to have at least <tt>newTyConInstArity
--   tycon</tt> elements.
newTyConInstRhs :: TyCon -> [Type] -> Type

-- | Given a <a>TyCon</a> and a list of argument types, partition the
--   arguments into:
--   
--   <ol>
--   <li><a>Inferred</a> or <a>Specified</a> (i.e., invisible) arguments
--   and</li>
--   <li><a>Required</a> (i.e., visible) arguments</li>
--   </ol>
partitionInvisibleTypes :: TyCon -> [Type] -> ([Type], [Type])

-- | Given a list of things paired with their visibilities, partition the
--   things into (invisible things, visible things).
partitionInvisibles :: [(a, ForAllTyFlag)] -> ([a], [a])
piResultTy :: HasDebugCallStack => Type -> Type -> Type

-- | (piResultTys f_ty [ty1, .., tyn]) gives the type of (f ty1 .. tyn)
--   where f :: f_ty <a>piResultTys</a> is interesting because: 1.
--   <tt>f_ty</tt> may have more for-alls than there are args 2. Less
--   obviously, it may have fewer for-alls For case 2. think of:
--   piResultTys (forall a.a) [forall b.b, Int] This really can happen, but
--   only (I think) in situations involving undefined. For example:
--   undefined :: forall a. a Term: undefined <tt>(forall b. b-&gt;b)
--   </tt>Int This term should have type (Int -&gt; Int), but notice that
--   there are more type args than foralls in <a>undefined</a>s type.
piResultTys :: HasDebugCallStack => Type -> [Type] -> Type
pickyIsLiftedTypeKind :: Kind -> Bool

-- | Render a type corresponding to a user type error into a SDoc.
pprUserTypeErrorTy :: ErrorMsgType -> SDoc

-- | Attempts to obtain the type variable underlying a <a>Type</a>, without
--   any expansion
repGetTyVar_maybe :: Type -> Maybe TyVar
returnsConstraintKind :: Kind -> Bool
rewriterView :: Type -> Maybe Type

-- | Check whether a type (usually of kind <a>RuntimeRep</a>) is lifted,
--   unlifted, or unknown. Returns Nothing if the type isn't of kind
--   <a>RuntimeRep</a>.
--   
--   `runtimeRepLevity_maybe rr` returns:
--   
--   <ul>
--   <li>`Just Lifted` if <tt>rr</tt> is `LiftedRep :: RuntimeRep`</li>
--   <li>`Just Unlifted` if <tt>rr</tt> is definitely unlifted, e.g.
--   <a>IntRep</a></li>
--   <li><a>Nothing</a> if not known (e.g. it's a type variable or a type
--   family application).</li>
--   </ul>
runtimeRepLevity_maybe :: RuntimeRepType -> Maybe Levity
sORTKind_maybe :: Kind -> Maybe (TypeOrConstraint, Type)
scaledSet :: Scaled a -> b -> Scaled b
seqType :: Type -> ()
seqTypes :: [Type] -> ()

-- | Attempts to take a type application apart, as in
--   <a>splitAppTy_maybe</a>, and panics if this is not possible
splitAppTy :: Type -> (Type, Type)

-- | Does the AppTy split as in <a>splitAppTy_maybe</a>, but assumes that
--   any coreView stuff is already done
splitAppTyNoView_maybe :: HasDebugCallStack => Type -> Maybe (Type, Type)

-- | Attempt to take a type application apart, whether it is a function,
--   type constructor, or plain type application. Note that type family
--   applications are NEVER unsaturated by this!
splitAppTy_maybe :: Type -> Maybe (Type, Type)

-- | Recursively splits a type as far as is possible, leaving a residual
--   type being applied to and the type arguments applied to it. Never
--   fails, even if that means returning an empty list of type
--   applications.
splitAppTys :: HasDebugCallStack => Type -> (Type, [Type])

-- | Like <a>splitAppTys</a>, but doesn't look through type synonyms
splitAppTysNoView :: HasDebugCallStack => Type -> (Type, [Type])
splitCastTy_maybe :: Type -> Maybe (Type, Coercion)

-- | Like <a>splitForAllTyCoVar_maybe</a>, but only returns Just if it is a
--   covar binder.
splitForAllCoVar_maybe :: Type -> Maybe (CoVar, Type)

-- | Attempts to take a ForAllTy apart, returning the full ForAllTyBinder
splitForAllForAllTyBinder_maybe :: Type -> Maybe (ForAllTyBinder, Type)

-- | Take a ForAllTy apart, returning the binders and result type
splitForAllForAllTyBinders :: Type -> ([ForAllTyBinder], Type)

-- | Like <a>splitForAllTyCoVars</a>, but only splits <a>ForAllTy</a>s with
--   <a>Invisible</a> type variable binders. Furthermore, each returned
--   tyvar is annotated with its <a>Specificity</a>.
splitForAllInvisTyBinders :: Type -> ([InvisTyBinder], Type)

-- | Like <a>splitForAllTyCoVars</a>, but only splits <a>ForAllTy</a>s with
--   <a>Required</a> type variable binders. Furthermore, each returned
--   tyvar is annotated with <tt>()</tt>.
splitForAllReqTyBinders :: Type -> ([ReqTyBinder], Type)

-- | Take a forall type apart, or panics if that is not possible.
splitForAllTyCoVar :: Type -> (TyCoVar, Type)

-- | Attempts to take a ForAllTy apart, returning the Var
splitForAllTyCoVar_maybe :: Type -> Maybe (TyCoVar, Type)

-- | Take a ForAllTy apart, returning the list of tycovars and the result
--   type. This always succeeds, even if it returns only an empty list.
--   Note that the result type returned may have free variables that were
--   bound by a forall.
splitForAllTyCoVars :: Type -> ([TyCoVar], Type)

-- | Attempts to take a ForAllTy apart, but only if the binder is a TyVar
splitForAllTyVar_maybe :: Type -> Maybe (TyVar, Type)

-- | Like <a>splitForAllTyCoVars</a>, but split only for tyvars. This
--   always succeeds, even if it returns only an empty list. Note that the
--   result type returned may have free variables that were bound by a
--   forall.
splitForAllTyVars :: Type -> ([TyVar], Type)

-- | Attempts to extract the multiplicity, argument and result types from a
--   type, and panics if that is not possible. See also
--   <a>splitFunTy_maybe</a>
splitFunTy :: Type -> (Mult, Type, Type)

-- | Attempts to extract the multiplicity, argument and result types from a
--   type
splitFunTy_maybe :: Type -> Maybe (FunTyFlag, Mult, Type, Type)
splitFunTys :: Type -> ([Scaled Type], Type)

-- | Like <a>splitPiTys</a>, but returns only *invisible* binders,
--   including constraints. Stops at the first visible binder.
splitInvisPiTys :: Type -> ([PiTyBinder], Type)

-- | Same as <a>splitInvisPiTys</a>, but stop when - you have found
--   <tt>n</tt> <a>PiTyBinder</a>s, - or you run out of invisible binders
splitInvisPiTysN :: Int -> Type -> ([PiTyBinder], Type)

-- | Takes a forall type apart, or panics
splitPiTy :: Type -> (PiTyBinder, Type)

-- | Attempts to take a forall type apart; works with proper foralls and
--   functions
splitPiTy_maybe :: Type -> Maybe (PiTyBinder, Type)

-- | Split off all PiTyBinders to a type, splitting both proper foralls and
--   functions
splitPiTys :: Type -> ([PiTyBinder], Type)

-- | (splitRuntimeRep_maybe rr) takes a Type rr :: RuntimeRep, and returns
--   the (TyCon,[Type]) for the RuntimeRep, if possible, where the TyCon is
--   one of the promoted DataCons of RuntimeRep. Remember: the unique on
--   TyCon that is a a promoted DataCon is the same as the unique on the
--   DataCon See Note [Promoted data constructors] in GHC.Core.TyCon May
--   not be possible if <tt>rr</tt> is a type variable or type family
--   application
splitRuntimeRep_maybe :: RuntimeRepType -> Maybe (TyCon, [Type])

-- | Attempts to tease a type apart into a type constructor and the
--   application of a number of arguments to that constructor. Panics if
--   that is not possible. See also <a>splitTyConApp_maybe</a>
splitTyConApp :: Type -> (TyCon, [Type])
splitTyConAppNoView_maybe :: HasDebugCallStack => Type -> Maybe (TyCon, [Type])

-- | Attempts to tease a type apart into a type constructor and the
--   application of a number of arguments to that constructor
splitTyConApp_maybe :: HasDebugCallStack => Type -> Maybe (TyCon, [Type])
stripCoercionTy :: Type -> Coercion

-- | Is this kind equivalent to <tt>TYPE (BoxedRep l)</tt> for some <tt>l
--   :: Levity</tt>?
tcIsBoxedTypeKind :: Kind -> Bool

-- | Is this kind equivalent to <a>Type</a> i.e. TYPE LiftedRep?
tcIsLiftedTypeKind :: Kind -> Bool

-- | Just like splitAppTyNoView_maybe, but does not split (c =&gt; t) See
--   Note [Decomposing fat arrow c=&gt;t]
tcSplitAppTyNoView_maybe :: Type -> Maybe (Type, Type)
tcSplitTyConApp :: Type -> (TyCon, [Type])

-- | tcSplitTyConApp_maybe splits a type constructor application into its
--   type constructor and applied types.
--   
--   Differs from splitTyConApp_maybe in that it does *not* split types
--   headed with (=&gt;), as that's not a TyCon in the type-checker.
--   
--   Note that this may fail (in funTyConAppTy_maybe) in the case of a
--   <a>FunTy</a> with an argument of unknown kind <a>FunTy</a> (e.g.
--   `FunTy (a :: k) Int`, since the kind of <tt>a</tt> isn't of the form
--   `TYPE rep`. This isn't usually a problem but may be temporarily the
--   case during canonicalization: see Note [Decomposing FunTy] in
--   GHC.Tc.Solver.Equality and Note [The Purely Kinded Type Invariant
--   (PKTI)] in GHC.Tc.Gen.HsType, Wrinkle around FunTy
--   
--   Consequently, you may need to zonk your type before using this
--   function.
tcSplitTyConApp_maybe :: HasDebugCallStack => Type -> Maybe (TyCon, [Type])
tyConAppArgs :: HasDebugCallStack => Type -> [Type]

-- | The same as <tt>snd . splitTyConApp</tt>
tyConAppArgs_maybe :: Type -> Maybe [Type]

-- | Return Just if this TyConAppCo should be represented as a FunCo
tyConAppFunCo_maybe :: HasDebugCallStack => Role -> TyCon -> [Coercion] -> Maybe Coercion

-- | Return Just if this TyConApp should be represented as a FunTy
tyConAppFunTy_maybe :: HasDebugCallStack => TyCon -> [Type] -> Maybe Type

-- | Does a <a>TyCon</a> (that is applied to some number of arguments) need
--   to be ascribed with an explicit kind signature to resolve ambiguity if
--   rendered as a source-syntax type? (See <tt>Note [When does a tycon
--   application need an explicit kind signature?]</tt> for a full
--   explanation of what this function checks for.)
tyConAppNeedsKindSig :: Bool -> TyCon -> Int -> Bool
tyConAppTyCon :: HasDebugCallStack => Type -> TyCon

-- | Retrieve the tycon heading this type, if there is one. Does <i>not</i>
--   look through synonyms.
tyConAppTyConPicky_maybe :: Type -> Maybe TyCon

-- | The same as <tt>fst . splitTyConApp</tt> We can short-cut the FunTy
--   case
tyConAppTyCon_maybe :: Type -> Maybe TyCon
tyConBindersPiTyBinders :: [TyConBinder] -> [PiTyBinder]

-- | Given a <a>TyCon</a> and a list of argument types to which the
--   <a>TyCon</a> is applied, determine each argument's visibility
--   (<a>Inferred</a>, <a>Specified</a>, or <a>Required</a>).
--   
--   Wrinkle: consider the following scenario:
--   
--   <pre>
--   T :: forall k. k -&gt; k
--   tyConForAllTyFlags T [forall m. m -&gt; m -&gt; m, S, R, Q]
--   </pre>
--   
--   After substituting, we get
--   
--   <pre>
--   T (forall m. m -&gt; m -&gt; m) :: (forall m. m -&gt; m -&gt; m) -&gt; forall n. n -&gt; n -&gt; n
--   </pre>
--   
--   Thus, the first argument is invisible, <tt>S</tt> is visible,
--   <tt>R</tt> is invisible again, and <tt>Q</tt> is visible.
tyConForAllTyFlags :: TyCon -> [Type] -> [ForAllTyFlag]
tyConIsTYPEorCONSTRAINT :: TyCon -> Bool

-- | Scale a payload by Many; used for type arguments in core
tymult :: a -> Scaled a

-- | Returns True if a type has a syntactically fixed runtime rep, as per
--   Note [Fixed RuntimeRep] in GHC.Tc.Utils.Concrete.
--   
--   This function is equivalent to `isFixedRuntimeRepKind . typeKind` but
--   much faster.
--   
--   <b>Precondition:</b> The type has kind <tt>(<tt>TYPE</tt> blah)</tt>
typeHasFixedRuntimeRep :: HasDebugCallStack => Type -> Bool
typeKind :: HasDebugCallStack => Type -> Kind
typeLevity :: HasDebugCallStack => Type -> Levity

-- | Tries to compute the <a>Levity</a> of the given type. Returns either a
--   definite <a>Levity</a>, or <a>Nothing</a> if we aren't sure (e.g. the
--   type is representation-polymorphic).
--   
--   Panics if the kind does not have the shape <tt>TYPE r</tt>.
typeLevity_maybe :: HasDebugCallStack => Type -> Maybe Levity
typeOrConstraintKind :: TypeOrConstraint -> RuntimeRepType -> Kind
typeTypeOrConstraint :: HasDebugCallStack => Type -> TypeOrConstraint

-- | Scale a payload by Many
unrestricted :: a -> Scaled a

-- | Is this type a custom user error? If so, give us the error message.
userTypeError_maybe :: Type -> Maybe ErrorMsgType

-- | Extract a relevant type, if there is one.
anonPiTyBinderType_maybe :: PiTyBinder -> Maybe Type
binderFlag :: VarBndr tv argf -> argf
binderFlags :: [VarBndr tv argf] -> [argf]
binderType :: VarBndr TyCoVar argf -> Type
binderVar :: VarBndr tv argf -> tv
binderVars :: [VarBndr tv argf] -> [tv]

-- | Does this binder bind a variable that is <i>not</i> erased? Returns
--   <a>True</a> for anonymous binders.
isAnonPiTyBinder :: PiTyBinder -> Bool

-- | Does this binder bind an invisible argument?
isInvisiblePiTyBinder :: PiTyBinder -> Bool
isNamedPiTyBinder :: PiTyBinder -> Bool

-- | Is this a type-level (i.e., computationally irrelevant, thus erasable)
--   variable? Satisfies <tt>isTyVar = not . isId</tt>.
isTyVar :: Var -> Bool

-- | Does this binder bind a visible argument?
isVisiblePiTyBinder :: PiTyBinder -> Bool

-- | Make a named binder
mkForAllTyBinder :: vis -> TyCoVar -> VarBndr TyCoVar vis

-- | Make many named binders
mkForAllTyBinders :: vis -> [TyCoVar] -> [VarBndr TyCoVar vis]

-- | Make a named binder <tt>var</tt> should be a type variable
mkTyVarBinder :: vis -> TyVar -> VarBndr TyVar vis

-- | Make many named binders Input vars should be type variables
mkTyVarBinders :: vis -> [TyVar] -> [VarBndr TyVar vis]
namedPiTyBinder_maybe :: PiTyBinder -> Maybe TyCoVar
piTyBinderType :: PiTyBinder -> Type
tyVarKind :: TyVar -> Kind
tyVarSpecToBinders :: [VarBndr a Specificity] -> [VarBndr a ForAllTyFlag]

-- | Does this <a>ForAllTyFlag</a> classify an argument that is not written
--   in Haskell?
isInvisibleForAllTyFlag :: ForAllTyFlag -> Bool

-- | Does this <a>ForAllTyFlag</a> classify an argument that is written in
--   Haskell?
isVisibleForAllTyFlag :: ForAllTyFlag -> Bool
type FRRType = Type

-- | The key type representing kinds in the compiler.
type Kind = Type

-- | The key representation of types within the compiler
type KindOrType = Type

-- | A type labeled <a>KnotTied</a> might have knot-tied tycons in it. See
--   Note [Type checking recursive type and class declarations] in
--   <a>GHC.Tc.TyCl</a>
type KnotTied (ty :: k) = ty

-- | Mult is a type alias for Type.
--   
--   Mult must contain Type because multiplicity variables are mere type
--   variables (of kind Multiplicity) in Haskell. So the simplest
--   implementation is to make Mult be Type.
--   
--   Multiplicities can be formed with: - One: GHC.Types.One (= oneDataCon)
--   - Many: GHC.Types.Many (= manyDataCon) - Multiplication:
--   GHC.Types.MultMul (= multMulTyCon)
--   
--   So that Mult feels a bit more structured, we provide pattern synonyms
--   and smart constructors for these.
type Mult = Type

-- | A type of the form <tt>p</tt> of constraint kind represents a value
--   whose type is the Haskell predicate <tt>p</tt>, where a predicate is
--   what occurs before the <tt>=&gt;</tt> in a Haskell type.
--   
--   We use <a>PredType</a> as documentation to mark those types that we
--   guarantee to have this kind.
--   
--   It can be expanded into its representation, but:
--   
--   <ul>
--   <li>The type checker must treat it as opaque</li>
--   <li>The rest of the compiler treats it as transparent</li>
--   </ul>
--   
--   Consider these examples:
--   
--   <pre>
--   f :: (Eq a) =&gt; a -&gt; Int
--   g :: (?x :: Int -&gt; Int) =&gt; a -&gt; Int
--   h :: (r\l) =&gt; {r} =&gt; {l::Int | r}
--   </pre>
--   
--   Here the <tt>Eq a</tt> and <tt>?x :: Int -&gt; Int</tt> and
--   <tt>rl</tt> are all called "predicates"
type PredType = Type

-- | Type synonym used for types of kind RuntimeRep.
type RuntimeRepType = Type

-- | A shorthand for data with an attached <a>Mult</a> element (the
--   multiplicity).
data Scaled a

-- | A collection of <a>PredType</a>s
type ThetaType = [PredType]
data TyCoFolder env a
TyCoFolder :: (Type -> Maybe Type) -> (env -> TyVar -> a) -> (env -> CoVar -> a) -> (env -> CoercionHole -> a) -> (env -> TyCoVar -> ForAllTyFlag -> env) -> TyCoFolder env a
[tcf_view] :: TyCoFolder env a -> Type -> Maybe Type
[tcf_tyvar] :: TyCoFolder env a -> env -> TyVar -> a
[tcf_covar] :: TyCoFolder env a -> env -> CoVar -> a

-- | What to do with coercion holes. See Note [Coercion holes] in
--   <a>GHC.Core.TyCo.Rep</a>.
[tcf_hole] :: TyCoFolder env a -> env -> CoercionHole -> a

-- | The returned env is used in the extended scope
[tcf_tycobinder] :: TyCoFolder env a -> env -> TyCoVar -> ForAllTyFlag -> env
data Type

-- | A substitution of <tt>Expr</tt>s for non-coercion <a>Id</a>s
type IdSubstEnv = IdEnv CoreExpr

-- | Type &amp; coercion &amp; id substitution
--   
--   The <a>Subst</a> data type defined in this module contains
--   substitution for tyvar, covar and id. However, operations on
--   IdSubstEnv (mapping from <a>Id</a> to <a>CoreExpr</a>) that require
--   the definition of the <a>Expr</a> data type are defined in
--   GHC.Core.Subst to avoid circular module dependency.
data Subst
Subst :: InScopeSet -> IdSubstEnv -> TvSubstEnv -> CvSubstEnv -> Subst

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type

-- | A type of kind <tt>ErrorMessage</tt> (from the <a>TypeError</a>
--   module).
type ErrorMsgType = Type

-- | This describes how a "map" operation over a type/coercion should
--   behave
data TyCoMapper env (m :: Type -> Type)
TyCoMapper :: (env -> TyVar -> m Type) -> (env -> CoVar -> m Coercion) -> (env -> CoercionHole -> m Coercion) -> (forall r. () => env -> TyCoVar -> ForAllTyFlag -> (env -> TyCoVar -> m r) -> m r) -> (TyCon -> m TyCon) -> TyCoMapper env (m :: Type -> Type)
[tcm_tyvar] :: TyCoMapper env (m :: Type -> Type) -> env -> TyVar -> m Type
[tcm_covar] :: TyCoMapper env (m :: Type -> Type) -> env -> CoVar -> m Coercion

-- | What to do with coercion holes. See Note [Coercion holes] in
--   <a>GHC.Core.TyCo.Rep</a>.
[tcm_hole] :: TyCoMapper env (m :: Type -> Type) -> env -> CoercionHole -> m Coercion

-- | The returned env is used in the extended scope
[tcm_tycobinder] :: TyCoMapper env (m :: Type -> Type) -> forall r. () => env -> TyCoVar -> ForAllTyFlag -> (env -> TyCoVar -> m r) -> m r

-- | This is used only for TcTyCons a) To zonk TcTyCons b) To turn TcTyCons
--   into TyCons. See Note [Type checking recursive type and class
--   declarations] in <a>GHC.Tc.TyCl</a>
[tcm_tycon] :: TyCoMapper env (m :: Type -> Type) -> TyCon -> m TyCon

-- | Variable Binder
--   
--   A <a>ForAllTyBinder</a> is the binder of a ForAllTy It's convenient to
--   define this synonym here rather its natural home in
--   <a>GHC.Core.TyCo.Rep</a>, because it's used in
--   GHC.Core.DataCon.hs-boot
--   
--   A <a>TyVarBinder</a> is a binder with only TyVar
type ForAllTyBinder = VarBndr TyCoVar ForAllTyFlag

-- | The non-dependent version of <a>ForAllTyFlag</a>. See Note [FunTyFlag]
--   Appears here partly so that it's together with its friends
--   ForAllTyFlag and ForallVisFlag, but also because it is used in
--   IfaceType, rather early in the compilation chain
data FunTyFlag
FTF_T_T :: FunTyFlag
FTF_T_C :: FunTyFlag
FTF_C_T :: FunTyFlag
FTF_C_C :: FunTyFlag

-- | A <a>PiTyBinder</a> represents an argument to a function. PiTyBinders
--   can be dependent (<a>Named</a>) or nondependent (<a>Anon</a>). They
--   may also be visible or not. See Note [PiTyBinders]
data PiTyBinder

-- | Type or Coercion Variable
type TyCoVar = Id

-- | Type or kind Variable
type TyVar = Var
type TyVarBinder = VarBndr TyVar ForAllTyFlag

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var

-- | ForAllTyFlag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, ForAllTyBinders, TyConBinders,
--   and visibility] in <a>GHC.Core.TyCo.Rep</a>
data ForAllTyFlag
Invisible :: !Specificity -> ForAllTyFlag
Required :: ForAllTyFlag
pattern Inferred :: ForAllTyFlag
pattern Specified :: ForAllTyFlag

-- | Whether an <a>Invisible</a> argument may appear in source Haskell.
data Specificity

-- | the argument may not appear in source Haskell, it is only inferred.
InferredSpec :: Specificity

-- | the argument may appear in source Haskell, but isn't required.
SpecifiedSpec :: Specificity

-- | Assuming that two types are the same, ignoring coercions, find a
--   nominal coercion between the types. This is useful when optimizing
--   transitivity over coercion applications, where splitting two AppCos
--   might yield different kinds. See Note [EtaAppCo] in
--   <a>GHC.Core.Coercion.Opt</a>.
buildCoercion :: HasDebugCallStack => Type -> Type -> CoercionN

-- | Creates a new coercion with both of its types casted by different
--   casts <tt>castCoercionKind g h1 h2</tt>, where <tt>g :: t1 ~r t2</tt>,
--   has type <tt>(t1 |&gt; h1) ~r (t2 |&gt; h2)</tt>. <tt>h1</tt> and
--   <tt>h2</tt> must be nominal. It calls <tt>coercionKindRole</tt>, so
--   it's quite inefficient (which <tt>I</tt> stands for) Use
--   <tt>castCoercionKind2</tt> instead if <tt>t1</tt>, <tt>t2</tt>, and
--   <tt>r</tt> are known beforehand.
castCoercionKind :: Coercion -> CoercionN -> CoercionN -> Coercion

-- | <tt>castCoercionKind1 g r t1 t2 h</tt> = <tt>coercionKind g r t1 t2 h
--   h</tt> That is, it's a specialised form of castCoercionKind, where the
--   two kind coercions are identical <tt>castCoercionKind1 g r t1 t2
--   h</tt>, where <tt>g :: t1 ~r t2</tt>, has type <tt>(t1 |&gt; h) ~r (t2
--   |&gt; h)</tt>. <tt>h</tt> must be nominal. See Note
--   [castCoercionKind1]
castCoercionKind1 :: Coercion -> Role -> Type -> Type -> CoercionN -> Coercion

-- | Creates a new coercion with both of its types casted by different
--   casts <tt>castCoercionKind2 g r t1 t2 h1 h2</tt>, where <tt>g :: t1 ~r
--   t2</tt>, has type <tt>(t1 |&gt; h1) ~r (t2 |&gt; h2)</tt>. <tt>h1</tt>
--   and <tt>h2</tt> must be nominal.
castCoercionKind2 :: Coercion -> Role -> Type -> Type -> CoercionN -> CoercionN -> Coercion
checkReflexiveMCo :: MCoercion -> MCoercion
coToMCo :: Coercion -> MCoercion
coVarKind :: CoVar -> Type
coVarLType :: HasDebugCallStack => CoVar -> Type
coVarName :: CoVar -> Name
coVarRType :: HasDebugCallStack => CoVar -> Type
coVarRole :: CoVar -> Role
coVarTypes :: HasDebugCallStack => CoVar -> Pair Type
coVarTypesRole :: HasDebugCallStack => CoVar -> (Type, Type, Role)

-- | If it is the case that
--   
--   <pre>
--   c :: (t1 ~ t2)
--   </pre>
--   
--   i.e. the kind of <tt>c</tt> relates <tt>t1</tt> and <tt>t2</tt>, then
--   <tt>coercionKind c = Pair t1 t2</tt>.
coercionKind :: HasDebugCallStack => Coercion -> Pair Type

-- | Get a coercion's kind and role.
coercionKindRole :: Coercion -> (Pair Type, Role)

-- | Apply <a>coercionKind</a> to multiple <a>Coercion</a>s
coercionKinds :: [Coercion] -> Pair [Type]
coercionLKind :: HasDebugCallStack => Coercion -> Type
coercionRKind :: HasDebugCallStack => Coercion -> Type

-- | Retrieve the role from a coercion.
coercionRole :: Coercion -> Role
coercionType :: Coercion -> Type

-- | Try one stepper and then try the next, if the first doesn't make
--   progress. So if it returns NS_Done, it means that both steppers are
--   satisfied
composeSteppers :: NormaliseStepper ev -> NormaliseStepper ev -> NormaliseStepper ev

-- | This breaks a <a>Coercion</a> with type <tt>T A B C ~ T D E F</tt>
--   into a list of <a>Coercion</a>s of kinds <tt>A ~ D</tt>, <tt>B ~
--   E</tt> and <tt>E ~ F</tt>. Hence:
--   
--   <pre>
--   decomposeCo 3 c [r1, r2, r3] = [nth r1 0 c, nth r2 1 c, nth r3 2 c]
--   </pre>
decomposeCo :: Arity -> Coercion -> Infinite Role -> [Coercion]
decomposeFunCo :: HasDebugCallStack => Coercion -> (CoercionN, Coercion, Coercion)
decomposePiCos :: HasDebugCallStack => CoercionN -> Pair Type -> [Type] -> ([CoercionN], CoercionN)

-- | Like <a>downgradeRole_maybe</a>, but panics if the change isn't a
--   downgrade. See Note [Role twiddling functions]
downgradeRole :: Role -> Role -> Coercion -> Coercion
emptyLiftingContext :: InScopeSet -> LiftingContext

-- | Syntactic equality of coercions
eqCoercion :: Coercion -> Coercion -> Bool

-- | Compare two <a>Coercion</a>s, with respect to an RnEnv2
eqCoercionX :: RnEnv2 -> Coercion -> Coercion -> Bool
etaExpandCoAxBranch :: CoAxBranch -> ([TyVar], [Type], Type)

-- | Extend a lifting context with a new mapping.
extendLiftingContext :: LiftingContext -> TyCoVar -> Coercion -> LiftingContext

-- | Extend a lifting context with a new mapping, and extend the in-scope
--   set
extendLiftingContextAndInScope :: LiftingContext -> TyCoVar -> Coercion -> LiftingContext

-- | Extend the substitution component of a lifting context with a new
--   binding for a coercion variable. Used during coercion optimisation.
extendLiftingContextCvSubst :: LiftingContext -> CoVar -> Coercion -> LiftingContext
funRole :: Role -> FunSel -> Role

-- | Extract a covar, if possible. This check is dirty. Be ashamed of
--   yourself. (It's dirty because it cares about the structure of a
--   coercion, which is morally reprehensible.)
getCoVar_maybe :: Coercion -> Maybe CoVar

-- | Extract the nth field of a FunCo
getNthFun :: FunSel -> a -> a -> a -> a

-- | Is there a hetero-kind coercion hole in this coercion?
hasCoercionHoleCo :: Coercion -> Bool

-- | Is there a hetero-kind coercion hole in this type? (That is, a
--   coercion hole with ch_hetero_kind=True.) See wrinkle (EIK2) of Note
--   [Equalities with incompatible kinds] in GHC.Tc.Solver.Equality
hasCoercionHoleTy :: Type -> Bool
hasThisCoercionHoleTy :: Type -> CoercionHole -> Bool

-- | If `instNewTyCon_maybe T ts = Just (rep_ty, co)` then `co :: T ts ~R#
--   rep_ty`
--   
--   Checks for a newtype, and for being saturated
instNewTyCon_maybe :: TyCon -> [Type] -> Maybe (Type, Coercion)

-- | Tests if this coercion is obviously a generalized reflexive coercion.
--   Guaranteed to work very quickly.
isGReflCo :: Coercion -> Bool

-- | Returns the type coerced if this coercion is a generalized reflexive
--   coercion. Guaranteed to work very quickly.
isGReflCo_maybe :: Coercion -> Maybe (Type, Role)

-- | Tests if this MCoercion is obviously generalized reflexive Guaranteed
--   to work very quickly.
isGReflMCo :: MCoercion -> Bool

-- | Is a var in the domain of a lifting context?
isMappedByLC :: TyCoVar -> LiftingContext -> Bool

-- | Tests if this coercion is obviously reflexive. Guaranteed to work very
--   quickly. Sometimes a coercion can be reflexive, but not obviously so.
--   c.f. <a>isReflexiveCo</a>
isReflCo :: Coercion -> Bool
isReflCoVar_maybe :: Var -> Maybe Coercion

-- | Returns the type coerced if this coercion is reflexive. Guaranteed to
--   work very quickly. Sometimes a coercion can be reflexive, but not
--   obviously so. c.f. <a>isReflexiveCo_maybe</a>
isReflCo_maybe :: Coercion -> Maybe (Type, Role)
isReflMCo :: MCoercion -> Bool

-- | Slowly checks if the coercion is reflexive. Don't call this in a loop,
--   as it walks over the entire coercion.
isReflexiveCo :: Coercion -> Bool

-- | Extracts the coerced type from a reflexive coercion. This potentially
--   walks over the entire coercion, so avoid doing this in a loop.
isReflexiveCo_maybe :: Coercion -> Maybe (Type, Role)

-- | Get the <a>InScopeSet</a> from a <a>LiftingContext</a>
lcInScopeSet :: LiftingContext -> InScopeSet

-- | Lookup a <a>CoVar</a> in the substitution in a <a>LiftingContext</a>
lcLookupCoVar :: LiftingContext -> CoVar -> Maybe Coercion
lcSubstLeft :: LiftingContext -> Subst
lcSubstRight :: LiftingContext -> Subst

-- | <tt>liftCoSubst role lc ty</tt> produces a coercion (at role
--   <tt>role</tt>) that coerces between <tt>lc_left(ty)</tt> and
--   <tt>lc_right(ty)</tt>, where <tt>lc_left</tt> is a substitution
--   mapping type variables to the left-hand types of the mapped coercions
--   in <tt>lc</tt>, and similar for <tt>lc_right</tt>.
liftCoSubst :: HasDebugCallStack => Role -> LiftingContext -> Type -> Coercion
liftCoSubstTyVar :: LiftingContext -> Role -> TyVar -> Maybe Coercion
liftCoSubstVarBndrUsing :: (r -> CoercionN) -> (LiftingContext -> Type -> r) -> LiftingContext -> TyCoVar -> (LiftingContext, TyCoVar, r)
liftCoSubstWith :: Role -> [TyCoVar] -> [Coercion] -> Type -> Coercion
liftCoSubstWithEx :: Role -> [TyVar] -> [Coercion] -> [TyCoVar] -> [Type] -> (Type -> Coercion, [Type])
liftEnvSubstLeft :: Subst -> LiftCoEnv -> Subst
liftEnvSubstRight :: Subst -> LiftCoEnv -> Subst
liftingContextSubst :: LiftingContext -> Subst
ltRole :: Role -> Role -> Bool

-- | Apply a <a>Coercion</a> to another <a>Coercion</a>. The second
--   coercion must be Nominal, unless the first is Phantom. If the first is
--   Phantom, then the second can be either Phantom or Nominal.
mkAppCo :: Coercion -> Coercion -> Coercion

-- | Applies multiple <a>Coercion</a>s to another <a>Coercion</a>, from
--   left to right. See also <a>mkAppCo</a>.
mkAppCos :: Coercion -> [Coercion] -> Coercion
mkAxInstCo :: Role -> CoAxiomRule -> [Type] -> [Coercion] -> Coercion

-- | Return the left-hand type of the axiom, when the axiom is instantiated
--   at the types given.
mkAxInstLHS :: forall (br :: BranchFlag). CoAxiom br -> BranchIndex -> [Type] -> [Coercion] -> Type
mkAxInstRHS :: forall (br :: BranchFlag). CoAxiom br -> BranchIndex -> [Type] -> [Coercion] -> Type
mkAxiomCo :: CoAxiomRule -> [Coercion] -> Coercion

-- | Cast a type by an <a>MCoercion</a>
mkCastTyMCo :: Type -> MCoercion -> Type
mkCoCast :: Coercion -> CoercionR -> Coercion
mkCoVarCo :: CoVar -> Coercion
mkCoVarCos :: [CoVar] -> [Coercion]

-- | Makes a coercion type from two types: the types whose equality is
--   proven by the relevant <a>Coercion</a>
mkCoercionType :: Role -> Type -> Type -> Type

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, <tt>co2:: ty ~r
--   ty'</tt>, produces @co' :: (ty |&gt; co) ~r ty' It is not only a
--   utility function, but it saves allocation when co is a GRefl coercion.
mkCoherenceLeftCo :: Role -> Type -> CoercionN -> Coercion -> Coercion

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, <tt>co2:: ty' ~r
--   ty</tt>, produces @co' :: ty' ~r (ty |&gt; co) It is not only a
--   utility function, but it saves allocation when co is a GRefl coercion.
mkCoherenceRightCo :: HasDebugCallStack => Role -> Type -> CoercionN -> Coercion -> Coercion

-- | Like <a>mkCoherenceRightCo</a>, but with an <a>MCoercion</a>
mkCoherenceRightMCo :: Role -> Type -> MCoercionN -> Coercion -> Coercion

-- | Make a Coercion from a tycovar, a kind coercion, and a body coercion.
mkForAllCo :: HasDebugCallStack => TyCoVar -> ForAllTyFlag -> ForAllTyFlag -> CoercionN -> Coercion -> Coercion

-- | Build a function <a>Coercion</a> from two other <a>Coercion</a>s. That
--   is, given <tt>co1 :: a ~ b</tt> and <tt>co2 :: x ~ y</tt> produce
--   <tt>co :: (a -&gt; x) ~ (b -&gt; y)</tt> or <tt>(a =&gt; x) ~ (b =&gt;
--   y)</tt>, depending on the kind of <tt>a</tt>/<tt>b</tt>. This (most
--   common) version takes a single FunTyFlag, which is used for both
--   fco_afl and ftf_afr of the FunCo
mkFunCo :: Role -> FunTyFlag -> CoercionN -> Coercion -> Coercion -> Coercion
mkFunCo2 :: Role -> FunTyFlag -> FunTyFlag -> CoercionN -> Coercion -> Coercion -> Coercion
mkFunCoNoFTF :: HasDebugCallStack => Role -> CoercionN -> Coercion -> Coercion -> Coercion
mkFunResCo :: Role -> Id -> Coercion -> Coercion
mkFunResMCo :: Id -> MCoercionR -> MCoercionR

-- | Make a generalized reflexive coercion
mkGReflCo :: Role -> Type -> MCoercionN -> Coercion

-- | Given <tt>r</tt>, <tt>ty :: k1</tt>, and <tt>co :: k1 ~N k2</tt>,
--   produces <tt>co' :: (ty |&gt; co) ~r ty</tt>
mkGReflLeftCo :: Role -> Type -> CoercionN -> Coercion
mkGReflLeftMCo :: Role -> Type -> MCoercionN -> Coercion
mkGReflMCo :: HasDebugCallStack => Role -> Type -> CoercionN -> Coercion

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, produces <tt>co' ::
--   ty ~r (ty |&gt; co)</tt>
mkGReflRightCo :: Role -> Type -> CoercionN -> Coercion
mkGReflRightMCo :: Role -> Type -> MCoercionN -> Coercion

-- | Make a coercion from a coercion hole
mkHoleCo :: CoercionHole -> Coercion

-- | Make a Coercion quantified over a type/coercion variable; the variable
--   has the same kind and visibility in both sides of the coercion
mkHomoForAllCos :: [ForAllTyBinder] -> Coercion -> Coercion

-- | Instantiates a <a>Coercion</a>. Works for both tyvar and covar
mkInstCo :: Coercion -> CoercionN -> Coercion

-- | Given <tt>co :: (a :: k) ~ (b :: k')</tt> produce <tt>co' :: k ~
--   k'</tt>.
mkKindCo :: Coercion -> Coercion
mkLRCo :: LeftOrRight -> Coercion -> Coercion
mkNakedForAllCo :: TyVar -> ForAllTyFlag -> ForAllTyFlag -> CoercionN -> Coercion -> Coercion
mkNakedFunCo :: Role -> FunTyFlag -> CoercionN -> Coercion -> Coercion -> Coercion

-- | Creates a primitive nominal type equality predicate with an explicit
--   (but homogeneous) kind: (~#) k k ty1 ty2
mkNomPrimEqPred :: Kind -> Type -> Type -> Type

-- | Make a nominal reflexive coercion
mkNomReflCo :: Type -> Coercion

-- | Make a phantom coercion between two types. The coercion passed in must
--   be a nominal coercion between the kinds of the types.
mkPhantomCo :: Coercion -> Type -> Type -> Coercion

-- | Make a forall <a>Coercion</a>, where both types related by the
--   coercion are quantified over the same variable.
mkPiCo :: Role -> Var -> Coercion -> Coercion
mkPiCos :: Role -> [Var] -> Coercion -> Coercion
mkPiMCos :: [Var] -> MCoercion -> MCoercion

-- | Creates a primitive nominal type equality predicate. t1 ~# t2
--   Invariant: the types are not Coercions
mkPrimEqPred :: Type -> Type -> Type

-- | Makes a lifted equality predicate at the given role
mkPrimEqPredRole :: Role -> Type -> Type -> PredType

-- | Make a "coercion between coercions".
mkProofIrrelCo :: Role -> CoercionN -> Coercion -> Coercion -> Coercion

-- | Make a reflexive coercion
mkReflCo :: Role -> Type -> Coercion

-- | Make a representational reflexive coercion
mkRepReflCo :: Type -> Coercion

-- | Creates a primitive representational type equality predicate. t1 ~R#
--   t2 Invariant: the types are not Coercions
mkReprPrimEqPred :: Type -> Type -> Type

-- | Given a coercion `co :: (t1 :: TYPE r1) ~ (t2 :: TYPE r2)` produce a
--   coercion `rep_co :: r1 ~ r2` But actually it is possible that co ::
--   (t1 :: CONSTRAINT r1) ~ (t2 :: CONSTRAINT r2) or co :: (t1 :: TYPE r1)
--   ~ (t2 :: CONSTRAINT r2) or co :: (t1 :: CONSTRAINT r1) ~ (t2 :: TYPE
--   r2) See Note [mkRuntimeRepCo]
mkRuntimeRepCo :: HasDebugCallStack => Coercion -> Coercion
mkSelCo :: HasDebugCallStack => CoSel -> Coercion -> Coercion
mkSelCoResRole :: CoSel -> Role -> Role
mkSubCo :: HasDebugCallStack => Coercion -> Coercion
mkSubstLiftingContext :: Subst -> LiftingContext

-- | Create a symmetric version of the given <a>Coercion</a> that asserts
--   equality between the same types but in the other "direction", so a
--   kind of <tt>t1 ~ t2</tt> becomes the kind <tt>t2 ~ t1</tt>.
mkSymCo :: Coercion -> Coercion

-- | Get the reverse of an <a>MCoercion</a>
mkSymMCo :: MCoercion -> MCoercion

-- | mkTransCo creates a new <a>Coercion</a> by composing the two given
--   <a>Coercion</a>s transitively: (co1 ; co2)
mkTransCo :: HasDebugCallStack => Coercion -> Coercion -> Coercion

-- | Compose two MCoercions via transitivity
mkTransMCo :: MCoercion -> MCoercion -> MCoercion
mkTransMCoL :: MCoercion -> Coercion -> MCoercion
mkTransMCoR :: Coercion -> MCoercion -> MCoercion

-- | Apply a type constructor to a list of coercions. It is the caller's
--   responsibility to get the roles correct on argument coercions.
mkTyConAppCo :: HasDebugCallStack => Role -> TyCon -> [Coercion] -> Coercion
mkUnbranchedAxInstCo :: Role -> CoAxiom Unbranched -> [Type] -> [Coercion] -> Coercion

-- | Instantiate the left-hand side of an unbranched axiom
mkUnbranchedAxInstLHS :: CoAxiom Unbranched -> [Type] -> [Coercion] -> Type
mkUnbranchedAxInstRHS :: CoAxiom Unbranched -> [Type] -> [Coercion] -> Type

-- | Make a universal coercion between two arbitrary types.
mkUnivCo :: UnivCoProvenance -> [Coercion] -> Role -> Type -> Type -> Coercion
multToCo :: Mult -> Coercion
pprCoAxBranch :: TyCon -> CoAxBranch -> SDoc
pprCoAxBranchLHS :: TyCon -> CoAxBranch -> SDoc
pprCoAxBranchUser :: TyCon -> CoAxBranch -> SDoc
pprCoAxiom :: forall (br :: BranchFlag). CoAxiom br -> SDoc

-- | like mkKindCo, but aggressively &amp; recursively optimizes to avoid
--   using a KindCo constructor. The output role is nominal.
promoteCoercion :: HasDebugCallStack => Coercion -> CoercionN
selectFromType :: HasDebugCallStack => CoSel -> Type -> Type
seqCo :: Coercion -> ()

-- | Set the type of a <a>CoercionHole</a>
setCoHoleType :: CoercionHole -> Type -> CoercionHole
setCoVarName :: CoVar -> Name -> CoVar
setCoVarUnique :: CoVar -> Unique -> CoVar

-- | Converts a coercion to be nominal, if possible. See Note [Role
--   twiddling functions]
setNominalRole_maybe :: Role -> Coercion -> Maybe CoercionN

-- | Attempt to take a coercion application apart.
splitAppCo_maybe :: Coercion -> Maybe (Coercion, Coercion)

-- | Like <a>splitForAllCo_maybe</a>, but only returns Just for covar
--   binder
splitForAllCo_co_maybe :: Coercion -> Maybe (CoVar, ForAllTyFlag, ForAllTyFlag, Coercion, Coercion)
splitForAllCo_maybe :: Coercion -> Maybe (TyCoVar, ForAllTyFlag, ForAllTyFlag, Coercion, Coercion)

-- | Like <a>splitForAllCo_maybe</a>, but only returns Just for tyvar
--   binder
splitForAllCo_ty_maybe :: Coercion -> Maybe (TyVar, ForAllTyFlag, ForAllTyFlag, Coercion, Coercion)
splitFunCo_maybe :: Coercion -> Maybe (Coercion, Coercion)

-- | Like <a>substForAllCoBndr</a>, but works on a lifting context
substForAllCoBndrUsingLC :: SwapFlag -> (Coercion -> Coercion) -> LiftingContext -> TyCoVar -> Coercion -> (LiftingContext, TyCoVar, Coercion)
substLeftCo :: LiftingContext -> Coercion -> Coercion
substRightCo :: LiftingContext -> Coercion -> Coercion

-- | Apply "sym" to all coercions in a <a>LiftCoEnv</a>
swapLiftCoEnv :: LiftCoEnv -> LiftCoEnv
tidyCoAxBndrsForUser :: TidyEnv -> [Var] -> (TidyEnv, [Var])

-- | Sometimes we want to look through a <tt>newtype</tt> and get its
--   associated coercion. This function strips off <tt>newtype</tt> layers
--   enough to reveal something that isn't a <tt>newtype</tt>.
--   Specifically, here's the invariant:
--   
--   <pre>
--   topNormaliseNewType_maybe rec_nts ty = Just (co, ty')
--   </pre>
--   
--   then (a) <tt>co : ty ~R ty'</tt>. (b) ty' is not a newtype.
--   
--   The function returns <tt>Nothing</tt> for non-<tt>newtypes</tt>, or
--   unsaturated applications
--   
--   This function does *not* look through type families, because it has no
--   access to the type family environment. If you do have that at hand,
--   consider to use topNormaliseType_maybe, which should be a drop-in
--   replacement for topNormaliseNewType_maybe If topNormliseNewType_maybe
--   ty = Just (co, ty'), then co : ty ~R ty'
topNormaliseNewType_maybe :: Type -> Maybe (Coercion, Type)

-- | A general function for normalising the top-level of a type. It
--   continues to use the provided <a>NormaliseStepper</a> until that
--   function fails, and then this function returns. The roles of the
--   coercions produced by the <a>NormaliseStepper</a> must all be the
--   same, which is the role returned from the call to
--   <a>topNormaliseTypeX</a>.
--   
--   Typically ev is Coercion.
--   
--   If topNormaliseTypeX step plus ty = Just (ev, ty') then ty ~ev1~ t1
--   ~ev2~ t2 ... ~evn~ ty' and ev = ev1 <tt>plus</tt> ev2 <tt>plus</tt>
--   ... <tt>plus</tt> evn If it returns Nothing then no newtype unwrapping
--   could happen
topNormaliseTypeX :: NormaliseStepper ev -> (ev -> ev -> ev) -> Type -> Maybe (ev, Type)
tyConRole :: Role -> TyCon -> Int -> Role
tyConRoleListRepresentational :: TyCon -> [Role]
tyConRoleListX :: Role -> TyCon -> [Role]
tyConRolesRepresentational :: TyCon -> Infinite Role
tyConRolesX :: Role -> TyCon -> Infinite Role

-- | A <a>NormaliseStepper</a> that unwraps newtypes, careful not to fall
--   into a loop. If it would fall into a loop, it produces
--   <a>NS_Abort</a>.
unwrapNewTypeStepper :: NormaliseStepper Coercion

-- | Erase the environments in a lifting context
zapLiftingContext :: LiftingContext -> LiftingContext
anyFreeVarsOfCo :: (TyCoVar -> Bool) -> Coercion -> Bool
coVarsOfCo :: Coercion -> CoVarSet
tyCoFVsOfCo :: Coercion -> FV
tyCoFVsOfCos :: [Coercion] -> FV
tyCoVarsOfCo :: Coercion -> TyCoVarSet

-- | Get a deterministic set of the vars free in a coercion
tyCoVarsOfCoDSet :: Coercion -> DTyCoVarSet
tyCoVarsOfCos :: [Coercion] -> TyCoVarSet
pprCo :: Coercion -> SDoc
pprParendCo :: Coercion -> SDoc
coHoleCoVar :: CoercionHole -> CoVar
coercionSize :: Coercion -> Int
setCoHoleCoVar :: CoercionHole -> CoVar -> CoercionHole
emptyCvSubstEnv :: CvSubstEnv
extendTvSubstAndInScope :: Subst -> TyVar -> Type -> Subst
getCvSubstEnv :: Subst -> CvSubstEnv
lookupCoVar :: Subst -> Var -> Maybe Coercion
substCoVar :: Subst -> CoVar -> Coercion
substCoVarBndr :: HasDebugCallStack => Subst -> CoVar -> (Subst, CoVar)
substCoVars :: Subst -> [CoVar] -> [Coercion]

-- | Coercion substitution, see <a>zipTvSubst</a>
substCoWith :: HasDebugCallStack => [TyVar] -> [Type] -> Coercion -> Coercion

-- | Substitute within several <a>Coercion</a>s The substitution has to
--   satisfy the invariants described in Note [The substitution invariant].
substCos :: HasDebugCallStack => Subst -> [Coercion] -> [Coercion]

-- | Tidy a Coercion
--   
--   See Note [Strictness in tidyType and friends]
tidyCo :: TidyEnv -> Coercion -> Coercion
tidyCos :: TidyEnv -> [Coercion] -> [Coercion]
pickLR :: LeftOrRight -> (a, a) -> a

-- | Is this a coercion variable? Satisfies <tt><a>isId</a> v ==&gt;
--   <a>isCoVar</a> v == not (<a>isNonCoVarId</a> v)</tt>.
isCoVar :: Var -> Bool
mkCoVar :: Name -> Type -> CoVar
type LiftCoEnv = VarEnv Coercion
data LiftingContext
LC :: Subst -> LiftCoEnv -> LiftingContext

-- | The result of stepping in a normalisation function. See
--   <a>topNormaliseTypeX</a>.
data NormaliseStepResult ev

-- | Nothing more to do
NS_Done :: NormaliseStepResult ev

-- | Utter failure. The outer function should fail too.
NS_Abort :: NormaliseStepResult ev

-- | We stepped, yielding new bits; ^ ev is evidence; Usually a co :: old
--   type ~ new type
NS_Step :: RecTcChecker -> Type -> ev -> NormaliseStepResult ev

-- | A function to check if we can reduce a type by one step. Used with
--   <a>topNormaliseTypeX</a>.
type NormaliseStepper ev = RecTcChecker -> TyCon -> [Type] -> NormaliseStepResult ev
data CoSel
SelTyCon :: Int -> Role -> CoSel
SelFun :: FunSel -> CoSel
SelForAll :: CoSel

-- | A <a>Coercion</a> is concrete evidence of the equality/convertibility
--   of two types.
data Coercion

-- | A coercion to be filled in by the type-checker. See Note [Coercion
--   holes]
data CoercionHole
CoercionHole :: CoVar -> IORef (Maybe Coercion) -> Bool -> CoercionHole
[ch_co_var] :: CoercionHole -> CoVar
[ch_ref] :: CoercionHole -> IORef (Maybe Coercion)
[ch_hetero_kind] :: CoercionHole -> Bool
type CoercionN = Coercion
type CoercionP = Coercion
type CoercionR = Coercion
data FunSel
SelMult :: FunSel
SelArg :: FunSel
SelRes :: FunSel

-- | A semantically more meaningful type to represent what may or may not
--   be a useful <a>Coercion</a>.
data MCoercion
MRefl :: MCoercion
MCo :: Coercion -> MCoercion
type MCoercionN = MCoercion
type MCoercionR = MCoercion

-- | For simplicity, we have just one UnivCo that represents a coercion
--   from some type to some other type, with (in general) no restrictions
--   on the type. The UnivCoProvenance specifies more exactly what the
--   coercion really is and why a program should (or shouldn't!) trust the
--   coercion. It is reasonable to consider each constructor of
--   <a>UnivCoProvenance</a> as a totally independent coercion form; their
--   only commonality is that they don't tell you what types they coercion
--   between. (That info is in the <a>UnivCo</a> constructor of
--   <a>Coercion</a>.
data UnivCoProvenance

-- | A substitution of <a>Coercion</a>s for <a>CoVar</a>s
type CvSubstEnv = CoVarEnv Coercion
data LeftOrRight
CLeft :: LeftOrRight
CRight :: LeftOrRight

-- | Coercion Variable
type CoVar = Id

-- | Type or Coercion Variable
type TyCoVar = Id

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var

-- | See Note [Roles] in GHC.Core.Coercion
--   
--   Order of constructors matters: the Ord instance coincides with the
--   *super*typing relation on roles.
data Role
Nominal :: Role
Representational :: Role
Phantom :: Role

-- | Class of things that we can obtain a <a>Unique</a> from
class Uniquable a
getUnique :: Uniquable a => a -> Unique

-- | Unique identifier.
--   
--   The type of unique identifiers that are used in many places in GHC for
--   fast ordering and equality tests. You should generate these with the
--   functions from the <tt>UniqSupply</tt> module
--   
--   These are sometimes also referred to as "keys" in comments in GHC.
data Unique
type PsError = PsMessage
type PsWarning = PsMessage

-- | A collection of messages emitted by GHC during error reporting. A
--   diagnostic message is typically a warning or an error. See Note
--   [Messages].
--   
--   <i>INVARIANT</i>: All the messages in this collection must be
--   relevant, i.e. their <a>Severity</a> should <i>not</i> be
--   <a>SevIgnore</a>. The smart constructor <a>mkMessages</a> will filter
--   out any message which <a>Severity</a> is <a>SevIgnore</a>.
data Messages e
data HsParsedModule

-- | Attempt to convert a Template Haskell name to one that GHC can
--   understand. Original TH names such as those you get when you use the
--   <tt>'foo</tt> syntax will be translated to their equivalent GHC name
--   exactly. Qualified or unqualified TH names will be dynamically bound
--   to names in the module being compiled, if possible. Exact TH names
--   will be bound to the name they represent, exactly.
thNameToGhcName :: Name -> CoreM (Maybe Name)

-- | Attempt to convert a Template Haskell name to one that GHC can
--   understand. Original TH names such as those you get when you use the
--   <tt>'foo</tt> syntax will be translated to their equivalent GHC name
--   exactly. Qualified or unqualified TH names will be dynamically bound
--   to names in the module being compiled, if possible. Exact TH names
--   will be bound to the name they represent, exactly.
--   
--   One must be careful to consistently use the same <a>NameCache</a> to
--   create identifier that might be compared. (C.f. how the <a>ST</a>
--   Monad enforces that variables from separate <a>runST</a> invocations
--   are never intermingled; it would be valid to use the same tricks for
--   <a>Name</a>s and <a>NameCache</a>s.)
--   
--   For now, the easiest and recommended way to ensure a consistent
--   <a>NameCache</a> is used it to retrieve the preexisting one from an
--   active <a>HscEnv</a>. A single <a>HscEnv</a> is created per GHC
--   "session", and this ensures everything in that session will get the
--   same name cache.
thNameToGhcNameIO :: NameCache -> Name -> IO (Maybe Name)
instance GHC.Types.TyThing.MonadThings GHC.Core.Opt.Monad.CoreM


-- | Tidying up Core
--   
--   This module's purpose is to prepare the Core program for two distinct
--   purposes: * To be serialised into the module's interface file * To
--   feed to the code generator
--   
--   The most important tasks are: * Determine which <a>Name</a>s should
--   ultimately be <tt>Internal</tt> and <tt>External</tt> (which may
--   differ to whether they were originally <tt>Internal</tt> or
--   <tt>External</tt>). See `Note [About the NameSorts]` in
--   GHC.Types.Name. For example, in: module M where f x = x + y where y =
--   factorial 4 could be optimized during the Core pass to: module M where
--   y = factorial 4 f x = x + y in which case <tt>y</tt> would be changed
--   from <tt>Internal</tt> to <tt>External</tt>.
--   
--   <ul>
--   <li>Rename local identifiers to avoid name clashes, so that unfoldings
--   etc can be serialialised using the OccName, without Uniques.</li>
--   </ul>
--   
--   For example (<tt>x_5</tt> means <tt>x</tt> with a <tt>Unique</tt> of
--   `5`): f x_12 x_23 = x_12 would be changed to: f x_12 x1_23 = x_12
module GHC.Iface.Tidy
data TidyOpts
TidyOpts :: !NameCache -> !Bool -> !UnfoldingOpts -> !UnfoldingExposure -> !Bool -> !Bool -> !Maybe StaticPtrOpts -> !Bool -> TidyOpts
[opt_name_cache] :: TidyOpts -> !NameCache

-- | Always true if we compile with -prof
[opt_collect_ccs] :: TidyOpts -> !Bool
[opt_unfolding_opts] :: TidyOpts -> !UnfoldingOpts

-- | Which unfoldings to expose
[opt_expose_unfoldings] :: TidyOpts -> !UnfoldingExposure

-- | trim off the arity, one-shot-ness, strictness etc which were retained
--   for the benefit of the code generator
[opt_trim_ids] :: TidyOpts -> !Bool

-- | Are rules exposed or not?
[opt_expose_rules] :: TidyOpts -> !Bool

-- | Options for generated static pointers, if enabled (/= Nothing).
[opt_static_ptr_opts] :: TidyOpts -> !Maybe StaticPtrOpts
[opt_keep_auto_rules] :: TidyOpts -> !Bool
data UnfoldingExposure

-- | Don't expose unfoldings
ExposeNone :: UnfoldingExposure

-- | Expose mandatory unfoldings and those meeting inlining thresholds.
ExposeSome :: UnfoldingExposure

-- | Expose unfoldings useful for inlinings and those which which might be
--   specialised. See Note [Exposing overloaded functions]
ExposeOverloaded :: UnfoldingExposure

-- | Expose all unfoldings
ExposeAll :: UnfoldingExposure
tidyProgram :: TidyOpts -> ModGuts -> IO (CgGuts, ModDetails)
mkBootModDetailsTc :: Logger -> TcGblEnv -> IO ModDetails
instance GHC.Internal.Base.Applicative GHC.Iface.Tidy.DFFV
instance GHC.Classes.Eq GHC.Iface.Tidy.UnfoldingExposure
instance GHC.Internal.Base.Functor GHC.Iface.Tidy.DFFV
instance GHC.Internal.Base.Monad GHC.Iface.Tidy.DFFV
instance GHC.Classes.Ord GHC.Iface.Tidy.UnfoldingExposure
instance GHC.Internal.Show.Show GHC.Iface.Tidy.UnfoldingExposure

module GHC.Driver.Config.Tidy
initTidyOpts :: HscEnv -> IO TidyOpts
initStaticPtrOpts :: HscEnv -> IO StaticPtrOpts


-- | The <tt>FamInst</tt> type: family instance heads
module GHC.Tc.Instance.Family
type FamInstEnvs = (FamInstEnv, FamInstEnv)
tcGetFamInstEnvs :: TcM FamInstEnvs
checkFamInstConsistency :: [Module] -> TcM ()
tcExtendLocalFamInstEnv :: [FamInst] -> TcM a -> TcM a

-- | Like <a>tcLookupDataFamInst_maybe</a>, but returns the arguments back
--   if there is no data family to unwrap. Returns a Representational
--   coercion
tcLookupDataFamInst :: FamInstEnvs -> TyCon -> [TcType] -> (TyCon, [TcType], Coercion)

-- | Converts a data family type (eg F [a]) to its representation type (eg
--   FList a) and returns a coercion between the two: co :: F [a] ~R FList
--   a.
tcLookupDataFamInst_maybe :: FamInstEnvs -> TyCon -> [TcType] -> Maybe (TyCon, [TcType], Coercion)

-- | If <tt>co :: T ts ~ rep_ty</tt> then:
--   
--   <pre>
--   instNewTyCon_maybe T ts = Just (rep_ty, co)
--   </pre>
--   
--   Checks for a newtype, and for being saturated Just like
--   Coercion.instNewTyCon_maybe, but returns a TcCoercion
tcInstNewTyCon_maybe :: TyCon -> [TcType] -> Maybe (TcType, TcCoercion)

-- | <a>tcTopNormaliseNewTypeTF_maybe</a> gets rid of top-level newtypes,
--   potentially looking through newtype <i>instances</i> and type
--   synonyms.
--   
--   It is only used by the type inference engine (specifically, when
--   solving representational equality), and hence it is careful to unwrap
--   only if the relevant data constructor is in scope. That's why it gets
--   a GlobalRdrEnv argument.
--   
--   It is careful not to unwrap data/newtype instances nor synonyms if it
--   can't continue unwrapping. Such care is necessary for proper error
--   messages.
--   
--   It does not look through type families. It does not normalise
--   arguments to a tycon.
--   
--   If the result is Just ((gres, co), rep_ty), then co : ty ~R rep_ty
--   gres are the GREs for the data constructors that had to be in scope
tcTopNormaliseNewTypeTF_maybe :: FamInstEnvs -> GlobalRdrEnv -> Type -> Maybe ((Bag GlobalRdrElt, TcCoercion), Type)

-- | Report a list of injectivity errors together with their source
--   locations. Looks only at one equation; does not look for conflicts
--   *among* equations.
reportInjectivityErrors :: forall (br :: BranchFlag). DynFlags -> CoAxiom br -> CoAxBranch -> [Bool] -> TcM ()

-- | Report error message for a pair of equations violating an injectivity
--   annotation. No error message if there are no branches.
reportConflictingInjectivityErrs :: TyCon -> [CoAxBranch] -> CoAxBranch -> TcM ()

module GHC.Tc.Errors

-- | Report unsolved goals as errors or warnings. We may also turn some
--   into deferred run-time errors if `-fdefer-type-errors` is on.
reportUnsolved :: WantedConstraints -> TcM (Bag EvBind)

-- | Report *all* unsolved goals as errors, even if -fdefer-type-errors is
--   on However, do not make any evidence bindings, because we don't have
--   any convenient place to put them. NB: Type-level holes are OK, because
--   there are no bindings. See Note [Deferring coercion errors to runtime]
--   Used by solveEqualities for kind equalities (see Note [Failure in
--   local type signatures] in GHC.Tc.Solver)
reportAllUnsolved :: WantedConstraints -> TcM ()

-- | Report all unsolved goals as warnings (but without deferring any
--   errors to run-time). See Note [Safe Haskell Overlapping Instances
--   Implementation] in <a>GHC.Tc.Solver</a>
warnAllUnsolved :: WantedConstraints -> TcM ()
warnDefaulting :: [Ct] -> TcTyVar -> Type -> TcM ()

-- | If the <a>TcSolverReportMsg</a> is a type mismatch between an actual
--   and an expected type, return the actual and expected types (in that
--   order).
--   
--   Prefer using this over manually inspecting the
--   <a>TcSolverReportMsg</a> datatype if you just want this information,
--   as the datatype itself is subject to change across GHC versions.
solverReportMsg_ExpectedActuals :: TcSolverReportMsg -> Maybe (Type, Type)
mismatchMsg_ExpectedActuals :: MismatchMsg -> Maybe (Type, Type)

module GHC.Rename.Utils
checkDupRdrNames :: [LocatedN RdrName] -> RnM ()
checkShadowedRdrNames :: [LocatedN RdrName] -> RnM ()
checkDupNames :: [Name] -> RnM ()
checkDupAndShadowedNames :: (GlobalRdrEnv, LocalRdrEnv) -> [Name] -> RnM ()
dupNamesErr :: NonEmpty SrcSpan -> NonEmpty RdrName -> RnM ()

-- | Ensure that a boxed or unboxed tuple has arity no larger than
--   <a>mAX_TUPLE_SIZE</a>.
checkTupSize :: Int -> TcM ()

-- | Ensure that a constraint tuple has arity no larger than
--   <a>mAX_CTUPLE_SIZE</a>.
checkCTupSize :: Int -> TcM ()
addFvRn :: FreeVars -> RnM (thing, FreeVars) -> RnM (thing, FreeVars)
mapFvRn :: Traversable f => (a -> RnM (b, FreeVars)) -> f a -> RnM (f b, FreeVars)
mapMaybeFvRn :: (a -> RnM (b, FreeVars)) -> Maybe a -> RnM (Maybe b, FreeVars)
warnUnusedMatches :: [Name] -> FreeVars -> RnM ()
warnUnusedTypePatterns :: [Name] -> FreeVars -> RnM ()
warnUnusedTopBinds :: [GlobalRdrElt] -> RnM ()
warnUnusedLocalBinds :: [Name] -> FreeVars -> RnM ()

-- | Whether to report deprecation warnings when registering a used GRE
--   
--   There is no option to only emit declaration warnings since everywhere
--   we emit the declaration warnings we also emit export warnings (See
--   Note [Handling of deprecations] for details)
data DeprecationWarnings
NoDeprecationWarnings :: DeprecationWarnings
ExportDeprecationWarnings :: DeprecationWarnings
AllDeprecationWarnings :: DeprecationWarnings
warnIfDeprecated :: DeprecationWarnings -> [GlobalRdrElt] -> RnM ()

-- | Checks to see if we need to warn for -Wunused-record-wildcards or
--   -Wredundant-record-wildcards
checkUnusedRecordWildcard :: SrcSpan -> FreeVars -> Maybe [ImplicitFieldBinders] -> RnM ()
badQualBndrErr :: RdrName -> TcRnMessage
typeAppErr :: TypeOrKind -> LHsType GhcPs -> TcRnMessage
badFieldConErr :: Name -> FieldLabelString -> TcRnMessage
wrapGenSpan :: HasAnnotation an => a -> GenLocated an a
genHsVar :: Name -> HsExpr GhcRn
genLHsVar :: Name -> LHsExpr GhcRn
genHsApp :: HsExpr GhcRn -> LHsExpr GhcRn -> HsExpr GhcRn
genHsApps :: Name -> [LHsExpr GhcRn] -> HsExpr GhcRn

-- | Keeps the span given to the <a>Name</a> for the application head only
genHsApps' :: LocatedN Name -> [LHsExpr GhcRn] -> HsExpr GhcRn
genHsExpApps :: HsExpr GhcRn -> [LHsExpr GhcRn] -> HsExpr GhcRn
genLHsApp :: HsExpr GhcRn -> LHsExpr GhcRn -> LHsExpr GhcRn
genAppType :: HsExpr GhcRn -> HsType (NoGhcTc GhcRn) -> HsExpr GhcRn
genLHsLit :: NoAnn an => HsLit GhcRn -> LocatedAn an (HsExpr GhcRn)
genHsIntegralLit :: NoAnn an => IntegralLit -> LocatedAn an (HsExpr GhcRn)
genHsTyLit :: FastString -> HsType GhcRn
genSimpleConPat :: Name -> [LPat GhcRn] -> LPat GhcRn
genVarPat :: Name -> LPat GhcRn
genWildPat :: LPat GhcRn
genSimpleFunBind :: Name -> [LPat GhcRn] -> LHsExpr GhcRn -> LHsBind GhcRn
genFunBind :: LocatedN Name -> [LMatch GhcRn (LHsExpr GhcRn)] -> HsBind GhcRn
genHsLamDoExp :: forall (p :: Pass). (IsPass p, XMG (GhcPass p) (LHsExpr (GhcPass p)) ~ Origin) => HsDoFlavour -> [LPat (GhcPass p)] -> LHsExpr (GhcPass p) -> LHsExpr (GhcPass p)
genHsCaseAltDoExp :: forall (p :: Pass) body. (Anno (GRHS (GhcPass p) (LocatedA (body (GhcPass p)))) ~ EpAnnCO, Anno (Match (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcSpanAnnA) => HsDoFlavour -> LPat (GhcPass p) -> LocatedA (body (GhcPass p)) -> LMatch (GhcPass p) (LocatedA (body (GhcPass p)))
genSimpleMatch :: forall (p :: Pass) body. (Anno (Match (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcSpanAnnA, Anno (GRHS (GhcPass p) (LocatedA (body (GhcPass p)))) ~ EpAnnCO) => HsMatchContext (LIdP (NoGhcTc (GhcPass p))) -> [LPat (GhcPass p)] -> LocatedA (body (GhcPass p)) -> LMatch (GhcPass p) (LocatedA (body (GhcPass p)))
genHsLet :: HsLocalBindsLR GhcRn GhcRn -> LHsExpr GhcRn -> HsExpr GhcRn
newLocalBndrRn :: LocatedN RdrName -> RnM Name
newLocalBndrsRn :: [LocatedN RdrName] -> RnM [Name]
bindLocalNames :: [Name] -> RnM a -> RnM a
bindLocalNamesFV :: [Name] -> RnM (a, FreeVars) -> RnM (a, FreeVars)
delLocalNames :: [Name] -> RnM a -> RnM a
addNameClashErrRn :: RdrName -> NonEmpty GlobalRdrElt -> RnM ()
mkNameClashErr :: GlobalRdrEnv -> RdrName -> NonEmpty GlobalRdrElt -> TcRnMessage

-- | Throw an error message if a user attempts to quantify an inferred type
--   variable in a place where specificity cannot be observed. For example,
--   <tt>forall {a}. [a] -&gt; [a]</tt> would be rejected to the inferred
--   type variable <tt>{a}</tt>, but <tt>forall a. [a] -&gt; [a]</tt> would
--   be accepted. See <tt>Note [Unobservably inferred type variables]</tt>.
checkInferredVars :: HsDocContext -> LHsSigType GhcPs -> RnM ()

-- | Examines a non-outermost type for <tt>forall</tt>s or contexts, which
--   are assumed to be nested. For example, in the following declaration:
--   
--   <pre>
--   instance forall a. forall b. C (Either a b)
--   </pre>
--   
--   The outermost <tt>forall a</tt> is fine, but the nested <tt>forall
--   b</tt> is not. We invoke <a>noNestedForallsContextsErr</a> on the type
--   <tt>forall b. C (Either a b)</tt> to catch the nested <tt>forall</tt>
--   and create a suitable error message. <a>noNestedForallsContextsErr</a>
--   returns <tt><a>Just</a> err_msg</tt> if such a <tt>forall</tt> or
--   context is found, and returns <tt>Nothing</tt> otherwise.
--   
--   This is currently used in the following places:
--   
--   <ul>
--   <li>In GADT constructor types (in <tt>rnConDecl</tt>). See <tt>Note
--   [GADT abstract syntax] (Wrinkle: No nested foralls or contexts)</tt>
--   in <a>GHC.Hs.Type</a>.</li>
--   <li>In instance declaration types (in <tt>rnClsIntDecl</tt> and
--   <tt>rnSrcDerivDecl</tt> in <a>GHC.Rename.Module</a> and
--   <tt>renameSig</tt> in <a>GHC.Rename.Bind</a>). See <tt>Note [No nested
--   foralls or contexts in instance types]</tt> in
--   <a>GHC.Hs.Type</a>.</li>
--   </ul>
noNestedForallsContextsErr :: NestedForallsContextsIn -> LHsType GhcRn -> Maybe (SrcSpan, TcRnMessage)

-- | A common way to invoke <a>noNestedForallsContextsErr</a>.
addNoNestedForallsContextsErr :: HsDocContext -> NestedForallsContextsIn -> LHsType GhcRn -> RnM ()

module GHC.Rename.Fixity

-- | Mini fixity env for the names we're about to bind, in a single binding
--   group
--   
--   It is keyed by the *FastString*, not the *OccName*, because the single
--   fixity decl <tt>infix 3 T</tt> affects both the data constructor T and
--   the type constructor T
--   
--   We keep the location so that if we find a duplicate, we can report it
--   sensibly
--   
--   Fixity declarations may influence names in a single namespace by using
--   a type or data specifier, e.g. in:
--   
--   <pre>
--   data a :*: b = a :*: b
--   infix 3 type :*:
--   </pre>
--   
--   To handle that correctly, MiniFixityEnv contains separate fields for
--   type-level and data-level names. If no namespace specifier is
--   provided, the declaration will populate both the type-level and
--   data-level fields.
data MiniFixityEnv
MFE :: FastStringEnv (Located Fixity) -> FastStringEnv (Located Fixity) -> MiniFixityEnv
[mfe_data_level_names] :: MiniFixityEnv -> FastStringEnv (Located Fixity)
[mfe_type_level_names] :: MiniFixityEnv -> FastStringEnv (Located Fixity)
addLocalFixities :: MiniFixityEnv -> [Name] -> RnM a -> RnM a
lookupMiniFixityEnv :: MiniFixityEnv -> Name -> Maybe (Located Fixity)
emptyMiniFixityEnv :: MiniFixityEnv
lookupFixityRn :: Name -> RnM Fixity

-- | <a>lookupFixityRn_help</a> returns <tt>(True, fixity)</tt> if it finds
--   a <a>Fixity</a> in a local environment or from an interface file.
--   Otherwise, it returns <tt>(False, fixity)</tt> (e.g., for unbound
--   <a>Name</a>s or <a>Name</a>s without user-supplied fixity
--   declarations).
lookupFixityRn_help :: Name -> RnM (Bool, Fixity)
lookupFieldFixityRn :: FieldOcc GhcRn -> RnM Fixity
lookupTyFixityRn :: LocatedN Name -> RnM Fixity

module GHC.Rename.Env
newTopSrcBinder :: LocatedN RdrName -> RnM Name
lookupLocatedTopBndrRn :: Located RdrName -> RnM (Located Name)
lookupLocatedTopBndrRnN :: LocatedN RdrName -> RnM (LocatedN Name)
lookupTopBndrRn :: WhatLooking -> RdrName -> RnM Name
lookupLocatedTopConstructorRn :: Located RdrName -> RnM (Located Name)
lookupLocatedTopConstructorRnN :: LocatedN RdrName -> RnM (LocatedN Name)
lookupLocatedOccRn :: GenLocated (EpAnn ann) RdrName -> TcRn (GenLocated (EpAnn ann) Name)
lookupLocatedOccRnConstr :: GenLocated (EpAnn ann) RdrName -> TcRn (GenLocated (EpAnn ann) Name)
lookupLocatedOccRnRecField :: GenLocated (EpAnn ann) RdrName -> TcRn (GenLocated (EpAnn ann) Name)
lookupLocatedOccRnNone :: GenLocated (EpAnn ann) RdrName -> TcRn (GenLocated (EpAnn ann) Name)
lookupOccRn :: RdrName -> RnM Name
lookupOccRn_maybe :: RdrName -> RnM (Maybe GlobalRdrElt)
lookupSameOccRn_maybe :: RdrName -> RnM (Maybe Name)
lookupLocalOccRn_maybe :: RdrName -> RnM (Maybe Name)

-- | lookupInfoOccRn is intended for use in GHCi's ":info" command It finds
--   all the GREs that RdrName could mean, not complaining about ambiguity,
--   but rather returning them all (c.f. #9881).
--   
--   lookupInfoOccRn is also used in situations where we check for at least
--   one definition of the RdrName, not complaining about multiple
--   definitions (see #17832).
lookupInfoOccRn :: RdrName -> RnM [Name]
lookupLocalOccThLvl_maybe :: Name -> RnM (Maybe (TopLevelFlag, ThLevel))
lookupLocalOccRn :: RdrName -> RnM Name
lookupTypeOccRn :: RdrName -> RnM Name
lookupGlobalOccRn :: RdrName -> RnM Name
lookupGlobalOccRn_maybe :: WhichGREs GREInfo -> RdrName -> RnM (Maybe GlobalRdrElt)

-- | Look up a <a>RdrName</a> used as a variable in an expression.
--   
--   This may be a local variable, global variable, or one or more record
--   selector functions. It will not return record fields created with the
--   <tt>NoFieldSelectors</tt> extension (see Note [NoFieldSelectors]).
--   
--   If the name is not in scope at the term level, but its promoted
--   equivalent is in scope at the type level, the lookup will succeed (so
--   that the type-checker can report a more informative error later). See
--   Note [Promotion].
lookupExprOccRn :: RdrName -> RnM (Maybe GlobalRdrElt)

-- | Look up an occurrence of a field in record construction or pattern
--   matching (but not update).
--   
--   If -XDisambiguateRecordFields is off, then we will pass <a>Nothing</a>
--   for the <a>DataCon</a> <a>Name</a>, i.e. we don't use the data
--   constructor for disambiguation. See Note [DisambiguateRecordFields]
--   and Note [NoFieldSelectors].
lookupRecFieldOcc :: Maybe Name -> RdrName -> RnM Name

-- | Returns all possible collections of field labels for the given record
--   update.
--   
--   Example:
--   
--   data D = MkD { fld1 :: Int, fld2 :: Bool } data E = MkE1 { fld1 ::
--   Int, fld2 :: Bool, fld3 :: Char } | MkE2 { fld1 :: Int, fld2 :: Bool }
--   data F = MkF1 { fld1 :: Int } | MkF2 { fld2 :: Bool }
--   
--   f r = r { fld1 = a, fld2 = b }
--   
--   This function will return:
--   
--   <ul>
--   <li><i> [ D.fld1, D.fld2 </i> -- could be a record update at type D ,
--   [ E.fld1, E.fld2 ] -- could be a record update at type E ] -- cannot
--   be a record update at type F: no constructor has both -- of the fields
--   fld1 and fld2</li>
--   </ul>
--   
--   If there are no valid parents for the record update, throws a
--   <a>TcRnBadRecordUpdate</a> error.
lookupRecUpdFields :: NonEmpty (LHsRecUpdField GhcPs GhcPs) -> RnM (NonEmpty (HsRecUpdParent GhcRn))
getFieldUpdLbl :: forall (p :: Pass) q. IsPass p => LHsRecUpdField (GhcPass p) q -> LocatedN RdrName
getUpdFieldLbls :: forall (p :: Pass) q. IsPass p => [LHsRecUpdField (GhcPass p) q] -> [RdrName]
data ChildLookupResult

-- | We couldn't find a suitable name
NameNotFound :: ChildLookupResult

-- | The child has an incorrect parent
IncorrectParent :: Name -> GlobalRdrElt -> [Name] -> ChildLookupResult
FoundChild :: GlobalRdrElt -> ChildLookupResult

-- | Used in export lists to lookup the children.
lookupSubBndrOcc_helper :: Bool -> DeprecationWarnings -> Name -> RdrName -> LookupChild -> RnM ChildLookupResult
data HsSigCtxt
TopSigCtxt :: NameSet -> HsSigCtxt
LocalBindCtxt :: NameSet -> HsSigCtxt
ClsDeclCtxt :: Name -> HsSigCtxt
InstDeclCtxt :: NameSet -> HsSigCtxt
HsBootCtxt :: NameSet -> HsSigCtxt
RoleAnnotCtxt :: NameSet -> HsSigCtxt
lookupLocalTcNames :: HsSigCtxt -> SDoc -> NamespaceSpecifier -> RdrName -> RnM [(RdrName, Name)]
lookupSigOccRn :: HsSigCtxt -> Sig GhcPs -> LocatedA RdrName -> RnM (LocatedA Name)
lookupSigOccRnN :: HsSigCtxt -> Sig GhcPs -> LocatedN RdrName -> RnM (LocatedN Name)

-- | Lookup a name in relation to the names in a <a>HsSigCtxt</a>
lookupSigCtxtOccRn :: HsSigCtxt -> SDoc -> GenLocated (EpAnn ann) RdrName -> RnM (GenLocated (EpAnn ann) Name)
lookupInstDeclBndr :: Name -> SDoc -> RdrName -> RnM Name
lookupFamInstName :: Maybe Name -> LocatedN RdrName -> RnM (LocatedN Name)

-- | Look up the arity and record fields of a constructor.
lookupConstructorInfo :: HasDebugCallStack => Name -> RnM ConInfo
lookupConstructorFields :: HasDebugCallStack => Name -> RnM [FieldLabel]

-- | Look up the <a>GREInfo</a> associated with the given <a>Name</a> by
--   looking up in the type environment.
lookupGREInfo :: HasDebugCallStack => HscEnv -> Name -> GREInfo

-- | Check irrefutability of a <a>ConLike</a> in a 'ConPat GhcRn' (the
--   'Irref-ConLike' condition of Note [Irrefutability of ConPat]).
irrefutableConLikeRn :: HasDebugCallStack => HscEnv -> GlobalRdrEnv -> CompleteMatches -> Name -> Bool

-- | Check irrefutability of the <a>ConLike</a> in a 'ConPat GhcTc' (the
--   'Irref-ConLike' condition of Note [Irrefutability of ConPat]), given
--   all in-scope COMPLETE pragmas (<a>CompleteMatches</a> in the
--   typechecker, <a>DsCompleteMatches</a> in the desugarer).
irrefutableConLikeTc :: NamedThing con => [CompleteMatchX con] -> ConLike -> Bool
lookupGreAvailRn :: RdrName -> RnM (Maybe GlobalRdrElt)
lookupSyntax :: Name -> RnM (SyntaxExpr GhcRn, FreeVars)
lookupSyntaxExpr :: Name -> RnM (HsExpr GhcRn, FreeVars)
lookupSyntaxNames :: [Name] -> RnM ([HsExpr GhcRn], FreeVars)
lookupSyntaxName :: Name -> RnM (Name, FreeVars)
lookupIfThenElse :: RnM (Maybe Name)
lookupQualifiedDoExpr :: HsStmtContext fn -> Name -> RnM (HsExpr GhcRn, FreeVars)
lookupQualifiedDo :: HsStmtContext fn -> Name -> RnM (SyntaxExpr GhcRn, FreeVars)
lookupQualifiedDoName :: HsStmtContext fn -> Name -> RnM (Name, FreeVars)
lookupNameWithQualifier :: Name -> ModuleName -> RnM (Name, FreeVars)

-- | Whether to report deprecation warnings when registering a used GRE
--   
--   There is no option to only emit declaration warnings since everywhere
--   we emit the declaration warnings we also emit export warnings (See
--   Note [Handling of deprecations] for details)
data DeprecationWarnings
NoDeprecationWarnings :: DeprecationWarnings
ExportDeprecationWarnings :: DeprecationWarnings
AllDeprecationWarnings :: DeprecationWarnings
addUsedGRE :: DeprecationWarnings -> GlobalRdrElt -> RnM ()
addUsedGREs :: DeprecationWarnings -> [GlobalRdrElt] -> RnM ()
addUsedDataCons :: GlobalRdrEnv -> TyCon -> RnM ()
dataTcOccs :: RdrName -> [RdrName]
instance GHC.Internal.Base.Monoid GHC.Rename.Env.DisambigInfo
instance GHC.Utils.Outputable.Outputable GHC.Rename.Env.ChildLookupResult
instance GHC.Utils.Outputable.Outputable GHC.Rename.Env.DisambigInfo
instance GHC.Utils.Outputable.Outputable GHC.Rename.Env.HsSigCtxt
instance GHC.Internal.Base.Semigroup GHC.Rename.Env.DisambigInfo

module GHC.Tc.Instance.Class
matchGlobalInst :: DynFlags -> Bool -> Class -> [Type] -> TcM ClsInstResult
matchEqualityInst :: Class -> [Type] -> (DataCon, Role, Type, Type)
data ClsInstResult
NoInstance :: ClsInstResult
OneInst :: [TcPredType] -> ([EvExpr] -> EvTerm) -> CanonicalEvidence -> InstanceWhat -> ClsInstResult
[cir_new_theta] :: ClsInstResult -> [TcPredType]
[cir_mk_ev] :: ClsInstResult -> [EvExpr] -> EvTerm
[cir_canonical] :: ClsInstResult -> CanonicalEvidence
[cir_what] :: ClsInstResult -> InstanceWhat
NotSure :: ClsInstResult
data InstanceWhat
BuiltinEqInstance :: InstanceWhat
BuiltinTypeableInstance :: TyCon -> InstanceWhat
BuiltinInstance :: InstanceWhat
LocalInstance :: InstanceWhat
TopLevInstance :: DFunId -> SafeOverlapping -> Maybe (WarningTxt GhcRn) -> InstanceWhat
[iw_dfun_id] :: InstanceWhat -> DFunId
[iw_safe_over] :: InstanceWhat -> SafeOverlapping
[iw_warn] :: InstanceWhat -> Maybe (WarningTxt GhcRn)
safeOverlap :: InstanceWhat -> Bool
instanceReturnsDictCon :: InstanceWhat -> Bool

-- | Extra information about the parent instance declaration, needed when
--   type-checking associated types. The <a>Class</a> is the enclosing
--   class, the [TyVar] are the <i>scoped</i> type variable of the instance
--   decl. The <tt>VarEnv Type</tt> maps class variables to their instance
--   types.
data AssocInstInfo
NotAssociated :: AssocInstInfo
InClsInst :: Class -> [TyVar] -> VarEnv Type -> AssocInstInfo
[ai_class] :: AssocInstInfo -> Class

-- | The <i>scoped</i> tyvars of the instance Why scoped? See bind_me in
--   <a>checkConsistentFamInst</a>
[ai_tyvars] :: AssocInstInfo -> [TyVar]

-- | Maps <i>class</i> tyvars to their instance types See Note [Matching in
--   the consistent-instantiation check]
[ai_inst_env] :: AssocInstInfo -> VarEnv Type
isNotAssociated :: AssocInstInfo -> Bool
instance GHC.Utils.Outputable.Outputable GHC.Tc.Instance.Class.ClsInstResult


-- | Monadic definitions for the constraint solver
module GHC.Tc.Solver.Monad
data TcS a
runTcS :: TcS a -> TcM (a, EvBindMap)

-- | This variant of <a>runTcS</a> will immediately fail upon encountering
--   an insoluble ct. See Note [Speeding up valid hole-fits]. Its one usage
--   site does not need the ev_binds, so we do not return them.
runTcSEarlyAbort :: TcS a -> TcM a
runTcSWithEvBinds :: EvBindsVar -> TcS a -> TcM a

-- | A variant of <a>runTcS</a> that takes and returns an <a>InertSet</a>
--   for later resumption of the <a>TcS</a> session.
runTcSInerts :: InertSet -> TcS a -> TcM (a, InertSet)
failTcS :: TcRnMessage -> TcS a
warnTcS :: TcRnMessage -> TcS ()
addErrTcS :: TcRnMessage -> TcS ()
wrapTcS :: TcM a -> TcS a

-- | Emit a warning within the <a>TcS</a> monad at the location given by
--   the <a>CtLoc</a>.
ctLocWarnTcS :: CtLoc -> TcRnMessage -> TcS ()

-- | This can deal only with equality constraints.
runTcSEqualities :: TcS a -> TcM a
nestTcS :: TcS a -> TcS a
nestImplicTcS :: EvBindsVar -> TcLevel -> TcS a -> TcS a
setEvBindsTcS :: EvBindsVar -> TcS a -> TcS a
emitImplicationTcS :: TcLevel -> SkolemInfoAnon -> [TcTyVar] -> [EvVar] -> Cts -> TcS TcEvBinds
emitTvImplicationTcS :: TcLevel -> SkolemInfoAnon -> [TcTyVar] -> Cts -> TcS ()
emitFunDepWanteds :: CtEvidence -> [FunDepEqn (CtLoc, RewriterSet)] -> TcS Bool
selectNextWorkItem :: TcS (Maybe Ct)
getWorkList :: TcS WorkList
updWorkListTcS :: (WorkList -> WorkList) -> TcS ()
pushLevelNoWorkList :: SDoc -> TcS a -> TcS (TcLevel, a)
runTcPluginTcS :: TcPluginM a -> TcS a
recordUsedGREs :: Bag GlobalRdrElt -> TcS ()
matchGlobalInst :: DynFlags -> Bool -> Class -> [Type] -> CtLoc -> TcS ClsInstResult
data ClsInstResult
NoInstance :: ClsInstResult
OneInst :: [TcPredType] -> ([EvExpr] -> EvTerm) -> CanonicalEvidence -> InstanceWhat -> ClsInstResult
[cir_new_theta] :: ClsInstResult -> [TcPredType]
[cir_mk_ev] :: ClsInstResult -> [EvExpr] -> EvTerm
[cir_canonical] :: ClsInstResult -> CanonicalEvidence
[cir_what] :: ClsInstResult -> InstanceWhat
NotSure :: ClsInstResult
data QCInst
QCI :: CtEvidence -> [TcTyVar] -> TcPredType -> ExpansionFuel -> QCInst
[qci_ev] :: QCInst -> CtEvidence
[qci_tvs] :: QCInst -> [TcTyVar]
[qci_pred] :: QCInst -> TcPredType
[qci_pend_sc] :: QCInst -> ExpansionFuel
data StopOrContinue a
StartAgain :: Ct -> StopOrContinue a
ContinueWith :: !a -> StopOrContinue a
Stop :: CtEvidence -> SDoc -> StopOrContinue a
continueWith :: a -> TcS (StopOrContinue a)
stopWith :: CtEvidence -> String -> TcS (StopOrContinue a)
startAgainWith :: Ct -> TcS (StopOrContinue a)
newtype SolverStage a
Stage :: TcS (StopOrContinue a) -> SolverStage a
[runSolverStage] :: SolverStage a -> TcS (StopOrContinue a)
simpleStage :: TcS a -> SolverStage a
stopWithStage :: CtEvidence -> String -> SolverStage a
nopStage :: a -> SolverStage a
panicTcS :: SDoc -> TcS a
traceTcS :: String -> SDoc -> TcS ()
tryEarlyAbortTcS :: TcS ()
traceFireTcS :: CtEvidence -> SDoc -> TcS ()
bumpStepCountTcS :: TcS ()
csTraceTcS :: SDoc -> TcS ()
wrapErrTcS :: TcM a -> TcS a
wrapWarnTcS :: TcM a -> TcS a
resetUnificationFlag :: TcS Bool
setUnificationFlag :: TcLevel -> TcS ()
data MaybeNew
Fresh :: CtEvidence -> MaybeNew
Cached :: EvExpr -> MaybeNew
freshGoals :: [MaybeNew] -> [CtEvidence]
isFresh :: MaybeNew -> Bool
getEvExpr :: MaybeNew -> EvExpr

-- | <a>CanonicalEvidence</a> says whether a piece of evidence has a
--   singleton type; For example, given (d1 :: C Int), will any other (d2
--   :: C Int) do equally well? See Note [Coherence and specialisation:
--   overview] above, and Note [Desugaring non-canonical evidence] in
--   GHC.HsToCore.Binds
data CanonicalEvidence
EvCanonical :: CanonicalEvidence
EvNonCanonical :: CanonicalEvidence
newTcEvBinds :: TcS EvBindsVar
newNoTcEvBinds :: TcS EvBindsVar

-- | Create a new Wanted constraint holding a coercion hole for an equality
--   between the two types at the given <a>Role</a>.
newWantedEq :: CtLoc -> RewriterSet -> Role -> TcType -> TcType -> TcS (CtEvidence, Coercion)

-- | Emit a new Wanted equality into the work-list
emitNewWantedEq :: CtLoc -> RewriterSet -> Role -> TcType -> TcType -> TcS Coercion

-- | Create a new Wanted constraint, potentially looking up non-equality
--   constraints in the cache instead of creating a new one from scratch.
--   
--   Deals with both equality and non-equality constraints.
newWanted :: CtLoc -> RewriterSet -> PredType -> TcS MaybeNew

-- | Create a new Wanted constraint.
--   
--   Deals with both equality and non-equality constraints.
--   
--   Does not attempt to re-use non-equality constraints that already exist
--   in the inert set.
newWantedNC :: CtLoc -> RewriterSet -> PredType -> TcS CtEvidence

-- | Create a new Wanted constraint holding an evidence variable.
--   
--   Don't use this for equality constraints: use <a>newWantedEq</a>
--   instead.
newWantedEvVarNC :: CtLoc -> RewriterSet -> TcPredType -> TcS CtEvidence

-- | Make a new <a>Id</a> of the given type, bound (in the monad's EvBinds)
--   to the given term
newBoundEvVarId :: TcPredType -> EvTerm -> TcS EvVar
unifyTyVar :: TcTyVar -> TcType -> TcS ()
reportUnifications :: TcS a -> TcS (Int, a)
setEvBind :: EvBind -> TcS ()

-- | Equalities only
setWantedEq :: HasDebugCallStack => TcEvDest -> Coercion -> TcS ()

-- | Good for both equalities and non-equalities
setWantedEvTerm :: TcEvDest -> CanonicalEvidence -> EvTerm -> TcS ()
setEvBindIfWanted :: CtEvidence -> CanonicalEvidence -> EvTerm -> TcS ()
newEvVar :: TcPredType -> TcS EvVar
newGivenEvVar :: CtLoc -> (TcPredType, EvTerm) -> TcS CtEvidence
emitNewGivens :: CtLoc -> [(Role, TcCoercion)] -> TcS ()

-- | Checks if the depth of the given location is too much. Fails if it's
--   too big, with an appropriate error message.
checkReductionDepth :: CtLoc -> TcType -> TcS ()
getSolvedDicts :: TcS (DictMap DictCt)
setSolvedDicts :: DictMap DictCt -> TcS ()
getInstEnvs :: TcS InstEnvs
getFamInstEnvs :: TcS (FamInstEnv, FamInstEnv)
getTopEnv :: TcS HscEnv
getGblEnv :: TcS TcGblEnv
getLclEnv :: TcS TcLclEnv
setSrcSpan :: RealSrcSpan -> TcS a -> TcS a
getTcEvBindsVar :: TcS EvBindsVar
getTcLevel :: TcS TcLevel
getTcEvTyCoVars :: EvBindsVar -> TcS TyCoVarSet
getTcEvBindsMap :: EvBindsVar -> TcS EvBindMap
setTcEvBindsMap :: EvBindsVar -> EvBindMap -> TcS ()
tcLookupClass :: Name -> TcS Class
tcLookupId :: Name -> TcS Id
tcLookupTyCon :: Name -> TcS TyCon
updInertSet :: (InertSet -> InertSet) -> TcS ()
updInertCans :: (InertCans -> InertCans) -> TcS ()
getHasGivenEqs :: TcLevel -> TcS (HasGivenEqs, InertIrreds)
setInertCans :: InertCans -> TcS ()
getInertEqs :: TcS InertEqs
getInertCans :: TcS InertCans
getInertGivens :: TcS [Ct]

-- | Retrieves all insoluble constraints from the inert set, specifically
--   including Given constraints.
--   
--   This consists of:
--   
--   <ul>
--   <li>insoluble equalities, such as <tt>Int ~# Bool</tt>;</li>
--   <li>constraints that are top-level custom type errors, of the form
--   <tt>TypeError msg</tt>, but not constraints such as <tt>Eq (TypeError
--   msg)</tt> in which the type error is nested;</li>
--   <li>unsatisfiable constraints, of the form <tt>Unsatisfiable
--   msg</tt>.</li>
--   </ul>
--   
--   The inclusion of Givens is important for pattern match warnings, as we
--   want to consider a pattern match that introduces insoluble Givens to
--   be redundant (see Note [Pattern match warnings with insoluble Givens]
--   in GHC.Tc.Solver).
getInertInsols :: TcS Cts
getInnermostGivenEqLevel :: TcS TcLevel
getInertSet :: TcS InertSet
setInertSet :: InertSet -> TcS ()
getUnsolvedInerts :: TcS (Bag Implication, Cts)

-- | Remove inert constraints from the <a>InertCans</a>, for use when a
--   typechecker plugin wishes to discard a given.
removeInertCts :: [Ct] -> InertCans -> InertCans
getPendingGivenScs :: TcS [Ct]
insertFunEq :: FunEqMap a -> TyCon -> [Type] -> a -> FunEqMap a
addInertForAll :: QCInst -> TcS ()
emitWorkNC :: [CtEvidence] -> TcS ()
emitWork :: Cts -> TcS ()

-- | Look up a dictionary inert.
lookupInertDict :: InertCans -> CtLoc -> Class -> [Type] -> Maybe DictCt
kickOutAfterUnification :: [TcTyVar] -> TcS ()
kickOutRewritable :: KickOutSpec -> CtFlavourRole -> TcS ()
addInertSafehask :: InertCans -> DictCt -> InertCans
insertSafeOverlapFailureTcS :: InstanceWhat -> DictCt -> TcS ()
updInertSafehask :: (DictMap DictCt -> DictMap DictCt) -> TcS ()
getSafeOverlapFailures :: TcS (Bag DictCt)
updSolvedDicts :: InstanceWhat -> DictCt -> TcS ()

-- | Look up a solved inert.
lookupSolvedDict :: InertSet -> CtLoc -> Class -> [Type] -> Maybe CtEvidence
foldIrreds :: (IrredCt -> b -> b) -> InertIrreds -> b -> b

-- | Looks up a family application in the inerts.
lookupFamAppInert :: (CtFlavourRole -> Bool) -> TyCon -> [Type] -> TcS (Maybe (Reduction, CtFlavourRole))
lookupFamAppCache :: TyCon -> [Type] -> TcS (Maybe Reduction)
extendFamAppCache :: TyCon -> [Type] -> Reduction -> TcS ()
pprKicked :: Int -> SDoc
instDFunType :: DFunId -> [DFunInstType] -> TcS ([TcType], TcThetaType)
wrapUnifierTcS :: CtEvidence -> Role -> (UnifyEnv -> TcM a) -> TcS (a, Bag Ct, [TcTyVar])
unifyFunDeps :: CtEvidence -> Role -> (UnifyEnv -> TcM ()) -> TcS Bool
uPairsTcM :: UnifyEnv -> [TypeEqn] -> TcM ()
unifyForAllBody :: CtEvidence -> Role -> (UnifyEnv -> TcM a) -> TcS (a, Cts)
newFlexiTcSTy :: Kind -> TcS TcType
instFlexiX :: Subst -> [TKVar] -> TcS Subst
cloneMetaTyVar :: TcTyVar -> TcS TcTyVar
tcInstSkolTyVarsX :: SkolemInfo -> Subst -> [TyVar] -> TcS (Subst, [TcTyVar])
data TcLevel
isFilledMetaTyVar_maybe :: TcTyVar -> TcS (Maybe Type)
isFilledMetaTyVar :: TcTyVar -> TcS Bool
isUnfilledMetaTyVar :: TcTyVar -> TcS Bool
zonkTyCoVarsAndFV :: TcTyCoVarSet -> TcS TcTyCoVarSet
zonkTcType :: TcType -> TcS TcType
zonkTcTypes :: [TcType] -> TcS [TcType]
zonkTcTyVar :: TcTyVar -> TcS TcType
zonkCo :: Coercion -> TcS Coercion
zonkTyCoVarsAndFVList :: [TcTyCoVar] -> TcS [TcTyCoVar]
zonkSimples :: Cts -> TcS Cts
zonkWC :: WantedConstraints -> TcS WantedConstraints
zonkTyCoVarKind :: TcTyCoVar -> TcS TcTyCoVar
newTcRef :: a -> TcS (TcRef a)
readTcRef :: TcRef a -> TcS a
writeTcRef :: TcRef a -> a -> TcS ()
updTcRef :: TcRef a -> (a -> a) -> TcS ()
getDefaultInfo :: TcS (DefaultEnv, Bool)
getDynFlags :: HasDynFlags m => m DynFlags
getGlobalRdrEnvTcS :: TcS GlobalRdrEnv
matchFam :: TyCon -> [Type] -> TcS (Maybe ReductionN)
matchFamTcM :: TyCon -> [Type] -> TcM (Maybe ReductionN)
checkWellStagedDFun :: CtLoc -> InstanceWhat -> PredType -> TcS ()
pprEq :: TcType -> TcType -> SDoc
checkTypeEq :: CtEvidence -> EqRel -> CanEqLHS -> TcType -> TcS (PuResult () Reduction)
checkTouchableTyVarEq :: CtEvidence -> TcTyVar -> TcType -> TcS (PuResult () Reduction)
instance GHC.Internal.Base.Applicative GHC.Tc.Solver.Monad.SolverStage
instance GHC.Internal.Base.Applicative GHC.Tc.Solver.Monad.TcS
instance GHC.Internal.Base.Functor GHC.Tc.Solver.Monad.SolverStage
instance GHC.Internal.Base.Functor GHC.Tc.Solver.Monad.StopOrContinue
instance GHC.Internal.Base.Functor GHC.Tc.Solver.Monad.TcS
instance GHC.Driver.DynFlags.HasDynFlags GHC.Tc.Solver.Monad.TcS
instance GHC.Unit.Module.HasModule GHC.Tc.Solver.Monad.TcS
instance GHC.Internal.Control.Monad.Fail.MonadFail GHC.Tc.Solver.Monad.TcS
instance GHC.Internal.Control.Monad.Fix.MonadFix GHC.Tc.Solver.Monad.TcS
instance GHC.Internal.Control.Monad.IO.Class.MonadIO GHC.Tc.Solver.Monad.TcS
instance GHC.Internal.Base.Monad GHC.Tc.Solver.Monad.SolverStage
instance GHC.Internal.Base.Monad GHC.Tc.Solver.Monad.TcS
instance GHC.Types.TyThing.MonadThings GHC.Tc.Solver.Monad.TcS
instance GHC.Types.Unique.Supply.MonadUnique GHC.Tc.Solver.Monad.TcS
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Tc.Solver.Monad.StopOrContinue a)

module GHC.Tc.Solver.Rewrite

-- | See Note [Rewriting]. If (xi, co, rewriters) &lt;- rewrite mode ev ty,
--   then co :: xi ~r ty where r is the role in <tt>ev</tt>. rewriters is
--   the set of coercion holes that have been used to rewrite See Note
--   [Wanteds rewrite Wanteds] in GHC.Tc.Types.Constraint
rewrite :: CtEvidence -> TcType -> TcS (Reduction, RewriterSet)

-- | See Note [Rewriting] <a>rewriteForErrors</a> is a variant of
--   <a>rewrite</a> that rewrites w.r.t. nominal equality only, as this is
--   better than full rewriting for error messages. (This was important
--   when we flirted with rewriting newtypes but perhaps less so now.)
rewriteForErrors :: CtEvidence -> TcType -> TcS (Reduction, RewriterSet)
rewriteArgsNom :: CtEvidence -> TyCon -> [TcType] -> TcS (Reductions, RewriterSet)

-- | Rewrite a type w.r.t. nominal equality. This is useful to rewrite a
--   type w.r.t. any givens. It does not do type-family reduction. This
--   will never emit new constraints. Call this when the inert set contains
--   only givens.
rewriteType :: CtLoc -> TcType -> TcS TcType
instance GHC.Internal.Base.Applicative GHC.Tc.Solver.Rewrite.RewriteM
instance GHC.Internal.Base.Functor GHC.Tc.Solver.Rewrite.RewriteM
instance GHC.Driver.DynFlags.HasDynFlags GHC.Tc.Solver.Rewrite.RewriteM
instance GHC.Internal.Base.Monad GHC.Tc.Solver.Rewrite.RewriteM


-- | This module provides an interface for typechecker plugins to access
--   select functions of the <tt>TcM</tt>, principally those to do with
--   reading parts of the state.
module GHC.Tc.Plugin

-- | <a>TcPluginM</a> is the monad in which type-checking plugins operate.
data TcPluginM a

-- | Perform some IO, typically to interact with an external tool.
tcPluginIO :: IO a -> TcPluginM a

-- | Output useful for debugging the compiler.
tcPluginTrace :: String -> SDoc -> TcPluginM ()

-- | This function provides an escape for direct access to the <tt>TcM</tt>
--   monad. It should not be used lightly, and the provided
--   <a>TcPluginM</a> API should be favoured instead.
unsafeTcPluginTcM :: TcM a -> TcPluginM a

-- | The result of searching for an imported module.
--   
--   NB: FindResult manages both user source-import lookups (which can
--   result in <a>Module</a>) as well as direct imports for interfaces
--   (which always result in <a>InstalledModule</a>).
data FindResult

-- | The module was found
Found :: ModLocation -> Module -> FindResult

-- | The requested unit was not found
NoPackage :: Unit -> FindResult

-- | _Error_: both in multiple packages
FoundMultiple :: [(Module, ModuleOrigin)] -> FindResult

-- | Not found
NotFound :: [FilePath] -> Maybe Unit -> [Unit] -> [Unit] -> [UnusableUnit] -> [ModuleSuggestion] -> FindResult

-- | Places where I looked
[fr_paths] :: FindResult -> [FilePath]

-- | Just p =&gt; module is in this unit's manifest, but couldn't find the
--   .hi file
[fr_pkg] :: FindResult -> Maybe Unit

-- | Module is in these units, but the *module* is hidden
[fr_mods_hidden] :: FindResult -> [Unit]

-- | Module is in these units, but the *unit* is hidden
[fr_pkgs_hidden] :: FindResult -> [Unit]

-- | Module is in these units, but it is unusable
[fr_unusables] :: FindResult -> [UnusableUnit]

-- | Possible mis-spelled modules
[fr_suggestions] :: FindResult -> [ModuleSuggestion]
findImportedModule :: ModuleName -> PkgQual -> TcPluginM FindResult
lookupOrig :: Module -> OccName -> TcPluginM Name
tcLookupGlobal :: Name -> TcPluginM TyThing
tcLookupTyCon :: Name -> TcPluginM TyCon
tcLookupDataCon :: Name -> TcPluginM DataCon
tcLookupClass :: Name -> TcPluginM Class
tcLookup :: Name -> TcPluginM TcTyThing
tcLookupId :: Name -> TcPluginM Id
getTopEnv :: TcPluginM HscEnv
getTargetPlatform :: TcPluginM Platform
getEnvs :: TcPluginM (TcGblEnv, TcLclEnv)
getInstEnvs :: TcPluginM InstEnvs
getFamInstEnvs :: TcPluginM (FamInstEnv, FamInstEnv)
matchFam :: TyCon -> [Type] -> TcPluginM (Maybe Reduction)
newUnique :: TcPluginM Unique
newFlexiTyVar :: Kind -> TcPluginM TcTyVar
isTouchableTcPluginM :: TcTyVar -> TcPluginM Bool

-- | Confused by zonking? See Note [What is zonking?] in
--   <a>GHC.Tc.Zonk.Type</a>.
zonkTcType :: TcType -> TcPluginM TcType
zonkCt :: Ct -> TcPluginM Ct

-- | Create a new Wanted constraint with the given <a>CtLoc</a>.
newWanted :: CtLoc -> PredType -> TcPluginM CtEvidence

-- | Create a new given constraint, with the supplied evidence.
--   
--   This should only be invoked within <tt>tcPluginSolve</tt>.
newGiven :: EvBindsVar -> CtLoc -> PredType -> EvExpr -> TcPluginM CtEvidence

-- | Create a fresh coercion hole. This should only be invoked within
--   <tt>tcPluginSolve</tt>.
newCoercionHole :: PredType -> TcPluginM CoercionHole

-- | Create a fresh evidence variable.
--   
--   This should only be invoked within <tt>tcPluginSolve</tt>.
newEvVar :: PredType -> TcPluginM EvVar

-- | Bind an evidence variable.
--   
--   This should only be invoked within <tt>tcPluginSolve</tt>.
setEvBind :: EvBindsVar -> EvBind -> TcPluginM ()


-- | Solving Class constraints CDictCan
module GHC.Tc.Solver.Dict
solveDict :: DictCt -> SolverStage Void
solveDictNC :: CtEvidence -> Class -> [Type] -> SolverStage Void
checkInstanceOK :: CtLoc -> InstanceWhat -> TcPredType -> TcS CtLoc
matchLocalInst :: TcPredType -> CtLoc -> TcS ClsInstResult
chooseInstance :: CtEvidence -> ClsInstResult -> TcS (StopOrContinue a)
makeSuperClasses :: [Ct] -> TcS [Ct]
mkStrictSuperClasses :: ExpansionFuel -> CtEvidence -> [TyVar] -> ThetaType -> Class -> [Type] -> TcS [Ct]
solveCallStack :: CtEvidence -> EvCallStack -> TcS ()

module GHC.Tc.Solver.Irred
solveIrred :: IrredCt -> SolverStage Void

module GHC.Tc.Solver.Equality
solveEquality :: CtEvidence -> EqRel -> Type -> Type -> SolverStage Void

module GHC.Tc.Solver.Solve
solveSimpleGivens :: [Ct] -> TcS ()
solveSimpleWanteds :: Cts -> TcS WantedConstraints

module GHC.Tc.Solver

-- | How should we choose which constraints to quantify over?
data InferMode

-- | Apply the monomorphism restriction, never quantifying over any
--   constraints
ApplyMR :: InferMode

-- | See Note [TcRnExprMode] in <a>GHC.Tc.Module</a>, the :type +d case;
--   this mode refuses to quantify over any defaultable constraint
EagerDefaulting :: InferMode

-- | Quantify over any constraint that satisfies pickQuantifiablePreds
NoRestrictions :: InferMode
simplifyInfer :: TcLevel -> InferMode -> [TcIdSigInst] -> [(Name, TcTauType)] -> WantedConstraints -> TcM ([TcTyVar], [EvVar], TcEvBinds, Bool)
findInferredDiff :: TcThetaType -> TcThetaType -> TcM TcThetaType
growThetaTyVars :: ThetaType -> TyCoVarSet -> TyCoVarSet
simplifyAmbiguityCheck :: Type -> WantedConstraints -> TcM ()
simplifyDefault :: ThetaType -> TcM Bool
simplifyTop :: WantedConstraints -> TcM (Bag EvBind)
simplifyTopImplic :: Bag Implication -> TcM ()
simplifyInteractive :: WantedConstraints -> TcM (Bag EvBind)

-- | Type-check a thing that emits only equality constraints, solving any
--   constraints we can and re-emitting constraints that we can't. Use this
--   variant only when we'll get another crack at it later See Note
--   [Failure in local type signatures]
--   
--   Panics if we solve any non-equality constraints. (In runTCSEqualities
--   we use an error thunk for the evidence bindings.)
solveEqualities :: String -> TcM a -> TcM a
pushLevelAndSolveEqualities :: SkolemInfoAnon -> [TyConBinder] -> TcM a -> TcM a
pushLevelAndSolveEqualitiesX :: String -> TcM a -> TcM (TcLevel, WantedConstraints, a)
reportUnsolvedEqualities :: SkolemInfo -> [TcTyVar] -> TcLevel -> WantedConstraints -> TcM ()
simplifyWantedsTcM :: [CtEvidence] -> TcM WantedConstraints

-- | Return (Just new_inerts) if the Givens are satisfiable, Nothing if
--   definitely contradictory.
--   
--   See Note [Pattern match warnings with insoluble Givens] above.
tcCheckGivens :: InertSet -> Bag EvVar -> TcM (Maybe InertSet)

-- | Return True if the Wanteds are soluble, False if not
tcCheckWanteds :: InertSet -> ThetaType -> TcM Bool

-- | Normalise a type as much as possible using the given constraints. See
--   <tt>Note [tcNormalise]</tt>.
tcNormalise :: InertSet -> Type -> TcM Type
captureTopConstraints :: TcM a -> TcM (a, WantedConstraints)

-- | Simplify top-level constraints, but without reporting any unsolved
--   constraints nor unsafe overlapping.
simplifyTopWanteds :: WantedConstraints -> TcS WantedConstraints
promoteTyVarSet :: HasDebugCallStack => TcTyVarSet -> TcM Bool
simplifyAndEmitFlatConstraints :: WantedConstraints -> TcM ()
solveWanteds :: WantedConstraints -> TcS WantedConstraints
approximateWC :: Bool -> WantedConstraints -> Cts
instance GHC.Utils.Outputable.Outputable GHC.Tc.Solver.InferMode
instance GHC.Utils.Outputable.Outputable GHC.Tc.Solver.Proposal
instance GHC.Utils.Outputable.Outputable GHC.Tc.Solver.ProposalSequence

module GHC.Tc.Validity
data Rank
ArbitraryRank :: Rank
LimitedRank :: Bool -> Rank -> Rank
MonoTypeRankZero :: Rank
MonoTypeTyConArg :: Rank
MonoTypeSynArg :: Rank
MonoTypeConstraint :: Rank
MustBeMonoType :: Rank

-- | UserTypeCtxt describes the origin of the polymorphic type in the
--   places where we need an expression to have that type
data UserTypeCtxt
FunSigCtxt :: Name -> ReportRedundantConstraints -> UserTypeCtxt
InfSigCtxt :: Name -> UserTypeCtxt
ExprSigCtxt :: ReportRedundantConstraints -> UserTypeCtxt
KindSigCtxt :: UserTypeCtxt
StandaloneKindSigCtxt :: Name -> UserTypeCtxt
TypeAppCtxt :: UserTypeCtxt
ConArgCtxt :: Name -> UserTypeCtxt
TySynCtxt :: Name -> UserTypeCtxt
PatSynCtxt :: Name -> UserTypeCtxt
PatSigCtxt :: UserTypeCtxt
RuleSigCtxt :: FastString -> Name -> UserTypeCtxt
ForSigCtxt :: Name -> UserTypeCtxt
DefaultDeclCtxt :: UserTypeCtxt
InstDeclCtxt :: Bool -> UserTypeCtxt
SpecInstCtxt :: UserTypeCtxt
GenSigCtxt :: UserTypeCtxt
GhciCtxt :: Bool -> UserTypeCtxt
ClassSCCtxt :: Name -> UserTypeCtxt
SigmaCtxt :: UserTypeCtxt
DataTyCtxt :: Name -> UserTypeCtxt
DerivClauseCtxt :: UserTypeCtxt
TyVarBndrKindCtxt :: Name -> UserTypeCtxt
DataKindCtxt :: Name -> UserTypeCtxt
TySynKindCtxt :: Name -> UserTypeCtxt
TyFamResKindCtxt :: Name -> UserTypeCtxt
checkValidType :: UserTypeCtxt -> Type -> TcM ()
checkValidMonoType :: Type -> TcM ()
checkValidTheta :: UserTypeCtxt -> ThetaType -> TcM ()
checkValidInstance :: UserTypeCtxt -> LHsSigType GhcRn -> Type -> TcM ()
checkValidInstHead :: UserTypeCtxt -> Class -> [Type] -> TcM ()
validDerivPred :: PatersonSize -> PredType -> Bool
checkTySynRhs :: UserTypeCtxt -> TcType -> TcM ()
checkEscapingKind :: Type -> TcM ()
checkValidCoAxiom :: CoAxiom Branched -> TcM ()
checkValidCoAxBranch :: TyCon -> CoAxBranch -> TcM ()

-- | Check binders for a type or data family declaration.
--   
--   Specifically, this function checks for:
--   
--   <ul>
--   <li>type variables used on the RHS but not bound (explicitly or
--   implicitly) in the LHS,</li>
--   <li>variables bound by a forall in the LHS but not used in the
--   RHS.</li>
--   </ul>
--   
--   See Note [Check type family instance binders].
checkFamPatBinders :: TyCon -> [TcTyVar] -> TyVarSet -> [TcType] -> TcType -> TcM ()

-- | Perform scoping check on a type family equation.
--   
--   See <a>TyFamEqnValidityInfo</a>.
checkTyFamEqnValidityInfo :: TyCon -> TyFamEqnValidityInfo -> TcM ()

-- | Do validity checks on a type family equation, including consistency
--   with any enclosing class instance head, termination, and lack of
--   polytypes.
--   
--   See also the separate <a>checkFamPatBinders</a> which performs scoping
--   checks on a type family equation. (It's separate because it expects
--   <a>TyFamEqnValidityInfo</a>, which comes from a separate place e.g.
--   for associated type defaults.)
checkValidTyFamEqn :: TyCon -> [Type] -> Type -> TcM ()

-- | Checks that an associated type family default:
--   
--   <ol>
--   <li>Only consists of arguments that are bare type variables, and</li>
--   <li>Has a distinct type variable in each argument.</li>
--   </ol>
--   
--   See <tt>Note [Type-checking default assoc decls]</tt> in
--   <a>GHC.Tc.TyCl</a>.
checkValidAssocTyFamDeflt :: TyCon -> [Type] -> TcM ()
checkConsistentFamInst :: AssocInstInfo -> TyCon -> CoAxBranch -> TcM ()
checkTyConTelescope :: TyCon -> TcM ()
instance GHC.Classes.Eq GHC.Tc.Validity.TypeOrKindCtxt
instance GHC.Utils.Outputable.Outputable GHC.Tc.Validity.ExpandMode
instance GHC.Utils.Outputable.Outputable GHC.Tc.Validity.TypeOrKindCtxt
instance GHC.Utils.Outputable.Outputable GHC.Tc.Validity.ValidityEnv

module GHC.Tc.Errors.Hole
findValidHoleFits :: TidyEnv -> [Implication] -> [CtEvidence] -> Hole -> TcM (TidyEnv, ValidHoleFits)

-- | A tcSubsumes which takes into account relevant constraints, to fix
--   #14273. This makes sure that when checking whether a type fits the
--   hole, the type has to be subsumed by type of the hole as well as
--   fulfill all constraints on the type of the hole.
tcCheckHoleFit :: TypedHole -> TcSigmaType -> TcSigmaType -> TcM (Bool, HsWrapper)

-- | Takes a list of free variables and restores any Flexi type variables
--   in free_vars after the action is run.
withoutUnification :: FV -> TcM a -> TcM a

-- | Reports whether first type (ty_a) subsumes the second type (ty_b),
--   discarding any errors. Subsumption here means that the ty_b can fit
--   into the ty_a, i.e. `tcSubsumes a b == True` if b is a subtype of a.
tcSubsumes :: TcSigmaType -> TcSigmaType -> TcM Bool

-- | Checks whether a MetaTyVar is flexible or not.
isFlexiTyVar :: TcTyVar -> TcM Bool

-- | tcFilterHoleFits filters the candidates by whether, given the
--   implications and the relevant constraints, they can be made to match
--   the type by running the type checker. Stops after finding limit
--   matches.
tcFilterHoleFits :: Maybe Int -> TypedHole -> (TcType, [TcTyVar]) -> [HoleFitCandidate] -> TcM (Bool, [HoleFit])
getLocalBindings :: TidyEnv -> CtLoc -> TcM [Id]
pprHoleFit :: HoleFitDispConfig -> HoleFit -> SDoc
addHoleFitDocs :: [HoleFit] -> TcM [HoleFit]
getHoleFitSortingAlg :: TcM HoleFitSortingAlg
getHoleFitDispConfig :: TcM HoleFitDispConfig

-- | Configuration for pretty-printing valid hole fits.
data HoleFitDispConfig
HFDC :: Bool -> Bool -> Bool -> Bool -> Bool -> HoleFitDispConfig
[showWrap] :: HoleFitDispConfig -> Bool
[showWrapVars] :: HoleFitDispConfig -> Bool
[showType] :: HoleFitDispConfig -> Bool
[showProv] :: HoleFitDispConfig -> Bool
[showMatches] :: HoleFitDispConfig -> Bool
data HoleFitSortingAlg
HFSNoSorting :: HoleFitSortingAlg
HFSBySize :: HoleFitSortingAlg
HFSBySubsumption :: HoleFitSortingAlg
relevantCtEvidence :: Type -> [CtEvidence] -> [CtEvidence]
zonkSubs :: TidyEnv -> [HoleFit] -> ZonkM (TidyEnv, [HoleFit])
sortHoleFitsByGraph :: [HoleFit] -> TcM [HoleFit]

-- | Sort by size uses as a measure for relevance the sizes of the
--   different types needed to instantiate the fit to the type of the hole.
--   This is much quicker than sorting by subsumption, and gives reasonable
--   results in most cases.
sortHoleFitsBySize :: [HoleFit] -> TcM [HoleFit]

-- | A HoleFitPlugin is a pair of candidate and fit plugins.
data HoleFitPlugin
HoleFitPlugin :: CandPlugin -> FitPlugin -> HoleFitPlugin
[candPlugin] :: HoleFitPlugin -> CandPlugin
[fitPlugin] :: HoleFitPlugin -> FitPlugin

-- | HoleFitPluginR adds a TcRef to hole fit plugins so that plugins can
--   track internal state. Note the existential quantification, ensuring
--   that the state cannot be modified from outside the plugin.
data HoleFitPluginR
HoleFitPluginR :: TcM (TcRef s) -> (TcRef s -> HoleFitPlugin) -> (TcRef s -> TcM ()) -> HoleFitPluginR

-- | Initializes the TcRef to be passed to the plugin
[hfPluginInit] :: HoleFitPluginR -> TcM (TcRef s)

-- | The function defining the plugin itself
[hfPluginRun] :: HoleFitPluginR -> TcRef s -> HoleFitPlugin

-- | Cleanup of state, guaranteed to be called even on error
[hfPluginStop] :: HoleFitPluginR -> TcRef s -> TcM ()
instance GHC.Classes.Eq GHC.Tc.Errors.Hole.HoleFitSortingAlg
instance GHC.Classes.Ord GHC.Tc.Errors.Hole.HoleFitSortingAlg


-- | Expand <tt>Do</tt> block statements into <tt>(&gt;&gt;=)</tt>,
--   <tt>(&gt;&gt;)</tt> and <tt>let</tt>s After renaming but right ebefore
--   type checking
module GHC.Tc.Gen.Do

-- | Expand the `do`-statments into expressions right after renaming so
--   that they can be typechecked. See Note [Expanding HsDo with
--   XXExprGhcRn] below for <a>HsDo</a> specific commentary and Note
--   [Handling overloaded and rebindable constructs] for high level
--   commentary
expandDoStmts :: HsDoFlavour -> [ExprLStmt GhcRn] -> TcM (LHsExpr GhcRn)

module GHC.Rename.Names

-- | Process Import Decls. See <a>rnImportDecl</a> for a description of
--   what the return types represent. Note: Do the non SOURCE ones first,
--   so that we get a helpful warning for SOURCE ones that are unnecessary
rnImports :: [(LImportDecl GhcPs, SDoc)] -> RnM ([LImportDecl GhcRn], [ImportUserSpec], GlobalRdrEnv, ImportAvails, [(Module, IfaceDefault)], AnyHpcUsage)
getLocalNonValBinders :: MiniFixityEnv -> HsGroup GhcPs -> RnM ((TcGblEnv, TcLclEnv), NameSet)
newRecordFieldLabel :: DuplicateRecordFields -> FieldSelectors -> [Name] -> LFieldOcc GhcPs -> RnM FieldLabel
importsFromIface :: HscEnv -> ModIface -> ImpDeclSpec -> Maybe NameSet -> GlobalRdrEnv

-- | The import specification as written by the user, including the list of
--   explicitly imported names. Used in <tt>ModIface</tt> to allow GHCi to
--   reconstruct the top level environment on demand.
--   
--   This is distinct from <a>ImportSpec</a> because we don't want to store
--   the list of explicitly imported names along with each <a>GRE</a>
--   
--   We don't want to store the entire GlobalRdrEnv for modules that are
--   imported without explicit export lists, as these may grow to be very
--   large. However, GlobalRdrEnvs which are the result of explicit import
--   lists are typically quite small.
--   
--   Why do we not store something like (Maybe (ImportListInterpretation,
--   [IE GhcPs]) in such a case? Because we don't want to store source
--   syntax including annotations in interface files.
data ImportUserSpec
ImpUserSpec :: !ImpDeclSpec -> !ImpUserList -> ImportUserSpec
[ius_decl] :: ImportUserSpec -> !ImpDeclSpec
[ius_imports] :: ImportUserSpec -> !ImpUserList
extendGlobalRdrEnvRn :: [GlobalRdrElt] -> MiniFixityEnv -> RnM (TcGblEnv, TcLclEnv)

-- | All the <a>GlobalRdrElt</a>s associated with a collection of
--   <a>AvailInfo</a>s.
gresFromAvails :: HscEnv -> Maybe ImportSpec -> [AvailInfo] -> [GlobalRdrElt]

-- | Calculate the <a>ImportAvails</a> induced by an import of a particular
--   interface, but without <a>imp_mods</a>.
calculateAvails :: HomeUnit -> Set UnitId -> ModIface -> IsSafeImport -> IsBootInterface -> ImportedBy -> ImportAvails
reportUnusedNames :: TcGblEnv -> HscSource -> RnM ()
checkConName :: RdrName -> TcRn ()
mkChildEnv :: [GlobalRdrElt] -> NameEnv [GlobalRdrElt]
findChildren :: NameEnv [a] -> Name -> [a]
findImportUsage :: [LImportDecl GhcRn] -> [GlobalRdrElt] -> [ImportDeclUsage]
getMinimalImports :: [ImportDeclUsage] -> RnM [LImportDecl GhcRn]
printMinimalImports :: HscSource -> [ImportDeclUsage] -> RnM ()

-- | Rename raw package imports
renamePkgQual :: UnitEnv -> ModuleName -> Maybe FastString -> PkgQual

-- | Rename raw package imports
renameRawPkgQual :: UnitEnv -> ModuleName -> RawPkgQual -> PkgQual
classifyGREs :: [GlobalRdrElt] -> ([GlobalRdrElt], [FieldGlobalRdrElt])
type ImportDeclUsage = (LImportDecl GhcRn, [GlobalRdrElt], [Name])
instance GHC.Utils.Outputable.Outputable GHC.Rename.Names.ImpOccItem

module GHC.Rename.HsType
rnHsType :: HsDocContext -> HsType GhcPs -> RnM (HsType GhcRn, FreeVars)
rnLHsType :: HsDocContext -> LHsType GhcPs -> RnM (LHsType GhcRn, FreeVars)
rnLHsTypes :: HsDocContext -> [LHsType GhcPs] -> RnM ([LHsType GhcRn], FreeVars)
rnContext :: HsDocContext -> LHsContext GhcPs -> RnM (LHsContext GhcRn, FreeVars)
rnMaybeContext :: HsDocContext -> Maybe (LHsContext GhcPs) -> RnM (Maybe (LHsContext GhcRn), FreeVars)
rnLHsKind :: HsDocContext -> LHsKind GhcPs -> RnM (LHsKind GhcRn, FreeVars)
rnLHsTypeArgs :: HsDocContext -> [LHsTypeArg GhcPs] -> RnM ([LHsTypeArg GhcRn], FreeVars)
rnHsSigType :: HsDocContext -> TypeOrKind -> LHsSigType GhcPs -> RnM (LHsSigType GhcRn, FreeVars)
rnHsWcType :: HsDocContext -> LHsWcType GhcPs -> RnM (LHsWcType GhcRn, FreeVars)
rnHsTyLit :: HsTyLit GhcPs -> RnM (HsTyLit GhcRn)
rnHsArrowWith :: (LocatedA (mult GhcPs) -> RnM (LocatedA (mult GhcRn), FreeVars)) -> HsArrowOf (LocatedA (mult GhcPs)) GhcPs -> RnM (HsArrowOf (LocatedA (mult GhcRn)) GhcRn, FreeVars)
data HsPatSigTypeScoping

-- | Always bind any free tyvars of the given type, regardless of whether
--   we have a forall at the top.
--   
--   For pattern type sigs, we <i>do</i> want to bring those type variables
--   into scope, even if there's a forall at the top which usually stops
--   that happening, e.g:
--   
--   <pre>
--   \ (x :: forall a. a -&gt; b) -&gt; e
--   </pre>
--   
--   Here we do bring <tt>b</tt> into scope.
--   
--   RULES can also use <a>AlwaysBind</a>, such as in the following
--   example:
--   
--   <pre>
--   {-# RULES \"f\" forall (x :: forall a. a -&gt; b). f x = ... b ... #-}
--   </pre>
--   
--   This only applies to RULES that do not explicitly bind their type
--   variables. If a RULE explicitly quantifies its type variables, then
--   <a>NeverBind</a> is used instead. See also <tt>Note [Pattern signature
--   binders and scoping]</tt> in <a>GHC.Hs.Type</a>.
AlwaysBind :: HsPatSigTypeScoping

-- | Never bind any free tyvars. This is used for RULES that have both
--   explicit type and term variable binders, e.g.:
--   
--   <pre>
--   {-# RULES \"const\" forall a. forall (x :: a) y. const x y = x #-}
--   </pre>
--   
--   The presence of the type variable binder <tt>forall a.</tt> implies
--   that the free variables in the types of the term variable binders
--   <tt>x</tt> and <tt>y</tt> are <i>not</i> bound. In the example above,
--   there are no such free variables, but if the user had written <tt>(y
--   :: b)</tt> instead of <tt>y</tt> in the term variable binders, then
--   <tt>b</tt> would be rejected for being out of scope. See also <tt>Note
--   [Pattern signature binders and scoping]</tt> in <a>GHC.Hs.Type</a>.
NeverBind :: HsPatSigTypeScoping
rnHsSigWcType :: HsDocContext -> LHsSigWcType GhcPs -> RnM (LHsSigWcType GhcRn, FreeVars)
rnHsPatSigType :: HsPatSigTypeScoping -> HsDocContext -> HsPatSigType GhcPs -> (HsPatSigType GhcRn -> RnM (a, FreeVars)) -> RnM (a, FreeVars)
rnHsPatSigKind :: HsPatSigTypeScoping -> HsDocContext -> HsPatSigType GhcPs -> (HsPatSigType GhcRn -> RnM (a, FreeVars)) -> RnM (a, FreeVars)
newTyVarNameRn :: Maybe a -> LocatedN RdrName -> RnM Name
rnConDeclFields :: HsDocContext -> [FieldLabel] -> [LConDeclField GhcPs] -> RnM ([LConDeclField GhcRn], FreeVars)
lookupField :: FastStringEnv FieldLabel -> FieldOcc GhcPs -> FieldOcc GhcRn
mkHsOpTyRn :: PromotionFlag -> LocatedN Name -> Fixity -> LHsType GhcRn -> LHsType GhcRn -> RnM (HsType GhcRn)
rnLTyVar :: LocatedN RdrName -> RnM (LocatedN Name)
rnScaledLHsType :: HsDocContext -> HsScaled GhcPs (LHsType GhcPs) -> RnM (HsScaled GhcRn (LHsType GhcRn), FreeVars)
data NegationHandling
ReassociateNegation :: NegationHandling
KeepNegationIntact :: NegationHandling
mkOpAppRn :: NegationHandling -> LHsExpr GhcRn -> LHsExpr GhcRn -> Fixity -> LHsExpr GhcRn -> RnM (HsExpr GhcRn)
mkNegAppRn :: LHsExpr GhcRn -> SyntaxExpr GhcRn -> RnM (HsExpr GhcRn)
mkConOpPatRn :: LocatedN Name -> Fixity -> LPat GhcRn -> LPat GhcRn -> RnM (Pat GhcRn)
checkPrecMatch :: Name -> MatchGroup GhcRn body -> RnM ()
checkSectionPrec :: FixityDirection -> HsExpr GhcPs -> LHsExpr GhcRn -> LHsExpr GhcRn -> RnM ()
bindHsOuterTyVarBndrs :: OutputableBndrFlag flag 'Renamed => HsDocContext -> Maybe assoc -> FreeKiTyVars -> HsOuterTyVarBndrs flag GhcPs -> (HsOuterTyVarBndrs flag GhcRn -> RnM (a, FreeVars)) -> RnM (a, FreeVars)
bindHsForAllTelescope :: HsDocContext -> HsForAllTelescope GhcPs -> (HsForAllTelescope GhcRn -> RnM (a, FreeVars)) -> RnM (a, FreeVars)
bindLHsTyVarBndr :: HsDocContext -> Maybe a -> LHsTyVarBndr flag GhcPs -> (LHsTyVarBndr flag GhcRn -> RnM (b, FreeVars)) -> RnM (b, FreeVars)
bindLHsTyVarBndrs :: OutputableBndrFlag flag 'Renamed => HsDocContext -> WarnUnusedForalls -> Maybe a -> [LHsTyVarBndr flag GhcPs] -> ([LHsTyVarBndr flag GhcRn] -> RnM (b, FreeVars)) -> RnM (b, FreeVars)

-- | Should GHC warn if a quantified type variable goes unused? Usually,
--   the answer is "yes", but in the particular case of binding
--   <a>LHsQTyVars</a>, we avoid emitting warnings. See <tt>Note [Suppress
--   -Wunused-foralls when binding LHsQTyVars]</tt>.
data WarnUnusedForalls
WarnUnusedForalls :: WarnUnusedForalls
NoWarnUnusedForalls :: WarnUnusedForalls

-- | Create new renamed type variables corresponding to source-level ones.
--   Duplicates are permitted, but will be removed. This is intended
--   especially for the case of handling the implicitly bound free
--   variables of a type signature.
rnImplicitTvOccs :: Maybe assoc -> FreeKiTyVars -> ([Name] -> RnM (a, FreeVars)) -> RnM (a, FreeVars)
bindSigTyVarsFV :: [Name] -> RnM (a, FreeVars) -> RnM (a, FreeVars)
bindHsQTyVars :: HsDocContext -> Maybe (a, [Name]) -> FreeKiTyVars -> LHsQTyVars GhcPs -> (LHsQTyVars GhcRn -> FreeKiTyVars -> RnM (b, FreeVars)) -> RnM (b, FreeVars)
type FreeKiTyVars = [LocatedN RdrName]

-- | Filter out any type and kind variables that are already in scope in
--   the the environment's LocalRdrEnv. Note that this includes named
--   wildcards, which look like perfectly ordinary type variables at this
--   point.
filterInScopeM :: FreeKiTyVars -> RnM FreeKiTyVars

-- | <a>extractHsTyRdrTyVars</a> finds the type/kind variables of a
--   HsType/HsKind. It's used when making the <tt>forall</tt>s explicit.
--   See Note [Kind and type-variable binders]
extractHsTyRdrTyVars :: LHsType GhcPs -> FreeKiTyVars

-- | Extracts the free type/kind variables from the kind signature of a
--   HsType. This is used to implicitly quantify over <tt>k</tt> in
--   <tt>type T = Nothing :: Maybe k</tt>. The left-to-right order of
--   variables is preserved. See Note [Kind and type-variable binders] and
--   Note [Ordering of implicit variables] and Note [Implicit
--   quantification in type synonyms].
extractHsTyRdrTyVarsKindVars :: LHsType GhcPs -> FreeKiTyVars

-- | Extracts free type and kind variables from types in a list. When the
--   same name occurs multiple times in the types, all occurrences are
--   returned.
extractHsTysRdrTyVars :: [LHsType GhcPs] -> FreeKiTyVars -> FreeKiTyVars
extractRdrKindSigVars :: LFamilyResultSig GhcPs -> FreeKiTyVars

-- | Extracts free type and kind variables from an argument in a GADT
--   constructor, returning variable occurrences in left-to-right order.
--   See <tt>Note [Ordering of implicit variables]</tt>.
extractConDeclGADTDetailsTyVars :: HsConDeclGADTDetails GhcPs -> FreeKiTyVars -> FreeKiTyVars

-- | Get type/kind variables mentioned in the kind signature, preserving
--   left-to-right order:
--   
--   <ul>
--   <li>data T a (b :: k1) :: k2 -&gt; k1 -&gt; k2 -&gt; Type -- result:
--   [k2,k1]</li>
--   <li>data T a (b :: k1) -- result: []</li>
--   </ul>
--   
--   See Note [Ordering of implicit variables].
extractDataDefnKindVars :: HsDataDefn GhcPs -> FreeKiTyVars
extractHsOuterTvBndrs :: HsOuterTyVarBndrs flag GhcPs -> FreeKiTyVars -> FreeKiTyVars
extractHsTyArgRdrKiTyVars :: [LHsTypeArg GhcPs] -> FreeKiTyVars
nubL :: Eq a => [GenLocated l a] -> [GenLocated l a]
nubN :: Eq a => [LocatedN a] -> [LocatedN a]
badKindSigErr :: HsDocContext -> LHsType GhcPs -> TcM ()
instance GHC.Utils.Outputable.Outputable GHC.Rename.HsType.RnTyKiEnv
instance GHC.Utils.Outputable.Outputable GHC.Rename.HsType.RnTyKiWhat
instance GHC.Utils.Outputable.Outputable GHC.Rename.HsType.WarnUnusedForalls

module GHC.Rename.Pat
rnPat :: HsMatchContextRn -> LPat GhcPs -> (LPat GhcRn -> RnM (a, FreeVars)) -> RnM (a, FreeVars)
rnPats :: HsMatchContextRn -> [LPat GhcPs] -> ([LPat GhcRn] -> RnM (a, FreeVars)) -> RnM (a, FreeVars)
rnBindPat :: NameMaker -> LPat GhcPs -> RnM (LPat GhcRn, FreeVars)
data NameMaker
applyNameMaker :: NameMaker -> LocatedN RdrName -> RnM (LocatedN Name)
localRecNameMaker :: MiniFixityEnv -> NameMaker
topRecNameMaker :: MiniFixityEnv -> NameMaker
isTopRecNameMaker :: NameMaker -> Bool
rnHsRecFields :: HsRecFieldContext -> (SrcSpan -> RdrName -> arg) -> HsRecFields GhcPs (LocatedA arg) -> RnM ([LHsRecField GhcRn (LocatedA arg)], FreeVars)
data HsRecFieldContext
HsRecFieldCon :: Name -> HsRecFieldContext
HsRecFieldPat :: Name -> HsRecFieldContext
HsRecFieldUpd :: HsRecFieldContext

-- | Rename a regular (non-overloaded) record field update, disambiguating
--   the fields if necessary.
rnHsRecUpdFields :: [LHsRecUpdField GhcPs GhcPs] -> RnM (XLHsRecUpdLabels GhcRn, [LHsRecUpdField GhcRn GhcRn], FreeVars)
data CpsRn b
liftCps :: RnM a -> CpsRn a
liftCpsWithCont :: (forall r. () => (b -> RnM (r, FreeVars)) -> RnM (r, FreeVars)) -> CpsRn b
rnLit :: HsLit p -> RnM ()
rnOverLit :: XXOverLit t ~ DataConCantHappen => HsOverLit t -> RnM ((HsOverLit GhcRn, Maybe (HsExpr GhcRn)), FreeVars)
instance GHC.Internal.Base.Applicative GHC.Rename.Pat.CpsRn
instance GHC.Internal.Base.Applicative GHC.Rename.Pat.TPRnM
instance GHC.Internal.Base.Functor GHC.Rename.Pat.CpsRn
instance GHC.Internal.Base.Functor GHC.Rename.Pat.TPRnM
instance GHC.Internal.Base.Monad GHC.Rename.Pat.CpsRn
instance GHC.Internal.Base.Monad GHC.Rename.Pat.TPRnM

module GHC.Rename.Bind
rnTopBindsLHS :: MiniFixityEnv -> HsValBinds GhcPs -> RnM (HsValBindsLR GhcRn GhcPs)
rnTopBindsLHSBoot :: MiniFixityEnv -> HsValBinds GhcPs -> RnM (HsValBindsLR GhcRn GhcPs)
rnTopBindsBoot :: NameSet -> HsValBindsLR GhcRn GhcPs -> RnM (HsValBinds GhcRn, DefUses)
rnValBindsRHS :: HsSigCtxt -> HsValBindsLR GhcRn GhcPs -> RnM (HsValBinds GhcRn, DefUses)
rnLocalBindsAndThen :: HsLocalBinds GhcPs -> (HsLocalBinds GhcRn -> FreeVars -> RnM (result, FreeVars)) -> RnM (result, FreeVars)
rnLocalValBindsLHS :: MiniFixityEnv -> HsValBinds GhcPs -> RnM ([Name], HsValBindsLR GhcRn GhcPs)
rnLocalValBindsRHS :: NameSet -> HsValBindsLR GhcRn GhcPs -> RnM (HsValBinds GhcRn, DefUses)
rnMethodBinds :: Bool -> Name -> [Name] -> LHsBinds GhcPs -> [LSig GhcPs] -> RnM (LHsBinds GhcRn, [LSig GhcRn], FreeVars)
renameSigs :: HsSigCtxt -> [LSig GhcPs] -> RnM ([LSig GhcRn], FreeVars)
rnMatchGroup :: (Outputable (body GhcPs), AnnoBody body) => HsMatchContextRn -> (LocatedA (body GhcPs) -> RnM (LocatedA (body GhcRn), FreeVars)) -> MatchGroup GhcPs (LocatedA (body GhcPs)) -> RnM (MatchGroup GhcRn (LocatedA (body GhcRn)), FreeVars)
rnGRHSs :: AnnoBody body => HsMatchContextRn -> (LocatedA (body GhcPs) -> RnM (LocatedA (body GhcRn), FreeVars)) -> GRHSs GhcPs (LocatedA (body GhcPs)) -> RnM (GRHSs GhcRn (LocatedA (body GhcRn)), FreeVars)
rnGRHS :: AnnoBody body => HsMatchContextRn -> (LocatedA (body GhcPs) -> RnM (LocatedA (body GhcRn), FreeVars)) -> LGRHS GhcPs (LocatedA (body GhcPs)) -> RnM (LGRHS GhcRn (LocatedA (body GhcRn)), FreeVars)
rnSrcFixityDecl :: HsSigCtxt -> FixitySig GhcPs -> RnM (FixitySig GhcRn)
makeMiniFixityEnv :: [LFixitySig GhcPs] -> RnM MiniFixityEnv

-- | Mini fixity env for the names we're about to bind, in a single binding
--   group
--   
--   It is keyed by the *FastString*, not the *OccName*, because the single
--   fixity decl <tt>infix 3 T</tt> affects both the data constructor T and
--   the type constructor T
--   
--   We keep the location so that if we find a duplicate, we can report it
--   sensibly
--   
--   Fixity declarations may influence names in a single namespace by using
--   a type or data specifier, e.g. in:
--   
--   <pre>
--   data a :*: b = a :*: b
--   infix 3 type :*:
--   </pre>
--   
--   To handle that correctly, MiniFixityEnv contains separate fields for
--   type-level and data-level names. If no namespace specifier is
--   provided, the declaration will populate both the type-level and
--   data-level fields.
data MiniFixityEnv
emptyMiniFixityEnv :: MiniFixityEnv
data HsSigCtxt
TopSigCtxt :: NameSet -> HsSigCtxt
LocalBindCtxt :: NameSet -> HsSigCtxt
ClsDeclCtxt :: Name -> HsSigCtxt
InstDeclCtxt :: NameSet -> HsSigCtxt
HsBootCtxt :: NameSet -> HsSigCtxt
RoleAnnotCtxt :: NameSet -> HsSigCtxt
rejectBootDecls :: HsBootOrSig -> (NonEmpty (LocatedA decl) -> BadBootDecls) -> [LocatedA decl] -> TcM ()
localCompletePragmas :: [LSig GhcRn] -> CompleteMatches

module GHC.Rename.Module

-- | <tt>rnSourceDecl</tt> "renames" declarations. It simultaneously
--   performs dependency analysis and precedence parsing. It also does the
--   following error checks:
--   
--   <ul>
--   <li>Checks that tyvars are used properly. This includes checking for
--   undefined tyvars, and tyvars in contexts that are ambiguous. (Some of
--   this checking has now been moved to module <tt>TcMonoType</tt>, since
--   we don't have functional dependency information at this point.)</li>
--   <li>Checks that all variable occurrences are defined.</li>
--   <li>Checks the <tt>(..)</tt> etc constraints in the export list.</li>
--   </ul>
--   
--   Brings the binders of the group into scope in the appropriate places;
--   does NOT assume that anything is in scope already
rnSrcDecls :: HsGroup GhcPs -> RnM (TcGblEnv, HsGroup GhcRn)
addTcgDUs :: TcGblEnv -> DefUses -> TcGblEnv
findSplice :: [LHsDecl GhcPs] -> RnM (HsGroup GhcPs, Maybe (SpliceDecl GhcPs, [LHsDecl GhcPs]))
rnWarningTxt :: WarningTxt GhcPs -> RnM (WarningTxt GhcRn)
rnLWarningTxt :: LWarningTxt GhcPs -> RnM (LWarningTxt GhcRn)

module GHC.Tc.Gen.Export
rnExports :: Bool -> Maybe (LocatedLI [LIE GhcPs]) -> RnM TcGblEnv
exports_from_avail :: Maybe (LocatedLI [LIE GhcPs]) -> GlobalRdrEnv -> ImportAvails -> Module -> RnM (Maybe [(LIE GhcRn, DefaultEnv, Avails)], Avails, ExportWarnNames GhcRn)
classifyGREs :: [GlobalRdrElt] -> ([GlobalRdrElt], [FieldGlobalRdrElt])

module GHC.Rename.Splice
rnTopSpliceDecls :: HsUntypedSplice GhcPs -> RnM ([LHsDecl GhcPs], FreeVars)
rnTypedSplice :: LHsExpr GhcPs -> RnM (HsExpr GhcRn, FreeVars)
rnSpliceType :: HsUntypedSplice GhcPs -> RnM (HsType GhcRn, FreeVars)
rnUntypedSpliceExpr :: HsUntypedSplice GhcPs -> RnM (HsExpr GhcRn, FreeVars)

-- | Rename a splice pattern. See Note [rnSplicePat]
rnSplicePat :: HsUntypedSplice GhcPs -> RnM ((HsUntypedSplice GhcRn, HsUntypedSpliceResult (LPat GhcPs)), FreeVars)

-- | Rename a splice type pattern. Much the same as <a>rnSplicePat</a>, but
--   works with LHsType instead of LPat
rnSpliceTyPat :: HsUntypedSplice GhcPs -> RnM ((HsUntypedSplice GhcRn, HsUntypedSpliceResult (LHsType GhcPs)), FreeVars)
rnSpliceDecl :: SpliceDecl GhcPs -> RnM (SpliceDecl GhcRn, FreeVars)
rnTypedBracket :: HsExpr GhcPs -> LHsExpr GhcPs -> RnM (HsExpr GhcRn, FreeVars)
rnUntypedBracket :: HsExpr GhcPs -> HsQuote GhcPs -> RnM (HsExpr GhcRn, FreeVars)
checkThLocalName :: Name -> RnM ()

-- | outputs splice information for 2 flags which have different output
--   formats: `-ddump-splices` and `-dth-dec-file`
traceSplice :: SpliceInfo -> TcM ()

-- | The splice data to be logged
data SpliceInfo
SpliceInfo :: String -> Maybe (LHsExpr GhcRn) -> Bool -> SDoc -> SpliceInfo
[spliceDescription] :: SpliceInfo -> String
[spliceSource] :: SpliceInfo -> Maybe (LHsExpr GhcRn)
[spliceIsDecl] :: SpliceInfo -> Bool
[spliceGenerated] :: SpliceInfo -> SDoc
checkThLocalTyName :: Name -> RnM ()

module GHC.Rename.Expr
rnLExpr :: LHsExpr GhcPs -> RnM (LHsExpr GhcRn, FreeVars)
rnExpr :: HsExpr GhcPs -> RnM (HsExpr GhcRn, FreeVars)

-- | Rename some Stmts
rnStmts :: AnnoBody body => HsStmtContextRn -> (body GhcPs -> RnM (body GhcRn, FreeVars)) -> [LStmt GhcPs (LocatedA (body GhcPs))] -> ([Name] -> RnM (thing, FreeVars)) -> RnM (([LStmt GhcRn (LocatedA (body GhcRn))], thing), FreeVars)
type AnnoBody (body :: Type -> Type) = Outputable body GhcPs

-- | An existential wrapper around <tt><a>StmtLR</a> GhcPs GhcPs body</tt>.
data UnexpectedStatement
[UnexpectedStatement] :: forall body. Outputable (StmtLR GhcPs GhcPs body) => StmtLR GhcPs GhcPs body -> UnexpectedStatement
instance GHC.Utils.Outputable.Outputable GHC.Rename.Expr.MonadNames
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Rename.Expr.StmtTree a)


-- | The loader
--   
--   This module deals with the top-level issues of dynamic linking
--   (loading), calling the object-code linker and the byte-code linker
--   where necessary.
module GHC.Linker.Loader
newtype Loader
Loader :: MVar (Maybe LoaderState) -> Loader
[loader_state] :: Loader -> MVar (Maybe LoaderState)
data LoaderState
LoaderState :: !LinkerEnv -> !LinkableSet -> !LinkableSet -> !PkgsLoaded -> ![(FilePath, String)] -> LoaderState

-- | Current global mapping from Names to their true values
[linker_env] :: LoaderState -> !LinkerEnv

-- | The currently loaded interpreted modules (home package)
[bcos_loaded] :: LoaderState -> !LinkableSet

-- | And the currently-loaded compiled modules (home package)
[objs_loaded] :: LoaderState -> !LinkableSet

-- | The currently-loaded packages; always object code haskell libraries,
--   system libraries, transitive dependencies
[pkgs_loaded] :: LoaderState -> !PkgsLoaded

-- | We need to remember the name of previous temporary DLL/.so libraries
--   so we can link them (see #10322)
[temp_sos] :: LoaderState -> ![(FilePath, String)]

-- | Initialise the dynamic linker. This entails
--   
--   a) Calling the C initialisation procedure,
--   
--   b) Loading any packages specified on the command line,
--   
--   c) Loading any packages specified on the command line, now held in the
--   <tt>-l</tt> options in <tt>v_Opt_l</tt>,
--   
--   d) Loading any <tt>.o/.dll</tt> files specified on the command line,
--   now held in <tt>ldInputs</tt>,
--   
--   e) Loading any MacOS frameworks.
--   
--   NOTE: This function is idempotent; if called more than once, it does
--   nothing. This is useful in Template Haskell, where we call it before
--   trying to link.
initLoaderState :: Interp -> HscEnv -> IO ()
uninitializedLoader :: IO Loader

-- | Display the loader state.
showLoaderState :: Interp -> IO SDoc
getLoaderState :: Interp -> IO (Maybe LoaderState)

-- | Load a single expression, <i>including</i> first loading packages and
--   modules that this expression depends on.
--   
--   Raises an IO exception (<a>ProgramError</a>) if it can't find a
--   compiled version of the dependents to load.
loadExpr :: Interp -> HscEnv -> SrcSpan -> UnlinkedBCO -> IO ForeignHValue
loadDecls :: Interp -> HscEnv -> SrcSpan -> Linkable -> IO ([(Name, ForeignHValue)], [Linkable], PkgsLoaded)

-- | Load exactly the specified packages, and their dependents (unless of
--   course they are already loaded). The dependents are loaded
--   automatically, and it doesn't matter what order you specify the input
--   packages.
loadPackages :: Interp -> HscEnv -> [UnitId] -> IO ()
loadModule :: Interp -> HscEnv -> Module -> IO ()
loadCmdLineLibs :: Interp -> HscEnv -> IO ()

-- | Load the module containing the given Name and get its associated
--   <a>HValue</a>.
--   
--   Throws a <a>ProgramError</a> if loading fails or the name cannot be
--   found.
loadName :: Interp -> HscEnv -> Name -> IO (ForeignHValue, [Linkable], PkgsLoaded)

-- | Unloading old objects ready for a new compilation sweep.
--   
--   The compilation manager provides us with a list of linkables that it
--   considers "stable", i.e. won't be recompiled this time around. For
--   each of the modules current linked in memory,
--   
--   <ul>
--   <li>if the linkable is stable (and it's the same one -- the user may
--   have recompiled the module on the side), we keep it,</li>
--   <li>otherwise, we unload it.</li>
--   <li>we also implicitly unload all temporary bindings at this
--   point.</li>
--   </ul>
unload :: Interp -> HscEnv -> [Linkable] -> IO ()

-- | Temporarily extend the loaded env.
withExtendedLoadedEnv :: ExceptionMonad m => Interp -> [(Name, ForeignHValue)] -> m a -> m a
extendLoadedEnv :: Interp -> [(Name, ForeignHValue)] -> IO ()
deleteFromLoadedEnv :: Interp -> [Name] -> IO ()
rmDupLinkables :: LinkableSet -> [Linkable] -> (LinkableSet, [Linkable])
modifyLoaderState :: Interp -> (LoaderState -> IO (LoaderState, a)) -> IO a
initLinkDepsOpts :: HscEnv -> LinkDepsOpts
getGccSearchDirectory :: Logger -> DynFlags -> String -> IO [FilePath]


-- | Dynamically lookup up values from modules and loading them.
module GHC.Runtime.Loader

-- | Loads the plugins specified in the pluginModNames field of the dynamic
--   flags. Should be called after command line arguments are parsed, but
--   before actual compilation starts. Idempotent operation. Should be
--   re-called if pluginModNames or pluginModNameOpts changes.
initializePlugins :: HscEnv -> IO HscEnv

-- | Initialise plugins specified by the current DynFlags and update the
--   session.
initializeSessionPlugins :: GhcMonad m => m ()
loadFrontendPlugin :: HscEnv -> ModuleName -> IO (FrontendPlugin, [Linkable], PkgsLoaded)

-- | Force the interfaces for the given modules to be loaded. The
--   <a>SDoc</a> parameter is used for debugging (<tt>-ddump-if-trace</tt>)
--   only: it is shown as the reason why the module is being loaded.
forceLoadModuleInterfaces :: HscEnv -> SDoc -> [Module] -> IO ()

-- | Force the interface for the module containing the name to be loaded.
--   The <a>SDoc</a> parameter is used for debugging
--   (<tt>-ddump-if-trace</tt>) only: it is shown as the reason why the
--   module is being loaded.
forceLoadNameModuleInterface :: HscEnv -> SDoc -> Name -> IO ()

-- | Load the <a>TyCon</a> associated with the given name, come hell or
--   high water. Fails if:
--   
--   <ul>
--   <li>The interface could not be loaded</li>
--   <li>The name is not that of a <a>TyCon</a></li>
--   <li>The name did not exist in the loaded module</li>
--   </ul>
forceLoadTyCon :: HscEnv -> Name -> IO TyCon

-- | Finds the <a>Name</a> corresponding to the given <a>RdrName</a> in the
--   context of the <a>ModuleName</a>. Returns <tt>Nothing</tt> if no such
--   <a>Name</a> could be found. Any other condition results in an
--   exception:
--   
--   <ul>
--   <li>If the module could not be found</li>
--   <li>If we could not determine the imports of the module</li>
--   </ul>
--   
--   Can only be used for looking up names while loading plugins (and is
--   *not* suitable for use within plugins). The interface file is loaded
--   very partially: just enough that it can be used, without its rules and
--   instances affecting (and being linked from!) the module being
--   compiled. This was introduced by 57d6798.
--   
--   Need the module as well to record information in the interface file
lookupRdrNameInModuleForPlugins :: HasDebugCallStack => HscEnv -> ModuleName -> RdrName -> IO (Maybe (Name, ModIface))

-- | Loads the value corresponding to a <a>Name</a> if that value has the
--   given <a>Type</a>. This only provides limited safety in that it is up
--   to the user to ensure that that type corresponds to the type you try
--   to use the return value at!
--   
--   If the value found was not of the correct type, returns <tt>Left
--   <a>actual_type</a></tt>. Any other condition results in an exception:
--   
--   <ul>
--   <li>If we could not load the names module</li>
--   <li>If the thing being loaded is not a value</li>
--   <li>If the Name does not exist in the module</li>
--   <li>If the link failed</li>
--   </ul>
getValueSafely :: HscEnv -> Name -> Type -> IO (Either Type (a, [Linkable], PkgsLoaded))
getHValueSafely :: Interp -> HscEnv -> Name -> Type -> IO (Either Type (HValue, [Linkable], PkgsLoaded))

-- | Coerce a value as usual, but:
--   
--   1) Evaluate it immediately to get a segfault early if the coercion was
--   wrong
--   
--   2) Wrap it in some debug messages at verbosity 3 or higher so we can
--   see what happened if it <i>does</i> segfault
lessUnsafeCoerce :: Logger -> String -> a -> IO b

module GHC.IfaceToCore
tcLookupImported_maybe :: Name -> TcM (MaybeErr IfaceMessage TyThing)
importDecl :: Name -> IfM lcl (MaybeErr IfaceMessage TyThing)
checkWiredInTyCon :: TyCon -> TcM ()
tcHiBootIface :: HscSource -> Module -> TcRn SelfBootInfo
typecheckIface :: ModIface -> IfG ModDetails
typecheckWholeCoreBindings :: IORef TypeEnv -> WholeCoreBindings -> IfG [CoreBind]

-- | This is a very interesting function. Like typecheckIface, we want to
--   type check an interface file into a ModDetails. However, the use-case
--   for these ModDetails is different: we want to compare all of the
--   ModDetails to ensure they define compatible declarations, and then
--   merge them together. So in particular, we have to take a different
--   strategy for knot-tying: we first speculatively merge the declarations
--   to get the "base" truth for what we believe the types will be (this is
--   "type computation.") Then we read everything in relative to this truth
--   and check for compatibility.
--   
--   During the merge process, we may need to nondeterministically pick a
--   particular declaration to use, if multiple signatures define the
--   declaration (<a>mergeIfaceDecl</a>). If, for all choices, there are no
--   type synonym cycles in the resulting merged graph, then we can show
--   that our choice cannot matter. Consider the set of entities which the
--   declarations depend on: by assumption of acyclicity, we can assume
--   that these have already been shown to be equal to each other
--   (otherwise merging will fail). Then it must be the case that all
--   candidate declarations here are type-equal (the choice doesn't matter)
--   or there is an inequality (in which case merging will fail.)
--   
--   Unfortunately, the choice can matter if there is a cycle. Consider the
--   following merge:
--   
--   signature H where { type A = C; type B = A; data C } signature H where
--   { type A = (); data B; type C = B }
--   
--   If we pick <tt>type A = C</tt> as our representative, there will be a
--   cycle and merging will fail. But if we pick <tt>type A = ()</tt> as
--   our representative, no cycle occurs, and we instead conclude that all
--   of the types are unit. So it seems that we either (a) need a stronger
--   acyclicity check which considers *all* possible choices from a merge,
--   or (b) we must find a selection of declarations which is acyclic, and
--   show that this is always the "best" choice we could have made (ezyang
--   conjectures this is the case but does not have a proof). For now this
--   is not implemented.
--   
--   It's worth noting that at the moment, a data constructor and a type
--   synonym are never compatible. Consider:
--   
--   signature H where { type Int=C; type B = Int; data C = Int} signature
--   H where { export Prelude.Int; data B; type C = B; }
--   
--   This will be rejected, because the reexported Int in the second
--   signature (a proper data type) is never considered equal to a type
--   synonym. Perhaps this should be relaxed, where a type synonym in a
--   signature is considered implemented by a data type declaration which
--   matches the reference of the type synonym.
typecheckIfacesForMerging :: Module -> [ModIface] -> KnotVars (IORef TypeEnv) -> IfM lcl (TypeEnv, [ModDetails])

-- | Typecheck a signature <a>ModIface</a> under the assumption that we
--   have instantiated it under some implementation (recorded in
--   <a>mi_semantic_module</a>) and want to check if the implementation
--   fills the signature.
--   
--   This needs to operate slightly differently than <a>typecheckIface</a>
--   because (1) we have a <a>NameShape</a>, from the exports of the
--   implementing module, which we will use to give our top-level
--   declarations the correct <a>Name</a>s even when the implementor
--   provided them with a reexport, and (2) we have to deal with DFun
--   silliness (see Note [rnIfaceNeverExported])
typecheckIfaceForInstantiate :: NameShape -> ModIface -> IfM lcl ModDetails
tcIfaceDecl :: Bool -> IfaceDecl -> IfL TyThing
tcIfaceDecls :: Bool -> [(Fingerprint, IfaceDecl)] -> IfL [(Name, TyThing)]
tcIfaceDefaults :: Module -> [(Module, IfaceDefault)] -> IfG [NonEmpty ClassDefaults]
tcIfaceInst :: IfaceClsInst -> IfL ClsInst
tcIfaceFamInst :: IfaceFamInst -> IfL FamInst
tcIfaceRules :: Bool -> [IfaceRule] -> IfL [CoreRule]
tcIfaceAnnotations :: [IfaceAnnotation] -> IfL [Annotation]
tcIfaceCompleteMatches :: [IfaceCompleteMatch] -> IfL [CompleteMatch]
tcIfaceExpr :: IfaceExpr -> IfL CoreExpr
tcIfaceGlobal :: Name -> IfL TyThing
tcIfaceOneShot :: IfaceOneShot -> OneShotInfo
tcTopIfaceBindings :: IORef TypeEnv -> [IfaceBindingX IfaceMaybeRhs IfaceTopBndrInfo] -> IfL [CoreBind]

-- | This function is only used to construct the environment for GHCi, so
--   we make up fake locations
tcIfaceImport :: HscEnv -> IfaceImport -> ImportUserSpec
hydrateCgBreakInfo :: CgBreakInfo -> IfL ([Maybe (Id, Word)], Type)


-- | Typechecking user-specified <tt>MonoTypes</tt>
module GHC.Tc.Gen.HsType
kcClassSigType :: [LocatedN Name] -> LHsSigType GhcRn -> TcM ()
tcClassSigType :: [LocatedN Name] -> LHsSigType GhcRn -> TcM Type
tcHsSigType :: UserTypeCtxt -> LHsSigType GhcRn -> TcM Type
tcHsSigWcType :: UserTypeCtxt -> LHsSigWcType GhcRn -> TcM Type
tcHsPartialSigType :: UserTypeCtxt -> LHsSigWcType GhcRn -> TcM ([(Name, TcTyVar)], Maybe TcType, [(Name, InvisTVBinder)], TcThetaType, TcType)
tcStandaloneKindSig :: LStandaloneKindSig GhcRn -> TcM (Name, Kind)
funsSigCtxt :: [LocatedN Name] -> UserTypeCtxt
addSigCtxt :: Outputable hs_ty => UserTypeCtxt -> LocatedA hs_ty -> TcM a -> TcM a
pprSigCtxt :: Outputable hs_ty => UserTypeCtxt -> LocatedA hs_ty -> SDoc
tcHsClsInstType :: UserTypeCtxt -> LHsSigType GhcRn -> TcM Type
tcHsDefault :: LHsSigType GhcRn -> TcM ([TyVar], Class, [Type], [Kind])
tcHsDeriv :: LHsSigType GhcRn -> TcM ([TyVar], Class, [Type], [Kind])

-- | Typecheck a deriving strategy. For most deriving strategies, this is a
--   no-op, but for the <tt>via</tt> strategy, this requires typechecking
--   the <tt>via</tt> type.
tcDerivStrategy :: Maybe (LDerivStrategy GhcRn) -> TcM (Maybe (LDerivStrategy GhcTc), [TcTyVar])

-- | Type-check a visible type application
tcHsTypeApp :: LHsWcType GhcRn -> Kind -> TcM Type

-- | UserTypeCtxt describes the origin of the polymorphic type in the
--   places where we need an expression to have that type
data UserTypeCtxt
FunSigCtxt :: Name -> ReportRedundantConstraints -> UserTypeCtxt
InfSigCtxt :: Name -> UserTypeCtxt
ExprSigCtxt :: ReportRedundantConstraints -> UserTypeCtxt
KindSigCtxt :: UserTypeCtxt
StandaloneKindSigCtxt :: Name -> UserTypeCtxt
TypeAppCtxt :: UserTypeCtxt
ConArgCtxt :: Name -> UserTypeCtxt
TySynCtxt :: Name -> UserTypeCtxt
PatSynCtxt :: Name -> UserTypeCtxt
PatSigCtxt :: UserTypeCtxt
RuleSigCtxt :: FastString -> Name -> UserTypeCtxt
ForSigCtxt :: Name -> UserTypeCtxt
DefaultDeclCtxt :: UserTypeCtxt
InstDeclCtxt :: Bool -> UserTypeCtxt
SpecInstCtxt :: UserTypeCtxt
GenSigCtxt :: UserTypeCtxt
GhciCtxt :: Bool -> UserTypeCtxt
ClassSCCtxt :: Name -> UserTypeCtxt
SigmaCtxt :: UserTypeCtxt
DataTyCtxt :: Name -> UserTypeCtxt
DerivClauseCtxt :: UserTypeCtxt
TyVarBndrKindCtxt :: Name -> UserTypeCtxt
DataKindCtxt :: Name -> UserTypeCtxt
TySynKindCtxt :: Name -> UserTypeCtxt
TyFamResKindCtxt :: Name -> UserTypeCtxt
bindImplicitTKBndrs_Tv :: [Name] -> TcM a -> TcM ([TcTyVar], a)
bindImplicitTKBndrs_Skol :: SkolemInfo -> [Name] -> TcM a -> TcM ([TcTyVar], a)
bindImplicitTKBndrs_Q_Tv :: [Name] -> TcM a -> TcM ([TcTyVar], a)
bindImplicitTKBndrs_Q_Skol :: SkolemInfo -> [Name] -> TcM a -> TcM ([TcTyVar], a)
bindExplicitTKBndrs_Tv :: OutputableBndrFlag flag 'Renamed => [LHsTyVarBndr flag GhcRn] -> TcM a -> TcM ([VarBndr TyVar flag], a)

-- | Skolemise the <a>HsTyVarBndr</a>s in an <a>HsForAllTelescope</a> with
--   the supplied <a>TcTyMode</a>.
bindExplicitTKBndrs_Skol :: OutputableBndrFlag flag 'Renamed => SkolemInfo -> [LHsTyVarBndr flag GhcRn] -> TcM a -> TcM ([VarBndr TyVar flag], a)
bindExplicitTKBndrs_Q_Tv :: OutputableBndrFlag flag 'Renamed => ContextKind -> [LHsTyVarBndr flag GhcRn] -> TcM a -> TcM ([VarBndr TyVar flag], a)
bindExplicitTKBndrs_Q_Skol :: OutputableBndrFlag flag 'Renamed => SkolemInfo -> ContextKind -> [LHsTyVarBndr flag GhcRn] -> TcM a -> TcM ([VarBndr TyVar flag], a)
bindOuterFamEqnTKBndrs_Q_Tv :: HsOuterFamEqnTyVarBndrs GhcRn -> TcM a -> TcM (HsOuterFamEqnTyVarBndrs GhcTc, a)
bindOuterFamEqnTKBndrs :: SkolemInfo -> HsOuterFamEqnTyVarBndrs GhcRn -> TcM a -> TcM (HsOuterFamEqnTyVarBndrs GhcTc, a)
tcOuterTKBndrs :: OutputableBndrFlag flag 'Renamed => SkolemInfo -> HsOuterTyVarBndrs flag GhcRn -> TcM a -> TcM (HsOuterTyVarBndrs flag GhcTc, a)
scopedSortOuter :: HsOuterTyVarBndrs flag GhcTc -> TcM (HsOuterTyVarBndrs flag GhcTc)
outerTyVars :: HsOuterTyVarBndrs flag GhcTc -> [TcTyVar]
outerTyVarBndrs :: HsOuterTyVarBndrs Specificity GhcTc -> [InvisTVBinder]
bindOuterSigTKBndrs_Tv :: HsOuterSigTyVarBndrs GhcRn -> TcM a -> TcM (HsOuterSigTyVarBndrs GhcTc, a)
tcExplicitTKBndrs :: OutputableBndrFlag flag 'Renamed => SkolemInfo -> [LHsTyVarBndr flag GhcRn] -> TcM a -> TcM ([VarBndr TyVar flag], a)
bindNamedWildCardBinders :: [Name] -> ([(Name, TcTyVar)] -> TcM a) -> TcM a

-- | Bring into scope the binders of a PolyTcTyCon Used for the type
--   variables of a type or class decl in the "kind checking" and "type
--   checking" pass, but not in the initial-kind run.
bindTyClTyVars :: Name -> ([TcTyConBinder] -> TcKind -> TcM a) -> TcM a
bindTyClTyVarsAndZonk :: Name -> ([TyConBinder] -> Kind -> TcM a) -> TcM a
tcFamTyPats :: TyCon -> HsFamEqnPats GhcRn -> TcM (TcType, TcKind)
etaExpandAlgTyCon :: TyConFlavour tc -> SkolemInfo -> [TcTyConBinder] -> Kind -> TcM ([TcTyConBinder], Kind)
tcbVisibilities :: TyCon -> [Type] -> [TyConBndrVis]
zonkAndScopedSort :: [TcTyVar] -> TcM [TcTyVar]
data InitialKindStrategy
InitialKindCheck :: SAKS_or_CUSK -> InitialKindStrategy
InitialKindInfer :: InitialKindStrategy
data SAKS_or_CUSK
SAKS :: Kind -> SAKS_or_CUSK
CUSK :: SAKS_or_CUSK

-- | Describes the kind expected in a certain context.
data ContextKind

-- | a specific kind
TheKind :: TcKind -> ContextKind

-- | any kind will do
AnyKind :: ContextKind

-- | something of the form <tt>TYPE _</tt>
OpenKind :: ContextKind
kcDeclHeader :: InitialKindStrategy -> Name -> TyConFlavour TyCon -> LHsQTyVars GhcRn -> TcM ContextKind -> TcM TcTyCon
checkForDuplicateScopedTyVars :: [(Name, TcTyVar)] -> TcM ()
tcHsLiftedType :: LHsType GhcRn -> TcM TcType
tcHsOpenType :: LHsType GhcRn -> TcM TcType
tcHsLiftedTypeNC :: LHsType GhcRn -> TcM TcType
tcHsOpenTypeNC :: LHsType GhcRn -> TcM TcType
tcInferLHsType :: LHsType GhcRn -> TcM TcType
tcInferLHsTypeKind :: LHsType GhcRn -> TcM (TcType, TcKind)
tcInferLHsTypeUnsaturated :: LHsType GhcRn -> TcM (TcType, TcKind)
tcCheckLHsTypeInContext :: LHsType GhcRn -> ContextKind -> TcM TcType
tcCheckLHsType :: LHsType GhcRn -> TcKind -> TcM TcType
tcHsContext :: Maybe (LHsContext GhcRn) -> TcM [PredType]
tcLHsPredType :: LHsType GhcRn -> TcM PredType

-- | <ul>
--   <li>Specialised version of <a>kindGeneralizeSome</a>, but with empty
--   WantedConstraints, so no filtering is needed i.e. kindGeneraliseAll =
--   kindGeneralizeSome emptyWC</li>
--   </ul>
kindGeneralizeAll :: SkolemInfo -> TcType -> TcM [KindVar]
tcLHsKindSig :: UserTypeCtxt -> LHsKind GhcRn -> TcM Kind

-- | Checks that the return kind in a data declaration's kind signature is
--   permissible. There are three cases:
--   
--   If dealing with a <tt>data</tt>, <tt>newtype</tt>, <tt>data
--   instance</tt>, or <tt>newtype instance</tt> declaration, check that
--   the return kind is <tt>Type</tt>.
--   
--   If the declaration is a <tt>newtype</tt> or <tt>newtype instance</tt>
--   and the <tt>UnliftedNewtypes</tt> extension is enabled, this check is
--   slightly relaxed so that a return kind of the form <tt>TYPE r</tt>
--   (for some <tt>r</tt>) is permitted. See <tt>Note [Implementation of
--   UnliftedNewtypes]</tt> in <a>GHC.Tc.TyCl</a>.
--   
--   If dealing with a <tt>data family</tt> declaration, check that the
--   return kind is either of the form:
--   
--   <ol>
--   <li><tt>TYPE r</tt> (for some <tt>r</tt>), or</li>
--   <li><tt>k</tt> (where <tt>k</tt> is a bare kind variable; see
--   #12369)</li>
--   </ol>
--   
--   See also Note [Datatype return kinds] in <a>GHC.Tc.TyCl</a>
checkDataKindSig :: DataSort -> Kind -> TcM ()

-- | A description of whether something is a
--   
--   <ul>
--   <li><tt>data</tt> or <tt>newtype</tt> (<a>DataDeclSort</a>)</li>
--   <li><tt>data instance</tt> or <tt>newtype instance</tt>
--   (<a>DataInstanceSort</a>)</li>
--   <li><tt>data family</tt> (<a>DataFamilySort</a>)</li>
--   </ul>
--   
--   At present, this data type is only consumed by
--   <tt>checkDataKindSig</tt>.
data DataSort
DataDeclSort :: NewOrData -> DataSort
DataInstanceSort :: NewOrData -> DataSort
DataFamilySort :: DataSort

-- | Checks that the result kind of a class is exactly <tt>Constraint</tt>,
--   rejecting type synonyms and type families that reduce to
--   <tt>Constraint</tt>. See #16826.
checkClassKindSig :: Kind -> TcM ()
tcMult :: HsArrow GhcRn -> TcM Mult
tcHsPatSigType :: UserTypeCtxt -> HoleMode -> HsPatSigType GhcRn -> ContextKind -> TcM ([(Name, TcTyVar)], [(Name, TcTyVar)], TcType)
tcHsTyPat :: HsTyPat GhcRn -> Kind -> TcM ([(Name, TcTyVar)], [(Name, TcTyVar)], TcType)
data HoleMode
HM_Sig :: HoleMode
HM_FamPat :: HoleMode
HM_VTA :: HoleMode
HM_TyAppPat :: HoleMode

-- | Make an appropriate message for an error in a function argument. Used
--   for both expressions and types.
funAppCtxt :: (Outputable fun, Outputable arg) => fun -> arg -> Int -> SDoc

-- | Add a "In the data declaration for T" or some such.
addTyConFlavCtxt :: Name -> TyConFlavour tc -> TcM a -> TcM a
tyLitFromLit :: HsLit GhcRn -> Maybe (HsTyLit GhcRn)
tyLitFromOverloadedLit :: OverLitVal -> Maybe (HsTyLit GhcRn)
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.HsType.ContextKind
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.HsType.HoleMode
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.HsType.SAKS_or_CUSK
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.HsType.TcTyMode

module GHC.Tc.Gen.Sig
data TcSigInfo
TcIdSig :: TcIdSig -> TcSigInfo
TcPatSynSig :: TcPatSynSig -> TcSigInfo
data TcIdSig
TcCompleteSig :: TcCompleteSig -> TcIdSig
TcPartialSig :: TcPartialSig -> TcIdSig
type TcSigFun = Name -> Maybe TcSigInfo
isPartialSig :: TcIdSigInst -> Bool

-- | No signature or a partial signature
hasCompleteSig :: TcSigFun -> Name -> Bool
tcSigInfoName :: TcSigInfo -> Name
tcIdSigLoc :: TcIdSig -> SrcSpan
completeSigPolyId_maybe :: TcSigInfo -> Maybe TcId

-- | If there are no wildcards, return a LHsSigWcType
isCompleteHsSig :: LHsSigWcType GhcRn -> Bool

-- | Find the location of the top-level context of a HsType. For example:
--   
--   <pre>
--   forall a b. (Eq a, Ord b) =&gt; blah
--               ^^^^^^^^^^^^^
--   </pre>
--   
--   If there is none, return Nothing
lhsSigWcTypeContextSpan :: LHsSigWcType GhcRn -> ReportRedundantConstraints
lhsSigTypeContextSpan :: LHsSigType GhcRn -> ReportRedundantConstraints
tcTySigs :: [LSig GhcRn] -> TcM ([TcId], TcSigFun)
tcUserTypeSig :: SrcSpan -> LHsSigWcType GhcRn -> Maybe Name -> TcM TcIdSig
completeSigFromId :: UserTypeCtxt -> Id -> TcCompleteSig
tcInstSig :: TcIdSig -> TcM TcIdSigInst
type TcPragEnv = NameEnv [LSig GhcRn]
emptyPragEnv :: TcPragEnv
lookupPragEnv :: TcPragEnv -> Name -> [LSig GhcRn]
extendPragEnv :: TcPragEnv -> (Name, LSig GhcRn) -> TcPragEnv
mkPragEnv :: [LSig GhcRn] -> LHsBinds GhcRn -> TcPragEnv
tcSpecPrags :: Id -> [LSig GhcRn] -> TcM [LTcSpecPrag]
tcSpecWrapper :: UserTypeCtxt -> TcType -> TcType -> TcM HsWrapper
tcImpPrags :: [LSig GhcRn] -> TcM [LTcSpecPrag]
addInlinePrags :: TcId -> [LSig GhcRn] -> TcM TcId
addInlinePragArity :: Arity -> LSig GhcRn -> LSig GhcRn


-- | Typechecking patterns
module GHC.Tc.Gen.Pat
tcLetPat :: (Name -> Maybe TcId) -> LetBndrSpec -> LPat GhcRn -> Scaled ExpSigmaTypeFRR -> TcM a -> TcM (LPat GhcTc, a)
newLetBndr :: LetBndrSpec -> Name -> Mult -> TcType -> TcM TcId
data LetBndrSpec
LetLclBndr :: LetBndrSpec
LetGblBndr :: TcPragEnv -> LetBndrSpec
tcCheckPat :: HsMatchContextRn -> LPat GhcRn -> Scaled TcSigmaTypeFRR -> TcM a -> TcM (LPat GhcTc, a)

-- | A variant of <tt>tcPat</tt> that takes a custom origin
tcCheckPat_O :: HsMatchContextRn -> CtOrigin -> LPat GhcRn -> Scaled TcSigmaTypeFRR -> TcM a -> TcM (LPat GhcTc, a)
tcInferPat :: FixedRuntimeRepContext -> HsMatchContextRn -> LPat GhcRn -> TcM a -> TcM ((LPat GhcTc, a), TcSigmaTypeFRR)
tcMatchPats :: HsMatchContextRn -> [LPat GhcRn] -> [ExpPatType] -> TcM a -> TcM ([LPat GhcTc], a)
addDataConStupidTheta :: DataCon -> [TcType] -> TcM ()
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.Pat.LetBndrSpec


-- | Typechecking <tt>default</tt> declarations
module GHC.Tc.Gen.Default
tcDefaults :: [LDefaultDecl GhcRn] -> TcM DefaultEnv

module GHC.Tc.Gen.Bind
tcLocalBinds :: HsLocalBinds GhcRn -> TcM thing -> TcM (HsLocalBinds GhcTc, HsWrapper, thing)
tcTopBinds :: [(RecFlag, LHsBinds GhcRn)] -> [LSig GhcRn] -> TcM (TcGblEnv, TcLclEnv)
tcValBinds :: TopLevelFlag -> [(RecFlag, LHsBinds GhcRn)] -> [LSig GhcRn] -> TcM thing -> TcM ([(RecFlag, LHsBinds GhcTc)], HsWrapper, thing)
tcHsBootSigs :: [(RecFlag, LHsBinds GhcRn)] -> [LSig GhcRn] -> TcM [Id]
tcPolyCheck :: TcPragEnv -> TcCompleteSig -> LHsBind GhcRn -> TcM (LHsBinds GhcTc, [Scaled TcId])
chooseInferredQuantifiers :: WantedConstraints -> TcThetaType -> TcTyVarSet -> [TcTyVar] -> Maybe TcIdSigInst -> TcM ([InvisTVBinder], TcThetaType)
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.Bind.GeneralisationPlan


-- | Analysis functions over data types. Specifically, detecting recursive
--   types.
--   
--   This stuff is only used for source-code decls; it's recorded in
--   interface files for imported data types.
module GHC.Tc.TyCl.Utils
type RolesInfo = Name -> [Role]
inferRoles :: HscSource -> RoleAnnotEnv -> [TyCon] -> Name -> [Role]

-- | Checks if any of the passed in <a>TyCon</a>s have cycles. Takes the
--   <a>Unit</a> of the home package (as we can avoid checking those
--   TyCons: cycles never go through foreign packages) and the
--   corresponding <tt>LTyClDecl Name</tt> for each <a>TyCon</a>, so we can
--   give better error messages.
checkSynCycles :: Unit -> [TyCon] -> [LTyClDecl GhcRn] -> TcM ()
checkClassCycles :: Class -> Maybe SuperclassCycle
addTyConsToGblEnv :: [TyCon] -> TcM (TcGblEnv, ThBindEnv)
mkDefaultMethodType :: Class -> Id -> DefMethSpec Type -> Type
tcRecSelBinds :: [(Id, LHsBind GhcRn)] -> TcM TcGblEnv
mkRecSelBinds :: [TyCon] -> [(Id, LHsBind GhcRn)]
mkOneRecordSelector :: [ConLike] -> RecSelParent -> FieldLabel -> FieldSelectors -> (Id, LHsBind GhcRn)
instance GHC.Internal.Base.Applicative GHC.Tc.TyCl.Utils.RoleM
instance GHC.Internal.Base.Applicative GHC.Tc.TyCl.Utils.SynCycleM
instance GHC.Internal.Base.Functor GHC.Tc.TyCl.Utils.RoleM
instance GHC.Internal.Base.Functor GHC.Tc.TyCl.Utils.SynCycleM
instance GHC.Internal.Base.Monad GHC.Tc.TyCl.Utils.RoleM
instance GHC.Internal.Base.Monad GHC.Tc.TyCl.Utils.SynCycleM

module GHC.Tc.Utils.Backpack

-- | For a module <tt>modname</tt> of type <a>HscSource</a>, determine the
--   list of extra "imports" of other requirements which should be
--   considered part of the import of the requirement, because it
--   transitively depends on those requirements by imports of modules from
--   other packages. The situation is something like this:
--   
--   unit p where signature X signature Y import X
--   
--   unit q where dependency p[X=&lt;A&gt;,Y=&lt;B&gt;] signature A
--   signature B
--   
--   Although q's B does not directly import A, we still have to make sure
--   we process A first, because the merging process will cause B to
--   indirectly import A. This function finds the TRANSITIVE closure of all
--   such imports we need to make.
findExtraSigImports :: HscEnv -> HscSource -> ModuleName -> IO [ModuleName]
implicitRequirements :: HscEnv -> [(PkgQual, Located ModuleName)] -> IO [ModuleName]

-- | Like <tt>implicitRequirements'</tt>, but returns either the module
--   name, if it is a free hole, or the instantiated unit the imported
--   module is from, so that that instantiated unit can be processed and
--   via the batch mod graph (rather than a transitive closure done here)
--   all the free holes are still reachable.
implicitRequirementsShallow :: HscEnv -> [(PkgQual, Located ModuleName)] -> IO ([ModuleName], [InstantiatedUnit])

-- | Given a <a>Unit</a>, make sure it is well typed. This is because unit
--   IDs come from Cabal, which does not know if things are well-typed or
--   not; a component may have been filled with implementations for the
--   holes that don't actually fulfill the requirements.
checkUnit :: Unit -> TcM ()

-- | Top-level driver for signature instantiation (run when compiling an
--   <tt>hsig</tt> file.)
tcRnCheckUnit :: HscEnv -> Unit -> IO (Messages TcRnMessage, Maybe ())

-- | Top-level driver for signature merging (run after typechecking an
--   <tt>hsig</tt> file).
tcRnMergeSignatures :: HscEnv -> HsParsedModule -> TcGblEnv -> ModIface -> IO (Messages TcRnMessage, Maybe TcGblEnv)

-- | Given a local <a>ModIface</a>, merge all inherited requirements from
--   <a>requirementMerges</a> into this signature, producing a final
--   <a>TcGblEnv</a> that matches the local signature and all required
--   signatures.
mergeSignatures :: HasDebugCallStack => HsParsedModule -> TcGblEnv -> ModIface -> TcRn TcGblEnv

-- | Top-level driver for signature instantiation (run when compiling an
--   <tt>hsig</tt> file.)
tcRnInstantiateSignature :: HscEnv -> Module -> RealSrcSpan -> IO (Messages TcRnMessage, Maybe TcGblEnv)

-- | Given <a>tcg_mod</a>, instantiate a <a>ModIface</a> from the
--   indefinite library to use the actual implementations of the relevant
--   entities, checking that the implementation matches the signature.
instantiateSignature :: TcRn TcGblEnv


-- | Typechecking pattern synonym declarations
module GHC.Tc.TyCl.PatSyn
tcPatSynDecl :: LocatedA (PatSynBind GhcRn GhcRn) -> TcSigFun -> TcPragEnv -> TcM (LHsBinds GhcTc, TcGblEnv)
tcPatSynBuilderBind :: TcPragEnv -> PatSynBind GhcRn GhcRn -> TcM (LHsBinds GhcTc)
patSynBuilderOcc :: PatSyn -> Maybe (HsExpr GhcTc, TcSigmaType)


-- | Typechecking class declarations
module GHC.Tc.TyCl.Class
tcClassSigs :: Name -> [LSig GhcRn] -> LHsBinds GhcRn -> TcM [TcMethInfo]
tcClassDecl2 :: LTyClDecl GhcRn -> TcM (LHsBinds GhcTc)
findMethodBind :: Name -> LHsBinds GhcRn -> TcPragEnv -> Maybe (LHsBind GhcRn, SrcSpan, [LSig GhcRn])
instantiateMethod :: Class -> TcId -> [TcType] -> TcType
tcClassMinimalDef :: Name -> [LSig GhcRn] -> [TcMethInfo] -> TcM ClassMinimalDef
type HsSigFun = Name -> Maybe LHsSigType GhcRn
mkHsSigFun :: [LSig GhcRn] -> HsSigFun
instDeclCtxt1 :: LHsSigType GhcRn -> SDoc
instDeclCtxt2 :: Type -> SDoc
instDeclCtxt3 :: Class -> [Type] -> SDoc

-- | Construct default instances for any associated types that aren't given
--   a user definition Returns [] or singleton
tcATDefault :: SrcSpan -> Subst -> NameSet -> ClassATItem -> TcM [FamInst]

-- | Apply a substitution to the type variable binders of an associated
--   type family. This is used to compute default instances for associated
--   type families (see <a>tcATDefault</a>) as well as
--   <tt>newtype</tt>-derived associated type family instances (see
--   <tt>gen_Newtype_fam_insts</tt> in <a>GHC.Tc.Deriv.Generate</a>).
--   
--   As a concrete example, consider the following class and associated
--   type family:
--   
--   <pre>
--   class C k (a :: k) where
--     type F k a (b :: k) :: Type
--     type F j p q = (Proxy <tt>j p, Proxy </tt>j (q :: j))
--   </pre>
--   
--   If a user defines this instance:
--   
--   <pre>
--   instance C (Type -&gt; Type) Maybe where {}
--   </pre>
--   
--   Then in order to typecheck the default <tt>F</tt> instance, we must
--   apply the substitution <tt>[k :-&gt; (Type -&gt; Type), a :-&gt;
--   Maybe]</tt> to <tt>F</tt>'s binders, which are <tt>[k, a, (b ::
--   k)]</tt>. The result should look like this:
--   
--   <pre>
--   type F (Type -&gt; Type) Maybe (b :: Type -&gt; Type) =
--     (Proxy <tt>(Type -&gt; Type) Maybe, Proxy </tt>(Type -&gt; Type) (b :: Type -&gt; Type))
--   </pre>
--   
--   Making this work requires some care. There are two cases:
--   
--   <ol>
--   <li>If we encounter a type variable in the domain of the substitution
--   (e.g., <tt>k</tt> or <tt>a</tt>), then we apply the substitution
--   directly.</li>
--   <li>Otherwise, we substitute into the type variable's kind (e.g., turn
--   <tt>b :: k</tt> to <tt>b :: Type -&gt; Type</tt>). We then return an
--   extended substitution where the old <tt>b</tt> (of kind <tt>k</tt>)
--   maps to the new <tt>b</tt> (of kind <tt>Type -&gt; Type</tt>).</li>
--   </ol>
--   
--   This step is important to do in case there are later occurrences of
--   <tt>b</tt>, which we must ensure have the correct kind. Otherwise, we
--   might end up with <tt>Proxy @(Type -&gt; Type) (b :: k)</tt> on the
--   right-hand side of the default instance, which would be completely
--   wrong.
--   
--   Contrast <a>substATBndrs</a> function with similar substitution
--   functions:
--   
--   <ul>
--   <li><tt>substTyVars</tt> does not substitute into the kinds of each
--   type variable, nor does it extend the substitution.
--   <tt>substTyVars</tt> is meant for occurrences of type variables,
--   whereas <tt>substATBndr</tt>s is meant for binders.</li>
--   <li><tt>substTyVarBndrs</tt> does substitute into kinds and extends
--   the substitution, but it does not apply the substitution to the
--   variables themselves. As such, <tt>substTyVarBndrs</tt> returns a list
--   of <a>TyVar</a>s rather than a list of <a>Type</a>s.</li>
--   </ul>
substATBndrs :: Subst -> [TyVar] -> (Subst, [Type])


-- | Generating derived instance declarations
--   
--   This module is nominally `<tt>subordinate'</tt> to
--   <a>GHC.Tc.Deriv</a>, which is the `<tt>official'</tt> interface to
--   deriving-related things.
--   
--   This is where we do all the grimy bindings' generation.
module GHC.Tc.Deriv.Generate

-- | A declarative description of an auxiliary binding that should be
--   generated. See <tt>Note [Auxiliary binders]</tt> for a more detailed
--   description of how these are used.
data AuxBindSpec

-- | <tt>$tag2con</tt>: Given a tag, computes the corresponding data
--   constructor
DerivTag2Con :: TyCon -> RdrName -> AuxBindSpec

-- | <tt>$maxtag</tt>: The maximum possible tag value among a data type's
--   constructors
DerivMaxTag :: TyCon -> RdrName -> AuxBindSpec

-- | <tt>$t</tt>: The <tt>DataType</tt> representation for a <tt>Data</tt>
--   instance
DerivDataDataType :: TyCon -> RdrName -> [RdrName] -> AuxBindSpec

-- | <tt>$c</tt>: The <tt>Constr</tt> representation for a <tt>Data</tt>
--   instance
DerivDataConstr :: DataCon -> RdrName -> RdrName -> AuxBindSpec
gen_Eq_binds :: SrcSpan -> DerivInstTys -> TcM (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Ord_binds :: SrcSpan -> DerivInstTys -> TcM (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Enum_binds :: SrcSpan -> DerivInstTys -> TcM (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Bounded_binds :: SrcSpan -> DerivInstTys -> (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Ix_binds :: SrcSpan -> DerivInstTys -> TcM (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Show_binds :: (Name -> Fixity) -> SrcSpan -> DerivInstTys -> (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Read_binds :: (Name -> Fixity) -> SrcSpan -> DerivInstTys -> (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Data_binds :: SrcSpan -> DerivInstTys -> TcM (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Lift_binds :: SrcSpan -> DerivInstTys -> (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Newtype_binds :: SrcSpan -> Class -> [TyVar] -> [Type] -> Type -> LHsBinds GhcPs
gen_Newtype_fam_insts :: SrcSpan -> Class -> [TyVar] -> [Type] -> Type -> TcM [FamInst]
mkCoerceClassMethEqn :: Class -> [TyVar] -> [Type] -> Type -> Id -> Pair Type

-- | Take a <a>Bag</a> of <a>AuxBindSpec</a>s and generate the code for
--   auxiliary bindings based on the declarative descriptions in the
--   supplied <a>AuxBindSpec</a>s. See <tt>Note [Auxiliary binders]</tt>.
genAuxBinds :: SrcSpan -> Bag AuxBindSpec -> Bag (LHsBind GhcPs, LSig GhcPs)
ordOpTbl :: [(Type, (RdrName, RdrName, RdrName, RdrName, RdrName))]
boxConTbl :: [(Type, LHsExpr GhcPs)]
mkRdrFunBind :: LocatedN RdrName -> [LMatch GhcPs (LHsExpr GhcPs)] -> LHsBind GhcPs

-- | Produces a function binding. When no equations are given, it generates
--   a binding of the given arity and an empty case expression for the last
--   argument that it passes to the given function to produce the
--   right-hand side.
mkRdrFunBindEC :: Arity -> (LHsExpr GhcPs -> LHsExpr GhcPs) -> LocatedN RdrName -> [LMatch GhcPs (LHsExpr GhcPs)] -> LHsBind GhcPs

-- | Produces a function binding. When there are no equations, it generates
--   a binding with the given arity that produces an error based on the
--   name of the type of the last argument.
mkRdrFunBindSE :: Arity -> LocatedN RdrName -> [LMatch GhcPs (LHsExpr GhcPs)] -> LHsBind GhcPs
error_Expr :: FastString -> LHsExpr GhcPs

-- | <tt>getPossibleDataCons tycon tycon_args</tt> returns the constructors
--   of <tt>tycon</tt> whose return types match when checked against
--   <tt>tycon_args</tt>.
--   
--   See Note [Filter out impossible GADT data constructors]
getPossibleDataCons :: TyCon -> [Type] -> [DataCon]

-- | Information about the arguments to the class in a stock- or
--   newtype-derived instance. For a <tt>deriving</tt>-generated instance
--   declaration such as this one:
--   
--   <pre>
--   instance Ctx =&gt; Cls cls_ty_1 ... cls_ty_m (TC tc_arg_1 ... tc_arg_n) where ...
--   </pre>
--   
--   <ul>
--   <li><a>dit_cls_tys</a> corresponds to <tt>cls_ty_1 ...
--   cls_ty_m</tt>.</li>
--   <li><a>dit_tc</a> corresponds to <tt>TC</tt>.</li>
--   <li><a>dit_tc_args</a> corresponds to <tt>tc_arg_1 ...
--   tc_arg_n</tt>.</li>
--   </ul>
--   
--   See <tt>Note [DerivEnv and DerivSpecMechanism]</tt> in
--   <a>GHC.Tc.Deriv.Utils</a> for a more in-depth explanation, including
--   the relationship between <a>dit_tc</a><i><a>dit_rep_tc</a> and
--   <a>dit_tc_args</a></i><a>dit_rep_tc_args</a>.
--   
--   A <a>DerivInstTys</a> value can be seen as a more structured
--   representation of the <tt>denv_inst_tys</tt> in a <tt>DerivEnv</tt>,
--   as the <tt>denv_inst_tys</tt> is equal to <tt>dit_cls_tys ++
--   [<a>mkTyConApp</a> dit_tc dit_tc_args]</tt>. Other parts of the
--   instance declaration can be found in the <tt>DerivEnv</tt>. For
--   example, the <tt>Cls</tt> in the example above corresponds to the
--   <tt>denv_cls</tt> field of <tt>DerivEnv</tt>.
--   
--   Similarly, the type variables that appear in a <a>DerivInstTys</a>
--   value are the same type variables as the <tt>denv_tvs</tt> in the
--   parent <tt>DerivEnv</tt>. Accordingly, if we are inferring an instance
--   context, the type variables will be <a>TcTyVar</a> skolems. Otherwise,
--   they will be ordinary <a>TyVar</a>s. See <tt>Note [Overlap and
--   deriving]</tt> in <a>GHC.Tc.Deriv.Infer</a>.
data DerivInstTys
DerivInstTys :: [Type] -> TyCon -> [Type] -> TyCon -> [Type] -> DataConEnv [Type] -> DerivInstTys

-- | Other arguments to the class except the last
[dit_cls_tys] :: DerivInstTys -> [Type]

-- | Type constructor for which the instance is requested (last arguments
--   to the type class)
[dit_tc] :: DerivInstTys -> TyCon

-- | Arguments to the type constructor
[dit_tc_args] :: DerivInstTys -> [Type]

-- | The representation tycon for <a>dit_tc</a> (for data family
--   instances). Otherwise the same as <a>dit_tc</a>.
[dit_rep_tc] :: DerivInstTys -> TyCon

-- | The representation types for <a>dit_tc_args</a> (for data family
--   instances). Otherwise the same as <a>dit_tc_args</a>.
[dit_rep_tc_args] :: DerivInstTys -> [Type]

-- | The cached results of instantiating each data constructor's field
--   types using <tt><a>dataConInstUnivs</a> data_con
--   <a>dit_rep_tc_args</a></tt>. See <tt>Note [Instantiating field types
--   in stock deriving]</tt>.
--   
--   This field is only used for stock-derived instances and goes unused
--   for newtype-derived instances. It is put here mainly for the sake of
--   convenience.
[dit_dc_inst_arg_env] :: DerivInstTys -> DataConEnv [Type]

-- | <tt><a>buildDataConInstArgEnv</a> tycon arg_tys</tt> constructs a
--   cache that maps each of <tt>tycon</tt>'s data constructors to their
--   field types, with are to be instantiated with <tt>arg_tys</tt>. See
--   <tt>Note [Instantiating field types in stock deriving]</tt>.
buildDataConInstArgEnv :: TyCon -> [Type] -> DataConEnv [Type]

-- | Look up a data constructor's instantiated field types in a
--   <a>DerivInstTys</a>. See <tt>Note [Instantiating field types in stock
--   deriving]</tt>.
derivDataConInstArgTys :: DataCon -> DerivInstTys -> [Type]

-- | Apply a substitution to all of the <a>Type</a>s contained in a
--   <a>DerivInstTys</a>. See <tt>Note [Instantiating field types in stock
--   deriving]</tt> for why we need to substitute into a
--   <a>DerivInstTys</a> in the first place.
substDerivInstTys :: Subst -> DerivInstTys -> DerivInstTys

-- | Zonk the <a>TcTyVar</a>s in a <a>DerivInstTys</a> value to
--   <a>TyVar</a>s. See <tt>Note [What is zonking?]</tt> in
--   <a>GHC.Tc.Zonk.Type</a>.
--   
--   This is only used in the final zonking step when inferring the context
--   for a derived instance. See <tt>Note [Overlap and deriving]</tt> in
--   <a>GHC.Tc.Deriv.Infer</a>.
zonkDerivInstTys :: DerivInstTys -> ZonkT TcM DerivInstTys
instance GHC.Utils.Outputable.Outputable GHC.Tc.Deriv.Generate.DerivInstTys


-- | The deriving code for the Functor, Foldable, and Traversable classes
module GHC.Tc.Deriv.Functor
data FFoldType a
FT :: a -> a -> a -> (a -> a -> a) -> (TyCon -> [a] -> a) -> (Type -> Type -> a -> a) -> a -> (TcTyVar -> a -> a) -> FFoldType a

-- | Does not contain variable
[ft_triv] :: FFoldType a -> a

-- | The variable itself
[ft_var] :: FFoldType a -> a

-- | The variable itself, contravariantly
[ft_co_var] :: FFoldType a -> a

-- | Function type
[ft_fun] :: FFoldType a -> a -> a -> a

-- | Tuple type. The <tt>[a]</tt> is the result of folding over the
--   arguments of the tuple.
[ft_tup] :: FFoldType a -> TyCon -> [a] -> a

-- | Type app, variable only in last argument. The two <a>Type</a>s are the
--   function and argument parts of <tt>fun_ty arg_ty</tt>, respectively.
[ft_ty_app] :: FFoldType a -> Type -> Type -> a -> a

-- | Type app, variable other than in last argument
[ft_bad_app] :: FFoldType a -> a

-- | Forall type
[ft_forall] :: FFoldType a -> TcTyVar -> a -> a
functorLikeTraverse :: TyVar -> FFoldType a -> Type -> a

-- | Return all syntactic subterms of a <a>Type</a> that are applied to the
--   <a>TyVar</a> argument. This determines what constraints should be
--   inferred for derived <a>Functor</a>, <a>Foldable</a>, and
--   <a>Traversable</a> instances in <a>GHC.Tc.Deriv.Infer</a>. For
--   instance, if we have:
--   
--   <pre>
--   data Foo a = MkFoo Int a (Maybe a) (Either Int (Maybe a))
--   </pre>
--   
--   Then the following would hold:
--   
--   <ul>
--   <li><tt><a>deepSubtypesContaining</a> a Int</tt> would return
--   <tt>[]</tt>, since <tt>Int</tt> does not contain the type variable
--   <tt>a</tt> at all.</li>
--   <li><tt><a>deepSubtypesContaining</a> a a</tt> would return
--   <tt>[]</tt>. Although the type <tt>a</tt> contains the type variable
--   <tt>a</tt>, it is not <i>applied</i> to <tt>a</tt>, which is the
--   criterion that <a>deepSubtypesContaining</a> checks for.</li>
--   <li><tt><a>deepSubtypesContaining</a> a (Maybe a)</tt> would return
--   <tt>[Maybe]</tt>, as <tt>Maybe</tt> is applied to <tt>a</tt>.</li>
--   <li><tt><a>deepSubtypesContaining</a> a (Either Int (Maybe a))</tt>
--   would return <tt>[Either Int, Maybe]</tt>. Both of these types are
--   applied to <tt>a</tt> through composition.</li>
--   </ul>
--   
--   As used in <a>GHC.Tc.Deriv.Infer</a>, the <a>Type</a> argument will
--   always come from <a>derivDataConInstArgTys</a>, so it is important
--   that the <a>TyVar</a> comes from <a>dataConUnivTyVars</a> to match.
--   Make sure <i>not</i> to take the <a>TyVar</a> from <a>tyConTyVars</a>,
--   as these differ from the <a>dataConUnivTyVars</a> when the data type
--   is a GADT. (See #22167 for what goes wrong if <a>tyConTyVars</a> is
--   used.)
deepSubtypesContaining :: TyVar -> Type -> [TcType]
foldDataConArgs :: FFoldType a -> DataCon -> DerivInstTys -> [a]
gen_Functor_binds :: SrcSpan -> DerivInstTys -> (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Foldable_binds :: SrcSpan -> DerivInstTys -> (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Traversable_binds :: SrcSpan -> DerivInstTys -> (LHsBinds GhcPs, Bag AuxBindSpec)


-- | The deriving code for the Generic class
module GHC.Tc.Deriv.Generics
canDoGenerics :: DerivInstTys -> Validity' [DeriveGenericsErrReason]
canDoGenerics1 :: DerivInstTys -> Validity' [DeriveGenericsErrReason]
data GenericKind
Gen0 :: GenericKind
Gen1 :: GenericKind
gen_Generic_binds :: GenericKind -> SrcSpan -> DerivInstTys -> TcM (LHsBinds GhcPs, [LSig GhcPs])
gen_Generic_fam_inst :: GenericKind -> (Name -> Fixity) -> SrcSpan -> DerivInstTys -> TcM FamInst

-- | Called by <a>inferConstraints</a>; generates a list of types, each of
--   which must be a <a>Functor</a> in order for the <tt>Generic1</tt>
--   instance to work. For instance, if we have:
--   
--   <pre>
--   data Foo a = MkFoo Int a (Maybe a) (Either Int (Maybe a))
--   </pre>
--   
--   Then <tt><a>get_gen1_constrained_tys</a> a (f (g a))</tt> would return
--   <tt>[Either Int]</tt>, as a derived <tt>Generic1</tt> instance would
--   need to call <a>fmap</a> at that type. Invoking
--   <tt><a>get_gen1_constrained_tys</a> a</tt> on any of the other fields
--   would return <tt>[]</tt>.
--   
--   <a>get_gen1_constrained_tys</a> is very similar in spirit to
--   <a>deepSubtypesContaining</a> in <a>GHC.Tc.Deriv.Functor</a>. Just
--   like with <a>deepSubtypesContaining</a>, it is important that the
--   <a>TyVar</a> argument come from <a>dataConUnivTyVars</a>. (See #22167
--   for what goes wrong if <a>tyConTyVars</a> is used.)
get_gen1_constrained_tys :: TyVar -> Type -> [Type]


-- | Error-checking and other utilities for <tt>deriving</tt> clauses or
--   declarations.
module GHC.Tc.Deriv.Utils

-- | To avoid having to manually plumb everything in <a>DerivEnv</a>
--   throughout various functions in <a>GHC.Tc.Deriv</a> and
--   <a>GHC.Tc.Deriv.Infer</a>, we use <a>DerivM</a>, which is a simple
--   reader around <a>TcRn</a>.
type DerivM = ReaderT DerivEnv TcRn

-- | Contains all of the information known about a derived instance when
--   determining what its <tt>EarlyDerivSpec</tt> should be. See <tt>Note
--   [DerivEnv and DerivSpecMechanism]</tt>.
data DerivEnv
DerivEnv :: Maybe OverlapMode -> [TyVar] -> Class -> [Type] -> DerivContext -> SkolemInfo -> Maybe (DerivStrategy GhcTc) -> Maybe (WarningTxt GhcRn) -> DerivEnv

-- | Is this an overlapping instance?
[denv_overlap_mode] :: DerivEnv -> Maybe OverlapMode

-- | Universally quantified type variables in the instance. If the
--   <tt>denv_ctxt</tt> is <a>InferContext</a>, these will be
--   <a>TcTyVar</a> skolems. If the <tt>denv_ctxt</tt> is
--   <a>SupplyContext</a>, these will be ordinary <a>TyVar</a>s. See
--   <tt>Note [Overlap and deriving]</tt> in <a>GHC.Tc.Deriv.Infer</a>.
--   
--   All type variables that appear in the <a>denv_inst_tys</a>,
--   <a>denv_ctxt</a>, <a>denv_skol_info</a>, and <a>denv_strat</a> should
--   come from <a>denv_tvs</a>.
[denv_tvs] :: DerivEnv -> [TyVar]

-- | Class for which we need to derive an instance
[denv_cls] :: DerivEnv -> Class

-- | All arguments to <a>denv_cls</a> in the derived instance.
[denv_inst_tys] :: DerivEnv -> [Type]

-- | <tt><a>SupplyContext</a> theta</tt> for standalone deriving (where
--   <tt>theta</tt> is the context of the instance). <a>InferContext</a>
--   for <tt>deriving</tt> clauses, or for standalone deriving that uses a
--   wildcard constraint. See <tt>Note [Inferring the instance
--   context]</tt>.
[denv_ctxt] :: DerivEnv -> DerivContext

-- | The <a>SkolemInfo</a> used to skolemise the <tt>denv_tvs</tt> in the
--   case where the <a>denv_ctxt</a> is <a>InferContext</a>.
[denv_skol_info] :: DerivEnv -> SkolemInfo

-- | <a>Just</a> if user requests a particular deriving strategy.
--   Otherwise, <a>Nothing</a>.
[denv_strat] :: DerivEnv -> Maybe (DerivStrategy GhcTc)

-- | A warning to emit whenever the derived instance is used
[denv_warn] :: DerivEnv -> Maybe (WarningTxt GhcRn)
data DerivSpec theta
DS :: SrcSpan -> Name -> [TyVar] -> theta -> Class -> [Type] -> SkolemInfo -> UserTypeCtxt -> Maybe OverlapMode -> Maybe SrcSpan -> DerivSpecMechanism -> Maybe (WarningTxt GhcRn) -> DerivSpec theta
[ds_loc] :: DerivSpec theta -> SrcSpan
[ds_name] :: DerivSpec theta -> Name
[ds_tvs] :: DerivSpec theta -> [TyVar]
[ds_theta] :: DerivSpec theta -> theta
[ds_cls] :: DerivSpec theta -> Class
[ds_tys] :: DerivSpec theta -> [Type]
[ds_skol_info] :: DerivSpec theta -> SkolemInfo
[ds_user_ctxt] :: DerivSpec theta -> UserTypeCtxt
[ds_overlap] :: DerivSpec theta -> Maybe OverlapMode
[ds_standalone_wildcard] :: DerivSpec theta -> Maybe SrcSpan
[ds_mechanism] :: DerivSpec theta -> DerivSpecMechanism
[ds_warn] :: DerivSpec theta -> Maybe (WarningTxt GhcRn)
pprDerivSpec :: Outputable theta => DerivSpec theta -> SDoc

-- | Set the <a>ds_theta</a> in a <a>DerivSpec</a>.
setDerivSpecTheta :: theta' -> DerivSpec theta -> DerivSpec theta'

-- | Zonk the <a>TcTyVar</a>s in a <a>DerivSpec</a> to <a>TyVar</a>s. See
--   <tt>Note [What is zonking?]</tt> in <a>GHC.Tc.Zonk.Type</a>.
--   
--   This is only used in the final zonking step when inferring the context
--   for a derived instance. See <tt>Note [Overlap and deriving]</tt> in
--   <a>GHC.Tc.Deriv.Infer</a>.
zonkDerivSpec :: DerivSpec ThetaType -> ZonkTcM (DerivSpec ThetaType)

-- | What action to take in order to derive a class instance. See <tt>Note
--   [DerivEnv and DerivSpecMechanism]</tt>, as well as <tt>Note [Deriving
--   strategies]</tt> in <a>GHC.Tc.Deriv</a>.
data DerivSpecMechanism

-- | "Standard" classes
DerivSpecStock :: DerivInstTys -> StockGenFns -> DerivSpecMechanism

-- | Information about the arguments to the class in the derived instance,
--   including what type constructor the last argument is headed by. See
--   <tt>Note [DerivEnv and DerivSpecMechanism]</tt>.
[dsm_stock_dit] :: DerivSpecMechanism -> DerivInstTys

-- | How to generate the instance bindings and associated type family
--   instances.
[dsm_stock_gen_fns] :: DerivSpecMechanism -> StockGenFns

-- | <pre>
--   GeneralizedNewtypeDeriving
--   </pre>
DerivSpecNewtype :: DerivInstTys -> Type -> DerivSpecMechanism

-- | Information about the arguments to the class in the derived instance,
--   including what type constructor the last argument is headed by. See
--   <tt>Note [DerivEnv and DerivSpecMechanism]</tt>.
[dsm_newtype_dit] :: DerivSpecMechanism -> DerivInstTys

-- | The newtype rep type.
[dsm_newtype_rep_ty] :: DerivSpecMechanism -> Type

-- | <pre>
--   DeriveAnyClass
--   </pre>
DerivSpecAnyClass :: DerivSpecMechanism

-- | <pre>
--   DerivingVia
--   </pre>
DerivSpecVia :: [Type] -> Type -> Type -> DerivSpecMechanism

-- | All arguments to the class besides the last one.
[dsm_via_cls_tys] :: DerivSpecMechanism -> [Type]

-- | The last argument to the class.
[dsm_via_inst_ty] :: DerivSpecMechanism -> Type

-- | The <tt>via</tt> type
[dsm_via_ty] :: DerivSpecMechanism -> Type

-- | Convert a <a>DerivSpecMechanism</a> to its corresponding
--   <a>DerivStrategy</a>.
derivSpecMechanismToStrategy :: DerivSpecMechanism -> DerivStrategy GhcTc
isDerivSpecStock :: DerivSpecMechanism -> Bool
isDerivSpecNewtype :: DerivSpecMechanism -> Bool
isDerivSpecAnyClass :: DerivSpecMechanism -> Bool
isDerivSpecVia :: DerivSpecMechanism -> Bool

-- | Zonk the <a>TcTyVar</a>s in a <a>DerivSpecMechanism</a> to
--   <a>TyVar</a>s. See <tt>Note [What is zonking?]</tt> in
--   <a>GHC.Tc.Zonk.Type</a>.
--   
--   This is only used in the final zonking step when inferring the context
--   for a derived instance. See <tt>Note [Overlap and deriving]</tt> in
--   <a>GHC.Tc.Deriv.Infer</a>.
zonkDerivSpecMechanism :: DerivSpecMechanism -> ZonkTcM DerivSpecMechanism

-- | Whether GHC is processing a <tt>deriving</tt> clause or a standalone
--   deriving declaration.
data DerivContext

-- | <tt>'InferContext mb_wildcard</tt> is either:
--   
--   <ul>
--   <li>A <tt>deriving</tt> clause (in which case <tt>mb_wildcard</tt> is
--   <a>Nothing</a>).</li>
--   <li>A standalone deriving declaration with an extra-constraints
--   wildcard as the context (in which case <tt>mb_wildcard</tt> is
--   <tt><a>Just</a> loc</tt>, where <tt>loc</tt> is the location of the
--   wildcard.</li>
--   </ul>
--   
--   GHC should infer the context.
InferContext :: Maybe SrcSpan -> DerivContext

-- | <tt><a>SupplyContext</a> theta</tt> is a standalone deriving
--   declaration, where <tt>theta</tt> is the context supplied by the user.
SupplyContext :: ThetaType -> DerivContext

-- | Records whether a particular class can be derived by way of an
--   <i>originative</i> deriving strategy (i.e., <tt>stock</tt> or
--   <tt>anyclass</tt>).
--   
--   See <tt>Note [Deriving strategies]</tt> in <a>GHC.Tc.Deriv</a>.
data OriginativeDerivStatus
CanDeriveStock :: StockGenFns -> OriginativeDerivStatus
StockClassError :: !DeriveInstanceErrReason -> OriginativeDerivStatus
CanDeriveAnyClass :: OriginativeDerivStatus
NonDerivableClass :: OriginativeDerivStatus

-- | Describes how to generate instance bindings (<a>stock_gen_binds</a>)
--   and associated type family instances (<a>stock_gen_fam_insts</a>) for
--   a particular stock-derived instance.
data StockGenFns
StockGenFns :: (SrcSpan -> DerivInstTys -> TcM (LHsBinds GhcPs, [LSig GhcPs], Bag AuxBindSpec, [Name])) -> (SrcSpan -> DerivInstTys -> TcM [FamInst]) -> StockGenFns

-- | Describes how to generate instance bindings for a stock-derived
--   instance.
--   
--   This function takes two arguments:
--   
--   <ol>
--   <li><a>SrcSpan</a>: the source location where the instance is being
--   derived. This will eventually be instantiated with the <a>ds_loc</a>
--   field of a <a>DerivSpec</a>.</li>
--   <li><a>DerivInstTys</a>: information about the argument types to which
--   a class is applied in a derived instance. This will eventually be
--   instantiated with the <a>dsm_stock_dit</a> field of a
--   <a>DerivSpecMechanism</a>.</li>
--   </ol>
--   
--   This function returns four things:
--   
--   <ol>
--   <li><tt><a>LHsBinds</a> <a>GhcPs</a></tt>: The derived instance's
--   function bindings (e.g., <tt>compare (T x) (T y) = compare x
--   y</tt>)</li>
--   <li><tt>[<a>LSig</a> <a>GhcPs</a>]</tt>: A list of instance specific
--   signatures/pragmas. Most likely <tt>INLINE</tt> pragmas for class
--   methods.</li>
--   <li><tt><a>Bag</a> <a>AuxBindSpec</a></tt>: Auxiliary bindings needed
--   to support the derived instance. As examples, derived <a>Eq</a> and
--   <a>Ord</a> instances sometimes require top-level <tt>con2tag</tt>
--   functions. See <tt>Note [Auxiliary binders]</tt> in
--   <a>GHC.Tc.Deriv.Generate</a>.</li>
--   <li><tt>[<a>Name</a>]</tt>: A list of Names for which
--   <tt>-Wunused-binds</tt> should be suppressed. This is used to suppress
--   unused warnings for record selectors when deriving <a>Read</a>,
--   <a>Show</a>, or <tt>Generic</tt>. See <tt>Note [Deriving and unused
--   record selectors]</tt>.</li>
--   </ol>
[stock_gen_binds] :: StockGenFns -> SrcSpan -> DerivInstTys -> TcM (LHsBinds GhcPs, [LSig GhcPs], Bag AuxBindSpec, [Name])

-- | Describes how to generate associated type family instances for a
--   stock-derived instance. This function takes the same arguments as the
--   <a>stock_gen_binds</a> function but returns a list of <a>FamInst</a>s
--   instead. Generating type family instances is done separately from
--   <a>stock_gen_binds</a> since the type family instances must be
--   generated before the instance bindings can be typechecked. See
--   <tt>Note [Staging of tcDeriving]</tt> in <a>GHC.Tc.Deriv</a>.
[stock_gen_fam_insts] :: StockGenFns -> SrcSpan -> DerivInstTys -> TcM [FamInst]

-- | Is GHC processing a standalone deriving declaration?
isStandaloneDeriv :: DerivM Bool

-- | Is GHC processing a standalone deriving declaration with an
--   extra-constraints wildcard as the context? (e.g., <tt>deriving
--   instance _ =&gt; Eq (Foo a)</tt>)
isStandaloneWildcardDeriv :: DerivM Bool

-- | Return <a>InstDeclCtxt</a> if processing with a standalone
--   <tt>deriving</tt> declaration or <a>DerivClauseCtxt</a> if processing
--   a <tt>deriving</tt> clause.
askDerivUserTypeCtxt :: DerivM UserTypeCtxt

-- | <tt><a>mkDerivOrigin</a> wc</tt> returns <a>StandAloneDerivOrigin</a>
--   if <tt>wc</tt> is <a>True</a>, and <a>DerivClauseOrigin</a> if
--   <tt>wc</tt> is <a>False</a>. Useful for error-reporting.
mkDerivOrigin :: Bool -> CtOrigin

-- | A <a>PredSpec</a> specifies a constraint to emitted when inferring the
--   instance context for a derived instance in <a>simplifyInfer</a>.
data PredSpec

-- | An ordinary <a>PredSpec</a> that directly stores a <a>PredType</a>,
--   which will be emitted as a wanted constraint in the constraint solving
--   machinery. This is the simple case, as there are no skolems,
--   metavariables, or given constraints involved.
SimplePredSpec :: TcPredType -> CtOrigin -> TypeOrKind -> PredSpec

-- | The constraint to emit as a wanted
[sps_pred] :: PredSpec -> TcPredType

-- | The origin of the constraint
[sps_origin] :: PredSpec -> CtOrigin

-- | Whether the constraint is a type or kind
[sps_type_or_kind] :: PredSpec -> TypeOrKind

-- | A special <a>PredSpec</a> that is only used by
--   <tt>DeriveAnyClass</tt>. This will check if <tt>stps_ty_actual</tt> is
--   a subtype of (i.e., more polymorphic than) <tt>stps_ty_expected</tt>
--   in the constraint solving machinery, emitting an implication
--   constraint as a side effect. For more details on how this works, see
--   <tt>Note [Gathering and simplifying constraints for
--   DeriveAnyClass]</tt> in <a>GHC.Tc.Deriv.Infer</a>.
SubTypePredSpec :: TcSigmaType -> TcSigmaType -> CtOrigin -> PredSpec

-- | The actual type. In the context of <tt>DeriveAnyClass</tt>, this is
--   the default method type signature.
[stps_ty_actual] :: PredSpec -> TcSigmaType

-- | The expected type. In the context of <tt>DeriveAnyClass</tt>, this is
--   the original method type signature.
[stps_ty_expected] :: PredSpec -> TcSigmaType

-- | The origin of the constraint
[stps_origin] :: PredSpec -> CtOrigin

-- | A list of <a>PredSpec</a> constraints to simplify when inferring a
--   derived instance's context. For the <tt>stock</tt>, <tt>newtype</tt>,
--   and <tt>via</tt> deriving strategies, these will consist of
--   <a>SimplePredSpec</a>s, and for <tt>DeriveAnyClass</tt>, these will
--   consist of <a>SubTypePredSpec</a>s. Here is an example to illustrate
--   the latter:
--   
--   <pre>
--   class Foo a where
--     bar :: forall b. Ix b =&gt; a -&gt; b -&gt; String
--     default bar :: forall y. (Show a, Ix y) =&gt; a -&gt; y -&gt; String
--     bar x y = show x ++ show (range (y, y))
--   
--     baz :: Eq a =&gt; a -&gt; a -&gt; Bool
--     default baz :: Ord a =&gt; a -&gt; a -&gt; Bool
--     baz x y = compare x y == EQ
--   
--   data Quux q = Quux deriving anyclass Foo
--   </pre>
--   
--   Then it would generate two <a>SubTypePredSpec</a>s, one for each
--   method:
--   
--   <pre>
--   [ SubTypePredSpec
--       { stps_ty_actual   = forall y. (Show (Quux q), Ix y) =&gt; Quux q -&gt; y -&gt; String
--       , stps_ty_expected = forall b.                (Ix b) =&gt; Quux q -&gt; b -&gt; String
--       , stps_ty_origin   = DerivClauseCtxt
--       }
--   , SubTypePredSpec
--       { stps_ty_actual   = Ord (Quux q) =&gt; Quux q -&gt; Quux q -&gt; Bool
--       , stps_ty_expected = Eq  (Quux q) =&gt; Quux q -&gt; Quux q -&gt; Bool
--       , stps_ty_origin   = DerivClauseCtxt
--       }
--   ]
--   </pre>
--   
--   (Note that the type variable <tt>q</tt> is bound by the data type
--   <tt>Quux</tt>, and thus appears free in the <a>stps_ty_actual</a>s and
--   <a>stps_ty_expected</a>s.)
--   
--   See <tt>Note [Gathering and simplifying constraints for
--   DeriveAnyClass]</tt> in <a>GHC.Tc.Deriv.Infer</a> for an explanation
--   of how these <a>SubTypePredSpec</a>s are used to compute implication
--   constraints.
type ThetaSpec = [PredSpec]

-- | Build a list of <a>SimplePredSpec</a>s, using the supplied
--   <a>CtOrigin</a> and <a>TypeOrKind</a> values for each <a>PredType</a>.
mkDirectThetaSpec :: CtOrigin -> TypeOrKind -> ThetaType -> ThetaSpec
substPredSpec :: HasDebugCallStack => Subst -> PredSpec -> PredSpec

-- | Capture wanted constraints from a <a>ThetaSpec</a>.
captureThetaSpecConstraints :: UserTypeCtxt -> ThetaSpec -> TcM (TcLevel, WantedConstraints)
checkOriginativeSideConditions :: DerivInstTys -> DerivM OriginativeDerivStatus
hasStockDeriving :: Class -> Maybe StockGenFns
std_class_via_coercible :: Class -> Bool
non_coercible_class :: Class -> Bool
newDerivClsInst :: DerivSpec ThetaType -> TcM ClsInst
extendLocalInstEnv :: [ClsInst] -> TcM a -> TcM a
instance GHC.Utils.Outputable.Outputable GHC.Tc.Deriv.Utils.DerivContext
instance GHC.Utils.Outputable.Outputable GHC.Tc.Deriv.Utils.DerivEnv
instance GHC.Utils.Outputable.Outputable theta => GHC.Utils.Outputable.Outputable (GHC.Tc.Deriv.Utils.DerivSpec theta)
instance GHC.Utils.Outputable.Outputable GHC.Tc.Deriv.Utils.DerivSpecMechanism
instance GHC.Utils.Outputable.Outputable GHC.Tc.Deriv.Utils.PredSpec


-- | Functions for inferring (and simplifying) the context for derived
--   instances.
module GHC.Tc.Deriv.Infer
inferConstraints :: DerivSpecMechanism -> DerivM (ThetaSpec, [TyVar], [TcType], DerivSpecMechanism)
simplifyInstanceContexts :: [DerivSpec ThetaSpec] -> TcM [DerivSpec ThetaType]

module GHC.Tc.Gen.Head
data HsExprArg (p :: TcPass)
[EValArg] :: forall (p :: TcPass). AppCtxt -> !XEVAType p -> LHsExpr (GhcPass (XPass p)) -> HsExprArg p
[EValArgQL] :: AppCtxt -> Scaled TcSigmaType -> LHsExpr GhcRn -> (HsExpr GhcTc, AppCtxt) -> UsageEnv -> [HsExprArg 'TcpInst] -> WantedConstraints -> Bool -> TcRhoType -> HsExprArg 'TcpInst
[ETypeArg] :: forall (p :: TcPass). AppCtxt -> LHsWcType GhcRn -> !XETAType p -> HsExprArg p
[EPrag] :: forall (p :: TcPass). AppCtxt -> HsPragE (GhcPass (XPass p)) -> HsExprArg p
[EWrap] :: forall (p :: TcPass). EWrap -> HsExprArg p
data TcPass
TcpRn :: TcPass
TcpInst :: TcPass
TcpTc :: TcPass
data QLFlag
DoQL :: QLFlag
NoQL :: QLFlag
data EWrap
EPar :: AppCtxt -> EWrap
EExpand :: HsThingRn -> EWrap
EHsWrap :: HsWrapper -> EWrap
data AppCtxt
VAExpansion :: HsThingRn -> SrcSpan -> SrcSpan -> AppCtxt
VACall :: HsExpr GhcRn -> Int -> SrcSpan -> AppCtxt
appCtxtLoc :: AppCtxt -> SrcSpan
insideExpansion :: AppCtxt -> Bool
splitHsApps :: HsExpr GhcRn -> TcM ((HsExpr GhcRn, AppCtxt), [HsExprArg 'TcpRn])

-- | Rebuild an application: takes a type-checked application head
--   expression together with arguments in the form of typechecked
--   <a>HsExprArg</a>s and returns a typechecked application of the head to
--   the arguments.
--   
--   This performs a representation-polymorphism check to ensure that
--   representation-polymorphic unlifted newtypes have been eta-expanded.
--   
--   See Note [Eta-expanding rep-poly unlifted newtypes].
rebuildHsApps :: (HsExpr GhcTc, AppCtxt) -> [HsExprArg 'TcpTc] -> HsExpr GhcTc
addArgWrap :: forall (p :: TcPass). HsWrapper -> [HsExprArg p] -> [HsExprArg p]
isHsValArg :: forall (id :: TcPass). HsExprArg id -> Bool
leadingValArgs :: [HsExprArg 'TcpRn] -> [LHsExpr GhcRn]
isVisibleArg :: forall (id :: TcPass). HsExprArg id -> Bool
tcInferAppHead :: (HsExpr GhcRn, AppCtxt) -> TcM (HsExpr GhcTc, TcSigmaType)
tcInferAppHead_maybe :: HsExpr GhcRn -> TcM (Maybe (HsExpr GhcTc, TcSigmaType))
tcInferId :: Name -> TcM (HsExpr GhcTc, TcSigmaType)
tcCheckId :: Name -> ExpRhoType -> TcM (HsExpr GhcTc)
obviousSig :: HsExpr GhcRn -> Maybe (LHsSigWcType GhcRn)
tyConOf :: FamInstEnvs -> TcSigmaType -> Maybe TyCon
tyConOfET :: FamInstEnvs -> ExpRhoType -> Maybe TyCon
fieldNotInType :: RecSelParent -> RdrName -> TcRnMessage
nonBidirectionalErr :: Name -> TcRnMessage
pprArgInst :: HsExprArg 'TcpInst -> SDoc
addHeadCtxt :: AppCtxt -> TcM a -> TcM a
addExprCtxt :: HsExpr GhcRn -> TcRn a -> TcRn a
addStmtCtxt :: ExprStmt GhcRn -> TcRn a -> TcRn a
addFunResCtxt :: forall (p :: TcPass) a. HsExpr GhcTc -> [HsExprArg p] -> TcType -> ExpRhoType -> TcM a -> TcM a
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.Head.AppCtxt
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.Head.EWrap
instance GHC.Hs.Extension.OutputableBndrId (GHC.Tc.Gen.Head.XPass p) => GHC.Utils.Outputable.Outputable (GHC.Tc.Gen.Head.HsExprArg p)
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.Head.QLFlag


-- | Typecheck some <tt>Matches</tt>
module GHC.Tc.Gen.Match
tcFunBindMatches :: UserTypeCtxt -> Name -> Mult -> MatchGroup GhcRn (LHsExpr GhcRn) -> [ExpPatType] -> ExpRhoType -> TcM (HsWrapper, MatchGroup GhcTc (LHsExpr GhcTc))
tcCaseMatches :: (AnnoBody body, Outputable (body GhcTc)) => TcMatchAltChecker body -> Scaled TcSigmaTypeFRR -> MatchGroup GhcRn (LocatedA (body GhcRn)) -> ExpRhoType -> TcM (HsWrapper, MatchGroup GhcTc (LocatedA (body GhcTc)))
tcLambdaMatches :: HsExpr GhcRn -> HsLamVariant -> MatchGroup GhcRn (LHsExpr GhcRn) -> [ExpPatType] -> ExpSigmaType -> TcM (HsWrapper, MatchGroup GhcTc (LHsExpr GhcTc))
tcGRHSList :: AnnoBody body => HsMatchContextRn -> TcMatchAltChecker body -> [LGRHS GhcRn (LocatedA (body GhcRn))] -> ExpRhoType -> TcM [LGRHS GhcTc (LocatedA (body GhcTc))]
tcGRHSsPat :: Mult -> GRHSs GhcRn (LHsExpr GhcRn) -> ExpRhoType -> TcM (GRHSs GhcTc (LHsExpr GhcTc))
type TcStmtChecker (body :: Type -> Type) rho_type = forall thing. () => HsStmtContextRn -> Stmt GhcRn LocatedA body GhcRn -> rho_type -> rho_type -> TcM thing -> TcM (Stmt GhcTc LocatedA body GhcTc, thing)
type TcExprStmtChecker = TcStmtChecker HsExpr ExpRhoType
type TcCmdStmtChecker = TcStmtChecker HsCmd TcRhoType
tcStmts :: forall (body :: Type -> Type) rho_type. AnnoBody body => HsStmtContextRn -> TcStmtChecker body rho_type -> [LStmt GhcRn (LocatedA (body GhcRn))] -> rho_type -> TcM [LStmt GhcTc (LocatedA (body GhcTc))]
tcStmtsAndThen :: forall (body :: Type -> Type) rho_type thing. AnnoBody body => HsStmtContextRn -> TcStmtChecker body rho_type -> [LStmt GhcRn (LocatedA (body GhcRn))] -> rho_type -> (rho_type -> TcM thing) -> TcM ([LStmt GhcTc (LocatedA (body GhcTc))], thing)
tcDoStmts :: HsDoFlavour -> LocatedLW [LStmt GhcRn (LHsExpr GhcRn)] -> ExpRhoType -> TcM (HsExpr GhcTc)
tcBody :: LHsExpr GhcRn -> ExpRhoType -> TcM (LHsExpr GhcTc)
tcDoStmt :: TcExprStmtChecker
tcGuardStmt :: TcExprStmtChecker

-- | <tt>checkArgCounts</tt> takes a <tt>[RenamedMatch]</tt> and decides
--   whether the same number of <i>required</i> (aka visible) args are used
--   in each equation. Returns the arity, the number of required args E.g.
--   f @a True y = ... f False z = ... The MatchGroup for <tt>f</tt> has
--   arity 2, not 3
checkArgCounts :: AnnoBody body => MatchGroup GhcRn (LocatedA (body GhcRn)) -> TcM VisArity


-- | Typecheck arrow notation
module GHC.Tc.Gen.Arrow
tcProc :: LPat GhcRn -> LHsCmdTop GhcRn -> ExpRhoType -> TcM (LPat GhcTc, LHsCmdTop GhcTc, TcCoercion)

module GHC.Tc.Gen.App
tcApp :: HsExpr GhcRn -> ExpRhoType -> TcM (HsExpr GhcTc)
tcInferSigma :: Bool -> LHsExpr GhcRn -> TcM TcSigmaType
tcExprPrag :: HsPragE GhcRn -> HsPragE GhcTc
instance GHC.Internal.Base.Monoid GHC.Tc.Gen.App.TcMBool
instance GHC.Internal.Base.Monoid GHC.Tc.Gen.App.TcMUnit
instance GHC.Internal.Base.Semigroup GHC.Tc.Gen.App.TcMBool
instance GHC.Internal.Base.Semigroup GHC.Tc.Gen.App.TcMUnit

module GHC.Tc.Gen.Expr
tcCheckPolyExpr :: LHsExpr GhcRn -> TcSigmaType -> TcM (LHsExpr GhcTc)
tcCheckPolyExprNC :: LHsExpr GhcRn -> TcSigmaType -> TcM (LHsExpr GhcTc)
tcCheckMonoExpr :: LHsExpr GhcRn -> TcRhoType -> TcM (LHsExpr GhcTc)
tcCheckMonoExprNC :: LHsExpr GhcRn -> TcRhoType -> TcM (LHsExpr GhcTc)
tcMonoExpr :: LHsExpr GhcRn -> ExpRhoType -> TcM (LHsExpr GhcTc)
tcMonoExprNC :: LHsExpr GhcRn -> ExpRhoType -> TcM (LHsExpr GhcTc)
tcInferRho :: LHsExpr GhcRn -> TcM (LHsExpr GhcTc, TcRhoType)
tcInferRhoNC :: LHsExpr GhcRn -> TcM (LHsExpr GhcTc, TcRhoType)
tcPolyLExpr :: LHsExpr GhcRn -> ExpSigmaType -> TcM (LHsExpr GhcTc)
tcPolyExpr :: HsExpr GhcRn -> ExpSigmaType -> TcM (HsExpr GhcTc)
tcExpr :: HsExpr GhcRn -> ExpRhoType -> TcM (HsExpr GhcTc)
tcPolyLExprSig :: LHsExpr GhcRn -> TcCompleteSig -> TcM (LHsExpr GhcTc)

-- | Typecheck a syntax operator The operator is a variable or a lambda at
--   this stage (i.e. renamer output)t
tcSyntaxOp :: CtOrigin -> SyntaxExprRn -> [SyntaxOpType] -> ExpRhoType -> ([TcSigmaType] -> [Mult] -> TcM a) -> TcM (a, SyntaxExprTc)

-- | Slightly more general version of <a>tcSyntaxOp</a> that allows the
--   caller to specify the shape of the result of the syntax operator
tcSyntaxOpGen :: CtOrigin -> SyntaxExprRn -> [SyntaxOpType] -> SyntaxOpType -> ([TcSigmaTypeFRR] -> [Mult] -> TcM a) -> TcM (a, SyntaxExprTc)

-- | What to expect for an argument to a rebindable-syntax operator. Quite
--   like <a>Type</a>, but allows for holes to be filled in by tcSyntaxOp.
--   The callback called from tcSyntaxOp gets a list of types; the meaning
--   of these types is determined by a left-to-right depth-first traversal
--   of the <a>SyntaxOpType</a> tree. So if you pass in
--   
--   <pre>
--   SynAny `SynFun` (SynList `SynFun` SynType Int) `SynFun` SynAny
--   </pre>
--   
--   you'll get three types back: one for the first <a>SynAny</a>, the
--   <i>element</i> type of the list, and one for the last <a>SynAny</a>.
--   You don't get anything for the <a>SynType</a>, because you've said
--   positively that it should be an Int, and so it shall be.
--   
--   You'll also get three multiplicities back: one for each function
--   arrow. See also Note [Linear types] in Multiplicity.
--   
--   This is defined here to avoid defining it in <a>GHC.Tc.Gen.Expr</a>
--   boot file.
data SyntaxOpType

-- | Any type
SynAny :: SyntaxOpType

-- | A rho type, skolemised or instantiated as appropriate
SynRho :: SyntaxOpType

-- | A list type. You get back the element type of the list
SynList :: SyntaxOpType

-- | A function.
SynFun :: SyntaxOpType -> SyntaxOpType -> SyntaxOpType

-- | A known type.
SynType :: ExpType -> SyntaxOpType
infixr 0 `SynFun`

-- | Like <a>SynType</a> but accepts a regular TcType
synKnownType :: TcType -> SyntaxOpType
tcCheckId :: Name -> ExpRhoType -> TcM (HsExpr GhcTc)


-- | Typechecking rewrite rules
module GHC.Tc.Gen.Rule
tcRules :: [LRuleDecls GhcRn] -> TcM [LRuleDecls GhcTc]


-- | Typechecking <tt>foreign</tt> declarations
--   
--   A foreign declaration is used to either give an externally implemented
--   function a Haskell type (and calling interface) or give a Haskell
--   function an external calling interface. Either way, the range of
--   argument and result types these functions can accommodate is
--   restricted to what the outside world understands (read C), and this
--   module checks to see if a foreign declaration has got a legal type.
module GHC.Tc.Gen.Foreign
tcForeignImports :: [LForeignDecl GhcRn] -> TcM ([Id], [LForeignDecl GhcTc], Bag GlobalRdrElt)
tcForeignExports :: [LForeignDecl GhcRn] -> TcM (LHsBinds GhcTc, [LForeignDecl GhcTc], Bag GlobalRdrElt)
isForeignImport :: UnXRec name => LForeignDecl name -> Bool
isForeignExport :: UnXRec name => LForeignDecl name -> Bool
tcFImport :: LForeignDecl GhcRn -> TcM (Id, LForeignDecl GhcTc, Bag GlobalRdrElt)
tcFExport :: ForeignDecl GhcRn -> TcM (LHsBind GhcTc, ForeignDecl GhcTc, Bag GlobalRdrElt)
tcForeignImports' :: [LForeignDecl GhcRn] -> TcM ([Id], [LForeignDecl GhcTc], Bag GlobalRdrElt)
tcCheckFIType :: [Scaled Type] -> Type -> ForeignImport GhcRn -> TcM (ForeignImport GhcTc)
checkCTarget :: ForeignImport GhcRn -> CCallTarget -> TcM ()
checkForeignArgs :: (Type -> Validity' IllegalForeignTypeReason) -> [Scaled Type] -> TcM ()

-- | Check that the type has the form (IO t) or (t) , and that t satisfies
--   the given predicate. When calling this function, any newtype wrappers
--   (should) have been already dealt with by normaliseFfiType.
--   
--   We also check that the Safe Haskell condition of FFI imports having
--   results in the IO monad holds.
checkForeignRes :: Bool -> Bool -> (Type -> Validity' IllegalForeignTypeReason) -> Type -> TcM ()
normaliseFfiType :: Type -> TcM (Reduction, Bag GlobalRdrElt)
nonIOok :: Bool
mustBeIO :: Bool
checkSafe :: Bool
noCheckSafe :: Bool
tcForeignExports' :: [LForeignDecl GhcRn] -> TcM (LHsBinds GhcTc, [LForeignDecl GhcTc], Bag GlobalRdrElt)
tcCheckFEType :: Type -> ForeignExport GhcRn -> TcM (ForeignExport GhcTc)


-- | Handles <tt>deriving</tt> clauses on <tt>data</tt> declarations.
module GHC.Tc.Deriv
tcDeriving :: [DerivInfo] -> [LDerivDecl GhcRn] -> TcM (TcGblEnv, Bag (InstInfo GhcRn), HsValBinds GhcRn)

-- | Stuff needed to process a datatype's `deriving` clauses
data DerivInfo
DerivInfo :: TyCon -> ![(Name, TyVar)] -> [LHsDerivingClause GhcRn] -> SDoc -> DerivInfo

-- | The data tycon for normal datatypes, or the *representation* tycon for
--   data families
[di_rep_tc] :: DerivInfo -> TyCon

-- | Variables that scope over the deriving clause. See <tt>Note [Scoped
--   tyvars in a TcTyCon]</tt> in <a>GHC.Core.TyCon</a>.
[di_scoped_tvs] :: DerivInfo -> ![(Name, TyVar)]
[di_clauses] :: DerivInfo -> [LHsDerivingClause GhcRn]

-- | error context
[di_ctxt] :: DerivInfo -> SDoc
instance GHC.Utils.Outputable.Outputable GHC.Tc.Deriv.EarlyDerivSpec


-- | Typecheck type and class declarations
module GHC.Tc.TyCl
tcTyAndClassDecls :: [TyClGroup GhcRn] -> TcM (TcGblEnv, [InstInfo GhcRn], [DerivInfo], ThBindEnv)
kcConDecls :: Foldable f => NewOrData -> TcKind -> f (LConDecl GhcRn) -> TcM ()
tcConDecls :: DataDeclInfo -> KnotTied TyCon -> [TcTyConBinder] -> TcKind -> DataDefnCons (LConDecl GhcRn) -> TcM (DataDefnCons DataCon)
data DataDeclInfo
DDataType :: DataDeclInfo
DDataInstance :: Type -> DataDeclInfo
dataDeclChecks :: Name -> Maybe (LHsContext GhcRn) -> DataDefnCons (LConDecl GhcRn) -> TcM Bool
checkValidTyCon :: TyCon -> TcM ()
tcFamTyPats :: TyCon -> HsFamEqnPats GhcRn -> TcM (TcType, TcKind)
tcTyFamInstEqn :: TcTyCon -> AssocInstInfo -> LTyFamInstEqn GhcRn -> TcM (KnotTied CoAxBranch, TyFamEqnValidityInfo)
tcAddTyFamInstCtxt :: TyFamInstDecl GhcRn -> TcM a -> TcM a
tcMkDataFamInstCtxt :: DataFamInstDecl GhcRn -> SDoc
tcAddDataFamInstCtxt :: DataFamInstDecl GhcRn -> TcM a -> TcM a
unravelFamInstPats :: TcType -> [TcType]
addConsistencyConstraints :: AssocInstInfo -> TcType -> TcM ()
checkFamTelescope :: TcLevel -> HsOuterFamEqnTyVarBndrs GhcRn -> [TcTyVar] -> TcM ()


-- | Typechecking instance declarations
module GHC.Tc.TyCl.Instance
tcInstDecls1 :: [LInstDecl GhcRn] -> TcM (TcGblEnv, [InstInfo GhcRn], [DerivInfo], ThBindEnv)

-- | Use DerivInfo for data family instances (produced by tcInstDecls1),
--   datatype declarations (TyClDecl), and standalone deriving declarations
--   (DerivDecl) to check and process all derived class instances.
tcInstDeclsDeriv :: [DerivInfo] -> [LDerivDecl GhcRn] -> TcM (TcGblEnv, [InstInfo GhcRn], HsValBinds GhcRn)
tcInstDecls2 :: [LTyClDecl GhcRn] -> [InstInfo GhcRn] -> TcM (LHsBinds GhcTc)


-- | Typechecking a whole module
--   
--   
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/type-checker</a>
module GHC.Tc.Module

-- | The returned [Id] is the list of new Ids bound by this statement. It
--   can be used to extend the InteractiveContext via
--   extendInteractiveContext.
--   
--   The returned TypecheckedHsExpr is of type IO [ Any ], a list of the
--   bound values, coerced to Any.
tcRnStmt :: HscEnv -> GhciLStmt GhcPs -> IO (Messages TcRnMessage, Maybe ([Id], LHsExpr GhcTc, FixityEnv))

-- | tcRnExpr just finds the type of an expression for :type
tcRnExpr :: HscEnv -> TcRnExprMode -> LHsExpr GhcPs -> IO (Messages TcRnMessage, Maybe Type)

-- | How should we infer a type? See Note [TcRnExprMode]
data TcRnExprMode

-- | Instantiate inferred quantifiers only (:type)
TM_Inst :: TcRnExprMode

-- | Instantiate all quantifiers, and do eager defaulting (:type +d)
TM_Default :: TcRnExprMode
tcRnType :: HscEnv -> ZonkFlexi -> Bool -> LHsType GhcPs -> IO (Messages TcRnMessage, Maybe (Type, Kind))
tcRnImportDecls :: HscEnv -> [LImportDecl GhcPs] -> IO (Messages TcRnMessage, Maybe GlobalRdrEnv)

-- | Find all the Names that this RdrName could mean, in GHCi
tcRnLookupRdrName :: HscEnv -> LocatedN RdrName -> IO (Messages TcRnMessage, Maybe [Name])

-- | ASSUMES that the module is either in the <tt>HomePackageTable</tt> or
--   is a package module with an interface on disk. If neither of these is
--   true, then the result will be an error indicating the interface could
--   not be found.
getModuleInterface :: HscEnv -> Module -> IO (Messages TcRnMessage, Maybe ModIface)
tcRnDeclsi :: HscEnv -> [LHsDecl GhcPs] -> IO (Messages TcRnMessage, Maybe TcGblEnv)
isGHCiMonad :: HscEnv -> String -> IO (Messages TcRnMessage, Maybe Name)
runTcInteractive :: HscEnv -> TcRn a -> IO (Messages TcRnMessage, Maybe a)
withTcPlugins :: HscEnv -> TcM a -> TcM a
withHoleFitPlugins :: HscEnv -> TcM a -> TcM a
tcRnLookupName :: HscEnv -> Name -> IO (Messages TcRnMessage, Maybe TyThing)
tcRnGetInfo :: HscEnv -> Name -> IO (Messages TcRnMessage, Maybe (TyThing, Fixity, [ClsInst], [FamInst], SDoc))

-- | Top level entry point for typechecker and renamer
tcRnModule :: HscEnv -> ModSummary -> Bool -> HsParsedModule -> IO (Messages TcRnMessage, Maybe TcGblEnv)
tcRnModuleTcRnM :: HscEnv -> ModSummary -> HsParsedModule -> (Module, SrcSpan) -> TcRn TcGblEnv
tcTopSrcDecls :: HsGroup GhcRn -> TcM (TcGblEnv, TcLclEnv)
rnTopSrcDecls :: HsGroup GhcPs -> TcM (TcGblEnv, HsGroup GhcRn)

-- | Compares the two things for equivalence between boot-file and normal
--   code. Returns <tt>Nothing</tt> on success or <tt>Just "some helpful
--   info for user"</tt> failure. If the difference will be apparent to the
--   user, <tt>Just empty</tt> is perfectly suitable.
checkBootDecl :: HsBootOrSig -> TyThing -> TyThing -> BootErrsM BootMismatchWhat
checkHiBootIface' :: [ClsInst] -> TypeEnv -> [AvailInfo] -> ModDetails -> TcM [(Id, Id)]

-- | For a module <tt>modname</tt> of type <a>HscSource</a>, determine the
--   list of extra "imports" of other requirements which should be
--   considered part of the import of the requirement, because it
--   transitively depends on those requirements by imports of modules from
--   other packages. The situation is something like this:
--   
--   unit p where signature X signature Y import X
--   
--   unit q where dependency p[X=&lt;A&gt;,Y=&lt;B&gt;] signature A
--   signature B
--   
--   Although q's B does not directly import A, we still have to make sure
--   we process A first, because the merging process will cause B to
--   indirectly import A. This function finds the TRANSITIVE closure of all
--   such imports we need to make.
findExtraSigImports :: HscEnv -> HscSource -> ModuleName -> IO [ModuleName]
implicitRequirements :: HscEnv -> [(PkgQual, Located ModuleName)] -> IO [ModuleName]

-- | Given a <a>Unit</a>, make sure it is well typed. This is because unit
--   IDs come from Cabal, which does not know if things are well-typed or
--   not; a component may have been filled with implementations for the
--   holes that don't actually fulfill the requirements.
checkUnit :: Unit -> TcM ()

-- | Given a local <a>ModIface</a>, merge all inherited requirements from
--   <a>requirementMerges</a> into this signature, producing a final
--   <a>TcGblEnv</a> that matches the local signature and all required
--   signatures.
mergeSignatures :: HasDebugCallStack => HsParsedModule -> TcGblEnv -> ModIface -> TcRn TcGblEnv

-- | Top-level driver for signature merging (run after typechecking an
--   <tt>hsig</tt> file).
tcRnMergeSignatures :: HscEnv -> HsParsedModule -> TcGblEnv -> ModIface -> IO (Messages TcRnMessage, Maybe TcGblEnv)

-- | Given <a>tcg_mod</a>, instantiate a <a>ModIface</a> from the
--   indefinite library to use the actual implementations of the relevant
--   entities, checking that the implementation matches the signature.
instantiateSignature :: TcRn TcGblEnv

-- | Top-level driver for signature instantiation (run when compiling an
--   <tt>hsig</tt> file.)
tcRnInstantiateSignature :: HscEnv -> Module -> RealSrcSpan -> IO (Messages TcRnMessage, Maybe TcGblEnv)
loadUnqualIfaces :: HscEnv -> InteractiveContext -> TcM ()

-- | Compares two things for equivalence between boot-file and normal code,
--   reporting an error if they don't match up.
checkBootDeclM :: HsBootOrSig -> TyThing -> TyThing -> TcM ()

-- | Extract the renamed information from TcGblEnv.
getRenamedStuff :: TcGblEnv -> RenamedStuff
type RenamedStuff = Maybe (HsGroup GhcRn, [LImportDecl GhcRn], Maybe [(LIE GhcRn, Avails)], Maybe LHsDoc GhcRn, Maybe XRec GhcRn ModuleName)

module GHC.HsToCore.Monad

-- | Desugaring monad. See also <tt>TcM</tt>.
type DsM = TcRnIf DsGblEnv DsLclEnv
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | Run a <a>DsM</a> action inside the <a>IO</a> monad.
initDs :: HscEnv -> TcGblEnv -> DsM a -> IO (Messages DsMessage, Maybe a)

-- | Run a <a>DsM</a> action inside the <a>TcM</a> monad.
initDsTc :: DsM a -> TcM (Messages DsMessage, Maybe a)
initTcDsForSolver :: TcM a -> DsM a

-- | Run a <a>DsM</a> action in the context of an existing <a>ModGuts</a>
initDsWithModGuts :: HscEnv -> ModGuts -> DsM a -> IO (Messages DsMessage, Maybe a)
fixDs :: (a -> DsM a) -> DsM a
foldlM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
whenGOptM :: GeneralFlag -> TcRnIf gbl lcl () -> TcRnIf gbl lcl ()
unsetGOptM :: GeneralFlag -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
unsetWOptM :: WarningFlag -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
xoptM :: Extension -> TcRnIf gbl lcl Bool
class Functor f => Applicative (f :: Type -> Type)
pure :: Applicative f => a -> f a
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
(*>) :: Applicative f => f a -> f b -> f b
(<*) :: Applicative f => f a -> f b -> f a
(<$>) :: Functor f => (a -> b) -> f a -> f b
duplicateLocalDs :: Id -> DsM Id
newSysLocalDs :: Scaled Type -> DsM Id
newSysLocalsDs :: [Scaled Type] -> DsM [Id]
newSysLocalMDs :: Type -> DsM Id
newSysLocalsMDs :: [Type] -> DsM [Id]
newFailLocalMDs :: Type -> DsM Id
newUniqueId :: Id -> Mult -> Type -> DsM Id
newPredVarDs :: PredType -> DsM Var
getSrcSpanDs :: DsM SrcSpan
putSrcSpanDs :: SrcSpan -> DsM a -> DsM a
putSrcSpanDsA :: EpAnn ann -> DsM a -> DsM a
mkNamePprCtxDs :: DsM NamePprCtx
newUnique :: TcRnIf gbl lcl Unique

-- | Unique Supply
--   
--   A value of type <a>UniqSupply</a> is unique, and it can supply
--   <i>one</i> distinct <a>Unique</a>. Also, from the supply, one can also
--   manufacture an arbitrary number of further <tt>UniqueSupply</tt>
--   values, which will be distinct from the first and from all others.
data UniqSupply
newUniqueSupply :: TcRnIf gbl lcl UniqSupply
getGhcModeDs :: DsM GhcMode
dsGetFamInstEnvs :: DsM FamInstEnvs
dsLookupGlobal :: Name -> DsM TyThing
dsLookupGlobalId :: Name -> DsM Id
dsLookupTyCon :: Name -> DsM TyCon
dsLookupDataCon :: Name -> DsM DataCon
dsLookupConLike :: Name -> DsM ConLike

-- | See <a>getCCIndexM</a>.
getCCIndexDsM :: FastString -> DsM CostCentreIndex
type DsMetaEnv = NameEnv DsMetaVal
data DsMetaVal
DsBound :: Id -> DsMetaVal
DsSplice :: HsExpr GhcTc -> DsMetaVal
dsGetMetaEnv :: DsM (NameEnv DsMetaVal)
dsLookupMetaEnv :: Name -> DsM (Maybe DsMetaVal)
dsExtendMetaEnv :: DsMetaEnv -> DsM a -> DsM a

-- | Get the current pattern match oracle state. See <a>dsl_nablas</a>.
getPmNablas :: DsM Nablas

-- | Set the pattern match oracle state within the scope of the given
--   action. See <a>dsl_nablas</a>.
updPmNablas :: Nablas -> DsM a -> DsM a
addUnspecables :: Set EvId -> DsM a -> DsM a
getUnspecables :: DsM (Set EvId)

-- | The <tt>COMPLETE</tt> pragmas that are in scope.
dsGetCompleteMatches :: DsM DsCompleteMatches
type DsWarning = (SrcSpan, SDoc)

-- | Emit a diagnostic for the current source location. In case the
--   diagnostic is a warning, the latter will be ignored and discarded if
--   the relevant <a>WarningFlag</a> is not set in the DynFlags. See Note
--   [Discarding Messages] in <a>Error</a>.
diagnosticDs :: DsMessage -> DsM ()

-- | Issue an error, but return the expression for (), so that we can
--   continue reporting errors.
errDsCoreExpr :: DsMessage -> DsM CoreExpr
failWithDs :: DsMessage -> DsM a
failDs :: DsM a
discardWarningsDs :: DsM a -> DsM a
addMessagesDs :: Messages DsMessage -> DsM ()
captureMessagesDs :: DsM a -> DsM (Messages DsMessage, a)
data DsMatchContext
DsMatchContext :: HsMatchContextRn -> SrcSpan -> DsMatchContext
data EquationInfo
EqnMatch :: LPat GhcTc -> EquationInfo -> EquationInfo

-- | The first pattern of the equation
--   
--   NB: The location info is used to determine whether the pattern is
--   generated or not. This helps us avoid warnings on patterns that GHC
--   elaborated.
--   
--   NB: We have <i>already</i> applied <tt>decideBangHood</tt> to this
--   pattern. See Note [decideBangHood] in <a>GHC.HsToCore.Utils</a>
[eqn_pat] :: EquationInfo -> LPat GhcTc

-- | The rest of the equation after its first pattern
[eqn_rest] :: EquationInfo -> EquationInfo

-- | What to do after match
EqnDone :: MatchResult CoreExpr -> EquationInfo
type EquationInfoNE = EquationInfo
prependPats :: [LPat GhcTc] -> EquationInfo -> EquationInfo
mkEqnInfo :: [LPat GhcTc] -> MatchResult CoreExpr -> EquationInfo
eqnMatchResult :: EquationInfo -> MatchResult CoreExpr

-- | This is a value of type a with potentially a CoreExpr-shaped hole in
--   it. This is used to deal with cases where we are potentially handling
--   pattern match failure, and want to later specify how failure is
--   handled.
data MatchResult a

-- | We represent the case where there is no hole without a function from
--   <a>CoreExpr</a>, like this, because sometimes we have nothing to put
--   in the hole and so want to be sure there is in fact no hole.
MR_Infallible :: DsM a -> MatchResult a
MR_Fallible :: (CoreExpr -> DsM a) -> MatchResult a
runMatchResult :: CoreExpr -> MatchResult a -> DsM a
type DsWrapper = CoreExpr -> CoreExpr
idDsWrapper :: DsWrapper

-- | Inject a trace message into the compiled program. Whereas pprTrace
--   prints out information *while compiling*, pprRuntimeTrace captures
--   that information and causes it to be printed *at runtime* using
--   Debug.Trace.trace.
--   
--   pprRuntimeTrace hdr doc expr
--   
--   will produce an expression that looks like
--   
--   trace (hdr + doc) expr
--   
--   When using this to debug a module that Debug.Trace depends on, it is
--   necessary to import {-# SOURCE #-} Debug.Trace () in that module. We
--   could avoid this inconvenience by wiring in Debug.Trace.trace, but
--   that doesn't seem worth the effort and maintenance cost.
pprRuntimeTrace :: String -> SDoc -> CoreExpr -> DsM CoreExpr
instance GHC.Internal.Base.Applicative GHC.HsToCore.Monad.MatchResult
instance GHC.Internal.Base.Functor GHC.HsToCore.Monad.MatchResult
instance GHC.Types.TyThing.MonadThings (GHC.Data.IOEnv.IOEnv (GHC.Tc.Types.Env GHC.HsToCore.Types.DsGblEnv GHC.HsToCore.Types.DsLclEnv))
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Monad.DsMatchContext
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Monad.EquationInfo


-- | Utility module for the pattern-match coverage checker.
module GHC.HsToCore.Pmc.Utils
tracePm :: String -> SDoc -> DsM ()
traceWhenFailPm :: String -> SDoc -> MaybeT DsM a -> MaybeT DsM a

-- | Generate a fresh <a>Id</a> of a given type
mkPmId :: Type -> DsM Id

-- | All warning flags that need to run the pattern match checker.
allPmCheckWarnings :: [WarningFlag]

-- | Check whether the redundancy checker should run (redundancy only)
overlapping :: DynFlags -> HsMatchContext fn -> Bool

-- | Check whether the exhaustiveness checker should run (exhaustiveness
--   only)
exhaustive :: DynFlags -> HsMatchContext fn -> Bool

-- | Check whether unnecessary bangs should be warned about
redundantBang :: DynFlags -> Bool

-- | Denotes whether an exhaustiveness check is supported, and if so, via
--   which <a>WarningFlag</a> it's controlled. Returns <a>Nothing</a> if
--   check is not supported.
exhaustiveWarningFlag :: HsMatchContext fn -> Maybe WarningFlag

-- | Check whether any part of pattern match checking is enabled for this
--   <a>HsMatchContext</a> (does not matter whether it is the redundancy
--   check or the exhaustiveness check).
isMatchContextPmChecked :: DynFlags -> Origin -> HsMatchContext fn -> Bool

-- | Check whether exhaustivity checks are enabled for this
--   <a>HsMatchContext</a>, when dealing with a single pattern (using the
--   <tt>matchSinglePatVar</tt> function).
isMatchContextPmChecked_SinglePat :: DynFlags -> Origin -> HsMatchContext fn -> LPat GhcTc -> Bool

-- | Return True when any of the pattern match warnings
--   (<a>allPmCheckWarnings</a>) are enabled, in which case we need to run
--   the pattern match checker.
needToRunPmCheck :: DynFlags -> Origin -> Bool


-- | Model refinements type as per the <a>Lower Your Guards paper</a>. The
--   main export of the module are the functions <a>addPhiCtsNablas</a> for
--   adding facts to the oracle, <a>isInhabited</a> to check if a
--   refinement type is inhabited and <a>generateInhabitingPatterns</a> to
--   turn a <a>Nabla</a> into a concrete pattern for an equation.
--   
--   In terms of the LYG paper, this module is concerned with Sections 3.4,
--   3.6 and 3.7. E.g., it represents refinement types directly as a bunch
--   of normalised refinement types <a>Nabla</a>.
module GHC.HsToCore.Pmc.Solver

-- | A normalised refinement type ∇ ("nabla"), comprised of an inert set of
--   canonical (i.e. mutually compatible) term and type constraints that
--   form the refinement type's predicate.
data Nabla

-- | A disjunctive bag of <a>Nabla</a>s, representing a refinement type.
newtype Nablas
MkNablas :: Bag Nabla -> Nablas
initNablas :: Nablas

-- | A high-level pattern-match constraint. Corresponds to φ from Figure 3
--   of the LYG paper.
data PhiCt

-- | A type constraint "T ~ U".
PhiTyCt :: !PredType -> PhiCt

-- | <tt>PhiCoreCt x e</tt> encodes "x ~ e", equating <tt>x</tt> with the
--   <a>CoreExpr</a> <tt>e</tt>.
PhiCoreCt :: !Id -> !CoreExpr -> PhiCt

-- | <tt>PhiConCt x K tvs dicts ys</tt> encodes <tt>K @tvs dicts ys &lt;-
--   x</tt>, matching <tt>x</tt> against the <a>PmAltCon</a> application
--   <tt>K @tvs dicts ys</tt>, binding <tt>tvs</tt>, <tt>dicts</tt> and
--   possibly unlifted fields <tt>ys</tt> in the process. See Note [Strict
--   fields and variables of unlifted type].
PhiConCt :: !Id -> !PmAltCon -> ![TyVar] -> ![PredType] -> ![Id] -> PhiCt

-- | <tt>PhiNotConCt x K</tt> encodes "x ≁ K", asserting that <tt>x</tt>
--   can't be headed by <tt>K</tt>.
PhiNotConCt :: !Id -> !PmAltCon -> PhiCt

-- | <tt>PhiBotCt x</tt> encodes "x ~ ⊥", equating <tt>x</tt> to ⊥. by
--   <tt>K</tt>.
PhiBotCt :: !Id -> PhiCt

-- | <tt>PhiNotBotCt x y</tt> encodes "x ≁ ⊥", asserting that <tt>x</tt>
--   can't be ⊥.
PhiNotBotCt :: !Id -> PhiCt
type PhiCts = Bag PhiCt

-- | <tt>addPmCtsNablas</tt> for a single <tt>PmCt</tt>.
addPhiCtNablas :: Nablas -> PhiCt -> DsM Nablas

-- | Add a bunch of <a>PhiCt</a>s to all the <a>Nabla</a>s. Lifts
--   <a>addPhiCts</a> over many <a>Nablas</a>.
addPhiCtsNablas :: Nablas -> PhiCts -> DsM Nablas

-- | Test if any of the <a>Nabla</a>s is inhabited. Currently this is pure,
--   because we preserve the invariant that there are no uninhabited
--   <a>Nabla</a>s. But that could change in the future, for example by
--   implementing this function in terms of <tt>notNull <a>$</a>
--   generateInhabitingPatterns 1 ds</tt>.
isInhabited :: Nablas -> DsM Bool

-- | <tt>generateInhabitingPatterns vs n nabla</tt> returns a list of at
--   most <tt>n</tt> (but perhaps empty) refinements of <tt>nabla</tt> that
--   represent inhabited patterns. Negative information is only retained if
--   literals are involved or for recursive GADTs.
generateInhabitingPatterns :: GenerateInhabitingPatternsMode -> [Id] -> Int -> Nabla -> DsM [Nabla]

-- | See Note [Case split inhabiting patterns]
data GenerateInhabitingPatternsMode
CaseSplitTopLevel :: GenerateInhabitingPatternsMode
MinimalCover :: GenerateInhabitingPatternsMode
instance GHC.Classes.Eq GHC.HsToCore.Pmc.Solver.GenerateInhabitingPatternsMode
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.GenerateInhabitingPatternsMode
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.PhiCt
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.TopNormaliseTypeResult
instance GHC.Internal.Show.Show GHC.HsToCore.Pmc.Solver.GenerateInhabitingPatternsMode


-- | Coverage checking step of the <a>Lower Your Guards paper</a>.
--   
--   Coverage check guard trees (like <tt><a>PmMatch</a> <a>Pre</a></tt>)
--   to get a <a>CheckResult</a>, containing
--   
--   <ol>
--   <li>The set of uncovered values, <a>cr_uncov</a></li>
--   <li>And an annotated tree variant (like <tt><a>PmMatch</a>
--   <a>Post</a></tt>) that captures redundancy and inaccessibility
--   information as <a>RedSets</a> annotations</li>
--   </ol>
--   
--   Basically the UA function from Section 5.1, which is an optimised
--   interleaving of U and A from Section 3.2 (Figure 5). The Normalised
--   Refinement Types <a>Nablas</a> are maintained in
--   <a>GHC.HsToCore.Pmc.Solver</a>.
module GHC.HsToCore.Pmc.Check

-- | Coverage checking action. Can be composed <a>leftToRight</a> or
--   <a>topToBottom</a>.
newtype CheckAction a
CA :: (Nablas -> DsM (CheckResult a)) -> CheckAction a
[unCA] :: CheckAction a -> Nablas -> DsM (CheckResult a)
checkMatchGroup :: PmMatchGroup Pre -> CheckAction (PmMatchGroup Post)
checkGRHSs :: PmGRHSs Pre -> CheckAction (PmGRHSs Post)
checkPatBind :: PmPatBind Pre -> CheckAction (PmPatBind Post)
checkEmptyCase :: PmEmptyCase -> CheckAction PmEmptyCase
checkRecSel :: PmRecSel () -> CheckAction (PmRecSel Id)
instance GHC.Internal.Base.Functor GHC.HsToCore.Pmc.Check.CheckAction


-- | Utility functions for constructing Core syntax, principally for
--   desugaring
module GHC.HsToCore.Utils
data EquationInfo
EqnMatch :: LPat GhcTc -> EquationInfo -> EquationInfo

-- | The first pattern of the equation
--   
--   NB: The location info is used to determine whether the pattern is
--   generated or not. This helps us avoid warnings on patterns that GHC
--   elaborated.
--   
--   NB: We have <i>already</i> applied <tt>decideBangHood</tt> to this
--   pattern. See Note [decideBangHood] in <a>GHC.HsToCore.Utils</a>
[eqn_pat] :: EquationInfo -> LPat GhcTc

-- | The rest of the equation after its first pattern
[eqn_rest] :: EquationInfo -> EquationInfo

-- | What to do after match
EqnDone :: MatchResult CoreExpr -> EquationInfo
firstPat :: EquationInfoNE -> Pat GhcTc
shiftEqns :: Functor f => f EquationInfoNE -> f EquationInfo
combineEqnRhss :: NonEmpty EquationInfo -> DsM (MatchResult CoreExpr)

-- | This is a value of type a with potentially a CoreExpr-shaped hole in
--   it. This is used to deal with cases where we are potentially handling
--   pattern match failure, and want to later specify how failure is
--   handled.
data MatchResult a

-- | We represent the case where there is no hole without a function from
--   <a>CoreExpr</a>, like this, because sometimes we have nothing to put
--   in the hole and so want to be sure there is in fact no hole.
MR_Infallible :: DsM a -> MatchResult a
MR_Fallible :: (CoreExpr -> DsM a) -> MatchResult a
data CaseAlt a
MkCaseAlt :: a -> [Var] -> HsWrapper -> MatchResult CoreExpr -> CaseAlt a
[alt_pat] :: CaseAlt a -> a
[alt_bndrs] :: CaseAlt a -> [Var]
[alt_wrapper] :: CaseAlt a -> HsWrapper
[alt_result] :: CaseAlt a -> MatchResult CoreExpr
cantFailMatchResult :: CoreExpr -> MatchResult CoreExpr
alwaysFailMatchResult :: MatchResult CoreExpr
extractMatchResult :: MatchResult CoreExpr -> CoreExpr -> DsM CoreExpr
combineMatchResults :: MatchResult CoreExpr -> MatchResult CoreExpr -> MatchResult CoreExpr
adjustMatchResultDs :: (a -> DsM b) -> MatchResult a -> MatchResult b
shareFailureHandler :: MatchResult CoreExpr -> MatchResult CoreExpr
dsHandleMonadicFailure :: HsDoFlavour -> LPat GhcTc -> Type -> MatchResult CoreExpr -> FailOperator GhcTc -> DsM CoreExpr
mkCoLetMatchResult :: CoreBind -> MatchResult CoreExpr -> MatchResult CoreExpr
mkViewMatchResult :: Id -> CoreExpr -> MatchResult CoreExpr -> MatchResult CoreExpr
mkGuardedMatchResult :: CoreExpr -> MatchResult CoreExpr -> MatchResult CoreExpr
matchCanFail :: MatchResult a -> Bool
mkEvalMatchResult :: Id -> Type -> MatchResult CoreExpr -> MatchResult CoreExpr
mkCoPrimCaseMatchResult :: Id -> Type -> [(Literal, MatchResult CoreExpr)] -> MatchResult CoreExpr
mkCoAlgCaseMatchResult :: Id -> Type -> NonEmpty (CaseAlt DataCon) -> MatchResult CoreExpr
mkCoSynCaseMatchResult :: Id -> Type -> CaseAlt PatSyn -> MatchResult CoreExpr
wrapBind :: Var -> Var -> CoreExpr -> CoreExpr
wrapBinds :: [(Var, Var)] -> CoreExpr -> CoreExpr
mkErrorAppDs :: Id -> Type -> SDoc -> DsM CoreExpr
mkCoreAppDs :: SDoc -> CoreExpr -> CoreExpr -> CoreExpr
mkCoreAppsDs :: SDoc -> CoreExpr -> [CoreExpr] -> CoreExpr
mkCastDs :: CoreExpr -> Coercion -> CoreExpr
mkFailExpr :: HsMatchContextRn -> Type -> DsM CoreExpr
seqVar :: Var -> CoreExpr -> CoreExpr
mkLHsPatTup :: [LPat GhcTc] -> LPat GhcTc
mkVanillaTuplePat :: [LPat GhcTc] -> Boxity -> Pat GhcTc
mkBigLHsVarTupId :: [Id] -> LHsExpr GhcTc
mkBigLHsTupId :: [LHsExpr GhcTc] -> LHsExpr GhcTc
mkBigLHsVarPatTupId :: [Id] -> LPat GhcTc
mkBigLHsPatTupId :: [LPat GhcTc] -> LPat GhcTc
mkSelectorBinds :: [[CoreTickish]] -> LPat GhcTc -> HsMatchContextRn -> CoreExpr -> DsM (Id, [(Id, CoreExpr)])
selectSimpleMatchVarL :: Mult -> LPat GhcTc -> DsM Id
selectMatchVars :: [(Mult, Pat GhcTc)] -> DsM [Id]
selectMatchVar :: Mult -> Pat GhcTc -> DsM Id
mkOptTickBox :: [CoreTickish] -> CoreExpr -> CoreExpr
mkBinaryTickBox :: Int -> Int -> CoreExpr -> DsM CoreExpr

-- | Use -XStrict to add a ! or remove a ~ See Note [decideBangHood]
decideBangHood :: DynFlags -> LPat GhcTc -> LPat GhcTc
isTrueLHsExpr :: LHsExpr GhcTc -> Maybe (CoreExpr -> DsM CoreExpr)
checkMultiplicityCoercions :: MultiplicityCheckCoercions -> DsM ()

module GHC.HsToCore.Foreign.Call
dsCCall :: CLabelString -> [CoreExpr] -> Safety -> Type -> DsM CoreExpr
mkFCall :: Unique -> ForeignCall -> [CoreExpr] -> Type -> CoreExpr
unboxArg :: CoreExpr -> DsM (CoreExpr, CoreExpr -> CoreExpr)
boxResult :: Type -> DsM (Type, CoreExpr -> CoreExpr)
resultWrapper :: Type -> DsM (Maybe Type, CoreExpr -> CoreExpr)

module GHC.HsToCore.Foreign.Wasm
dsWasmJSImport :: Id -> Coercion -> CImportSpec -> Safety -> DsM ([Binding], CHeader, CStub, [Id])
dsWasmJSExport :: Id -> Coercion -> CLabelString -> DsM (CHeader, CStub, String, [Id], [Binding])


-- | Foreign primitive calls
--   
--   This is for `<tt>foreign import prim</tt>' declarations.
--   
--   Currently, at the core level we pretend that these primitive calls are
--   foreign calls. It may make more sense in future to have them as a
--   distinct kind of Id, or perhaps to bundle them with PrimOps since
--   semantically and for calling convention they are really prim ops.
module GHC.HsToCore.Foreign.Prim
dsPrimCall :: Id -> Coercion -> ForeignCall -> DsM ([(Id, Expr TyVar)], CHeader, CStub)


-- | Handling of JavaScript foreign imports/exports
module GHC.HsToCore.Foreign.JavaScript

-- | Desugaring of JavaScript foreign imports
dsJsImport :: Id -> Coercion -> CImportSpec -> CCallConv -> Safety -> Maybe Header -> DsM ([Binding], CHeader, CStub)
dsJsFExport :: Id -> Coercion -> CLabelString -> CCallConv -> Bool -> DsM (CHeader, CStub, String)
dsJsFExportDynamic :: Id -> Coercion -> CCallConv -> DsM ([Binding], CHeader, CStub)


-- | Handling of C foreign imports/exports
module GHC.HsToCore.Foreign.C
dsCImport :: Id -> Coercion -> CImportSpec -> CCallConv -> Safety -> Maybe Header -> DsM ([Binding], CHeader, CStub)
dsCFExport :: Id -> Coercion -> CLabelString -> CCallConv -> Bool -> DsM (CHeader, CStub, String)
dsCFExportDynamic :: Id -> Coercion -> CCallConv -> DsM ([Binding], CHeader, CStub)


-- | Desugaring foreign declarations
module GHC.HsToCore.Foreign.Decl
dsForeigns :: [LForeignDecl GhcTc] -> DsM (ForeignStubs, OrdList Binding)

module GHC.HsToCore.Match.Literal
dsLit :: HsLit GhcRn -> DsM CoreExpr

-- | Post-typechecker, the <a>HsExpr</a> field of an <a>OverLit</a>
--   contains (an expression for) the literal value itself.
dsOverLit :: HsOverLit GhcTc -> DsM CoreExpr
hsLitKey :: Platform -> HsLit GhcTc -> Literal
tidyLitPat :: HsLit GhcTc -> Pat GhcTc
tidyNPat :: HsOverLit GhcTc -> Maybe (SyntaxExpr GhcTc) -> SyntaxExpr GhcTc -> Type -> Pat GhcTc
matchLiterals :: NonEmpty Id -> Type -> NonEmpty (NonEmpty EquationInfoNE) -> DsM (MatchResult CoreExpr)
matchNPlusKPats :: NonEmpty Id -> Type -> NonEmpty EquationInfoNE -> DsM (MatchResult CoreExpr)
matchNPats :: NonEmpty Id -> Type -> NonEmpty EquationInfoNE -> DsM (MatchResult CoreExpr)
warnAboutIdentities :: DynFlags -> Id -> Type -> DsM ()

-- | Emit warnings on overloaded integral literals which overflow the
--   bounds implied by their type.
warnAboutOverflowedOverLit :: HsOverLit GhcTc -> DsM ()

-- | Emit warnings on integral literals which overflow the bounds implied
--   by their type.
warnAboutOverflowedLit :: HsLit GhcTc -> DsM ()

-- | Warns about <tt>[2,3 .. 1]</tt> or <tt>[<tt>b</tt> .. <tt>a</tt>]</tt>
--   which return the empty list. For numeric literals, only works for
--   integral types, not floating point.
warnAboutEmptyEnumerations :: FamInstEnvs -> DynFlags -> LHsExpr GhcTc -> Maybe (LHsExpr GhcTc) -> LHsExpr GhcTc -> DsM ()

module GHC.HsToCore.GuardedRHSs
dsGuarded :: GRHSs GhcTc (LHsExpr GhcTc) -> Type -> NonEmpty Nablas -> DsM CoreExpr
dsGRHSs :: HsMatchContextRn -> GRHSs GhcTc (LHsExpr GhcTc) -> Type -> NonEmpty Nablas -> DsM (MatchResult CoreExpr)
isTrueLHsExpr :: LHsExpr GhcTc -> Maybe (CoreExpr -> DsM CoreExpr)


-- | Desugaring step of the <a>Lower Your Guards paper</a>.
--   
--   Desugars Haskell source syntax into guard tree variants Pm*. In terms
--   of the paper, this module is concerned with Sections 3.1, Figure 4, in
--   particular.
module GHC.HsToCore.Pmc.Desugar
desugarPatBind :: SrcSpan -> Id -> Pat GhcTc -> DsM (PmPatBind Pre)
desugarGRHSs :: SrcSpan -> SDoc -> GRHSs GhcTc (LHsExpr GhcTc) -> DsM (PmGRHSs Pre)

-- | Desugar the non-empty <a>Match</a>es of a <a>MatchGroup</a>.
desugarMatches :: [Id] -> NonEmpty (LMatch GhcTc (LHsExpr GhcTc)) -> DsM (PmMatchGroup Pre)
desugarEmptyCase :: Id -> DsM PmEmptyCase


-- | This module coverage checks pattern matches. It finds
--   
--   <ul>
--   <li>Uncovered patterns, certifying non-exhaustivity</li>
--   <li>Redundant equations</li>
--   <li>Equations with an inaccessible right-hand-side</li>
--   </ul>
--   
--   The algorithm is based on the paper <a>Lower Your Guards: A
--   Compositional Pattern-Match Coverage Checker"</a>
--   
--   There is an overview Figure 2 in there that's probably helpful. Here
--   is an overview of how it's implemented, which follows the structure of
--   the entry points such as <a>pmcMatches</a>:
--   
--   <ol>
--   <li>Desugar source syntax (like <a>LMatch</a>) to guard tree variants
--   (like <tt>GrdMatch</tt>), with one of the desugaring functions (like
--   <tt>desugarMatch</tt>). See <a>GHC.HsToCore.Pmc.Desugar</a>. Follows
--   Section 3.1 in the paper.</li>
--   <li>Coverage check guard trees (with a function like
--   <tt>checkMatch</tt>) to get a <a>CheckResult</a>. See
--   <a>GHC.HsToCore.Pmc.Check</a>. The normalised refinement types
--   <a>Nabla</a> are tested for inhabitants by
--   <a>GHC.HsToCore.Pmc.Solver</a>.</li>
--   <li>Collect redundancy information into a <a>CIRB</a> with a function
--   such as <a>cirbsMatch</a>. Follows the R function from Figure 6 of the
--   paper.</li>
--   <li>Format and report uncovered patterns and redundant equations
--   (<a>CIRB</a>) with <a>formatReportWarnings</a>. Basically job of the G
--   function, plus proper pretty printing of the warnings (Section 5.4 of
--   the paper).</li>
--   <li>Return <a>Nablas</a> reaching syntactic sub-components for Note
--   [Long-distance information]. Collected by functions such as
--   <a>ldiMatch</a>. See Section 4.1 of the paper.</li>
--   </ol>
module GHC.HsToCore.Pmc

-- | Check a pattern binding (let, where) for exhaustiveness.
pmcPatBind :: DsMatchContext -> Id -> Pat GhcTc -> DsM Nablas

-- | Check a list of syntactic <a>Match</a>es (part of case, functions,
--   etc.), each with a <a>Pat</a> and one or more <a>GRHSs</a>:
--   
--   <pre>
--   f x y | x == y    = 1   -- match on x and y with two guarded RHSs
--         | otherwise = 2
--   f _ _             = 3   -- clause with a single, un-guarded RHS
--   </pre>
--   
--   Returns one non-empty <a>Nablas</a> for 1.) each pattern of a
--   <a>Match</a> and 2.) each of a <a>Match</a>es <a>GRHS</a> for Note
--   [Long-distance information].
--   
--   Special case: When there are <i>no matches</i>, then the function
--   assumes it checks an <tt>-XEmptyCase</tt> with only a single match
--   variable. See Note [Checking EmptyCase].
pmcMatches :: Origin -> DsMatchContext -> [Id] -> [LMatch GhcTc (LHsExpr GhcTc)] -> DsM [(Nablas, NonEmpty Nablas)]

-- | Exhaustive for guard matches, is used for guards in pattern bindings
--   and in <tt>MultiIf</tt> expressions. Returns the <a>Nablas</a> covered
--   by the RHSs.
pmcGRHSs :: HsMatchContextRn -> GRHSs GhcTc (LHsExpr GhcTc) -> DsM (NonEmpty Nablas)
pmcRecSel :: Id -> CoreExpr -> DsM ()

-- | Check whether any part of pattern match checking is enabled for this
--   <a>HsMatchContext</a> (does not matter whether it is the redundancy
--   check or the exhaustiveness check).
isMatchContextPmChecked :: DynFlags -> Origin -> HsMatchContext fn -> Bool

-- | Check whether exhaustivity checks are enabled for this
--   <a>HsMatchContext</a>, when dealing with a single pattern (using the
--   <tt>matchSinglePatVar</tt> function).
isMatchContextPmChecked_SinglePat :: DynFlags -> Origin -> HsMatchContext fn -> LPat GhcTc -> Bool

-- | Add in-scope type constraints if the coverage checker might run and
--   then run the given action.
addTyCs :: Origin -> Bag EvVar -> DsM a -> DsM a

-- | Add equalities for the <a>CoreExpr</a> scrutinees to the local
--   <a>DsM</a> environment, e.g. when checking a case expression: case e
--   of x { matches } When checking matches we record that (x ~ e) where x
--   is the initial uncovered. All matches will have to satisfy this
--   equality. This is also used for the Arrows cases command, where these
--   equalities have to be added for multiple scrutinees rather than just
--   one.
addCoreScrutTmCs :: [CoreExpr] -> [Id] -> DsM a -> DsM a

-- | <a>addCoreScrutTmCs</a>, but desugars the <a>LHsExpr</a>s first.
addHsScrutTmCs :: [LHsExpr GhcTc] -> [Id] -> DsM a -> DsM a

-- | A non-empty delta that is initialised from the ambient refinement type
--   capturing long-distance information, or the trivially habitable
--   <a>Nablas</a> if the former is uninhabited. See Note [Recovering from
--   unsatisfiable pattern-matching constraints].
getLdiNablas :: DsM Nablas
getNFirstUncovered :: GenerateInhabitingPatternsMode -> [Id] -> Int -> Nablas -> DsM [Nabla]
instance GHC.Classes.Eq (GHC.HsToCore.Pmc.FormatReportWarningsMode ann)
instance GHC.Internal.Base.Monoid GHC.HsToCore.Pmc.CIRB
instance GHC.Internal.Base.Semigroup GHC.HsToCore.Pmc.CIRB

module GHC.HsToCore.Binds

-- | Desugar top level binds, strict binds are treated like normal binds
--   since there is no good time to force before first usage.
dsTopLHsBinds :: LHsBinds GhcTc -> DsM (OrdList (Id, CoreExpr))

-- | Desugar all other kind of bindings, Ids of strict binds are returned
--   to later be forced in the binding group body, see Note [Desugar Strict
--   binds]
--   
--   Invariant: the desugared bindings are returned in dependency order,
--   see Note [Return non-recursive bindings in dependency order]
dsLHsBinds :: LHsBinds GhcTc -> DsM ([Id], [(Id, CoreExpr)])
decomposeRuleLhs :: DynFlags -> [Var] -> CoreExpr -> VarSet -> Either DsMessage ([Var], Id, [CoreExpr])
dsSpec :: Maybe CoreExpr -> Located TcSpecPrag -> DsM (Maybe (OrdList (Id, CoreExpr), CoreRule))
dsHsWrapper :: HsWrapper -> ((CoreExpr -> CoreExpr) -> DsM a) -> DsM a
dsHsWrappers :: [HsWrapper] -> ([CoreExpr -> CoreExpr] -> DsM a) -> DsM a
dsEvTerm :: EvTerm -> DsM CoreExpr
dsTcEvBinds :: TcEvBinds -> ([CoreBind] -> DsM a) -> DsM a
dsTcEvBinds_s :: [TcEvBinds] -> ([CoreBind] -> DsM a) -> DsM a
dsEvBinds :: Bag EvBind -> ([CoreBind] -> DsM a) -> DsM a
dsWarnOrphanRule :: CoreRule -> DsM ()

module GHC.HsToCore.Quote
dsBracket :: HsBracketTc -> DsM CoreExpr
instance GHC.HsToCore.Quote.RepTV (Language.Haskell.Syntax.Type.HsBndrVis GHC.Hs.Extension.GhcRn) GHC.Internal.TH.Syntax.BndrVis
instance GHC.HsToCore.Quote.RepTV Language.Haskell.Syntax.Specificity.Specificity GHC.Internal.TH.Syntax.Specificity
instance GHC.HsToCore.Quote.RepTV () ()

module GHC.HsToCore.Match.Constructor
matchConFamily :: NonEmpty Id -> Type -> NonEmpty (NonEmpty EquationInfoNE) -> DsM (MatchResult CoreExpr)
matchPatSyn :: NonEmpty Id -> Type -> NonEmpty EquationInfoNE -> DsM (MatchResult CoreExpr)

module GHC.HsToCore.Match
match :: [MatchId] -> Type -> [EquationInfo] -> DsM (MatchResult CoreExpr)
matchEquations :: HsMatchContextRn -> [MatchId] -> [EquationInfo] -> Type -> DsM CoreExpr
matchWrapper :: HsMatchContextRn -> Maybe [LHsExpr GhcTc] -> MatchGroup GhcTc (LHsExpr GhcTc) -> DsM ([Id], CoreExpr)

-- | <tt>matchSimply</tt> is a wrapper for <a>match</a> which deals with
--   the situation where we want to match a single expression against a
--   single pattern. It returns an expression.
matchSimply :: CoreExpr -> HsMatchContextRn -> Mult -> LPat GhcTc -> CoreExpr -> CoreExpr -> DsM CoreExpr
matchSinglePat :: CoreExpr -> HsMatchContextRn -> LPat GhcTc -> Mult -> Type -> MatchResult CoreExpr -> DsM (MatchResult CoreExpr)
matchSinglePatVar :: Id -> Maybe CoreExpr -> HsMatchContextRn -> LPat GhcTc -> Type -> MatchResult CoreExpr -> DsM (MatchResult CoreExpr)
instance GHC.Internal.Show.Show GHC.HsToCore.Match.PatGroup

module GHC.HsToCore.ListComp
dsListComp :: [ExprLStmt GhcTc] -> Type -> DsM CoreExpr
dsMonadComp :: [ExprLStmt GhcTc] -> DsM CoreExpr

module GHC.HsToCore.Arrows
dsProcExpr :: LPat GhcTc -> LHsCmdTop GhcTc -> DsM CoreExpr

module GHC.HsToCore.Expr

-- | Desugar a typechecked expression.
dsExpr :: HsExpr GhcTc -> DsM CoreExpr

-- | Desugar a located typechecked expression.
dsLExpr :: LHsExpr GhcTc -> DsM CoreExpr
dsLocalBinds :: HsLocalBinds GhcTc -> CoreExpr -> DsM CoreExpr
dsValBinds :: HsValBinds GhcTc -> CoreExpr -> DsM CoreExpr
dsLit :: HsLit GhcRn -> DsM CoreExpr
dsSyntaxExpr :: SyntaxExpr GhcTc -> [CoreExpr] -> DsM CoreExpr


-- | Module for detecting if recompilation is required
module GHC.Iface.Recomp

-- | Top level function to check if the version of an old interface file is
--   equivalent to the current source file the user asked us to compile. If
--   the same, we can avoid recompilation.
--   
--   We return on the outside whether the interface file is up to date,
--   providing evidence that is with a <a>ModIface</a>. In the case that it
--   isn't, we may also return a found or provided <a>ModIface</a>. Why we
--   don't always return the old one, if it exists, is unclear to me,
--   except that I tried it and some tests failed (see #18205).
checkOldIface :: HscEnv -> ModSummary -> Maybe ModIface -> IO (MaybeValidated ModIface)
data RecompileRequired

-- | everything is up to date, recompilation is not required
UpToDate :: RecompileRequired

-- | Need to compile the module
NeedsRecompile :: !CompileReason -> RecompileRequired
needsRecompileBecause :: RecompReason -> RecompileRequired
recompThen :: Monad m => m RecompileRequired -> m RecompileRequired -> m RecompileRequired
data MaybeValidated a

-- | The item contained is validated to be up to date
UpToDateItem :: a -> MaybeValidated a

-- | The item is are absent altogether or out of date, for the reason
--   given.
OutOfDateItem :: !CompileReason -> Maybe a -> MaybeValidated a
outOfDateItemBecause :: RecompReason -> Maybe a -> MaybeValidated a
data RecompReason
UnitDepRemoved :: UnitId -> RecompReason
ModulePackageChanged :: FastString -> RecompReason
SourceFileChanged :: RecompReason
ThisUnitIdChanged :: RecompReason
ImpurePlugin :: RecompReason
PluginsChanged :: RecompReason
PluginFingerprintChanged :: RecompReason
ModuleInstChanged :: RecompReason
HieMissing :: RecompReason
HieOutdated :: RecompReason
SigsMergeChanged :: RecompReason
ModuleChanged :: ModuleName -> RecompReason
ModuleRemoved :: (UnitId, ModuleName) -> RecompReason
ModuleAdded :: (UnitId, ModuleName) -> RecompReason
ModuleChangedRaw :: ModuleName -> RecompReason
ModuleChangedIface :: ModuleName -> RecompReason
FileChanged :: FilePath -> RecompReason
CustomReason :: String -> RecompReason
FlagsChanged :: RecompReason
OptimFlagsChanged :: RecompReason
HpcFlagsChanged :: RecompReason
MissingBytecode :: RecompReason
MissingObjectFile :: RecompReason
MissingDynObjectFile :: RecompReason
MissingDynHiFile :: RecompReason
MismatchedDynHiFile :: RecompReason
ObjectsChanged :: RecompReason
LibraryChanged :: RecompReason
THWithJS :: RecompReason
data CompileReason

-- | The .hs file has been touched, or the .o/.hi file does not exist
MustCompile :: CompileReason

-- | The .o/.hi files are up to date, but something else has changed to
--   force recompilation; the String says what (one-line summary)
RecompBecause :: !RecompReason -> CompileReason
recompileRequired :: RecompileRequired -> Bool

-- | Add fingerprints for top-level declarations to a <a>ModIface</a>.
--   
--   See Note [Fingerprinting IfaceDecls]
addFingerprints :: HscEnv -> PartialModIface -> IO ModIface
instance GHC.Utils.Binary.Binary GHC.Iface.Recomp.IfaceDeclExtras
instance GHC.Utils.Binary.Binary GHC.Iface.Recomp.IfaceIdExtras
instance GHC.Classes.Eq GHC.Iface.Recomp.CompileReason
instance GHC.Classes.Eq GHC.Iface.Recomp.RecompReason
instance GHC.Classes.Eq GHC.Iface.Recomp.RecompileRequired
instance GHC.Internal.Base.Functor GHC.Iface.Recomp.MaybeValidated
instance GHC.Internal.Base.Monoid GHC.Iface.Recomp.RecompileRequired
instance GHC.Utils.Outputable.Outputable GHC.Iface.Recomp.CompileReason
instance GHC.Utils.Outputable.Outputable GHC.Iface.Recomp.IfaceDeclExtras
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Iface.Recomp.MaybeValidated a)
instance GHC.Utils.Outputable.Outputable GHC.Iface.Recomp.RecompReason
instance GHC.Utils.Outputable.Outputable GHC.Iface.Recomp.RecompileRequired
instance GHC.Internal.Base.Semigroup GHC.Iface.Recomp.RecompileRequired

module GHC.HsToCore.Usage
mkUsageInfo :: UsageConfig -> Plugins -> FinderCache -> UnitEnv -> Module -> ImportedMods -> NameSet -> [FilePath] -> [(Module, Fingerprint)] -> [Linkable] -> PkgsLoaded -> IfG [Usage]
mkUsedNames :: TcGblEnv -> NameSet
data UsageConfig
UsageConfig :: !Bool -> UsageConfig

-- | Are all implicit imports required to be safe for this Safe Haskell
--   mode?
[uc_safe_implicit_imps_req] :: UsageConfig -> !Bool

module GHC.Driver.Config.HsToCore.Usage
initUsageConfig :: HscEnv -> UsageConfig


-- | Module for constructing <tt>ModIface</tt> values (interface files),
--   writing them to disk and comparing two versions to see if
--   recompilation is required.
module GHC.Iface.Make
mkPartialIface :: HscEnv -> CoreProgram -> ModDetails -> ModSummary -> [ImportUserSpec] -> ModGuts -> PartialModIface

-- | Fully instantiate an interface. Adds fingerprints and potentially code
--   generator produced information.
--   
--   CmmCgInfos is not available when not generating code (-fno-code), or
--   when not generating interface pragmas (-fomit-interface-pragmas). See
--   also Note [Conveying CAF-info and LFInfo between modules] in
--   GHC.StgToCmm.Types.
mkFullIface :: HscEnv -> PartialModIface -> Maybe StgCgInfos -> Maybe CmmCgInfos -> ForeignStubs -> [(ForeignSrcLang, FilePath)] -> IO ModIface

-- | Make an interface from the results of typechecking only. Useful for
--   non-optimising compilation, or where we aren't generating any object
--   code at all (<tt>NoBackend</tt>).
mkIfaceTc :: HscEnv -> SafeHaskellMode -> ModDetails -> ModSummary -> Maybe CoreProgram -> TcGblEnv -> IO ModIface
mkIfaceExports :: [AvailInfo] -> [IfaceExport]

module GHC.Iface.Ext.Ast

-- | Construct an <a>HieFile</a> from the outputs of the typechecker.
mkHieFile :: MonadIO m => ModSummary -> TcGblEnv -> RenamedSource -> m HieFile

-- | Construct an <a>HieFile</a> from the outputs of the typechecker but
--   don't read the source file again from disk.
mkHieFileWithSource :: FilePath -> ByteString -> ModSummary -> TcGblEnv -> RenamedSource -> HieFile
getCompressedAsts :: TypecheckedSource -> RenamedSource -> Bag EvBind -> [ClsInst] -> [TyCon] -> TypeEnv -> (HieASTs TypeIndex, Array TypeIndex HieTypeFlat, NameEntityInfo)
enrichHie :: TypecheckedSource -> RenamedSource -> Bag EvBind -> [ClsInst] -> [TyCon] -> TypeEnv -> (HieASTs Type, NameEntityInfo)
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Iface.Ext.Ast.PScoped a)
instance GHC.Parser.Annotation.HasLoc a => GHC.Parser.Annotation.HasLoc (Language.Haskell.Syntax.Decls.DataDefnCons a)
instance (GHC.Parser.Annotation.HasLoc a, GHC.Iface.Ext.Ast.HiePass p) => GHC.Parser.Annotation.HasLoc (Language.Haskell.Syntax.Decls.FamEqn (GHC.Hs.Extension.GhcPass p) a)
instance (GHC.Parser.Annotation.HasLoc tm, GHC.Parser.Annotation.HasLoc ty) => GHC.Parser.Annotation.HasLoc (Language.Haskell.Syntax.Type.HsArg (GHC.Hs.Extension.GhcPass p) tm ty)
instance GHC.Parser.Annotation.HasLoc (Language.Haskell.Syntax.Decls.HsDataDefn GHC.Hs.Extension.GhcRn)
instance GHC.Parser.Annotation.HasLoc thing => GHC.Parser.Annotation.HasLoc (GHC.Iface.Ext.Ast.PScoped thing)
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.HasType (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Binds.HsBind (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.HasType (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Pat.Pat (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.HasType (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass 'GHC.Hs.Extension.Renamed
instance GHC.Iface.Ext.Ast.HiePass 'GHC.Hs.Extension.Typechecked
instance GHC.Iface.Ext.Ast.ModifyState GHC.Types.Name.Name
instance GHC.Iface.Ext.Ast.ModifyState GHC.Types.Var.Id
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.AnnProvenance GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.LHsExpr a) => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.ArithSeqInfo a)
instance GHC.Iface.Ext.Ast.ToHie a => GHC.Iface.Ext.Ast.ToHie (GHC.Data.Bag.Bag a)
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.BindContext (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Binds.HsBind (GHC.Hs.Extension.GhcPass p))))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (Language.Haskell.Syntax.Type.FieldOcc (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (GHC.Types.SrcLoc.Located a)) => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (GHC.Parser.Annotation.LocatedN a))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (GHC.Types.SrcLoc.Located a)) => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (GHC.Parser.Annotation.LocatedA a))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (GHC.Types.SrcLoc.Located GHC.Types.Var.Var))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (GHC.Types.SrcLoc.Located GHC.Types.Name.Name))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (GHC.Types.SrcLoc.Located Language.Haskell.Syntax.Extension.NoExtField))
instance GHC.Iface.Ext.Ast.ToHie a => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.DataDefnCons a)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.EvBindContext (GHC.Parser.Annotation.LocatedA GHC.Tc.Types.Evidence.TcEvBinds))
instance (GHC.Iface.Ext.Ast.ToHie rhs, GHC.Parser.Annotation.HasLoc rhs) => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.FamEqn GHC.Hs.Extension.GhcRn rhs)
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.FamilyInfo GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.ForeignExport GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.ForeignImport GHC.Hs.Extension.GhcRn)
instance (GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p))), GHC.Iface.Ext.Ast.HiePass p, GHC.Iface.Ext.Ast.AnnoBody p body) => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.GRHSs (GHC.Hs.Extension.GhcPass p) (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p))))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Binds.FixitySig GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.DefaultDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.ForeignDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.WarnDecls GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.WarnDecl GHC.Hs.Extension.GhcRn))
instance (GHC.Iface.Ext.Ast.HiePass p, GHC.Internal.Data.Data.Data (body (GHC.Hs.Extension.GhcPass p)), GHC.Iface.Ext.Ast.AnnoBody p body, GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p)))) => GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.Match (GHC.Hs.Extension.GhcPass p) (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p)))))
instance (GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p))), GHC.Iface.Ext.Ast.HiePass p, GHC.Iface.Ext.Ast.AnnoBody p body) => GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Expr.GRHS (GHC.Hs.Extension.GhcPass p) (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p)))))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.Binds.PatSynBind (GHC.Hs.Extension.GhcPass p) (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Lit.HsOverLit (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.AnnDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Expr.HsCmdTop (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedC [GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr (GHC.Hs.Extension.GhcPass p))])
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsUntypedSplice (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA GHC.Tc.Types.Evidence.HsWrapper)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA GHC.Hs.Expr.SyntaxExprRn)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA GHC.Hs.Expr.SyntaxExprTc)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.TyClDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.FamilyDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.FunDep GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.RuleDecls GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Decls.InjectivityAnn GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Types.SrcLoc.Located [GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Decls.HsDerivingClause GHC.Hs.Extension.GhcRn)])
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Decls.HsDerivingClause GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedC (Language.Haskell.Syntax.Decls.DerivClauseTys GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedP GHC.Types.Basic.OverlapMode)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.ConDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedL [GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.ConDeclField GHC.Hs.Extension.GhcRn)])
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.StandaloneKindSig GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedC [GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcRn)])
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.RuleDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.ConDeclField GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.SpliceDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Data.BooleanFormula.LBooleanFormula (GHC.Parser.Annotation.LocatedN GHC.Types.Name.Name))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns Language.Haskell.Syntax.Type.HsIPName)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.RoleAnnotDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.InstDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.ClsInstDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.DataFamInstDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.TyFamInstDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.DerivDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.ImpExp.ImportDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.DocDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Hs.Doc.LHsDoc GHC.Hs.Extension.GhcRn)
instance (GHC.Iface.Ext.Ast.ToHie tm, GHC.Iface.Ext.Ast.ToHie ty) => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Type.HsArg (GHC.Hs.Extension.GhcPass p) tm ty)
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.HsConDeclGADTDetails GHC.Hs.Extension.GhcRn)
instance (GHC.Iface.Ext.Ast.ToHie tyarg, GHC.Iface.Ext.Ast.ToHie arg, GHC.Iface.Ext.Ast.ToHie rec) => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Type.HsConDetails tyarg arg rec)
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.HsDataDefn GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Binds.HsPatSynDir (GHC.Hs.Extension.GhcPass p))
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.HsQuote GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ToHie a => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Type.HsScaled GHC.Hs.Extension.GhcRn a)
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.HsTupArg (GHC.Hs.Extension.GhcPass p))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.IEContext (GHC.Parser.Annotation.LocatedA Language.Haskell.Syntax.Module.Name.ModuleName))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.IEContext (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.ImpExp.IE GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.IEContext (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.ImpExp.IEWrappedName GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.IEContext (GHC.Types.SrcLoc.Located GHC.Types.GREInfo.RecFieldInfo))
instance GHC.Iface.Ext.Ast.ToHie a => GHC.Iface.Ext.Ast.ToHie [a]
instance (GHC.Iface.Ext.Ast.HiePass p, GHC.Iface.Ext.Ast.AnnoBody p body, GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p)))) => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.MatchGroup (GHC.Hs.Extension.GhcPass p) (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p))))
instance GHC.Iface.Ext.Ast.ToHie a => GHC.Iface.Ext.Ast.ToHie (GHC.Internal.Maybe.Maybe a)
instance GHC.Iface.Ext.Ast.ToHie a => GHC.Iface.Ext.Ast.ToHie (GHC.Internal.Base.NonEmpty a)
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.PScoped (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Pat.Pat (GHC.Hs.Extension.GhcPass p))))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.PatSynFieldContext (Language.Haskell.Syntax.Binds.RecordPatSynField (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.ToHie GHC.Hs.Expr.PendingRnSplice
instance GHC.Iface.Ext.Ast.ToHie GHC.Hs.Expr.PendingTcSplice
instance (GHC.Iface.Ext.Ast.ToHie arg, GHC.Parser.Annotation.HasLoc arg, GHC.Internal.Data.Data.Data arg, GHC.Iface.Ext.Ast.HiePass p) => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RContext (Language.Haskell.Syntax.Pat.HsRecFields (GHC.Hs.Extension.GhcPass p) arg))
instance (GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RFContext label), GHC.Iface.Ext.Ast.ToHie arg, GHC.Parser.Annotation.HasLoc arg, GHC.Internal.Data.Data.Data arg, GHC.Internal.Data.Data.Data label) => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RContext (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Pat.HsFieldBind label arg)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RFContext (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.FieldOcc (GHC.Hs.Extension.GhcPass p))))
instance (GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p))), GHC.Iface.Ext.Ast.AnnoBody p body, GHC.Iface.Ext.Ast.HiePass p) => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.Stmt (GHC.Hs.Extension.GhcPass p) (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p))))))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (Language.Haskell.Syntax.Binds.HsLocalBinds (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Binds.IPBind (GHC.Hs.Extension.GhcPass p))))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (Language.Haskell.Syntax.Binds.HsValBindsLR (GHC.Hs.Extension.GhcPass p) (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (GHC.Hs.Binds.NHsValBindsLR (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (GHC.Hs.Expr.ApplicativeArg (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Decls.FamilyResultSig GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Decls.DerivStrategy GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Decls.RuleBndr GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.SigContext (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Binds.Sig (GHC.Hs.Extension.GhcPass p))))
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.StandaloneKindSig GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (Language.Haskell.Syntax.Type.HsPatSigType GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (Language.Haskell.Syntax.Type.HsTyPat GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (Language.Haskell.Syntax.Decls.FamEqn GHC.Hs.Extension.GhcRn (Language.Haskell.Syntax.Decls.HsDataDefn GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (Language.Haskell.Syntax.Decls.FamEqn GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcRn))))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (Language.Haskell.Syntax.Type.HsWildCardBndrs GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsSigType GHC.Hs.Extension.GhcRn))))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (Language.Haskell.Syntax.Type.HsWildCardBndrs GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcRn))))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsSigType GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (Language.Haskell.Syntax.Type.LHsQTyVars GHC.Hs.Extension.GhcRn))
instance GHC.Internal.Data.Data.Data flag => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TVScoped (Language.Haskell.Syntax.Type.HsOuterTyVarBndrs flag GHC.Hs.Extension.GhcRn))
instance GHC.Internal.Data.Data.Data flag => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TVScoped (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsTyVarBndr flag GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.TyClGroup GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ToHie GHC.Internal.Base.Void

module GHC.HsToCore

-- | Main entry point to the desugarer.
deSugar :: HscEnv -> ModLocation -> TcGblEnv -> IO (Messages DsMessage, Maybe ModGuts)
deSugarExpr :: HscEnv -> LHsExpr GhcTc -> IO (Messages DsMessage, Maybe CoreExpr)

module GHC.Iface.Ext.Binary

-- | Read a <a>HieFile</a> from a <a>FilePath</a>. Can use an existing
--   <a>NameCache</a>.
readHieFile :: NameCache -> FilePath -> IO HieFileResult

-- | Read a <a>HieFile</a> from a <a>FilePath</a>. Can use an existing
--   <a>NameCache</a>. Allows you to specify which versions of hieFile to
--   attempt to read. <a>Left</a> case returns the failing header versions.
readHieFileWithVersion :: (HieHeader -> Bool) -> NameCache -> FilePath -> IO (Either HieHeader HieFileResult)
type HieHeader = (Integer, ByteString)

-- | Write a <a>HieFile</a> to the given <a>FilePath</a>, with a proper
--   header and symbol tables for <a>Name</a>s and <a>FastString</a>s.
writeHieFile :: FilePath -> HieFile -> IO ()

-- | <a>Name</a>'s get converted into <a>HieName</a>'s before being written
--   into <tt>.hie</tt> files. See <a>toHieName</a> and
--   <tt>fromHieName</tt> for logic on how to convert between these two
--   types.
data HieName
ExternalName :: !Module -> !OccName -> !SrcSpan -> HieName
LocalName :: !OccName -> !SrcSpan -> HieName
KnownKeyName :: !Unique -> HieName
toHieName :: Name -> HieName
data HieFileResult
HieFileResult :: Integer -> ByteString -> HieFile -> HieFileResult
[hie_file_result_version] :: HieFileResult -> Integer
[hie_file_result_ghc_version] :: HieFileResult -> ByteString
[hie_file_result] :: HieFileResult -> HieFile

-- | The header for HIE files - Capital ASCII letters "HIE".
hieMagic :: [Word8]
hieNameOcc :: HieName -> OccName

module GHC.Builtin.PrimOps.Casts

-- | `getCasts from_rep to_rep` gives us a list of primops which when
--   applied in order convert from_rep to to_rep. See Note [PrimRep based
--   casting]
getCasts :: PrimRep -> PrimRep -> [(PrimOp, Type)]

module GHC.Stg.Unarise
unarise :: UniqSupply -> (DataCon -> [StgArg] -> Bool) -> [StgTopBinding] -> [StgTopBinding]
instance GHC.Utils.Outputable.Outputable GHC.Stg.Unarise.UnariseVal

module GHC.Stg.Pipeline
data StgPipelineOpts
StgPipelineOpts :: ![StgToDo] -> !Maybe DiagOpts -> !StgPprOpts -> !Platform -> !Bool -> (Module -> DataCon -> [StgArg] -> Bool) -> StgPipelineOpts

-- | Spec of what stg-to-stg passes to do
[stgPipeline_phases] :: StgPipelineOpts -> ![StgToDo]

-- | Should we lint the STG at various stages of the pipeline?
[stgPipeline_lint] :: StgPipelineOpts -> !Maybe DiagOpts
[stgPipeline_pprOpts] :: StgPipelineOpts -> !StgPprOpts
[stgPlatform] :: StgPipelineOpts -> !Platform
[stgPipeline_forBytecode] :: StgPipelineOpts -> !Bool

-- | Is a top-level (static) StgConApp allowed or not. If not, use dynamic
--   allocation.
--   
--   This is typically used to support dynamic linking on Windows and the
--   -fexternal-dynamic-refs flag. See GHC.Stg.Utils.allowTopLevelConApp.
[stgPipeline_allowTopLevelConApp] :: StgPipelineOpts -> Module -> DataCon -> [StgArg] -> Bool

-- | Optional Stg-to-Stg passes.
data StgToDo

-- | Common subexpression elimination
StgCSE :: StgToDo

-- | Lambda lifting closure variables, trading stack/register allocation
--   for heap allocation
StgLiftLams :: StgLiftConfig -> StgToDo
StgStats :: StgToDo

-- | Mandatory unarise pass, desugaring unboxed tuple and sum binders
StgUnarise :: StgToDo

-- | Mandatory when compiling to bytecode
StgBcPrep :: StgToDo

-- | Useful for building up <tt>getStgToDo</tt>
StgDoNothing :: StgToDo
stg2stg :: Logger -> [Var] -> StgPipelineOpts -> Module -> [StgTopBinding] -> IO ([(CgStgTopBinding, IdSet)], StgCgInfos)

-- | Information to be exposed in interface files which is produced by the
--   stg2stg passes.
type StgCgInfos = NameEnv TagSig
instance GHC.Internal.Base.Applicative GHC.Stg.Pipeline.StgM
instance GHC.Classes.Eq GHC.Stg.Pipeline.StgToDo
instance GHC.Internal.Base.Functor GHC.Stg.Pipeline.StgM
instance GHC.Internal.Control.Monad.IO.Class.MonadIO GHC.Stg.Pipeline.StgM
instance GHC.Internal.Base.Monad GHC.Stg.Pipeline.StgM
instance GHC.Types.Unique.Supply.MonadUnique GHC.Stg.Pipeline.StgM
instance GHC.Classes.Ord GHC.Stg.Pipeline.StgToDo
instance GHC.Internal.Read.Read GHC.Stg.Pipeline.StgToDo
instance GHC.Internal.Show.Show GHC.Stg.Pipeline.StgToDo

module GHC.Driver.Config.Stg.Pipeline

-- | Initialize STG pretty-printing options from DynFlags
initStgPipelineOpts :: DynFlags -> Bool -> StgPipelineOpts


-- | Main API for compiling plain Haskell source code.
--   
--   This module implements compilation of a Haskell source. It is
--   <i>not</i> concerned with preprocessing of source files; this is
--   handled in <a>GHC.Driver.Pipeline</a>
--   
--   There are various entry points depending on what mode we're in:
--   "batch" mode (<tt>--make</tt>), "one-shot" mode (<tt>-c</tt>,
--   <tt>-S</tt> etc.), and "interactive" mode (GHCi). There are also entry
--   points for individual passes: parsing, typechecking/renaming,
--   desugaring, and simplification.
--   
--   All the functions here take an <a>HscEnv</a> as a parameter, but none
--   of them return a new one: <a>HscEnv</a> is treated as an immutable
--   value from here on in (although it has mutable components, for the
--   caches).
--   
--   We use the Hsc monad to deal with warning messages consistently:
--   specifically, while executing within an Hsc monad, warnings are
--   collected. When a Hsc monad returns to an IO monad, the warnings are
--   printed, or compilation aborts if the <tt>-Werror</tt> flag is
--   enabled.
--   
--   (c) The GRASP/AQUA Project, Glasgow University, 1993-2000
module GHC.Driver.Main
newHscEnv :: FilePath -> DynFlags -> IO HscEnv
newHscEnvWithHUG :: FilePath -> DynFlags -> UnitId -> HomeUnitGraph -> IO HscEnv

-- | Initialize HscEnv from an optional top_dir path
initHscEnv :: Maybe FilePath -> IO HscEnv
type Messager = HscEnv -> (Int, Int) -> RecompileRequired -> ModuleGraphNode -> IO ()
batchMsg :: Messager
batchMultiMsg :: Messager

-- | Action to perform in backend compilation
data HscBackendAction

-- | Update the boot and signature file results.
HscUpdate :: ModIface -> HscBackendAction

-- | Recompile this module.
HscRecomp :: CgGuts -> !ModLocation -> !PartialModIface -> !Maybe Fingerprint -> HscBackendAction

-- | Information for the code generator.
[hscs_guts] :: HscBackendAction -> CgGuts

-- | Module info
[hscs_mod_location] :: HscBackendAction -> !ModLocation

-- | Partial interface
[hscs_partial_iface] :: HscBackendAction -> !PartialModIface

-- | Old interface hash for this compilation, if an old interface file
--   exists. Pass to <tt>hscMaybeWriteIface</tt> when writing the interface
--   to avoid updating the existing interface when the interface isn't
--   changed.
[hscs_old_iface_hash] :: HscBackendAction -> !Maybe Fingerprint

-- | Status of a module in incremental compilation
data HscRecompStatus

-- | Nothing to do because code already exists.
HscUpToDate :: ModIface -> HomeModLinkable -> HscRecompStatus

-- | Recompilation of module, or update of interface is required.
--   Optionally pass the old interface hash to avoid updating the existing
--   interface when it has not changed.
HscRecompNeeded :: Maybe Fingerprint -> HscRecompStatus
initModDetails :: HscEnv -> ModIface -> IO ModDetails

-- | If the <a>Linkable</a> contains Core bindings loaded from an
--   interface, replace them with a lazy IO thunk that compiles them to
--   bytecode and foreign objects, using the supplied environment for type
--   checking.
--   
--   The laziness is necessary because this value is stored purely in a
--   <a>HomeModLinkable</a> in the home package table, rather than some
--   dedicated mutable state that would generate bytecode on demand, so we
--   have to call this function even when we don't know that we'll need the
--   bytecode.
--   
--   In addition, the laziness has to be hidden inside <a>LazyBCOs</a>
--   because <a>Linkable</a> is used too generally, so that looking at the
--   constructor to decide whether to discard it when linking native code
--   would force the thunk otherwise, incurring a significant performance
--   penalty.
--   
--   This is sound because generateByteCode just depends on things already
--   loaded in the interface file.
initWholeCoreBindings :: HscEnv -> ModIface -> ModDetails -> Linkable -> IO Linkable

-- | Return an <a>IO</a> that hydrates Core bindings and compiles them to
--   bytecode if the interface contains any, using the supplied type env
--   for typechecking.
--   
--   Unlike <a>initWholeCoreBindings</a>, this does not use lazy IO.
--   Instead, the <a>IO</a> is only evaluated (in <tt>get_link_deps</tt>)
--   when it is clear that it will be used immediately (because we're
--   linking TH with <tt>-fprefer-byte-code</tt> in oneshot mode), and the
--   result is cached in <a>LoaderState</a>.
--   
--   <a>initWholeCoreBindings</a> needs the laziness because it is used to
--   populate <a>HomeModInfo</a>, which is done preemptively, in
--   anticipation of downstream modules using the bytecode for TH in make
--   mode, which might never happen.
loadIfaceByteCode :: HscEnv -> ModIface -> ModLocation -> TypeEnv -> Maybe (IO Linkable)

-- | Write interface files
hscMaybeWriteIface :: Logger -> DynFlags -> Bool -> ModIface -> Maybe Fingerprint -> ModLocation -> IO ()
hscCompileCmmFile :: HscEnv -> FilePath -> FilePath -> FilePath -> IO (Maybe FilePath)

-- | Compile to hard-code.
hscGenHardCode :: HscEnv -> CgGuts -> ModLocation -> FilePath -> IO (FilePath, Maybe FilePath, [(ForeignSrcLang, FilePath)], Maybe StgCgInfos, Maybe CmmCgInfos)
hscInteractive :: HscEnv -> CgInteractiveGuts -> ModLocation -> IO (Maybe FilePath, CompiledByteCode)
mkCgInteractiveGuts :: CgGuts -> CgInteractiveGuts
data CgInteractiveGuts

-- | Compile Core bindings and foreign inputs that were loaded from an
--   interface, to produce bytecode and potential foreign objects for the
--   purpose of linking splices.
generateByteCode :: HscEnv -> CgInteractiveGuts -> ModLocation -> IO (CompiledByteCode, [FilePath])
generateFreshByteCode :: HscEnv -> ModuleName -> CgInteractiveGuts -> ModLocation -> IO Linkable

-- | Do the recompilation avoidance checks for both one-shot and --make
--   modes This function is the *only* place in the compiler where we
--   decide whether to recompile a module or not!
hscRecompStatus :: Maybe Messager -> HscEnv -> ModSummary -> Maybe ModIface -> HomeModLinkable -> (Int, Int) -> IO HscRecompStatus

-- | parse a file, returning the abstract syntax
hscParse :: HscEnv -> ModSummary -> IO HsParsedModule

-- | Rename and typecheck a module, additionally returning the renamed
--   syntax
hscTypecheckRename :: HscEnv -> ModSummary -> HsParsedModule -> IO (TcGblEnv, RenamedStuff)

-- | Rename and typecheck a module, additionally returning the renamed
--   syntax and the diagnostics produced.
hscTypecheckRenameWithDiagnostics :: HscEnv -> ModSummary -> HsParsedModule -> IO ((TcGblEnv, RenamedStuff), Messages GhcMessage)

-- | Do Typechecking without throwing SourceError exception with -Werror
hscTypecheckAndGetWarnings :: HscEnv -> ModSummary -> IO (FrontendResult, WarningMessages)

-- | Convert a typechecked module to Core
hscDesugar :: HscEnv -> ModSummary -> TcGblEnv -> IO ModGuts

-- | Make a <a>ModDetails</a> from the results of typechecking. Used when
--   typechecking only, as opposed to full compilation.
makeSimpleDetails :: Logger -> TcGblEnv -> IO ModDetails

-- | Run Core2Core simplifier. The list of String is a list of (Core)
--   plugin module names added via TH (cf <tt>addCorePlugin</tt>).
hscSimplify :: HscEnv -> [String] -> ModGuts -> IO ModGuts
hscDesugarAndSimplify :: ModSummary -> FrontendResult -> Messages GhcMessage -> Maybe Fingerprint -> Hsc HscBackendAction

-- | Check that a module is safe to import.
--   
--   We return True to indicate the import is safe and False otherwise
--   although in the False case an exception may be thrown first.
hscCheckSafe :: HscEnv -> Module -> SrcSpan -> IO Bool

-- | Return if a module is trusted and the pkgs it depends on to be
--   trusted.
hscGetSafe :: HscEnv -> Module -> SrcSpan -> IO (Bool, Set UnitId)
hscParseIdentifier :: HscEnv -> String -> IO (LocatedN RdrName)
hscTcRcLookupName :: HscEnv -> Name -> IO (Maybe TyThing)
hscTcRnGetInfo :: HscEnv -> Name -> IO (Maybe (TyThing, Fixity, [ClsInst], [FamInst], SDoc))
hscIsGHCiMonad :: HscEnv -> String -> IO Name
hscGetModuleInterface :: HscEnv -> Module -> IO ModIface

-- | Rename some import declarations
hscRnImportDecls :: HscEnv -> [LImportDecl GhcPs] -> IO GlobalRdrEnv

-- | Lookup things in the compiler's environment
hscTcRnLookupRdrName :: HscEnv -> LocatedN RdrName -> IO (NonEmpty Name)

-- | Compile a stmt all the way to an HValue, but don't run it
--   
--   We return Nothing to indicate an empty statement (or comment only),
--   not a parse error.
hscStmt :: HscEnv -> String -> IO (Maybe ([Id], ForeignHValue, FixityEnv))
hscParseStmtWithLocation :: String -> Int -> String -> Hsc (Maybe (GhciLStmt GhcPs))

-- | Compile a stmt all the way to an HValue, but don't run it
--   
--   We return Nothing to indicate an empty statement (or comment only),
--   not a parse error.
hscStmtWithLocation :: HscEnv -> String -> String -> Int -> IO (Maybe ([Id], ForeignHValue, FixityEnv))
hscParsedStmt :: HscEnv -> GhciLStmt GhcPs -> IO (Maybe ([Id], ForeignHValue, FixityEnv))

-- | Compile a decls
hscDecls :: HscEnv -> String -> IO ([TyThing], InteractiveContext)
hscParseDeclsWithLocation :: HscEnv -> String -> Int -> String -> IO [LHsDecl GhcPs]

-- | Compile a decls
hscDeclsWithLocation :: HscEnv -> String -> String -> Int -> IO ([TyThing], InteractiveContext)
hscParsedDecls :: HscEnv -> [LHsDecl GhcPs] -> IO ([TyThing], InteractiveContext)
hscParseModuleWithLocation :: HscEnv -> String -> Int -> String -> IO (HsModule GhcPs)

-- | Typecheck an expression (but don't run it)
hscTcExpr :: HscEnv -> TcRnExprMode -> String -> IO Type

-- | How should we infer a type? See Note [TcRnExprMode]
data TcRnExprMode

-- | Instantiate inferred quantifiers only (:type)
TM_Inst :: TcRnExprMode

-- | Instantiate all quantifiers, and do eager defaulting (:type +d)
TM_Default :: TcRnExprMode
hscImport :: HscEnv -> String -> IO (ImportDecl GhcPs)

-- | Find the kind of a type, after generalisation
hscKcType :: HscEnv -> Bool -> String -> IO (Type, Kind)
hscParseExpr :: String -> Hsc (LHsExpr GhcPs)
hscParseType :: String -> Hsc (LHsType GhcPs)
hscCompileCoreExpr :: HscEnv -> SrcSpan -> CoreExpr -> IO (ForeignHValue, [Linkable], PkgsLoaded)
hscTidy :: HscEnv -> ModGuts -> IO (CgGuts, ModDetails)
hscCompileCoreExpr' :: HscEnv -> SrcSpan -> CoreExpr -> IO (ForeignHValue, [Linkable], PkgsLoaded)
hscParse' :: ModSummary -> Hsc HsParsedModule

-- | Run Core2Core simplifier. The list of String is a list of (Core)
--   plugin module names added via TH (cf <tt>addCorePlugin</tt>).
hscSimplify' :: [String] -> ModGuts -> Hsc ModGuts
hscDesugar' :: ModLocation -> TcGblEnv -> Hsc ModGuts
tcRnModule' :: ModSummary -> Bool -> HsParsedModule -> Hsc TcGblEnv
doCodeGen :: HscEnv -> Module -> InfoTableProvMap -> [TyCon] -> CollectedCCs -> [CgStgTopBinding] -> IO (CgStream CmmGroupSRTs CmmCgInfos)
getHscEnv :: Hsc HscEnv
hscSimpleIface' :: Maybe CoreProgram -> TcGblEnv -> ModSummary -> Hsc (ModIface, ModDetails)
oneShotMsg :: Logger -> RecompileRequired -> IO ()
dumpIfaceStats :: HscEnv -> IO ()

-- | Deal with errors and warnings returned by a compilation step
--   
--   In order to reduce dependencies to other parts of the compiler,
--   functions outside the "main" parts of GHC return warnings and errors
--   as a parameter and signal success via by wrapping the result in a
--   <a>Maybe</a> type. This function logs the returned warnings and
--   propagates errors as exceptions (of type <a>SourceError</a>).
--   
--   This function assumes the following invariants:
--   
--   <ol>
--   <li>If the second result indicates success (is of the form 'Just x'),
--   there must be no error messages in the first result.</li>
--   <li>If there are no error messages, but the second result indicates
--   failure there should be warnings in the first result. That is, if the
--   action failed, it must have been due to the warnings (i.e.,
--   <tt>-Werror</tt>).</li>
--   </ol>
ioMsgMaybe :: IO (Messages GhcMessage, Maybe a) -> Hsc a
showModuleIndex :: (Int, Int) -> SDoc

-- | Load the given static-pointer table entries into the interpreter. See
--   Note [Grand plan for static forms] in
--   <a>GHC.Iface.Tidy.StaticPtrTable</a>.
hscAddSptEntries :: HscEnv -> [SptEntry] -> IO ()
writeInterfaceOnlyMode :: DynFlags -> Bool
loadByteCode :: ModIface -> ModSummary -> IO (MaybeValidated Linkable)


-- | Template Haskell splices
module GHC.Tc.Gen.Splice
tcTypedSplice :: Name -> LHsExpr GhcRn -> ExpRhoType -> TcM (HsExpr GhcTc)
tcTypedBracket :: HsExpr GhcRn -> LHsExpr GhcRn -> ExpRhoType -> TcM (HsExpr GhcTc)
tcUntypedBracket :: HsExpr GhcRn -> HsQuote GhcRn -> [PendingRnSplice] -> ExpRhoType -> TcM (HsExpr GhcTc)
runAnnotation :: CoreAnnTarget -> LHsExpr GhcRn -> TcM Annotation
getUntypedSpliceBody :: HsUntypedSpliceResult (HsExpr GhcRn) -> TcM (HsExpr GhcRn)
runMetaE :: LHsExpr GhcTc -> TcM (LHsExpr GhcPs)
runMetaP :: LHsExpr GhcTc -> TcM (LPat GhcPs)
runMetaT :: LHsExpr GhcTc -> TcM (LHsType GhcPs)
runMetaD :: LHsExpr GhcTc -> TcM [LHsDecl GhcPs]
runQuasi :: Q a -> TcM a
tcTopSpliceExpr :: SpliceType -> TcM (LHsExpr GhcTc) -> TcM (LHsExpr GhcTc)
lookupThName_maybe :: Name -> TcM (Maybe Name)
defaultRunMeta :: MetaHook TcM
runMeta' :: Bool -> (hs_syn -> SDoc) -> (SrcSpan -> ForeignHValue -> TcM (Either RunSpliceFailReason hs_syn)) -> LHsExpr GhcTc -> TcM hs_syn
runRemoteModFinalizers :: ThModFinalizers -> TcM ()

-- | Releases the external interpreter state.
finishTH :: TcM ()
runTopSplice :: DelayedSplice -> TcM (HsExpr GhcTc)
instance GHC.Internal.TH.Syntax.Quasi GHC.Tc.Types.TcM
instance GHC.Tc.Gen.Splice.ReifyFlag Language.Haskell.Syntax.Specificity.Specificity GHC.Internal.TH.Syntax.Specificity
instance GHC.Tc.Gen.Splice.ReifyFlag GHC.Core.TyCon.TyConBndrVis (GHC.Internal.Maybe.Maybe GHC.Internal.TH.Syntax.BndrVis)
instance GHC.Tc.Gen.Splice.ReifyFlag () ()

module GHC.Runtime.Eval
data Resume
Resume :: String -> ForeignRef (ResumeContext [HValueRef]) -> ResumeBindings -> [Id] -> ForeignHValue -> Maybe InternalBreakpointId -> SrcSpan -> String -> RemotePtr CostCentreStack -> [History] -> Int -> Resume
[resumeStmt] :: Resume -> String
[resumeContext] :: Resume -> ForeignRef (ResumeContext [HValueRef])
[resumeBindings] :: Resume -> ResumeBindings
[resumeFinalIds] :: Resume -> [Id]
[resumeApStack] :: Resume -> ForeignHValue

-- | the breakpoint we stopped at (Nothing <a>=</a> exception)
[resumeBreakpointId] :: Resume -> Maybe InternalBreakpointId
[resumeSpan] :: Resume -> SrcSpan
[resumeDecl] :: Resume -> String
[resumeCCS] :: Resume -> RemotePtr CostCentreStack
[resumeHistory] :: Resume -> [History]
[resumeHistoryIx] :: Resume -> Int
data History
History :: ForeignHValue -> InternalBreakpointId -> [String] -> History
[historyApStack] :: History -> ForeignHValue

-- | breakpoint identifier
[historyBreakpointId] :: History -> InternalBreakpointId

-- | declarations enclosing the breakpoint
[historyEnclosingDecls] :: History -> [String]

-- | Run a statement in the current interactive context.
execStmt :: GhcMonad m => String -> ExecOptions -> m ExecResult

-- | Like <a>execStmt</a>, but takes a parsed statement as argument. Useful
--   when doing preprocessing on the AST before execution, e.g. in GHCi
--   (see GHCi.UI.runStmt).
execStmt' :: GhcMonad m => GhciLStmt GhcPs -> String -> ExecOptions -> m ExecResult
data ExecOptions
ExecOptions :: SingleStep -> String -> Int -> (ForeignHValue -> EvalExpr ForeignHValue) -> ExecOptions

-- | stepping mode
[execSingleStep] :: ExecOptions -> SingleStep

-- | filename (for errors)
[execSourceFile] :: ExecOptions -> String

-- | line number (for errors)
[execLineNumber] :: ExecOptions -> Int
[execWrap] :: ExecOptions -> ForeignHValue -> EvalExpr ForeignHValue

-- | default ExecOptions
execOptions :: ExecOptions
data ExecResult
ExecComplete :: Either SomeException [Name] -> Word64 -> ExecResult
[execResult] :: ExecResult -> Either SomeException [Name]
[execAllocation] :: ExecResult -> Word64
ExecBreak :: [Name] -> Maybe InternalBreakpointId -> ExecResult
[breakNames] :: ExecResult -> [Name]
[breakPointId] :: ExecResult -> Maybe InternalBreakpointId
resumeExec :: GhcMonad m => (SrcSpan -> Bool) -> SingleStep -> Maybe Int -> m ExecResult
runDecls :: GhcMonad m => String -> m [Name]

-- | Run some declarations and return any user-visible names that were
--   brought into scope.
runDeclsWithLocation :: GhcMonad m => String -> Int -> String -> m [Name]

-- | Like <a>runDeclsWithLocation</a>, but takes parsed declarations as
--   argument. Useful when doing preprocessing on the AST before execution,
--   e.g. in GHCi (see GHCi.UI.runStmt).
runParsedDecls :: GhcMonad m => [LHsDecl GhcPs] -> m [Name]
parseImportDecl :: GhcMonad m => String -> m (ImportDecl GhcPs)
data SingleStep
RunToCompletion :: SingleStep
SingleStep :: SingleStep
RunAndLogSteps :: SingleStep
abandon :: GhcMonad m => m Bool
abandonAll :: GhcMonad m => m Bool
getResumeContext :: GhcMonad m => m [Resume]
getHistorySpan :: HscEnv -> History -> SrcSpan
getModBreaks :: HomeModInfo -> ModBreaks
getHistoryModule :: History -> Module
setupBreakpoint :: GhcMonad m => HscEnv -> BreakpointId -> Int -> m ()
back :: GhcMonad m => Int -> m ([Name], Int, SrcSpan, String)
forward :: GhcMonad m => Int -> m ([Name], Int, SrcSpan, String)

-- | Set the interactive evaluation context.
--   
--   (setContext imports) sets the ic_imports field (which in turn
--   determines what is in scope at the prompt) to <tt>imports</tt>, and
--   updates the icReaderEnv environment to reflect it.
--   
--   We retain in scope all the things defined at the prompt, and kept in
--   ic_tythings. (Indeed, they shadow stuff from ic_imports.)
setContext :: GhcMonad m => [InteractiveImport] -> m ()

-- | Get the interactive evaluation context, consisting of a pair of the
--   set of modules from which we take the full top-level scope, and the
--   set of modules from which we take just the exports respectively.
getContext :: GhcMonad m => m [InteractiveImport]
mkTopLevEnv :: HscEnv -> ModuleName -> IO (Either String GlobalRdrEnv)

-- | Returns all names in scope in the current interactive context
getNamesInScope :: GhcMonad m => m [Name]

-- | Returns all <a>RdrName</a>s in scope in the current interactive
--   context, excluding any that are internally-generated.
getRdrNamesInScope :: GhcMonad m => m [RdrName]

-- | Returns <tt>True</tt> if the specified module is interpreted, and
--   hence has its full top-level scope available.
moduleIsInterpreted :: GhcMonad m => Module -> m Bool

-- | Looks up an identifier in the current interactive context (for :info)
--   Filter the instances by the ones whose tycons (or classes resp) are in
--   scope (qualified or otherwise). Otherwise we list a whole lot too
--   many! The exact choice of which ones to show, and which to hide, is a
--   judgement call. (see #1581)
getInfo :: GhcMonad m => Bool -> Name -> m (Maybe (TyThing, Fixity, [ClsInst], [FamInst], SDoc))

-- | Get the type of an expression Returns the type as described by
--   <a>TcRnExprMode</a>
exprType :: GhcMonad m => TcRnExprMode -> String -> m Type

-- | Get the kind of a type
typeKind :: GhcMonad m => Bool -> String -> m (Type, Kind)

-- | Parses a string as an identifier, and returns the list of <a>Name</a>s
--   that the identifier can refer to in the current interactive context.
parseName :: GhcMonad m => String -> m (NonEmpty Name)
parseInstanceHead :: GhcMonad m => String -> m Type
getInstancesForType :: GhcMonad m => Type -> m [ClsInst]
getDocs :: GhcMonad m => Name -> m (Either GetDocsFailure (Maybe [HsDoc GhcRn], IntMap (HsDoc GhcRn)))

-- | Failure modes for <a>getDocs</a>.
data GetDocsFailure

-- | <a>nameModule_maybe</a> returned <a>Nothing</a>.
NameHasNoModule :: Name -> GetDocsFailure

-- | The module was loaded without <tt>-haddock</tt>,
NoDocsInIface :: Module -> Bool -> GetDocsFailure

-- | The <a>Name</a> was defined interactively.
InteractiveName :: GetDocsFailure
showModule :: GhcMonad m => ModSummary -> m String
moduleIsBootOrNotObjectLinkable :: GhcMonad m => ModSummary -> m Bool

-- | Parse an expression, the parsed expression can be further processed
--   and passed to compileParsedExpr.
parseExpr :: GhcMonad m => String -> m (LHsExpr GhcPs)
compileParsedExpr :: GhcMonad m => LHsExpr GhcPs -> m HValue

-- | Compile an expression, run it, and deliver the resulting HValue.
compileExpr :: GhcMonad m => String -> m HValue

-- | Compile an expression, run it and return the result as a Dynamic.
dynCompileExpr :: GhcMonad m => String -> m Dynamic

-- | Compile an expression, run it, and deliver the resulting HValue.
compileExprRemote :: GhcMonad m => String -> m ForeignHValue

-- | Compile a parsed expression (before renaming), run it, and deliver the
--   resulting HValue.
compileParsedExprRemote :: GhcMonad m => LHsExpr GhcPs -> m ForeignHValue
data Term
Term :: RttiType -> Either String DataCon -> ForeignHValue -> [Term] -> Term
[ty] :: Term -> RttiType
[dc] :: Term -> Either String DataCon
[val] :: Term -> ForeignHValue
[subTerms] :: Term -> [Term]
Prim :: RttiType -> [Word] -> Term
[ty] :: Term -> RttiType
[valRaw] :: Term -> [Word]
Suspension :: ClosureType -> RttiType -> ForeignHValue -> Maybe Name -> Term
[ctype] :: Term -> ClosureType
[ty] :: Term -> RttiType
[val] :: Term -> ForeignHValue
[bound_to] :: Term -> Maybe Name
NewtypeWrap :: RttiType -> Either String DataCon -> Term -> Term
[ty] :: Term -> RttiType
[dc] :: Term -> Either String DataCon
[wrapped_term] :: Term -> Term
RefWrap :: RttiType -> Term -> Term
[ty] :: Term -> RttiType
[wrapped_term] :: Term -> Term
obtainTermFromId :: HscEnv -> Int -> Bool -> Id -> IO Term
obtainTermFromVal :: HscEnv -> Int -> Bool -> Type -> a -> IO Term
reconstructType :: HscEnv -> Int -> Id -> IO (Maybe Type)
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Eval.GetDocsFailure

module GHC.Driver.Pipeline.Execute
newtype HookedUse a
HookedUse :: ((Hooks, PhaseHook) -> IO a) -> HookedUse a
[runHookedUse] :: HookedUse a -> (Hooks, PhaseHook) -> IO a

-- | The default mechanism to run a pipeline, see Note [The Pipeline Monad]
runPipeline :: Hooks -> HookedUse a -> IO a

-- | Default interpretation of each phase, in terms of IO.
runPhase :: TPhase out -> IO out
runLlvmManglePhase :: PipeEnv -> HscEnv -> FilePath -> IO [Char]
runMergeForeign :: PipeEnv -> HscEnv -> FilePath -> [FilePath] -> IO FilePath
runLlvmLlcPhase :: PipeEnv -> HscEnv -> FilePath -> IO FilePath
runLlvmOptPhase :: PipeEnv -> HscEnv -> FilePath -> IO FilePath
runGenericAsPhase :: (Logger -> DynFlags -> [Option] -> IO ()) -> [Option] -> Bool -> PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> IO FilePath
runLlvmAsPhase :: Bool -> PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> IO FilePath
runAsPhase :: Bool -> PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> IO FilePath

-- | Run the JS Backend postHsc phase.
runJsPhase :: PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> IO FilePath

-- | Deal with foreign JS files (embed them into .o files)
runForeignJsPhase :: PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> IO FilePath
runCcPhase :: Phase -> PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> IO FilePath
runHscBackendPhase :: PipeEnv -> HscEnv -> ModuleName -> HscSource -> ModLocation -> HscBackendAction -> IO ([FilePath], ModIface, HomeModLinkable, FilePath)
runUnlitPhase :: HscEnv -> FilePath -> FilePath -> IO FilePath
getFileArgs :: HscEnv -> FilePath -> IO (DynFlags, Messages PsMessage, Messages DriverMessage)
runCppPhase :: HscEnv -> FilePath -> FilePath -> IO FilePath
runHscPhase :: PipeEnv -> HscEnv -> FilePath -> HscSource -> IO (HscEnv, ModSummary, HscRecompStatus)

-- | Calculate the ModLocation from the provided DynFlags. This function is
--   only used in one-shot mode and therefore takes into account the effect
--   of -o/-ohi flags (which do nothing in --make mode)
mkOneShotModLocation :: PipeEnv -> DynFlags -> HscSource -> ModuleName -> IO ModLocation
runHscTcPhase :: HscEnv -> ModSummary -> IO (FrontendResult, Messages GhcMessage)
runHscPostTcPhase :: HscEnv -> ModSummary -> FrontendResult -> Messages GhcMessage -> Maybe Fingerprint -> IO HscBackendAction
runHsPpPhase :: HscEnv -> FilePath -> FilePath -> FilePath -> IO FilePath
phaseOutputFilenameNew :: Phase -> PipeEnv -> HscEnv -> Maybe ModLocation -> IO FilePath

-- | Computes the next output filename for something in the compilation
--   pipeline. This is controlled by several variables:
--   
--   <ol>
--   <li><a>Phase</a>: the last phase to be run (e.g. <tt>stopPhase</tt>).
--   This is used to tell if we're in the last phase or not, because in
--   that case flags like <tt>-o</tt> may be important.</li>
--   <li><a>PipelineOutput</a>: is this intended to be a <a>Temporary</a>
--   or <a>Persistent</a> build output? Temporary files just go in a fresh
--   temporary name.</li>
--   <li><a>String</a>: what was the basename of the original input
--   file?</li>
--   <li><a>DynFlags</a>: the obvious thing</li>
--   <li><a>Phase</a>: the phase we want to determine the output filename
--   of.</li>
--   <li><tt>Maybe ModLocation</tt>: the <a>ModLocation</a> of the module
--   we're compiling; this can be used to override the default output of an
--   object file. (TODO: do we actually need this?)</li>
--   </ol>
getOutputFilename :: Logger -> TmpFs -> Phase -> PipelineOutput -> String -> DynFlags -> Phase -> Maybe ModLocation -> IO FilePath

-- | LLVM Options. These are flags to be passed to opt and llc, to ensure
--   consistency we list them in pairs, so that they form groups.
llvmOptions :: LlvmConfig -> DynFlags -> [(String, String)]

-- | What phase to run after one of the backend code generators has run
hscPostBackendPhase :: HscSource -> Backend -> Phase
compileStub :: HscEnv -> FilePath -> IO FilePath

-- | See Note [Object merging].
joinObjectFiles :: HscEnv -> [FilePath] -> FilePath -> IO ()
getHCFilePackages :: FilePath -> IO [UnitId]
linkDynLibCheck :: Logger -> TmpFs -> DynFlags -> UnitEnv -> [String] -> [UnitId] -> IO ()
touchObjectFile :: FilePath -> IO ()
instance GHC.Internal.Base.Applicative GHC.Driver.Pipeline.Execute.HookedUse
instance GHC.Internal.Base.Functor GHC.Driver.Pipeline.Execute.HookedUse
instance Control.Monad.Catch.MonadCatch GHC.Driver.Pipeline.Execute.HookedUse
instance GHC.Internal.Base.Monad GHC.Driver.Pipeline.Execute.HookedUse
instance GHC.Internal.Control.Monad.IO.Class.MonadIO GHC.Driver.Pipeline.Execute.HookedUse
instance Control.Monad.Catch.MonadThrow GHC.Driver.Pipeline.Execute.HookedUse
instance GHC.Driver.Pipeline.Monad.MonadUse GHC.Driver.Pipeline.Phases.TPhase GHC.Driver.Pipeline.Execute.HookedUse

module GHC.Driver.Pipeline
oneShot :: HscEnv -> StopPhase -> [(String, Maybe Phase)] -> IO ()
compileFile :: HscEnv -> StopPhase -> (FilePath, Maybe Phase) -> IO (Maybe FilePath)

-- | Just preprocess a file, put the result in a temp. file (used by the
--   compilation manager during the summary phase).
--   
--   We return the augmented DynFlags, because they contain the result of
--   slurping in the OPTIONS pragmas
preprocess :: HscEnv -> FilePath -> Maybe InputFileBuffer -> Maybe Phase -> IO (Either DriverMessages (DynFlags, FilePath))

-- | Compile
--   
--   Compile a single module, under the control of the compilation manager.
--   
--   This is the interface between the compilation manager and the compiler
--   proper (hsc), where we deal with tedious details like reading the
--   OPTIONS pragma from the source file, converting the C or assembly that
--   GHC produces into an object file, and compiling FFI stub files.
--   
--   NB. No old interface can also mean that the source has changed.
compileOne :: HscEnv -> ModSummary -> Int -> Int -> Maybe ModIface -> HomeModLinkable -> IO HomeModInfo
compileOne' :: Maybe Messager -> HscEnv -> ModSummary -> Int -> Int -> Maybe ModIface -> HomeModLinkable -> IO HomeModInfo
compileForeign :: HscEnv -> ForeignSrcLang -> FilePath -> IO FilePath
compileEmptyStub :: DynFlags -> HscEnv -> FilePath -> ModLocation -> ModuleName -> IO ()
link :: GhcLink -> Logger -> TmpFs -> FinderCache -> Hooks -> DynFlags -> UnitEnv -> Bool -> Maybe (RecompileRequired -> IO ()) -> HomePackageTable -> IO SuccessFlag
linkingNeeded :: Logger -> DynFlags -> UnitEnv -> Bool -> [Linkable] -> [UnitId] -> IO RecompileRequired
checkLinkInfo :: Logger -> DynFlags -> UnitEnv -> [UnitId] -> FilePath -> IO Bool
data PipeEnv
PipeEnv :: StopPhase -> String -> String -> String -> Phase -> PipelineOutput -> PipeEnv

-- | Stop just after this phase
[stop_phase] :: PipeEnv -> StopPhase

-- | basename of original input source
[src_filename] :: PipeEnv -> String

-- | basename of original input source
[src_basename] :: PipeEnv -> String

-- | its extension
[src_suffix] :: PipeEnv -> String
[start_phase] :: PipeEnv -> Phase

-- | says where to put the pipeline output
[output_spec] :: PipeEnv -> PipelineOutput
mkPipeEnv :: StopPhase -> FilePath -> Maybe Phase -> PipelineOutput -> PipeEnv
phaseOutputFilenameNew :: Phase -> PipeEnv -> HscEnv -> Maybe ModLocation -> IO FilePath
data TPhase res
[T_Unlit] :: PipeEnv -> HscEnv -> FilePath -> TPhase [Char]
[T_FileArgs] :: HscEnv -> FilePath -> TPhase (DynFlags, Messages PsMessage, Messages DriverMessage)
[T_Cpp] :: PipeEnv -> HscEnv -> FilePath -> TPhase [Char]
[T_HsPp] :: PipeEnv -> HscEnv -> FilePath -> FilePath -> TPhase [Char]
[T_HscRecomp] :: PipeEnv -> HscEnv -> FilePath -> HscSource -> TPhase (HscEnv, ModSummary, HscRecompStatus)
[T_Hsc] :: HscEnv -> ModSummary -> TPhase (FrontendResult, Messages GhcMessage)
[T_HscPostTc] :: HscEnv -> ModSummary -> FrontendResult -> Messages GhcMessage -> Maybe Fingerprint -> TPhase HscBackendAction
[T_HscBackend] :: PipeEnv -> HscEnv -> ModuleName -> HscSource -> ModLocation -> HscBackendAction -> TPhase ([FilePath], ModIface, HomeModLinkable, FilePath)
[T_CmmCpp] :: PipeEnv -> HscEnv -> FilePath -> TPhase [Char]
[T_Cmm] :: PipeEnv -> HscEnv -> FilePath -> TPhase ([FilePath], FilePath)
[T_Cc] :: Phase -> PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> TPhase [Char]
[T_As] :: Bool -> PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> TPhase [Char]
[T_Js] :: PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> TPhase [Char]
[T_ForeignJs] :: PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> TPhase [Char]
[T_LlvmOpt] :: PipeEnv -> HscEnv -> FilePath -> TPhase [Char]
[T_LlvmLlc] :: PipeEnv -> HscEnv -> FilePath -> TPhase [Char]
[T_LlvmAs] :: Bool -> PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> TPhase [Char]
[T_LlvmMangle] :: PipeEnv -> HscEnv -> FilePath -> TPhase [Char]
[T_MergeForeign] :: PipeEnv -> HscEnv -> FilePath -> [FilePath] -> TPhase [Char]

-- | Default interpretation of each phase, in terms of IO.
runPhase :: TPhase out -> IO out

-- | What phase to run after one of the backend code generators has run
hscPostBackendPhase :: HscSource -> Backend -> Phase
type TPipelineClass (f :: Type -> Type) (m :: Type -> Type) = (Functor m, MonadIO m, Applicative m, Monad m, MonadUse f m)

-- | Lift a <tt>f</tt> action into an <tt>m</tt> action.
class MonadUse (f :: k -> Type) (m :: k -> Type)
use :: forall (a :: k). MonadUse f m => f a -> m a

-- | The preprocessor pipeline
preprocessPipeline :: P m => PipeEnv -> HscEnv -> FilePath -> m (DynFlags, FilePath)

-- | The complete compilation pipeline, from start to finish
fullPipeline :: P m => PipeEnv -> HscEnv -> FilePath -> HscSource -> m (ModIface, HomeModLinkable)

-- | Everything after preprocess
hscPipeline :: P m => PipeEnv -> (HscEnv, ModSummary, HscRecompStatus) -> m (ModIface, HomeModLinkable)
hscBackendPipeline :: P m => PipeEnv -> HscEnv -> ModSummary -> HscBackendAction -> m (ModIface, HomeModLinkable)
hscPostBackendPipeline :: P m => PipeEnv -> HscEnv -> HscSource -> Backend -> Maybe ModLocation -> FilePath -> m (Maybe FilePath)
hscGenBackendPipeline :: P m => PipeEnv -> HscEnv -> ModSummary -> HscBackendAction -> m (ModIface, HomeModLinkable)
asPipeline :: P m => Bool -> PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> m (Maybe ObjFile)
viaCPipeline :: P m => Phase -> PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> m (Maybe FilePath)
cmmCppPipeline :: P m => PipeEnv -> HscEnv -> FilePath -> m (Maybe FilePath)
cmmPipeline :: P m => PipeEnv -> HscEnv -> FilePath -> m (Maybe FilePath)
jsPipeline :: P m => PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> m FilePath
llvmPipeline :: P m => PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> m (Maybe FilePath)
llvmLlcPipeline :: P m => PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> m (Maybe FilePath)
llvmManglePipeline :: P m => PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> m (Maybe FilePath)
pipelineStart :: P m => PipeEnv -> HscEnv -> FilePath -> Maybe Phase -> m (Maybe FilePath)

-- | The default mechanism to run a pipeline, see Note [The Pipeline Monad]
runPipeline :: Hooks -> HookedUse a -> IO a

module GHC.Driver.Make

-- | Perform a dependency analysis starting from the current targets and
--   update the session with the new module graph.
--   
--   Dependency analysis entails parsing the <tt>import</tt> directives and
--   may therefore require running certain preprocessors.
--   
--   Note that each <a>ModSummary</a> in the module graph caches its
--   <a>DynFlags</a>. These <a>DynFlags</a> are determined by the
--   <i>current</i> session <a>DynFlags</a> and the <tt>OPTIONS</tt> and
--   <tt>LANGUAGE</tt> pragmas of the parsed module. Thus if you want
--   changes to the <a>DynFlags</a> to take effect you need to call this
--   function again. In case of errors, just throw them.
depanal :: GhcMonad m => [ModuleName] -> Bool -> m ModuleGraph

-- | Perform dependency analysis like in <a>depanal</a>. In case of errors,
--   the errors and an empty module graph are returned.
depanalE :: GhcMonad m => [ModuleName] -> Bool -> m (DriverMessages, ModuleGraph)

-- | Perform dependency analysis like <a>depanal</a> but return a partial
--   module graph even in the face of problems with some modules.
--   
--   Modules which have parse errors in the module header, failing
--   preprocessors or other issues preventing them from being summarised
--   will simply be absent from the returned module graph.
--   
--   Unlike <a>depanal</a> this function will not update
--   <a>hsc_mod_graph</a> with the new module graph.
depanalPartial :: GhcMonad m => [ModuleName] -> Bool -> m (DriverMessages, ModuleGraph)

-- | This function checks then important property that if both p and q are
--   home units then any dependency of p, which transitively depends on q
--   is also a home unit.
--   
--   See Note [Multiple Home Units], section 'Closure Property'.
checkHomeUnitsClosed :: UnitEnv -> [DriverMessages]

-- | Try to load the program. See <a>LoadHowMuch</a> for the different
--   modes.
--   
--   This function implements the core of GHC's <tt>--make</tt> mode. It
--   preprocesses, compiles and loads the specified modules, avoiding
--   re-compilation wherever possible. Depending on the backend (see
--   <a>backend</a> field) compiling and loading may result in files being
--   created on disk.
--   
--   Calls the <a>defaultWarnErrLogger</a> after each compiling each
--   module, whether successful or not.
--   
--   If errors are encountered during dependency analysis, the module
--   <a>depanalE</a> returns together with the errors an empty ModuleGraph.
--   After processing this empty ModuleGraph, the errors of depanalE are
--   thrown. All other errors are reported using the
--   <a>defaultWarnErrLogger</a>.
load :: GhcMonad f => LoadHowMuch -> f SuccessFlag
loadWithCache :: GhcMonad m => Maybe ModIfaceCache -> (GhcMessage -> AnyGhcDiagnostic) -> LoadHowMuch -> m SuccessFlag

-- | Generalized version of <a>load</a> which also supports a custom
--   <a>Messager</a> (for reporting progress) and <a>ModuleGraph</a>
--   (generally produced by calling <a>depanal</a>.
load' :: GhcMonad m => Maybe ModIfaceCache -> LoadHowMuch -> (GhcMessage -> AnyGhcDiagnostic) -> Maybe Messager -> ModuleGraph -> m SuccessFlag
type AnyGhcDiagnostic = UnknownDiagnostic DiagnosticOpts GhcMessage

-- | Describes which modules of the module graph need to be loaded.
data LoadHowMuch

-- | Load all targets and its dependencies.
LoadAllTargets :: LoadHowMuch

-- | Load only the given module and its dependencies.
LoadUpTo :: HomeUnitModule -> LoadHowMuch

-- | Load only the dependencies of the given module, but not the module
--   itself.
LoadDependenciesOf :: HomeUnitModule -> LoadHowMuch
data ModIfaceCache
ModIfaceCache :: IO [CachedIface] -> (CachedIface -> IO ()) -> ModIfaceCache
[iface_clearCache] :: ModIfaceCache -> IO [CachedIface]
[iface_addToCache] :: ModIfaceCache -> CachedIface -> IO ()
noIfaceCache :: Maybe ModIfaceCache
newIfaceCache :: IO ModIfaceCache

-- | Collect the instantiations of dependencies to create
--   <a>InstantiationNode</a> work graph nodes. These are used to represent
--   the type checking that is done after all the free holes (sigs in
--   current package) relevant to that instantiation are compiled. This is
--   necessary to catch some instantiation errors.
--   
--   In the future, perhaps more of the work of instantiation could be
--   moved here, instead of shoved in with the module compilation nodes.
--   That could simplify backpack, and maybe hs-boot too.
instantiationNodes :: UnitId -> UnitState -> [ModuleGraphNode]

-- | Downsweep (dependency analysis)
--   
--   Chase downwards from the specified root set, returning summaries for
--   all home modules encountered. Only follow source-import links.
--   
--   We pass in the previous collection of summaries, which is used as a
--   cache to avoid recalculating a module summary if the source is
--   unchanged.
--   
--   The returned list of [ModSummary] nodes has one node for each
--   home-package module, plus one for any hs-boot files. The imports of
--   these nodes are all there, including the imports of non-home-package
--   modules.
downsweep :: HscEnv -> [ModSummary] -> [ModuleName] -> Bool -> IO ([DriverMessages], [ModuleGraphNode])

-- | Topological sort of the module graph
--   
--   Calculate SCCs of the module graph, possibly dropping the hi-boot
--   nodes The resulting list of strongly-connected-components is in
--   topologically sorted order, starting with the module(s) at the bottom
--   of the dependency graph (ie compile them first) and ending with the
--   ones at the top.
--   
--   Drop hi-boot nodes (first boolean arg)?
--   
--   <ul>
--   <li><tt>False</tt>: treat the hi-boot summaries as nodes of the graph,
--   so the graph must be acyclic</li>
--   <li><tt>True</tt>: eliminate the hi-boot nodes, and instead pretend
--   the a source-import of Foo is an import of Foo The resulting graph has
--   no hi-boot nodes, but can be cyclic</li>
--   </ul>
topSortModuleGraph :: Bool -> ModuleGraph -> Maybe HomeUnitModule -> [SCC ModuleGraphNode]

-- | Like <a>ms_home_imps</a>, but for SOURCE imports.
ms_home_srcimps :: ModSummary -> [Located ModuleName]

-- | All of the (possibly) home module imports from a <a>ModSummary</a>;
--   that is to say, each of these module names could be a home import if
--   an appropriately named file existed. (This is in contrast to package
--   qualified imports, which are guaranteed not to be home imports.)
ms_home_imps :: ModSummary -> [(PkgQual, Located ModuleName)]
summariseModule :: HscEnv -> HomeUnit -> Map (UnitId, FilePath) ModSummary -> IsBootInterface -> Located ModuleName -> PkgQual -> Maybe (StringBuffer, UTCTime) -> [ModuleName] -> IO SummariseResult
data SummariseResult
FoundInstantiation :: InstantiatedUnit -> SummariseResult
FoundHomeWithError :: (UnitId, DriverMessages) -> SummariseResult
FoundHome :: ModSummary -> SummariseResult
External :: UnitId -> SummariseResult
NotThere :: SummariseResult
summariseFile :: HscEnv -> HomeUnit -> Map (UnitId, FilePath) ModSummary -> FilePath -> Maybe Phase -> Maybe (StringBuffer, UTCTime) -> IO (Either DriverMessages ModSummary)

-- | Tests if an <a>HscSource</a> is a boot file, primarily for
--   constructing elements of <tt>BuildModule</tt>. We conflate signatures
--   and modules because they are bound in the same namespace; only boot
--   interfaces can be disambiguated with `import {-# SOURCE #-}`.
hscSourceToIsBoot :: HscSource -> IsBootInterface

-- | For a module <tt>modname</tt> of type <a>HscSource</a>, determine the
--   list of extra "imports" of other requirements which should be
--   considered part of the import of the requirement, because it
--   transitively depends on those requirements by imports of modules from
--   other packages. The situation is something like this:
--   
--   unit p where signature X signature Y import X
--   
--   unit q where dependency p[X=&lt;A&gt;,Y=&lt;B&gt;] signature A
--   signature B
--   
--   Although q's B does not directly import A, we still have to make sure
--   we process A first, because the merging process will cause B to
--   indirectly import A. This function finds the TRANSITIVE closure of all
--   such imports we need to make.
findExtraSigImports :: HscEnv -> HscSource -> ModuleName -> IO [ModuleName]

-- | Like <tt>implicitRequirements'</tt>, but returns either the module
--   name, if it is a free hole, or the instantiated unit the imported
--   module is from, so that that instantiated unit can be processed and
--   via the batch mod graph (rather than a transitive closure done here)
--   all the free holes are still reachable.
implicitRequirementsShallow :: HscEnv -> [(PkgQual, Located ModuleName)] -> IO ([ModuleName], [InstantiatedUnit])
noModError :: HscEnv -> SrcSpan -> ModuleName -> FindResult -> MsgEnvelope GhcMessage
cyclicModuleErr :: [ModuleGraphNode] -> MsgEnvelope GhcMessage
type SummaryNode = Node Int ModuleGraphNode

-- | Indicates whether a module name is referring to a boot interface
--   (hs-boot file) or regular module (hs file). We need to treat boot
--   modules specially when building compilation graphs, since they break
--   cycles. Regular source files and signature files are treated
--   equivalently.
data IsBootInterface
NotBoot :: IsBootInterface
IsBoot :: IsBootInterface
mkNodeKey :: ModuleGraphNode -> NodeKey
type ModNodeKey = ModuleNameWithIsBoot
data ModNodeKeyWithUid
ModNodeKeyWithUid :: !ModuleNameWithIsBoot -> !UnitId -> ModNodeKeyWithUid
[mnkModuleName] :: ModNodeKeyWithUid -> !ModuleNameWithIsBoot
[mnkUnitId] :: ModNodeKeyWithUid -> !UnitId
newtype ModNodeMap a
ModNodeMap :: Map ModNodeKey a -> ModNodeMap a
[unModNodeMap] :: ModNodeMap a -> Map ModNodeKey a
emptyModNodeMap :: ModNodeMap a
modNodeMapElems :: ModNodeMap a -> [a]
modNodeMapLookup :: ModNodeKey -> ModNodeMap a -> Maybe a
modNodeMapInsert :: ModNodeKey -> a -> ModNodeMap a -> ModNodeMap a
modNodeMapSingleton :: ModNodeKey -> a -> ModNodeMap a
modNodeMapUnionWith :: (a -> a -> a) -> ModNodeMap a -> ModNodeMap a -> ModNodeMap a
instance GHC.Classes.Eq GHC.Driver.Make.CodeGenEnable
instance GHC.Classes.Eq GHC.Driver.Make.WorkerLimit
instance GHC.Internal.Data.Foldable.Foldable GHC.Driver.Make.ModNodeMap
instance GHC.Internal.Base.Functor GHC.Driver.Make.ModNodeMap
instance GHC.Internal.Base.Functor GHC.Driver.Make.ResultVar
instance GHC.Classes.Ord GHC.Driver.Make.CodeGenEnable
instance GHC.Utils.Outputable.Outputable GHC.Driver.Make.BuildPlan
instance GHC.Utils.Outputable.Outputable GHC.Driver.Make.CachedIface
instance GHC.Utils.Outputable.Outputable GHC.Driver.Make.CodeGenEnable
instance GHC.Utils.Outputable.Outputable GHC.Driver.Make.ModuleGraphNodeWithBootFile
instance GHC.Internal.Show.Show GHC.Driver.Make.CodeGenEnable
instance GHC.Internal.Show.Show GHC.Driver.Make.ResultLoopOrigin
instance GHC.Internal.Show.Show GHC.Driver.Make.ResultOrigin
instance GHC.Internal.Data.Traversable.Traversable GHC.Driver.Make.ModNodeMap

module GHC

-- | Install some default exception handlers and run the inner computation.
--   Unless you want to handle exceptions yourself, you should wrap this
--   around the top level of your program. The default handlers output the
--   error message(s) to stderr and exit cleanly.
defaultErrorHandler :: ExceptionMonad m => FatalMessager -> FlushOut -> m a -> m a

-- | This function is no longer necessary, cleanup is now done by
--   runGhc/runGhcT.

-- | <i>Deprecated: Cleanup is now done by runGhc/runGhcT</i>
defaultCleanupHandler :: ExceptionMonad m => DynFlags -> m a -> m a
prettyPrintGhcErrors :: ExceptionMonad m => Logger -> m a -> m a

-- | Temporarily install standard signal handlers for catching ^C, which
--   just throw an exception in the current thread.
withSignalHandlers :: ExceptionMonad m => m a -> m a
withCleanupSession :: GhcMonad m => m a -> m a

-- | A minimal implementation of a <a>GhcMonad</a>. If you need a custom
--   monad, e.g., to maintain additional state consider wrapping this monad
--   or using <a>GhcT</a>.
data Ghc a

-- | A monad transformer to add GHC specific features to another monad.
--   
--   Note that the wrapped monad must support IO and handling of
--   exceptions.
data GhcT (m :: Type -> Type) a

-- | A monad that has all the features needed by GHC API calls.
--   
--   In short, a GHC monad
--   
--   <ul>
--   <li>allows embedding of IO actions,</li>
--   <li>can log warnings,</li>
--   <li>allows handling of (extensible) exceptions, and</li>
--   <li>maintains a current session.</li>
--   </ul>
--   
--   If you do not use <a>Ghc</a> or <a>GhcT</a>, make sure to call
--   <a>initGhcMonad</a> before any call to the GHC API functions can
--   occur.
class (Functor m, ExceptionMonad m, HasDynFlags m, HasLogger m) => GhcMonad (m :: Type -> Type)
getSession :: GhcMonad m => m HscEnv
setSession :: GhcMonad m => HscEnv -> m ()

-- | HscEnv is like <a>Session</a>, except that some of the fields are
--   immutable. An HscEnv is used to compile a single module from plain
--   Haskell source code (after preprocessing) to either C, assembly or
--   C--. It's also used to store the dynamic linker state to allow for
--   multiple linkers in the same address space. Things like the module
--   graph don't change during a single compilation.
--   
--   Historical note: "hsc" used to be the name of the compiler binary,
--   when there was a separate driver and compiler. To compile a single
--   module, the driver would invoke hsc on the source code... so nowadays
--   we think of hsc as the layer of the compiler that deals with compiling
--   a single module.
data HscEnv

-- | Run function for the <a>Ghc</a> monad.
--   
--   It initialises the GHC session and warnings via <a>initGhcMonad</a>.
--   Each call to this function will create a new session which should not
--   be shared among several threads.
--   
--   Any errors not handled inside the <a>Ghc</a> action are propagated as
--   IO exceptions.
runGhc :: Maybe FilePath -> Ghc a -> IO a

-- | Run function for <a>GhcT</a> monad transformer.
--   
--   It initialises the GHC session and warnings via <a>initGhcMonad</a>.
--   Each call to this function will create a new session which should not
--   be shared among several threads.
runGhcT :: ExceptionMonad m => Maybe FilePath -> GhcT m a -> m a

-- | Initialise a GHC session.
--   
--   If you implement a custom <a>GhcMonad</a> you must call this function
--   in the monad run function. It will initialise the session variable and
--   clear all warnings.
--   
--   The first argument should point to the directory where GHC's library
--   files reside. More precisely, this should be the output of <tt>ghc
--   --print-libdir</tt> of the version of GHC the module using this API is
--   compiled with. For portability, you should use the <tt>ghc-paths</tt>
--   package, available at
--   <a>http://hackage.haskell.org/package/ghc-paths</a>.
initGhcMonad :: GhcMonad m => Maybe FilePath -> m ()

-- | Print the all diagnostics in a <a>SourceError</a>. Useful inside
--   exception handlers.
printException :: (HasLogger m, MonadIO m, HasDynFlags m) => SourceError -> m ()

-- | Perform the given action and call the exception handler if the action
--   throws a <a>SourceError</a>. See <a>SourceError</a> for more
--   information.
handleSourceError :: MonadCatch m => (SourceError -> m a) -> m a -> m a

-- | Contains not only a collection of <a>GeneralFlag</a>s but also a
--   plethora of information relating to the compilation of a single file
--   or GHC session
data DynFlags
DynFlags :: GhcMode -> GhcLink -> !Backend -> {-# UNPACK #-} !GhcNameVersion -> {-# UNPACK #-} !FileSettings -> Platform -> {-# UNPACK #-} !ToolSettings -> {-# UNPACK #-} !PlatformMisc -> [(String, String)] -> TempDir -> Int -> Int -> Int -> Int -> Int -> Maybe String -> [Int] -> Maybe ParMakeCount -> Bool -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Int -> Int -> Int -> !Int -> Int -> Maybe Int -> Maybe Int -> Int -> Maybe Word -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Bool -> Maybe Int -> Int -> [FilePath] -> ModuleName -> Maybe String -> IntWithInf -> IntWithInf -> Int -> Int -> Int -> UnitId -> Maybe UnitId -> [(ModuleName, Module)] -> Maybe FilePath -> Maybe String -> Set ModuleName -> [ReexportedModule] -> Ways -> Maybe (String, Int) -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> String -> String -> String -> String -> String -> String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> DynLibLoader -> !Bool -> FilePath -> Maybe FilePath -> [Option] -> IncludeSpecs -> [String] -> [String] -> [String] -> Maybe String -> RtsOptsEnabled -> Bool -> String -> [ModuleName] -> [(ModuleName, String)] -> [String] -> [ExternalPluginSpec] -> FilePath -> Bool -> Bool -> [ModuleName] -> [String] -> [PackageDBFlag] -> [IgnorePackageFlag] -> [PackageFlag] -> [PackageFlag] -> [TrustFlag] -> Maybe FilePath -> EnumSet DumpFlag -> EnumSet GeneralFlag -> EnumSet WarningFlag -> EnumSet WarningFlag -> WarningCategorySet -> WarningCategorySet -> Maybe Language -> SafeHaskellMode -> Bool -> Bool -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> [OnOff Extension] -> EnumSet Extension -> !UnfoldingOpts -> Int -> Int -> Int -> FlushOut -> Maybe FilePath -> Maybe String -> [String] -> Int -> Int -> Bool -> OverridingBool -> Bool -> OverridingBool -> Bool -> Scheme -> ProfAuto -> [CallerCcFilter] -> Maybe String -> Maybe SseVersion -> Maybe BmiVersion -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Int -> Int -> Int -> Bool -> Maybe Int -> Word64 -> Int -> Weights -> DynFlags
[ghcMode] :: DynFlags -> GhcMode
[ghcLink] :: DynFlags -> GhcLink

-- | The backend to use (if any).
--   
--   Whenever you change the backend, also make sure to set <a>ghcLink</a>
--   to something sensible.
--   
--   <tt>NoBackend</tt> can be used to avoid generating any output,
--   however, note that:
--   
--   <ul>
--   <li>If a program uses Template Haskell the typechecker may need to run
--   code from an imported module. To facilitate this, code generation is
--   enabled for modules imported by modules that use template haskell,
--   using the default backend for the platform. See Note [-fno-code
--   mode].</li>
--   </ul>
[backend] :: DynFlags -> !Backend
[ghcNameVersion] :: DynFlags -> {-# UNPACK #-} !GhcNameVersion
[fileSettings] :: DynFlags -> {-# UNPACK #-} !FileSettings
[targetPlatform] :: DynFlags -> Platform
[toolSettings] :: DynFlags -> {-# UNPACK #-} !ToolSettings
[platformMisc] :: DynFlags -> {-# UNPACK #-} !PlatformMisc
[rawSettings] :: DynFlags -> [(String, String)]
[tmpDir] :: DynFlags -> TempDir

-- | LLVM optimisation level
[llvmOptLevel] :: DynFlags -> Int

-- | Verbosity level: see Note [Verbosity levels]
[verbosity] :: DynFlags -> Int

-- | How much debug information to produce
[debugLevel] :: DynFlags -> Int

-- | Number of simplifier phases
[simplPhases] :: DynFlags -> Int

-- | Max simplifier iterations
[maxSimplIterations] :: DynFlags -> Int
[ruleCheck] :: DynFlags -> Maybe String

-- | Additional demand analysis
[strictnessBefore] :: DynFlags -> [Int]

-- | The number of modules to compile in parallel If unspecified, compile
--   with a single job.
[parMakeCount] :: DynFlags -> Maybe ParMakeCount

-- | Enable RTS timing statistics?
[enableTimeStats] :: DynFlags -> Bool

-- | The heap size to set.
[ghcHeapSize] :: DynFlags -> Maybe Int

-- | Maximum number of bindings from the type envt to show in type error
--   messages
[maxRelevantBinds] :: DynFlags -> Maybe Int

-- | Maximum number of hole fits to show in typed hole error messages
[maxValidHoleFits] :: DynFlags -> Maybe Int

-- | Maximum number of refinement hole fits to show in typed hole error
--   messages
[maxRefHoleFits] :: DynFlags -> Maybe Int

-- | Maximum level of refinement for refinement hole fits in typed hole
--   error messages
[refLevelHoleFits] :: DynFlags -> Maybe Int

-- | Maximum number of unmatched patterns to show in non-exhaustiveness
--   warnings
[maxUncoveredPatterns] :: DynFlags -> Int

-- | Soft limit on the number of models the pattern match checker checks a
--   pattern against. A safe guard against exponential blow-up.
[maxPmCheckModels] :: DynFlags -> Int

-- | Multiplier for simplifier ticks
[simplTickFactor] :: DynFlags -> Int

-- | Whether DmdAnal should optimistically put an Unboxed demand on
--   returned products with at most this number of fields
[dmdUnboxWidth] :: DynFlags -> !Int
[ifCompression] :: DynFlags -> Int

-- | Threshold for SpecConstr
[specConstrThreshold] :: DynFlags -> Maybe Int

-- | Max number of specialisations for any one function
[specConstrCount] :: DynFlags -> Maybe Int

-- | Max number of specialisations for recursive types Not optional;
--   otherwise ForceSpecConstr can diverge.
[specConstrRecursive] :: DynFlags -> Int

-- | Binary literals (e.g. strings) whose size is above this threshold will
--   be dumped in a binary file by the assembler code generator. 0 and
--   Nothing disables this feature. See <a>Config</a>.
[binBlobThreshold] :: DynFlags -> Maybe Word

-- | Threshold for LiberateCase
[liberateCaseThreshold] :: DynFlags -> Maybe Int

-- | Arg count for lambda floating See <a>FloatOutSwitches</a>
[floatLamArgs] :: DynFlags -> Maybe Int

-- | Maximum number of arguments after lambda lifting a recursive function.
[liftLamsRecArgs] :: DynFlags -> Maybe Int

-- | Maximum number of arguments after lambda lifting a non-recursive
--   function.
[liftLamsNonRecArgs] :: DynFlags -> Maybe Int

-- | Lambda lift even when this turns a known call into an unknown call.
[liftLamsKnown] :: DynFlags -> Bool

-- | Align Cmm functions at this boundary or use default.
[cmmProcAlignment] :: DynFlags -> Maybe Int

-- | Simplification history size
[historySize] :: DynFlags -> Int
[importPaths] :: DynFlags -> [FilePath]
[mainModuleNameIs] :: DynFlags -> ModuleName
[mainFunIs] :: DynFlags -> Maybe String

-- | Typechecker maximum stack depth
[reductionDepth] :: DynFlags -> IntWithInf

-- | Number of iterations in the constraints solver Typically only 1 is
--   needed
[solverIterations] :: DynFlags -> IntWithInf

-- | Number of layers of superclass expansion for givens Should be &lt;
--   solverIterations See Note [Expanding Recursive Superclasses and
--   ExpansionFuel]
[givensFuel] :: DynFlags -> Int

-- | Number of layers of superclass expansion for wanteds Should be &lt;
--   givensFuel See Note [Expanding Recursive Superclasses and
--   ExpansionFuel]
[wantedsFuel] :: DynFlags -> Int

-- | Number of layers of superclass expansion for quantified constraints
--   Should be &lt; givensFuel See Note [Expanding Recursive Superclasses
--   and ExpansionFuel]
[qcsFuel] :: DynFlags -> Int

-- | Target home unit-id
[homeUnitId_] :: DynFlags -> UnitId

-- | Id of the unit to instantiate
[homeUnitInstanceOf_] :: DynFlags -> Maybe UnitId

-- | Module instantiations
[homeUnitInstantiations_] :: DynFlags -> [(ModuleName, Module)]
[workingDirectory] :: DynFlags -> Maybe FilePath

-- | What the package is called, use with multiple home units
[thisPackageName] :: DynFlags -> Maybe String
[hiddenModules] :: DynFlags -> Set ModuleName
[reexportedModules] :: DynFlags -> [ReexportedModule]

-- | Target way flags from the command line
[targetWays_] :: DynFlags -> Ways
[splitInfo] :: DynFlags -> Maybe (String, Int)
[objectDir] :: DynFlags -> Maybe String
[dylibInstallName] :: DynFlags -> Maybe String
[hiDir] :: DynFlags -> Maybe String
[hieDir] :: DynFlags -> Maybe String
[stubDir] :: DynFlags -> Maybe String
[dumpDir] :: DynFlags -> Maybe String
[objectSuf_] :: DynFlags -> String
[hcSuf] :: DynFlags -> String
[hiSuf_] :: DynFlags -> String
[hieSuf] :: DynFlags -> String
[dynObjectSuf_] :: DynFlags -> String
[dynHiSuf_] :: DynFlags -> String
[outputFile_] :: DynFlags -> Maybe String
[dynOutputFile_] :: DynFlags -> Maybe String
[outputHi] :: DynFlags -> Maybe String
[dynOutputHi] :: DynFlags -> Maybe String
[dynLibLoader] :: DynFlags -> DynLibLoader

-- | Indicate if we are now generating dynamic output because of
--   -dynamic-too. This predicate is used to query the appropriate fields
--   (outputFile/dynOutputFile, ways, etc.)
[dynamicNow] :: DynFlags -> !Bool

-- | This defaults to 'non-module'. It can be set by <a>setDumpPrefix</a>
--   or 'ghc.GHCi.UI.runStmt' based on where its output is going.
[dumpPrefix] :: DynFlags -> FilePath

-- | Override the <a>dumpPrefix</a> set by <a>setDumpPrefix</a> or
--   'ghc.GHCi.UI.runStmt'. Set by <tt>-ddump-file-prefix</tt>
[dumpPrefixForce] :: DynFlags -> Maybe FilePath
[ldInputs] :: DynFlags -> [Option]
[includePaths] :: DynFlags -> IncludeSpecs
[libraryPaths] :: DynFlags -> [String]
[frameworkPaths] :: DynFlags -> [String]
[cmdlineFrameworks] :: DynFlags -> [String]
[rtsOpts] :: DynFlags -> Maybe String
[rtsOptsEnabled] :: DynFlags -> RtsOptsEnabled
[rtsOptsSuggestions] :: DynFlags -> Bool

-- | Path to store the .mix files
[hpcDir] :: DynFlags -> String

-- | the <tt>-fplugin</tt> flags given on the command line, in *reverse*
--   order that they're specified on the command line.
[pluginModNames] :: DynFlags -> [ModuleName]
[pluginModNameOpts] :: DynFlags -> [(ModuleName, String)]

-- | the <tt>-ffrontend-opt</tt> flags given on the command line, in
--   *reverse* order that they're specified on the command line.
[frontendPluginOpts] :: DynFlags -> [String]

-- | External plugins loaded from shared libraries
[externalPluginSpecs] :: DynFlags -> [ExternalPluginSpec]
[depMakefile] :: DynFlags -> FilePath
[depIncludePkgDeps] :: DynFlags -> Bool
[depIncludeCppDeps] :: DynFlags -> Bool
[depExcludeMods] :: DynFlags -> [ModuleName]
[depSuffixes] :: DynFlags -> [String]

-- | The <tt>-package-db</tt> flags given on the command line, In *reverse*
--   order that they're specified on the command line. This is intended to
--   be applied with the list of "initial" package databases derived from
--   <tt>GHC_PACKAGE_PATH</tt>; see <tt>getUnitDbRefs</tt>.
[packageDBFlags] :: DynFlags -> [PackageDBFlag]

-- | The <tt>-ignore-package</tt> flags from the command line. In *reverse*
--   order that they're specified on the command line.
[ignorePackageFlags] :: DynFlags -> [IgnorePackageFlag]

-- | The <tt>-package</tt> and <tt>-hide-package</tt> flags from the
--   command-line. In *reverse* order that they're specified on the command
--   line.
[packageFlags] :: DynFlags -> [PackageFlag]

-- | The <tt>-plugin-package-id</tt> flags from command line. In *reverse*
--   order that they're specified on the command line.
[pluginPackageFlags] :: DynFlags -> [PackageFlag]

-- | The <tt>-trust</tt> and <tt>-distrust</tt> flags. In *reverse* order
--   that they're specified on the command line.
[trustFlags] :: DynFlags -> [TrustFlag]

-- | Filepath to the package environment file (if overriding default)
[packageEnv] :: DynFlags -> Maybe FilePath
[dumpFlags] :: DynFlags -> EnumSet DumpFlag
[generalFlags] :: DynFlags -> EnumSet GeneralFlag
[warningFlags] :: DynFlags -> EnumSet WarningFlag
[fatalWarningFlags] :: DynFlags -> EnumSet WarningFlag
[customWarningCategories] :: DynFlags -> WarningCategorySet
[fatalCustomWarningCategories] :: DynFlags -> WarningCategorySet
[language] :: DynFlags -> Maybe Language

-- | Safe Haskell mode
[safeHaskell] :: DynFlags -> SafeHaskellMode
[safeInfer] :: DynFlags -> Bool
[safeInferred] :: DynFlags -> Bool
[thOnLoc] :: DynFlags -> SrcSpan
[newDerivOnLoc] :: DynFlags -> SrcSpan
[deriveViaOnLoc] :: DynFlags -> SrcSpan
[overlapInstLoc] :: DynFlags -> SrcSpan
[incoherentOnLoc] :: DynFlags -> SrcSpan
[pkgTrustOnLoc] :: DynFlags -> SrcSpan
[warnSafeOnLoc] :: DynFlags -> SrcSpan
[warnUnsafeOnLoc] :: DynFlags -> SrcSpan
[trustworthyOnLoc] :: DynFlags -> SrcSpan
[extensions] :: DynFlags -> [OnOff Extension]
[extensionFlags] :: DynFlags -> EnumSet Extension

-- | Unfolding control See Note [Discounts and thresholds] in
--   GHC.Core.Unfold
[unfoldingOpts] :: DynFlags -> !UnfoldingOpts
[maxWorkerArgs] :: DynFlags -> Int
[maxForcedSpecArgs] :: DynFlags -> Int
[ghciHistSize] :: DynFlags -> Int
[flushOut] :: DynFlags -> FlushOut
[ghcVersionFile] :: DynFlags -> Maybe FilePath
[haddockOptions] :: DynFlags -> Maybe String

-- | GHCi scripts specified by -ghci-script, in reverse order
[ghciScripts] :: DynFlags -> [String]
[pprUserLength] :: DynFlags -> Int
[pprCols] :: DynFlags -> Int
[useUnicode] :: DynFlags -> Bool
[useColor] :: DynFlags -> OverridingBool
[canUseColor] :: DynFlags -> Bool
[useErrorLinks] :: DynFlags -> OverridingBool
[canUseErrorLinks] :: DynFlags -> Bool
[colScheme] :: DynFlags -> Scheme

-- | what kind of {-# SCC #-} to add automatically
[profAuto] :: DynFlags -> ProfAuto
[callerCcFilters] :: DynFlags -> [CallerCcFilter]
[interactivePrint] :: DynFlags -> Maybe String

-- | Machine dependent flags (-m&lt;blah&gt; stuff)
[sseVersion] :: DynFlags -> Maybe SseVersion
[bmiVersion] :: DynFlags -> Maybe BmiVersion
[avx] :: DynFlags -> Bool
[avx2] :: DynFlags -> Bool
[avx512cd] :: DynFlags -> Bool
[avx512er] :: DynFlags -> Bool
[avx512f] :: DynFlags -> Bool
[avx512pf] :: DynFlags -> Bool

-- | Enable FMA instructions.
[fma] :: DynFlags -> Bool

-- | Max size, in bytes, of inline array allocations.
[maxInlineAllocSize] :: DynFlags -> Int

-- | Only inline memcpy if it generates no more than this many pseudo
--   (roughly: Cmm) instructions.
[maxInlineMemcpyInsns] :: DynFlags -> Int

-- | Only inline memset if it generates no more than this many pseudo
--   (roughly: Cmm) instructions.
[maxInlineMemsetInsns] :: DynFlags -> Int

-- | Reverse the order of error messages in GHC/GHCi
[reverseErrors] :: DynFlags -> Bool

-- | Limit the maximum number of errors to show
[maxErrors] :: DynFlags -> Maybe Int

-- | Unique supply configuration for testing build determinism
[initialUnique] :: DynFlags -> Word64
[uniqueIncrement] :: DynFlags -> Int

-- | Temporary: CFG Edge weights for fast iterations
[cfgWeights] :: DynFlags -> Weights

-- | Enumerates the simple on-or-off dynamic flags
data GeneralFlag

-- | Append dump output to files instead of stdout.
Opt_DumpToFile :: GeneralFlag

-- | Use foo.ways.<a>dumpFlag</a> instead of foo.<a>dumpFlag</a>
Opt_DumpWithWays :: GeneralFlag
Opt_D_dump_minimal_imports :: GeneralFlag
Opt_DoCoreLinting :: GeneralFlag
Opt_DoLinearCoreLinting :: GeneralFlag
Opt_DoStgLinting :: GeneralFlag
Opt_DoCmmLinting :: GeneralFlag
Opt_DoAsmLinting :: GeneralFlag
Opt_DoAnnotationLinting :: GeneralFlag
Opt_DoBoundsChecking :: GeneralFlag
Opt_NoLlvmMangler :: GeneralFlag
Opt_FastLlvm :: GeneralFlag
Opt_NoTypeableBinds :: GeneralFlag
Opt_DistinctConstructorTables :: GeneralFlag
Opt_InfoTableMap :: GeneralFlag
Opt_InfoTableMapWithFallback :: GeneralFlag
Opt_InfoTableMapWithStack :: GeneralFlag
Opt_WarnIsError :: GeneralFlag
Opt_ShowWarnGroups :: GeneralFlag
Opt_HideSourcePaths :: GeneralFlag
Opt_PrintExplicitForalls :: GeneralFlag
Opt_PrintExplicitKinds :: GeneralFlag
Opt_PrintExplicitCoercions :: GeneralFlag
Opt_PrintExplicitRuntimeReps :: GeneralFlag
Opt_PrintEqualityRelations :: GeneralFlag
Opt_PrintAxiomIncomps :: GeneralFlag
Opt_PrintUnicodeSyntax :: GeneralFlag
Opt_PrintExpandedSynonyms :: GeneralFlag
Opt_PrintPotentialInstances :: GeneralFlag
Opt_PrintRedundantPromotionTicks :: GeneralFlag
Opt_PrintTypecheckerElaboration :: GeneralFlag
Opt_CallArity :: GeneralFlag
Opt_Exitification :: GeneralFlag
Opt_Strictness :: GeneralFlag
Opt_LateDmdAnal :: GeneralFlag
Opt_KillAbsence :: GeneralFlag
Opt_KillOneShot :: GeneralFlag
Opt_FullLaziness :: GeneralFlag
Opt_FloatIn :: GeneralFlag

-- | Enable floating out of let-bindings in the simplifier
Opt_LocalFloatOut :: GeneralFlag

-- | Enable floating out of let-bindings at the top level in the simplifier
--   N.B. See Note [RHS Floating]
Opt_LocalFloatOutTopLevel :: GeneralFlag
Opt_LateSpecialise :: GeneralFlag
Opt_Specialise :: GeneralFlag
Opt_SpecialiseAggressively :: GeneralFlag
Opt_CrossModuleSpecialise :: GeneralFlag
Opt_PolymorphicSpecialisation :: GeneralFlag
Opt_InlineGenerics :: GeneralFlag
Opt_InlineGenericsAggressively :: GeneralFlag
Opt_StaticArgumentTransformation :: GeneralFlag
Opt_CSE :: GeneralFlag
Opt_StgCSE :: GeneralFlag
Opt_StgLiftLams :: GeneralFlag
Opt_LiberateCase :: GeneralFlag
Opt_SpecConstr :: GeneralFlag
Opt_SpecConstrKeen :: GeneralFlag
Opt_SpecialiseIncoherents :: GeneralFlag
Opt_DoLambdaEtaExpansion :: GeneralFlag
Opt_DoCleverArgEtaExpansion :: GeneralFlag
Opt_IgnoreAsserts :: GeneralFlag
Opt_DoEtaReduction :: GeneralFlag
Opt_CaseMerge :: GeneralFlag
Opt_CaseFolding :: GeneralFlag
Opt_UnboxStrictFields :: GeneralFlag
Opt_UnboxSmallStrictFields :: GeneralFlag
Opt_DictsCheap :: GeneralFlag
Opt_EnableRewriteRules :: GeneralFlag
Opt_EnableThSpliceWarnings :: GeneralFlag
Opt_RegsGraph :: GeneralFlag
Opt_RegsIterative :: GeneralFlag
Opt_PedanticBottoms :: GeneralFlag
Opt_LlvmFillUndefWithGarbage :: GeneralFlag
Opt_IrrefutableTuples :: GeneralFlag
Opt_CmmSink :: GeneralFlag
Opt_CmmStaticPred :: GeneralFlag
Opt_CmmElimCommonBlocks :: GeneralFlag
Opt_CmmControlFlow :: GeneralFlag
Opt_AsmShortcutting :: GeneralFlag
Opt_OmitYields :: GeneralFlag
Opt_FunToThunk :: GeneralFlag
Opt_DictsStrict :: GeneralFlag

-- | deprecated, no effect and behaviour is now default. Allowed switching
--   of a special demand transformer for dictionary selectors
Opt_DmdTxDictSel :: GeneralFlag
Opt_Loopification :: GeneralFlag

-- | Use the cfg based block layout algorithm.
Opt_CfgBlocklayout :: GeneralFlag

-- | Layout based on last instruction per block.
Opt_WeightlessBlocklayout :: GeneralFlag
Opt_CprAnal :: GeneralFlag
Opt_WorkerWrapper :: GeneralFlag

-- | Do W/W split for unlifting even if we won't unbox anything.
Opt_WorkerWrapperUnlift :: GeneralFlag
Opt_SolveConstantDicts :: GeneralFlag
Opt_AlignmentSanitisation :: GeneralFlag
Opt_CatchNonexhaustiveCases :: GeneralFlag
Opt_NumConstantFolding :: GeneralFlag
Opt_CoreConstantFolding :: GeneralFlag
Opt_FastPAPCalls :: GeneralFlag
Opt_SpecEval :: GeneralFlag
Opt_SpecEvalDictFun :: GeneralFlag
Opt_DoTagInferenceChecks :: GeneralFlag
Opt_SimplPreInlining :: GeneralFlag
Opt_IgnoreInterfacePragmas :: GeneralFlag
Opt_OmitInterfacePragmas :: GeneralFlag
Opt_ExposeAllUnfoldings :: GeneralFlag
Opt_ExposeOverloadedUnfoldings :: GeneralFlag

-- | Keep auto-generated rules even if they seem to have become useless
Opt_KeepAutoRules :: GeneralFlag
Opt_WriteInterface :: GeneralFlag
Opt_WriteHie :: GeneralFlag

-- | render JavaScript pretty-printed instead of minified (compacted)
Opt_DisableJsMinifier :: GeneralFlag

-- | don't link C sources (compiled to JS) with Haskell code (compiled to
--   JS)
Opt_DisableJsCsources :: GeneralFlag
Opt_AutoSccsOnIndividualCafs :: GeneralFlag
Opt_ProfCountEntries :: GeneralFlag
Opt_ProfLateInlineCcs :: GeneralFlag
Opt_ProfLateCcs :: GeneralFlag
Opt_ProfLateOverloadedCcs :: GeneralFlag
Opt_ProfLateoverloadedCallsCCs :: GeneralFlag

-- | Ignore manual SCC annotations
Opt_ProfManualCcs :: GeneralFlag
Opt_Pp :: GeneralFlag
Opt_ForceRecomp :: GeneralFlag
Opt_IgnoreOptimChanges :: GeneralFlag
Opt_IgnoreHpcChanges :: GeneralFlag
Opt_ExcessPrecision :: GeneralFlag
Opt_EagerBlackHoling :: GeneralFlag
Opt_OrigThunkInfo :: GeneralFlag
Opt_NoHsMain :: GeneralFlag
Opt_SplitSections :: GeneralFlag
Opt_StgStats :: GeneralFlag
Opt_HideAllPackages :: GeneralFlag
Opt_HideAllPluginPackages :: GeneralFlag
Opt_PrintBindResult :: GeneralFlag
Opt_Haddock :: GeneralFlag
Opt_HaddockOptions :: GeneralFlag
Opt_BreakOnException :: GeneralFlag
Opt_BreakOnError :: GeneralFlag
Opt_PrintEvldWithShow :: GeneralFlag
Opt_PrintBindContents :: GeneralFlag
Opt_GenManifest :: GeneralFlag
Opt_EmbedManifest :: GeneralFlag
Opt_SharedImplib :: GeneralFlag
Opt_BuildingCabalPackage :: GeneralFlag
Opt_IgnoreDotGhci :: GeneralFlag
Opt_GhciSandbox :: GeneralFlag
Opt_InsertBreakpoints :: GeneralFlag
Opt_GhciHistory :: GeneralFlag
Opt_GhciLeakCheck :: GeneralFlag
Opt_ValidateHie :: GeneralFlag
Opt_LocalGhciHistory :: GeneralFlag
Opt_NoIt :: GeneralFlag
Opt_HelpfulErrors :: GeneralFlag
Opt_DeferTypeErrors :: GeneralFlag
Opt_DeferTypedHoles :: GeneralFlag
Opt_DeferOutOfScopeVariables :: GeneralFlag

-- | <pre>
--   -fPIC
--   </pre>
Opt_PIC :: GeneralFlag

-- | <pre>
--   -fPIE
--   </pre>
Opt_PIE :: GeneralFlag

-- | <pre>
--   -pie
--   </pre>
Opt_PICExecutable :: GeneralFlag
Opt_ExternalDynamicRefs :: GeneralFlag
Opt_Ticky :: GeneralFlag
Opt_Ticky_Allocd :: GeneralFlag
Opt_Ticky_LNE :: GeneralFlag
Opt_Ticky_Dyn_Thunk :: GeneralFlag
Opt_Ticky_Tag :: GeneralFlag

-- | Use regular thunks even when we could use std ap thunks in order to
--   get entry counts
Opt_Ticky_AP :: GeneralFlag
Opt_CmmThreadSanitizer :: GeneralFlag
Opt_RPath :: GeneralFlag
Opt_RelativeDynlibPaths :: GeneralFlag

-- | <pre>
--   -fcompact-unwind
--   </pre>
Opt_CompactUnwind :: GeneralFlag
Opt_Hpc :: GeneralFlag
Opt_FamAppCache :: GeneralFlag
Opt_ExternalInterpreter :: GeneralFlag
Opt_OptimalApplicativeDo :: GeneralFlag
Opt_VersionMacros :: GeneralFlag
Opt_WholeArchiveHsLibs :: GeneralFlag
Opt_SingleLibFolder :: GeneralFlag
Opt_ExposeInternalSymbols :: GeneralFlag
Opt_KeepCAFs :: GeneralFlag
Opt_KeepGoing :: GeneralFlag
Opt_ByteCode :: GeneralFlag
Opt_ByteCodeAndObjectCode :: GeneralFlag
Opt_UnoptimizedCoreForInterpreter :: GeneralFlag
Opt_LinkRts :: GeneralFlag
Opt_ErrorSpans :: GeneralFlag
Opt_DeferDiagnostics :: GeneralFlag

-- | Dump diagnostics as JSON
Opt_DiagnosticsAsJSON :: GeneralFlag
Opt_DiagnosticsShowCaret :: GeneralFlag
Opt_PprCaseAsLet :: GeneralFlag
Opt_PprShowTicks :: GeneralFlag
Opt_ShowHoleConstraints :: GeneralFlag
Opt_ShowValidHoleFits :: GeneralFlag
Opt_SortValidHoleFits :: GeneralFlag
Opt_SortBySizeHoleFits :: GeneralFlag
Opt_SortBySubsumHoleFits :: GeneralFlag
Opt_AbstractRefHoleFits :: GeneralFlag
Opt_UnclutterValidHoleFits :: GeneralFlag
Opt_ShowTypeAppOfHoleFits :: GeneralFlag
Opt_ShowTypeAppVarsOfHoleFits :: GeneralFlag
Opt_ShowDocsOfHoleFits :: GeneralFlag
Opt_ShowTypeOfHoleFits :: GeneralFlag
Opt_ShowProvOfHoleFits :: GeneralFlag
Opt_ShowMatchesOfHoleFits :: GeneralFlag
Opt_ShowLoadedModules :: GeneralFlag
Opt_HexWordLiterals :: GeneralFlag
Opt_SuppressCoercions :: GeneralFlag
Opt_SuppressCoercionTypes :: GeneralFlag
Opt_SuppressVarKinds :: GeneralFlag
Opt_SuppressModulePrefixes :: GeneralFlag
Opt_SuppressTypeApplications :: GeneralFlag
Opt_SuppressIdInfo :: GeneralFlag
Opt_SuppressUnfoldings :: GeneralFlag
Opt_SuppressTypeSignatures :: GeneralFlag
Opt_SuppressUniques :: GeneralFlag
Opt_SuppressStgExts :: GeneralFlag
Opt_SuppressStgReps :: GeneralFlag
Opt_SuppressTicks :: GeneralFlag

-- | Suppress timestamps in dumps
Opt_SuppressTimestamps :: GeneralFlag

-- | Suppress per binding Core size stats in dumps
Opt_SuppressCoreSizes :: GeneralFlag
Opt_ShowErrorContext :: GeneralFlag
Opt_ObjectDeterminism :: GeneralFlag
Opt_AutoLinkPackages :: GeneralFlag
Opt_ImplicitImportQualified :: GeneralFlag
Opt_KeepHscppFiles :: GeneralFlag
Opt_KeepHiDiffs :: GeneralFlag
Opt_KeepHcFiles :: GeneralFlag
Opt_KeepSFiles :: GeneralFlag
Opt_KeepTmpFiles :: GeneralFlag
Opt_KeepRawTokenStream :: GeneralFlag
Opt_KeepLlvmFiles :: GeneralFlag
Opt_KeepHiFiles :: GeneralFlag
Opt_KeepOFiles :: GeneralFlag
Opt_BuildDynamicToo :: GeneralFlag
Opt_WriteIfSimplifiedCore :: GeneralFlag
Opt_UseBytecodeRatherThanObjects :: GeneralFlag
Opt_DistrustAllPackages :: GeneralFlag
Opt_PackageTrust :: GeneralFlag
Opt_PluginTrustworthy :: GeneralFlag
Opt_G_NoStateHack :: GeneralFlag
Opt_G_NoOptCoercion :: GeneralFlag

-- | Used to describe warnings and errors o The message has a
--   file/line/column heading, plus "warning:" or "error:", added by
--   mkLocMessage o With <a>SevIgnore</a> the message is suppressed o
--   Output is intended for end users
data Severity

-- | Ignore this message, for example in case of suppression of warnings
--   users don't want to see. See Note [Suppressing Messages]
SevIgnore :: Severity
SevWarning :: Severity
SevError :: Severity

-- | A value of type <tt>Backend</tt> represents one of GHC's back ends.
--   The set of back ends cannot be extended except by modifying the
--   definition of <tt>Backend</tt> in this module.
--   
--   The <tt>Backend</tt> type is abstract; that is, its value constructors
--   are not exported. It's crucial that they not be exported, because a
--   value of type <tt>Backend</tt> carries only the back end's
--   <i>name</i>, not its behavior or properties. If <tt>Backend</tt> were
--   not abstract, then code elsewhere in the compiler could depend
--   directly on the name, not on the semantics, which would make it
--   challenging to create a new back end. Because <tt>Backend</tt>
--   <i>is</i> abstract, all the obligations of a new back end are
--   enumerated in this module, in the form of functions that take
--   <tt>Backend</tt> as an argument.
--   
--   The issue of abstraction is discussed at great length in #20927 and
--   !7442.
data Backend

-- | Test whether a <a>GeneralFlag</a> is set
--   
--   Note that <a>dynamicNow</a> (i.e., dynamic objects built with
--   `-dynamic-too`) always implicitly enables Opt_PIC,
--   Opt_ExternalDynamicRefs, and disables Opt_SplitSections.
gopt :: GeneralFlag -> DynFlags -> Bool

-- | The native code generator. Compiles Cmm code into textual assembler,
--   then relies on an external assembler toolchain to produce machine
--   code.
--   
--   Only supports a few platforms (X86, PowerPC, SPARC).
--   
--   See <a>GHC.CmmToAsm</a>.
ncgBackend :: Backend

-- | The LLVM backend.
--   
--   Compiles Cmm code into LLVM textual IR, then relies on LLVM toolchain
--   to produce machine code.
--   
--   It relies on LLVM support for the calling convention used by the NCG
--   backend to produce code objects ABI compatible with it (see "cc 10" or
--   "ghccc" calling convention in
--   <a>https://llvm.org/docs/LangRef.html#calling-conventions)</a>.
--   
--   Supports a few platforms (X86, AArch64, s390x, ARM).
--   
--   See <a>GHC.CmmToLlvm</a>
llvmBackend :: Backend

-- | Via-C ("unregisterised") backend.
--   
--   Compiles Cmm code into C code, then relies on a C compiler to produce
--   machine code.
--   
--   It produces code objects that are <i>not</i> ABI compatible with those
--   produced by NCG and LLVM backends.
--   
--   Produced code is expected to be less efficient than the one produced
--   by NCG and LLVM backends because STG registers are not pinned into
--   real registers. On the other hand, it supports more target platforms
--   (those having a valid C toolchain).
--   
--   See <a>GHC.CmmToC</a>
viaCBackend :: Backend

-- | The ByteCode interpreter.
--   
--   Produce ByteCode objects (BCO, see <a>GHC.ByteCode</a>) that can be
--   interpreted. It is used by GHCi.
--   
--   Currently some extensions are not supported (foreign primops).
--   
--   See <a>GHC.StgToByteCode</a>
interpreterBackend :: Backend

-- | A dummy back end that generates no code.
--   
--   Use this back end to disable code generation. It is particularly
--   useful when GHC is used as a library for other purpose than generating
--   code (e.g. to generate documentation with Haddock) or when the user
--   requested it (via `-fno-code`) for some reason.
noBackend :: Backend

-- | The <a>GhcMode</a> tells us whether we're doing multi-module
--   compilation (controlled via the <a>GHC</a> API) or one-shot
--   (single-module) compilation. This makes a difference primarily to the
--   <a>GHC.Unit.Finder</a>: in one-shot mode we look for interface files
--   for imported modules, but in multi-module mode we look for source
--   files in order to check whether they need to be recompiled.
data GhcMode

-- | <tt>--make</tt>, GHCi, etc.
CompManager :: GhcMode

-- | <pre>
--   ghc -c Foo.hs
--   </pre>
OneShot :: GhcMode

-- | <tt>ghc -M</tt>, see <a>GHC.Unit.Finder</a> for why we need this
MkDepend :: GhcMode

-- | What to do in the link step, if there is one.
data GhcLink

-- | Don't link at all
NoLink :: GhcLink

-- | Link object code into a binary
LinkBinary :: GhcLink

-- | Use the in-memory dynamic linker (works for both bytecode and object
--   code).
LinkInMemory :: GhcLink

-- | Link objects into a dynamic lib (DLL on Windows, DSO on ELF platforms)
LinkDynLib :: GhcLink

-- | Link objects into a static lib
LinkStaticLib :: GhcLink

-- | Link objects into a merged "GHCi object"
LinkMergedObj :: GhcLink
parseDynamicFlags :: MonadIO m => Logger -> DynFlags -> [Located String] -> m (DynFlags, [Located String], Messages DriverMessage)

-- | Parse command line arguments that look like files. First normalises
--   its arguments and then splits them into source files and object files.
--   A source file can be turned into a <a>Target</a> via
--   <a>guessTarget</a>
parseTargetFiles :: DynFlags -> [String] -> (DynFlags, [(String, Maybe Phase)], [String])

-- | Grabs the DynFlags from the Session
getSessionDynFlags :: GhcMonad m => m DynFlags
setTopSessionDynFlags :: GhcMonad m => DynFlags -> m ()
setSessionDynFlags :: (HasCallStack, GhcMonad m) => DynFlags -> m ()
setUnitDynFlags :: GhcMonad m => UnitId -> DynFlags -> m ()

-- | Returns the program <a>DynFlags</a>.
getProgramDynFlags :: GhcMonad m => m DynFlags

-- | Sets the program <a>DynFlags</a>. Note: this invalidates the internal
--   cached module graph, causing more work to be done the next time
--   <a>load</a> is called.
--   
--   Returns a boolean indicating if preload units have changed and need to
--   be reloaded.
setProgramDynFlags :: GhcMonad m => DynFlags -> m Bool

-- | Get the <a>DynFlags</a> used to evaluate interactive expressions.
getInteractiveDynFlags :: GhcMonad m => m DynFlags

-- | Set the <a>DynFlags</a> used to evaluate interactive expressions. Also
--   initialise (load) plugins.
--   
--   Note: this cannot be used for changes to packages. Use
--   <a>setSessionDynFlags</a>, or <a>setProgramDynFlags</a> and then copy
--   the <tt>unitState</tt> into the interactive <tt>DynFlags</tt>.
setInteractiveDynFlags :: GhcMonad m => DynFlags -> m ()

-- | Find the package environment (if one exists)
--   
--   We interpret the package environment as a set of package flags; to be
--   specific, if we find a package environment file like
--   
--   <pre>
--   clear-package-db
--   global-package-db
--   package-db blah/package.conf.d
--   package-id id1
--   package-id id2
--   </pre>
--   
--   we interpret this as
--   
--   <pre>
--   [ -hide-all-packages
--   , -clear-package-db
--   , -global-package-db
--   , -package-db blah/package.conf.d
--   , -package-id id1
--   , -package-id id2
--   ]
--   </pre>
--   
--   There's also an older syntax alias for package-id, which is just an
--   unadorned package id
--   
--   <pre>
--   id1
--   id2
--   </pre>
interpretPackageEnv :: Logger -> DynFlags -> IO DynFlags
data Logger
getLogger :: HasLogger m => m Logger

-- | Push a log hook
pushLogHook :: (LogAction -> LogAction) -> Logger -> Logger

-- | Pop a log hook
popLogHook :: Logger -> Logger

-- | Push a log hook on the stack
pushLogHookM :: GhcMonad m => (LogAction -> LogAction) -> m ()

-- | Pop a log hook from the stack
popLogHookM :: GhcMonad m => m ()

-- | Modify the logger
modifyLogger :: GhcMonad m => (Logger -> Logger) -> m ()

-- | Put a log message
putMsgM :: GhcMonad m => SDoc -> m ()

-- | Put a log message
putLogMsgM :: GhcMonad m => MessageClass -> SrcSpan -> SDoc -> m ()

-- | A compilation target.
--   
--   A target may be supplied with the actual text of the module. If so,
--   use this instead of the file contents (this is for use in an IDE where
--   the file hasn't been saved by the user yet).
--   
--   These fields are strict because Targets are long lived.
data Target
Target :: !TargetId -> !Bool -> !UnitId -> !Maybe (InputFileBuffer, UTCTime) -> Target

-- | module or filename
[targetId] :: Target -> !TargetId

-- | object code allowed?
[targetAllowObjCode] :: Target -> !Bool

-- | id of the unit this target is part of
[targetUnitId] :: Target -> !UnitId

-- | Optional in-memory buffer containing the source code GHC should use
--   for this target instead of reading it from disk.
--   
--   Since GHC version 8.10 modules which require preprocessors such as
--   Literate Haskell or CPP to run are also supported.
--   
--   If a corresponding source file does not exist on disk this will result
--   in a <tt>SourceError</tt> exception if <tt>targetId = TargetModule
--   _</tt> is used. However together with <tt>targetId = TargetFile _</tt>
--   GHC will not complain about the file missing.
[targetContents] :: Target -> !Maybe (InputFileBuffer, UTCTime)
data TargetId

-- | A module name: search for the file
TargetModule :: !ModuleName -> TargetId

-- | A filename: preprocess &amp; parse it to find the module name. If
--   specified, the Phase indicates how to compile this file (which phase
--   to start from). Nothing indicates the starting phase should be
--   determined from the suffix of the filename.
TargetFile :: !FilePath -> !Maybe Phase -> TargetId

-- | Untyped Phase description
data Phase

-- | Sets the targets for this session. Each target may be a module name or
--   a filename. The targets correspond to the set of root modules for the
--   program/library. Unloading the current program is achieved by setting
--   the current set of targets to be empty, followed by <a>load</a>.
setTargets :: GhcMonad m => [Target] -> m ()

-- | Returns the current set of targets
getTargets :: GhcMonad m => m [Target]

-- | Add another target.
addTarget :: GhcMonad m => Target -> m ()

-- | Remove a target
removeTarget :: GhcMonad m => TargetId -> m ()

-- | Attempts to guess what Target a string refers to. This function
--   implements the <tt>--make</tt>/GHCi command-line syntax for filenames:
--   
--   <ul>
--   <li>if the string looks like a Haskell source filename, then interpret
--   it as such</li>
--   <li>if adding a .hs or .lhs suffix yields the name of an existing
--   file, then use that</li>
--   <li>otherwise interpret the string as a module name</li>
--   </ul>
guessTarget :: GhcMonad m => String -> Maybe UnitId -> Maybe Phase -> m Target

-- | Perform a dependency analysis starting from the current targets and
--   update the session with the new module graph.
--   
--   Dependency analysis entails parsing the <tt>import</tt> directives and
--   may therefore require running certain preprocessors.
--   
--   Note that each <a>ModSummary</a> in the module graph caches its
--   <a>DynFlags</a>. These <a>DynFlags</a> are determined by the
--   <i>current</i> session <a>DynFlags</a> and the <tt>OPTIONS</tt> and
--   <tt>LANGUAGE</tt> pragmas of the parsed module. Thus if you want
--   changes to the <a>DynFlags</a> to take effect you need to call this
--   function again. In case of errors, just throw them.
depanal :: GhcMonad m => [ModuleName] -> Bool -> m ModuleGraph

-- | Perform dependency analysis like in <a>depanal</a>. In case of errors,
--   the errors and an empty module graph are returned.
depanalE :: GhcMonad m => [ModuleName] -> Bool -> m (DriverMessages, ModuleGraph)

-- | Try to load the program. See <a>LoadHowMuch</a> for the different
--   modes.
--   
--   This function implements the core of GHC's <tt>--make</tt> mode. It
--   preprocesses, compiles and loads the specified modules, avoiding
--   re-compilation wherever possible. Depending on the backend (see
--   <a>backend</a> field) compiling and loading may result in files being
--   created on disk.
--   
--   Calls the <a>defaultWarnErrLogger</a> after each compiling each
--   module, whether successful or not.
--   
--   If errors are encountered during dependency analysis, the module
--   <a>depanalE</a> returns together with the errors an empty ModuleGraph.
--   After processing this empty ModuleGraph, the errors of depanalE are
--   thrown. All other errors are reported using the
--   <a>defaultWarnErrLogger</a>.
load :: GhcMonad f => LoadHowMuch -> f SuccessFlag
loadWithCache :: GhcMonad m => Maybe ModIfaceCache -> (GhcMessage -> AnyGhcDiagnostic) -> LoadHowMuch -> m SuccessFlag

-- | Describes which modules of the module graph need to be loaded.
data LoadHowMuch

-- | Load all targets and its dependencies.
LoadAllTargets :: LoadHowMuch

-- | Load only the given module and its dependencies.
LoadUpTo :: HomeUnitModule -> LoadHowMuch

-- | Load only the dependencies of the given module, but not the module
--   itself.
LoadDependenciesOf :: HomeUnitModule -> LoadHowMuch
data InteractiveImport

-- | Bring the exports of a particular module (filtered by an import decl)
--   into scope
IIDecl :: ImportDecl GhcPs -> InteractiveImport

-- | Bring into scope the entire top-level envt of of this module,
--   including the things imported into it.
IIModule :: ModuleName -> InteractiveImport
data SuccessFlag
Succeeded :: SuccessFlag
Failed :: SuccessFlag
succeeded :: SuccessFlag -> Bool
failed :: SuccessFlag -> Bool
defaultWarnErrLogger :: WarnErrLogger

-- | A function called to log warnings and errors.
type WarnErrLogger = forall (m :: Type -> Type). (HasDynFlags m, MonadIO m, HasLogger m) => Maybe SourceError -> m ()

-- | Inform GHC that the working directory has changed. GHC will flush its
--   cache of module locations, since it may no longer be valid.
--   
--   Note: Before changing the working directory make sure all threads
--   running in the same session have stopped. If you change the working
--   directory, you should also unload the current program (set targets to
--   empty, followed by load).
workingDirectoryChanged :: GhcMonad m => m ()

-- | Parse a module.
--   
--   Throws a <a>SourceError</a> on parse error.
parseModule :: GhcMonad m => ModSummary -> m ParsedModule

-- | Typecheck and rename a parsed module.
--   
--   Throws a <a>SourceError</a> if either fails.
typecheckModule :: GhcMonad m => ParsedModule -> m TypecheckedModule

-- | Desugar a typechecked module.
desugarModule :: GhcMonad m => TypecheckedModule -> m DesugaredModule

-- | The result of successful parsing.
data ParsedModule
ParsedModule :: ModSummary -> ParsedSource -> [FilePath] -> ParsedModule
[pm_mod_summary] :: ParsedModule -> ModSummary
[pm_parsed_source] :: ParsedModule -> ParsedSource
[pm_extra_src_files] :: ParsedModule -> [FilePath]

-- | The result of successful typechecking. It also contains the parser
--   result.
data TypecheckedModule
TypecheckedModule :: ParsedModule -> Maybe RenamedSource -> TypecheckedSource -> ModuleInfo -> (TcGblEnv, ModDetails) -> TypecheckedModule
[tm_parsed_module] :: TypecheckedModule -> ParsedModule
[tm_renamed_source] :: TypecheckedModule -> Maybe RenamedSource
[tm_typechecked_source] :: TypecheckedModule -> TypecheckedSource
[tm_checked_module_info] :: TypecheckedModule -> ModuleInfo
[tm_internals_] :: TypecheckedModule -> (TcGblEnv, ModDetails)

-- | The result of successful desugaring (i.e., translation to core). Also
--   contains all the information of a typechecked module.
data DesugaredModule
DesugaredModule :: TypecheckedModule -> ModGuts -> DesugaredModule
[dm_typechecked_module] :: DesugaredModule -> TypecheckedModule
[dm_core_module] :: DesugaredModule -> ModGuts
type TypecheckedSource = LHsBinds GhcTc
type ParsedSource = Located HsModule GhcPs
type RenamedSource = (HsGroup GhcRn, [LImportDecl GhcRn], Maybe [(LIE GhcRn, Avails)], Maybe LHsDoc GhcRn, Maybe XRec GhcRn ModuleName)
class ParsedMod m => TypecheckedMod m
class ParsedMod m
moduleInfo :: TypecheckedMod m => m -> ModuleInfo
renamedSource :: TypecheckedMod m => m -> Maybe RenamedSource
typecheckedSource :: TypecheckedMod m => m -> TypecheckedSource
parsedSource :: ParsedMod m => m -> ParsedSource
coreModule :: DesugaredMod m => m -> ModGuts

-- | Package-qualifier after renaming
--   
--   Renaming detects if "this" or the unit-id of the home-unit was used as
--   a package qualifier.
data PkgQual

-- | No package qualifier
NoPkgQual :: PkgQual

-- | Import from home-unit
ThisPkg :: !UnitId -> PkgQual

-- | Import from another unit
OtherPkg :: !UnitId -> PkgQual

-- | A CoreModule consists of just the fields of a <a>ModGuts</a> that are
--   needed for the <a>compileToCoreModule</a> interface.
data CoreModule
CoreModule :: !Module -> !TypeEnv -> CoreProgram -> SafeHaskellMode -> CoreModule

-- | Module name
[cm_module] :: CoreModule -> !Module

-- | Type environment for types declared in this module
[cm_types] :: CoreModule -> !TypeEnv

-- | Declarations
[cm_binds] :: CoreModule -> CoreProgram

-- | Safe Haskell mode
[cm_safe] :: CoreModule -> SafeHaskellMode

-- | This is the way to get access to the Core bindings corresponding to a
--   module. <tt>compileToCore</tt> parses, typechecks, and desugars the
--   module, then returns the resulting Core module (consisting of the
--   module name, type declarations, and function declarations) if
--   successful.
compileToCoreModule :: GhcMonad m => FilePath -> m CoreModule

-- | Like compileToCoreModule, but invokes the simplifier, so as to return
--   simplified and tidied Core.
compileToCoreSimplified :: GhcMonad m => FilePath -> m CoreModule

-- | A '<tt>ModuleGraph</tt>' contains all the nodes from the home package
--   (only). See '<tt>ModuleGraphNode</tt>' for information about the
--   nodes.
--   
--   Modules need to be compiled. hs-boots need to be typechecked before
--   the associated "real" module so modules with {-# SOURCE #-} imports
--   can be built. Instantiations also need to be typechecked to ensure
--   that the module fits the signature. Substantiation typechecking is
--   roughly comparable to the check that the module and its hs-boot agree.
--   
--   The graph is not necessarily stored in topologically-sorted order. Use
--   <a>topSortModuleGraph</a> and <a>flattenSCC</a> to achieve this.
data ModuleGraph
emptyMG :: ModuleGraph

-- | Map a function <tt>f</tt> over all the <tt>ModSummaries</tt>. To
--   preserve invariants <tt>f</tt> can't change the isBoot status.
mapMG :: (ModSummary -> ModSummary) -> ModuleGraph -> ModuleGraph
mkModuleGraph :: [ModuleGraphNode] -> ModuleGraph
mgModSummaries :: ModuleGraph -> [ModSummary]

-- | Look up a ModSummary in the ModuleGraph Looks up the non-boot
--   ModSummary Linear in the size of the module graph
mgLookupModule :: ModuleGraph -> Module -> Maybe ModSummary

-- | Data for a module node in a <tt>ModuleGraph</tt>. Module nodes of the
--   module graph are one of:
--   
--   <ul>
--   <li>A regular Haskell source module</li>
--   <li>A hi-boot source module</li>
--   </ul>
data ModSummary
ModSummary :: Module -> HscSource -> ModLocation -> Fingerprint -> Maybe UTCTime -> !Maybe UTCTime -> Maybe UTCTime -> Maybe UTCTime -> [(PkgQual, Located ModuleName)] -> [(PkgQual, Located ModuleName)] -> !Bool -> Maybe HsParsedModule -> FilePath -> DynFlags -> Maybe StringBuffer -> ModSummary

-- | Identity of the module
[ms_mod] :: ModSummary -> Module

-- | The module source either plain Haskell, hs-boot, or hsig
[ms_hsc_src] :: ModSummary -> HscSource

-- | Location of the various files belonging to the module
[ms_location] :: ModSummary -> ModLocation

-- | Content hash of source file
[ms_hs_hash] :: ModSummary -> Fingerprint

-- | Timestamp of object, if we have one
[ms_obj_date] :: ModSummary -> Maybe UTCTime

-- | Timestamp of dynamic object, if we have one
[ms_dyn_obj_date] :: ModSummary -> !Maybe UTCTime

-- | Timestamp of hi file, if we have one See Note [When source is
--   considered modified] and #9243
[ms_iface_date] :: ModSummary -> Maybe UTCTime

-- | Timestamp of hie file, if we have one
[ms_hie_date] :: ModSummary -> Maybe UTCTime

-- | Source imports of the module
[ms_srcimps] :: ModSummary -> [(PkgQual, Located ModuleName)]

-- | Non-source imports of the module from the module *text*
[ms_textual_imps] :: ModSummary -> [(PkgQual, Located ModuleName)]

-- | Whether the special module GHC.Prim was imported explicitly
[ms_ghc_prim_import] :: ModSummary -> !Bool

-- | The parsed, nonrenamed source, if we have it. This is also used to
--   support "inline module syntax" in Backpack files.
[ms_parsed_mod] :: ModSummary -> Maybe HsParsedModule

-- | Filename of preprocessed source file
[ms_hspp_file] :: ModSummary -> FilePath

-- | Cached flags from <tt>OPTIONS</tt>, <tt>INCLUDE</tt> and
--   <tt>LANGUAGE</tt> pragmas in the modules source code
[ms_hspp_opts] :: ModSummary -> DynFlags

-- | The actual preprocessed source, if we have it
[ms_hspp_buf] :: ModSummary -> Maybe StringBuffer
ms_mod_name :: ModSummary -> ModuleName

-- | Module Location
--   
--   Where a module lives on the file system: the actual locations of the
--   .hs, .hi, .dyn_hi, .o, .dyn_o and .hie files, if we have them.
--   
--   For a module in another unit, the ml_hs_file_ospath and
--   ml_obj_file_ospath components of ModLocation are undefined.
--   
--   The locations specified by a ModLocation may or may not correspond to
--   actual files yet: for example, even if the object file doesn't exist,
--   the ModLocation still contains the path to where the object file will
--   reside if/when it is created.
--   
--   The paths of anything which can affect recompilation should be placed
--   inside ModLocation.
--   
--   When a ModLocation is created none of the filepaths will have -boot
--   suffixes. This is because in --make mode the ModLocation is put in the
--   finder cache which is indexed by ModuleName, when a ModLocation is
--   retrieved from the FinderCache the boot suffixes are appended. The
--   other case is in -c mode, there the ModLocation immediately gets given
--   the boot suffixes in mkOneShotModLocation.
data ModLocation
OsPathModLocation :: Maybe OsPath -> OsPath -> OsPath -> OsPath -> OsPath -> OsPath -> ModLocation

-- | The source file, if we have one. Package modules probably don't have
--   source files.
[ml_hs_file_ospath] :: ModLocation -> Maybe OsPath

-- | Where the .hi file is, whether or not it exists yet. Always of form
--   foo.hi, even if there is an hi-boot file (we add the -boot suffix
--   later)
[ml_hi_file_ospath] :: ModLocation -> OsPath

-- | Where the .dyn_hi file is, whether or not it exists yet.
[ml_dyn_hi_file_ospath] :: ModLocation -> OsPath

-- | Where the .o file is, whether or not it exists yet. (might not exist
--   either because the module hasn't been compiled yet, or because it is
--   part of a unit with a .a file)
[ml_obj_file_ospath] :: ModLocation -> OsPath

-- | Where the .dy file is, whether or not it exists yet.
[ml_dyn_obj_file_ospath] :: ModLocation -> OsPath

-- | Where the .hie file is, whether or not it exists yet.
[ml_hie_file_ospath] :: ModLocation -> OsPath
pattern ModLocation :: Maybe FilePath -> FilePath -> FilePath -> FilePath -> FilePath -> FilePath -> ModLocation

-- | Return the <a>ModSummary</a> of a module with the given name.
--   
--   The module must be part of the module graph (see <a>hsc_mod_graph</a>
--   and <a>ModuleGraph</a>). If this is not the case, this function will
--   throw a <a>GhcApiError</a>.
--   
--   This function ignores boot modules and requires that there is only one
--   non-boot module with the given name.
getModSummary :: GhcMonad m => ModuleName -> m ModSummary

-- | Get the module dependency graph.
getModuleGraph :: GhcMonad m => m ModuleGraph

-- | Return <tt>True</tt> &lt;==&gt; module is loaded.
isLoaded :: GhcMonad m => ModuleName -> m Bool
isLoadedModule :: GhcMonad m => UnitId -> ModuleName -> m Bool

-- | Topological sort of the module graph
--   
--   Calculate SCCs of the module graph, possibly dropping the hi-boot
--   nodes The resulting list of strongly-connected-components is in
--   topologically sorted order, starting with the module(s) at the bottom
--   of the dependency graph (ie compile them first) and ending with the
--   ones at the top.
--   
--   Drop hi-boot nodes (first boolean arg)?
--   
--   <ul>
--   <li><tt>False</tt>: treat the hi-boot summaries as nodes of the graph,
--   so the graph must be acyclic</li>
--   <li><tt>True</tt>: eliminate the hi-boot nodes, and instead pretend
--   the a source-import of Foo is an import of Foo The resulting graph has
--   no hi-boot nodes, but can be cyclic</li>
--   </ul>
topSortModuleGraph :: Bool -> ModuleGraph -> Maybe HomeUnitModule -> [SCC ModuleGraphNode]

-- | Container for information about a <a>Module</a>.
data ModuleInfo

-- | Request information about a loaded <a>Module</a>
getModuleInfo :: GhcMonad m => Module -> m (Maybe ModuleInfo)

-- | The list of top-level entities defined in a module
modInfoTyThings :: ModuleInfo -> [TyThing]
modInfoExports :: ModuleInfo -> [Name]
modInfoExportsWithSelectors :: ModuleInfo -> [Name]

-- | Returns the instances defined by the specified module. Warning:
--   currently unimplemented for package modules.
modInfoInstances :: ModuleInfo -> [ClsInst]
modInfoIsExportedName :: ModuleInfo -> Name -> Bool
modInfoLookupName :: GhcMonad m => ModuleInfo -> Name -> m (Maybe TyThing)
modInfoIface :: ModuleInfo -> Maybe ModIface

-- | Retrieve module safe haskell mode
modInfoSafe :: ModuleInfo -> SafeHaskellMode

-- | Looks up a global name: that is, any top-level name in any visible
--   module. Unlike <a>lookupName</a>, lookupGlobalName does not use the
--   interactive context, and therefore does not require a preceding
--   <a>setContext</a>.
lookupGlobalName :: GhcMonad m => Name -> m (Maybe TyThing)
findGlobalAnns :: (GhcMonad m, Typeable a) => ([Word8] -> a) -> AnnTarget Name -> m [a]
mkNamePprCtxForModule :: GhcMonad m => Module -> ModuleInfo -> m NamePprCtx
type ModIface = ModIface_ 'ModIfaceFinal

-- | A <a>ModIface</a> plus a <tt>ModDetails</tt> summarises everything we
--   know about a compiled module. The <a>ModIface</a> is the stuff
--   *before* linking, and can be written out to an interface file. The
--   'ModDetails is after linking and can be completely recovered from just
--   the <a>ModIface</a>.
--   
--   When we read an interface file, we also construct a <a>ModIface</a>
--   from it, except that we explicitly make the <a>mi_decls</a> and a few
--   other fields empty; as when reading we consolidate the declarations
--   etc. into a number of indexed maps and environments in the
--   <tt>ExternalPackageState</tt>.
--   
--   See Note [Strictness in ModIface] to learn about why some fields are
--   strict and others are not.
--   
--   See Note [Private fields in ModIface] to learn why we don't export any
--   of the fields.
data ModIface_ (phase :: ModIfacePhase)
pattern ModIface :: Module -> Maybe Module -> HscSource -> Dependencies -> [Usage] -> [IfaceExport] -> Bool -> [(OccName, Fixity)] -> IfaceWarnings -> [IfaceAnnotation] -> [IfaceDeclExts phase] -> Maybe [IfaceBindingX IfaceMaybeRhs IfaceTopBndrInfo] -> IfaceForeign -> [IfaceDefault] -> Maybe IfaceTopEnv -> [IfaceClsInst] -> [IfaceFamInst] -> [IfaceRule] -> AnyHpcUsage -> IfaceTrustInfo -> Bool -> [IfaceCompleteMatch] -> Maybe Docs -> IfaceBackendExts phase -> ExtensibleFields -> Fingerprint -> IfaceBinHandle phase -> ModIface_ phase

-- | The various Safe Haskell modes
data SafeHaskellMode

-- | inferred unsafe
Sf_None :: SafeHaskellMode

-- | declared and checked
Sf_Unsafe :: SafeHaskellMode

-- | declared and checked
Sf_Trustworthy :: SafeHaskellMode

-- | declared and checked
Sf_Safe :: SafeHaskellMode

-- | inferred as safe
Sf_SafeInferred :: SafeHaskellMode

-- | <tt>-fno-safe-haskell</tt> state
Sf_Ignore :: SafeHaskellMode

-- | When printing code that contains original names, we need to map the
--   original names back to something the user understands. This is the
--   purpose of the triple of functions that gets passed around when
--   rendering <a>SDoc</a>.
data NamePprCtx
alwaysQualify :: NamePprCtx

-- | Run a statement in the current interactive context.
execStmt :: GhcMonad m => String -> ExecOptions -> m ExecResult

-- | Like <a>execStmt</a>, but takes a parsed statement as argument. Useful
--   when doing preprocessing on the AST before execution, e.g. in GHCi
--   (see GHCi.UI.runStmt).
execStmt' :: GhcMonad m => GhciLStmt GhcPs -> String -> ExecOptions -> m ExecResult
data ExecOptions
ExecOptions :: SingleStep -> String -> Int -> (ForeignHValue -> EvalExpr ForeignHValue) -> ExecOptions

-- | stepping mode
[execSingleStep] :: ExecOptions -> SingleStep

-- | filename (for errors)
[execSourceFile] :: ExecOptions -> String

-- | line number (for errors)
[execLineNumber] :: ExecOptions -> Int
[execWrap] :: ExecOptions -> ForeignHValue -> EvalExpr ForeignHValue

-- | default ExecOptions
execOptions :: ExecOptions
data ExecResult
ExecComplete :: Either SomeException [Name] -> Word64 -> ExecResult
[execResult] :: ExecResult -> Either SomeException [Name]
[execAllocation] :: ExecResult -> Word64
ExecBreak :: [Name] -> Maybe InternalBreakpointId -> ExecResult
[breakNames] :: ExecResult -> [Name]
[breakPointId] :: ExecResult -> Maybe InternalBreakpointId
resumeExec :: GhcMonad m => (SrcSpan -> Bool) -> SingleStep -> Maybe Int -> m ExecResult
runDecls :: GhcMonad m => String -> m [Name]

-- | Run some declarations and return any user-visible names that were
--   brought into scope.
runDeclsWithLocation :: GhcMonad m => String -> Int -> String -> m [Name]

-- | Like <a>runDeclsWithLocation</a>, but takes parsed declarations as
--   argument. Useful when doing preprocessing on the AST before execution,
--   e.g. in GHCi (see GHCi.UI.runStmt).
runParsedDecls :: GhcMonad m => [LHsDecl GhcPs] -> m [Name]
parseImportDecl :: GhcMonad m => String -> m (ImportDecl GhcPs)

-- | Set the interactive evaluation context.
--   
--   (setContext imports) sets the ic_imports field (which in turn
--   determines what is in scope at the prompt) to <tt>imports</tt>, and
--   updates the icReaderEnv environment to reflect it.
--   
--   We retain in scope all the things defined at the prompt, and kept in
--   ic_tythings. (Indeed, they shadow stuff from ic_imports.)
setContext :: GhcMonad m => [InteractiveImport] -> m ()

-- | Get the interactive evaluation context, consisting of a pair of the
--   set of modules from which we take the full top-level scope, and the
--   set of modules from which we take just the exports respectively.
getContext :: GhcMonad m => m [InteractiveImport]

-- | Set the monad GHCi lifts user statements into.
--   
--   Checks that a type (in string form) is an instance of the
--   <tt>GHC.GHCi.GHCiSandboxIO</tt> type class. Sets it to be the GHCi
--   monad if it is, throws an error otherwise.
setGHCiMonad :: GhcMonad m => String -> m ()

-- | Get the monad GHCi lifts user statements into.
getGHCiMonad :: GhcMonad m => m Name

-- | Return the bindings for the current interactive session.
getBindings :: GhcMonad m => m [TyThing]

-- | Return the instances for the current interactive session.
getInsts :: GhcMonad m => m ([ClsInst], [FamInst])
getNamePprCtx :: GhcMonad m => m NamePprCtx

-- | Takes a <a>ModuleName</a> and possibly a <a>UnitId</a>, and consults
--   the filesystem and package database to find the corresponding
--   <a>Module</a>, using the algorithm that is used for an <tt>import</tt>
--   declaration.
findModule :: GhcMonad m => ModuleName -> Maybe FastString -> m Module

-- | Like <a>findModule</a>, but differs slightly when the module refers to
--   a source file, and the file has not been loaded via <a>load</a>. In
--   this case, <a>findModule</a> will throw an error (module not loaded),
--   but <a>lookupModule</a> will check to see whether the module can also
--   be found in a package, and if so, that package <a>Module</a> will be
--   returned. If not, the usual module-not-found error will be thrown.
lookupModule :: GhcMonad m => ModuleName -> Maybe FastString -> m Module
findQualifiedModule :: GhcMonad m => PkgQual -> ModuleName -> m Module
lookupQualifiedModule :: GhcMonad m => PkgQual -> ModuleName -> m Module
renamePkgQualM :: GhcMonad m => ModuleName -> Maybe FastString -> m PkgQual
renameRawPkgQualM :: GhcMonad m => ModuleName -> RawPkgQual -> m PkgQual

-- | Check that a module is safe to import (according to Safe Haskell).
--   
--   We return True to indicate the import is safe and False otherwise
--   although in the False case an error may be thrown first.
isModuleTrusted :: GhcMonad m => Module -> m Bool

-- | Return if a module is trusted and the pkgs it depends on to be
--   trusted.
moduleTrustReqs :: GhcMonad m => Module -> m (Bool, Set UnitId)

-- | Returns all names in scope in the current interactive context
getNamesInScope :: GhcMonad m => m [Name]

-- | Returns all <a>RdrName</a>s in scope in the current interactive
--   context, excluding any that are internally-generated.
getRdrNamesInScope :: GhcMonad m => m [RdrName]

-- | get the GlobalRdrEnv for a session
getGRE :: GhcMonad m => m GlobalRdrEnv

-- | Returns <tt>True</tt> if the specified module is interpreted, and
--   hence has its full top-level scope available.
moduleIsInterpreted :: GhcMonad m => Module -> m Bool

-- | Looks up an identifier in the current interactive context (for :info)
--   Filter the instances by the ones whose tycons (or classes resp) are in
--   scope (qualified or otherwise). Otherwise we list a whole lot too
--   many! The exact choice of which ones to show, and which to hide, is a
--   judgement call. (see #1581)
getInfo :: GhcMonad m => Bool -> Name -> m (Maybe (TyThing, Fixity, [ClsInst], [FamInst], SDoc))
showModule :: GhcMonad m => ModSummary -> m String
moduleIsBootOrNotObjectLinkable :: GhcMonad m => ModSummary -> m Bool

-- | Retrieve all type and family instances in the environment, indexed by
--   <a>Name</a>. Each name's lists will contain every instance in which
--   that name is mentioned in the instance head.
getNameToInstancesIndex :: GhcMonad m => [Module] -> Maybe [Module] -> m (Messages TcRnMessage, Maybe (NameEnv ([ClsInst], [FamInst])))

-- | Get the type of an expression Returns the type as described by
--   <a>TcRnExprMode</a>
exprType :: GhcMonad m => TcRnExprMode -> String -> m Type

-- | How should we infer a type? See Note [TcRnExprMode]
data TcRnExprMode

-- | Instantiate inferred quantifiers only (:type)
TM_Inst :: TcRnExprMode

-- | Instantiate all quantifiers, and do eager defaulting (:type +d)
TM_Default :: TcRnExprMode

-- | Get the kind of a type
typeKind :: GhcMonad m => Bool -> String -> m (Type, Kind)

-- | Parses a string as an identifier, and returns the list of <a>Name</a>s
--   that the identifier can refer to in the current interactive context.
parseName :: GhcMonad m => String -> m (NonEmpty Name)

-- | Returns the <a>TyThing</a> for a <a>Name</a>. The <a>Name</a> may
--   refer to any entity known to GHC, including <a>Name</a>s defined using
--   <tt>runStmt</tt>.
lookupName :: GhcMonad m => Name -> m (Maybe TyThing)
data HValue

-- | Parse an expression, the parsed expression can be further processed
--   and passed to compileParsedExpr.
parseExpr :: GhcMonad m => String -> m (LHsExpr GhcPs)
compileParsedExpr :: GhcMonad m => LHsExpr GhcPs -> m HValue

-- | Compile an expression, run it, and deliver the resulting HValue.
compileExpr :: GhcMonad m => String -> m HValue

-- | Compile an expression, run it and return the result as a Dynamic.
dynCompileExpr :: GhcMonad m => String -> m Dynamic
type ForeignHValue = ForeignRef HValue

-- | Compile an expression, run it, and deliver the resulting HValue.
compileExprRemote :: GhcMonad m => String -> m ForeignHValue

-- | Compile a parsed expression (before renaming), run it, and deliver the
--   resulting HValue.
compileParsedExprRemote :: GhcMonad m => LHsExpr GhcPs -> m ForeignHValue
getDocs :: GhcMonad m => Name -> m (Either GetDocsFailure (Maybe [HsDoc GhcRn], IntMap (HsDoc GhcRn)))

-- | Failure modes for <a>getDocs</a>.
data GetDocsFailure

-- | <a>nameModule_maybe</a> returned <a>Nothing</a>.
NameHasNoModule :: Name -> GetDocsFailure

-- | The module was loaded without <tt>-haddock</tt>,
NoDocsInIface :: Module -> Bool -> GetDocsFailure

-- | The <a>Name</a> was defined interactively.
InteractiveName :: GetDocsFailure
runTcInteractive :: HscEnv -> TcRn a -> IO (Messages TcRnMessage, Maybe a)

-- | Returns <tt>True</tt> if passed string is a statement.
isStmt :: ParserOpts -> String -> Bool

-- | Returns <tt>True</tt> if passed string has an import declaration.
hasImport :: ParserOpts -> String -> Bool

-- | Returns <tt>True</tt> if passed string is an import declaration.
isImport :: ParserOpts -> String -> Bool

-- | Returns <tt>True</tt> if passed string is a declaration but <b><i>not
--   a splice</i></b>.
isDecl :: ParserOpts -> String -> Bool
data SingleStep
RunToCompletion :: SingleStep
SingleStep :: SingleStep
RunAndLogSteps :: SingleStep
data Resume
Resume :: String -> ForeignRef (ResumeContext [HValueRef]) -> ResumeBindings -> [Id] -> ForeignHValue -> Maybe InternalBreakpointId -> SrcSpan -> String -> RemotePtr CostCentreStack -> [History] -> Int -> Resume
[resumeStmt] :: Resume -> String
[resumeContext] :: Resume -> ForeignRef (ResumeContext [HValueRef])
[resumeBindings] :: Resume -> ResumeBindings
[resumeFinalIds] :: Resume -> [Id]
[resumeApStack] :: Resume -> ForeignHValue

-- | the breakpoint we stopped at (Nothing <a>=</a> exception)
[resumeBreakpointId] :: Resume -> Maybe InternalBreakpointId
[resumeSpan] :: Resume -> SrcSpan
[resumeDecl] :: Resume -> String
[resumeCCS] :: Resume -> RemotePtr CostCentreStack
[resumeHistory] :: Resume -> [History]
[resumeHistoryIx] :: Resume -> Int
data History
getHistorySpan :: GhcMonad m => History -> m SrcSpan
getHistoryModule :: History -> Module
abandon :: GhcMonad m => m Bool
abandonAll :: GhcMonad m => m Bool
getResumeContext :: GhcMonad m => m [Resume]
obtainTermFromId :: GhcMonad m => Int -> Bool -> Id -> m Term
obtainTermFromVal :: GhcMonad m => Int -> Bool -> Type -> a -> m Term
reconstructType :: HscEnv -> Int -> Id -> IO (Maybe Type)
modInfoModBreaks :: ModuleInfo -> ModBreaks

-- | All the information about the breakpoints for a module
data ModBreaks
ModBreaks :: ForeignRef BreakArray -> !Array BreakIndex SrcSpan -> !Array BreakIndex [OccName] -> !Array BreakIndex [String] -> !Array BreakIndex (RemotePtr CostCentre) -> IntMap CgBreakInfo -> RemotePtr ModuleName -> ModBreaks

-- | The array of flags, one per breakpoint, indicating which breakpoints
--   are enabled.
[modBreaks_flags] :: ModBreaks -> ForeignRef BreakArray

-- | An array giving the source span of each breakpoint.
[modBreaks_locs] :: ModBreaks -> !Array BreakIndex SrcSpan

-- | An array giving the names of the free variables at each breakpoint.
[modBreaks_vars] :: ModBreaks -> !Array BreakIndex [OccName]

-- | An array giving the names of the declarations enclosing each
--   breakpoint. See Note [Field modBreaks_decls]
[modBreaks_decls] :: ModBreaks -> !Array BreakIndex [String]

-- | Array pointing to cost centre for each breakpoint
[modBreaks_ccs] :: ModBreaks -> !Array BreakIndex (RemotePtr CostCentre)

-- | info about each breakpoint from the bytecode generator
[modBreaks_breakInfo] :: ModBreaks -> IntMap CgBreakInfo
[modBreaks_module] :: ModBreaks -> RemotePtr ModuleName

-- | Breakpoint index
type BreakIndex = Int

-- | Breakpoint identifier.
--   
--   See Note [Breakpoint identifiers]
data BreakpointId
BreakpointId :: !Module -> !Int -> BreakpointId

-- | Breakpoint tick module
[bi_tick_mod] :: BreakpointId -> !Module

-- | Breakpoint tick index
[bi_tick_index] :: BreakpointId -> !Int

-- | Internal breakpoint identifier
--   
--   See Note [Breakpoint identifiers]
data InternalBreakpointId
InternalBreakpointId :: !Module -> !Int -> !Module -> !Int -> InternalBreakpointId

-- | Breakpoint tick module
[ibi_tick_mod] :: InternalBreakpointId -> !Module

-- | Breakpoint tick index
[ibi_tick_index] :: InternalBreakpointId -> !Int

-- | Breakpoint info module
[ibi_info_mod] :: InternalBreakpointId -> !Module

-- | Breakpoint info index
[ibi_info_index] :: InternalBreakpointId -> !Int
back :: GhcMonad m => Int -> m ([Name], Int, SrcSpan, String)
forward :: GhcMonad m => Int -> m ([Name], Int, SrcSpan, String)
setupBreakpoint :: GhcMonad m => HscEnv -> BreakpointId -> Int -> m ()
type Unit = GenUnit UnitId

-- | A Module is a pair of a <a>Unit</a> and a <a>ModuleName</a>.
type Module = GenModule Unit
mkModule :: u -> ModuleName -> GenModule u
pprModule :: IsLine doc => Module -> doc

-- | Module name (e.g. A.B.C)
moduleName :: GenModule unit -> ModuleName

-- | Unit the module belongs to
moduleUnit :: GenModule unit -> unit

-- | A unique, unambiguous name for something, containing information about
--   where that thing originated.
data Name
isExternalName :: Name -> Bool
nameModule :: HasDebugCallStack => Name -> Module

-- | print a <a>NamedThing</a>, adding parentheses if the name is an
--   operator.
pprParenSymName :: NamedThing a => a -> SDoc
nameSrcSpan :: Name -> SrcSpan

-- | A class allowing convenient access to the <a>Name</a> of various
--   datatypes
class NamedThing a
getOccName :: NamedThing a => a -> OccName
getName :: NamedThing a => a -> Name

-- | Reader Name
--   
--   Do not use the data constructors of RdrName directly: prefer the
--   family of functions that creates them, such as <a>mkRdrUnqual</a>
--   
--   <ul>
--   <li>Note: A Located RdrName will only have API Annotations if it is a
--   compound one, e.g.</li>
--   </ul>
--   
--   <pre>
--   `bar`
--   ( ~ )
--   </pre>
data RdrName

-- | Unqualified name
--   
--   Used for ordinary, unqualified occurrences, e.g. <tt>x</tt>,
--   <tt>y</tt> or <tt>Foo</tt>. Create such a <a>RdrName</a> with
--   <a>mkRdrUnqual</a>
Unqual :: OccName -> RdrName

-- | Qualified name
--   
--   A qualified name written by the user in <i>source</i> code. The module
--   isn't necessarily the module where the thing is defined; just the one
--   from which it is imported. Examples are <tt>Bar.x</tt>, <tt>Bar.y</tt>
--   or <tt>Bar.Foo</tt>. Create such a <a>RdrName</a> with
--   <a>mkRdrQual</a>
Qual :: ModuleName -> OccName -> RdrName

-- | Identifier
type Id = Var
idType :: Id -> Kind

-- | <a>isImplicitId</a> tells whether an <a>Id</a>s info is implied by
--   other declarations, so we don't need to put its signature in an
--   interface file, even if it's mentioned in some other interface
--   unfolding.
isImplicitId :: Id -> Bool
isDeadBinder :: Id -> Bool

-- | <tt>isExportedIdVar</tt> means "don't throw this away"
isExportedId :: Var -> Bool
isLocalId :: Var -> Bool
isGlobalId :: Var -> Bool
isRecordSelector :: Id -> Bool
isPrimOpId :: Id -> Bool
isFCallId :: Id -> Bool
isClassOpId_maybe :: Id -> Maybe Class
isDataConWorkId :: Id -> Bool

-- | Get from either the worker or the wrapper <a>Id</a> to the
--   <a>DataCon</a>. Currently used only in the desugarer.
--   
--   INVARIANT: <tt>idDataCon (dataConWrapId d) = d</tt>: remember,
--   <a>dataConWrapId</a> can return either the wrapper or the worker
idDataCon :: Id -> DataCon

-- | Returns true if an application to n args diverges or throws an
--   exception See Note [Dead ends] in <a>GHC.Types.Demand</a>.
isDeadEndId :: Var -> Bool
isDictonaryId :: Id -> Bool

-- | If the <a>Id</a> is that for a record selector, extract the
--   <a>sel_tycon</a>. Panic otherwise.
recordSelectorTyCon :: Id -> RecSelParent

-- | TyCons represent type constructors. Type constructors are introduced
--   by things such as:
--   
--   1) Data declarations: <tt>data Foo = ...</tt> creates the <tt>Foo</tt>
--   type constructor of kind <tt>Type</tt>
--   
--   2) Type synonyms: <tt>type Foo = ...</tt> creates the <tt>Foo</tt>
--   type constructor
--   
--   3) Newtypes: <tt>newtype Foo a = MkFoo ...</tt> creates the
--   <tt>Foo</tt> type constructor of kind <tt>Type -&gt; Type</tt>
--   
--   4) Class declarations: <tt>class Foo where</tt> creates the
--   <tt>Foo</tt> type constructor of kind <tt>Constraint</tt>
--   
--   This data type also encodes a number of primitive, built in type
--   constructors such as those for function and tuple types.
--   
--   If you edit this type, you may need to update the GHC formalism See
--   Note [GHC Formalism] in GHC.Core.Lint
data TyCon

-- | TyVar binders
tyConTyVars :: TyCon -> [TyVar]

-- | As <a>tyConDataCons_maybe</a>, but returns the empty list of
--   constructors if no constructors could be found
tyConDataCons :: TyCon -> [DataCon]

-- | Arity
tyConArity :: TyCon -> Arity

-- | Is this <a>TyCon</a> that for a class instance?
isClassTyCon :: TyCon -> Bool

-- | Is this a <a>TyCon</a> representing a regular H98 type synonym
--   (<tt>type</tt>)?
isTypeSynonymTyCon :: TyCon -> Bool

-- | Is this a type family <a>TyCon</a> (whether open or closed)?
isTypeFamilyTyCon :: TyCon -> Bool

-- | Is this <a>TyCon</a> that for a <tt>newtype</tt>
isNewTyCon :: TyCon -> Bool

-- | Does this <a>TyCon</a> represent something that cannot be defined in
--   Haskell?
isPrimTyCon :: TyCon -> Bool

-- | Is this a <a>TyCon</a>, synonym or otherwise, that defines a family?
isFamilyTyCon :: TyCon -> Bool

-- | Is this a <a>TyCon</a>, synonym or otherwise, that defines a family
--   with instances?
isOpenFamilyTyCon :: TyCon -> Bool

-- | Is this an open type family TyCon?
isOpenTypeFamilyTyCon :: TyCon -> Bool

-- | If this <a>TyCon</a> is that for a class instance, return the class it
--   is for. Otherwise returns <tt>Nothing</tt>
tyConClass_maybe :: TyCon -> Maybe Class

-- | Extract the information pertaining to the right hand side of a type
--   synonym (<tt>type</tt>) declaration.
synTyConRhs_maybe :: TyCon -> Maybe Type

-- | Extract the <a>TyVar</a>s bound by a vanilla type synonym and the
--   corresponding (unsubstituted) right hand side.
synTyConDefn_maybe :: TyCon -> Maybe ([TyVar], Type)

-- | Kind of this TyCon
tyConKind :: TyCon -> Kind

-- | Type or kind Variable
type TyVar = Var
alphaTyVars :: [TyVar]

-- | A data constructor
data DataCon
dataConType :: DataCon -> Type

-- | The type constructor that we are building via this data constructor
dataConTyCon :: DataCon -> TyCon

-- | The labels for the fields of this particular <a>DataCon</a>
dataConFieldLabels :: DataCon -> [FieldLabel]

-- | Should the <a>DataCon</a> be presented infix?
dataConIsInfix :: DataCon -> Bool

-- | Vanilla <a>DataCon</a>s are those that are nice boring Haskell 98
--   constructors
isVanillaDataCon :: DataCon -> Bool

-- | The user-declared type of the data constructor in the nice-to-read
--   form:
--   
--   <pre>
--   T :: forall a b. a -&gt; b -&gt; T [a]
--   </pre>
--   
--   rather than:
--   
--   <pre>
--   T :: forall a c. forall b. (c~[a]) =&gt; a -&gt; b -&gt; T c
--   </pre>
--   
--   The type variables are quantified in the order that the user wrote
--   them. See <tt>Note [DataCon user type variable binders]</tt>.
--   
--   NB: If the constructor is part of a data instance, the result type
--   mentions the family tycon, not the internal one.
dataConWrapperType :: DataCon -> Type

-- | Strictness/unpack annotations, from user; or, for imported DataCons,
--   from the interface file The list is in one-to-one correspondence with
--   the arity of the <a>DataCon</a>
dataConSrcBangs :: DataCon -> [HsSrcBang]
data StrictnessMark
MarkedStrict :: StrictnessMark
NotMarkedStrict :: StrictnessMark
isMarkedStrict :: StrictnessMark -> Bool
data Class
classMethods :: Class -> [Id]
classSCTheta :: Class -> [PredType]
classTvsFds :: Class -> ([TyVar], [FunDep TyVar])
classATs :: Class -> [TyCon]
pprFundeps :: Outputable a => [FunDep a] -> SDoc

-- | A type-class instance. Note that there is some tricky laziness at work
--   here. See Note [ClsInst laziness and the rough-match fields] for more
--   details.
data ClsInst
instanceDFunId :: ClsInst -> DFunId
pprInstance :: ClsInst -> SDoc
pprInstanceHdr :: ClsInst -> SDoc

-- | Pretty-prints a <a>FamInst</a> (type/data family instance) with its
--   defining location.
pprFamInst :: FamInst -> SDoc
data FamInst
data Type

-- | Take a ForAllTy apart, returning the list of tycovars and the result
--   type. This always succeeds, even if it returns only an empty list.
--   Note that the result type returned may have free variables that were
--   bound by a forall.
splitForAllTyCoVars :: Type -> ([TyCoVar], Type)

-- | Extract the function result type and panic if that is not possible
funResultTy :: HasDebugCallStack => Type -> Type
pprParendType :: Type -> SDoc
pprTypeApp :: TyCon -> [Type] -> SDoc

-- | The key type representing kinds in the compiler.
type Kind = Type

-- | A type of the form <tt>p</tt> of constraint kind represents a value
--   whose type is the Haskell predicate <tt>p</tt>, where a predicate is
--   what occurs before the <tt>=&gt;</tt> in a Haskell type.
--   
--   We use <a>PredType</a> as documentation to mark those types that we
--   guarantee to have this kind.
--   
--   It can be expanded into its representation, but:
--   
--   <ul>
--   <li>The type checker must treat it as opaque</li>
--   <li>The rest of the compiler treats it as transparent</li>
--   </ul>
--   
--   Consider these examples:
--   
--   <pre>
--   f :: (Eq a) =&gt; a -&gt; Int
--   g :: (?x :: Int -&gt; Int) =&gt; a -&gt; Int
--   h :: (r\l) =&gt; {r} =&gt; {l::Int | r}
--   </pre>
--   
--   Here the <tt>Eq a</tt> and <tt>?x :: Int -&gt; Int</tt> and
--   <tt>rl</tt> are all called "predicates"
type PredType = Type

-- | A collection of <a>PredType</a>s
type ThetaType = [PredType]
pprForAll :: [ForAllTyBinder] -> SDoc
pprThetaArrowTy :: ThetaType -> SDoc
parseInstanceHead :: GhcMonad m => String -> m Type
getInstancesForType :: GhcMonad m => Type -> m [ClsInst]

-- | A global typecheckable-thing, essentially anything that has a name.
--   Not to be confused with a <tt>TcTyThing</tt>, which is also a
--   typecheckable thing but in the *local* context. See
--   <a>GHC.Tc.Utils.Env</a> for how to retrieve a <a>TyThing</a> given a
--   <a>Name</a>.
data TyThing
AnId :: Id -> TyThing
AConLike :: ConLike -> TyThing
ATyCon :: TyCon -> TyThing
ACoAxiom :: CoAxiom Branched -> TyThing
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection
defaultFixity :: Fixity
maxPrecedence :: Int
negateFixity :: Fixity
compareFixity :: Fixity -> Fixity -> (Bool, Bool)

-- | Captures the fixity of declarations as they are parsed. This is not
--   necessarily the same as the fixity declaration, as the normal fixity
--   may be overridden using parens or backticks.
data LexicalFixity
Prefix :: LexicalFixity
Infix :: LexicalFixity

-- | Source Location
data SrcLoc
RealSrcLoc :: !RealSrcLoc -> !Maybe BufPos -> SrcLoc
UnhelpfulLoc :: !FastString -> SrcLoc

-- | Real Source Location
--   
--   Represents a single point within a file
data RealSrcLoc
mkSrcLoc :: FastString -> Int -> Int -> SrcLoc

-- | Built-in "bad" <a>SrcLoc</a> values for particular locations
noSrcLoc :: SrcLoc

-- | Gives the filename of the <a>RealSrcLoc</a>
srcLocFile :: RealSrcLoc -> FastString

-- | Raises an error when used on a "bad" <a>SrcLoc</a>
srcLocLine :: RealSrcLoc -> Int

-- | Raises an error when used on a "bad" <a>SrcLoc</a>
srcLocCol :: RealSrcLoc -> Int

-- | Source Span
--   
--   A <a>SrcSpan</a> identifies either a specific portion of a text file
--   or a human-readable description of a location.
data SrcSpan
RealSrcSpan :: !RealSrcSpan -> !Maybe BufSpan -> SrcSpan
UnhelpfulSpan :: !UnhelpfulSpanReason -> SrcSpan

-- | A <a>RealSrcSpan</a> delimits a portion of a text file. It could be
--   represented by a pair of (line,column) coordinates, but in fact we
--   optimise slightly by using more compact representations for
--   single-line and zero-length spans, both of which are quite common.
--   
--   The end position is defined to be the column <i>after</i> the end of
--   the span. That is, a span of (1,1)-(1,2) is one character long, and a
--   span of (1,1)-(1,1) is zero characters long.
--   
--   Real Source Span
data RealSrcSpan

-- | Create a <a>SrcSpan</a> between two points in a file
mkSrcSpan :: SrcLoc -> SrcLoc -> SrcSpan

-- | Create a <a>SrcSpan</a> corresponding to a single point
srcLocSpan :: SrcLoc -> SrcSpan

-- | Test if a <a>SrcSpan</a> is "good", i.e. has precise location
--   information
isGoodSrcSpan :: SrcSpan -> Bool

-- | Built-in "bad" <a>SrcSpan</a>s for common sources of location
--   uncertainty
noSrcSpan :: SrcSpan

-- | Returns the location at the start of the <a>SrcSpan</a> or a "bad"
--   <a>SrcSpan</a> if that is unavailable
srcSpanStart :: SrcSpan -> SrcLoc

-- | Returns the location at the end of the <a>SrcSpan</a> or a "bad"
--   <a>SrcSpan</a> if that is unavailable
srcSpanEnd :: SrcSpan -> SrcLoc
srcSpanFile :: RealSrcSpan -> FastString
srcSpanStartLine :: RealSrcSpan -> Int
srcSpanEndLine :: RealSrcSpan -> Int
srcSpanStartCol :: RealSrcSpan -> Int
srcSpanEndCol :: RealSrcSpan -> Int

-- | We attach SrcSpans to lots of things, so let's have a datatype for it.
data GenLocated l e
L :: l -> e -> GenLocated l e
type Located = GenLocated SrcSpan
type RealLocated = GenLocated RealSrcSpan
noLoc :: e -> Located e
mkGeneralLocated :: String -> e -> Located e
getLoc :: GenLocated l e -> l
unLoc :: GenLocated l e -> e
getRealSrcSpan :: RealLocated a -> RealSrcSpan
unRealSrcSpan :: RealLocated a -> a

-- | Tests whether the two located things are equal
eqLocated :: Eq a => GenLocated l a -> GenLocated l a -> Bool

-- | Tests the ordering of the two located things
cmpLocated :: Ord a => GenLocated l a -> GenLocated l a -> Ordering
combineLocs :: Located a -> Located b -> SrcSpan

-- | Combine locations from two <a>Located</a> things and add them to a
--   third thing
addCLoc :: Located a -> Located b -> c -> Located c

-- | Strategies for ordering <a>SrcSpan</a>s
leftmost_smallest :: SrcSpan -> SrcSpan -> Ordering

-- | Strategies for ordering <a>SrcSpan</a>s
leftmost_largest :: SrcSpan -> SrcSpan -> Ordering

-- | Strategies for ordering <a>SrcSpan</a>s
rightmost_smallest :: SrcSpan -> SrcSpan -> Ordering

-- | Determines whether a span encloses a given line and column index
spans :: SrcSpan -> (Int, Int) -> Bool

-- | Determines whether a span is enclosed by another one
isSubspanOf :: SrcSpan -> SrcSpan -> Bool

-- | GHC's own exception type error messages all take the form:
--   
--   <pre>
--   &lt;location&gt;: &lt;error&gt;
--   
--   </pre>
--   
--   If the location is on the command line, or in GHC itself, then
--   &lt;location&gt;="ghc". All of the error types below correspond to a
--   &lt;location&gt; of "ghc", except for ProgramError (where the string
--   is assumed to contain a location already, so we don't print one).
data GhcException

-- | Some other fatal signal (SIGHUP,SIGTERM)
Signal :: Int -> GhcException

-- | Prints the short usage msg after the error
UsageError :: String -> GhcException

-- | A problem with the command line arguments, but don't print usage.
CmdLineError :: String -> GhcException

-- | The <tt>impossible</tt> happened.
Panic :: String -> GhcException
PprPanic :: String -> SDoc -> GhcException

-- | The user tickled something that's known not to work yet, but we're not
--   counting it as a bug.
Sorry :: String -> GhcException
PprSorry :: String -> SDoc -> GhcException

-- | An installation problem.
InstallationError :: String -> GhcException

-- | An error in the user's code, probably.
ProgramError :: String -> GhcException
PprProgramError :: String -> SDoc -> GhcException

-- | Append a description of the given exception to this string.
showGhcException :: SDocContext -> GhcException -> ShowS

-- | An error thrown if the GHC API is used in an incorrect fashion.
newtype GhcApiError
GhcApiError :: String -> GhcApiError
data Token

-- | Return module source as token stream, including comments.
--   
--   A <a>Module</a> can be turned into a <a>ModSummary</a> using
--   <a>getModSummary</a> if your session is fully initialised. Throws a
--   <a>SourceError</a> on parse error.
getTokenStream :: ModSummary -> IO [Located Token]

-- | Give even more information on the source than <a>getTokenStream</a>
--   This function allows reconstructing the source completely with
--   <a>showRichTokenStream</a>.
getRichTokenStream :: ModSummary -> IO [(Located Token, String)]

-- | Take a rich token stream such as produced from
--   <a>getRichTokenStream</a> and return source code almost identical to
--   the original code (except for insignificant whitespace.)
showRichTokenStream :: [(Located Token, String)] -> String

-- | Given a source location and a StringBuffer corresponding to this
--   location, return a rich token stream with the source associated to the
--   tokens.
addSourceToTokens :: RealSrcLoc -> StringBuffer -> [Located Token] -> [(Located Token, String)]

-- | A pure interface to the module parser.
parser :: String -> DynFlags -> FilePath -> (WarningMessages, Either ErrorMessages (Located (HsModule GhcPs)))
data EpaComment
EpaComment :: EpaCommentTok -> RealSrcSpan -> EpaComment
[ac_tok] :: EpaComment -> EpaCommentTok

-- | The location of the prior token, used in exact printing. The
--   <a>EpaComment</a> appears as an <a>LEpaComment</a> containing its
--   location. The difference between the end of the prior token and the
--   start of this location is used for the spacing when exact printing the
--   comment.
[ac_prior_tok] :: EpaComment -> RealSrcSpan
instance GHC.DesugaredMod GHC.DesugaredModule
instance GHC.Internal.Exception.Type.Exception GHC.GhcApiError
instance GHC.Utils.Outputable.Outputable GHC.CoreModule
instance GHC.ParsedMod GHC.DesugaredModule
instance GHC.ParsedMod GHC.ParsedModule
instance GHC.ParsedMod GHC.TypecheckedModule
instance GHC.Internal.Show.Show GHC.GhcApiError
instance GHC.TypecheckedMod GHC.DesugaredModule
instance GHC.TypecheckedMod GHC.TypecheckedModule

module GHC.Runtime.Debugger

-- | The :print &amp; friends commands
pprintClosureCommand :: GhcMonad m => Bool -> Bool -> String -> m ()
showTerm :: GhcMonad m => Term -> m SDoc
pprTypeAndContents :: GhcMonad m => Id -> m SDoc

module GHC.Driver.MakeFile
doMkDependHS :: GhcMonad m => [FilePath] -> m ()


-- | This is the driver for the 'ghc --backpack' mode, which is a
--   reimplementation of the "package manager" bits of Backpack directly in
--   GHC. The basic method of operation is to compile packages and then
--   directly insert them into GHC's in memory database.
--   
--   The compilation products of this mode aren't really suitable for
--   Cabal, because GHC makes up component IDs for the things it builds and
--   doesn't serialize out the database contents. But it's still handy for
--   constructing tests.
module GHC.Driver.Backpack

-- | Entry point to compile a Backpack file.
doBackpack :: [FilePath] -> Ghc ()
instance GHC.Classes.Eq GHC.Driver.Backpack.SessionType
instance GHC.Driver.Monad.GhcMonad GHC.Driver.Backpack.BkpM
instance GHC.Driver.DynFlags.HasDynFlags GHC.Driver.Backpack.BkpM
instance GHC.Utils.Logger.HasLogger GHC.Driver.Backpack.BkpM
