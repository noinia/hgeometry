<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span id="local-6989586621682615187"><span id="local-6989586621682615188"><span id="local-6989586621682615189"><span id="local-6989586621682615190"></span></span></span></span><span class="hs-pragma">{-# LANGUAGE CPP #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE ViewPatterns #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE ConstraintKinds #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE DeriveDataTypeable #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE FlexibleContexts #-}</span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# LANGUAGE FlexibleInstances #-}</span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE GADTs #-}</span><span>
</span><span id="line-8"></span><span class="hs-pragma">{-# LANGUAGE LambdaCase #-}</span><span>
</span><span id="line-9"></span><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><span id="line-10"></span><span class="hs-pragma">{-# LANGUAGE TypeApplications #-}</span><span>
</span><span id="line-11"></span><span class="hs-pragma">{-# LANGUAGE TypeFamilies #-}</span><span>
</span><span id="line-12"></span><span class="hs-pragma">{-# LANGUAGE DataKinds #-}</span><span>
</span><span id="line-13"></span><span class="hs-pragma">{-# LANGUAGE UndecidableInstances #-}</span><span> </span><span class="hs-comment">-- Wrinkle in Note [Trees That Grow]</span><span>
</span><span id="line-14"></span><span>                                      </span><span class="hs-comment">-- in module Language.Haskell.Syntax.Extension</span><span>
</span><span id="line-15"></span><span>
</span><span id="line-16"></span><span class="hs-pragma">{-# OPTIONS_GHC -Wno-orphans #-}</span><span> </span><span class="hs-comment">-- Outputable</span><span>
</span><span id="line-17"></span><span>
</span><span id="line-18"></span><span class="hs-comment">{-
(c) The University of Glasgow 2006
(c) The GRASP/AQUA Project, Glasgow University, 1992-1998

\section[PatSyntax]{Abstract Haskell syntax---patterns}
-}</span><span>
</span><span id="line-24"></span><span>
</span><span id="line-25"></span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html"><span class="hs-identifier">GHC.Hs.Pat</span></a></span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-26"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier">Pat</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier">LPat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-27"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#isInvisArgPat"><span class="hs-identifier">isInvisArgPat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#isVisArgPat"><span class="hs-identifier">isVisArgPat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-28"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#EpAnnSumPat"><span class="hs-identifier">EpAnnSumPat</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-29"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#ConPatTc"><span class="hs-identifier">ConPatTc</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-30"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConLikeP"><span class="hs-identifier">ConLikeP</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-31"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#HsPatExpansion"><span class="hs-identifier">HsPatExpansion</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-32"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#XXPatGhcTc"><span class="hs-identifier">XXPatGhcTc</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-33"></span><span>
</span><span id="line-34"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatDetails"><span class="hs-identifier">HsConPatDetails</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsConPatArgs"><span class="hs-identifier">hsConPatArgs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsConPatTyArgs"><span class="hs-identifier">hsConPatTyArgs</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-35"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatTyArg"><span class="hs-identifier">HsConPatTyArg</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-36"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecFields"><span class="hs-identifier">HsRecFields</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsFieldBind"><span class="hs-identifier">HsFieldBind</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LHsFieldBind"><span class="hs-identifier">LHsFieldBind</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-37"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecField"><span class="hs-identifier">HsRecField</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LHsRecField"><span class="hs-identifier">LHsRecField</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-38"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecUpdField"><span class="hs-identifier">HsRecUpdField</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LHsRecUpdField"><span class="hs-identifier">LHsRecUpdField</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-39"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#RecFieldsDotDot"><span class="hs-identifier">RecFieldsDotDot</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-40"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsRecFields"><span class="hs-identifier">hsRecFields</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsRecFieldSel"><span class="hs-identifier">hsRecFieldSel</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#hsRecFieldId"><span class="hs-identifier">hsRecFieldId</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsRecFieldsArgs"><span class="hs-identifier">hsRecFieldsArgs</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-41"></span><span>
</span><span id="line-42"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#mkPrefixConPat"><span class="hs-identifier">mkPrefixConPat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#mkCharLitPat"><span class="hs-identifier">mkCharLitPat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#mkNilPat"><span class="hs-identifier">mkNilPat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-43"></span><span>
</span><span id="line-44"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#isSimplePat"><span class="hs-identifier">isSimplePat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#isPatSyn"><span class="hs-identifier">isPatSyn</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-45"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPatBind"><span class="hs-identifier">looksLazyPatBind</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-46"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#isBangedLPat"><span class="hs-identifier">isBangedLPat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-47"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#gParPat"><span class="hs-identifier">gParPat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#patNeedsParens"><span class="hs-identifier">patNeedsParens</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#parenthesizePat"><span class="hs-identifier">parenthesizePat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-48"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#isIrrefutableHsPat"><span class="hs-identifier">isIrrefutableHsPat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-49"></span><span>
</span><span id="line-50"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#isBoringHsPat"><span class="hs-identifier">isBoringHsPat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-51"></span><span>
</span><span id="line-52"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#collectEvVarsPat"><span class="hs-identifier">collectEvVarsPat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#collectEvVarsPats"><span class="hs-identifier">collectEvVarsPats</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-53"></span><span>
</span><span id="line-54"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier">pprParendLPat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#pprConArgs"><span class="hs-identifier">pprConArgs</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-55"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#pprLPat"><span class="hs-identifier">pprLPat</span></a></span><span>
</span><span id="line-56"></span><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-57"></span><span>
</span><span id="line-58"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Prelude.html"><span class="hs-identifier">GHC.Prelude</span></a></span><span>
</span><span id="line-59"></span><span>
</span><span id="line-60"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html"><span class="hs-identifier">Language.Haskell.Syntax.Pat</span></a></span><span>
</span><span id="line-61"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html"><span class="hs-identifier">Language.Haskell.Syntax.Expr</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier">HsExpr</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-62"></span><span>
</span><span id="line-63"></span><span class="hs-keyword">import</span><span> </span><span class="hs-pragma">{-# SOURCE</span><span> </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="GHC.Hs.Expr.html"><span class="hs-identifier">GHC.Hs.Expr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Expr.html#pprLExpr"><span class="hs-identifier">pprLExpr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Expr.html#pprUntypedSplice"><span class="hs-identifier">pprUntypedSplice</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Expr.html#HsUntypedSpliceResult"><span class="hs-identifier">HsUntypedSpliceResult</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-64"></span><span>
</span><span id="line-65"></span><span class="hs-comment">-- friends:</span><span>
</span><span id="line-66"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Hs.Binds.html"><span class="hs-identifier">GHC.Hs.Binds</span></a></span><span>
</span><span id="line-67"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Hs.Lit.html"><span class="hs-identifier">GHC.Hs.Lit</span></a></span><span>
</span><span id="line-68"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html"><span class="hs-identifier">Language.Haskell.Syntax.Extension</span></a></span><span>
</span><span id="line-69"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html"><span class="hs-identifier">GHC.Parser.Annotation</span></a></span><span>
</span><span id="line-70"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html"><span class="hs-identifier">GHC.Hs.Extension</span></a></span><span>
</span><span id="line-71"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Hs.Type.html"><span class="hs-identifier">GHC.Hs.Type</span></a></span><span>
</span><span id="line-72"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html"><span class="hs-identifier">GHC.Tc.Types.Evidence</span></a></span><span>
</span><span id="line-73"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html"><span class="hs-identifier">GHC.Types.Basic</span></a></span><span>
</span><span id="line-74"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.SourceText.html"><span class="hs-identifier">GHC.Types.SourceText</span></a></span><span>
</span><span id="line-75"></span><span class="hs-comment">-- others:</span><span>
</span><span id="line-76"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.Ppr.html"><span class="hs-identifier">GHC.Core.Ppr</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="hs-comment">{- instance OutputableBndr TyVar -}</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-77"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Builtin.Types.html"><span class="hs-identifier">GHC.Builtin.Types</span></a></span><span>
</span><span id="line-78"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Var.html"><span class="hs-identifier">GHC.Types.Var</span></a></span><span>
</span><span id="line-79"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Name.Reader.html"><span class="hs-identifier">GHC.Types.Name.Reader</span></a></span><span>
</span><span id="line-80"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.ConLike.html"><span class="hs-identifier">GHC.Core.ConLike</span></a></span><span>
</span><span id="line-81"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.DataCon.html"><span class="hs-identifier">GHC.Core.DataCon</span></a></span><span>
</span><span id="line-82"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html"><span class="hs-identifier">GHC.Utils.Outputable</span></a></span><span>
</span><span id="line-83"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.Type.html"><span class="hs-identifier">GHC.Core.Type</span></a></span><span>
</span><span id="line-84"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html"><span class="hs-identifier">GHC.Types.SrcLoc</span></a></span><span>
</span><span id="line-85"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Data.Bag.html"><span class="hs-identifier">GHC.Data.Bag</span></a></span><span> </span><span class="hs-comment">-- collect ev vars from pats</span><span>
</span><span id="line-86"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Name.html"><span class="hs-identifier">GHC.Types.Name</span></a></span><span>
</span><span id="line-87"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.21.0.0-ae91/src/Data.Data.html"><span class="hs-identifier">Data.Data</span></a></span><span>
</span><span id="line-88"></span><span>
</span><span id="line-89"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="../../base-4.21.0.0-ae91/src/Data.List.NonEmpty.html"><span class="hs-identifier">Data.List.NonEmpty</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">NE</span></span><span>
</span><span id="line-90"></span><span>
</span><span id="line-91"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XWildPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XWildPat"><span class="hs-identifier hs-var">XWildPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-92"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XWildPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XWildPat"><span class="hs-identifier hs-var">XWildPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-93"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XWildPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XWildPat"><span class="hs-identifier hs-var">XWildPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-94"></span><span>
</span><span id="line-95"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XVarPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XVarPat"><span class="hs-identifier hs-var">XVarPat</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-96"></span><span>
</span><span id="line-97"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XLazyPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLazyPat"><span class="hs-identifier hs-var">XLazyPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpToken"><span class="hs-identifier hs-type">EpToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;~&quot;</span></span><span>
</span><span id="line-98"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XLazyPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLazyPat"><span class="hs-identifier hs-var">XLazyPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-99"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XLazyPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLazyPat"><span class="hs-identifier hs-var">XLazyPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-100"></span><span>
</span><span id="line-101"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XAsPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XAsPat"><span class="hs-identifier hs-var">XAsPat</span></a></span></span><span>   </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpToken"><span class="hs-identifier hs-type">EpToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;@&quot;</span></span><span>
</span><span id="line-102"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XAsPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XAsPat"><span class="hs-identifier hs-var">XAsPat</span></a></span></span><span>   </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-103"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XAsPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XAsPat"><span class="hs-identifier hs-var">XAsPat</span></a></span></span><span>   </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-104"></span><span>
</span><span id="line-105"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XParPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XParPat"><span class="hs-identifier hs-var">XParPat</span></a></span></span><span>  </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Parser.Annotation.html#EpToken"><span class="hs-identifier hs-type">EpToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;(&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpToken"><span class="hs-identifier hs-type">EpToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;)&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-106"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XParPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XParPat"><span class="hs-identifier hs-var">XParPat</span></a></span></span><span>  </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-107"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XParPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XParPat"><span class="hs-identifier hs-var">XParPat</span></a></span></span><span>  </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-108"></span><span>
</span><span id="line-109"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XBangPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XBangPat"><span class="hs-identifier hs-var">XBangPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpToken"><span class="hs-identifier hs-type">EpToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;!&quot;</span></span><span>
</span><span id="line-110"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XBangPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XBangPat"><span class="hs-identifier hs-var">XBangPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-111"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XBangPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XBangPat"><span class="hs-identifier hs-var">XBangPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-112"></span><span>
</span><span id="line-113"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XListPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XListPat"><span class="hs-identifier hs-var">XListPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#AnnList"><span class="hs-identifier hs-type">AnnList</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-114"></span><span>  </span><span class="hs-comment">-- After parsing, ListPat can refer to a built-in Haskell list pattern</span><span>
</span><span id="line-115"></span><span>  </span><span class="hs-comment">-- or an overloaded list pattern.</span><span>
</span><span id="line-116"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XListPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XListPat"><span class="hs-identifier hs-var">XListPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-117"></span><span>  </span><span class="hs-comment">-- Built-in list patterns only.</span><span>
</span><span id="line-118"></span><span>  </span><span class="hs-comment">-- After renaming, overloaded list patterns are expanded to view patterns.</span><span>
</span><span id="line-119"></span><span>  </span><span class="hs-comment">-- See Note [Desugaring overloaded list patterns]</span><span>
</span><span id="line-120"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XListPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XListPat"><span class="hs-identifier hs-var">XListPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-121"></span><span>  </span><span class="hs-comment">-- List element type, for use in hsPatType.</span><span>
</span><span id="line-122"></span><span>
</span><span id="line-123"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XTuplePat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTuplePat"><span class="hs-identifier hs-var">XTuplePat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Parser.Annotation.html#EpaLocation"><span class="hs-identifier hs-type">EpaLocation</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpaLocation"><span class="hs-identifier hs-type">EpaLocation</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-124"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XTuplePat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTuplePat"><span class="hs-identifier hs-var">XTuplePat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-125"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XTuplePat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTuplePat"><span class="hs-identifier hs-var">XTuplePat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-126"></span><span>
</span><span id="line-127"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XOrPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XOrPat"><span class="hs-identifier hs-var">XOrPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-128"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XOrPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XOrPat"><span class="hs-identifier hs-var">XOrPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-129"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XOrPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XOrPat"><span class="hs-identifier hs-var">XOrPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-130"></span><span>
</span><span id="line-131"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSumPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSumPat"><span class="hs-identifier hs-var">XSumPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#EpAnnSumPat"><span class="hs-identifier hs-type">EpAnnSumPat</span></a></span><span>
</span><span id="line-132"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSumPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSumPat"><span class="hs-identifier hs-var">XSumPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-133"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSumPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSumPat"><span class="hs-identifier hs-var">XSumPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-134"></span><span>
</span><span id="line-135"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XConPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XConPat"><span class="hs-identifier hs-var">XConPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Parser.Annotation.html#EpToken"><span class="hs-identifier hs-type">EpToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;{&quot;</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Parser.Annotation.html#EpToken"><span class="hs-identifier hs-type">EpToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;}&quot;</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-136"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XConPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XConPat"><span class="hs-identifier hs-var">XConPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-137"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XConPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XConPat"><span class="hs-identifier hs-var">XConPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#ConPatTc"><span class="hs-identifier hs-type">ConPatTc</span></a></span><span>
</span><span id="line-138"></span><span>
</span><span id="line-139"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XViewPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XViewPat"><span class="hs-identifier hs-var">XViewPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#TokRarrow"><span class="hs-identifier hs-type">TokRarrow</span></a></span><span>
</span><span id="line-140"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XViewPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XViewPat"><span class="hs-identifier hs-var">XViewPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier hs-type">HsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-141"></span><span>  </span><span class="hs-comment">-- The @HsExpr GhcRn@ gives an inverse to the view function.</span><span>
</span><span id="line-142"></span><span>  </span><span class="hs-comment">-- This is used for overloaded lists in particular.</span><span>
</span><span id="line-143"></span><span>  </span><span class="hs-comment">-- See Note [Invertible view patterns] in GHC.Tc.TyCl.PatSyn.</span><span>
</span><span id="line-144"></span><span>
</span><span id="line-145"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XViewPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XViewPat"><span class="hs-identifier hs-var">XViewPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-146"></span><span>  </span><span class="hs-comment">-- Overall type of the pattern</span><span>
</span><span id="line-147"></span><span>  </span><span class="hs-comment">-- (= the argument type of the view function), for hsPatType.</span><span>
</span><span id="line-148"></span><span>
</span><span id="line-149"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSplicePat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSplicePat"><span class="hs-identifier hs-var">XSplicePat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-150"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSplicePat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSplicePat"><span class="hs-identifier hs-var">XSplicePat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Hs.Expr.html#HsUntypedSpliceResult"><span class="hs-identifier hs-type">HsUntypedSpliceResult</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- See Note [Lifecycle of a splice] in GHC.Hs.Expr</span><span>
</span><span id="line-151"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSplicePat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSplicePat"><span class="hs-identifier hs-var">XSplicePat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#DataConCantHappen"><span class="hs-identifier hs-type">DataConCantHappen</span></a></span><span>
</span><span id="line-152"></span><span>
</span><span id="line-153"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XLitPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLitPat"><span class="hs-identifier hs-var">XLitPat</span></a></span></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-154"></span><span>
</span><span id="line-155"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XNPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNPat"><span class="hs-identifier hs-var">XNPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpToken"><span class="hs-identifier hs-type">EpToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;-&quot;</span></span><span>
</span><span id="line-156"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XNPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNPat"><span class="hs-identifier hs-var">XNPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpToken"><span class="hs-identifier hs-type">EpToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;-&quot;</span></span><span>
</span><span id="line-157"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XNPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNPat"><span class="hs-identifier hs-var">XNPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-158"></span><span>
</span><span id="line-159"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XNPlusKPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNPlusKPat"><span class="hs-identifier hs-var">XNPlusKPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpToken"><span class="hs-identifier hs-type">EpToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;+&quot;</span></span><span>
</span><span id="line-160"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XNPlusKPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNPlusKPat"><span class="hs-identifier hs-var">XNPlusKPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-161"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XNPlusKPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNPlusKPat"><span class="hs-identifier hs-var">XNPlusKPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-162"></span><span>
</span><span id="line-163"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSigPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSigPat"><span class="hs-identifier hs-var">XSigPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#TokDcolon"><span class="hs-identifier hs-type">TokDcolon</span></a></span><span>
</span><span id="line-164"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSigPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSigPat"><span class="hs-identifier hs-var">XSigPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-165"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSigPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSigPat"><span class="hs-identifier hs-var">XSigPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-166"></span><span>
</span><span id="line-167"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XEmbTyPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XEmbTyPat"><span class="hs-identifier hs-var">XEmbTyPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpToken"><span class="hs-identifier hs-type">EpToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;type&quot;</span></span><span>
</span><span id="line-168"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XEmbTyPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XEmbTyPat"><span class="hs-identifier hs-var">XEmbTyPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-169"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XEmbTyPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XEmbTyPat"><span class="hs-identifier hs-var">XEmbTyPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-170"></span><span>
</span><span id="line-171"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XXPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXPat"><span class="hs-identifier hs-var">XXPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#DataConCantHappen"><span class="hs-identifier hs-type">DataConCantHappen</span></a></span><span>
</span><span id="line-172"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XXPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXPat"><span class="hs-identifier hs-var">XXPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#HsPatExpansion"><span class="hs-identifier hs-type">HsPatExpansion</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-173"></span><span>  </span><span class="hs-comment">-- Original pattern and its desugaring/expansion.</span><span>
</span><span id="line-174"></span><span>  </span><span class="hs-comment">-- See Note [Rebindable syntax and XXExprGhcRn].</span><span>
</span><span id="line-175"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XXPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXPat"><span class="hs-identifier hs-var">XXPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#XXPatGhcTc"><span class="hs-identifier hs-type">XXPatGhcTc</span></a></span><span>
</span><span id="line-176"></span><span>  </span><span class="hs-comment">-- After typechecking, we add extra constructors: CoPat and XXExprGhcRn.</span><span>
</span><span id="line-177"></span><span>  </span><span class="hs-comment">-- XXExprGhcRn allows us to handle RebindableSyntax in pattern position:</span><span>
</span><span id="line-178"></span><span>  </span><span class="hs-comment">-- see &quot;XXExpr GhcTc&quot; for the counterpart in expressions.</span><span>
</span><span id="line-179"></span><span>
</span><span id="line-180"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="ConLikeP"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConLikeP"><span class="hs-identifier hs-var">ConLikeP</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span><span> </span><span class="hs-comment">-- IdP GhcPs</span><span>
</span><span id="line-181"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="ConLikeP"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConLikeP"><span class="hs-identifier hs-var">ConLikeP</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Types.Name.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>    </span><span class="hs-comment">-- IdP GhcRn</span><span>
</span><span id="line-182"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="ConLikeP"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConLikeP"><span class="hs-identifier hs-var">ConLikeP</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.ConLike.html#ConLike"><span class="hs-identifier hs-type">ConLike</span></a></span><span>
</span><span id="line-183"></span><span>
</span><span id="line-184"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XConPatTyArg"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XConPatTyArg"><span class="hs-identifier hs-var">XConPatTyArg</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpToken"><span class="hs-identifier hs-type">EpToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;@&quot;</span></span><span>
</span><span id="line-185"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XConPatTyArg"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XConPatTyArg"><span class="hs-identifier hs-var">XConPatTyArg</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-186"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XConPatTyArg"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XConPatTyArg"><span class="hs-identifier hs-var">XConPatTyArg</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-187"></span><span>
</span><span id="line-188"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XHsRecFields"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XHsRecFields"><span class="hs-identifier hs-var">XHsRecFields</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-189"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XHsRecFields"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XHsRecFields"><span class="hs-identifier hs-var">XHsRecFields</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-190"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XHsRecFields"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XHsRecFields"><span class="hs-identifier hs-var">XHsRecFields</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html#MultiplicityCheckCoercions"><span class="hs-identifier hs-type">MultiplicityCheckCoercions</span></a></span><span>
</span><span id="line-191"></span><span>
</span><span id="line-192"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XHsFieldBind"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XHsFieldBind"><span class="hs-identifier hs-var">XHsFieldBind</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Parser.Annotation.html#EpToken"><span class="hs-identifier hs-type">EpToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;=&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-193"></span><span>
</span><span id="line-194"></span><span class="hs-comment">-- The specificity of an invisible pattern from the parser is always</span><span>
</span><span id="line-195"></span><span class="hs-comment">-- SpecifiedSpec. The specificity field supports code generated when deriving</span><span>
</span><span id="line-196"></span><span class="hs-comment">-- newtype or via; see Note [Inferred invisible patterns].</span><span>
</span><span id="line-197"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XInvisPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XInvisPat"><span class="hs-identifier hs-var">XInvisPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Parser.Annotation.html#EpToken"><span class="hs-identifier hs-type">EpToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;@&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Specificity.html#Specificity"><span class="hs-identifier hs-type">Specificity</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-198"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XInvisPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XInvisPat"><span class="hs-identifier hs-var">XInvisPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Specificity.html#Specificity"><span class="hs-identifier hs-type">Specificity</span></a></span><span>
</span><span id="line-199"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XInvisPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XInvisPat"><span class="hs-identifier hs-var">XInvisPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-200"></span><span>
</span><span id="line-201"></span><span>
</span><span id="line-202"></span><span class="hs-comment">{- Note [Invisible binders in functions]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
GHC Proposal #448 (section 1.5 Type arguments in lambda patterns) introduces
binders for invisible type arguments (@a-binders) in function equations and
lambdas, e.g.

  1.  {-# LANGUAGE TypeAbstractions #-}
      id1 :: a -&gt; a
      id1 @t x = x :: t     -- @t-binder on the LHS of a function equation

  2.  {-# LANGUAGE TypeAbstractions #-}
      ex :: (Int8, Int16)
      ex = higherRank (\ @a x -&gt; maxBound @a - x )
                            -- @a-binder in a lambda pattern in an argument
                            -- to a higher-order function
      higherRank :: (forall a. (Num a, Bounded a) =&gt; a -&gt; a) -&gt; (Int8, Int16)
      higherRank f = (f 42, f 42)

In the AST, invisible patterns are represented as InvisPat constructor inside of Pat:
    data Pat p
      = ...
      | InvisPat (LHsType p)
      ...

Just like `BangPat`, the `Pat` data type allows `InvisPat` to appear in
nested positions. But this is often not allowed; e.g.

   f @a x = rhs    -- YES
   f (@a,x) = rhs  -- NO

   g = do { @a &lt;- e1; e2 }         -- NO
   h x = case x of { @a -&gt; rhs }   -- NO

Rather than excluding these things syntactically, we reject them in the renamer
(see `rn_pats_general`).  This actually gives a better error message than we
would get if they were rejected in the parser.

Each pattern is either visible (not prefixed with @) or invisible (prefixed with @):
    f :: forall a. forall b -&gt; forall c. Int -&gt; ...
    f @a b @c x  = ...

In this example, the arg-patterns are
    1. InvisPat @a     -- in the type sig: forall a.
    2. VarPat b        -- in the type sig: forall b -&gt;
    3. InvisPat @c     -- in the type sig: forall c.
    4. VarPat x        -- in the type sig: Int -&gt;

Invisible patterns are always type patterns, i.e. they are matched with
forall-bound type variables in the signature. Consequently, those variables (and
their binders) are erased during compilation, having no effect on program
execution at runtime.

Visible patterns, on the other hand, may be matched with ordinary function
arguments (Int -&gt;) as well as required type arguments (forall b -&gt;). This means
that a visible pattern may either be erased or retained, and we only find out in
the type checker, namely in tcMatchPats, where we match up all arg-patterns with
quantifiers from the type signature.

In other words, invisible patterns are always /erased/, while visible patterns
are sometimes /erased/ and sometimes /retained/.

The desugarer has no use for erased patterns, as the type checker generates
HsWrappers to bind the corresponding type variables. Erased patterns are simply
discarded inside tcMatchPats, where we know if visible pattern retained or erased.
-}</span><span>
</span><span id="line-267"></span><span>
</span><span id="line-268"></span><span class="hs-comment">-- ---------------------------------------------------------------------</span><span>
</span><span id="line-269"></span><span>
</span><span id="line-270"></span><span class="hs-comment">-- API Annotations types</span><span>
</span><span id="line-271"></span><span>
</span><span id="line-272"></span><span class="hs-keyword">data</span><span> </span><span id="EpAnnSumPat"><span class="annot"><a href="GHC.Hs.Pat.html#EpAnnSumPat"><span class="hs-identifier hs-var">EpAnnSumPat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="EpAnnSumPat"><span class="annot"><a href="GHC.Hs.Pat.html#EpAnnSumPat"><span class="hs-identifier hs-var">EpAnnSumPat</span></a></span></span><span>
</span><span id="line-273"></span><span>      </span><span class="hs-special">{</span><span> </span><span id="sumPatParens"><span class="annot"><span class="annottext">EpAnnSumPat -&gt; (EpaLocation, EpaLocation)
</span><a href="GHC.Hs.Pat.html#sumPatParens"><span class="hs-identifier hs-var hs-var">sumPatParens</span></a></span></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Parser.Annotation.html#EpaLocation"><span class="hs-identifier hs-type">EpaLocation</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpaLocation"><span class="hs-identifier hs-type">EpaLocation</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-274"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="sumPatVbarsBefore"><span class="annot"><span class="annottext">EpAnnSumPat -&gt; [EpToken &quot;|&quot;]
</span><a href="GHC.Hs.Pat.html#sumPatVbarsBefore"><span class="hs-identifier hs-var hs-var">sumPatVbarsBefore</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#EpToken"><span class="hs-identifier hs-type">EpToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;|&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-275"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="sumPatVbarsAfter"><span class="annot"><span class="annottext">EpAnnSumPat -&gt; [EpToken &quot;|&quot;]
</span><a href="GHC.Hs.Pat.html#sumPatVbarsAfter"><span class="hs-identifier hs-var hs-var">sumPatVbarsAfter</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#EpToken"><span class="hs-identifier hs-type">EpToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;|&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-276"></span><span>      </span><span class="hs-special">}</span><span> </span><span class="hs-keyword">deriving</span><span> </span><span id="local-6989586621682615248"><span id="local-6989586621682615258"><span id="local-6989586621682615266"><span id="local-6989586621682615268"><span id="local-6989586621682615270"><span id="local-6989586621682615276"><span id="local-6989586621682615281"><span id="local-6989586621682615284"><span id="local-6989586621682615287"><span id="local-6989586621682615290"><span id="local-6989586621682615293"><span id="local-6989586621682615296"><span id="local-6989586621682615301"><span id="local-6989586621682615306"><span class="annot"><span class="annottext">Typeable EpAnnSumPat
Typeable EpAnnSumPat =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; EpAnnSumPat -&gt; c EpAnnSumPat)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c EpAnnSumPat)
-&gt; (EpAnnSumPat -&gt; Constr)
-&gt; (EpAnnSumPat -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c EpAnnSumPat))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c EpAnnSumPat))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; EpAnnSumPat -&gt; EpAnnSumPat)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat)
-&gt; Data EpAnnSumPat
EpAnnSumPat -&gt; Constr
EpAnnSumPat -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; EpAnnSumPat -&gt; EpAnnSumPat
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c EpAnnSumPat
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; EpAnnSumPat -&gt; c EpAnnSumPat
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c EpAnnSumPat)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c EpAnnSumPat)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; EpAnnSumPat -&gt; c EpAnnSumPat
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; EpAnnSumPat -&gt; c EpAnnSumPat
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c EpAnnSumPat
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c EpAnnSumPat
$ctoConstr :: EpAnnSumPat -&gt; Constr
toConstr :: EpAnnSumPat -&gt; Constr
$cdataTypeOf :: EpAnnSumPat -&gt; DataType
dataTypeOf :: EpAnnSumPat -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c EpAnnSumPat)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c EpAnnSumPat)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c EpAnnSumPat)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c EpAnnSumPat)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; EpAnnSumPat -&gt; EpAnnSumPat
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; EpAnnSumPat -&gt; EpAnnSumPat
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-277"></span><span>
</span><span id="line-278"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#NoAnn"><span class="hs-identifier hs-type">NoAnn</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#EpAnnSumPat"><span class="hs-identifier hs-type">EpAnnSumPat</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-279"></span><span>  </span><span id="local-6989586621682615338"><span class="annot"><span class="annottext">noAnn :: EpAnnSumPat
</span><a href="#local-6989586621682615338"><span class="hs-identifier hs-var hs-var hs-var">noAnn</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(EpaLocation, EpaLocation)
-&gt; [EpToken &quot;|&quot;] -&gt; [EpToken &quot;|&quot;] -&gt; EpAnnSumPat
</span><a href="GHC.Hs.Pat.html#EpAnnSumPat"><span class="hs-identifier hs-var">EpAnnSumPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">EpaLocation
forall a. NoAnn a =&gt; a
</span><a href="GHC.Parser.Annotation.html#noAnn"><span class="hs-identifier hs-var">noAnn</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">EpaLocation
forall a. NoAnn a =&gt; a
</span><a href="GHC.Parser.Annotation.html#noAnn"><span class="hs-identifier hs-var">noAnn</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-280"></span><span>
</span><span id="line-281"></span><span class="hs-comment">-- ---------------------------------------------------------------------</span><span>
</span><span id="line-282"></span><span>
</span><span id="line-283"></span><span class="annot"><span class="hs-comment">-- | Extension constructor for Pat, added after typechecking.</span></span><span>
</span><span id="line-284"></span><span class="hs-keyword">data</span><span> </span><span id="XXPatGhcTc"><span class="annot"><a href="GHC.Hs.Pat.html#XXPatGhcTc"><span class="hs-identifier hs-var">XXPatGhcTc</span></a></span></span><span>
</span><span id="line-285"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- | Coercion Pattern (translation only)</span><span>
</span><span id="line-286"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-287"></span><span>    </span><span class="hs-comment">-- During desugaring a (CoPat co pat) turns into a cast with 'co' on the</span><span>
</span><span id="line-288"></span><span>    </span><span class="hs-comment">-- scrutinee, followed by a match on 'pat'.</span><span>
</span><span id="line-289"></span><span>    </span><span id="CoPat"><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier hs-var">CoPat</span></a></span></span><span>
</span><span id="line-290"></span><span>      </span><span class="hs-special">{</span><span> </span><span class="hs-comment">-- | Coercion Pattern</span><span>
</span><span id="line-291"></span><span>        </span><span class="hs-comment">-- If co :: t1 ~ t2, p :: t2,</span><span>
</span><span id="line-292"></span><span>        </span><span class="hs-comment">-- then (CoPat co p) :: t1</span><span>
</span><span id="line-293"></span><span>        </span><span id="co_cpt_wrap"><span class="annot"><span class="annottext">XXPatGhcTc -&gt; HsWrapper
</span><a href="GHC.Hs.Pat.html#co_cpt_wrap"><span class="hs-identifier hs-var hs-var">co_cpt_wrap</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html#HsWrapper"><span class="hs-identifier hs-type">HsWrapper</span></a></span><span>
</span><span id="line-294"></span><span>
</span><span id="line-295"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-comment">-- | Why not LPat?  Ans: existing locn will do</span></span><span>
</span><span id="line-296"></span><span>        </span><span id="co_pat_inner"><span class="annot"><span class="annottext">XXPatGhcTc -&gt; Pat GhcTc
</span><a href="GHC.Hs.Pat.html#co_pat_inner"><span class="hs-identifier hs-var hs-var">co_pat_inner</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span>
</span><span id="line-297"></span><span>
</span><span id="line-298"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-comment">-- | Type of whole pattern, t1</span></span><span>
</span><span id="line-299"></span><span>        </span><span id="co_pat_ty"><span class="annot"><span class="annottext">XXPatGhcTc -&gt; Type
</span><a href="GHC.Hs.Pat.html#co_pat_ty"><span class="hs-identifier hs-var hs-var">co_pat_ty</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-300"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-301"></span><span>  </span><span class="hs-comment">-- | Pattern expansion: original pattern, and desugared pattern,</span><span>
</span><span id="line-302"></span><span>  </span><span class="hs-comment">-- for RebindableSyntax and other overloaded syntax such as OverloadedLists.</span><span>
</span><span id="line-303"></span><span>  </span><span class="hs-comment">-- See Note [Rebindable syntax and XXExprGhcRn].</span><span>
</span><span id="line-304"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ExpansionPat"><span class="annot"><a href="GHC.Hs.Pat.html#ExpansionPat"><span class="hs-identifier hs-var">ExpansionPat</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-305"></span><span>
</span><span id="line-306"></span><span>
</span><span id="line-307"></span><span class="hs-comment">-- See Note [Rebindable syntax and XXExprGhcRn].</span><span>
</span><span id="line-308"></span><span class="hs-keyword">data</span><span> </span><span id="HsPatExpansion"><span class="annot"><a href="GHC.Hs.Pat.html#HsPatExpansion"><span class="hs-identifier hs-var">HsPatExpansion</span></a></span></span><span> </span><span id="local-6989586621682615345"><span class="annot"><a href="#local-6989586621682615345"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621682615346"><span class="annot"><a href="#local-6989586621682615346"><span class="hs-identifier hs-type">b</span></a></span></span><span>
</span><span id="line-309"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsPatExpanded"><span class="annot"><a href="GHC.Hs.Pat.html#HsPatExpanded"><span class="hs-identifier hs-var">HsPatExpanded</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621682615345"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615346"><span class="hs-identifier hs-type">b</span></a></span><span>
</span><span id="line-310"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span id="local-6989586621682615355"><span id="local-6989586621682615359"><span id="local-6989586621682615363"><span id="local-6989586621682615365"><span id="local-6989586621682615367"><span id="local-6989586621682615373"><span id="local-6989586621682615380"><span id="local-6989586621682615383"><span id="local-6989586621682615386"><span id="local-6989586621682615389"><span id="local-6989586621682615392"><span id="local-6989586621682615395"><span id="local-6989586621682615400"><span id="local-6989586621682615405"><span class="annot"><span class="annottext">Typeable (HsPatExpansion a b)
Typeable (HsPatExpansion a b) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g)
 -&gt; HsPatExpansion a b
 -&gt; c (HsPatExpansion a b))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (HsPatExpansion a b))
-&gt; (HsPatExpansion a b -&gt; Constr)
-&gt; (HsPatExpansion a b -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (HsPatExpansion a b)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (HsPatExpansion a b)))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; HsPatExpansion a b -&gt; HsPatExpansion a b)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsPatExpansion a b -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsPatExpansion a b -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; HsPatExpansion a b -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsPatExpansion a b -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b))
-&gt; Data (HsPatExpansion a b)
HsPatExpansion a b -&gt; Constr
HsPatExpansion a b -&gt; DataType
(forall b. Data b =&gt; b -&gt; b)
-&gt; HsPatExpansion a b -&gt; HsPatExpansion a b
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsPatExpansion a b -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; HsPatExpansion a b -&gt; [u]
forall a b. (Data a, Data b) =&gt; Typeable (HsPatExpansion a b)
forall a b. (Data a, Data b) =&gt; HsPatExpansion a b -&gt; Constr
forall a b. (Data a, Data b) =&gt; HsPatExpansion a b -&gt; DataType
forall a b.
(Data a, Data b) =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; HsPatExpansion a b -&gt; HsPatExpansion a b
forall a b u.
(Data a, Data b) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsPatExpansion a b -&gt; u
forall a b u.
(Data a, Data b) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; HsPatExpansion a b -&gt; [u]
forall a b r r'.
(Data a, Data b) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsPatExpansion a b -&gt; r
forall a b r r'.
(Data a, Data b) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsPatExpansion a b -&gt; r
forall a b (m :: * -&gt; *).
(Data a, Data b, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b)
forall a b (m :: * -&gt; *).
(Data a, Data b, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b)
forall a b (c :: * -&gt; *).
(Data a, Data b) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (HsPatExpansion a b)
forall a b (c :: * -&gt; *).
(Data a, Data b) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; HsPatExpansion a b
-&gt; c (HsPatExpansion a b)
forall a b (t :: * -&gt; *) (c :: * -&gt; *).
(Data a, Data b, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (HsPatExpansion a b))
forall a b (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data a, Data b, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (HsPatExpansion a b))
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsPatExpansion a b -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsPatExpansion a b -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (HsPatExpansion a b)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; HsPatExpansion a b
-&gt; c (HsPatExpansion a b)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (HsPatExpansion a b))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (HsPatExpansion a b))
$cgfoldl :: forall a b (c :: * -&gt; *).
(Data a, Data b) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; HsPatExpansion a b
-&gt; c (HsPatExpansion a b)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; HsPatExpansion a b
-&gt; c (HsPatExpansion a b)
$cgunfold :: forall a b (c :: * -&gt; *).
(Data a, Data b) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (HsPatExpansion a b)
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (HsPatExpansion a b)
$ctoConstr :: forall a b. (Data a, Data b) =&gt; HsPatExpansion a b -&gt; Constr
toConstr :: HsPatExpansion a b -&gt; Constr
$cdataTypeOf :: forall a b. (Data a, Data b) =&gt; HsPatExpansion a b -&gt; DataType
dataTypeOf :: HsPatExpansion a b -&gt; DataType
$cdataCast1 :: forall a b (t :: * -&gt; *) (c :: * -&gt; *).
(Data a, Data b, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (HsPatExpansion a b))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (HsPatExpansion a b))
$cdataCast2 :: forall a b (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data a, Data b, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (HsPatExpansion a b))
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (HsPatExpansion a b))
$cgmapT :: forall a b.
(Data a, Data b) =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; HsPatExpansion a b -&gt; HsPatExpansion a b
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; HsPatExpansion a b -&gt; HsPatExpansion a b
$cgmapQl :: forall a b r r'.
(Data a, Data b) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsPatExpansion a b -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsPatExpansion a b -&gt; r
$cgmapQr :: forall a b r r'.
(Data a, Data b) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsPatExpansion a b -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsPatExpansion a b -&gt; r
$cgmapQ :: forall a b u.
(Data a, Data b) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; HsPatExpansion a b -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; HsPatExpansion a b -&gt; [u]
$cgmapQi :: forall a b u.
(Data a, Data b) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsPatExpansion a b -&gt; u
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsPatExpansion a b -&gt; u
$cgmapM :: forall a b (m :: * -&gt; *).
(Data a, Data b, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b)
$cgmapMp :: forall a b (m :: * -&gt; *).
(Data a, Data b, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b)
$cgmapMo :: forall a b (m :: * -&gt; *).
(Data a, Data b, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-311"></span><span>
</span><span id="line-312"></span><span class="hs-comment">-- | This is the extension field for ConPat, added after typechecking</span><span>
</span><span id="line-313"></span><span class="hs-comment">-- It adds quite a few extra fields, to support elaboration of pattern matching.</span><span>
</span><span id="line-314"></span><span class="hs-keyword">data</span><span> </span><span id="ConPatTc"><span class="annot"><a href="GHC.Hs.Pat.html#ConPatTc"><span class="hs-identifier hs-var">ConPatTc</span></a></span></span><span>
</span><span id="line-315"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ConPatTc"><span class="annot"><a href="GHC.Hs.Pat.html#ConPatTc"><span class="hs-identifier hs-var">ConPatTc</span></a></span></span><span>
</span><span id="line-316"></span><span>    </span><span class="hs-special">{</span><span> </span><span class="hs-comment">-- | The universal arg types  1-1 with the universal</span><span>
</span><span id="line-317"></span><span>      </span><span class="hs-comment">-- tyvars of the constructor/pattern synonym</span><span>
</span><span id="line-318"></span><span>      </span><span class="hs-comment">-- Use (conLikeResTy pat_con cpt_arg_tys) to get</span><span>
</span><span id="line-319"></span><span>      </span><span class="hs-comment">-- the type of the pattern</span><span>
</span><span id="line-320"></span><span>      </span><span id="cpt_arg_tys"><span class="annot"><span class="annottext">ConPatTc -&gt; [Type]
</span><a href="GHC.Hs.Pat.html#cpt_arg_tys"><span class="hs-identifier hs-var hs-var">cpt_arg_tys</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-321"></span><span>
</span><span id="line-322"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- | Existentially bound type variables</span><span>
</span><span id="line-323"></span><span>      </span><span class="hs-comment">-- in correctly-scoped order e.g. [k:*  x:k]</span><span>
</span><span id="line-324"></span><span>      </span><span id="cpt_tvs"><span class="annot"><span class="annottext">ConPatTc -&gt; [TyVar]
</span><a href="GHC.Hs.Pat.html#cpt_tvs"><span class="hs-identifier hs-var hs-var">cpt_tvs</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Var.html#TyVar"><span class="hs-identifier hs-type">TyVar</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-325"></span><span>
</span><span id="line-326"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- | Ditto *coercion variables* and *dictionaries*</span><span>
</span><span id="line-327"></span><span>      </span><span class="hs-comment">-- One reason for putting coercion variable here  I think</span><span>
</span><span id="line-328"></span><span>      </span><span class="hs-comment">--      is to ensure their kinds are zonked</span><span>
</span><span id="line-329"></span><span>      </span><span id="cpt_dicts"><span class="annot"><span class="annottext">ConPatTc -&gt; [TyVar]
</span><a href="GHC.Hs.Pat.html#cpt_dicts"><span class="hs-identifier hs-var hs-var">cpt_dicts</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Var.html#EvVar"><span class="hs-identifier hs-type">EvVar</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-330"></span><span>
</span><span id="line-331"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-comment">-- | Bindings involving those dictionaries</span></span><span>
</span><span id="line-332"></span><span>      </span><span id="cpt_binds"><span class="annot"><span class="annottext">ConPatTc -&gt; TcEvBinds
</span><a href="GHC.Hs.Pat.html#cpt_binds"><span class="hs-identifier hs-var hs-var">cpt_binds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html#TcEvBinds"><span class="hs-identifier hs-type">TcEvBinds</span></a></span><span>
</span><span id="line-333"></span><span>
</span><span id="line-334"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- | Extra wrapper to pass to the matcher</span><span>
</span><span id="line-335"></span><span>      </span><span class="hs-comment">-- Only relevant for pattern-synonyms;</span><span>
</span><span id="line-336"></span><span>      </span><span class="hs-comment">--   ignored for data cons</span><span>
</span><span id="line-337"></span><span>      </span><span id="cpt_wrap"><span class="annot"><span class="annottext">ConPatTc -&gt; HsWrapper
</span><a href="GHC.Hs.Pat.html#cpt_wrap"><span class="hs-identifier hs-var hs-var">cpt_wrap</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html#HsWrapper"><span class="hs-identifier hs-type">HsWrapper</span></a></span><span>
</span><span id="line-338"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-339"></span><span>
</span><span id="line-340"></span><span id="local-6989586621682614942"><span class="annot"><a href="GHC.Hs.Pat.html#hsRecFieldId"><span class="hs-identifier hs-type">hsRecFieldId</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecField"><span class="hs-identifier hs-type">HsRecField</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682614942"><span class="hs-identifier hs-type">arg</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Types.Var.html#Id"><span class="hs-identifier hs-type">Id</span></a></span></span><span>
</span><span id="line-341"></span><span id="hsRecFieldId"><span class="annot"><span class="annottext">hsRecFieldId :: forall arg. HsRecField GhcTc arg -&gt; TyVar
</span><a href="GHC.Hs.Pat.html#hsRecFieldId"><span class="hs-identifier hs-var hs-var">hsRecFieldId</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsRecField GhcTc arg -&gt; IdP GhcTc
HsRecField GhcTc arg -&gt; TyVar
forall p arg. UnXRec p =&gt; HsRecField p arg -&gt; IdP p
</span><a href="Language.Haskell.Syntax.Pat.html#hsRecFieldSel"><span class="hs-identifier hs-var">hsRecFieldSel</span></a></span><span>
</span><span id="line-342"></span><span>
</span><span id="line-343"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
*              Printing patterns
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-350"></span><span>
</span><span id="line-351"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621682614954"><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsTyPat"><span class="hs-identifier hs-type">HsTyPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682614954"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatTyArg"><span class="hs-identifier hs-type">HsConPatTyArg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682614954"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-352"></span><span>  </span><span id="local-6989586621682615430"><span class="annot"><span class="annottext">ppr :: HsConPatTyArg p -&gt; SDoc
</span><a href="#local-6989586621682615430"><span class="hs-identifier hs-var hs-var hs-var">ppr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatTyArg"><span class="hs-identifier hs-type">HsConPatTyArg</span></a></span><span> </span><span class="annot"><span class="annottext">XConPatTyArg p
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615433"><span class="annot"><span class="annottext">HsTyPat p
</span><a href="#local-6989586621682615433"><span class="hs-identifier hs-var">ty</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
forall doc. IsLine doc =&gt; Char -&gt; doc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'@'</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%3E"><span class="hs-operator hs-var">&lt;&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">HsTyPat p -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">HsTyPat p
</span><a href="#local-6989586621682615433"><span class="hs-identifier hs-var">ty</span></a></span><span>
</span><span id="line-353"></span><span>
</span><span id="line-354"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621682614964"><span id="local-6989586621682614965"><span class="hs-special">(</span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682614964"><span class="hs-identifier hs-type">arg</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682614965"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecField"><span class="hs-identifier hs-type">HsRecField</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682614965"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682614964"><span class="hs-identifier hs-type">arg</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682614965"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#RecFieldsDotDot"><span class="hs-identifier hs-type">RecFieldsDotDot</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">~</span></span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#LocatedE"><span class="hs-identifier hs-type">LocatedE</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#RecFieldsDotDot"><span class="hs-identifier hs-type">RecFieldsDotDot</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-355"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecFields"><span class="hs-identifier hs-type">HsRecFields</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682614965"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682614964"><span class="hs-identifier hs-type">arg</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-356"></span><span>  </span><span id="local-6989586621682615458"><span class="annot"><span class="annottext">ppr :: HsRecFields p arg -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var hs-var hs-var">ppr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecFields"><span class="hs-identifier hs-type">HsRecFields</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">rec_flds :: forall p arg. HsRecFields p arg -&gt; [LHsRecField p arg]
</span><a href="Language.Haskell.Syntax.Pat.html#rec_flds"><span class="hs-identifier hs-var">rec_flds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621682615461"><span class="annot"><span class="annottext">[XRec p (HsRecField p arg)]
</span><a href="#local-6989586621682615461"><span class="hs-identifier hs-var">flds</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">rec_dotdot :: forall p arg. HsRecFields p arg -&gt; Maybe (XRec p RecFieldsDotDot)
</span><a href="Language.Haskell.Syntax.Pat.html#rec_dotdot"><span class="hs-identifier hs-var">rec_dotdot</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (XRec p RecFieldsDotDot)
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-357"></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#braces"><span class="hs-identifier hs-var">braces</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#fsep"><span class="hs-identifier hs-var">fsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SDoc -&gt; [SDoc] -&gt; [SDoc]
forall doc. IsLine doc =&gt; doc -&gt; [doc] -&gt; [doc]
</span><a href="GHC.Utils.Outputable.html#punctuate"><span class="hs-identifier hs-var">punctuate</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc
forall doc. IsLine doc =&gt; doc
</span><a href="GHC.Utils.Outputable.html#comma"><span class="hs-identifier hs-var">comma</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(XRec p (HsRecField p arg) -&gt; SDoc)
-&gt; [XRec p (HsRecField p arg)] -&gt; [SDoc]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">XRec p (HsRecField p arg) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">[XRec p (HsRecField p arg)]
</span><a href="#local-6989586621682615461"><span class="hs-identifier hs-var">flds</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-358"></span><span>  </span><span class="annot"><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecFields"><span class="hs-identifier hs-type">HsRecFields</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">rec_flds :: forall p arg. HsRecFields p arg -&gt; [LHsRecField p arg]
</span><a href="Language.Haskell.Syntax.Pat.html#rec_flds"><span class="hs-identifier hs-var">rec_flds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621682615467"><span class="annot"><span class="annottext">[XRec p (HsRecField p arg)]
</span><a href="#local-6989586621682615467"><span class="hs-identifier hs-var">flds</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">rec_dotdot :: forall p arg. HsRecFields p arg -&gt; Maybe (XRec p RecFieldsDotDot)
</span><a href="Language.Haskell.Syntax.Pat.html#rec_dotdot"><span class="hs-identifier hs-var">rec_dotdot</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">XRec p RecFieldsDotDot -&gt; RecFieldsDotDot
LocatedE RecFieldsDotDot -&gt; RecFieldsDotDot
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#RecFieldsDotDot"><span class="hs-identifier hs-type">RecFieldsDotDot</span></a></span><span> </span><span id="local-6989586621682615470"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621682615470"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-359"></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#braces"><span class="hs-identifier hs-var">braces</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#fsep"><span class="hs-identifier hs-var">fsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SDoc -&gt; [SDoc] -&gt; [SDoc]
forall doc. IsLine doc =&gt; doc -&gt; [doc] -&gt; [doc]
</span><a href="GHC.Utils.Outputable.html#punctuate"><span class="hs-identifier hs-var">punctuate</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc
forall doc. IsLine doc =&gt; doc
</span><a href="GHC.Utils.Outputable.html#comma"><span class="hs-identifier hs-var">comma</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(XRec p (HsRecField p arg) -&gt; SDoc)
-&gt; [XRec p (HsRecField p arg)] -&gt; [SDoc]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">XRec p (HsRecField p arg) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; [XRec p (HsRecField p arg)] -&gt; [XRec p (HsRecField p arg)]
forall a. Int -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">take</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621682615470"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">[XRec p (HsRecField p arg)]
</span><a href="#local-6989586621682615467"><span class="hs-identifier hs-var">flds</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; [SDoc] -&gt; [SDoc]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">SDoc
</span><a href="#local-6989586621682615472"><span class="hs-identifier hs-var">dotdot</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-360"></span><span>        </span><span class="hs-keyword">where</span><span>
</span><span id="line-361"></span><span>          </span><span id="local-6989586621682615472"><span class="annot"><span class="annottext">dotdot :: SDoc
</span><a href="#local-6989586621682615472"><span class="hs-identifier hs-var hs-var">dotdot</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
forall doc. IsLine doc =&gt; String -&gt; doc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;..&quot;</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
forall doc. IsOutput doc =&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#whenPprDebug"><span class="hs-identifier hs-var">whenPprDebug</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[XRec p (HsRecField p arg)] -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; [XRec p (HsRecField p arg)] -&gt; [XRec p (HsRecField p arg)]
forall a. Int -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">drop</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621682615470"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">[XRec p (HsRecField p arg)]
</span><a href="#local-6989586621682615467"><span class="hs-identifier hs-var">flds</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-362"></span><span>
</span><span id="line-363"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621682614989"><span id="local-6989586621682614990"><span class="hs-special">(</span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682614989"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#OutputableBndr"><span class="hs-identifier hs-type">OutputableBndr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682614989"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682614990"><span class="hs-identifier hs-type">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-364"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsFieldBind"><span class="hs-identifier hs-type">HsFieldBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682614989"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682614990"><span class="hs-identifier hs-type">arg</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-365"></span><span>  </span><span id="local-6989586621682615488"><span class="annot"><span class="annottext">ppr :: HsFieldBind p arg -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var hs-var hs-var">ppr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsFieldBind"><span class="hs-identifier hs-type">HsFieldBind</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">hfbLHS :: forall lhs rhs. HsFieldBind lhs rhs -&gt; lhs
</span><a href="Language.Haskell.Syntax.Pat.html#hfbLHS"><span class="hs-identifier hs-var">hfbLHS</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621682615491"><span class="annot"><span class="annottext">p
</span><a href="#local-6989586621682615491"><span class="hs-identifier hs-var">f</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">hfbRHS :: forall lhs rhs. HsFieldBind lhs rhs -&gt; rhs
</span><a href="Language.Haskell.Syntax.Pat.html#hfbRHS"><span class="hs-identifier hs-var">hfbRHS</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621682615493"><span class="annot"><span class="annottext">arg
</span><a href="#local-6989586621682615493"><span class="hs-identifier hs-var">arg</span></a></span></span><span class="hs-special">,</span><span>
</span><span id="line-366"></span><span>                     </span><span class="annot"><span class="annottext">hfbPun :: forall lhs rhs. HsFieldBind lhs rhs -&gt; Bool
</span><a href="Language.Haskell.Syntax.Pat.html#hfbPun"><span class="hs-identifier hs-var">hfbPun</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621682615495"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682615495"><span class="hs-identifier hs-var">pun</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-367"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">p -&gt; SDoc
forall a. OutputableBndr a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprPrefixOcc"><span class="hs-identifier hs-var">pprPrefixOcc</span></a></span><span> </span><span class="annot"><span class="annottext">p
</span><a href="#local-6989586621682615491"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; SDoc -&gt; SDoc
forall doc. IsOutput doc =&gt; Bool -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#ppUnless"><span class="hs-identifier hs-var">ppUnless</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682615495"><span class="hs-identifier hs-var">pun</span></a></span><span> </span><span class="annot"><span class="annottext">(SDoc -&gt; SDoc) -&gt; SDoc -&gt; SDoc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">SDoc
forall doc. IsLine doc =&gt; doc
</span><a href="GHC.Utils.Outputable.html#equals"><span class="hs-identifier hs-var">equals</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">arg -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">arg
</span><a href="#local-6989586621682615493"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-368"></span><span>
</span><span id="line-369"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621682615005"><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615005"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615005"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-370"></span><span>    </span><span id="local-6989586621682615503"><span class="annot"><span class="annottext">ppr :: Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var hs-var hs-var">ppr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; SDoc
forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span>
</span><span id="line-371"></span><span>
</span><span id="line-372"></span><span class="hs-comment">-- See Note [Rebindable syntax and XXExprGhcRn].</span><span>
</span><span id="line-373"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621682615008"><span id="local-6989586621682615009"><span class="hs-special">(</span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615008"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615009"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Pat.html#HsPatExpansion"><span class="hs-identifier hs-type">HsPatExpansion</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615008"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615009"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-374"></span><span>  </span><span id="local-6989586621682615515"><span class="annot"><span class="annottext">ppr :: HsPatExpansion a b -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var hs-var hs-var">ppr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Pat.html#HsPatExpanded"><span class="hs-identifier hs-type">HsPatExpanded</span></a></span><span> </span><span id="local-6989586621682615516"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621682615516"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621682615517"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621682615517"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsOutput doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#ifPprDebug"><span class="hs-identifier hs-var">ifPprDebug</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsDoc doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#vcat"><span class="hs-identifier hs-var">vcat</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">a -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621682615516"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621682615517"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621682615516"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-375"></span><span>
</span><span id="line-376"></span><span id="local-6989586621682615013"><span class="annot"><a href="GHC.Hs.Pat.html#pprLPat"><span class="hs-identifier hs-type">pprLPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615013"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615013"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span></span><span>
</span><span id="line-377"></span><span id="pprLPat"><span class="annot"><span class="annottext">pprLPat :: forall (p :: Pass). OutputableBndrId p =&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprLPat"><span class="hs-identifier hs-var hs-var">pprLPat</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-type">L</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpanAnnA
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615523"><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621682615523"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; SDoc
forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621682615523"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-378"></span><span>
</span><span id="line-379"></span><span class="annot"><span class="hs-comment">-- | Print with type info if -dppr-debug is on</span></span><span>
</span><span id="line-380"></span><span id="local-6989586621682615524"><span class="annot"><a href="GHC.Hs.Pat.html#pprPatBndr"><span class="hs-identifier hs-type">pprPatBndr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#OutputableBndr"><span class="hs-identifier hs-type">OutputableBndr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615524"><span class="hs-identifier hs-type">name</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682615524"><span class="hs-identifier hs-type">name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span></span><span>
</span><span id="line-381"></span><span id="pprPatBndr"><span class="annot"><span class="annottext">pprPatBndr :: forall a. OutputableBndr a =&gt; a -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPatBndr"><span class="hs-identifier hs-var hs-var">pprPatBndr</span></a></span></span><span> </span><span id="local-6989586621682615531"><span class="annot"><span class="annottext">name
</span><a href="#local-6989586621682615531"><span class="hs-identifier hs-var">var</span></a></span></span><span>
</span><span id="line-382"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; SDoc) -&gt; SDoc
forall doc. IsOutput doc =&gt; (Bool -&gt; doc) -&gt; doc
</span><a href="GHC.Utils.Outputable.html#getPprDebug"><span class="hs-identifier hs-var">getPprDebug</span></a></span><span> </span><span class="annot"><span class="annottext">((Bool -&gt; SDoc) -&gt; SDoc) -&gt; (Bool -&gt; SDoc) -&gt; SDoc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-383"></span><span>      </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">BindingSite -&gt; name -&gt; SDoc
forall a. OutputableBndr a =&gt; BindingSite -&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprBndr"><span class="hs-identifier hs-var">pprBndr</span></a></span><span> </span><span class="annot"><span class="annottext">BindingSite
</span><a href="GHC.Utils.Outputable.html#LambdaBind"><span class="hs-identifier hs-var">LambdaBind</span></a></span><span> </span><span class="annot"><span class="annottext">name
</span><a href="#local-6989586621682615531"><span class="hs-identifier hs-var">var</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- Could pass the site to pprPat</span><span>
</span><span id="line-384"></span><span>                                              </span><span class="hs-comment">-- but is it worth it?</span><span>
</span><span id="line-385"></span><span>      </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">name -&gt; SDoc
forall a. OutputableBndr a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprPrefixOcc"><span class="hs-identifier hs-var">pprPrefixOcc</span></a></span><span> </span><span class="annot"><span class="annottext">name
</span><a href="#local-6989586621682615531"><span class="hs-identifier hs-var">var</span></a></span><span>
</span><span id="line-386"></span><span>
</span><span id="line-387"></span><span id="local-6989586621682615019"><span class="annot"><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-type">pprParendLPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615019"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-388"></span><span>              </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#PprPrec"><span class="hs-identifier hs-type">PprPrec</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615019"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span></span><span>
</span><span id="line-389"></span><span id="pprParendLPat"><span class="annot"><span class="annottext">pprParendLPat :: forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var hs-var">pprParendLPat</span></a></span></span><span> </span><span id="local-6989586621682615538"><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621682615538"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; Pat (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendPat"><span class="hs-identifier hs-var">pprParendPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621682615538"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">(Pat (GhcPass p) -&gt; SDoc)
-&gt; (GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Pat (GhcPass p))
-&gt; GenLocated SrcSpanAnnA (Pat (GhcPass p))
-&gt; SDoc
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Pat (GhcPass p)
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span>
</span><span id="line-390"></span><span>
</span><span id="line-391"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprParendPat"><span class="hs-identifier hs-type">pprParendPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621682615022"><span class="annot"><a href="#local-6989586621682615022"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615022"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-392"></span><span>             </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#PprPrec"><span class="hs-identifier hs-type">PprPrec</span></a></span><span>
</span><span id="line-393"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615022"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-394"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span><span>
</span><span id="line-395"></span><span id="pprParendPat"><span class="annot"><span class="annottext">pprParendPat :: forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendPat"><span class="hs-identifier hs-var hs-var">pprParendPat</span></a></span></span><span> </span><span id="local-6989586621682615548"><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621682615548"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621682615549"><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621682615549"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(SDocContext -&gt; Bool) -&gt; (Bool -&gt; SDoc) -&gt; SDoc
forall a. (SDocContext -&gt; a) -&gt; (a -&gt; SDoc) -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#sdocOption"><span class="hs-identifier hs-var">sdocOption</span></a></span><span> </span><span class="annot"><span class="annottext">SDocContext -&gt; Bool
</span><a href="GHC.Utils.Outputable.html#sdocPrintTypecheckerElaboration"><span class="hs-identifier hs-var">sdocPrintTypecheckerElaboration</span></a></span><span> </span><span class="annot"><span class="annottext">((Bool -&gt; SDoc) -&gt; SDoc) -&gt; (Bool -&gt; SDoc) -&gt; SDoc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621682615552"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682615552"><span class="hs-identifier hs-var">print_tc_elab</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-396"></span><span>    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615553"><span class="hs-identifier hs-var">need_parens</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682615552"><span class="hs-identifier hs-var">print_tc_elab</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621682615549"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-397"></span><span>    </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; SDoc
forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621682615549"><span class="hs-identifier hs-var">pat</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-398"></span><span>    </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; SDoc
forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621682615549"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-399"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-400"></span><span>    </span><span id="local-6989586621682615553"><span class="annot"><span class="annottext">need_parens :: Bool -&gt; Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615553"><span class="hs-identifier hs-var hs-var">need_parens</span></a></span></span><span> </span><span id="local-6989586621682615554"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682615554"><span class="hs-identifier hs-var">print_tc_elab</span></a></span></span><span> </span><span id="local-6989586621682615555"><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621682615555"><span class="hs-identifier hs-var">pat</span></a></span></span><span>
</span><span id="line-401"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621682615022"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-402"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XPat"><span class="hs-identifier hs-type">XPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier hs-type">CoPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621682615555"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-403"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682615554"><span class="hs-identifier hs-var">print_tc_elab</span></a></span><span>
</span><span id="line-404"></span><span>
</span><span id="line-405"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-406"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; Pat (GhcPass p) -&gt; Bool
forall (p :: Pass). IsPass p =&gt; PprPrec -&gt; Pat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#patNeedsParens"><span class="hs-identifier hs-var">patNeedsParens</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621682615548"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621682615555"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-407"></span><span>      </span><span class="hs-comment">-- For a CoPat we need parens if we are going to show it, which</span><span>
</span><span id="line-408"></span><span>      </span><span class="hs-comment">-- we do if -fprint-typechecker-elaboration is on (c.f. pprHsWrapper)</span><span>
</span><span id="line-409"></span><span>      </span><span class="hs-comment">-- But otherwise the CoPat is discarded, so it</span><span>
</span><span id="line-410"></span><span>      </span><span class="hs-comment">-- is the pattern inside that matters.  Sigh.</span><span>
</span><span id="line-411"></span><span>
</span><span id="line-412"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-type">pprPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621682615560"><span class="annot"><a href="#local-6989586621682615560"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615560"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615560"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span><span>
</span><span id="line-413"></span><span id="pprPat"><span class="annot"><span class="annottext">pprPat :: forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var hs-var">pprPat</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#VarPat"><span class="hs-identifier hs-type">VarPat</span></a></span><span> </span><span class="annot"><span class="annottext">XVarPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615638"><span class="annot"><span class="annottext">LIdP (GhcPass p)
</span><a href="#local-6989586621682615638"><span class="hs-identifier hs-var">lvar</span></a></span></span><span class="hs-special">)</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">IdGhcP p -&gt; SDoc
forall a. OutputableBndr a =&gt; a -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPatBndr"><span class="hs-identifier hs-var">pprPatBndr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">GenLocated (Anno (IdGhcP p)) (IdGhcP p) -&gt; IdGhcP p
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass p)
GenLocated (Anno (IdGhcP p)) (IdGhcP p)
</span><a href="#local-6989586621682615638"><span class="hs-identifier hs-var">lvar</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-414"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#WildPat"><span class="hs-identifier hs-type">WildPat</span></a></span><span> </span><span class="annot"><span class="annottext">XWildPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
forall doc. IsLine doc =&gt; Char -&gt; doc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'_'</span></span><span>
</span><span id="line-415"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LazyPat"><span class="hs-identifier hs-type">LazyPat</span></a></span><span> </span><span class="annot"><span class="annottext">XLazyPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615641"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615641"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
forall doc. IsLine doc =&gt; Char -&gt; doc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'~'</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%3E"><span class="hs-operator hs-var">&lt;&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var">pprParendLPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615641"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-416"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="annot"><span class="annottext">XBangPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615644"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615644"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
forall doc. IsLine doc =&gt; Char -&gt; doc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'!'</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%3E"><span class="hs-operator hs-var">&lt;&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var">pprParendLPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615644"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-417"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#AsPat"><span class="hs-identifier hs-type">AsPat</span></a></span><span> </span><span class="annot"><span class="annottext">XAsPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615646"><span class="annot"><span class="annottext">LIdP (GhcPass p)
</span><a href="#local-6989586621682615646"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621682615647"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615647"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#hcat"><span class="hs-identifier hs-var">hcat</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">IdGhcP p -&gt; SDoc
forall a. OutputableBndr a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprPrefixOcc"><span class="hs-identifier hs-var">pprPrefixOcc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">GenLocated (Anno (IdGhcP p)) (IdGhcP p) -&gt; IdGhcP p
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass p)
GenLocated (Anno (IdGhcP p)) (IdGhcP p)
</span><a href="#local-6989586621682615646"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
forall doc. IsLine doc =&gt; Char -&gt; doc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'@'</span></span><span class="hs-special">,</span><span>
</span><span id="line-418"></span><span>                                        </span><span class="annot"><span class="annottext">PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var">pprParendLPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615647"><span class="hs-identifier hs-var">pat</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-419"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ViewPat"><span class="hs-identifier hs-type">ViewPat</span></a></span><span> </span><span class="annot"><span class="annottext">XViewPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615650"><span class="annot"><span class="annottext">LHsExpr (GhcPass p)
</span><a href="#local-6989586621682615650"><span class="hs-identifier hs-var">expr</span></a></span></span><span> </span><span id="local-6989586621682615651"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615651"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#hcat"><span class="hs-identifier hs-var">hcat</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LHsExpr (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
LHsExpr (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Expr.html#pprLExpr"><span class="hs-identifier hs-var">pprLExpr</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass p)
</span><a href="#local-6989586621682615650"><span class="hs-identifier hs-var">expr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
forall doc. IsLine doc =&gt; String -&gt; doc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot; -&gt; &quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
GenLocated SrcSpanAnnA (Pat (GhcPass p))
</span><a href="#local-6989586621682615651"><span class="hs-identifier hs-var">pat</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-420"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615653"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615653"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
GenLocated SrcSpanAnnA (Pat (GhcPass p))
</span><a href="#local-6989586621682615653"><span class="hs-identifier hs-var">pat</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-421"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LitPat"><span class="hs-identifier hs-type">LitPat</span></a></span><span> </span><span class="annot"><span class="annottext">XLitPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615655"><span class="annot"><span class="annottext">HsLit (GhcPass p)
</span><a href="#local-6989586621682615655"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">)</span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsLit (GhcPass p) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">HsLit (GhcPass p)
</span><a href="#local-6989586621682615655"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-422"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span> </span><span class="annot"><span class="annottext">XNPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615657"><span class="annot"><span class="annottext">XRec (GhcPass p) (HsOverLit (GhcPass p))
</span><a href="#local-6989586621682615657"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe (SyntaxExpr (GhcPass p))
</span><span class="hs-identifier hs-var">Nothing</span></span><span>  </span><span class="annot"><span class="annottext">SyntaxExpr (GhcPass p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">GenLocated EpAnnCO (HsOverLit (GhcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (HsOverLit (GhcPass p))
GenLocated EpAnnCO (HsOverLit (GhcPass p))
</span><a href="#local-6989586621682615657"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-423"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span> </span><span class="annot"><span class="annottext">XNPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615658"><span class="annot"><span class="annottext">XRec (GhcPass p) (HsOverLit (GhcPass p))
</span><a href="#local-6989586621682615658"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="annottext">SyntaxExpr (GhcPass p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">SyntaxExpr (GhcPass p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
forall doc. IsLine doc =&gt; Char -&gt; doc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'-'</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%3E"><span class="hs-operator hs-var">&lt;&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated EpAnnCO (HsOverLit (GhcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (HsOverLit (GhcPass p))
GenLocated EpAnnCO (HsOverLit (GhcPass p))
</span><a href="#local-6989586621682615658"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-424"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPlusKPat"><span class="hs-identifier hs-type">NPlusKPat</span></a></span><span> </span><span class="annot"><span class="annottext">XNPlusKPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615660"><span class="annot"><span class="annottext">LIdP (GhcPass p)
</span><a href="#local-6989586621682615660"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621682615661"><span class="annot"><span class="annottext">XRec (GhcPass p) (HsOverLit (GhcPass p))
</span><a href="#local-6989586621682615661"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="annot"><span class="annottext">HsOverLit (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">SyntaxExpr (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">SyntaxExpr (GhcPass p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#hcat"><span class="hs-identifier hs-var">hcat</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">SDoc
</span><a href="#local-6989586621682615662"><span class="hs-identifier hs-var">ppr_n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
forall doc. IsLine doc =&gt; Char -&gt; doc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'+'</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">GenLocated EpAnnCO (HsOverLit (GhcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (HsOverLit (GhcPass p))
GenLocated EpAnnCO (HsOverLit (GhcPass p))
</span><a href="#local-6989586621682615661"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-425"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621682615662"><span class="annot"><span class="annottext">ppr_n :: SDoc
</span><a href="#local-6989586621682615662"><span class="hs-identifier hs-var hs-var">ppr_n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621682615560"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-426"></span><span>                  </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-var">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass p)
GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621682615660"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-427"></span><span>                  </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN Name -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass p)
GenLocated SrcSpanAnnN Name
</span><a href="#local-6989586621682615660"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-428"></span><span>                  </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN TyVar -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass p)
GenLocated SrcSpanAnnN TyVar
</span><a href="#local-6989586621682615660"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-429"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SplicePat"><span class="hs-identifier hs-type">SplicePat</span></a></span><span> </span><span id="local-6989586621682615675"><span class="annot"><span class="annottext">XSplicePat (GhcPass p)
</span><a href="#local-6989586621682615675"><span class="hs-identifier hs-var">ext</span></a></span></span><span> </span><span id="local-6989586621682615676"><span class="annot"><span class="annottext">HsUntypedSplice (GhcPass p)
</span><a href="#local-6989586621682615676"><span class="hs-identifier hs-var">splice</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span>
</span><span id="line-430"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621682615560"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-431"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-var">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Maybe Name -&gt; HsUntypedSplice (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
Bool -&gt; Maybe Name -&gt; HsUntypedSplice (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Expr.html#pprUntypedSplice"><span class="hs-identifier hs-var">pprUntypedSplice</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">Maybe Name
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">HsUntypedSplice (GhcPass p)
</span><a href="#local-6989586621682615676"><span class="hs-identifier hs-var">splice</span></a></span><span>
</span><span id="line-432"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="GHC.Hs.Expr.html#HsUntypedSpliceNested"><span class="hs-identifier hs-type">HsUntypedSpliceNested</span></a></span><span> </span><span id="local-6989586621682615684"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621682615684"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">XSplicePat (GhcPass p)
</span><a href="#local-6989586621682615675"><span class="hs-identifier hs-var">ext</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Maybe Name -&gt; HsUntypedSplice (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
Bool -&gt; Maybe Name -&gt; HsUntypedSplice (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Expr.html#pprUntypedSplice"><span class="hs-identifier hs-var">pprUntypedSplice</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Maybe Name
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621682615684"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">HsUntypedSplice (GhcPass p)
</span><a href="#local-6989586621682615676"><span class="hs-identifier hs-var">splice</span></a></span><span>
</span><span id="line-433"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="GHC.Hs.Expr.html#HsUntypedSpliceTop"><span class="hs-identifier hs-type">HsUntypedSpliceTop</span></a></span><span> </span><span class="annot"><span class="annottext">ThModFinalizers
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615690"><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621682615690"><span class="hs-identifier hs-var">p</span></a></span></span><span>  </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">XSplicePat (GhcPass p)
</span><a href="#local-6989586621682615675"><span class="hs-identifier hs-var">ext</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat GhcRn -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621682615690"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-434"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">DataConCantHappen -&gt; SDoc
forall a. DataConCantHappen -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#dataConCantHappen"><span class="hs-identifier hs-var">dataConCantHappen</span></a></span><span> </span><span class="annot"><span class="annottext">XSplicePat (GhcPass p)
DataConCantHappen
</span><a href="#local-6989586621682615675"><span class="hs-identifier hs-var">ext</span></a></span><span>
</span><span id="line-435"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SigPat"><span class="hs-identifier hs-type">SigPat</span></a></span><span> </span><span class="annot"><span class="annottext">XSigPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615694"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615694"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span id="local-6989586621682615695"><span class="annot"><span class="annottext">HsPatSigType (NoGhcTc (GhcPass p))
</span><a href="#local-6989586621682615695"><span class="hs-identifier hs-var">ty</span></a></span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
GenLocated SrcSpanAnnA (Pat (GhcPass p))
</span><a href="#local-6989586621682615694"><span class="hs-identifier hs-var">pat</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc
</span><a href="GHC.Utils.Outputable.html#dcolon"><span class="hs-identifier hs-var">dcolon</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">HsPatSigType (GhcPass (NoGhcTcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">HsPatSigType (NoGhcTc (GhcPass p))
HsPatSigType (GhcPass (NoGhcTcPass p))
</span><a href="#local-6989586621682615695"><span class="hs-identifier hs-var">ty</span></a></span><span>
</span><span id="line-436"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ListPat"><span class="hs-identifier hs-type">ListPat</span></a></span><span> </span><span class="annot"><span class="annottext">XListPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615698"><span class="annot"><span class="annottext">[LPat (GhcPass p)]
</span><a href="#local-6989586621682615698"><span class="hs-identifier hs-var">pats</span></a></span></span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#brackets"><span class="hs-identifier hs-var">brackets</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[GenLocated SrcSpanAnnA (Pat (GhcPass p))] -&gt; SDoc
forall a. Outputable a =&gt; [a] -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#interpp%27SP"><span class="hs-identifier hs-var">interpp'SP</span></a></span><span> </span><span class="annot"><span class="annottext">[LPat (GhcPass p)]
[GenLocated SrcSpanAnnA (Pat (GhcPass p))]
</span><a href="#local-6989586621682615698"><span class="hs-identifier hs-var">pats</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-437"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#OrPat"><span class="hs-identifier hs-type">OrPat</span></a></span><span> </span><span class="annot"><span class="annottext">XOrPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615702"><span class="annot"><span class="annottext">NonEmpty (LPat (GhcPass p))
</span><a href="#local-6989586621682615702"><span class="hs-identifier hs-var">pats</span></a></span></span><span class="hs-special">)</span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc)
-&gt; [GenLocated SrcSpanAnnA (Pat (GhcPass p))] -&gt; SDoc
forall a. (a -&gt; SDoc) -&gt; [a] -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprWithSemis"><span class="hs-identifier hs-var">pprWithSemis</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NonEmpty (GenLocated SrcSpanAnnA (Pat (GhcPass p)))
-&gt; [GenLocated SrcSpanAnnA (Pat (GhcPass p))]
forall a. NonEmpty a -&gt; [a]
</span><a href="../../base-4.21.0.0-ae91/src/Data.List.NonEmpty.html#toList"><span class="hs-identifier hs-var">NE.toList</span></a></span><span> </span><span class="annot"><span class="annottext">NonEmpty (LPat (GhcPass p))
NonEmpty (GenLocated SrcSpanAnnA (Pat (GhcPass p)))
</span><a href="#local-6989586621682615702"><span class="hs-identifier hs-var">pats</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-438"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#TuplePat"><span class="hs-identifier hs-type">TuplePat</span></a></span><span> </span><span class="annot"><span class="annottext">XTuplePat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615706"><span class="annot"><span class="annottext">[LPat (GhcPass p)]
</span><a href="#local-6989586621682615706"><span class="hs-identifier hs-var">pats</span></a></span></span><span> </span><span id="local-6989586621682615707"><span class="annot"><span class="annottext">Boxity
</span><a href="#local-6989586621682615707"><span class="hs-identifier hs-var">bx</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-439"></span><span>    </span><span class="hs-comment">-- Special-case unary boxed tuples so that they are pretty-printed as</span><span>
</span><span id="line-440"></span><span>    </span><span class="hs-comment">-- `MkSolo x`, not `(x)`</span><span>
</span><span id="line-441"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">[</span><span id="local-6989586621682615708"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615708"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[LPat (GhcPass p)]
</span><a href="#local-6989586621682615706"><span class="hs-identifier hs-var">pats</span></a></span><span>
</span><span id="line-442"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Boxity
</span><a href="Language.Haskell.Syntax.Basic.html#Boxed"><span class="hs-identifier hs-var">Boxed</span></a></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Boxity
</span><a href="#local-6989586621682615707"><span class="hs-identifier hs-var">bx</span></a></span><span>
</span><span id="line-443"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#hcat"><span class="hs-identifier hs-var">hcat</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">String -&gt; SDoc
forall doc. IsLine doc =&gt; String -&gt; doc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Boxity -&gt; NameSpace -&gt; Int -&gt; String
</span><a href="GHC.Builtin.Types.html#mkTupleStr"><span class="hs-identifier hs-var">mkTupleStr</span></a></span><span> </span><span class="annot"><span class="annottext">Boxity
</span><a href="Language.Haskell.Syntax.Basic.html#Boxed"><span class="hs-identifier hs-var">Boxed</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="GHC.Types.Name.Occurrence.html#dataName"><span class="hs-identifier hs-var">dataName</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var">pprParendLPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615708"><span class="hs-identifier hs-var">pat</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-444"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-445"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TupleSort -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Types.Basic.html#tupleParens"><span class="hs-identifier hs-var">tupleParens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Boxity -&gt; TupleSort
</span><a href="GHC.Types.Basic.html#boxityTupleSort"><span class="hs-identifier hs-var">boxityTupleSort</span></a></span><span> </span><span class="annot"><span class="annottext">Boxity
</span><a href="#local-6989586621682615707"><span class="hs-identifier hs-var">bx</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc)
-&gt; [GenLocated SrcSpanAnnA (Pat (GhcPass p))] -&gt; SDoc
forall a. (a -&gt; SDoc) -&gt; [a] -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprWithCommas"><span class="hs-identifier hs-var">pprWithCommas</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">[LPat (GhcPass p)]
[GenLocated SrcSpanAnnA (Pat (GhcPass p))]
</span><a href="#local-6989586621682615706"><span class="hs-identifier hs-var">pats</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-446"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SumPat"><span class="hs-identifier hs-type">SumPat</span></a></span><span> </span><span class="annot"><span class="annottext">XSumPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615716"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615716"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span id="local-6989586621682615717"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621682615717"><span class="hs-identifier hs-var">alt</span></a></span></span><span> </span><span id="local-6989586621682615718"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621682615718"><span class="hs-identifier hs-var">arity</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
</span><a href="GHC.Types.Basic.html#sumParens"><span class="hs-identifier hs-var">sumParens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc)
-&gt; GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Int -&gt; Int -&gt; SDoc
forall a. (a -&gt; SDoc) -&gt; a -&gt; Int -&gt; Int -&gt; SDoc
</span><a href="GHC.Types.Basic.html#pprAlternative"><span class="hs-identifier hs-var">pprAlternative</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
GenLocated SrcSpanAnnA (Pat (GhcPass p))
</span><a href="#local-6989586621682615716"><span class="hs-identifier hs-var">pat</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621682615717"><span class="hs-identifier hs-var">alt</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621682615718"><span class="hs-identifier hs-var">arity</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-447"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConPat"><span class="hs-identifier hs-type">ConPat</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pat_con :: forall p. Pat p -&gt; XRec p (ConLikeP p)
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con"><span class="hs-identifier hs-var">pat_con</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621682615723"><span class="annot"><span class="annottext">XRec (GhcPass p) (ConLikeP (GhcPass p))
</span><a href="#local-6989586621682615723"><span class="hs-identifier hs-var">con</span></a></span></span><span>
</span><span id="line-448"></span><span>               </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pat_args :: forall p. Pat p -&gt; HsConPatDetails p
</span><a href="Language.Haskell.Syntax.Pat.html#pat_args"><span class="hs-identifier hs-var">pat_args</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621682615725"><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621682615725"><span class="hs-identifier hs-var">details</span></a></span></span><span>
</span><span id="line-449"></span><span>               </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pat_con_ext :: forall p. Pat p -&gt; XConPat p
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con_ext"><span class="hs-identifier hs-var">pat_con_ext</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621682615727"><span class="annot"><span class="annottext">XConPat (GhcPass p)
</span><a href="#local-6989586621682615727"><span class="hs-identifier hs-var">ext</span></a></span></span><span>
</span><span id="line-450"></span><span>               </span><span class="hs-special">}</span><span>
</span><span id="line-451"></span><span>       </span><span class="hs-special">)</span><span>
</span><span id="line-452"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621682615560"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-453"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-var">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">RdrName -&gt; HsConPatDetails (GhcPass p) -&gt; SDoc
forall con (p :: Pass).
(OutputableBndr con, OutputableBndrId p,
 Outputable (Anno (IdGhcP p))) =&gt;
con -&gt; HsConPatDetails (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprUserCon"><span class="hs-identifier hs-var">pprUserCon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName -&gt; RdrName
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (ConLikeP (GhcPass p))
GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621682615723"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621682615725"><span class="hs-identifier hs-var">details</span></a></span><span>
</span><span id="line-454"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; HsConPatDetails (GhcPass p) -&gt; SDoc
forall con (p :: Pass).
(OutputableBndr con, OutputableBndrId p,
 Outputable (Anno (IdGhcP p))) =&gt;
con -&gt; HsConPatDetails (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprUserCon"><span class="hs-identifier hs-var">pprUserCon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN Name -&gt; Name
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (ConLikeP (GhcPass p))
GenLocated SrcSpanAnnN Name
</span><a href="#local-6989586621682615723"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621682615725"><span class="hs-identifier hs-var">details</span></a></span><span>
</span><span id="line-455"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(SDocContext -&gt; Bool) -&gt; (Bool -&gt; SDoc) -&gt; SDoc
forall a. (SDocContext -&gt; a) -&gt; (a -&gt; SDoc) -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#sdocOption"><span class="hs-identifier hs-var">sdocOption</span></a></span><span> </span><span class="annot"><span class="annottext">SDocContext -&gt; Bool
</span><a href="GHC.Utils.Outputable.html#sdocPrintTypecheckerElaboration"><span class="hs-identifier hs-var">sdocPrintTypecheckerElaboration</span></a></span><span> </span><span class="annot"><span class="annottext">((Bool -&gt; SDoc) -&gt; SDoc) -&gt; (Bool -&gt; SDoc) -&gt; SDoc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-456"></span><span>        </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ConLike -&gt; HsConPatDetails (GhcPass p) -&gt; SDoc
forall con (p :: Pass).
(OutputableBndr con, OutputableBndrId p,
 Outputable (Anno (IdGhcP p))) =&gt;
con -&gt; HsConPatDetails (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprUserCon"><span class="hs-identifier hs-var">pprUserCon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN ConLike -&gt; ConLike
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (ConLikeP (GhcPass p))
GenLocated SrcSpanAnnN ConLike
</span><a href="#local-6989586621682615723"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621682615725"><span class="hs-identifier hs-var">details</span></a></span><span>
</span><span id="line-457"></span><span>        </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-458"></span><span>          </span><span class="hs-comment">-- Tiresome; in 'GHC.Tc.Gen.Bind.tcRhs' we print out a typechecked Pat in an</span><span>
</span><span id="line-459"></span><span>          </span><span class="hs-comment">-- error message, and we want to make sure it prints nicely</span><span>
</span><span id="line-460"></span><span>          </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN ConLike -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (ConLikeP (GhcPass p))
GenLocated SrcSpanAnnN ConLike
</span><a href="#local-6989586621682615723"><span class="hs-identifier hs-var">con</span></a></span><span>
</span><span id="line-461"></span><span>            </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%3E"><span class="hs-operator hs-var">&lt;&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#braces"><span class="hs-identifier hs-var">braces</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#sep"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#hsep"><span class="hs-identifier hs-var">hsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(TyVar -&gt; SDoc) -&gt; [TyVar] -&gt; [SDoc]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TyVar -&gt; SDoc
forall a. OutputableBndr a =&gt; a -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPatBndr"><span class="hs-identifier hs-var">pprPatBndr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVar]
</span><a href="#local-6989586621682615771"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVar] -&gt; [TyVar] -&gt; [TyVar]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[TyVar]
</span><a href="#local-6989586621682615772"><span class="hs-identifier hs-var">dicts</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-462"></span><span>                           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">TcEvBinds -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">TcEvBinds
</span><a href="#local-6989586621682615773"><span class="hs-identifier hs-var">binds</span></a></span><span> </span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-463"></span><span>            </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p) -&gt; SDoc
forall (p :: Pass).
(OutputableBndrId p, Outputable (Anno (IdGhcP p))) =&gt;
HsConPatDetails (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprConArgs"><span class="hs-identifier hs-var">pprConArgs</span></a></span><span> </span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621682615725"><span class="hs-identifier hs-var">details</span></a></span><span>
</span><span id="line-464"></span><span>        </span><span class="hs-keyword">where</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#ConPatTc"><span class="hs-identifier hs-type">ConPatTc</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">cpt_tvs :: ConPatTc -&gt; [TyVar]
</span><a href="GHC.Hs.Pat.html#cpt_tvs"><span class="hs-identifier hs-var">cpt_tvs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621682615771"><span class="annot"><span class="annottext">[TyVar]
</span><a href="#local-6989586621682615771"><span class="hs-identifier hs-var">tvs</span></a></span></span><span>
</span><span id="line-465"></span><span>                       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cpt_dicts :: ConPatTc -&gt; [TyVar]
</span><a href="GHC.Hs.Pat.html#cpt_dicts"><span class="hs-identifier hs-var">cpt_dicts</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621682615772"><span class="annot"><span class="annottext">[TyVar]
</span><a href="#local-6989586621682615772"><span class="hs-identifier hs-var">dicts</span></a></span></span><span>
</span><span id="line-466"></span><span>                       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cpt_binds :: ConPatTc -&gt; TcEvBinds
</span><a href="GHC.Hs.Pat.html#cpt_binds"><span class="hs-identifier hs-var">cpt_binds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621682615773"><span class="annot"><span class="annottext">TcEvBinds
</span><a href="#local-6989586621682615773"><span class="hs-identifier hs-var">binds</span></a></span></span><span>
</span><span id="line-467"></span><span>                       </span><span class="hs-special">}</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">XConPat (GhcPass p)
</span><a href="#local-6989586621682615727"><span class="hs-identifier hs-var">ext</span></a></span><span>
</span><span id="line-468"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#EmbTyPat"><span class="hs-identifier hs-type">EmbTyPat</span></a></span><span> </span><span class="annot"><span class="annottext">XEmbTyPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615775"><span class="annot"><span class="annottext">HsTyPat (NoGhcTc (GhcPass p))
</span><a href="#local-6989586621682615775"><span class="hs-identifier hs-var">tp</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
forall doc. IsLine doc =&gt; String -&gt; doc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;type&quot;</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">HsTyPat (GhcPass (NoGhcTcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">HsTyPat (NoGhcTc (GhcPass p))
HsTyPat (GhcPass (NoGhcTcPass p))
</span><a href="#local-6989586621682615775"><span class="hs-identifier hs-var">tp</span></a></span><span>
</span><span id="line-469"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#InvisPat"><span class="hs-identifier hs-type">InvisPat</span></a></span><span> </span><span id="local-6989586621682615777"><span class="annot"><span class="annottext">XInvisPat (GhcPass p)
</span><a href="#local-6989586621682615777"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621682615778"><span class="annot"><span class="annottext">HsTyPat (NoGhcTc (GhcPass p))
</span><a href="#local-6989586621682615778"><span class="hs-identifier hs-var">tp</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
forall doc. IsLine doc =&gt; Char -&gt; doc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'@'</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%3E"><span class="hs-operator hs-var">&lt;&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
</span><a href="#local-6989586621682615779"><span class="hs-identifier hs-var">delimit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HsTyPat (GhcPass (NoGhcTcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">HsTyPat (NoGhcTc (GhcPass p))
HsTyPat (GhcPass (NoGhcTcPass p))
</span><a href="#local-6989586621682615778"><span class="hs-identifier hs-var">tp</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-470"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-471"></span><span>    </span><span id="local-6989586621682615779"><span class="annot"><span class="annottext">delimit :: SDoc -&gt; SDoc
</span><a href="#local-6989586621682615779"><span class="hs-identifier hs-var hs-var">delimit</span></a></span></span><span>
</span><span id="line-472"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682615780"><span class="hs-identifier hs-var">inferred</span></a></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#braces"><span class="hs-identifier hs-var">braces</span></a></span><span>
</span><span id="line-473"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682615781"><span class="hs-identifier hs-var">needs_parens</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span>
</span><span id="line-474"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span>
</span><span id="line-475"></span><span>    </span><span id="local-6989586621682615780"><span class="annot"><span class="annottext">inferred :: Bool
</span><a href="#local-6989586621682615780"><span class="hs-identifier hs-var hs-var">inferred</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621682615560"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-476"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-var">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(EpToken &quot;@&quot;, Specificity) -&gt; Specificity
forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span> </span><span class="annot"><span class="annottext">(EpToken &quot;@&quot;, Specificity)
XInvisPat (GhcPass p)
</span><a href="#local-6989586621682615777"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Specificity -&gt; Specificity -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Specificity
</span><a href="Language.Haskell.Syntax.Specificity.html#InferredSpec"><span class="hs-identifier hs-var">InferredSpec</span></a></span><span>
</span><span id="line-477"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">XInvisPat (GhcPass p)
Specificity
</span><a href="#local-6989586621682615777"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Specificity -&gt; Specificity -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Specificity
</span><a href="Language.Haskell.Syntax.Specificity.html#InferredSpec"><span class="hs-identifier hs-var">InferredSpec</span></a></span><span>
</span><span id="line-478"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-479"></span><span>    </span><span id="local-6989586621682615781"><span class="annot"><span class="annottext">needs_parens :: Bool
</span><a href="#local-6989586621682615781"><span class="hs-identifier hs-var hs-var">needs_parens</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; HsType (GhcPass (NoGhcTcPass p)) -&gt; Bool
forall (p :: Pass). PprPrec -&gt; HsType (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Type.html#hsTypeNeedsParens"><span class="hs-identifier hs-var">hsTypeNeedsParens</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">(HsType (GhcPass (NoGhcTcPass p)) -&gt; Bool)
-&gt; HsType (GhcPass (NoGhcTcPass p)) -&gt; Bool
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (HsType (GhcPass (NoGhcTcPass p)))
-&gt; HsType (GhcPass (NoGhcTcPass p))
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (HsType (GhcPass (NoGhcTcPass p)))
 -&gt; HsType (GhcPass (NoGhcTcPass p)))
-&gt; GenLocated SrcSpanAnnA (HsType (GhcPass (NoGhcTcPass p)))
-&gt; HsType (GhcPass (NoGhcTcPass p))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">HsTyPat (GhcPass (NoGhcTcPass p))
-&gt; LHsType (GhcPass (NoGhcTcPass p))
forall pass. HsTyPat pass -&gt; LHsType pass
</span><a href="Language.Haskell.Syntax.Type.html#hstp_body"><span class="hs-identifier hs-var">hstp_body</span></a></span><span> </span><span class="annot"><span class="annottext">HsTyPat (NoGhcTc (GhcPass p))
HsTyPat (GhcPass (NoGhcTcPass p))
</span><a href="#local-6989586621682615778"><span class="hs-identifier hs-var">tp</span></a></span><span>
</span><span id="line-480"></span><span>
</span><span id="line-481"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XPat"><span class="hs-identifier hs-type">XPat</span></a></span><span> </span><span id="local-6989586621682615793"><span class="annot"><span class="annottext">XXPat (GhcPass p)
</span><a href="#local-6989586621682615793"><span class="hs-identifier hs-var">ext</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621682615560"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-482"></span><span>  </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">XXPat (GhcPass p)
</span><a href="#local-6989586621682615793"><span class="hs-identifier hs-var">ext</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-483"></span><span>    </span><span class="annot"><a href="GHC.Hs.Pat.html#HsPatExpanded"><span class="hs-identifier hs-type">HsPatExpanded</span></a></span><span> </span><span id="local-6989586621682615797"><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621682615797"><span class="hs-identifier hs-var">orig</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat GhcRn -&gt; SDoc
forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621682615797"><span class="hs-identifier hs-var">orig</span></a></span><span>
</span><span id="line-484"></span><span>  </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">XXPat (GhcPass p)
</span><a href="#local-6989586621682615793"><span class="hs-identifier hs-var">ext</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-485"></span><span>    </span><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier hs-type">CoPat</span></a></span><span> </span><span id="local-6989586621682615807"><span class="annot"><span class="annottext">HsWrapper
</span><a href="#local-6989586621682615807"><span class="hs-identifier hs-var">co</span></a></span></span><span> </span><span id="local-6989586621682615808"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621682615808"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-486"></span><span>      </span><span class="annot"><span class="annottext">HsWrapper -&gt; (Bool -&gt; SDoc) -&gt; SDoc
</span><a href="GHC.Tc.Types.Evidence.html#pprHsWrapper"><span class="hs-identifier hs-var">pprHsWrapper</span></a></span><span> </span><span class="annot"><span class="annottext">HsWrapper
</span><a href="#local-6989586621682615807"><span class="hs-identifier hs-var">co</span></a></span><span> </span><span class="annot"><span class="annottext">((Bool -&gt; SDoc) -&gt; SDoc) -&gt; (Bool -&gt; SDoc) -&gt; SDoc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621682615810"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682615810"><span class="hs-identifier hs-var">parens</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-487"></span><span>        </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682615810"><span class="hs-identifier hs-var">parens</span></a></span><span>
</span><span id="line-488"></span><span>        </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; Pat GhcTc -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendPat"><span class="hs-identifier hs-var">pprParendPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621682615808"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-489"></span><span>        </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Pat GhcTc -&gt; SDoc
forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621682615808"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-490"></span><span>    </span><span class="annot"><a href="GHC.Hs.Pat.html#ExpansionPat"><span class="hs-identifier hs-type">ExpansionPat</span></a></span><span> </span><span id="local-6989586621682615811"><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621682615811"><span class="hs-identifier hs-var">orig</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat GhcRn -&gt; SDoc
forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621682615811"><span class="hs-identifier hs-var">orig</span></a></span><span>
</span><span id="line-491"></span><span>
</span><span id="line-492"></span><span id="local-6989586621682615098"><span id="local-6989586621682615099"><span class="annot"><a href="GHC.Hs.Pat.html#pprUserCon"><span class="hs-identifier hs-type">pprUserCon</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Utils.Outputable.html#OutputableBndr"><span class="hs-identifier hs-type">OutputableBndr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615098"><span class="hs-identifier hs-type">con</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615099"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-493"></span><span>                     </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-type">Anno</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#IdGhcP"><span class="hs-identifier hs-type">IdGhcP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615099"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-494"></span><span>           </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682615098"><span class="hs-identifier hs-type">con</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatDetails"><span class="hs-identifier hs-type">HsConPatDetails</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615099"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span></span></span><span>
</span><span id="line-495"></span><span id="pprUserCon"><span class="annot"><span class="annottext">pprUserCon :: forall con (p :: Pass).
(OutputableBndr con, OutputableBndrId p,
 Outputable (Anno (IdGhcP p))) =&gt;
con -&gt; HsConPatDetails (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprUserCon"><span class="hs-identifier hs-var hs-var">pprUserCon</span></a></span></span><span> </span><span id="local-6989586621682615826"><span class="annot"><span class="annottext">con
</span><a href="#local-6989586621682615826"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#InfixCon"><span class="hs-identifier hs-type">InfixCon</span></a></span><span> </span><span id="local-6989586621682615828"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615828"><span class="hs-identifier hs-var">p1</span></a></span></span><span> </span><span id="local-6989586621682615829"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615829"><span class="hs-identifier hs-var">p2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
GenLocated SrcSpanAnnA (Pat (GhcPass p))
</span><a href="#local-6989586621682615828"><span class="hs-identifier hs-var">p1</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">con -&gt; SDoc
forall a. OutputableBndr a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprInfixOcc"><span class="hs-identifier hs-var">pprInfixOcc</span></a></span><span> </span><span class="annot"><span class="annottext">con
</span><a href="#local-6989586621682615826"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
GenLocated SrcSpanAnnA (Pat (GhcPass p))
</span><a href="#local-6989586621682615829"><span class="hs-identifier hs-var">p2</span></a></span><span>
</span><span id="line-496"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprUserCon"><span class="hs-identifier hs-var">pprUserCon</span></a></span><span> </span><span id="local-6989586621682615831"><span class="annot"><span class="annottext">con
</span><a href="#local-6989586621682615831"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621682615832"><span class="annot"><span class="annottext">HsConDetails
  (HsConPatTyArg (NoGhcTc (GhcPass p)))
  (LPat (GhcPass p))
  (HsRecFields (GhcPass p) (LPat (GhcPass p)))
</span><a href="#local-6989586621682615832"><span class="hs-identifier hs-var">details</span></a></span></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">con -&gt; SDoc
forall a. OutputableBndr a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprPrefixOcc"><span class="hs-identifier hs-var">pprPrefixOcc</span></a></span><span> </span><span class="annot"><span class="annottext">con
</span><a href="#local-6989586621682615831"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">HsConDetails
  (HsConPatTyArg (NoGhcTc (GhcPass p)))
  (LPat (GhcPass p))
  (HsRecFields (GhcPass p) (LPat (GhcPass p)))
-&gt; SDoc
forall (p :: Pass).
(OutputableBndrId p, Outputable (Anno (IdGhcP p))) =&gt;
HsConPatDetails (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprConArgs"><span class="hs-identifier hs-var">pprConArgs</span></a></span><span> </span><span class="annot"><span class="annottext">HsConDetails
  (HsConPatTyArg (NoGhcTc (GhcPass p)))
  (LPat (GhcPass p))
  (HsRecFields (GhcPass p) (LPat (GhcPass p)))
</span><a href="#local-6989586621682615832"><span class="hs-identifier hs-var">details</span></a></span><span>
</span><span id="line-497"></span><span>
</span><span id="line-498"></span><span id="local-6989586621682615101"><span class="annot"><a href="GHC.Hs.Pat.html#pprConArgs"><span class="hs-identifier hs-type">pprConArgs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615101"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-499"></span><span>                     </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-type">Anno</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#IdGhcP"><span class="hs-identifier hs-type">IdGhcP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615101"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-500"></span><span>           </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatDetails"><span class="hs-identifier hs-type">HsConPatDetails</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615101"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span></span><span>
</span><span id="line-501"></span><span id="pprConArgs"><span class="annot"><span class="annottext">pprConArgs :: forall (p :: Pass).
(OutputableBndrId p, Outputable (Anno (IdGhcP p))) =&gt;
HsConPatDetails (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprConArgs"><span class="hs-identifier hs-var hs-var">pprConArgs</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#PrefixCon"><span class="hs-identifier hs-type">PrefixCon</span></a></span><span> </span><span id="local-6989586621682615869"><span class="annot"><span class="annottext">[HsConPatTyArg (NoGhcTc (GhcPass p))]
</span><a href="#local-6989586621682615869"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span id="local-6989586621682615870"><span class="annot"><span class="annottext">[LPat (GhcPass p)]
</span><a href="#local-6989586621682615870"><span class="hs-identifier hs-var">pats</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#fsep"><span class="hs-identifier hs-var">fsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[HsConPatTyArg (GhcPass (NoGhcTcPass p))] -&gt; SDoc
forall a. Outputable a =&gt; [a] -&gt; SDoc
</span><a href="#local-6989586621682615871"><span class="hs-identifier hs-var">pprTyArgs</span></a></span><span> </span><span class="annot"><span class="annottext">[HsConPatTyArg (NoGhcTc (GhcPass p))]
[HsConPatTyArg (GhcPass (NoGhcTcPass p))]
</span><a href="#local-6989586621682615869"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; [SDoc] -&gt; [SDoc]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc)
-&gt; [GenLocated SrcSpanAnnA (Pat (GhcPass p))] -&gt; [SDoc]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var">pprParendLPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[LPat (GhcPass p)]
[GenLocated SrcSpanAnnA (Pat (GhcPass p))]
</span><a href="#local-6989586621682615870"><span class="hs-identifier hs-var">pats</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-502"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621682615871"><span class="annot"><span class="annottext">pprTyArgs :: [a] -&gt; SDoc
</span><a href="#local-6989586621682615871"><span class="hs-identifier hs-var hs-var">pprTyArgs</span></a></span></span><span> </span><span id="local-6989586621682615875"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621682615875"><span class="hs-identifier hs-var">tyargs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#fsep"><span class="hs-identifier hs-var">fsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; SDoc) -&gt; [a] -&gt; [SDoc]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621682615875"><span class="hs-identifier hs-var">tyargs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-503"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprConArgs"><span class="hs-identifier hs-var">pprConArgs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#InfixCon"><span class="hs-identifier hs-type">InfixCon</span></a></span><span> </span><span id="local-6989586621682615876"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615876"><span class="hs-identifier hs-var">p1</span></a></span></span><span> </span><span id="local-6989586621682615877"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615877"><span class="hs-identifier hs-var">p2</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#sep"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var">pprParendLPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615876"><span class="hs-identifier hs-var">p1</span></a></span><span>
</span><span id="line-504"></span><span>                                     </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var">pprParendLPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615877"><span class="hs-identifier hs-var">p2</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-505"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprConArgs"><span class="hs-identifier hs-var">pprConArgs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#RecCon"><span class="hs-identifier hs-type">RecCon</span></a></span><span> </span><span id="local-6989586621682615879"><span class="annot"><span class="annottext">HsRecFields (GhcPass p) (LPat (GhcPass p))
</span><a href="#local-6989586621682615879"><span class="hs-identifier hs-var">rpats</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsRecFields (GhcPass p) (GenLocated SrcSpanAnnA (Pat (GhcPass p)))
-&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">HsRecFields (GhcPass p) (LPat (GhcPass p))
HsRecFields (GhcPass p) (GenLocated SrcSpanAnnA (Pat (GhcPass p)))
</span><a href="#local-6989586621682615879"><span class="hs-identifier hs-var">rpats</span></a></span><span>
</span><span id="line-506"></span><span>
</span><span id="line-507"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
*              Building patterns
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-514"></span><span>
</span><span id="line-515"></span><span class="annot"><a href="GHC.Hs.Pat.html#mkPrefixConPat"><span class="hs-identifier hs-type">mkPrefixConPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Core.DataCon.html#DataCon"><span class="hs-identifier hs-type">DataCon</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-516"></span><span>                  </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span>
</span><span id="line-517"></span><span class="hs-comment">-- Make a vanilla Prefix constructor pattern</span><span>
</span><span id="line-518"></span><span id="mkPrefixConPat"><span class="annot"><span class="annottext">mkPrefixConPat :: DataCon -&gt; [LPat GhcTc] -&gt; [Type] -&gt; LPat GhcTc
</span><a href="GHC.Hs.Pat.html#mkPrefixConPat"><span class="hs-identifier hs-var hs-var">mkPrefixConPat</span></a></span></span><span> </span><span id="local-6989586621682615880"><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621682615880"><span class="hs-identifier hs-var">dc</span></a></span></span><span> </span><span id="local-6989586621682615881"><span class="annot"><span class="annottext">[LPat GhcTc]
</span><a href="#local-6989586621682615881"><span class="hs-identifier hs-var">pats</span></a></span></span><span> </span><span id="local-6989586621682615882"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621682615882"><span class="hs-identifier hs-var">tys</span></a></span></span><span>
</span><span id="line-519"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat GhcTc -&gt; GenLocated SrcSpanAnnA (Pat GhcTc)
forall e a. HasAnnotation e =&gt; a -&gt; GenLocated e a
</span><a href="GHC.Parser.Annotation.html#noLocA"><span class="hs-identifier hs-var">noLocA</span></a></span><span> </span><span class="annot"><span class="annottext">(Pat GhcTc -&gt; GenLocated SrcSpanAnnA (Pat GhcTc))
-&gt; Pat GhcTc -&gt; GenLocated SrcSpanAnnA (Pat GhcTc)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConPat"><span class="hs-identifier hs-type">ConPat</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pat_con :: XRec GhcTc (ConLikeP GhcTc)
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con"><span class="hs-identifier hs-var">pat_con</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConLike -&gt; GenLocated SrcSpanAnnN ConLike
forall e a. HasAnnotation e =&gt; a -&gt; GenLocated e a
</span><a href="GHC.Parser.Annotation.html#noLocA"><span class="hs-identifier hs-var">noLocA</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DataCon -&gt; ConLike
</span><a href="GHC.Core.ConLike.html#RealDataCon"><span class="hs-identifier hs-var">RealDataCon</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621682615880"><span class="hs-identifier hs-var">dc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-520"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pat_args :: HsConPatDetails GhcTc
</span><a href="Language.Haskell.Syntax.Pat.html#pat_args"><span class="hs-identifier hs-var">pat_args</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[HsConPatTyArg (NoGhcTc GhcTc)]
-&gt; [LPat GhcTc] -&gt; HsConPatDetails GhcTc
forall tyarg arg rec.
[tyarg] -&gt; [arg] -&gt; HsConDetails tyarg arg rec
</span><a href="Language.Haskell.Syntax.Type.html#PrefixCon"><span class="hs-identifier hs-var">PrefixCon</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">[LPat GhcTc]
</span><a href="#local-6989586621682615881"><span class="hs-identifier hs-var">pats</span></a></span><span>
</span><span id="line-521"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pat_con_ext :: XConPat GhcTc
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con_ext"><span class="hs-identifier hs-var">pat_con_ext</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#ConPatTc"><span class="hs-identifier hs-type">ConPatTc</span></a></span><span>
</span><span id="line-522"></span><span>                      </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">cpt_tvs :: [TyVar]
</span><a href="GHC.Hs.Pat.html#cpt_tvs"><span class="hs-identifier hs-var">cpt_tvs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-523"></span><span>                      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cpt_dicts :: [TyVar]
</span><a href="GHC.Hs.Pat.html#cpt_dicts"><span class="hs-identifier hs-var">cpt_dicts</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-524"></span><span>                      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cpt_binds :: TcEvBinds
</span><a href="GHC.Hs.Pat.html#cpt_binds"><span class="hs-identifier hs-var">cpt_binds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TcEvBinds
</span><a href="GHC.Tc.Types.Evidence.html#emptyTcEvBinds"><span class="hs-identifier hs-var">emptyTcEvBinds</span></a></span><span>
</span><span id="line-525"></span><span>                      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cpt_arg_tys :: [Type]
</span><a href="GHC.Hs.Pat.html#cpt_arg_tys"><span class="hs-identifier hs-var">cpt_arg_tys</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621682615882"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-526"></span><span>                      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cpt_wrap :: HsWrapper
</span><a href="GHC.Hs.Pat.html#cpt_wrap"><span class="hs-identifier hs-var">cpt_wrap</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsWrapper
</span><a href="GHC.Tc.Types.Evidence.html#idHsWrapper"><span class="hs-identifier hs-var">idHsWrapper</span></a></span><span>
</span><span id="line-527"></span><span>                      </span><span class="hs-special">}</span><span>
</span><span id="line-528"></span><span>                    </span><span class="hs-special">}</span><span>
</span><span id="line-529"></span><span>
</span><span id="line-530"></span><span class="annot"><a href="GHC.Hs.Pat.html#mkNilPat"><span class="hs-identifier hs-type">mkNilPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span>
</span><span id="line-531"></span><span id="mkNilPat"><span class="annot"><span class="annottext">mkNilPat :: Type -&gt; LPat GhcTc
</span><a href="GHC.Hs.Pat.html#mkNilPat"><span class="hs-identifier hs-var hs-var">mkNilPat</span></a></span></span><span> </span><span id="local-6989586621682615887"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621682615887"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DataCon -&gt; [LPat GhcTc] -&gt; [Type] -&gt; LPat GhcTc
</span><a href="GHC.Hs.Pat.html#mkPrefixConPat"><span class="hs-identifier hs-var">mkPrefixConPat</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="GHC.Builtin.Types.html#nilDataCon"><span class="hs-identifier hs-var">nilDataCon</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621682615887"><span class="hs-identifier hs-var">ty</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-532"></span><span>
</span><span id="line-533"></span><span class="annot"><a href="GHC.Hs.Pat.html#mkCharLitPat"><span class="hs-identifier hs-type">mkCharLitPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.SourceText.html#SourceText"><span class="hs-identifier hs-type">SourceText</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span>
</span><span id="line-534"></span><span id="mkCharLitPat"><span class="annot"><span class="annottext">mkCharLitPat :: SourceText -&gt; Char -&gt; LPat GhcTc
</span><a href="GHC.Hs.Pat.html#mkCharLitPat"><span class="hs-identifier hs-var hs-var">mkCharLitPat</span></a></span></span><span> </span><span id="local-6989586621682615889"><span class="annot"><span class="annottext">SourceText
</span><a href="#local-6989586621682615889"><span class="hs-identifier hs-var">src</span></a></span></span><span> </span><span id="local-6989586621682615890"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621682615890"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DataCon -&gt; [LPat GhcTc] -&gt; [Type] -&gt; LPat GhcTc
</span><a href="GHC.Hs.Pat.html#mkPrefixConPat"><span class="hs-identifier hs-var">mkPrefixConPat</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="GHC.Builtin.Types.html#charDataCon"><span class="hs-identifier hs-var">charDataCon</span></a></span><span>
</span><span id="line-535"></span><span>                          </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Pat GhcTc -&gt; GenLocated SrcSpanAnnA (Pat GhcTc)
forall e a. HasAnnotation e =&gt; a -&gt; GenLocated e a
</span><a href="GHC.Parser.Annotation.html#noLocA"><span class="hs-identifier hs-var">noLocA</span></a></span><span> </span><span class="annot"><span class="annottext">(Pat GhcTc -&gt; GenLocated SrcSpanAnnA (Pat GhcTc))
-&gt; Pat GhcTc -&gt; GenLocated SrcSpanAnnA (Pat GhcTc)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">XLitPat GhcTc -&gt; HsLit GhcTc -&gt; Pat GhcTc
forall p. XLitPat p -&gt; HsLit p -&gt; Pat p
</span><a href="Language.Haskell.Syntax.Pat.html#LitPat"><span class="hs-identifier hs-var">LitPat</span></a></span><span> </span><span class="annot"><span class="annottext">XLitPat GhcTc
NoExtField
</span><a href="Language.Haskell.Syntax.Extension.html#noExtField"><span class="hs-identifier hs-var">noExtField</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">XHsCharPrim GhcTc -&gt; Char -&gt; HsLit GhcTc
forall x. XHsCharPrim x -&gt; Char -&gt; HsLit x
</span><a href="Language.Haskell.Syntax.Lit.html#HsCharPrim"><span class="hs-identifier hs-var">HsCharPrim</span></a></span><span> </span><span class="annot"><span class="annottext">XHsCharPrim GhcTc
SourceText
</span><a href="#local-6989586621682615889"><span class="hs-identifier hs-var">src</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621682615890"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-536"></span><span>
</span><span id="line-537"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
* Predicates for checking things about pattern-lists in EquationInfo   *
*                                                                      *
************************************************************************

\subsection[Pat-list-predicates]{Look for interesting things in patterns}

Unlike in the Wadler chapter, where patterns are either ``variables''
or ``constructors,'' here we distinguish between:
\begin{description}
\item[unfailable:]
Patterns that cannot fail to match: variables, wildcards, and lazy
patterns.

These are the irrefutable patterns; the two other categories
are refutable patterns.

\item[constructor:]
A non-literal constructor pattern (see next category).

\item[literal patterns:]
At least the numeric ones may be overloaded.
\end{description}

A pattern is in {\em exactly one} of the above three categories; `as'
patterns are treated specially, of course.

The 1.3 report defines what ``irrefutable'' and ``failure-free'' patterns are.
-}</span><span>
</span><span id="line-568"></span><span>
</span><span id="line-569"></span><span id="local-6989586621682615134"><span class="annot"><a href="GHC.Hs.Pat.html#isBangedLPat"><span class="hs-identifier hs-type">isBangedLPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615134"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-570"></span><span id="isBangedLPat"><span class="annot"><span class="annottext">isBangedLPat :: forall (p :: Pass). LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isBangedLPat"><span class="hs-identifier hs-var hs-var">isBangedLPat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; Bool
forall (p :: Pass). Pat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isBangedPat"><span class="hs-identifier hs-var">isBangedPat</span></a></span><span> </span><span class="annot"><span class="annottext">(Pat (GhcPass p) -&gt; Bool)
-&gt; (GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Pat (GhcPass p))
-&gt; GenLocated SrcSpanAnnA (Pat (GhcPass p))
-&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Pat (GhcPass p)
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span>
</span><span id="line-571"></span><span>
</span><span id="line-572"></span><span id="local-6989586621682615136"><span class="annot"><a href="GHC.Hs.Pat.html#isBangedPat"><span class="hs-identifier hs-type">isBangedPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615136"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-573"></span><span id="isBangedPat"><span class="annot"><span class="annottext">isBangedPat :: forall (p :: Pass). Pat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isBangedPat"><span class="hs-identifier hs-var hs-var">isBangedPat</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615895"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615895"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
forall (p :: Pass). LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isBangedLPat"><span class="hs-identifier hs-var">isBangedLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615895"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-574"></span><span class="annot"><a href="GHC.Hs.Pat.html#isBangedPat"><span class="hs-identifier hs-var">isBangedPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-575"></span><span class="annot"><a href="GHC.Hs.Pat.html#isBangedPat"><span class="hs-identifier hs-var">isBangedPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-576"></span><span>
</span><span id="line-577"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPatBind"><span class="hs-identifier hs-type">looksLazyPatBind</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsBind"><span class="hs-identifier hs-type">HsBind</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-578"></span><span class="hs-comment">-- Returns True of anything *except*</span><span>
</span><span id="line-579"></span><span class="hs-comment">--     a StrictHsBind (as above) or</span><span>
</span><span id="line-580"></span><span class="hs-comment">--     a VarPat</span><span>
</span><span id="line-581"></span><span class="hs-comment">-- In particular, returns True of a pattern binding with a compound pattern, like (I# x)</span><span>
</span><span id="line-582"></span><span class="hs-comment">-- Looks through AbsBinds</span><span>
</span><span id="line-583"></span><span id="looksLazyPatBind"><span class="annot"><span class="annottext">looksLazyPatBind :: HsBind GhcTc -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyPatBind"><span class="hs-identifier hs-var hs-var">looksLazyPatBind</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#PatBind"><span class="hs-identifier hs-type">PatBind</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pat_lhs :: forall idL idR. HsBindLR idL idR -&gt; LPat idL
</span><a href="Language.Haskell.Syntax.Binds.html#pat_lhs"><span class="hs-identifier hs-var">pat_lhs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621682615898"><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621682615898"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-584"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bool
forall (p :: Pass). LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyLPat"><span class="hs-identifier hs-var">looksLazyLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621682615898"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-585"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPatBind"><span class="hs-identifier hs-var">looksLazyPatBind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#XHsBindsLR"><span class="hs-identifier hs-type">XHsBindsLR</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Binds.html#AbsBinds"><span class="hs-identifier hs-type">AbsBinds</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">abs_binds :: AbsBinds -&gt; LHsBinds GhcTc
</span><a href="GHC.Hs.Binds.html#abs_binds"><span class="hs-identifier hs-var">abs_binds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621682615903"><span class="annot"><span class="annottext">LHsBinds GhcTc
</span><a href="#local-6989586621682615903"><span class="hs-identifier hs-var">binds</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-586"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (HsBind GhcTc) -&gt; Bool)
-&gt; [GenLocated SrcSpanAnnA (HsBind GhcTc)] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">any</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HsBind GhcTc -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyPatBind"><span class="hs-identifier hs-var">looksLazyPatBind</span></a></span><span> </span><span class="annot"><span class="annottext">(HsBind GhcTc -&gt; Bool)
-&gt; (GenLocated SrcSpanAnnA (HsBind GhcTc) -&gt; HsBind GhcTc)
-&gt; GenLocated SrcSpanAnnA (HsBind GhcTc)
-&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (HsBind GhcTc) -&gt; HsBind GhcTc
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">LHsBinds GhcTc
[GenLocated SrcSpanAnnA (HsBind GhcTc)]
</span><a href="#local-6989586621682615903"><span class="hs-identifier hs-var">binds</span></a></span><span>
</span><span id="line-587"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPatBind"><span class="hs-identifier hs-var">looksLazyPatBind</span></a></span><span> </span><span class="annot"><span class="annottext">HsBind GhcTc
</span><span class="hs-identifier">_</span></span><span>
</span><span id="line-588"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-589"></span><span>
</span><span id="line-590"></span><span id="local-6989586621682615905"><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyLPat"><span class="hs-identifier hs-type">looksLazyLPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615905"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-591"></span><span id="looksLazyLPat"><span class="annot"><span class="annottext">looksLazyLPat :: forall (p :: Pass). LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyLPat"><span class="hs-identifier hs-var hs-var">looksLazyLPat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; Bool
forall (p :: Pass). Pat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-var">looksLazyPat</span></a></span><span> </span><span class="annot"><span class="annottext">(Pat (GhcPass p) -&gt; Bool)
-&gt; (GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Pat (GhcPass p))
-&gt; GenLocated SrcSpanAnnA (Pat (GhcPass p))
-&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Pat (GhcPass p)
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span>
</span><span id="line-592"></span><span>
</span><span id="line-593"></span><span id="local-6989586621682615907"><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-type">looksLazyPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615907"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-594"></span><span id="looksLazyPat"><span class="annot"><span class="annottext">looksLazyPat :: forall (p :: Pass). Pat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-var hs-var">looksLazyPat</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615908"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615908"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
forall (p :: Pass). LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyLPat"><span class="hs-identifier hs-var">looksLazyLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615908"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-595"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-var">looksLazyPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#AsPat"><span class="hs-identifier hs-type">AsPat</span></a></span><span> </span><span class="annot"><span class="annottext">XAsPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615909"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615909"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
forall (p :: Pass). LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyLPat"><span class="hs-identifier hs-var">looksLazyLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615909"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-596"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-var">looksLazyPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-597"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-var">looksLazyPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#VarPat"><span class="hs-identifier hs-type">VarPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-598"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-var">looksLazyPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#WildPat"><span class="hs-identifier hs-type">WildPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-599"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-var">looksLazyPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-600"></span><span>
</span><span id="line-601"></span><span class="hs-comment">{-
Note [-XStrict and irrefutability]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When -XStrict is enabled the rules for irrefutability are slightly modified.
Specifically, the pattern in a program like

    do ~(Just hi) &lt;- expr

cannot be considered irrefutable. The ~ here merely disables the bang that
-XStrict would usually apply, rendering the program equivalent to the following
without -XStrict

    do Just hi &lt;- expr

To achieve make this pattern irrefutable with -XStrict the user would rather
need to write

    do ~(~(Just hi)) &lt;- expr

Failing to account for this resulted in #19027. To fix this isIrrefutableHsPat
takes care to check for two the irrefutability of the inner pattern when it
encounters a LazyPat and -XStrict is enabled.

See also Note [decideBangHood] in GHC.HsToCore.Utils.
-}</span><span>
</span><span id="line-626"></span><span>
</span><span id="line-627"></span><span class="hs-comment">-- | @isIrrefutableHsPat p@ is true if matching against @p@ cannot fail</span><span>
</span><span id="line-628"></span><span class="hs-comment">-- in the sense of falling through to the next pattern.</span><span>
</span><span id="line-629"></span><span class="hs-comment">--      (NB: this is not quite the same as the (silly) defn</span><span>
</span><span id="line-630"></span><span class="hs-comment">--      in 3.17.2 of the Haskell 98 report.)</span><span>
</span><span id="line-631"></span><span class="hs-comment">--</span><span>
</span><span id="line-632"></span><span class="hs-comment">-- If isIrrefutableHsPat returns 'True', the pattern is definitely irrefutable.</span><span>
</span><span id="line-633"></span><span class="hs-comment">--</span><span>
</span><span id="line-634"></span><span class="hs-comment">-- However, isIrrefutableHsPat returns 'False' if it's in doubt. It's a</span><span>
</span><span id="line-635"></span><span class="hs-comment">-- best effort guess with the information we have available:</span><span>
</span><span id="line-636"></span><span class="hs-comment">--</span><span>
</span><span id="line-637"></span><span class="hs-comment">--  - we sometimes call 'isIrrefutableHsPat' from the renamer, in which case</span><span>
</span><span id="line-638"></span><span class="hs-comment">--    we don't have type information to hand. This means we can't properly</span><span>
</span><span id="line-639"></span><span class="hs-comment">--    handle GADTs, nor the result TyCon of COMPLETE pragmas.</span><span>
</span><span id="line-640"></span><span class="hs-comment">--  - even when calling 'isIrrefutableHsPat' in the typechecker, we don't keep</span><span>
</span><span id="line-641"></span><span class="hs-comment">--    track of any long distance information like the pattern-match checker does.</span><span>
</span><span id="line-642"></span><span class="annot"><a href="GHC.Hs.Pat.html#isIrrefutableHsPat"><span class="hs-identifier hs-type">isIrrefutableHsPat</span></a></span><span>
</span><span id="line-643"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621682615149"><span class="annot"><a href="#local-6989586621682615149"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-644"></span><span>  </span><span class="hs-operator">.</span><span>  </span><span class="annot"><a href="GHC.Hs.Extension.html#IsPass"><span class="hs-identifier hs-type">IsPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615149"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-645"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>                           </span><span class="hs-comment">-- ^ Are we in a @-XStrict@ context?</span><span>
</span><span id="line-646"></span><span>                                    </span><span class="hs-comment">-- See Note [-XStrict and irrefutability]</span><span>
</span><span id="line-647"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConLikeP"><span class="hs-identifier hs-type">ConLikeP</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615149"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ How to check whether the 'ConLike' in a</span><span>
</span><span id="line-648"></span><span>                                    </span><span class="hs-comment">-- 'ConPat' pattern is irrefutable</span><span>
</span><span id="line-649"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615149"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>               </span><span class="annot"><span class="hs-comment">-- ^ The (located) pattern to check</span></span><span>
</span><span id="line-650"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>                           </span><span class="hs-comment">-- Is it irrefutable?</span><span>
</span><span id="line-651"></span><span id="isIrrefutableHsPat"><span class="annot"><span class="annottext">isIrrefutableHsPat :: forall (p :: Pass).
IsPass p =&gt;
Bool -&gt; (ConLikeP (GhcPass p) -&gt; Bool) -&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isIrrefutableHsPat"><span class="hs-identifier hs-var hs-var">isIrrefutableHsPat</span></a></span></span><span> </span><span id="local-6989586621682615919"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682615919"><span class="hs-identifier hs-var">is_strict</span></a></span></span><span> </span><span id="local-6989586621682615920"><span class="annot"><span class="annottext">ConLikeP (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615920"><span class="hs-identifier hs-var">irref_conLike</span></a></span></span><span> </span><span id="local-6989586621682615921"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615921"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Pat (GhcPass p)
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
GenLocated SrcSpanAnnA (Pat (GhcPass p))
</span><a href="#local-6989586621682615921"><span class="hs-identifier hs-var">pat</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-652"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-653"></span><span>    </span><span id="local-6989586621682615923"><span class="annot"><span class="annottext">goL :: GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Bool
</span><a href="#local-6989586621682615923"><span class="hs-identifier hs-var hs-var">goL</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-type">L</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpanAnnA
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615924"><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621682615924"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621682615924"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-654"></span><span>
</span><span id="line-655"></span><span>    </span><span class="annot"><a href="#local-6989586621682615922"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615149"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-656"></span><span>    </span><span id="local-6989586621682615922"><span class="annot"><span class="annottext">go :: Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615922"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#WildPat"><span class="hs-identifier hs-type">WildPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-657"></span><span>    </span><span class="annot"><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#VarPat"><span class="hs-identifier hs-type">VarPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-658"></span><span>    </span><span class="annot"><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LazyPat"><span class="hs-identifier hs-type">LazyPat</span></a></span><span> </span><span class="annot"><span class="annottext">XLazyPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615925"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615925"><span class="hs-identifier hs-var">p'</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-659"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682615919"><span class="hs-identifier hs-var">is_strict</span></a></span><span>
</span><span id="line-660"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; (ConLikeP (GhcPass p) -&gt; Bool) -&gt; LPat (GhcPass p) -&gt; Bool
forall (p :: Pass).
IsPass p =&gt;
Bool -&gt; (ConLikeP (GhcPass p) -&gt; Bool) -&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isIrrefutableHsPat"><span class="hs-identifier hs-var">isIrrefutableHsPat</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="annot"><span class="annottext">ConLikeP (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615920"><span class="hs-identifier hs-var">irref_conLike</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615925"><span class="hs-identifier hs-var">p'</span></a></span><span>
</span><span id="line-661"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-662"></span><span>    </span><span class="annot"><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="annot"><span class="annottext">XBangPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615926"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615926"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Bool
</span><a href="#local-6989586621682615923"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
GenLocated SrcSpanAnnA (Pat (GhcPass p))
</span><a href="#local-6989586621682615926"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-663"></span><span>    </span><span class="annot"><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615927"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615927"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Bool
</span><a href="#local-6989586621682615923"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
GenLocated SrcSpanAnnA (Pat (GhcPass p))
</span><a href="#local-6989586621682615927"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-664"></span><span>    </span><span class="annot"><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#AsPat"><span class="hs-identifier hs-type">AsPat</span></a></span><span> </span><span class="annot"><span class="annottext">XAsPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615928"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615928"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Bool
</span><a href="#local-6989586621682615923"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
GenLocated SrcSpanAnnA (Pat (GhcPass p))
</span><a href="#local-6989586621682615928"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-665"></span><span>    </span><span class="annot"><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ViewPat"><span class="hs-identifier hs-type">ViewPat</span></a></span><span> </span><span class="annot"><span class="annottext">XViewPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615929"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615929"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Bool
</span><a href="#local-6989586621682615923"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
GenLocated SrcSpanAnnA (Pat (GhcPass p))
</span><a href="#local-6989586621682615929"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-666"></span><span>    </span><span class="annot"><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SigPat"><span class="hs-identifier hs-type">SigPat</span></a></span><span> </span><span class="annot"><span class="annottext">XSigPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615930"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615930"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="annot"><span class="annottext">HsPatSigType (NoGhcTc (GhcPass p))
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Bool
</span><a href="#local-6989586621682615923"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
GenLocated SrcSpanAnnA (Pat (GhcPass p))
</span><a href="#local-6989586621682615930"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-667"></span><span>    </span><span class="annot"><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#TuplePat"><span class="hs-identifier hs-type">TuplePat</span></a></span><span> </span><span class="annot"><span class="annottext">XTuplePat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615931"><span class="annot"><span class="annottext">[LPat (GhcPass p)]
</span><a href="#local-6989586621682615931"><span class="hs-identifier hs-var">pats</span></a></span></span><span> </span><span class="annot"><span class="annottext">Boxity
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Bool)
-&gt; [GenLocated SrcSpanAnnA (Pat (GhcPass p))] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Bool
</span><a href="#local-6989586621682615923"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">[LPat (GhcPass p)]
[GenLocated SrcSpanAnnA (Pat (GhcPass p))]
</span><a href="#local-6989586621682615931"><span class="hs-identifier hs-var">pats</span></a></span><span>
</span><span id="line-668"></span><span>    </span><span class="annot"><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#OrPat"><span class="hs-identifier hs-type">OrPat</span></a></span><span> </span><span class="annot"><span class="annottext">XOrPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615933"><span class="annot"><span class="annottext">NonEmpty (LPat (GhcPass p))
</span><a href="#local-6989586621682615933"><span class="hs-identifier hs-var">pats</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Bool)
-&gt; NonEmpty (GenLocated SrcSpanAnnA (Pat (GhcPass p))) -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">any</span></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Bool
</span><a href="#local-6989586621682615923"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">NonEmpty (LPat (GhcPass p))
NonEmpty (GenLocated SrcSpanAnnA (Pat (GhcPass p)))
</span><a href="#local-6989586621682615933"><span class="hs-identifier hs-var">pats</span></a></span><span> </span><span class="hs-comment">-- This is simplistic; see Note [Irrefutable or-patterns]</span><span>
</span><span id="line-669"></span><span>    </span><span class="annot"><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SumPat"><span class="hs-identifier hs-type">SumPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-comment">-- See Note [Unboxed sum patterns aren't irrefutable]</span><span>
</span><span id="line-670"></span><span>    </span><span class="annot"><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ListPat"><span class="hs-identifier hs-type">ListPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-671"></span><span>
</span><span id="line-672"></span><span>    </span><span class="hs-comment">-- See Note [Irrefutability of ConPat]</span><span>
</span><span id="line-673"></span><span>    </span><span class="annot"><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConPat"><span class="hs-identifier hs-type">ConPat</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pat_con :: forall p. Pat p -&gt; XRec p (ConLikeP p)
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con"><span class="hs-identifier hs-var">pat_con</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-type">L</span></a></span><span> </span><span class="annot"><span class="annottext">Anno (ConLikeP (GhcPass p))
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615934"><span class="annot"><span class="annottext">ConLikeP (GhcPass p)
</span><a href="#local-6989586621682615934"><span class="hs-identifier hs-var">con</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pat_args :: forall p. Pat p -&gt; HsConPatDetails p
</span><a href="Language.Haskell.Syntax.Pat.html#pat_args"><span class="hs-identifier hs-var">pat_args</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621682615935"><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621682615935"><span class="hs-identifier hs-var">details</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-674"></span><span>                           </span><span class="hs-glyph">=</span><span>  </span><span class="annot"><span class="annottext">ConLikeP (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615920"><span class="hs-identifier hs-var">irref_conLike</span></a></span><span> </span><span class="annot"><span class="annottext">ConLikeP (GhcPass p)
</span><a href="#local-6989586621682615934"><span class="hs-identifier hs-var">con</span></a></span><span>
</span><span id="line-675"></span><span>                           </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Bool)
-&gt; [GenLocated SrcSpanAnnA (Pat (GhcPass p))] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Bool
</span><a href="#local-6989586621682615923"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p) -&gt; [LPat (GhcPass p)]
forall p. UnXRec p =&gt; HsConPatDetails p -&gt; [LPat p]
</span><a href="Language.Haskell.Syntax.Pat.html#hsConPatArgs"><span class="hs-identifier hs-var">hsConPatArgs</span></a></span><span> </span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621682615935"><span class="hs-identifier hs-var">details</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-676"></span><span>    </span><span class="annot"><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LitPat"><span class="hs-identifier hs-type">LitPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-677"></span><span>    </span><span class="annot"><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-678"></span><span>    </span><span class="annot"><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPlusKPat"><span class="hs-identifier hs-type">NPlusKPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-679"></span><span>
</span><span id="line-680"></span><span>    </span><span class="hs-comment">-- We conservatively assume that no TH splices are irrefutable</span><span>
</span><span id="line-681"></span><span>    </span><span class="hs-comment">-- since we cannot know until the splice is evaluated.</span><span>
</span><span id="line-682"></span><span>    </span><span class="annot"><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SplicePat"><span class="hs-identifier hs-type">SplicePat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-683"></span><span>
</span><span id="line-684"></span><span>    </span><span class="hs-comment">-- The behavior of this case is unimportant, as GHC will throw an error shortly</span><span>
</span><span id="line-685"></span><span>    </span><span class="hs-comment">-- after reaching this case for other reasons (see TcRnIllegalTypePattern).</span><span>
</span><span id="line-686"></span><span>    </span><span class="annot"><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#EmbTyPat"><span class="hs-identifier hs-type">EmbTyPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-687"></span><span>    </span><span class="annot"><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#InvisPat"><span class="hs-identifier hs-type">InvisPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-688"></span><span>
</span><span id="line-689"></span><span>    </span><span class="annot"><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XPat"><span class="hs-identifier hs-type">XPat</span></a></span><span> </span><span id="local-6989586621682615937"><span class="annot"><span class="annottext">XXPat (GhcPass p)
</span><a href="#local-6989586621682615937"><span class="hs-identifier hs-var">ext</span></a></span></span><span class="hs-special">)</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621682615149"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-690"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">XXPat (GhcPass p)
</span><a href="#local-6989586621682615937"><span class="hs-identifier hs-var">ext</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-691"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#HsPatExpanded"><span class="hs-identifier hs-type">HsPatExpanded</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615939"><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621682615939"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621682615939"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-692"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">XXPat (GhcPass p)
</span><a href="#local-6989586621682615937"><span class="hs-identifier hs-var">ext</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-693"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier hs-type">CoPat</span></a></span><span> </span><span class="annot"><span class="annottext">HsWrapper
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615941"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621682615941"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
Pat GhcTc
</span><a href="#local-6989586621682615941"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-694"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#ExpansionPat"><span class="hs-identifier hs-type">ExpansionPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615942"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621682615942"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615922"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
Pat GhcTc
</span><a href="#local-6989586621682615942"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-695"></span><span>
</span><span id="line-696"></span><span class="hs-comment">-- | Is the pattern any of combination of:</span><span>
</span><span id="line-697"></span><span class="hs-comment">--</span><span>
</span><span id="line-698"></span><span class="hs-comment">-- - (pat)</span><span>
</span><span id="line-699"></span><span class="hs-comment">-- - pat :: Type</span><span>
</span><span id="line-700"></span><span class="hs-comment">-- - ~pat</span><span>
</span><span id="line-701"></span><span class="hs-comment">-- - !pat</span><span>
</span><span id="line-702"></span><span class="hs-comment">-- - x (variable)</span><span>
</span><span id="line-703"></span><span id="local-6989586621682615152"><span class="annot"><a href="GHC.Hs.Pat.html#isSimplePat"><span class="hs-identifier hs-type">isSimplePat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615152"><span class="hs-identifier hs-type">x</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615152"><span class="hs-identifier hs-type">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span>
</span><span id="line-704"></span><span id="isSimplePat"><span class="annot"><span class="annottext">isSimplePat :: forall (x :: Pass). LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
</span><a href="GHC.Hs.Pat.html#isSimplePat"><span class="hs-identifier hs-var hs-var">isSimplePat</span></a></span></span><span> </span><span id="local-6989586621682615943"><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621682615943"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass x)) -&gt; Pat (GhcPass x)
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x)
GenLocated SrcSpanAnnA (Pat (GhcPass x))
</span><a href="#local-6989586621682615943"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-705"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass x)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615944"><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621682615944"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
forall (x :: Pass). LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
</span><a href="GHC.Hs.Pat.html#isSimplePat"><span class="hs-identifier hs-var">isSimplePat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621682615944"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-706"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SigPat"><span class="hs-identifier hs-type">SigPat</span></a></span><span> </span><span class="annot"><span class="annottext">XSigPat (GhcPass x)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615945"><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621682615945"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="annot"><span class="annottext">HsPatSigType (NoGhcTc (GhcPass x))
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
forall (x :: Pass). LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
</span><a href="GHC.Hs.Pat.html#isSimplePat"><span class="hs-identifier hs-var">isSimplePat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621682615945"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-707"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LazyPat"><span class="hs-identifier hs-type">LazyPat</span></a></span><span> </span><span class="annot"><span class="annottext">XLazyPat (GhcPass x)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615946"><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621682615946"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
forall (x :: Pass). LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
</span><a href="GHC.Hs.Pat.html#isSimplePat"><span class="hs-identifier hs-var">isSimplePat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621682615946"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-708"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="annot"><span class="annottext">XBangPat (GhcPass x)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615947"><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621682615947"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
forall (x :: Pass). LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
</span><a href="GHC.Hs.Pat.html#isSimplePat"><span class="hs-identifier hs-var">isSimplePat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621682615947"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-709"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#VarPat"><span class="hs-identifier hs-type">VarPat</span></a></span><span> </span><span class="annot"><span class="annottext">XVarPat (GhcPass x)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615948"><span class="annot"><span class="annottext">LIdP (GhcPass x)
</span><a href="#local-6989586621682615948"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">IdGhcP x -&gt; Maybe (IdGhcP x)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">GenLocated (Anno (IdGhcP x)) (IdGhcP x) -&gt; IdGhcP x
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass x)
GenLocated (Anno (IdGhcP x)) (IdGhcP x)
</span><a href="#local-6989586621682615948"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-710"></span><span>  </span><span class="annot"><span class="annottext">Pat (GhcPass x)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe (IdP (GhcPass x))
Maybe (IdGhcP x)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-711"></span><span>
</span><span id="line-712"></span><span class="hs-comment">-- | Is this pattern boring from the perspective of pattern-match checking,</span><span>
</span><span id="line-713"></span><span class="hs-comment">-- i.e. introduces no new pieces of long-distance information</span><span>
</span><span id="line-714"></span><span class="hs-comment">-- which could influence pattern-match checking?</span><span>
</span><span id="line-715"></span><span class="hs-comment">--</span><span>
</span><span id="line-716"></span><span class="hs-comment">-- See Note [Boring patterns].</span><span>
</span><span id="line-717"></span><span class="annot"><a href="GHC.Hs.Pat.html#isBoringHsPat"><span class="hs-identifier hs-type">isBoringHsPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621682615154"><span class="annot"><a href="#local-6989586621682615154"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615154"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615154"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-718"></span><span class="hs-comment">-- NB: it's always safe to return 'False' in this function; that just means</span><span>
</span><span id="line-719"></span><span class="hs-comment">-- performing potentially-redundant pattern-match checking.</span><span>
</span><span id="line-720"></span><span id="isBoringHsPat"><span class="annot"><span class="annottext">isBoringHsPat :: forall (p :: Pass). OutputableBndrId p =&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isBoringHsPat"><span class="hs-identifier hs-var hs-var">isBoringHsPat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
forall (p :: Pass). OutputableBndrId p =&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615951"><span class="hs-identifier hs-var">goL</span></a></span><span>
</span><span id="line-721"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-722"></span><span>    </span><span class="annot"><a href="#local-6989586621682615951"><span class="hs-identifier hs-type">goL</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621682615952"><span class="annot"><a href="#local-6989586621682615952"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615952"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615952"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-723"></span><span>    </span><span id="local-6989586621682615951"><span class="annot"><span class="annottext">goL :: forall (p :: Pass). OutputableBndrId p =&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615951"><span class="hs-identifier hs-var hs-var">goL</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; Bool
forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615955"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">(Pat (GhcPass p) -&gt; Bool)
-&gt; (GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Pat (GhcPass p))
-&gt; GenLocated SrcSpanAnnA (Pat (GhcPass p))
-&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Pat (GhcPass p)
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span>
</span><span id="line-724"></span><span>
</span><span id="line-725"></span><span>    </span><span class="annot"><a href="#local-6989586621682615955"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621682615157"><span class="annot"><a href="#local-6989586621682615157"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615157"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615157"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-726"></span><span>    </span><span id="local-6989586621682615955"><span class="annot"><span class="annottext">go :: forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615955"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-727"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#WildPat"><span class="hs-identifier hs-type">WildPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-728"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#VarPat"><span class="hs-identifier hs-type">VarPat</span></a></span><span>  </span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-729"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LazyPat"><span class="hs-identifier hs-type">LazyPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-730"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="annot"><span class="annottext">XBangPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615971"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615971"><span class="hs-identifier hs-var">pat</span></a></span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
forall (p :: Pass). OutputableBndrId p =&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615951"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615971"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-731"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615972"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615972"><span class="hs-identifier hs-var">pat</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
forall (p :: Pass). OutputableBndrId p =&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615951"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615972"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-732"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#AsPat"><span class="hs-identifier hs-type">AsPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-comment">-- the pattern x@y links x and y together,</span><span>
</span><span id="line-733"></span><span>                        </span><span class="hs-comment">-- which is a nontrivial piece of information</span><span>
</span><span id="line-734"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ViewPat"><span class="hs-identifier hs-type">ViewPat</span></a></span><span> </span><span class="annot"><span class="annottext">XViewPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615973"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615973"><span class="hs-identifier hs-var">pat</span></a></span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
forall (p :: Pass). OutputableBndrId p =&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615951"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615973"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-735"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SigPat"><span class="hs-identifier hs-type">SigPat</span></a></span><span> </span><span class="annot"><span class="annottext">XSigPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615974"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615974"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="annot"><span class="annottext">HsPatSigType (NoGhcTc (GhcPass p))
</span><span class="hs-identifier">_</span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
forall (p :: Pass). OutputableBndrId p =&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615951"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615974"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-736"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#TuplePat"><span class="hs-identifier hs-type">TuplePat</span></a></span><span> </span><span class="annot"><span class="annottext">XTuplePat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615975"><span class="annot"><span class="annottext">[LPat (GhcPass p)]
</span><a href="#local-6989586621682615975"><span class="hs-identifier hs-var">pats</span></a></span></span><span> </span><span class="annot"><span class="annottext">Boxity
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Bool)
-&gt; [GenLocated SrcSpanAnnA (Pat (GhcPass p))] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Bool
forall (p :: Pass). OutputableBndrId p =&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615951"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">[LPat (GhcPass p)]
[GenLocated SrcSpanAnnA (Pat (GhcPass p))]
</span><a href="#local-6989586621682615975"><span class="hs-identifier hs-var">pats</span></a></span><span>
</span><span id="line-737"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SumPat"><span class="hs-identifier hs-type">SumPat</span></a></span><span>  </span><span class="annot"><span class="annottext">XSumPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615976"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615976"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
forall (p :: Pass). OutputableBndrId p =&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615951"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682615976"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-738"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ListPat"><span class="hs-identifier hs-type">ListPat</span></a></span><span> </span><span class="annot"><span class="annottext">XListPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615977"><span class="annot"><span class="annottext">[LPat (GhcPass p)]
</span><a href="#local-6989586621682615977"><span class="hs-identifier hs-var">pats</span></a></span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Bool)
-&gt; [GenLocated SrcSpanAnnA (Pat (GhcPass p))] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Bool
forall (p :: Pass). OutputableBndrId p =&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615951"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">[LPat (GhcPass p)]
[GenLocated SrcSpanAnnA (Pat (GhcPass p))]
</span><a href="#local-6989586621682615977"><span class="hs-identifier hs-var">pats</span></a></span><span>
</span><span id="line-739"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConPat"><span class="hs-identifier hs-type">ConPat</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pat_con :: forall p. Pat p -&gt; XRec p (ConLikeP p)
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con"><span class="hs-identifier hs-var">pat_con</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621682615978"><span class="annot"><span class="annottext">XRec (GhcPass p) (ConLikeP (GhcPass p))
</span><a href="#local-6989586621682615978"><span class="hs-identifier hs-var">con</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pat_args :: forall p. Pat p -&gt; HsConPatDetails p
</span><a href="Language.Haskell.Syntax.Pat.html#pat_args"><span class="hs-identifier hs-var">pat_args</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621682615979"><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621682615979"><span class="hs-identifier hs-var">details</span></a></span></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-740"></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621682615157"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-741"></span><span>            </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-var">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-comment">-- conservative</span><span>
</span><span id="line-742"></span><span>            </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-comment">-- conservative</span><span>
</span><span id="line-743"></span><span>            </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span>
</span><span id="line-744"></span><span>              </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">ConLike -&gt; Bool
</span><a href="GHC.Core.ConLike.html#isVanillaConLike"><span class="hs-identifier hs-var">isVanillaConLike</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN ConLike -&gt; ConLike
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (ConLikeP (GhcPass p))
GenLocated SrcSpanAnnN ConLike
</span><a href="#local-6989586621682615978"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-745"></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (Pat GhcTc) -&gt; Bool)
-&gt; [GenLocated SrcSpanAnnA (Pat GhcTc)] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bool
GenLocated SrcSpanAnnA (Pat GhcTc) -&gt; Bool
forall (p :: Pass). OutputableBndrId p =&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615951"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p) -&gt; [LPat (GhcPass p)]
forall p. UnXRec p =&gt; HsConPatDetails p -&gt; [LPat p]
</span><a href="Language.Haskell.Syntax.Pat.html#hsConPatArgs"><span class="hs-identifier hs-var">hsConPatArgs</span></a></span><span> </span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621682615979"><span class="hs-identifier hs-var">details</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-746"></span><span>              </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-747"></span><span>              </span><span class="hs-comment">-- A pattern match on a GADT constructor can introduce</span><span>
</span><span id="line-748"></span><span>              </span><span class="hs-comment">-- type-level information (for example, T18572).</span><span>
</span><span id="line-749"></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-750"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#OrPat"><span class="hs-identifier hs-type">OrPat</span></a></span><span> </span><span class="annot"><span class="annottext">XOrPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615988"><span class="annot"><span class="annottext">NonEmpty (LPat (GhcPass p))
</span><a href="#local-6989586621682615988"><span class="hs-identifier hs-var">pats</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Bool)
-&gt; NonEmpty (GenLocated SrcSpanAnnA (Pat (GhcPass p))) -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Bool
forall (p :: Pass). OutputableBndrId p =&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615951"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">NonEmpty (LPat (GhcPass p))
NonEmpty (GenLocated SrcSpanAnnA (Pat (GhcPass p)))
</span><a href="#local-6989586621682615988"><span class="hs-identifier hs-var">pats</span></a></span><span>
</span><span id="line-751"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LitPat"><span class="hs-identifier hs-type">LitPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-752"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-753"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPlusKPat"><span class="hs-identifier hs-type">NPlusKPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-754"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SplicePat"><span class="hs-identifier hs-type">SplicePat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-755"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#EmbTyPat"><span class="hs-identifier hs-type">EmbTyPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-756"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#InvisPat"><span class="hs-identifier hs-type">InvisPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-757"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XPat"><span class="hs-identifier hs-type">XPat</span></a></span><span> </span><span id="local-6989586621682615989"><span class="annot"><span class="annottext">XXPat (GhcPass p)
</span><a href="#local-6989586621682615989"><span class="hs-identifier hs-var">ext</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-758"></span><span>        </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621682615157"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-759"></span><span>         </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">XXPat (GhcPass p)
</span><a href="#local-6989586621682615989"><span class="hs-identifier hs-var">ext</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-760"></span><span>           </span><span class="annot"><a href="GHC.Hs.Pat.html#HsPatExpanded"><span class="hs-identifier hs-type">HsPatExpanded</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615993"><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621682615993"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat GhcRn -&gt; Bool
forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615955"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621682615993"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-761"></span><span>         </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">XXPat (GhcPass p)
</span><a href="#local-6989586621682615989"><span class="hs-identifier hs-var">ext</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-762"></span><span>           </span><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier hs-type">CoPat</span></a></span><span> </span><span class="annot"><span class="annottext">HsWrapper
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615998"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621682615998"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat GhcTc -&gt; Bool
forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615955"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621682615998"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-763"></span><span>           </span><span class="annot"><a href="GHC.Hs.Pat.html#ExpansionPat"><span class="hs-identifier hs-type">ExpansionPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682615999"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621682615999"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat GhcTc -&gt; Bool
forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621682615955"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621682615999"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-764"></span><span>
</span><span id="line-765"></span><span class="annot"><a href="GHC.Hs.Pat.html#isPatSyn"><span class="hs-identifier hs-type">isPatSyn</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-766"></span><span id="isPatSyn"><span class="annot"><span class="annottext">isPatSyn :: LPat GhcTc -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isPatSyn"><span class="hs-identifier hs-var hs-var">isPatSyn</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-type">L</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpanAnnA
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConPat"><span class="hs-identifier hs-type">ConPat</span></a></span><span> </span><span class="hs-special">{</span><span class="annot"><span class="annottext">pat_con :: forall p. Pat p -&gt; XRec p (ConLikeP p)
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con"><span class="hs-identifier hs-var">pat_con</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-type">L</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpanAnnN
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Core.ConLike.html#PatSynCon"><span class="hs-identifier hs-type">PatSynCon</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span class="hs-special">}</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-767"></span><span class="annot"><a href="GHC.Hs.Pat.html#isPatSyn"><span class="hs-identifier hs-var">isPatSyn</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-768"></span><span>
</span><span id="line-769"></span><span class="hs-comment">{- Note [Irrefutability of ConPat]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
A constructor pattern `ConPat { pat_con, pat_args }` is irrefutable under two
conditions:

  Irref-ConLike: the constructor, pat_con, is itself irrefutable.
  Irref-args   : all of the argument patterns, pat_args, are irrefutable.

The (Irref-ConLike) condition can be stated as follows:

  Irref-DataCon: a DataCon is irrefutable iff it is the only constructor of its
                 parent type constructor.
  Irref-PatSyn:  a PatSyn is irrefutable iff there is a COMPLETE pragma
                 containing this PatSyn as its sole member.

To understand this, let's consider some simple examples:

  data A = MkA Int Bool
  data BC = B Int | C

  pattern P :: Maybe Int -&gt; BC
  pattern P mb_i &lt;- ( ( \ case { B i -&gt; Just i; C -&gt; Nothing } ) -&gt; mb_i )
  {-# COMPLETE P #-}

In this case:

  - the pattern 'A p1 p2' (for patterns 'p1 :: Int', 'p2 :: Bool') is irrefutable
    precisely when both 'p1' and 'p2' are irrefutable (this is the same as
    irrefutability of tuple patterns);
  - neither of the patterns 'B p' (for any pattern 'p :: Int') or 'C' are irrefutable,
    because the parent type constructor 'BC' contains more than one data constructor,
  - the pattern 'P q', for a pattern 'q :: Maybe Int', is irrefutable precisely
    when 'q' is irrefutable, due to the COMPLETE pragma on 'P'.

Wrinkle [Irrefutability and COMPLETE pragma result TyCons]

  There is one subtlety in the Irref-PatSyn condition: COMPLETE pragmas may
  optionally specify a result TyCon, as explained in Note [Implementation of COMPLETE pragmas]
  in GHC.HsToCore.Pmc.Solver.

  So, for a COMPLETE pragma with a result TyCon, we would need to compute
  'completeMatchAppliesAtType' to ensure that the COMPLETE pragma is indeed
  applicable. Doing so is not so straightforward in 'isIrrefutableHsPat', for
  a couple of reasons:

    1. 'isIrrefutableHsPat' is called from within the renamer, which means
       we don't have the appropriate 'Type' to hand,
    2. Even when 'isIrrefutableHsPat' is called from within the typechecker,
       computing 'completeMatchAppliesAtType' for a 'ConPat' which might be
       nested deep inside the top-level call, such as

          ( ( _ , P (x :: Int) ) :: ( Int, Int )

        would require keeping track of types as we recur in 'isIrrefutableHsPat',
        which would be much more involved and require duplicating code from
        the pattern match checker (it performs this check using the notion
        of &quot;match variables&quot;, which we don't have in the typechecker).

Note [Irrefutable or-patterns]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When is an or-pattern ( p_1 ; ... ; p_n ) irrefutable? It certainly suffices
that individual pattern p_i is irrefutable, but it isn't necessary.

For example, with the datatype definition

  data ABC = A | B | C

the or-pattern ( B ; C ; A ) is irrefutable. Similarly, one can take into
account COMPLETE pragmas, e.g. (P ; R ; Q) is irrefutable in the presence of
{-# COMPLETE P, Q, R #-}. This would extend Note [Irrefutability of ConPat] to
the case of disjunctions of constructor patterns.

For now, the function 'isIrrefutableHsPat' does not take into account these
additional complications, and considers an or-pattern irrefutable precisely when
any of the summands are irrefutable. This pessimistic behaviour is OK: the contract
of 'isIrrefutableHsPat' is that it can only return 'True' for definitely irrefutable
patterns, but may conservatively return 'False' in other cases.

The justification for this design choice is as follows:

  1. Producing the correct answer in all cases would be rather difficult,
     for example for a complex pattern such as ( P ; !( R ; S ; ( Q :: Ty ) ) ).
  2. Irrefutable or-patterns aren't particularly common or useful, given that
     (currently) or-patterns aren't allowed to bind variables.

Note [Unboxed sum patterns aren't irrefutable]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Unlike unboxed tuples, unboxed sums are *not* irrefutable when used as
patterns. A simple example that demonstrates this is from #14228:

  pattern Just' x = (# x | #)
  pattern Nothing' = (# | () #)

  foo x = case x of
    Nothing' -&gt; putStrLn &quot;nothing&quot;
    Just'    -&gt; putStrLn &quot;just&quot;

In foo, the pattern Nothing' (that is, (# x | #)) is certainly not irrefutable,
as does not match an unboxed sum value of the same arity&#8212;namely, (# | y #)
(covered by Just'). In fact, no unboxed sum pattern is irrefutable, since the
minimum unboxed sum arity is 2.

Failing to mark unboxed sum patterns as non-irrefutable would cause the Just'
case in foo to be unreachable, as GHC would mistakenly believe that Nothing'
is the only thing that could possibly be matched!

Note [Boring patterns]
~~~~~~~~~~~~~~~~~~~~~~
A pattern is called boring when no new information is gained upon successfully
matching on the pattern.

Some examples of boring patterns:

  - x, for a variable x. We learn nothing about x upon matching this pattern.
  - Just y. This pattern can fail, but if it matches, we don't learn anything
    about y.

Some examples of non-boring patterns:

  - x@(Just y). A match on this pattern introduces the fact that x is headed
    by the constructor Just, which means that a subsequent pattern match such as

      case x of { Just z -&gt; ... }

    should not be marked as incomplete.
  - a@b. Matching on this pattern introduces a relation between 'a' and 'b',
    which means that we shouldn't emit any warnings in code of the form

      case a of
        True -&gt; case b of { True -&gt; .. } -- no warning here!
        False -&gt; ...
  - GADT patterns. For example, with the GADT

      data G i where { MkGInt :: G Int }

    a match on the pattern 'MkGInt' introduces type-level information:

      foo :: G i -&gt; i
      foo MkGInt = 3

    Here we learn that i ~ Int after matching on 'MkGInt', so this pattern
    is not boring.

When a pattern is boring, and we are only interested in additional long-distance
information (not whether the pattern itself is fallible), we can skip pattern-match
checking entirely. Doing this saves about 10% allocations in test T11195.

This happens when we are checking pattern-matches in do-notation, for example:

  do { x@(Just y) &lt;- z
     ; ...
     ; return $ case x of { Just w -&gt; ... } }

Here we *do not* want to emit a pattern-match warning on the first line for the
incomplete pattern-match, as incompleteness inside do-notation is handled
using MonadFail. However, we still want to propagate the fact that x is headed
by the 'Just' constructor, to avoid a pattern-match warning on the last line.

Note [Implementation of OrPatterns]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This Note describes the implementation of the extension -XOrPatterns.

* Proposal: https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0522-or-patterns.rst
* Discussion: https://github.com/ghc-proposals/ghc-proposals/pull/522 and others

Parser
------
We parse an or-pattern `pat_1; ...; pat_k` into `OrPat [pat_1, ..., pat_k]`,
where `OrPat` is a constructor of `Pat` in Language.Haskell.Syntax.Pat.
We occasionally refer to any of the `pat_k` as &quot;pattern alternatives&quot; below.
The changes to the parser are as outlined in Section 8.1 of the proposal.
The main productions are

  orpats -&gt; exp | exp ';' orpats
  aexp2 -&gt; '(' orpats ')'
  pat -&gt; orpats

Renamer and typechecker
-----------------------
The typing rule for or-patterns in terms of pattern types is

                   &#915;0, &#931;0 &#8866; pat_i : &#964; &#10547; &#915;0,&#931;i,&#936;i
            --------------------------------------------
            &#915;0, &#931;0 &#8866; ( pat_1; ...; pat_n ) : &#964; &#10547; &#915;0,&#931;0,&#8709;

(See the proposal for what a pattern type `&#915;, &#931; &#8866; pat : &#964; &#10547; &#915;,&#931;,&#936;` is.)
The main points

  * None of the patterns may bind any variables, hence the same &#915;0 in both input
    and output.
  * Any Given constraints bound by the pattern are discarded: the rule discards
    the &#931;i returned by each pattern.
  * Similarly any existentials &#936;i bound by the pattern are discarded.

In GHC.Rename.Pat.rnPatAndThen, we reject visible term and type binders (i.e.
concerning &#915;0).

Regarding the Givens &#931;i and existenials &#936;i (i.e. invisible type binders)
introduced by the pattern alternatives `pat_i`, we discard them in
GHC.Tc.Gen.Pats.tc_pat in a manner similar to LazyPats;
see Note [Hopping the LIE in lazy patterns].

Why is it useful to allow &#931;i and &#936;i only to discard them immediately after?
Consider

  data T a where MkT :: forall a x. Num a =&gt; x -&gt; T a
  foo :: T a -&gt; a
  foo (MkT{}; MkT{}) = 3

We do want to allow matching on MkT{} in or-patterns, despite them invisibly
binding an existential type variable `x` and a new Given constraint `Num a`.
Clearly, `x` must be dead in the RHS of foo, because there is no field binder
that brings it to life, so no harm done.
But we must be careful not to solve the `Num a` Wanted constraint in the RHS of
foo with the Given constraint from the pattern alternatives, hence we are
Hopping the LIE.

Desugarer
---------
The desugaring of or-patterns is complicated by the fact that we have to avoid
exponential code blowup. Consider
  f (LT; GT) (EQ; GT) = rhs1
  f _        _        = rhs2
The na&#239;ve desugaring of or-patterns would explode every or-pattern, thus
  f LT EQ = rhs1
  f LT GT = rhs1
  f GT EQ = rhs1
  f GT GT = rhs1
  f _  _  = rhs2
which leads to an exponential number of copies of `rhs1`.
Our current strategy, implemented in GHC.HsToCore.Match.tidy1, is to
desugar to LambdaCase and ViewPatterns,
  f ((\case LT -&gt; True; GT -&gt; True; _ -&gt; False) -&gt; True)
    ((\case EQ -&gt; True; GT -&gt; True; _ -&gt; False) -&gt; True)
    = rhs1
  f _ _ = rhs2
The existing code for ViewPatterns makes sure that we do not duplicate `rhs1`
and the Simplifier will take care to turn this into efficient code.

Pattern-match checker
---------------------
The changes to the pattern-match checker are described in detail in Section 4.9
of the 2024 revision of the &quot;Lower Your Guards&quot; paper.
What follows is a brief summary of that change.

The pattern-match checker desugars patterns as well, into syntactic variants of
*guard trees* such as `PmMatch`, describing a single Match `f ps | grhss`.
It used to be that each such guard trees nicely captured the effects of pattern
matching `ps` in a conjunctive list of `PmGrd`s, each of which refines
the set of Nablas that reach the RHS of the clause.
`PmGrd` is the heart of the Lower Your Guards approach: it is compositional,
simple, and *non-recursive*, unlike or-patterns!
Conjunction is implemented with the `...Pmc.Check.leftToRight` combinator.
But to desugar or-patterns, we need to compose with `Pmc.Check.topToBottom`
to model first match semantics!
This was previously impossible in the pattern fragment, and indeed is
incompatible with the simple &quot;list of `PmGrd`s&quot; desugaring of patterns.

So our solution is to generalise &quot;sequence of `PmGrd`&quot; into a series-parallel
graph `GrdDag`, a special kind of DAG, where &quot;series&quot; corresponds to
left-to-right sequence and &quot;parallel&quot; corresponds to top-to-bottom or-pattern
alternatives. Example

  f (LT; GT) True (EQ; GT) = rhs

desugars to

   /- LT &lt;- x -\             /- EQ &lt;- z -\
  .             . True &lt;- y .             .-&gt; rhs
   \- GT &lt;- x ./             \- GT &lt;- z -/

Branching is GdAlt and models first-match semantics of or-patterns, and
sequencing is GdSeq.

We must take care of exponential explosion of Covered sets for long matches like
  g (LT; GT) (LT; GT) ... True = 1
Fortunately, we can build on our existing throttling mechanism;
see Note [Countering exponential blowup] in GHC.HsToCore.Pmc.Check.
-}</span><span>
</span><span id="line-1048"></span><span>
</span><span id="line-1049"></span><span>
</span><span id="line-1050"></span><span class="hs-comment">-- | @'patNeedsParens' p pat@ returns 'True' if the pattern @pat@ needs</span><span>
</span><span id="line-1051"></span><span class="hs-comment">-- parentheses under precedence @p@.</span><span>
</span><span id="line-1052"></span><span class="annot"><a href="GHC.Hs.Pat.html#patNeedsParens"><span class="hs-identifier hs-type">patNeedsParens</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621682615036"><span class="annot"><a href="#local-6989586621682615036"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#IsPass"><span class="hs-identifier hs-type">IsPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615036"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#PprPrec"><span class="hs-identifier hs-type">PprPrec</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615036"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-1053"></span><span id="patNeedsParens"><span class="annot"><span class="annottext">patNeedsParens :: forall (p :: Pass). IsPass p =&gt; PprPrec -&gt; Pat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#patNeedsParens"><span class="hs-identifier hs-var hs-var">patNeedsParens</span></a></span></span><span> </span><span id="local-6989586621682616003"><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621682616003"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (q :: Pass). IsPass q =&gt; Pat (GhcPass q) -&gt; Bool
</span><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621682615036"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-1054"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1055"></span><span>    </span><span class="hs-comment">-- Remark: go needs to be polymorphic, as we call it recursively</span><span>
</span><span id="line-1056"></span><span>    </span><span class="hs-comment">-- at a different GhcPass (see the case for GhcTc XPat below).</span><span>
</span><span id="line-1057"></span><span>    </span><span class="annot"><a href="#local-6989586621682616004"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621682615160"><span class="annot"><a href="#local-6989586621682615160"><span class="hs-identifier hs-type">q</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#IsPass"><span class="hs-identifier hs-type">IsPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615160"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615160"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-1058"></span><span>    </span><span id="local-6989586621682616004"><span class="annot"><span class="annottext">go :: forall (q :: Pass). IsPass q =&gt; Pat (GhcPass q) -&gt; Bool
</span><a href="#local-6989586621682616004"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPlusKPat"><span class="hs-identifier hs-type">NPlusKPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621682616003"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; PprPrec -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;</span></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#opPrec"><span class="hs-identifier hs-var">opPrec</span></a></span><span>
</span><span id="line-1059"></span><span>    </span><span class="annot"><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#OrPat"><span class="hs-identifier hs-type">OrPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621682616003"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; PprPrec -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;</span></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#topPrec"><span class="hs-identifier hs-var">topPrec</span></a></span><span>
</span><span id="line-1060"></span><span>    </span><span class="annot"><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SplicePat"><span class="hs-identifier hs-type">SplicePat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1061"></span><span>    </span><span class="annot"><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConPat"><span class="hs-identifier hs-type">ConPat</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pat_args :: forall p. Pat p -&gt; HsConPatDetails p
</span><a href="Language.Haskell.Syntax.Pat.html#pat_args"><span class="hs-identifier hs-var">pat_args</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621682616016"><span class="annot"><span class="annottext">HsConPatDetails (GhcPass q)
</span><a href="#local-6989586621682616016"><span class="hs-identifier hs-var">ds</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-1062"></span><span>                         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec
-&gt; HsConDetails
     (HsConPatTyArg (GhcPass (NoGhcTcPass q)))
     (GenLocated SrcSpanAnnA (Pat (GhcPass q)))
     (HsRecFields
        (GhcPass q) (GenLocated SrcSpanAnnA (Pat (GhcPass q))))
-&gt; Bool
forall t a b. PprPrec -&gt; HsConDetails t a b -&gt; Bool
</span><a href="GHC.Hs.Pat.html#conPatNeedsParens"><span class="hs-identifier hs-var">conPatNeedsParens</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621682616003"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass q)
HsConDetails
  (HsConPatTyArg (GhcPass (NoGhcTcPass q)))
  (GenLocated SrcSpanAnnA (Pat (GhcPass q)))
  (HsRecFields
     (GhcPass q) (GenLocated SrcSpanAnnA (Pat (GhcPass q))))
</span><a href="#local-6989586621682616016"><span class="hs-identifier hs-var">ds</span></a></span><span>
</span><span id="line-1063"></span><span>    </span><span class="annot"><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SigPat"><span class="hs-identifier hs-type">SigPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621682616003"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; PprPrec -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;=</span></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#sigPrec"><span class="hs-identifier hs-var">sigPrec</span></a></span><span>
</span><span id="line-1064"></span><span>    </span><span class="annot"><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ViewPat"><span class="hs-identifier hs-type">ViewPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1065"></span><span>    </span><span class="annot"><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#EmbTyPat"><span class="hs-identifier hs-type">EmbTyPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1066"></span><span>    </span><span class="annot"><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#InvisPat"><span class="hs-identifier hs-type">InvisPat</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1067"></span><span>    </span><span class="annot"><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XPat"><span class="hs-identifier hs-type">XPat</span></a></span><span> </span><span id="local-6989586621682616019"><span class="annot"><span class="annottext">XXPat (GhcPass q)
</span><a href="#local-6989586621682616019"><span class="hs-identifier hs-var">ext</span></a></span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621682615160"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1068"></span><span>      </span><span class="annot"><span class="annottext">GhcPass q
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">XXPat (GhcPass q)
</span><a href="#local-6989586621682616019"><span class="hs-identifier hs-var">ext</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1069"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#HsPatExpanded"><span class="hs-identifier hs-type">HsPatExpanded</span></a></span><span> </span><span id="local-6989586621682616023"><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621682616023"><span class="hs-identifier hs-var">orig</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat GhcRn -&gt; Bool
forall (q :: Pass). IsPass q =&gt; Pat (GhcPass q) -&gt; Bool
</span><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621682616023"><span class="hs-identifier hs-var">orig</span></a></span><span>
</span><span id="line-1070"></span><span>      </span><span class="annot"><span class="annottext">GhcPass q
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">XXPat (GhcPass q)
</span><a href="#local-6989586621682616019"><span class="hs-identifier hs-var">ext</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1071"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier hs-type">CoPat</span></a></span><span> </span><span class="annot"><span class="annottext">HsWrapper
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682616029"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621682616029"><span class="hs-identifier hs-var">inner</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat GhcTc -&gt; Bool
forall (q :: Pass). IsPass q =&gt; Pat (GhcPass q) -&gt; Bool
</span><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621682616029"><span class="hs-identifier hs-var">inner</span></a></span><span>
</span><span id="line-1072"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#ExpansionPat"><span class="hs-identifier hs-type">ExpansionPat</span></a></span><span> </span><span id="local-6989586621682616030"><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621682616030"><span class="hs-identifier hs-var">orig</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat GhcRn -&gt; Bool
forall (q :: Pass). IsPass q =&gt; Pat (GhcPass q) -&gt; Bool
</span><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621682616030"><span class="hs-identifier hs-var">orig</span></a></span><span>
</span><span id="line-1073"></span><span>          </span><span class="hs-comment">--                   ^^^^^^^</span><span>
</span><span id="line-1074"></span><span>          </span><span class="hs-comment">-- NB: recursive call of go at a different GhcPass.</span><span>
</span><span id="line-1075"></span><span>    </span><span class="annot"><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#WildPat"><span class="hs-identifier hs-type">WildPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1076"></span><span>    </span><span class="annot"><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#VarPat"><span class="hs-identifier hs-type">VarPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1077"></span><span>    </span><span class="annot"><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LazyPat"><span class="hs-identifier hs-type">LazyPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1078"></span><span>    </span><span class="annot"><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1079"></span><span>    </span><span class="annot"><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1080"></span><span>    </span><span class="annot"><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#AsPat"><span class="hs-identifier hs-type">AsPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1081"></span><span>    </span><span class="hs-comment">-- Special-case unary boxed tuple applications so that they are</span><span>
</span><span id="line-1082"></span><span>    </span><span class="hs-comment">-- parenthesized as `Identity (Solo x)`, not `Identity Solo x` (#18612)</span><span>
</span><span id="line-1083"></span><span>    </span><span class="hs-comment">-- See Note [One-tuples] in GHC.Builtin.Types</span><span>
</span><span id="line-1084"></span><span>    </span><span class="annot"><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#TuplePat"><span class="hs-identifier hs-type">TuplePat</span></a></span><span> </span><span class="annot"><span class="annottext">XTuplePat (GhcPass q)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LPat (GhcPass q)
</span><span class="hs-identifier">_</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Boxity
</span><a href="Language.Haskell.Syntax.Basic.html#Boxed"><span class="hs-identifier hs-var">Boxed</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1085"></span><span>                         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621682616003"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; PprPrec -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;=</span></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span>
</span><span id="line-1086"></span><span>    </span><span class="annot"><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#TuplePat"><span class="hs-identifier hs-type">TuplePat</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1087"></span><span>    </span><span class="annot"><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SumPat"><span class="hs-identifier hs-type">SumPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1088"></span><span>    </span><span class="annot"><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ListPat"><span class="hs-identifier hs-type">ListPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1089"></span><span>    </span><span class="annot"><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LitPat"><span class="hs-identifier hs-type">LitPat</span></a></span><span> </span><span class="annot"><span class="annottext">XLitPat (GhcPass q)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682616031"><span class="annot"><span class="annottext">HsLit (GhcPass q)
</span><a href="#local-6989586621682616031"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; HsLit (GhcPass q) -&gt; Bool
forall x. PprPrec -&gt; HsLit x -&gt; Bool
</span><a href="GHC.Hs.Lit.html#hsLitNeedsParens"><span class="hs-identifier hs-var">hsLitNeedsParens</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621682616003"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">HsLit (GhcPass q)
</span><a href="#local-6989586621682616031"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1090"></span><span>    </span><span class="annot"><a href="#local-6989586621682616004"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span> </span><span class="annot"><span class="annottext">XNPat (GhcPass q)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682616033"><span class="annot"><span class="annottext">XRec (GhcPass q) (HsOverLit (GhcPass q))
</span><a href="#local-6989586621682616033"><span class="hs-identifier hs-var">lol</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe (SyntaxExpr (GhcPass q))
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">SyntaxExpr (GhcPass q)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; HsOverLit (GhcPass q) -&gt; Bool
forall x. PprPrec -&gt; HsOverLit x -&gt; Bool
</span><a href="GHC.Hs.Lit.html#hsOverLitNeedsParens"><span class="hs-identifier hs-var">hsOverLitNeedsParens</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621682616003"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">GenLocated EpAnnCO (HsOverLit (GhcPass q)) -&gt; HsOverLit (GhcPass q)
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass q) (HsOverLit (GhcPass q))
GenLocated EpAnnCO (HsOverLit (GhcPass q))
</span><a href="#local-6989586621682616033"><span class="hs-identifier hs-var">lol</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1091"></span><span>
</span><span id="line-1092"></span><span class="hs-comment">-- | @'conPatNeedsParens' p cp@ returns 'True' if the constructor patterns @cp@</span><span>
</span><span id="line-1093"></span><span class="hs-comment">-- needs parentheses under precedence @p@.</span><span>
</span><span id="line-1094"></span><span id="local-6989586621682615163"><span id="local-6989586621682615164"><span id="local-6989586621682615165"><span class="annot"><a href="GHC.Hs.Pat.html#conPatNeedsParens"><span class="hs-identifier hs-type">conPatNeedsParens</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#PprPrec"><span class="hs-identifier hs-type">PprPrec</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsConDetails"><span class="hs-identifier hs-type">HsConDetails</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615163"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615164"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615165"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span></span><span>
</span><span id="line-1095"></span><span id="conPatNeedsParens"><span class="annot"><span class="annottext">conPatNeedsParens :: forall t a b. PprPrec -&gt; HsConDetails t a b -&gt; Bool
</span><a href="GHC.Hs.Pat.html#conPatNeedsParens"><span class="hs-identifier hs-var hs-var">conPatNeedsParens</span></a></span></span><span> </span><span id="local-6989586621682616039"><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621682616039"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsConDetails t a b -&gt; Bool
</span><a href="#local-6989586621682616040"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-1096"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1097"></span><span>    </span><span id="local-6989586621682616040"><span class="annot"><span class="annottext">go :: HsConDetails t a b -&gt; Bool
</span><a href="#local-6989586621682616040"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#PrefixCon"><span class="hs-identifier hs-type">PrefixCon</span></a></span><span> </span><span id="local-6989586621682616041"><span class="annot"><span class="annottext">[t]
</span><a href="#local-6989586621682616041"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span id="local-6989586621682616042"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621682616042"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621682616039"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; PprPrec -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;=</span></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[a] -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621682616042"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[t] -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[t]
</span><a href="#local-6989586621682616041"><span class="hs-identifier hs-var">ts</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1098"></span><span>    </span><span class="annot"><a href="#local-6989586621682616040"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#InfixCon"><span class="hs-identifier hs-type">InfixCon</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621682616039"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; PprPrec -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;=</span></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#opPrec"><span class="hs-identifier hs-var">opPrec</span></a></span><span> </span><span class="hs-comment">-- type args should be empty in this case</span><span>
</span><span id="line-1099"></span><span>    </span><span class="annot"><a href="#local-6989586621682616040"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#RecCon"><span class="hs-identifier hs-type">RecCon</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1100"></span><span>
</span><span id="line-1101"></span><span>
</span><span id="line-1102"></span><span class="annot"><span class="hs-comment">-- | Parenthesize a pattern without token information</span></span><span>
</span><span id="line-1103"></span><span class="annot"><a href="GHC.Hs.Pat.html#gParPat"><span class="hs-identifier hs-type">gParPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621682615173"><span class="annot"><a href="#local-6989586621682615173"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#IsPass"><span class="hs-identifier hs-type">IsPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615173"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615173"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615173"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1104"></span><span id="gParPat"><span class="annot"><span class="annottext">gParPat :: forall (p :: Pass). IsPass p =&gt; LPat (GhcPass p) -&gt; Pat (GhcPass p)
</span><a href="GHC.Hs.Pat.html#gParPat"><span class="hs-identifier hs-var hs-var">gParPat</span></a></span></span><span> </span><span id="local-6989586621682616048"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682616048"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass p) -&gt; LPat (GhcPass p) -&gt; Pat (GhcPass p)
forall p. XParPat p -&gt; LPat p -&gt; Pat p
</span><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-var">ParPat</span></a></span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass p)
</span><a href="#local-6989586621682616049"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682616048"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-1105"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1106"></span><span>    </span><span id="local-6989586621682616049"><span class="annot"><span class="annottext">x :: XParPat (GhcPass p)
</span><a href="#local-6989586621682616049"><span class="hs-identifier hs-var hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621682615173"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1107"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-var">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(EpToken &quot;(&quot;, EpToken &quot;)&quot;)
XParPat (GhcPass p)
forall a. NoAnn a =&gt; a
</span><a href="GHC.Parser.Annotation.html#noAnn"><span class="hs-identifier hs-var">noAnn</span></a></span><span>
</span><span id="line-1108"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass p)
NoExtField
</span><a href="Language.Haskell.Syntax.Extension.html#noExtField"><span class="hs-identifier hs-var">noExtField</span></a></span><span>
</span><span id="line-1109"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass p)
NoExtField
</span><a href="Language.Haskell.Syntax.Extension.html#noExtField"><span class="hs-identifier hs-var">noExtField</span></a></span><span>
</span><span id="line-1110"></span><span>
</span><span id="line-1111"></span><span class="hs-comment">-- | @'parenthesizePat' p pat@ checks if @'patNeedsParens' p pat@ is true, and</span><span>
</span><span id="line-1112"></span><span class="hs-comment">-- if so, surrounds @pat@ with a 'ParPat'. Otherwise, it simply returns @pat@.</span><span>
</span><span id="line-1113"></span><span id="local-6989586621682615178"><span class="annot"><a href="GHC.Hs.Pat.html#parenthesizePat"><span class="hs-identifier hs-type">parenthesizePat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#IsPass"><span class="hs-identifier hs-type">IsPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615178"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-1114"></span><span>                </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#PprPrec"><span class="hs-identifier hs-type">PprPrec</span></a></span><span>
</span><span id="line-1115"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615178"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1116"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682615178"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-1117"></span><span id="parenthesizePat"><span class="annot"><span class="annottext">parenthesizePat :: forall (p :: Pass).
IsPass p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; LPat (GhcPass p)
</span><a href="GHC.Hs.Pat.html#parenthesizePat"><span class="hs-identifier hs-var hs-var">parenthesizePat</span></a></span></span><span> </span><span id="local-6989586621682616061"><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621682616061"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621682616062"><span class="annot"><span class="annottext">lpat :: LPat (GhcPass p)
</span><a href="#local-6989586621682616062"><span class="hs-identifier hs-var">lpat</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-type">L</span></a></span><span> </span><span id="local-6989586621682616063"><span class="annot"><span class="annottext">SrcSpanAnnA
</span><a href="#local-6989586621682616063"><span class="hs-identifier hs-var">loc</span></a></span></span><span> </span><span id="local-6989586621682616064"><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621682616064"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-1118"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; Pat (GhcPass p) -&gt; Bool
forall (p :: Pass). IsPass p =&gt; PprPrec -&gt; Pat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#patNeedsParens"><span class="hs-identifier hs-var">patNeedsParens</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621682616061"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621682616064"><span class="hs-identifier hs-var">pat</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SrcSpanAnnA
-&gt; Pat (GhcPass p) -&gt; GenLocated SrcSpanAnnA (Pat (GhcPass p))
forall l e. l -&gt; e -&gt; GenLocated l e
</span><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-var">L</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpanAnnA
</span><a href="#local-6989586621682616063"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Pat (GhcPass p)
forall (p :: Pass). IsPass p =&gt; LPat (GhcPass p) -&gt; Pat (GhcPass p)
</span><a href="GHC.Hs.Pat.html#gParPat"><span class="hs-identifier hs-var">gParPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682616062"><span class="hs-identifier hs-var">lpat</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1119"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621682616062"><span class="hs-identifier hs-var">lpat</span></a></span><span>
</span><span id="line-1120"></span><span>
</span><span id="line-1121"></span><span>
</span><span id="line-1122"></span><span class="hs-comment">{-
% Collect all EvVars from all constructor patterns
-}</span><span>
</span><span id="line-1125"></span><span>
</span><span id="line-1126"></span><span class="hs-comment">-- May need to add more cases</span><span>
</span><span id="line-1127"></span><span class="annot"><a href="GHC.Hs.Pat.html#collectEvVarsPats"><span class="hs-identifier hs-type">collectEvVarsPats</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Data.Bag.html#Bag"><span class="hs-identifier hs-type">Bag</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Var.html#EvVar"><span class="hs-identifier hs-type">EvVar</span></a></span><span>
</span><span id="line-1128"></span><span id="collectEvVarsPats"><span class="annot"><span class="annottext">collectEvVarsPats :: [Pat GhcTc] -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsPats"><span class="hs-identifier hs-var hs-var">collectEvVarsPats</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Bag TyVar] -&gt; Bag TyVar
forall a. [Bag a] -&gt; Bag a
</span><a href="GHC.Data.Bag.html#unionManyBags"><span class="hs-identifier hs-var">unionManyBags</span></a></span><span> </span><span class="annot"><span class="annottext">([Bag TyVar] -&gt; Bag TyVar)
-&gt; ([Pat GhcTc] -&gt; [Bag TyVar]) -&gt; [Pat GhcTc] -&gt; Bag TyVar
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Pat GhcTc -&gt; Bag TyVar) -&gt; [Pat GhcTc] -&gt; [Bag TyVar]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsPat"><span class="hs-identifier hs-var">collectEvVarsPat</span></a></span><span>
</span><span id="line-1129"></span><span>
</span><span id="line-1130"></span><span class="annot"><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-type">collectEvVarsLPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Data.Bag.html#Bag"><span class="hs-identifier hs-type">Bag</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Var.html#EvVar"><span class="hs-identifier hs-type">EvVar</span></a></span><span>
</span><span id="line-1131"></span><span id="collectEvVarsLPat"><span class="annot"><span class="annottext">collectEvVarsLPat :: LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var hs-var">collectEvVarsLPat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsPat"><span class="hs-identifier hs-var">collectEvVarsPat</span></a></span><span> </span><span class="annot"><span class="annottext">(Pat GhcTc -&gt; Bag TyVar)
-&gt; (GenLocated SrcSpanAnnA (Pat GhcTc) -&gt; Pat GhcTc)
-&gt; GenLocated SrcSpanAnnA (Pat GhcTc)
-&gt; Bag TyVar
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat GhcTc) -&gt; Pat GhcTc
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span>
</span><span id="line-1132"></span><span>
</span><span id="line-1133"></span><span class="annot"><a href="GHC.Hs.Pat.html#collectEvVarsPat"><span class="hs-identifier hs-type">collectEvVarsPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Data.Bag.html#Bag"><span class="hs-identifier hs-type">Bag</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Var.html#EvVar"><span class="hs-identifier hs-type">EvVar</span></a></span><span>
</span><span id="line-1134"></span><span id="collectEvVarsPat"><span class="annot"><span class="annottext">collectEvVarsPat :: Pat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsPat"><span class="hs-identifier hs-var hs-var">collectEvVarsPat</span></a></span></span><span> </span><span id="local-6989586621682616067"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621682616067"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1135"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621682616067"><span class="hs-identifier hs-var">pat</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1136"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LazyPat"><span class="hs-identifier hs-type">LazyPat</span></a></span><span> </span><span class="annot"><span class="annottext">XLazyPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682616068"><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621682616068"><span class="hs-identifier hs-var">p</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621682616068"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1137"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#AsPat"><span class="hs-identifier hs-type">AsPat</span></a></span><span> </span><span class="annot"><span class="annottext">XAsPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LIdP GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682616069"><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621682616069"><span class="hs-identifier hs-var">p</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621682616069"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1138"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span>  </span><span class="annot"><span class="annottext">XParPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682616070"><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621682616070"><span class="hs-identifier hs-var">p</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621682616070"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1139"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="annot"><span class="annottext">XBangPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682616071"><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621682616071"><span class="hs-identifier hs-var">p</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621682616071"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1140"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ListPat"><span class="hs-identifier hs-type">ListPat</span></a></span><span> </span><span class="annot"><span class="annottext">XListPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682616072"><span class="annot"><span class="annottext">[LPat GhcTc]
</span><a href="#local-6989586621682616072"><span class="hs-identifier hs-var">ps</span></a></span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Bag TyVar] -&gt; Bag TyVar
forall a. [Bag a] -&gt; Bag a
</span><a href="GHC.Data.Bag.html#unionManyBags"><span class="hs-identifier hs-var">unionManyBags</span></a></span><span> </span><span class="annot"><span class="annottext">([Bag TyVar] -&gt; Bag TyVar) -&gt; [Bag TyVar] -&gt; Bag TyVar
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (Pat GhcTc) -&gt; Bag TyVar)
-&gt; [GenLocated SrcSpanAnnA (Pat GhcTc)] -&gt; [Bag TyVar]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
GenLocated SrcSpanAnnA (Pat GhcTc) -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">[LPat GhcTc]
[GenLocated SrcSpanAnnA (Pat GhcTc)]
</span><a href="#local-6989586621682616072"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-1141"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#TuplePat"><span class="hs-identifier hs-type">TuplePat</span></a></span><span> </span><span class="annot"><span class="annottext">XTuplePat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682616073"><span class="annot"><span class="annottext">[LPat GhcTc]
</span><a href="#local-6989586621682616073"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span class="annot"><span class="annottext">Boxity
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Bag TyVar] -&gt; Bag TyVar
forall a. [Bag a] -&gt; Bag a
</span><a href="GHC.Data.Bag.html#unionManyBags"><span class="hs-identifier hs-var">unionManyBags</span></a></span><span> </span><span class="annot"><span class="annottext">([Bag TyVar] -&gt; Bag TyVar) -&gt; [Bag TyVar] -&gt; Bag TyVar
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (Pat GhcTc) -&gt; Bag TyVar)
-&gt; [GenLocated SrcSpanAnnA (Pat GhcTc)] -&gt; [Bag TyVar]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
GenLocated SrcSpanAnnA (Pat GhcTc) -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">[LPat GhcTc]
[GenLocated SrcSpanAnnA (Pat GhcTc)]
</span><a href="#local-6989586621682616073"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-1142"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#OrPat"><span class="hs-identifier hs-type">OrPat</span></a></span><span> </span><span class="annot"><span class="annottext">XOrPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682616074"><span class="annot"><span class="annottext">NonEmpty (LPat GhcTc)
</span><a href="#local-6989586621682616074"><span class="hs-identifier hs-var">ps</span></a></span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Bag TyVar] -&gt; Bag TyVar
forall a. [Bag a] -&gt; Bag a
</span><a href="GHC.Data.Bag.html#unionManyBags"><span class="hs-identifier hs-var">unionManyBags</span></a></span><span> </span><span class="annot"><span class="annottext">([Bag TyVar] -&gt; Bag TyVar) -&gt; [Bag TyVar] -&gt; Bag TyVar
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (Pat GhcTc) -&gt; Bag TyVar)
-&gt; [GenLocated SrcSpanAnnA (Pat GhcTc)] -&gt; [Bag TyVar]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
GenLocated SrcSpanAnnA (Pat GhcTc) -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NonEmpty (GenLocated SrcSpanAnnA (Pat GhcTc))
-&gt; [GenLocated SrcSpanAnnA (Pat GhcTc)]
forall a. NonEmpty a -&gt; [a]
</span><a href="../../base-4.21.0.0-ae91/src/Data.List.NonEmpty.html#toList"><span class="hs-identifier hs-var">NE.toList</span></a></span><span> </span><span class="annot"><span class="annottext">NonEmpty (LPat GhcTc)
NonEmpty (GenLocated SrcSpanAnnA (Pat GhcTc))
</span><a href="#local-6989586621682616074"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1143"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SumPat"><span class="hs-identifier hs-type">SumPat</span></a></span><span> </span><span class="annot"><span class="annottext">XSumPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682616075"><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621682616075"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621682616075"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1144"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConPat"><span class="hs-identifier hs-type">ConPat</span></a></span><span>
</span><span id="line-1145"></span><span>      </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pat_args :: forall p. Pat p -&gt; HsConPatDetails p
</span><a href="Language.Haskell.Syntax.Pat.html#pat_args"><span class="hs-identifier hs-var">pat_args</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621682616076"><span class="annot"><span class="annottext">HsConPatDetails GhcTc
</span><a href="#local-6989586621682616076"><span class="hs-identifier hs-var">args</span></a></span></span><span>
</span><span id="line-1146"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pat_con_ext :: forall p. Pat p -&gt; XConPat p
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con_ext"><span class="hs-identifier hs-var">pat_con_ext</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#ConPatTc"><span class="hs-identifier hs-type">ConPatTc</span></a></span><span>
</span><span id="line-1147"></span><span>        </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">cpt_dicts :: ConPatTc -&gt; [TyVar]
</span><a href="GHC.Hs.Pat.html#cpt_dicts"><span class="hs-identifier hs-var">cpt_dicts</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621682616077"><span class="annot"><span class="annottext">[TyVar]
</span><a href="#local-6989586621682616077"><span class="hs-identifier hs-var">dicts</span></a></span></span><span>
</span><span id="line-1148"></span><span>        </span><span class="hs-special">}</span><span>
</span><span id="line-1149"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-1150"></span><span>                     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bag TyVar -&gt; Bag TyVar -&gt; Bag TyVar
forall a. Bag a -&gt; Bag a -&gt; Bag a
</span><a href="GHC.Data.Bag.html#unionBags"><span class="hs-identifier hs-var">unionBags</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVar] -&gt; Bag TyVar
forall a. [a] -&gt; Bag a
</span><a href="GHC.Data.Bag.html#listToBag"><span class="hs-identifier hs-var">listToBag</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVar]
</span><a href="#local-6989586621682616077"><span class="hs-identifier hs-var">dicts</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1151"></span><span>                                   </span><span class="annot"><span class="annottext">(Bag TyVar -&gt; Bag TyVar) -&gt; Bag TyVar -&gt; Bag TyVar
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Bag TyVar] -&gt; Bag TyVar
forall a. [Bag a] -&gt; Bag a
</span><a href="GHC.Data.Bag.html#unionManyBags"><span class="hs-identifier hs-var">unionManyBags</span></a></span><span>
</span><span id="line-1152"></span><span>                                   </span><span class="annot"><span class="annottext">([Bag TyVar] -&gt; Bag TyVar) -&gt; [Bag TyVar] -&gt; Bag TyVar
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (Pat GhcTc) -&gt; Bag TyVar)
-&gt; [GenLocated SrcSpanAnnA (Pat GhcTc)] -&gt; [Bag TyVar]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
GenLocated SrcSpanAnnA (Pat GhcTc) -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span>
</span><span id="line-1153"></span><span>                                   </span><span class="annot"><span class="annottext">([GenLocated SrcSpanAnnA (Pat GhcTc)] -&gt; [Bag TyVar])
-&gt; [GenLocated SrcSpanAnnA (Pat GhcTc)] -&gt; [Bag TyVar]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">HsConPatDetails GhcTc -&gt; [LPat GhcTc]
forall p. UnXRec p =&gt; HsConPatDetails p -&gt; [LPat p]
</span><a href="Language.Haskell.Syntax.Pat.html#hsConPatArgs"><span class="hs-identifier hs-var">hsConPatArgs</span></a></span><span> </span><span class="annot"><span class="annottext">HsConPatDetails GhcTc
</span><a href="#local-6989586621682616076"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-1154"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SigPat"><span class="hs-identifier hs-type">SigPat</span></a></span><span>  </span><span class="annot"><span class="annottext">XSigPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682616080"><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621682616080"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="annot"><span class="annottext">HsPatSigType (NoGhcTc GhcTc)
</span><span class="hs-identifier">_</span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621682616080"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1155"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XPat"><span class="hs-identifier hs-type">XPat</span></a></span><span> </span><span id="local-6989586621682616081"><span class="annot"><span class="annottext">XXPat GhcTc
</span><a href="#local-6989586621682616081"><span class="hs-identifier hs-var">ext</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">XXPat GhcTc
</span><a href="#local-6989586621682616081"><span class="hs-identifier hs-var">ext</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1156"></span><span>      </span><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier hs-type">CoPat</span></a></span><span> </span><span class="annot"><span class="annottext">HsWrapper
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682616082"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621682616082"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsPat"><span class="hs-identifier hs-var">collectEvVarsPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621682616082"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1157"></span><span>      </span><span class="annot"><a href="GHC.Hs.Pat.html#ExpansionPat"><span class="hs-identifier hs-type">ExpansionPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682616083"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621682616083"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsPat"><span class="hs-identifier hs-var">collectEvVarsPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621682616083"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1158"></span><span>    </span><span id="local-6989586621682616084"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621682616084"><span class="hs-identifier hs-var">_other_pat</span></a></span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bag TyVar
forall a. Bag a
</span><a href="GHC.Data.Bag.html#emptyBag"><span class="hs-identifier hs-var">emptyBag</span></a></span><span>
</span><span id="line-1159"></span><span>
</span><span id="line-1160"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{Anno instances}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-1167"></span><span>
</span><span id="line-1168"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="Anno"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-var">Anno</span></a></span></span><span> </span><span id="local-6989586621682616086"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682616086"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#SrcSpanAnnA"><span class="hs-identifier hs-type">SrcSpanAnnA</span></a></span><span>
</span><span id="line-1169"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="Anno"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-var">Anno</span></a></span></span><span> </span><span id="local-6989586621682616087"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Lit.html#HsOverLit"><span class="hs-identifier hs-type">HsOverLit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682616087"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnnCO"><span class="hs-identifier hs-type">EpAnnCO</span></a></span><span>
</span><span id="line-1170"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="Anno"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-var">Anno</span></a></span></span><span> </span><span class="annot"><a href="GHC.Core.ConLike.html#ConLike"><span class="hs-identifier hs-type">ConLike</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#SrcSpanAnnN"><span class="hs-identifier hs-type">SrcSpanAnnN</span></a></span><span>
</span><span id="line-1171"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="Anno"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-var">Anno</span></a></span></span><span> </span><span id="local-6989586621682616088"><span id="local-6989586621682616089"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsFieldBind"><span class="hs-identifier hs-type">HsFieldBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682616088"><span class="hs-identifier hs-type">lhs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682616089"><span class="hs-identifier hs-type">rhs</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#SrcSpanAnnA"><span class="hs-identifier hs-type">SrcSpanAnnA</span></a></span><span>
</span><span id="line-1172"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="Anno"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-var">Anno</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#RecFieldsDotDot"><span class="hs-identifier hs-type">RecFieldsDotDot</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpaLocation"><span class="hs-identifier hs-type">EpaLocation</span></a></span><span>
</span><span id="line-1173"></span></pre></body></html>