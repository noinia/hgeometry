<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE MultiWayIf #-}</span><span>
</span><span id="line-2"></span><span>
</span><span id="line-3"></span><span class="annot"><span class="hs-comment">-- | Solving Class constraints CDictCan</span></span><span>
</span><span id="line-4"></span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html"><span class="hs-identifier">GHC.Tc.Solver.Dict</span></a></span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-5"></span><span>  </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#solveDict"><span class="hs-identifier">solveDict</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#solveDictNC"><span class="hs-identifier">solveDictNC</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-6"></span><span>  </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#checkInstanceOK"><span class="hs-identifier">checkInstanceOK</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-7"></span><span>  </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#matchLocalInst"><span class="hs-identifier">matchLocalInst</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#chooseInstance"><span class="hs-identifier">chooseInstance</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-8"></span><span>  </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#makeSuperClasses"><span class="hs-identifier">makeSuperClasses</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#mkStrictSuperClasses"><span class="hs-identifier">mkStrictSuperClasses</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-9"></span><span>  </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#solveCallStack"><span class="hs-identifier">solveCallStack</span></a></span><span>    </span><span class="hs-comment">-- For GHC.Tc.Solver</span><span>
</span><span id="line-10"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-11"></span><span>
</span><span id="line-12"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Prelude.html"><span class="hs-identifier">GHC.Prelude</span></a></span><span>
</span><span id="line-13"></span><span>
</span><span id="line-14"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Tc.Errors.Types.html"><span class="hs-identifier">GHC.Tc.Errors.Types</span></a></span><span>
</span><span id="line-15"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Tc.Instance.FunDeps.html"><span class="hs-identifier">GHC.Tc.Instance.FunDeps</span></a></span><span>
</span><span id="line-16"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Tc.Instance.Class.html"><span class="hs-identifier">GHC.Tc.Instance.Class</span></a></span><span class="hs-special">(</span><span> </span><span class="annot"><a href="GHC.Tc.Instance.Class.html#safeOverlap"><span class="hs-identifier">safeOverlap</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Instance.Class.html#matchEqualityInst"><span class="hs-identifier">matchEqualityInst</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-17"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html"><span class="hs-identifier">GHC.Tc.Types.Evidence</span></a></span><span>
</span><span id="line-18"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html"><span class="hs-identifier">GHC.Tc.Types.Constraint</span></a></span><span>
</span><span id="line-19"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Tc.Types.CtLoc.html"><span class="hs-identifier">GHC.Tc.Types.CtLoc</span></a></span><span>
</span><span id="line-20"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Origin.html"><span class="hs-identifier">GHC.Tc.Types.Origin</span></a></span><span>
</span><span id="line-21"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Tc.Types.EvTerm.html"><span class="hs-identifier">GHC.Tc.Types.EvTerm</span></a></span><span class="hs-special">(</span><span> </span><span class="annot"><a href="GHC.Tc.Types.EvTerm.html#evCallStack"><span class="hs-identifier">evCallStack</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-22"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.InertSet.html"><span class="hs-identifier">GHC.Tc.Solver.InertSet</span></a></span><span>
</span><span id="line-23"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html"><span class="hs-identifier">GHC.Tc.Solver.Monad</span></a></span><span>
</span><span id="line-24"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Types.html"><span class="hs-identifier">GHC.Tc.Solver.Types</span></a></span><span>
</span><span id="line-25"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Tc.Utils.TcType.html"><span class="hs-identifier">GHC.Tc.Utils.TcType</span></a></span><span>
</span><span id="line-26"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Tc.Utils.Unify.html"><span class="hs-identifier">GHC.Tc.Utils.Unify</span></a></span><span class="hs-special">(</span><span> </span><span class="annot"><a href="GHC.Tc.Utils.Unify.html#uType"><span class="hs-identifier">uType</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-27"></span><span>
</span><span id="line-28"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Hs.Type.html"><span class="hs-identifier">GHC.Hs.Type</span></a></span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsIPName"><span class="hs-identifier">HsIPName</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-29"></span><span>
</span><span id="line-30"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.html"><span class="hs-identifier">GHC.Core</span></a></span><span>
</span><span id="line-31"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.Type.html"><span class="hs-identifier">GHC.Core.Type</span></a></span><span>
</span><span id="line-32"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.InstEnv.html"><span class="hs-identifier">GHC.Core.InstEnv</span></a></span><span>     </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="GHC.Core.InstEnv.html#DFunInstType"><span class="hs-identifier">DFunInstType</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Core.InstEnv.html#ClsInst"><span class="hs-identifier">ClsInst</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-33"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.Class.html"><span class="hs-identifier">GHC.Core.Class</span></a></span><span>
</span><span id="line-34"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.Predicate.html"><span class="hs-identifier">GHC.Core.Predicate</span></a></span><span>
</span><span id="line-35"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.Multiplicity.html"><span class="hs-identifier">GHC.Core.Multiplicity</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#scaledThing"><span class="hs-identifier">scaledThing</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-36"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.Unify.html"><span class="hs-identifier">GHC.Core.Unify</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="GHC.Core.Unify.html#ruleMatchTyKiX"><span class="hs-identifier">ruleMatchTyKiX</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-37"></span><span>
</span><span id="line-38"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Name.html"><span class="hs-identifier">GHC.Types.Name</span></a></span><span>
</span><span id="line-39"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Name.Set.html"><span class="hs-identifier">GHC.Types.Name.Set</span></a></span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Var.html"><span class="hs-identifier">GHC.Types.Var</span></a></span><span>
</span><span id="line-41"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Id.html"><span class="hs-identifier">GHC.Types.Id</span></a></span><span class="hs-special">(</span><span> </span><span class="annot"><a href="GHC.Types.Id.html#mkTemplateLocals"><span class="hs-identifier">mkTemplateLocals</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-42"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Var.Set.html"><span class="hs-identifier">GHC.Types.Var.Set</span></a></span><span>
</span><span id="line-43"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Var.Env.html"><span class="hs-identifier">GHC.Types.Var.Env</span></a></span><span>
</span><span id="line-44"></span><span>
</span><span id="line-45"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Utils.Monad.html"><span class="hs-identifier">GHC.Utils.Monad</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="GHC.Utils.Monad.html#concatMapM"><span class="hs-identifier">concatMapM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">foldlM</span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-46"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html"><span class="hs-identifier">GHC.Utils.Outputable</span></a></span><span>
</span><span id="line-47"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Utils.Panic.html"><span class="hs-identifier">GHC.Utils.Panic</span></a></span><span>
</span><span id="line-48"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Utils.Misc.html"><span class="hs-identifier">GHC.Utils.Misc</span></a></span><span>
</span><span id="line-49"></span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Unit.Module.html"><span class="hs-identifier">GHC.Unit.Module</span></a></span><span>
</span><span id="line-51"></span><span>
</span><span id="line-52"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Data.Bag.html"><span class="hs-identifier">GHC.Data.Bag</span></a></span><span>
</span><span id="line-53"></span><span>
</span><span id="line-54"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Driver.DynFlags.html"><span class="hs-identifier">GHC.Driver.DynFlags</span></a></span><span>
</span><span id="line-55"></span><span>
</span><span id="line-56"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="../../ghc-boot-9.12.2-1a37/src/GHC.LanguageExtensions.html"><span class="hs-identifier">GHC.LanguageExtensions</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">LangExt</span></span><span>
</span><span id="line-57"></span><span>
</span><span id="line-58"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.21.0.0-ae91/src/Data.Maybe.html"><span class="hs-identifier">Data.Maybe</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">listToMaybe</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">mapMaybe</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">isJust</span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-59"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.21.0.0-ae91/src/Data.Void.html"><span class="hs-identifier">Data.Void</span></a></span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">Void</span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-60"></span><span>
</span><span id="line-61"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../transformers-0.6.1.2-38b1/src/Control.Monad.Trans.Maybe.html"><span class="hs-identifier">Control.Monad.Trans.Maybe</span></a></span><span class="hs-special">(</span><span> </span><span class="annot"><a href="../../transformers-0.6.1.2-38b1/src/Control.Monad.Trans.Maybe.html#MaybeT"><span class="hs-identifier">MaybeT</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../transformers-0.6.1.2-38b1/src/Control.Monad.Trans.Maybe.html#runMaybeT"><span class="hs-identifier">runMaybeT</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-62"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../transformers-0.6.1.2-38b1/src/Control.Monad.Trans.Class.html"><span class="hs-identifier">Control.Monad.Trans.Class</span></a></span><span class="hs-special">(</span><span> </span><span class="annot"><a href="../../transformers-0.6.1.2-38b1/src/Control.Monad.Trans.Class.html#lift"><span class="hs-identifier">lift</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-63"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.21.0.0-ae91/src/Control.Monad.html"><span class="hs-identifier">Control.Monad</span></a></span><span>
</span><span id="line-64"></span><span>
</span><span id="line-65"></span><span>
</span><span id="line-66"></span><span class="annot"><span class="hs-comment">{- *********************************************************************
*                                                                      *
*                      Class Canonicalization
*                                                                      *
********************************************************************* -}</span></span><span>
</span><span id="line-71"></span><span>
</span><span id="line-72"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#solveDictNC"><span class="hs-identifier hs-type">solveDictNC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CtEvidence"><span class="hs-identifier hs-type">CtEvidence</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.Class.html#Class"><span class="hs-identifier hs-type">Class</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#SolverStage"><span class="hs-identifier hs-type">SolverStage</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Void</span></span><span>
</span><span id="line-73"></span><span class="hs-comment">-- NC: this comes from CNonCanonical or CIrredCan</span><span>
</span><span id="line-74"></span><span class="hs-comment">-- Precondition: already rewritten by inert set</span><span>
</span><span id="line-75"></span><span id="solveDictNC"><span class="annot"><span class="annottext">solveDictNC :: CtEvidence -&gt; Class -&gt; [Type] -&gt; SolverStage Void
</span><a href="GHC.Tc.Solver.Dict.html#solveDictNC"><span class="hs-identifier hs-var hs-var">solveDictNC</span></a></span></span><span> </span><span id="local-6989586621683041618"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041618"><span class="hs-identifier hs-var">ev</span></a></span></span><span> </span><span id="local-6989586621683041619"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041619"><span class="hs-identifier hs-var">cls</span></a></span></span><span> </span><span id="local-6989586621683041620"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041620"><span class="hs-identifier hs-var">tys</span></a></span></span><span>
</span><span id="line-76"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">TcS () -&gt; SolverStage ()
forall a. TcS a -&gt; SolverStage a
</span><a href="GHC.Tc.Solver.Monad.html#simpleStage"><span class="hs-identifier hs-var">simpleStage</span></a></span><span> </span><span class="annot"><span class="annottext">(TcS () -&gt; SolverStage ()) -&gt; TcS () -&gt; SolverStage ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-var">traceTcS</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;solveDictNC&quot;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Class -&gt; [Type] -&gt; Type
</span><a href="GHC.Core.Predicate.html#mkClassPred"><span class="hs-identifier hs-var">mkClassPred</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041619"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041620"><span class="hs-identifier hs-var">tys</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsDoc doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%24%24"><span class="hs-operator hs-var">$$</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041618"><span class="hs-identifier hs-var">ev</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-77"></span><span>       </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683041626"><span class="annot"><a href="#local-6989586621683041626"><span class="hs-identifier hs-var">dict_ct</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; Class -&gt; [Type] -&gt; SolverStage DictCt
</span><a href="GHC.Tc.Solver.Dict.html#canDictCt"><span class="hs-identifier hs-var">canDictCt</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041618"><span class="hs-identifier hs-var">ev</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041619"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041620"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-78"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#solveDict"><span class="hs-identifier hs-type">solveDict</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041626"><span class="hs-identifier hs-type">dict_ct</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-79"></span><span>
</span><span id="line-80"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#solveDict"><span class="hs-identifier hs-type">solveDict</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#SolverStage"><span class="hs-identifier hs-type">SolverStage</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Void</span></span><span>
</span><span id="line-81"></span><span class="hs-comment">-- Preconditions: `tys` are already rewritten by the inert set</span><span>
</span><span id="line-82"></span><span id="solveDict"><span class="annot"><span class="annottext">solveDict :: DictCt -&gt; SolverStage Void
</span><a href="GHC.Tc.Solver.Dict.html#solveDict"><span class="hs-identifier hs-var hs-var">solveDict</span></a></span></span><span> </span><span id="local-6989586621683041628"><span class="annot"><span class="annottext">dict_ct :: DictCt
</span><a href="#local-6989586621683041628"><span class="hs-identifier hs-var">dict_ct</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">di_ev :: DictCt -&gt; CtEvidence
</span><a href="GHC.Tc.Types.Constraint.html#di_ev"><span class="hs-identifier hs-var">di_ev</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041631"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041631"><span class="hs-identifier hs-var">ev</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">di_cls :: DictCt -&gt; Class
</span><a href="GHC.Tc.Types.Constraint.html#di_cls"><span class="hs-identifier hs-var">di_cls</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041633"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041633"><span class="hs-identifier hs-var">cls</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">di_tys :: DictCt -&gt; [Type]
</span><a href="GHC.Tc.Types.Constraint.html#di_tys"><span class="hs-identifier hs-var">di_tys</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041635"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041635"><span class="hs-identifier hs-var">tys</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-83"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Class -&gt; Bool
</span><a href="GHC.Core.Predicate.html#isEqualityClass"><span class="hs-identifier hs-var">isEqualityClass</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041633"><span class="hs-identifier hs-var">cls</span></a></span><span>
</span><span id="line-84"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; Class -&gt; [Type] -&gt; SolverStage Void
</span><a href="GHC.Tc.Solver.Dict.html#solveEqualityDict"><span class="hs-identifier hs-var">solveEqualityDict</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041631"><span class="hs-identifier hs-var">ev</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041633"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041635"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-85"></span><span>
</span><span id="line-86"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-87"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; SDoc -&gt; SolverStage Void -&gt; SolverStage Void
forall a. HasCallStack =&gt; Bool -&gt; SDoc -&gt; a -&gt; a
</span><a href="GHC.Utils.Panic.html#assertPpr"><span class="hs-identifier hs-var">assertPpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; CtEvidence -&gt; Role
CtEvidence -&gt; Role
</span><a href="GHC.Tc.Types.Constraint.html#ctEvRewriteRole"><span class="hs-identifier hs-var">ctEvRewriteRole</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041631"><span class="hs-identifier hs-var">ev</span></a></span><span> </span><span class="annot"><span class="annottext">Role -&gt; Role -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Role
</span><a href="Language.Haskell.Syntax.Basic.html#Nominal"><span class="hs-identifier hs-var">Nominal</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtEvidence -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041631"><span class="hs-identifier hs-var">ev</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsDoc doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%24%24"><span class="hs-operator hs-var">$$</span></a></span><span> </span><span class="annot"><span class="annottext">Class -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041633"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsDoc doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%24%24"><span class="hs-operator hs-var">$$</span></a></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041635"><span class="hs-identifier hs-var">tys</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(SolverStage Void -&gt; SolverStage Void)
-&gt; SolverStage Void -&gt; SolverStage Void
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-88"></span><span>    </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">TcS () -&gt; SolverStage ()
forall a. TcS a -&gt; SolverStage a
</span><a href="GHC.Tc.Solver.Monad.html#simpleStage"><span class="hs-identifier hs-var">simpleStage</span></a></span><span> </span><span class="annot"><span class="annottext">(TcS () -&gt; SolverStage ()) -&gt; TcS () -&gt; SolverStage ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-var">traceTcS</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;solveDict&quot;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DictCt -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041628"><span class="hs-identifier hs-var">dict_ct</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-89"></span><span>
</span><span id="line-90"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">DictCt -&gt; SolverStage ()
</span><a href="GHC.Tc.Solver.Dict.html#tryInertDicts"><span class="hs-identifier hs-var">tryInertDicts</span></a></span><span> </span><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041628"><span class="hs-identifier hs-var">dict_ct</span></a></span><span>
</span><span id="line-91"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">DictCt -&gt; SolverStage ()
</span><a href="GHC.Tc.Solver.Dict.html#tryInstances"><span class="hs-identifier hs-var">tryInstances</span></a></span><span> </span><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041628"><span class="hs-identifier hs-var">dict_ct</span></a></span><span>
</span><span id="line-92"></span><span>
</span><span id="line-93"></span><span>       </span><span class="hs-comment">-- Try fundeps /after/ tryInstances:</span><span>
</span><span id="line-94"></span><span>       </span><span class="hs-comment">--     see (DFL2) in Note [Do fundeps last]</span><span>
</span><span id="line-95"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">DictCt -&gt; SolverStage ()
</span><a href="GHC.Tc.Solver.Dict.html#doLocalFunDepImprovement"><span class="hs-identifier hs-var">doLocalFunDepImprovement</span></a></span><span> </span><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041628"><span class="hs-identifier hs-var">dict_ct</span></a></span><span>
</span><span id="line-96"></span><span>           </span><span class="hs-comment">-- doLocalFunDepImprovement does StartAgain if there</span><span>
</span><span id="line-97"></span><span>           </span><span class="hs-comment">-- are any fundeps: see (DFL1) in Note [Do fundeps last]</span><span>
</span><span id="line-98"></span><span>
</span><span id="line-99"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">DictCt -&gt; SolverStage ()
</span><a href="GHC.Tc.Solver.Dict.html#doTopFunDepImprovement"><span class="hs-identifier hs-var">doTopFunDepImprovement</span></a></span><span> </span><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041628"><span class="hs-identifier hs-var">dict_ct</span></a></span><span>
</span><span id="line-100"></span><span>
</span><span id="line-101"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">TcS () -&gt; SolverStage ()
forall a. TcS a -&gt; SolverStage a
</span><a href="GHC.Tc.Solver.Monad.html#simpleStage"><span class="hs-identifier hs-var">simpleStage</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DictCt -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Dict.html#updInertDicts"><span class="hs-identifier hs-var">updInertDicts</span></a></span><span> </span><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041628"><span class="hs-identifier hs-var">dict_ct</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-102"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; String -&gt; SolverStage Void
forall a. CtEvidence -&gt; String -&gt; SolverStage a
</span><a href="GHC.Tc.Solver.Monad.html#stopWithStage"><span class="hs-identifier hs-var">stopWithStage</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DictCt -&gt; CtEvidence
</span><a href="GHC.Tc.Types.Constraint.html#dictCtEvidence"><span class="hs-identifier hs-var">dictCtEvidence</span></a></span><span> </span><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041628"><span class="hs-identifier hs-var">dict_ct</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Kept inert DictCt&quot;</span></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-103"></span><span>
</span><span id="line-104"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#updInertDicts"><span class="hs-identifier hs-type">updInertDicts</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#TcS"><span class="hs-identifier hs-type">TcS</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-105"></span><span id="updInertDicts"><span class="annot"><span class="annottext">updInertDicts :: DictCt -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Dict.html#updInertDicts"><span class="hs-identifier hs-var hs-var">updInertDicts</span></a></span></span><span> </span><span id="local-6989586621683041648"><span class="annot"><span class="annottext">dict_ct :: DictCt
</span><a href="#local-6989586621683041648"><span class="hs-identifier hs-var">dict_ct</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">di_cls :: DictCt -&gt; Class
</span><a href="GHC.Tc.Types.Constraint.html#di_cls"><span class="hs-identifier hs-var">di_cls</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041649"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041649"><span class="hs-identifier hs-var">cls</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">di_ev :: DictCt -&gt; CtEvidence
</span><a href="GHC.Tc.Types.Constraint.html#di_ev"><span class="hs-identifier hs-var">di_ev</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041650"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041650"><span class="hs-identifier hs-var">ev</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">di_tys :: DictCt -&gt; [Type]
</span><a href="GHC.Tc.Types.Constraint.html#di_tys"><span class="hs-identifier hs-var">di_tys</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041651"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041651"><span class="hs-identifier hs-var">tys</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-106"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-var">traceTcS</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Adding inert dict&quot;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DictCt -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041648"><span class="hs-identifier hs-var">dict_ct</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsDoc doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%24%24"><span class="hs-operator hs-var">$$</span></a></span><span> </span><span class="annot"><span class="annottext">Class -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041649"><span class="hs-identifier hs-var">cls</span></a></span><span>  </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041651"><span class="hs-identifier hs-var">tys</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-107"></span><span>
</span><span id="line-108"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="hs-glyph">|</span><span>  </span><span class="annot"><span class="annottext">CtEvidence -&gt; Bool
</span><a href="GHC.Tc.Types.Constraint.html#isGiven"><span class="hs-identifier hs-var">isGiven</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041650"><span class="hs-identifier hs-var">ev</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621683041654"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041654"><span class="hs-identifier hs-var">str_ty</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Class -&gt; [Type] -&gt; Maybe (Type, Type)
</span><a href="GHC.Core.Predicate.html#isIPPred_maybe"><span class="hs-identifier hs-var">isIPPred_maybe</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041649"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041651"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-109"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-comment">-- See (SIP1) and (SIP2) in Note [Shadowing of implicit parameters]</span><span>
</span><span id="line-110"></span><span>               </span><span class="hs-comment">-- Update /both/ inert_cans /and/ inert_solved_dicts.</span><span>
</span><span id="line-111"></span><span>               </span><span class="annot"><span class="annottext">(InertSet -&gt; InertSet) -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#updInertSet"><span class="hs-identifier hs-var">updInertSet</span></a></span><span> </span><span class="annot"><span class="annottext">((InertSet -&gt; InertSet) -&gt; TcS ())
-&gt; (InertSet -&gt; InertSet) -&gt; TcS ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621683041657"><span class="annot"><span class="annottext">inerts :: InertSet
</span><a href="#local-6989586621683041657"><span class="hs-identifier hs-var">inerts</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Solver.InertSet.html#IS"><span class="hs-identifier hs-type">IS</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">inert_cans :: InertSet -&gt; InertCans
</span><a href="GHC.Tc.Solver.InertSet.html#inert_cans"><span class="hs-identifier hs-var">inert_cans</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041660"><span class="annot"><span class="annottext">InertCans
</span><a href="#local-6989586621683041660"><span class="hs-identifier hs-var">ics</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">inert_solved_dicts :: InertSet -&gt; DictMap DictCt
</span><a href="GHC.Tc.Solver.InertSet.html#inert_solved_dicts"><span class="hs-identifier hs-var">inert_solved_dicts</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041662"><span class="annot"><span class="annottext">DictMap DictCt
</span><a href="#local-6989586621683041662"><span class="hs-identifier hs-var">solved</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-112"></span><span>               </span><span class="annot"><span class="annottext">InertSet
</span><a href="#local-6989586621683041657"><span class="hs-identifier hs-var">inerts</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.InertSet.html#inert_cans"><span class="hs-identifier hs-var">inert_cans</span></a></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.InertSet.html#updDicts"><span class="hs-identifier hs-type">updDicts</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Solver.InertSet.html#filterDicts"><span class="hs-identifier hs-type">filterDicts</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621683041665"><span class="hs-identifier hs-type">not_ip_for</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041654"><span class="hs-identifier hs-type">str_ty</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621683041660"><span class="hs-identifier hs-type">ics</span></a></span><span>
</span><span id="line-113"></span><span>                      </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.InertSet.html#inert_solved_dicts"><span class="hs-identifier hs-var">inert_solved_dicts</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.InertSet.html#filterDicts"><span class="hs-identifier hs-type">filterDicts</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621683041665"><span class="hs-identifier hs-type">not_ip_for</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041654"><span class="hs-identifier hs-type">str_ty</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621683041662"><span class="hs-identifier hs-type">solved</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-114"></span><span>            </span><span class="hs-glyph">|</span><span>  </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-115"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">() -&gt; TcS ()
forall a. a -&gt; TcS a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-116"></span><span>
</span><span id="line-117"></span><span>       </span><span class="hs-comment">-- Add the new constraint to the inert set</span><span>
</span><span id="line-118"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">(InertCans -&gt; InertCans) -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#updInertCans"><span class="hs-identifier hs-var">updInertCans</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(DictMap DictCt -&gt; DictMap DictCt) -&gt; InertCans -&gt; InertCans
</span><a href="GHC.Tc.Solver.InertSet.html#updDicts"><span class="hs-identifier hs-var">updDicts</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DictCt -&gt; DictMap DictCt -&gt; DictMap DictCt
</span><a href="GHC.Tc.Solver.InertSet.html#addDict"><span class="hs-identifier hs-var">addDict</span></a></span><span> </span><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041648"><span class="hs-identifier hs-var">dict_ct</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-119"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-120"></span><span>    </span><span class="annot"><a href="#local-6989586621683041665"><span class="hs-identifier hs-type">not_ip_for</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-121"></span><span>    </span><span id="local-6989586621683041665"><span class="annot"><span class="annottext">not_ip_for :: Type -&gt; DictCt -&gt; Bool
</span><a href="#local-6989586621683041665"><span class="hs-identifier hs-var hs-var">not_ip_for</span></a></span></span><span> </span><span id="local-6989586621683041668"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041668"><span class="hs-identifier hs-var">str_ty</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">di_cls :: DictCt -&gt; Class
</span><a href="GHC.Tc.Types.Constraint.html#di_cls"><span class="hs-identifier hs-var">di_cls</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041669"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041669"><span class="hs-identifier hs-var">cls</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">di_tys :: DictCt -&gt; [Type]
</span><a href="GHC.Tc.Types.Constraint.html#di_tys"><span class="hs-identifier hs-var">di_tys</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041670"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041670"><span class="hs-identifier hs-var">tys</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-122"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Class -&gt; [Type] -&gt; Bool
</span><a href="GHC.Core.Predicate.html#mentionsIP"><span class="hs-identifier hs-var">mentionsIP</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041668"><span class="hs-identifier hs-var">str_ty</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041669"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041670"><span class="hs-identifier hs-var">tys</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-123"></span><span>
</span><span id="line-124"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#canDictCt"><span class="hs-identifier hs-type">canDictCt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CtEvidence"><span class="hs-identifier hs-type">CtEvidence</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.Class.html#Class"><span class="hs-identifier hs-type">Class</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#SolverStage"><span class="hs-identifier hs-type">SolverStage</span></a></span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span>
</span><span id="line-125"></span><span class="hs-comment">-- Once-only processing of Dict constraints:</span><span>
</span><span id="line-126"></span><span class="hs-comment">--   * expand superclasses</span><span>
</span><span id="line-127"></span><span class="hs-comment">--   * deal with CallStack</span><span>
</span><span id="line-128"></span><span id="canDictCt"><span class="annot"><span class="annottext">canDictCt :: CtEvidence -&gt; Class -&gt; [Type] -&gt; SolverStage DictCt
</span><a href="GHC.Tc.Solver.Dict.html#canDictCt"><span class="hs-identifier hs-var hs-var">canDictCt</span></a></span></span><span> </span><span id="local-6989586621683041673"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041673"><span class="hs-identifier hs-var">ev</span></a></span></span><span> </span><span id="local-6989586621683041674"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041674"><span class="hs-identifier hs-var">cls</span></a></span></span><span> </span><span id="local-6989586621683041675"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041675"><span class="hs-identifier hs-var">tys</span></a></span></span><span>
</span><span id="line-129"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; Bool
</span><a href="GHC.Tc.Types.Constraint.html#isGiven"><span class="hs-identifier hs-var">isGiven</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041673"><span class="hs-identifier hs-var">ev</span></a></span><span>  </span><span class="hs-comment">-- See Note [Eagerly expand given superclasses]</span><span>
</span><span id="line-130"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TcS (StopOrContinue DictCt) -&gt; SolverStage DictCt
forall a. TcS (StopOrContinue a) -&gt; SolverStage a
</span><a href="GHC.Tc.Solver.Monad.html#Stage"><span class="hs-identifier hs-var">Stage</span></a></span><span> </span><span class="annot"><span class="annottext">(TcS (StopOrContinue DictCt) -&gt; SolverStage DictCt)
-&gt; TcS (StopOrContinue DictCt) -&gt; SolverStage DictCt
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-131"></span><span>    </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span id="local-6989586621683041677"><span class="annot"><a href="#local-6989586621683041677"><span class="hs-identifier hs-var">dflags</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TcS DynFlags
forall (m :: * -&gt; *). HasDynFlags m =&gt; m DynFlags
</span><a href="GHC.Driver.DynFlags.html#getDynFlags"><span class="hs-identifier hs-var">getDynFlags</span></a></span><span>
</span><span id="line-132"></span><span>       </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683041679"><span class="annot"><a href="#local-6989586621683041679"><span class="hs-identifier hs-var">sc_cts</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#mkStrictSuperClasses"><span class="hs-identifier hs-type">mkStrictSuperClasses</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Driver.DynFlags.html#givensFuel"><span class="hs-identifier hs-var">givensFuel</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041677"><span class="hs-identifier hs-type">dflags</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621683041673"><span class="hs-identifier hs-type">ev</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><a href="#local-6989586621683041674"><span class="hs-identifier hs-type">cls</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041675"><span class="hs-identifier hs-type">tys</span></a></span><span>
</span><span id="line-133"></span><span>         </span><span class="hs-comment">-- givensFuel dflags: See Note [Expanding Recursive Superclasses and ExpansionFuel]</span><span>
</span><span id="line-134"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#emitWork"><span class="hs-identifier hs-type">emitWork</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Data.Bag.html#listToBag"><span class="hs-identifier hs-type">listToBag</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041679"><span class="hs-identifier hs-type">sc_cts</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-135"></span><span>
</span><span id="line-136"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#continueWith"><span class="hs-identifier hs-type">continueWith</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#di_ev"><span class="hs-identifier hs-var">di_ev</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621683041673"><span class="hs-identifier hs-type">ev</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#di_cls"><span class="hs-identifier hs-var">di_cls</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621683041674"><span class="hs-identifier hs-type">cls</span></a></span><span>
</span><span id="line-137"></span><span>                              </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#di_tys"><span class="hs-identifier hs-var">di_tys</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621683041675"><span class="hs-identifier hs-type">tys</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#di_pend_sc"><span class="hs-identifier hs-var">di_pend_sc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#doNotExpand"><span class="hs-identifier hs-type">doNotExpand</span></a></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-138"></span><span>         </span><span class="hs-comment">-- doNotExpand: We have already expanded superclasses for /this/ dict</span><span>
</span><span id="line-139"></span><span>         </span><span class="hs-comment">-- so set the fuel to doNotExpand to avoid repeating expansion</span><span>
</span><span id="line-140"></span><span>
</span><span id="line-141"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CtWanted"><span class="hs-identifier hs-type">CtWanted</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">ctev_rewriters :: CtEvidence -&gt; RewriterSet
</span><a href="GHC.Tc.Types.Constraint.html#ctev_rewriters"><span class="hs-identifier hs-var">ctev_rewriters</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041688"><span class="annot"><span class="annottext">RewriterSet
</span><a href="#local-6989586621683041688"><span class="hs-identifier hs-var">rewriters</span></a></span></span><span> </span><span class="hs-special">}</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041673"><span class="hs-identifier hs-var">ev</span></a></span><span>
</span><span id="line-142"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621683041689"><span class="annot"><span class="annottext">FastString
</span><a href="#local-6989586621683041689"><span class="hs-identifier hs-var">ip_name</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Class -&gt; [Type] -&gt; Maybe FastString
</span><a href="GHC.Core.Predicate.html#isCallStackPred"><span class="hs-identifier hs-var">isCallStackPred</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041674"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041675"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-143"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CtOrigin -&gt; Bool
</span><a href="GHC.Tc.Types.Origin.html#isPushCallStackOrigin"><span class="hs-identifier hs-var">isPushCallStackOrigin</span></a></span><span> </span><span class="annot"><span class="annottext">CtOrigin
</span><a href="#local-6989586621683041692"><span class="hs-identifier hs-var">orig</span></a></span><span>
</span><span id="line-144"></span><span>  </span><span class="hs-comment">-- If we're given a CallStack constraint that arose from a function</span><span>
</span><span id="line-145"></span><span>  </span><span class="hs-comment">-- call, we need to push the current call-site onto the stack instead</span><span>
</span><span id="line-146"></span><span>  </span><span class="hs-comment">-- of solving it directly from a given.</span><span>
</span><span id="line-147"></span><span>  </span><span class="hs-comment">-- See Note [Overview of implicit CallStacks] in GHC.Tc.Types.Evidence</span><span>
</span><span id="line-148"></span><span>  </span><span class="hs-comment">-- and Note [Solving CallStack constraints] in GHC.Tc.Solver.Types</span><span>
</span><span id="line-149"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TcS (StopOrContinue DictCt) -&gt; SolverStage DictCt
forall a. TcS (StopOrContinue a) -&gt; SolverStage a
</span><a href="GHC.Tc.Solver.Monad.html#Stage"><span class="hs-identifier hs-var">Stage</span></a></span><span> </span><span class="annot"><span class="annottext">(TcS (StopOrContinue DictCt) -&gt; SolverStage DictCt)
-&gt; TcS (StopOrContinue DictCt) -&gt; SolverStage DictCt
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-150"></span><span>    </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-comment">-- First we emit a new constraint that will capture the</span><span>
</span><span id="line-151"></span><span>         </span><span class="hs-comment">-- given CallStack.</span><span>
</span><span id="line-152"></span><span>         </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621683041693"><span class="annot"><span class="annottext">new_loc :: CtLoc
</span><a href="#local-6989586621683041693"><span class="hs-identifier hs-var hs-var hs-var">new_loc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtLoc -&gt; CtOrigin -&gt; CtLoc
</span><a href="GHC.Tc.Types.CtLoc.html#setCtLocOrigin"><span class="hs-identifier hs-var">setCtLocOrigin</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041695"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HsIPName -&gt; CtOrigin
</span><a href="GHC.Tc.Types.Origin.html#IPOccOrigin"><span class="hs-identifier hs-var">IPOccOrigin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FastString -&gt; HsIPName
</span><a href="Language.Haskell.Syntax.Type.html#HsIPName"><span class="hs-identifier hs-var">HsIPName</span></a></span><span> </span><span class="annot"><span class="annottext">FastString
</span><a href="#local-6989586621683041689"><span class="hs-identifier hs-var">ip_name</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-153"></span><span>                            </span><span class="hs-comment">-- We change the origin to IPOccOrigin so</span><span>
</span><span id="line-154"></span><span>                            </span><span class="hs-comment">-- this rule does not fire again.</span><span>
</span><span id="line-155"></span><span>                            </span><span class="hs-comment">-- See Note [Overview of implicit CallStacks]</span><span>
</span><span id="line-156"></span><span>                            </span><span class="hs-comment">-- in GHC.Tc.Types.Evidence</span><span>
</span><span id="line-157"></span><span>
</span><span id="line-158"></span><span>       </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683041698"><span class="annot"><a href="#local-6989586621683041698"><span class="hs-identifier hs-var">new_ev</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">CtLoc -&gt; RewriterSet -&gt; Type -&gt; TcS CtEvidence
</span><a href="GHC.Tc.Solver.Monad.html#newWantedEvVarNC"><span class="hs-identifier hs-var">newWantedEvVarNC</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041693"><span class="hs-identifier hs-var">new_loc</span></a></span><span> </span><span class="annot"><span class="annottext">RewriterSet
</span><a href="#local-6989586621683041688"><span class="hs-identifier hs-var">rewriters</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041700"><span class="hs-identifier hs-var">pred</span></a></span><span>
</span><span id="line-159"></span><span>
</span><span id="line-160"></span><span>         </span><span class="hs-comment">-- Then we solve the wanted by pushing the call-site</span><span>
</span><span id="line-161"></span><span>         </span><span class="hs-comment">-- onto the newly emitted CallStack</span><span>
</span><span id="line-162"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621683041701"><span class="annot"><a href="#local-6989586621683041701"><span class="hs-identifier hs-var hs-var">ev_cs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FastString -&gt; RealSrcSpan -&gt; EvExpr -&gt; EvCallStack
</span><a href="GHC.Tc.Types.Evidence.html#EvCsPushCall"><span class="hs-identifier hs-var">EvCsPushCall</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtOrigin -&gt; FastString
</span><a href="GHC.Tc.Types.Origin.html#callStackOriginFS"><span class="hs-identifier hs-var">callStackOriginFS</span></a></span><span> </span><span class="annot"><span class="annottext">CtOrigin
</span><a href="#local-6989586621683041692"><span class="hs-identifier hs-var">orig</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-163"></span><span>                                  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtLoc -&gt; RealSrcSpan
</span><a href="GHC.Tc.Types.CtLoc.html#ctLocSpan"><span class="hs-identifier hs-var">ctLocSpan</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041695"><span class="hs-identifier hs-var">loc</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; CtEvidence -&gt; EvExpr
CtEvidence -&gt; EvExpr
</span><a href="GHC.Tc.Types.Constraint.html#ctEvExpr"><span class="hs-identifier hs-var">ctEvExpr</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041698"><span class="hs-identifier hs-var">new_ev</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-164"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#solveCallStack"><span class="hs-identifier hs-type">solveCallStack</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041673"><span class="hs-identifier hs-type">ev</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041701"><span class="hs-identifier hs-type">ev_cs</span></a></span><span>
</span><span id="line-165"></span><span>
</span><span id="line-166"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#continueWith"><span class="hs-identifier hs-type">continueWith</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#di_ev"><span class="hs-identifier hs-var">di_ev</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621683041698"><span class="hs-identifier hs-type">new_ev</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#di_cls"><span class="hs-identifier hs-var">di_cls</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621683041674"><span class="hs-identifier hs-type">cls</span></a></span><span>
</span><span id="line-167"></span><span>                              </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#di_tys"><span class="hs-identifier hs-var">di_tys</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621683041675"><span class="hs-identifier hs-type">tys</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#di_pend_sc"><span class="hs-identifier hs-var">di_pend_sc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#doNotExpand"><span class="hs-identifier hs-type">doNotExpand</span></a></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-168"></span><span>         </span><span class="hs-comment">-- doNotExpand: No superclasses for class CallStack</span><span>
</span><span id="line-169"></span><span>         </span><span class="hs-comment">-- See invariants in CDictCan.cc_pend_sc</span><span>
</span><span id="line-170"></span><span>
</span><span id="line-171"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-172"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TcS (StopOrContinue DictCt) -&gt; SolverStage DictCt
forall a. TcS (StopOrContinue a) -&gt; SolverStage a
</span><a href="GHC.Tc.Solver.Monad.html#Stage"><span class="hs-identifier hs-var">Stage</span></a></span><span> </span><span class="annot"><span class="annottext">(TcS (StopOrContinue DictCt) -&gt; SolverStage DictCt)
-&gt; TcS (StopOrContinue DictCt) -&gt; SolverStage DictCt
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-173"></span><span>    </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span id="local-6989586621683041706"><span class="annot"><a href="#local-6989586621683041706"><span class="hs-identifier hs-var">dflags</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TcS DynFlags
forall (m :: * -&gt; *). HasDynFlags m =&gt; m DynFlags
</span><a href="GHC.Driver.DynFlags.html#getDynFlags"><span class="hs-identifier hs-var">getDynFlags</span></a></span><span>
</span><span id="line-174"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621683041707"><span class="annot"><a href="#local-6989586621683041707"><span class="hs-identifier hs-var hs-var">fuel</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Class -&gt; Bool
</span><a href="GHC.Core.Class.html#classHasSCs"><span class="hs-identifier hs-var">classHasSCs</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041674"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DynFlags -&gt; ScDepth
</span><a href="GHC.Driver.DynFlags.html#wantedsFuel"><span class="hs-identifier hs-var">wantedsFuel</span></a></span><span> </span><span class="annot"><span class="annottext">DynFlags
</span><a href="#local-6989586621683041706"><span class="hs-identifier hs-var">dflags</span></a></span><span>
</span><span id="line-175"></span><span>                  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ScDepth
</span><a href="GHC.Tc.Types.Constraint.html#doNotExpand"><span class="hs-identifier hs-var">doNotExpand</span></a></span><span>
</span><span id="line-176"></span><span>                  </span><span class="hs-comment">-- See Invariants in `CCDictCan.cc_pend_sc`</span><span>
</span><span id="line-177"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#continueWith"><span class="hs-identifier hs-type">continueWith</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#di_ev"><span class="hs-identifier hs-var">di_ev</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621683041673"><span class="hs-identifier hs-type">ev</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#di_cls"><span class="hs-identifier hs-var">di_cls</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621683041674"><span class="hs-identifier hs-type">cls</span></a></span><span>
</span><span id="line-178"></span><span>                              </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#di_tys"><span class="hs-identifier hs-var">di_tys</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621683041675"><span class="hs-identifier hs-type">tys</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#di_pend_sc"><span class="hs-identifier hs-var">di_pend_sc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621683041707"><span class="hs-identifier hs-type">fuel</span></a></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-179"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-180"></span><span>    </span><span id="local-6989586621683041695"><span class="annot"><span class="annottext">loc :: CtLoc
</span><a href="#local-6989586621683041695"><span class="hs-identifier hs-var hs-var">loc</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; CtLoc
</span><a href="GHC.Tc.Types.Constraint.html#ctEvLoc"><span class="hs-identifier hs-var">ctEvLoc</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041673"><span class="hs-identifier hs-var">ev</span></a></span><span>
</span><span id="line-181"></span><span>    </span><span id="local-6989586621683041692"><span class="annot"><span class="annottext">orig :: CtOrigin
</span><a href="#local-6989586621683041692"><span class="hs-identifier hs-var hs-var">orig</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtLoc -&gt; CtOrigin
</span><a href="GHC.Tc.Types.CtLoc.html#ctLocOrigin"><span class="hs-identifier hs-var">ctLocOrigin</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041695"><span class="hs-identifier hs-var">loc</span></a></span><span>
</span><span id="line-182"></span><span>    </span><span id="local-6989586621683041700"><span class="annot"><span class="annottext">pred :: Type
</span><a href="#local-6989586621683041700"><span class="hs-identifier hs-var hs-var">pred</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; Type
</span><a href="GHC.Tc.Types.Constraint.html#ctEvPred"><span class="hs-identifier hs-var">ctEvPred</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041673"><span class="hs-identifier hs-var">ev</span></a></span><span>
</span><span id="line-183"></span><span>
</span><span id="line-184"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#solveCallStack"><span class="hs-identifier hs-type">solveCallStack</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CtEvidence"><span class="hs-identifier hs-type">CtEvidence</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html#EvCallStack"><span class="hs-identifier hs-type">EvCallStack</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#TcS"><span class="hs-identifier hs-type">TcS</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-185"></span><span class="hs-comment">-- Also called from GHC.Tc.Solver when defaulting call stacks</span><span>
</span><span id="line-186"></span><span id="solveCallStack"><span class="annot"><span class="annottext">solveCallStack :: CtEvidence -&gt; EvCallStack -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Dict.html#solveCallStack"><span class="hs-identifier hs-var hs-var">solveCallStack</span></a></span></span><span> </span><span id="local-6989586621683041713"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041713"><span class="hs-identifier hs-var">ev</span></a></span></span><span> </span><span id="local-6989586621683041714"><span class="annot"><span class="annottext">EvCallStack
</span><a href="#local-6989586621683041714"><span class="hs-identifier hs-var">ev_cs</span></a></span></span><span>
</span><span id="line-187"></span><span>  </span><span class="hs-comment">-- We're given ev_cs :: CallStack, but the evidence term should be a</span><span>
</span><span id="line-188"></span><span>  </span><span class="hs-comment">-- dictionary, so we have to coerce ev_cs to a dictionary for</span><span>
</span><span id="line-189"></span><span>  </span><span class="hs-comment">-- `IP ip CallStack`. See Note [Overview of implicit CallStacks]</span><span>
</span><span id="line-190"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span id="local-6989586621683041715"><span class="annot"><a href="#local-6989586621683041715"><span class="hs-identifier hs-var">cs_tm</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">EvCallStack -&gt; TcS EvExpr
forall (m :: * -&gt; *).
(MonadThings m, HasModule m, HasDynFlags m) =&gt;
EvCallStack -&gt; m EvExpr
</span><a href="GHC.Tc.Types.EvTerm.html#evCallStack"><span class="hs-identifier hs-var">evCallStack</span></a></span><span> </span><span class="annot"><span class="annottext">EvCallStack
</span><a href="#local-6989586621683041714"><span class="hs-identifier hs-var">ev_cs</span></a></span><span>
</span><span id="line-191"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621683041716"><span class="annot"><a href="#local-6989586621683041716"><span class="hs-identifier hs-var hs-var">ev_tm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">EvExpr -&gt; TcCoercion -&gt; EvTerm
</span><a href="GHC.Tc.Types.Evidence.html#mkEvCast"><span class="hs-identifier hs-var">mkEvCast</span></a></span><span> </span><span class="annot"><span class="annottext">EvExpr
</span><a href="#local-6989586621683041715"><span class="hs-identifier hs-var">cs_tm</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; TcCoercion
</span><a href="GHC.Tc.Types.Evidence.html#wrapIP"><span class="hs-identifier hs-var">wrapIP</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtEvidence -&gt; Type
</span><a href="GHC.Tc.Types.Constraint.html#ctEvPred"><span class="hs-identifier hs-var">ctEvPred</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041713"><span class="hs-identifier hs-var">ev</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-192"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#setEvBindIfWanted"><span class="hs-identifier hs-type">setEvBindIfWanted</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041713"><span class="hs-identifier hs-type">ev</span></a></span><span> </span><span class="annot"><a href="GHC.Core.InstEnv.html#EvCanonical"><span class="hs-identifier hs-type">EvCanonical</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041716"><span class="hs-identifier hs-type">ev_tm</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-193"></span><span>         </span><span class="hs-comment">-- EvCanonical: see Note [CallStack and ExecptionContext hack]</span><span>
</span><span id="line-194"></span><span>
</span><span id="line-195"></span><span class="hs-comment">{- Note [CallStack and ExecptionContext hack]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
It isn't really right that we treat CallStack and ExceptionContext dictionaries
as canonical, in the sense of Note [Coherence and specialisation: overview].
They definitely are not!

But if we use EvNonCanonical here we get lots of
    nospec (error @Int) dict  string
(since `error` takes a HasCallStack dict), and that isn't bottomng  (at least not
without extra work)  So, hackily, we just say that HasCallStack and ExceptionContext
are canonical, even though they aren't really.

Note [Shadowing of implicit parameters]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When we add a new /given/ implicit parameter to the inert set, it /replaces/
any existing givens for the same implicit parameter.  This makes a difference
in two places:

* In `GHC.Tc.Solver.InertSet.solveOneFromTheOther`, be careful when we have
   (?x :: ty) in the inert set and an identical (?x :: ty) as the work item.

* In `updInertDicts` in this module, when adding [G] (?x :: ty), remove  any
  existing [G] (?x :: ty'), regardless of ty'.

* Wrinkle (SIP1): we must be careful of superclasses.  Consider
     f,g :: (?x::Int, C a) =&gt; a -&gt; a
     f v = let ?x = 4 in g v

  The call to 'g' gives rise to a Wanted constraint (?x::Int, C a).
  We must /not/ solve this from the Given (?x::Int, C a), because of
  the intervening binding for (?x::Int).  #14218.

  We deal with this by arranging that when we add [G] (?x::ty) we delete
  * from the inert_cans, and
  * from the inert_solved_dicts
  any existing [G] (?x::ty) /and/ any [G] D tys, where (D tys) has a superclass
  with (?x::ty).  See Note [Local implicit parameters] in GHC.Core.Predicate.

  An important special case is constraint tuples like [G] (% ?x::ty, Eq a %).
  But it could happen for `class xx =&gt; D xx where ...` and the constraint D
  (?x :: int).  This corner (constraint-kinded variables instantiated with
  implicit parameter constraints) is not well explorered.

  Example in #14218, and #23761

  The code that accounts for (SIP1) is in updInertDicts; in particular the call to
  GHC.Core.Predicate.mentionsIP.

* Wrinkle (SIP2): we must apply this update semantics for `inert_solved_dicts`
  as well as `inert_cans`.
  You might think that wouldn't be necessary, because an element of
  `inert_solved_dicts` is never an implicit parameter (see
  Note [Solved dictionaries] in GHC.Tc.Solver.InertSet).
  While that is true, dictionaries in `inert_solved_dicts` may still have
  implicit parameters as a /superclass/! For example:

    class c =&gt; C c where ...
    f :: C (?x::Int) =&gt; blah

  Now (C (?x::Int)) has a superclass (?x::Int). This may look exotic, but it
  happens particularly for constraint tuples, like `(% ?x::Int, Eq a %)`.

Example 1:

Suppose we have (typecheck/should_compile/ImplicitParamFDs)
  flub :: (?x :: Int) =&gt; (Int, Integer)
  flub = (?x, let ?x = 5 in ?x)
When we are checking the last ?x occurrence, we guess its type to be a fresh
unification variable alpha and emit an (IP &quot;x&quot; alpha) constraint. But the given
(?x :: Int) has been translated to an IP &quot;x&quot; Int constraint, which has a
functional dependency from the name to the type. So if that (?x::Int) is still
in the inert set, we'd get a fundep interaction that tells us that alpha ~ Int,
and we get a type error. This is bad.  The &quot;replacement&quot; semantics stops this
happening.

Example 2:

f :: (?x :: Char) =&gt; Char
f = let ?x = 'a' in ?x

The &quot;let ?x = ...&quot; generates an implication constraint of the form:

?x :: Char =&gt; ?x :: Char

Furthermore, the signature for `f` also generates an implication
constraint, so we end up with the following nested implication:

?x :: Char =&gt; (?x :: Char =&gt; ?x :: Char)

Note that the wanted (?x :: Char) constraint may be solved in two incompatible
ways: either by using the parameter from the signature, or by using the local
definition.  Our intention is that the local definition should &quot;shadow&quot; the
parameter of the signature.  The &quot;replacement&quot; semantics for implicit parameters
does this.

Example 3:

Similarly, consider
   f :: (?x::a) =&gt; Bool -&gt; a

   g v = let ?x::Int = 3
         in (f v, let ?x::Bool = True in f v)

This should probably be well typed, with
   g :: Bool -&gt; (Int, Bool)

So the inner binding for ?x::Bool *overrides* the outer one.

See ticket #17104 for a rather tricky example of this overriding
behaviour.

All this works for the normal cases but it has an odd side effect in
some pathological programs like this:

    -- This is accepted, the second parameter shadows
    f1 :: (?x :: Int, ?x :: Char) =&gt; Char
    f1 = ?x

    -- This is rejected, the second parameter shadows
    f2 :: (?x :: Int, ?x :: Char) =&gt; Int
    f2 = ?x

Both of these are actually wrong:  when we try to use either one,
we'll get two incompatible wanted constraints (?x :: Int, ?x :: Char),
which would lead to an error.

I can think of two ways to fix this:

  1. Simply disallow multiple constraints for the same implicit
    parameter---this is never useful, and it can be detected completely
    syntactically.

  2. Move the shadowing machinery to the location where we nest
     implications, and add some code here that will produce an
     error if we get multiple givens for the same implicit parameter.
-}</span><span>
</span><span id="line-331"></span><span>
</span><span id="line-332"></span><span>
</span><span id="line-333"></span><span class="annot"><span class="hs-comment">{- ******************************************************************************
*                                                                               *
                   solveEqualityDict
*                                                                               *
****************************************************************************** -}</span></span><span>
</span><span id="line-338"></span><span>
</span><span id="line-339"></span><span class="hs-comment">{- Note [Solving equality classes]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider (~), which behaves as if it was defined like this:
  class a ~# b =&gt; a ~ b
  instance a ~# b =&gt; a ~ b
There are two more similar &quot;equality classes&quot; like this.  The full list is
  * (~)         eqTyCon
  * (~~)        heqTyCon
  * Coercible   coercibleTyCon
(See Note [The equality types story] in GHC.Builtin.Types.Prim.)

(EQC1) For Givens, when expanding the superclasses of a equality class,
  we can /replace/ the constraint with its superclasses (which, remember, are
  equally powerful) rather than /adding/ them. This can make a huge difference.
  Consider T17836, which has a constraint like
      forall b,c. a ~ (b,c) =&gt;
        forall d,e. c ~ (d,e) =&gt;
          ...etc...
  If we just /add/ the superclasses of [G] g1:a ~ (b,c), we'll put
  [G] g1:(a~(b,c)) in the inert set and emit [G] g2:a ~# (b,c).  That will
  kick out g1, and it'll be re-inserted as [G] g1':(b,c)~(b,c) which does
  no good to anyone.  When the implication is deeply nested, this has
  quadratic cost, and no benefit.  Just replace!

  (This can have a /big/ effect: test T17836 involves deeply-nested GADT
  pattern matching. Its compile-time allocation decreased by 40% when
  I added the &quot;replace&quot; rather than &quot;add&quot; semantics.)

(EQC2) Faced with [W] t1 ~ t2, it's always OK to reduce it to [W] t1 ~# t2,
  without worrying about Note [Instance and Given overlap].  Why?  Because
  if we had [G] s1 ~ s2, then we'd get the superclass [G] s1 ~# s2, and
  so the reduction of the [W] constraint does not risk losing any solutions.

  On the other hand, it can be fatal to /fail/ to reduce such equalities
  on the grounds of Note [Instance and Given overlap], because many good
  things flow from [W] t1 ~# t2.

Conclusion: we have a special solver pipeline for equality-class constraints,
`solveEqualityDict`.  It aggressively decomposes the boxed equality constraint
into an unboxed coercion, both for Givens and Wanteds, and /replaces/ the
boxed equality constraint with the unboxed one, so that the inert set never
contains the boxed one.

Note [Solving tuple constraints]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
I tried treating tuple constraints, such as (% Eq a, Show a %), rather like
equality-class constraints (see Note [Solving equality classes]). That is, by
eagerly decomposing tuple-constraints into their component (Eq a) and (Show a).

But discarding the tuple Given (which &quot;replacing&quot; does) means that we may
have to reconstruct it for a recursive call.  For example
    f :: (% Eq a, Show a %) =&gt; blah
    f x = ....(f x')....
If we decomposed eagerly we'd get
    f = \(d : (% Eq a, Show a %)).
         let de = fst d
             ds = snd d
         in ....(f (% de, ds %))...
and the optimiser may not be clever enough to transform (f (% de, ds %)) into
(f d). See #10359 and its test case, and #23398.  (This issue is less pressing for
equality classes because they have to be unpacked strictly, so CSE-ing away
the reconstruction works fine.

So at the moment we don't decompose tuple constraints eagerly; instead we mostly
just treat them like other constraints.
* Given tuples are decomposed via their superclasses, in `canDictCt`.  So
    [G] (% Eq a, Show a %)
  has superclasses
    [G] Eq a,  [G] Show a

* Wanted tuples are decomposed via a built-in &quot;instance&quot;. See
  `GHC.Tc.Instance.Class.matchCTuple`

There is a bit of special treatment: search for isCTupleClass.
-}</span><span>
</span><span id="line-414"></span><span>
</span><span id="line-415"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#solveEqualityDict"><span class="hs-identifier hs-type">solveEqualityDict</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CtEvidence"><span class="hs-identifier hs-type">CtEvidence</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.Class.html#Class"><span class="hs-identifier hs-type">Class</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#SolverStage"><span class="hs-identifier hs-type">SolverStage</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Void</span></span><span>
</span><span id="line-416"></span><span class="hs-comment">-- Precondition: (isEqualityClass cls) True, so cls is (~), (~~), or Coercible</span><span>
</span><span id="line-417"></span><span id="solveEqualityDict"><span class="annot"><span class="annottext">solveEqualityDict :: CtEvidence -&gt; Class -&gt; [Type] -&gt; SolverStage Void
</span><a href="GHC.Tc.Solver.Dict.html#solveEqualityDict"><span class="hs-identifier hs-var hs-var">solveEqualityDict</span></a></span></span><span> </span><span id="local-6989586621683041721"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041721"><span class="hs-identifier hs-var">ev</span></a></span></span><span> </span><span id="local-6989586621683041722"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041722"><span class="hs-identifier hs-var">cls</span></a></span></span><span> </span><span id="local-6989586621683041723"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041723"><span class="hs-identifier hs-var">tys</span></a></span></span><span>
</span><span id="line-418"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CtWanted"><span class="hs-identifier hs-type">CtWanted</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">ctev_dest :: CtEvidence -&gt; TcEvDest
</span><a href="GHC.Tc.Types.Constraint.html#ctev_dest"><span class="hs-identifier hs-var">ctev_dest</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041725"><span class="annot"><span class="annottext">TcEvDest
</span><a href="#local-6989586621683041725"><span class="hs-identifier hs-var">dest</span></a></span></span><span> </span><span class="hs-special">}</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041721"><span class="hs-identifier hs-var">ev</span></a></span><span>
</span><span id="line-419"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TcS (StopOrContinue Void) -&gt; SolverStage Void
forall a. TcS (StopOrContinue a) -&gt; SolverStage a
</span><a href="GHC.Tc.Solver.Monad.html#Stage"><span class="hs-identifier hs-var">Stage</span></a></span><span> </span><span class="annot"><span class="annottext">(TcS (StopOrContinue Void) -&gt; SolverStage Void)
-&gt; TcS (StopOrContinue Void) -&gt; SolverStage Void
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-420"></span><span>    </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621683041726"><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621683041726"><span class="hs-identifier hs-var hs-var">data_con</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621683041727"><span class="annot"><span class="annottext">Role
</span><a href="#local-6989586621683041727"><span class="hs-keyword hs-var hs-var">role</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621683041728"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041728"><span class="hs-identifier hs-var hs-var">t1</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621683041729"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041729"><span class="hs-identifier hs-var hs-var">t2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Class -&gt; [Type] -&gt; (DataCon, Role, Type, Type)
</span><a href="GHC.Tc.Instance.Class.html#matchEqualityInst"><span class="hs-identifier hs-var">matchEqualityInst</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041722"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041723"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-421"></span><span>         </span><span class="hs-comment">-- Unify t1~t2, putting anything that can't be solved</span><span>
</span><span id="line-422"></span><span>         </span><span class="hs-comment">-- immediately into the work list</span><span>
</span><span id="line-423"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-special">(</span><span id="local-6989586621683041730"><span class="annot"><a href="#local-6989586621683041730"><span class="hs-identifier hs-var">co</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">CtEvidence
-&gt; Role
-&gt; (UnifyEnv -&gt; TcM TcCoercion)
-&gt; TcS (TcCoercion, Cts, [EvVar])
forall a.
CtEvidence -&gt; Role -&gt; (UnifyEnv -&gt; TcM a) -&gt; TcS (a, Cts, [EvVar])
</span><a href="GHC.Tc.Solver.Monad.html#wrapUnifierTcS"><span class="hs-identifier hs-var">wrapUnifierTcS</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041721"><span class="hs-identifier hs-var">ev</span></a></span><span> </span><span class="annot"><span class="annottext">Role
</span><a href="#local-6989586621683041727"><span class="hs-keyword hs-var">role</span></a></span><span> </span><span class="annot"><span class="annottext">((UnifyEnv -&gt; TcM TcCoercion) -&gt; TcS (TcCoercion, Cts, [EvVar]))
-&gt; (UnifyEnv -&gt; TcM TcCoercion) -&gt; TcS (TcCoercion, Cts, [EvVar])
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621683041732"><span class="annot"><span class="annottext">UnifyEnv
</span><a href="#local-6989586621683041732"><span class="hs-identifier hs-var">uenv</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-424"></span><span>                       </span><span class="annot"><span class="annottext">UnifyEnv -&gt; Type -&gt; Type -&gt; TcM TcCoercion
</span><a href="GHC.Tc.Utils.Unify.html#uType"><span class="hs-identifier hs-var">uType</span></a></span><span> </span><span class="annot"><span class="annottext">UnifyEnv
</span><a href="#local-6989586621683041732"><span class="hs-identifier hs-var">uenv</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041728"><span class="hs-identifier hs-var">t1</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041729"><span class="hs-identifier hs-var">t2</span></a></span><span>
</span><span id="line-425"></span><span>         </span><span class="hs-comment">-- Set  d :: (t1~t2) = Eq# co</span><span>
</span><span id="line-426"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#setWantedEvTerm"><span class="hs-identifier hs-type">setWantedEvTerm</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041725"><span class="hs-identifier hs-type">dest</span></a></span><span> </span><span class="annot"><a href="GHC.Core.InstEnv.html#EvCanonical"><span class="hs-identifier hs-type">EvCanonical</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span>
</span><span id="line-427"></span><span>         </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html#evDataConApp"><span class="hs-identifier hs-type">evDataConApp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041726"><span class="hs-identifier hs-type">data_con</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041723"><span class="hs-identifier hs-type">tys</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.html#Coercion"><span class="hs-identifier hs-type">Coercion</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041730"><span class="hs-identifier hs-type">co</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-428"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#stopWith"><span class="hs-identifier hs-type">stopWith</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041721"><span class="hs-identifier hs-type">ev</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;Solved wanted lifted equality&quot;</span></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-429"></span><span>
</span><span id="line-430"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CtGiven"><span class="hs-identifier hs-type">CtGiven</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">ctev_evar :: CtEvidence -&gt; EvVar
</span><a href="GHC.Tc.Types.Constraint.html#ctev_evar"><span class="hs-identifier hs-var">ctev_evar</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041739"><span class="annot"><span class="annottext">EvVar
</span><a href="#local-6989586621683041739"><span class="hs-identifier hs-var">ev_id</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ctev_loc :: CtEvidence -&gt; CtLoc
</span><a href="GHC.Tc.Types.Constraint.html#ctev_loc"><span class="hs-identifier hs-var">ctev_loc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041741"><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041741"><span class="hs-identifier hs-var">loc</span></a></span></span><span> </span><span class="hs-special">}</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041721"><span class="hs-identifier hs-var">ev</span></a></span><span>
</span><span id="line-431"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span id="local-6989586621683041742"><span class="annot"><span class="annottext">EvVar
</span><a href="#local-6989586621683041742"><span class="hs-identifier hs-var">sel_id</span></a></span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Class -&gt; [EvVar]
</span><a href="GHC.Core.Class.html#classSCSelIds"><span class="hs-identifier hs-var">classSCSelIds</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041722"><span class="hs-identifier hs-var">cls</span></a></span><span>  </span><span class="hs-comment">-- Equality classes have just one superclass</span><span>
</span><span id="line-432"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TcS (StopOrContinue Void) -&gt; SolverStage Void
forall a. TcS (StopOrContinue a) -&gt; SolverStage a
</span><a href="GHC.Tc.Solver.Monad.html#Stage"><span class="hs-identifier hs-var">Stage</span></a></span><span> </span><span class="annot"><span class="annottext">(TcS (StopOrContinue Void) -&gt; SolverStage Void)
-&gt; TcS (StopOrContinue Void) -&gt; SolverStage Void
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-433"></span><span>    </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621683041744"><span class="annot"><span class="annottext">sc_pred :: Type
</span><a href="#local-6989586621683041744"><span class="hs-identifier hs-var hs-var hs-var">sc_pred</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">EvVar -&gt; [Type] -&gt; Type
</span><a href="GHC.Core.Predicate.html#classMethodInstTy"><span class="hs-identifier hs-var">classMethodInstTy</span></a></span><span> </span><span class="annot"><span class="annottext">EvVar
</span><a href="#local-6989586621683041742"><span class="hs-identifier hs-var">sel_id</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041723"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-434"></span><span>             </span><span id="local-6989586621683041746"><span class="annot"><span class="annottext">ev_expr :: EvTerm
</span><a href="#local-6989586621683041746"><span class="hs-identifier hs-var hs-var hs-var">ev_expr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">EvExpr -&gt; EvTerm
</span><a href="GHC.Tc.Types.Evidence.html#EvExpr"><span class="hs-identifier hs-var">EvExpr</span></a></span><span> </span><span class="annot"><span class="annottext">(EvExpr -&gt; EvTerm) -&gt; EvExpr -&gt; EvTerm
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">EvVar -&gt; EvExpr
forall b. EvVar -&gt; Expr b
</span><a href="GHC.Core.html#Var"><span class="hs-identifier hs-var">Var</span></a></span><span> </span><span class="annot"><span class="annottext">EvVar
</span><a href="#local-6989586621683041742"><span class="hs-identifier hs-var">sel_id</span></a></span><span> </span><span class="annot"><span class="annottext">EvExpr -&gt; [Type] -&gt; EvExpr
forall b. Expr b -&gt; [Type] -&gt; Expr b
</span><a href="GHC.Core.html#mkTyApps"><span class="hs-operator hs-var">`mkTyApps`</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041723"><span class="hs-identifier hs-var">tys</span></a></span><span> </span><span class="annot"><span class="annottext">EvExpr -&gt; EvExpr -&gt; EvExpr
forall b. Expr b -&gt; Expr b -&gt; Expr b
</span><a href="GHC.Core.html#App"><span class="hs-operator hs-var">`App`</span></a></span><span> </span><span class="annot"><span class="annottext">EvVar -&gt; EvExpr
</span><a href="GHC.Tc.Types.Evidence.html#evId"><span class="hs-identifier hs-var">evId</span></a></span><span> </span><span class="annot"><span class="annottext">EvVar
</span><a href="#local-6989586621683041739"><span class="hs-identifier hs-var">ev_id</span></a></span><span>
</span><span id="line-435"></span><span>       </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683041752"><span class="annot"><a href="#local-6989586621683041752"><span class="hs-identifier hs-var">given_ev</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">CtLoc -&gt; (Type, EvTerm) -&gt; TcS CtEvidence
</span><a href="GHC.Tc.Solver.Monad.html#newGivenEvVar"><span class="hs-identifier hs-var">newGivenEvVar</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041741"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041744"><span class="hs-identifier hs-var">sc_pred</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">EvTerm
</span><a href="#local-6989586621683041746"><span class="hs-identifier hs-var">ev_expr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-436"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#startAgainWith"><span class="hs-identifier hs-type">startAgainWith</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#mkNonCanonical"><span class="hs-identifier hs-type">mkNonCanonical</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041752"><span class="hs-identifier hs-type">given_ev</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-437"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-438"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; SolverStage Void
forall a. HasCallStack =&gt; String -&gt; SDoc -&gt; a
</span><a href="GHC.Utils.Panic.html#pprPanic"><span class="hs-identifier hs-var">pprPanic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;solveEqualityDict&quot;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Class -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041722"><span class="hs-identifier hs-var">cls</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-439"></span><span>
</span><span id="line-440"></span><span class="annot"><span class="hs-comment">{- ******************************************************************************
*                                                                               *
                   interactDict
*                                                                               *
*********************************************************************************

Note [Shortcut solving]
~~~~~~~~~~~~~~~~~~~~~~~
When we interact a [W] constraint with a [G] constraint that solves it, there is
a possibility that we could produce better code if instead we solved from a
top-level instance declaration (See #12791, #5835). For example:

    class M a b where m :: a -&gt; b

    type C a b = (Num a, M a b)

    f :: C Int b =&gt; b -&gt; Int -&gt; Int
    f _ x = x + 1

The body of `f` requires a [W] `Num Int` instance. We could solve this
constraint from the givens because we have `C Int b` and that provides us a
solution for `Num Int`. This would let us produce core like the following
(with -O2):

    f :: forall b. C Int b =&gt; b -&gt; Int -&gt; Int
    f = \ (@ b) ($d(%,%) :: C Int b) _ (eta1 :: Int) -&gt;
        + @ Int
          (GHC.Classes.$p1(%,%) @ (Num Int) @ (M Int b) $d(%,%))
          eta1
          A.f1

This is bad! We could do /much/ better if we solved [W] `Num Int` directly
from the instance that we have in scope:

    f :: forall b. C Int b =&gt; b -&gt; Int -&gt; Int
    f = \ (@ b) _ _ (x :: Int) -&gt;
        case x of { GHC.Types.I# x1 -&gt; GHC.Types.I# (GHC.Prim.+# x1 1#) }

** NB: It is important to emphasize that all this is purely an optimization:
** exactly the same programs should typecheck with or without this
** procedure.

Solving fully
~~~~~~~~~~~~~
There is a reason why the solver does not simply try to solve such
constraints with top-level instances. If the solver finds a relevant
instance declaration in scope, that instance may require a context
that can't be solved for. A good example of this is:

    f :: Ord [a] =&gt; ...
    f x = ..Need Eq [a]...

If we have instance `Eq a =&gt; Eq [a]` in scope and we tried to use it, we would
be left with the obligation to solve the constraint Eq a, which we cannot. So we
must be conservative in our attempt to use an instance declaration to solve the
[W] constraint we're interested in.

Our rule is that we try to solve all of the instance's subgoals
recursively all at once. Precisely: We only attempt to solve
constraints of the form `C1, ... Cm =&gt; C t1 ... t n`, where all the Ci
are themselves class constraints of the form `C1', ... Cm' =&gt; C' t1'
... tn'` and we only succeed if the entire tree of constraints is
solvable from instances.

An example that succeeds:

    class Eq a =&gt; C a b | b -&gt; a where
      m :: b -&gt; a

    f :: C [Int] b =&gt; b -&gt; Bool
    f x = m x == []

We solve for `Eq [Int]`, which requires `Eq Int`, which we also have. This
produces the following core:

    f :: forall b. C [Int] b =&gt; b -&gt; Bool
    f = \ (@ b) ($dC :: C [Int] b) (x :: b) -&gt;
        GHC.Classes.$fEq[]_$s$c==
          (m @ [Int] @ b $dC x) (GHC.Types.[] @ Int)

An example that fails:

    class Eq a =&gt; C a b | b -&gt; a where
      m :: b -&gt; a

    f :: C [a] b =&gt; b -&gt; Bool
    f x = m x == []

Which, because solving `Eq [a]` demands `Eq a` which we cannot solve, produces:

    f :: forall a b. C [a] b =&gt; b -&gt; Bool
    f = \ (@ a) (@ b) ($dC :: C [a] b) (eta :: b) -&gt;
        ==
          @ [a]
          (A.$p1C @ [a] @ b $dC)
          (m @ [a] @ b $dC eta)
          (GHC.Types.[] @ a)

Note [Shortcut solving: type families]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Suppose we have (#13943)
  class Take (n :: Nat) where ...
  instance {-# OVERLAPPING #-}                    Take 0 where ..
  instance {-# OVERLAPPABLE #-} (Take (n - 1)) =&gt; Take n where ..

And we have [W] Take 3.  That only matches one instance so we get
[W] Take (3-1).  Really we should now rewrite to reduce the (3-1) to 2, and
so on -- but that is reproducing yet more of the solver.  Sigh.  For now,
we just give up (remember all this is just an optimisation).

But we must not just naively try to lookup (Take (3-1)) in the
InstEnv, or it'll (wrongly) appear not to match (Take 0) and get a
unique match on the (Take n) instance.  That leads immediately to an
infinite loop.  Hence the check that 'preds' have no type families
(isTyFamFree).

Note [Shortcut solving: incoherence]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This optimization relies on coherence of dictionaries to be correct. When we
cannot assume coherence because of IncoherentInstances then this optimization
can change the behavior of the user's code.

The following four modules produce a program whose output would change depending
on whether we apply this optimization when IncoherentInstances is in effect:

=========
    {-# LANGUAGE MultiParamTypeClasses #-}
    module A where

    class A a where
      int :: a -&gt; Int

    class A a =&gt; C a b where
      m :: b -&gt; a -&gt; a

=========
    {-# LANGUAGE FlexibleInstances     #-}
    {-# LANGUAGE MultiParamTypeClasses #-}
    module B where

    import A

    instance A a where
      int _ = 1

    instance C a [b] where
      m _ = id

=========
    {-# LANGUAGE FlexibleContexts      #-}
    {-# LANGUAGE FlexibleInstances     #-}
    {-# LANGUAGE IncoherentInstances   #-}
    {-# LANGUAGE MultiParamTypeClasses #-}
    module C where

    import A

    instance A Int where
      int _ = 2

    instance C Int [Int] where
      m _ = id

    intC :: C Int a =&gt; a -&gt; Int -&gt; Int
    intC _ x = int x

=========
    module Main where

    import A
    import B
    import C

    main :: IO ()
    main = print (intC [] (0::Int))

The output of `main` if we avoid the optimization under the effect of
IncoherentInstances is `1`. If we were to do the optimization, the output of
`main` would be `2`.

Note [Shortcut try_solve_from_instance]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The workhorse of the short-cut solver is
    try_solve_from_instance :: (EvBindMap, DictMap CtEvidence)
                            -&gt; CtEvidence       -- Solve this
                            -&gt; MaybeT TcS (EvBindMap, DictMap CtEvidence)
Note that:

* The CtEvidence is the goal to be solved

* The MaybeT manages early failure if we find a subgoal that
  cannot be solved from instances.

* The (EvBindMap, DictMap CtEvidence) is an accumulating purely-functional
  state that allows try_solve_from_instance to augment the evidence
  bindings and inert_solved_dicts as it goes.

  If it succeeds, we commit all these bindings and solved dicts to the
  main TcS InertSet.  If not, we abandon it all entirely.

Passing along the solved_dicts important for two reasons:

* We need to be able to handle recursive super classes. The
  solved_dicts state  ensures that we remember what we have already
  tried to solve to avoid looping.

* As #15164 showed, it can be important to exploit sharing between
  goals. E.g. To solve G we may need G1 and G2. To solve G1 we may need H;
  and to solve G2 we may need H. If we don't spot this sharing we may
  solve H twice; and if this pattern repeats we may get exponentially bad
  behaviour.

Note [No Given/Given fundeps]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We do not create constraints from:
* Given/Given interactions via functional dependencies or type family
  injectivity annotations.
* Given/instance fundep interactions via functional dependencies or
  type family injectivity annotations.

In this Note, all these interactions are called just &quot;fundeps&quot;.

We ingore such fundeps for several reasons:

1. These fundeps will never serve a purpose in accepting more
   programs: Given constraints do not contain metavariables that could
   be unified via exploring fundeps. They *could* be useful in
   discovering inaccessible code. However, the constraints will be
   Wanteds, and as such will cause errors (not just warnings) if they
   go unsolved. Maybe there is a clever way to get the right
   inaccessible code warnings, but the path forward is far from
   clear. #12466 has further commentary.

2. Furthermore, here is a case where a Given/instance interaction is actively
   harmful (from dependent/should_compile/RaeJobTalk):

       type family a == b :: Bool
       type family Not a = r | r -&gt; a where
         Not False = True
         Not True  = False

       [G] Not (a == b) ~ True

   Reacting this Given with the equations for Not produces

      [W] a == b ~ False

   This is indeed a true consequence, and would make sense as a fresh Given.
   But we don't have a way to produce evidence for fundeps, as a Wanted it
   is /harmful/: we can't prove it, and so we'll report an error and reject
   the program. (Previously fundeps gave rise to Deriveds, which
   carried no evidence, so it didn't matter that they could not be proved.)

3. #20922 showed a subtle different problem with Given/instance fundeps.
      type family ZipCons (as :: [k]) (bssx :: [[k]]) = (r :: [[k]]) | r -&gt; as bssx where
        ZipCons (a ': as) (bs ': bss) = (a ': bs) ': ZipCons as bss
        ...

      tclevel = 4
      [G] ZipCons is1 iss ~ (i : is2) : jss

   (The tclevel=4 means that this Given is at level 4.)  The fundep tells us that
   'iss' must be of form (is2 : beta[4]) where beta[4] is a fresh unification
   variable; we don't know what type it stands for. So we would emit
      [W] iss ~ is2 : beta

   Again we can't prove that equality; and worse we'll rewrite iss to
   (is2:beta) in deeply nested constraints inside this implication,
   where beta is untouchable (under other equality constraints), leading
   to other insoluble constraints.

The bottom line: since we have no evidence for them, we should ignore Given/Given
and Given/instance fundeps entirely.
-}</span></span><span>
</span><span id="line-714"></span><span>
</span><span id="line-715"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#tryInertDicts"><span class="hs-identifier hs-type">tryInertDicts</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#SolverStage"><span class="hs-identifier hs-type">SolverStage</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-716"></span><span id="tryInertDicts"><span class="annot"><span class="annottext">tryInertDicts :: DictCt -&gt; SolverStage ()
</span><a href="GHC.Tc.Solver.Dict.html#tryInertDicts"><span class="hs-identifier hs-var hs-var">tryInertDicts</span></a></span></span><span> </span><span id="local-6989586621683041757"><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041757"><span class="hs-identifier hs-var">dict_ct</span></a></span></span><span>
</span><span id="line-717"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TcS (StopOrContinue ()) -&gt; SolverStage ()
forall a. TcS (StopOrContinue a) -&gt; SolverStage a
</span><a href="GHC.Tc.Solver.Monad.html#Stage"><span class="hs-identifier hs-var">Stage</span></a></span><span> </span><span class="annot"><span class="annottext">(TcS (StopOrContinue ()) -&gt; SolverStage ())
-&gt; TcS (StopOrContinue ()) -&gt; SolverStage ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span id="local-6989586621683041758"><span class="annot"><a href="#local-6989586621683041758"><span class="hs-identifier hs-var">inerts</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TcS InertCans
</span><a href="GHC.Tc.Solver.Monad.html#getInertCans"><span class="hs-identifier hs-var">getInertCans</span></a></span><span>
</span><span id="line-718"></span><span>               </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#try_inert_dicts"><span class="hs-identifier hs-type">try_inert_dicts</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041758"><span class="hs-identifier hs-type">inerts</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041757"><span class="hs-identifier hs-type">dict_ct</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-719"></span><span>
</span><span id="line-720"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#try_inert_dicts"><span class="hs-identifier hs-type">try_inert_dicts</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.InertSet.html#InertCans"><span class="hs-identifier hs-type">InertCans</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#TcS"><span class="hs-identifier hs-type">TcS</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#StopOrContinue"><span class="hs-identifier hs-type">StopOrContinue</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-721"></span><span id="try_inert_dicts"><span class="annot"><span class="annottext">try_inert_dicts :: InertCans -&gt; DictCt -&gt; TcS (StopOrContinue ())
</span><a href="GHC.Tc.Solver.Dict.html#try_inert_dicts"><span class="hs-identifier hs-var hs-var">try_inert_dicts</span></a></span></span><span> </span><span id="local-6989586621683041761"><span class="annot"><span class="annottext">InertCans
</span><a href="#local-6989586621683041761"><span class="hs-identifier hs-var">inerts</span></a></span></span><span> </span><span id="local-6989586621683041762"><span class="annot"><span class="annottext">dict_w :: DictCt
</span><a href="#local-6989586621683041762"><span class="hs-identifier hs-var">dict_w</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">di_ev :: DictCt -&gt; CtEvidence
</span><a href="GHC.Tc.Types.Constraint.html#di_ev"><span class="hs-identifier hs-var">di_ev</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041763"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041763"><span class="hs-identifier hs-var">ev_w</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">di_cls :: DictCt -&gt; Class
</span><a href="GHC.Tc.Types.Constraint.html#di_cls"><span class="hs-identifier hs-var">di_cls</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041764"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041764"><span class="hs-identifier hs-var">cls</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">di_tys :: DictCt -&gt; [Type]
</span><a href="GHC.Tc.Types.Constraint.html#di_tys"><span class="hs-identifier hs-var">di_tys</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041765"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041765"><span class="hs-identifier hs-var">tys</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-722"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621683041766"><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041766"><span class="hs-identifier hs-var">dict_i</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">InertCans -&gt; CtLoc -&gt; Class -&gt; [Type] -&gt; Maybe DictCt
</span><a href="GHC.Tc.Solver.Monad.html#lookupInertDict"><span class="hs-identifier hs-var">lookupInertDict</span></a></span><span> </span><span class="annot"><span class="annottext">InertCans
</span><a href="#local-6989586621683041761"><span class="hs-identifier hs-var">inerts</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtEvidence -&gt; CtLoc
</span><a href="GHC.Tc.Types.Constraint.html#ctEvLoc"><span class="hs-identifier hs-var">ctEvLoc</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041763"><span class="hs-identifier hs-var">ev_w</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041764"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041765"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-723"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621683041768"><span class="annot"><span class="annottext">ev_i :: CtEvidence
</span><a href="#local-6989586621683041768"><span class="hs-identifier hs-var hs-var">ev_i</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DictCt -&gt; CtEvidence
</span><a href="GHC.Tc.Types.Constraint.html#dictCtEvidence"><span class="hs-identifier hs-var">dictCtEvidence</span></a></span><span> </span><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041766"><span class="hs-identifier hs-var">dict_i</span></a></span><span>
</span><span id="line-724"></span><span>        </span><span id="local-6989586621683041769"><span class="annot"><span class="annottext">loc_i :: CtLoc
</span><a href="#local-6989586621683041769"><span class="hs-identifier hs-var hs-var">loc_i</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; CtLoc
</span><a href="GHC.Tc.Types.Constraint.html#ctEvLoc"><span class="hs-identifier hs-var">ctEvLoc</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041768"><span class="hs-identifier hs-var">ev_i</span></a></span><span>
</span><span id="line-725"></span><span>        </span><span id="local-6989586621683041770"><span class="annot"><span class="annottext">loc_w :: CtLoc
</span><a href="#local-6989586621683041770"><span class="hs-identifier hs-var hs-var">loc_w</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; CtLoc
</span><a href="GHC.Tc.Types.Constraint.html#ctEvLoc"><span class="hs-identifier hs-var">ctEvLoc</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041763"><span class="hs-identifier hs-var">ev_w</span></a></span><span>
</span><span id="line-726"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- There is a matching dictionary in the inert set</span><span>
</span><span id="line-727"></span><span>    </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-comment">-- First to try to solve it /completely/ from top level instances</span><span>
</span><span id="line-728"></span><span>         </span><span class="hs-comment">-- See Note [Shortcut solving]</span><span>
</span><span id="line-729"></span><span>         </span><span id="local-6989586621683041771"><span class="annot"><a href="#local-6989586621683041771"><span class="hs-identifier hs-var">dflags</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TcS DynFlags
forall (m :: * -&gt; *). HasDynFlags m =&gt; m DynFlags
</span><a href="GHC.Driver.DynFlags.html#getDynFlags"><span class="hs-identifier hs-var">getDynFlags</span></a></span><span>
</span><span id="line-730"></span><span>       </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683041772"><span class="annot"><a href="#local-6989586621683041772"><span class="hs-identifier hs-var">short_cut_worked</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#shortCutSolver"><span class="hs-identifier hs-type">shortCutSolver</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041771"><span class="hs-identifier hs-type">dflags</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041763"><span class="hs-identifier hs-type">ev_w</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041768"><span class="hs-identifier hs-type">ev_i</span></a></span><span>
</span><span id="line-731"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><a href="#local-6989586621683041772"><span class="hs-identifier hs-type">short_cut_worked</span></a></span><span>
</span><span id="line-732"></span><span>         </span><span class="hs-keyword">then</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#stopWith"><span class="hs-identifier hs-type">stopWith</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041763"><span class="hs-identifier hs-type">ev_w</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;interactDict/solved from instance&quot;</span></span><span>
</span><span id="line-733"></span><span>
</span><span id="line-734"></span><span>         </span><span class="hs-comment">-- Next see if we are in &quot;loopy-superclass&quot; land.  If so,</span><span>
</span><span id="line-735"></span><span>         </span><span class="hs-comment">-- we don't want to replace the (Given) inert with the</span><span>
</span><span id="line-736"></span><span>         </span><span class="hs-comment">-- (Wanted) work-item, or vice versa; we want to hang on</span><span>
</span><span id="line-737"></span><span>         </span><span class="hs-comment">-- to both, and try to solve the work-item via an instance.</span><span>
</span><span id="line-738"></span><span>         </span><span class="hs-comment">-- See Note [Solving superclass constraints] in GHC.Tc.TyCl.Instance</span><span>
</span><span id="line-739"></span><span>         </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.InertSet.html#prohibitedSuperClassSolve"><span class="hs-identifier hs-type">prohibitedSuperClassSolve</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041769"><span class="hs-identifier hs-type">loc_i</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041770"><span class="hs-identifier hs-type">loc_w</span></a></span><span>
</span><span id="line-740"></span><span>         </span><span class="hs-keyword">then</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#continueWith"><span class="hs-identifier hs-type">continueWith</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-741"></span><span>         </span><span class="hs-keyword">else</span><span>
</span><span id="line-742"></span><span>    </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-comment">-- The short-cut solver didn't fire, and loopy superclasses</span><span>
</span><span id="line-743"></span><span>         </span><span class="hs-comment">-- are dealt with, so we can either solve</span><span>
</span><span id="line-744"></span><span>         </span><span class="hs-comment">-- the inert from the work-item or vice-versa.</span><span>
</span><span id="line-745"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.InertSet.html#solveOneFromTheOther"><span class="hs-identifier hs-type">solveOneFromTheOther</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CDictCan"><span class="hs-identifier hs-type">CDictCan</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041766"><span class="hs-identifier hs-type">dict_i</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CDictCan"><span class="hs-identifier hs-type">CDictCan</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041762"><span class="hs-identifier hs-type">dict_w</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-746"></span><span>           </span><span class="annot"><span class="annottext">InteractResult
</span><a href="GHC.Tc.Solver.InertSet.html#KeepInert"><span class="hs-identifier hs-var">KeepInert</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-var">traceTcS</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;lookupInertDict:KeepInert&quot;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DictCt -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041762"><span class="hs-identifier hs-var">dict_w</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-747"></span><span>                           </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; CanonicalEvidence -&gt; EvTerm -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#setEvBindIfWanted"><span class="hs-identifier hs-var">setEvBindIfWanted</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041763"><span class="hs-identifier hs-var">ev_w</span></a></span><span> </span><span class="annot"><span class="annottext">CanonicalEvidence
</span><a href="GHC.Core.InstEnv.html#EvCanonical"><span class="hs-identifier hs-var">EvCanonical</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtEvidence -&gt; EvTerm
</span><a href="GHC.Tc.Types.Constraint.html#ctEvTerm"><span class="hs-identifier hs-var">ctEvTerm</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041768"><span class="hs-identifier hs-var">ev_i</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-748"></span><span>                           </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">StopOrContinue () -&gt; TcS (StopOrContinue ())
forall a. a -&gt; TcS a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(StopOrContinue () -&gt; TcS (StopOrContinue ()))
-&gt; StopOrContinue () -&gt; TcS (StopOrContinue ())
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; SDoc -&gt; StopOrContinue ()
forall a. CtEvidence -&gt; SDoc -&gt; StopOrContinue a
</span><a href="GHC.Tc.Solver.Monad.html#Stop"><span class="hs-identifier hs-var">Stop</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041763"><span class="hs-identifier hs-var">ev_w</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; SDoc
forall doc. IsLine doc =&gt; String -&gt; doc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Dict equal&quot;</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">DictCt -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041762"><span class="hs-identifier hs-var">dict_w</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-749"></span><span>           </span><span class="annot"><span class="annottext">InteractResult
</span><a href="GHC.Tc.Solver.InertSet.html#KeepWork"><span class="hs-identifier hs-var">KeepWork</span></a></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-var">traceTcS</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;lookupInertDict:KeepWork&quot;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DictCt -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041762"><span class="hs-identifier hs-var">dict_w</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-750"></span><span>                           </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; CanonicalEvidence -&gt; EvTerm -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#setEvBindIfWanted"><span class="hs-identifier hs-var">setEvBindIfWanted</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041768"><span class="hs-identifier hs-var">ev_i</span></a></span><span> </span><span class="annot"><span class="annottext">CanonicalEvidence
</span><a href="GHC.Core.InstEnv.html#EvCanonical"><span class="hs-identifier hs-var">EvCanonical</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtEvidence -&gt; EvTerm
</span><a href="GHC.Tc.Types.Constraint.html#ctEvTerm"><span class="hs-identifier hs-var">ctEvTerm</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041763"><span class="hs-identifier hs-var">ev_w</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-751"></span><span>                           </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">(InertCans -&gt; InertCans) -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#updInertCans"><span class="hs-identifier hs-var">updInertCans</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(DictMap DictCt -&gt; DictMap DictCt) -&gt; InertCans -&gt; InertCans
</span><a href="GHC.Tc.Solver.InertSet.html#updDicts"><span class="hs-identifier hs-var">updDicts</span></a></span><span> </span><span class="annot"><span class="annottext">((DictMap DictCt -&gt; DictMap DictCt) -&gt; InertCans -&gt; InertCans)
-&gt; (DictMap DictCt -&gt; DictMap DictCt) -&gt; InertCans -&gt; InertCans
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">DictCt -&gt; DictMap DictCt -&gt; DictMap DictCt
forall a. DictCt -&gt; DictMap a -&gt; DictMap a
</span><a href="GHC.Tc.Solver.InertSet.html#delDict"><span class="hs-identifier hs-var">delDict</span></a></span><span> </span><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041762"><span class="hs-identifier hs-var">dict_w</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-752"></span><span>                           </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">() -&gt; TcS (StopOrContinue ())
forall a. a -&gt; TcS (StopOrContinue a)
</span><a href="GHC.Tc.Solver.Monad.html#continueWith"><span class="hs-identifier hs-var">continueWith</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span> </span><span class="hs-special">}</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-753"></span><span>
</span><span id="line-754"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-755"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-var">traceTcS</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;tryInertDicts:no&quot;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DictCt -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041762"><span class="hs-identifier hs-var">dict_w</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsDoc doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%24%24"><span class="hs-operator hs-var">$$</span></a></span><span> </span><span class="annot"><span class="annottext">Class -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041764"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041765"><span class="hs-identifier hs-var">tys</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-756"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">() -&gt; TcS (StopOrContinue ())
forall a. a -&gt; TcS (StopOrContinue a)
</span><a href="GHC.Tc.Solver.Monad.html#continueWith"><span class="hs-identifier hs-var">continueWith</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-757"></span><span>
</span><span id="line-758"></span><span class="hs-comment">-- See Note [Shortcut solving]</span><span>
</span><span id="line-759"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#shortCutSolver"><span class="hs-identifier hs-type">shortCutSolver</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Driver.DynFlags.html#DynFlags"><span class="hs-identifier hs-type">DynFlags</span></a></span><span>
</span><span id="line-760"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CtEvidence"><span class="hs-identifier hs-type">CtEvidence</span></a></span><span> </span><span class="hs-comment">-- Work item</span><span>
</span><span id="line-761"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CtEvidence"><span class="hs-identifier hs-type">CtEvidence</span></a></span><span> </span><span class="hs-comment">-- Inert we want to try to replace</span><span>
</span><span id="line-762"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#TcS"><span class="hs-identifier hs-type">TcS</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>   </span><span class="hs-comment">-- True &lt;=&gt; success</span><span>
</span><span id="line-763"></span><span id="shortCutSolver"><span class="annot"><span class="annottext">shortCutSolver :: DynFlags -&gt; CtEvidence -&gt; CtEvidence -&gt; TcS Bool
</span><a href="GHC.Tc.Solver.Dict.html#shortCutSolver"><span class="hs-identifier hs-var hs-var">shortCutSolver</span></a></span></span><span> </span><span id="local-6989586621683041783"><span class="annot"><span class="annottext">DynFlags
</span><a href="#local-6989586621683041783"><span class="hs-identifier hs-var">dflags</span></a></span></span><span> </span><span id="local-6989586621683041784"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041784"><span class="hs-identifier hs-var">ev_w</span></a></span></span><span> </span><span id="local-6989586621683041785"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041785"><span class="hs-identifier hs-var">ev_i</span></a></span></span><span>
</span><span id="line-764"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; Bool
</span><a href="GHC.Tc.Types.Constraint.html#isWanted"><span class="hs-identifier hs-var">isWanted</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041784"><span class="hs-identifier hs-var">ev_w</span></a></span><span>
</span><span id="line-765"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; Bool
</span><a href="GHC.Tc.Types.Constraint.html#isGiven"><span class="hs-identifier hs-var">isGiven</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041785"><span class="hs-identifier hs-var">ev_i</span></a></span><span>
</span><span id="line-766"></span><span>    </span><span class="hs-comment">-- We are about to solve a [W] constraint from a [G] constraint. We take</span><span>
</span><span id="line-767"></span><span>    </span><span class="hs-comment">-- a moment to see if we can get a better solution using an instance.</span><span>
</span><span id="line-768"></span><span>    </span><span class="hs-comment">-- Note that we only do this for the sake of performance. Exactly the same</span><span>
</span><span id="line-769"></span><span>    </span><span class="hs-comment">-- programs should typecheck regardless of whether we take this step or</span><span>
</span><span id="line-770"></span><span>    </span><span class="hs-comment">-- not. See Note [Shortcut solving]</span><span>
</span><span id="line-771"></span><span>
</span><span id="line-772"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Bool
</span><a href="GHC.Core.Predicate.html#isIPLikePred"><span class="hs-identifier hs-var">isIPLikePred</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtEvidence -&gt; Type
</span><a href="GHC.Tc.Types.Constraint.html#ctEvPred"><span class="hs-identifier hs-var">ctEvPred</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041784"><span class="hs-identifier hs-var">ev_w</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- Not for implicit parameters (#18627)</span><span>
</span><span id="line-773"></span><span>
</span><span id="line-774"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Extension -&gt; DynFlags -&gt; Bool
</span><a href="GHC.Driver.DynFlags.html#xopt"><span class="hs-identifier hs-var">xopt</span></a></span><span> </span><span class="annot"><span class="annottext">Extension
</span><span class="hs-identifier hs-var">LangExt.IncoherentInstances</span></span><span> </span><span class="annot"><span class="annottext">DynFlags
</span><a href="#local-6989586621683041783"><span class="hs-identifier hs-var">dflags</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-775"></span><span>    </span><span class="hs-comment">-- If IncoherentInstances is on then we cannot rely on coherence of proofs</span><span>
</span><span id="line-776"></span><span>    </span><span class="hs-comment">-- in order to justify this optimization: The proof provided by the</span><span>
</span><span id="line-777"></span><span>    </span><span class="hs-comment">-- [G] constraint's superclass may be different from the top-level proof.</span><span>
</span><span id="line-778"></span><span>    </span><span class="hs-comment">-- See Note [Shortcut solving: incoherence]</span><span>
</span><span id="line-779"></span><span>
</span><span id="line-780"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">GeneralFlag -&gt; DynFlags -&gt; Bool
</span><a href="GHC.Driver.DynFlags.html#gopt"><span class="hs-identifier hs-var">gopt</span></a></span><span> </span><span class="annot"><span class="annottext">GeneralFlag
</span><a href="GHC.Driver.Flags.html#Opt_SolveConstantDicts"><span class="hs-identifier hs-var">Opt_SolveConstantDicts</span></a></span><span> </span><span class="annot"><span class="annottext">DynFlags
</span><a href="#local-6989586621683041783"><span class="hs-identifier hs-var">dflags</span></a></span><span>
</span><span id="line-781"></span><span>    </span><span class="hs-comment">-- Enabled by the -fsolve-constant-dicts flag</span><span>
</span><span id="line-782"></span><span>
</span><span id="line-783"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span id="local-6989586621683041792"><span class="annot"><a href="#local-6989586621683041792"><span class="hs-identifier hs-var">ev_binds_var</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TcS EvBindsVar
</span><a href="GHC.Tc.Solver.Monad.html#getTcEvBindsVar"><span class="hs-identifier hs-var">getTcEvBindsVar</span></a></span><span>
</span><span id="line-784"></span><span>       </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683041794"><span class="annot"><a href="#local-6989586621683041794"><span class="hs-identifier hs-var">ev_binds</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="GHC.Utils.Panic.html#assertPpr"><span class="hs-identifier hs-type">assertPpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Evidence.html#isCoEvBindsVar"><span class="hs-identifier hs-type">isCoEvBindsVar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041792"><span class="hs-identifier hs-type">ev_binds_var</span></a></span><span> </span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-type">ppr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041784"><span class="hs-identifier hs-type">ev_w</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span>
</span><span id="line-785"></span><span>                     </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#getTcEvBindsMap"><span class="hs-identifier hs-type">getTcEvBindsMap</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041792"><span class="hs-identifier hs-type">ev_binds_var</span></a></span><span>
</span><span id="line-786"></span><span>       </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683041797"><span class="annot"><a href="#local-6989586621683041797"><span class="hs-identifier hs-var">solved_dicts</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#getSolvedDicts"><span class="hs-identifier hs-type">getSolvedDicts</span></a></span><span>
</span><span id="line-787"></span><span>
</span><span id="line-788"></span><span>       </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683041799"><span class="annot"><a href="#local-6989586621683041799"><span class="hs-identifier hs-var">mb_stuff</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="../../transformers-0.6.1.2-38b1/src/Control.Monad.Trans.Maybe.html#runMaybeT"><span class="hs-identifier hs-var">runMaybeT</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span>
</span><span id="line-789"></span><span>                     </span><span class="annot"><a href="#local-6989586621683041800"><span class="hs-identifier hs-type">try_solve_from_instance</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621683041794"><span class="hs-identifier hs-type">ev_binds</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621683041797"><span class="hs-identifier hs-type">solved_dicts</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621683041784"><span class="hs-identifier hs-type">ev_w</span></a></span><span>
</span><span id="line-790"></span><span>
</span><span id="line-791"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621683041799"><span class="hs-identifier hs-type">mb_stuff</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-792"></span><span>           </span><span class="annot"><span class="annottext">Maybe (EvBindMap, DictMap DictCt)
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; TcS Bool
forall a. a -&gt; TcS a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-793"></span><span>           </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621683041801"><span class="annot"><span class="annottext">EvBindMap
</span><a href="#local-6989586621683041801"><span class="hs-identifier hs-var">ev_binds'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621683041802"><span class="annot"><span class="annottext">DictMap DictCt
</span><a href="#local-6989586621683041802"><span class="hs-identifier hs-var">solved_dicts'</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-794"></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">EvBindsVar -&gt; EvBindMap -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#setTcEvBindsMap"><span class="hs-identifier hs-var">setTcEvBindsMap</span></a></span><span> </span><span class="annot"><span class="annottext">EvBindsVar
</span><a href="#local-6989586621683041792"><span class="hs-identifier hs-var">ev_binds_var</span></a></span><span> </span><span class="annot"><span class="annottext">EvBindMap
</span><a href="#local-6989586621683041801"><span class="hs-identifier hs-var">ev_binds'</span></a></span><span>
</span><span id="line-795"></span><span>                    </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">DictMap DictCt -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#setSolvedDicts"><span class="hs-identifier hs-var">setSolvedDicts</span></a></span><span> </span><span class="annot"><span class="annottext">DictMap DictCt
</span><a href="#local-6989586621683041802"><span class="hs-identifier hs-var">solved_dicts'</span></a></span><span>
</span><span id="line-796"></span><span>                    </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; TcS Bool
forall a. a -&gt; TcS a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="hs-special">}</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-797"></span><span>
</span><span id="line-798"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-799"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; TcS Bool
forall a. a -&gt; TcS a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-800"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-801"></span><span>    </span><span class="hs-comment">-- This `CtLoc` is used only to check the well-staged condition of any</span><span>
</span><span id="line-802"></span><span>    </span><span class="hs-comment">-- candidate DFun. Our subgoals all have the same stage as our root</span><span>
</span><span id="line-803"></span><span>    </span><span class="hs-comment">-- [W] constraint so it is safe to use this while solving them.</span><span>
</span><span id="line-804"></span><span>    </span><span id="local-6989586621683041805"><span class="annot"><span class="annottext">loc_w :: CtLoc
</span><a href="#local-6989586621683041805"><span class="hs-identifier hs-var hs-var">loc_w</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; CtLoc
</span><a href="GHC.Tc.Types.Constraint.html#ctEvLoc"><span class="hs-identifier hs-var">ctEvLoc</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041784"><span class="hs-identifier hs-var">ev_w</span></a></span><span>
</span><span id="line-805"></span><span>
</span><span id="line-806"></span><span>    </span><span class="annot"><a href="#local-6989586621683041800"><span class="hs-identifier hs-type">try_solve_from_instance</span></a></span><span>   </span><span class="hs-comment">-- See Note [Shortcut try_solve_from_instance]</span><span>
</span><span id="line-807"></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Evidence.html#EvBindMap"><span class="hs-identifier hs-type">EvBindMap</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Types.html#DictMap"><span class="hs-identifier hs-type">DictMap</span></a></span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CtEvidence"><span class="hs-identifier hs-type">CtEvidence</span></a></span><span>
</span><span id="line-808"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../transformers-0.6.1.2-38b1/src/Control.Monad.Trans.Maybe.html#MaybeT"><span class="hs-identifier hs-type">MaybeT</span></a></span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#TcS"><span class="hs-identifier hs-type">TcS</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Evidence.html#EvBindMap"><span class="hs-identifier hs-type">EvBindMap</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Types.html#DictMap"><span class="hs-identifier hs-type">DictMap</span></a></span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-809"></span><span>    </span><span id="local-6989586621683041800"><span class="annot"><span class="annottext">try_solve_from_instance :: (EvBindMap, DictMap DictCt)
-&gt; CtEvidence -&gt; MaybeT TcS (EvBindMap, DictMap DictCt)
</span><a href="#local-6989586621683041800"><span class="hs-identifier hs-var hs-var">try_solve_from_instance</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621683041806"><span class="annot"><span class="annottext">EvBindMap
</span><a href="#local-6989586621683041806"><span class="hs-identifier hs-var">ev_binds</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621683041807"><span class="annot"><span class="annottext">DictMap DictCt
</span><a href="#local-6989586621683041807"><span class="hs-identifier hs-var">solved_dicts</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621683041808"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041808"><span class="hs-identifier hs-var">ev</span></a></span></span><span>
</span><span id="line-810"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621683041809"><span class="annot"><span class="annottext">pred :: Type
</span><a href="#local-6989586621683041809"><span class="hs-identifier hs-var hs-var">pred</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; Type
</span><a href="GHC.Tc.Types.Constraint.html#ctEvPred"><span class="hs-identifier hs-var">ctEvPred</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041808"><span class="hs-identifier hs-var">ev</span></a></span><span>
</span><span id="line-811"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Core.Predicate.html#ClassPred"><span class="hs-identifier hs-type">ClassPred</span></a></span><span> </span><span id="local-6989586621683041811"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041811"><span class="hs-identifier hs-var">cls</span></a></span></span><span> </span><span id="local-6989586621683041812"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041812"><span class="hs-identifier hs-var">tys</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Pred
</span><a href="GHC.Core.Predicate.html#classifyPredType"><span class="hs-identifier hs-var">classifyPredType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041809"><span class="hs-identifier hs-var">pred</span></a></span><span>
</span><span id="line-812"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span id="local-6989586621683041814"><span class="annot"><a href="#local-6989586621683041814"><span class="hs-identifier hs-var">inst_res</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TcS ClsInstResult -&gt; MaybeT TcS ClsInstResult
forall (m :: * -&gt; *) a. Monad m =&gt; m a -&gt; MaybeT m a
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><a href="../../transformers-0.6.1.2-38b1/src/Control.Monad.Trans.Class.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(TcS ClsInstResult -&gt; MaybeT TcS ClsInstResult)
-&gt; TcS ClsInstResult -&gt; MaybeT TcS ClsInstResult
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">DynFlags -&gt; Bool -&gt; Class -&gt; [Type] -&gt; CtLoc -&gt; TcS ClsInstResult
</span><a href="GHC.Tc.Solver.Monad.html#matchGlobalInst"><span class="hs-identifier hs-var">matchGlobalInst</span></a></span><span> </span><span class="annot"><span class="annottext">DynFlags
</span><a href="#local-6989586621683041783"><span class="hs-identifier hs-var">dflags</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041811"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041812"><span class="hs-identifier hs-var">tys</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041805"><span class="hs-identifier hs-var">loc_w</span></a></span><span>
</span><span id="line-813"></span><span>           </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="../../transformers-0.6.1.2-38b1/src/Control.Monad.Trans.Class.html#lift"><span class="hs-identifier hs-type">lift</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#warn_custom_warn_instance"><span class="hs-identifier hs-type">warn_custom_warn_instance</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041814"><span class="hs-identifier hs-type">inst_res</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041805"><span class="hs-identifier hs-type">loc_w</span></a></span><span>
</span><span id="line-814"></span><span>                 </span><span class="hs-comment">-- See Note [Implementation of deprecated instances]</span><span>
</span><span id="line-815"></span><span>           </span><span class="hs-special">;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621683041814"><span class="hs-identifier hs-type">inst_res</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-816"></span><span>               </span><span class="annot"><a href="GHC.Tc.Instance.Class.html#OneInst"><span class="hs-identifier hs-type">OneInst</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">cir_new_theta :: ClsInstResult -&gt; [Type]
</span><a href="GHC.Tc.Instance.Class.html#cir_new_theta"><span class="hs-identifier hs-var">cir_new_theta</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041819"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041819"><span class="hs-identifier hs-var">preds</span></a></span></span><span>
</span><span id="line-817"></span><span>                       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cir_mk_ev :: ClsInstResult -&gt; [EvExpr] -&gt; EvTerm
</span><a href="GHC.Tc.Instance.Class.html#cir_mk_ev"><span class="hs-identifier hs-var">cir_mk_ev</span></a></span><span>       </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041821"><span class="annot"><span class="annottext">[EvExpr] -&gt; EvTerm
</span><a href="#local-6989586621683041821"><span class="hs-identifier hs-var">mk_ev</span></a></span></span><span>
</span><span id="line-818"></span><span>                       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cir_canonical :: ClsInstResult -&gt; CanonicalEvidence
</span><a href="GHC.Tc.Instance.Class.html#cir_canonical"><span class="hs-identifier hs-var">cir_canonical</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041823"><span class="annot"><span class="annottext">CanonicalEvidence
</span><a href="#local-6989586621683041823"><span class="hs-identifier hs-var">canonical</span></a></span></span><span>
</span><span id="line-819"></span><span>                       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cir_what :: ClsInstResult -&gt; InstanceWhat
</span><a href="GHC.Tc.Instance.Class.html#cir_what"><span class="hs-identifier hs-var">cir_what</span></a></span><span>        </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041825"><span class="annot"><span class="annottext">InstanceWhat
</span><a href="#local-6989586621683041825"><span class="hs-identifier hs-var">what</span></a></span></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-820"></span><span>                 </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">InstanceWhat -&gt; Bool
</span><a href="GHC.Tc.Instance.Class.html#safeOverlap"><span class="hs-identifier hs-var">safeOverlap</span></a></span><span> </span><span class="annot"><span class="annottext">InstanceWhat
</span><a href="#local-6989586621683041825"><span class="hs-identifier hs-var">what</span></a></span><span>
</span><span id="line-821"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Bool) -&gt; [Type] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Bool
</span><a href="GHC.Tc.Utils.TcType.html#isTyFamFree"><span class="hs-identifier hs-var">isTyFamFree</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041819"><span class="hs-identifier hs-var">preds</span></a></span><span>  </span><span class="hs-comment">-- Note [Shortcut solving: type families]</span><span>
</span><span id="line-822"></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621683041828"><span class="annot"><span class="annottext">dict_ct :: DictCt
</span><a href="#local-6989586621683041828"><span class="hs-identifier hs-var hs-var hs-var">dict_ct</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">di_ev :: CtEvidence
</span><a href="GHC.Tc.Types.Constraint.html#di_ev"><span class="hs-identifier hs-var">di_ev</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041808"><span class="hs-identifier hs-var">ev</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">di_cls :: Class
</span><a href="GHC.Tc.Types.Constraint.html#di_cls"><span class="hs-identifier hs-var">di_cls</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041811"><span class="hs-identifier hs-var">cls</span></a></span><span>
</span><span id="line-823"></span><span>                                              </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">di_tys :: [Type]
</span><a href="GHC.Tc.Types.Constraint.html#di_tys"><span class="hs-identifier hs-var">di_tys</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041812"><span class="hs-identifier hs-var">tys</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">di_pend_sc :: ScDepth
</span><a href="GHC.Tc.Types.Constraint.html#di_pend_sc"><span class="hs-identifier hs-var">di_pend_sc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ScDepth
</span><a href="GHC.Tc.Types.Constraint.html#doNotExpand"><span class="hs-identifier hs-var">doNotExpand</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-824"></span><span>                             </span><span id="local-6989586621683041829"><span class="annot"><span class="annottext">solved_dicts' :: DictMap DictCt
</span><a href="#local-6989586621683041829"><span class="hs-identifier hs-var hs-var hs-var">solved_dicts'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DictCt -&gt; DictMap DictCt -&gt; DictMap DictCt
</span><a href="GHC.Tc.Solver.InertSet.html#addSolvedDict"><span class="hs-identifier hs-var">addSolvedDict</span></a></span><span> </span><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041828"><span class="hs-identifier hs-var">dict_ct</span></a></span><span> </span><span class="annot"><span class="annottext">DictMap DictCt
</span><a href="#local-6989586621683041807"><span class="hs-identifier hs-var">solved_dicts</span></a></span><span>
</span><span id="line-825"></span><span>                             </span><span class="hs-comment">-- solved_dicts': it is important that we add our goal</span><span>
</span><span id="line-826"></span><span>                             </span><span class="hs-comment">-- to the cache before we solve! Otherwise we may end</span><span>
</span><span id="line-827"></span><span>                             </span><span class="hs-comment">-- up in a loop while solving recursive dictionaries.</span><span>
</span><span id="line-828"></span><span>
</span><span id="line-829"></span><span>                       </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">TcS () -&gt; MaybeT TcS ()
forall (m :: * -&gt; *) a. Monad m =&gt; m a -&gt; MaybeT m a
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><a href="../../transformers-0.6.1.2-38b1/src/Control.Monad.Trans.Class.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(TcS () -&gt; MaybeT TcS ()) -&gt; TcS () -&gt; MaybeT TcS ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-var">traceTcS</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;shortCutSolver: found instance&quot;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041819"><span class="hs-identifier hs-var">preds</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-830"></span><span>                       </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683041831"><span class="annot"><a href="#local-6989586621683041831"><span class="hs-identifier hs-var">loc'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TcS CtLoc -&gt; MaybeT TcS CtLoc
forall (m :: * -&gt; *) a. Monad m =&gt; m a -&gt; MaybeT m a
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><a href="../../transformers-0.6.1.2-38b1/src/Control.Monad.Trans.Class.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(TcS CtLoc -&gt; MaybeT TcS CtLoc) -&gt; TcS CtLoc -&gt; MaybeT TcS CtLoc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">CtLoc -&gt; InstanceWhat -&gt; Type -&gt; TcS CtLoc
</span><a href="GHC.Tc.Solver.Dict.html#checkInstanceOK"><span class="hs-identifier hs-var">checkInstanceOK</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtEvidence -&gt; CtLoc
</span><a href="GHC.Tc.Types.Constraint.html#ctEvLoc"><span class="hs-identifier hs-var">ctEvLoc</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041808"><span class="hs-identifier hs-var">ev</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">InstanceWhat
</span><a href="#local-6989586621683041825"><span class="hs-identifier hs-var">what</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041809"><span class="hs-identifier hs-var">pred</span></a></span><span>
</span><span id="line-831"></span><span>                       </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="../../transformers-0.6.1.2-38b1/src/Control.Monad.Trans.Class.html#lift"><span class="hs-identifier hs-type">lift</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#checkReductionDepth"><span class="hs-identifier hs-type">checkReductionDepth</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041831"><span class="hs-identifier hs-type">loc'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041809"><span class="hs-identifier hs-type">pred</span></a></span><span>
</span><span id="line-832"></span><span>
</span><span id="line-833"></span><span>
</span><span id="line-834"></span><span>                       </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683041833"><span class="annot"><a href="#local-6989586621683041833"><span class="hs-identifier hs-var">evc_vs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="hs-identifier hs-type">mapM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621683041835"><span class="hs-identifier hs-type">new_wanted_cached</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041808"><span class="hs-identifier hs-type">ev</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041831"><span class="hs-identifier hs-type">loc'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041829"><span class="hs-identifier hs-type">solved_dicts'</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621683041819"><span class="hs-identifier hs-type">preds</span></a></span><span>
</span><span id="line-835"></span><span>                                  </span><span class="hs-comment">-- Emit work for subgoals but use our local cache</span><span>
</span><span id="line-836"></span><span>                                  </span><span class="hs-comment">-- so we can solve recursive dictionaries.</span><span>
</span><span id="line-837"></span><span>
</span><span id="line-838"></span><span>                       </span><span class="hs-special">;</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621683041836"><span class="annot"><a href="#local-6989586621683041836"><span class="hs-identifier hs-var hs-var">ev_tm</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[EvExpr] -&gt; EvTerm
</span><a href="#local-6989586621683041821"><span class="hs-identifier hs-var">mk_ev</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(MaybeNew -&gt; EvExpr) -&gt; [MaybeNew] -&gt; [EvExpr]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">MaybeNew -&gt; EvExpr
</span><a href="GHC.Tc.Solver.Monad.html#getEvExpr"><span class="hs-identifier hs-var">getEvExpr</span></a></span><span> </span><span class="annot"><span class="annottext">[MaybeNew]
</span><a href="#local-6989586621683041833"><span class="hs-identifier hs-var">evc_vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-839"></span><span>                             </span><span id="local-6989586621683041838"><span class="annot"><a href="#local-6989586621683041838"><span class="hs-identifier hs-var hs-var">ev_binds'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">EvBindMap -&gt; EvBind -&gt; EvBindMap
</span><a href="GHC.Tc.Types.Evidence.html#extendEvBinds"><span class="hs-identifier hs-var">extendEvBinds</span></a></span><span> </span><span class="annot"><span class="annottext">EvBindMap
</span><a href="#local-6989586621683041806"><span class="hs-identifier hs-var">ev_binds</span></a></span><span> </span><span class="annot"><span class="annottext">(EvBind -&gt; EvBindMap) -&gt; EvBind -&gt; EvBindMap
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-840"></span><span>                                         </span><span class="annot"><span class="annottext">EvVar -&gt; CanonicalEvidence -&gt; EvTerm -&gt; EvBind
</span><a href="GHC.Tc.Types.Evidence.html#mkWantedEvBind"><span class="hs-identifier hs-var">mkWantedEvBind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtEvidence -&gt; EvVar
</span><a href="GHC.Tc.Types.Constraint.html#ctEvEvId"><span class="hs-identifier hs-var">ctEvEvId</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041808"><span class="hs-identifier hs-var">ev</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">CanonicalEvidence
</span><a href="#local-6989586621683041823"><span class="hs-identifier hs-var">canonical</span></a></span><span> </span><span class="annot"><span class="annottext">EvTerm
</span><a href="#local-6989586621683041836"><span class="hs-identifier hs-var">ev_tm</span></a></span><span>
</span><span id="line-841"></span><span>
</span><span id="line-842"></span><span>                       </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">foldlM</span></span><span> </span><span class="annot"><a href="#local-6989586621683041800"><span class="hs-identifier hs-type">try_solve_from_instance</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621683041838"><span class="hs-identifier hs-type">ev_binds'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621683041829"><span class="hs-identifier hs-type">solved_dicts'</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span>
</span><span id="line-843"></span><span>                         </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#freshGoals"><span class="hs-identifier hs-type">freshGoals</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041833"><span class="hs-identifier hs-type">evc_vs</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-844"></span><span>
</span><span id="line-845"></span><span>               </span><span class="annot"><span class="annottext">ClsInstResult
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">MaybeT TcS (EvBindMap, DictMap DictCt)
forall a. MaybeT TcS a
forall (m :: * -&gt; *) a. MonadPlus m =&gt; m a
</span><span class="hs-identifier hs-var">mzero</span></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-846"></span><span>
</span><span id="line-847"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-848"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">MaybeT TcS (EvBindMap, DictMap DictCt)
forall a. MaybeT TcS a
forall (m :: * -&gt; *) a. MonadPlus m =&gt; m a
</span><span class="hs-identifier hs-var">mzero</span></span><span>
</span><span id="line-849"></span><span>
</span><span id="line-850"></span><span>
</span><span id="line-851"></span><span>    </span><span class="hs-comment">-- Use a local cache of solved dicts while emitting EvVars for new work</span><span>
</span><span id="line-852"></span><span>    </span><span class="hs-comment">-- We bail out of the entire computation if we need to emit an EvVar for</span><span>
</span><span id="line-853"></span><span>    </span><span class="hs-comment">-- a subgoal that isn't a ClassPred.</span><span>
</span><span id="line-854"></span><span>    </span><span class="annot"><a href="#local-6989586621683041835"><span class="hs-identifier hs-type">new_wanted_cached</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CtEvidence"><span class="hs-identifier hs-type">CtEvidence</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Types.CtLoc.html#CtLoc"><span class="hs-identifier hs-type">CtLoc</span></a></span><span>
</span><span id="line-855"></span><span>                      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Types.html#DictMap"><span class="hs-identifier hs-type">DictMap</span></a></span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Utils.TcType.html#TcPredType"><span class="hs-identifier hs-type">TcPredType</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../transformers-0.6.1.2-38b1/src/Control.Monad.Trans.Maybe.html#MaybeT"><span class="hs-identifier hs-type">MaybeT</span></a></span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#TcS"><span class="hs-identifier hs-type">TcS</span></a></span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#MaybeNew"><span class="hs-identifier hs-type">MaybeNew</span></a></span><span>
</span><span id="line-856"></span><span>    </span><span id="local-6989586621683041835"><span class="annot"><span class="annottext">new_wanted_cached :: CtEvidence
-&gt; CtLoc -&gt; DictMap DictCt -&gt; Type -&gt; MaybeT TcS MaybeNew
</span><a href="#local-6989586621683041835"><span class="hs-identifier hs-var hs-var">new_wanted_cached</span></a></span></span><span> </span><span id="local-6989586621683041845"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041845"><span class="hs-identifier hs-var">ev_w</span></a></span></span><span> </span><span id="local-6989586621683041846"><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041846"><span class="hs-identifier hs-var">loc</span></a></span></span><span> </span><span id="local-6989586621683041847"><span class="annot"><span class="annottext">DictMap DictCt
</span><a href="#local-6989586621683041847"><span class="hs-identifier hs-var">cache</span></a></span></span><span> </span><span id="local-6989586621683041848"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041848"><span class="hs-identifier hs-var">pty</span></a></span></span><span>
</span><span id="line-857"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="GHC.Core.Predicate.html#ClassPred"><span class="hs-identifier hs-type">ClassPred</span></a></span><span> </span><span id="local-6989586621683041849"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041849"><span class="hs-identifier hs-var">cls</span></a></span></span><span> </span><span id="local-6989586621683041850"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041850"><span class="hs-identifier hs-var">tys</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Pred
</span><a href="GHC.Core.Predicate.html#classifyPredType"><span class="hs-identifier hs-var">classifyPredType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041848"><span class="hs-identifier hs-var">pty</span></a></span><span>
</span><span id="line-858"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TcS MaybeNew -&gt; MaybeT TcS MaybeNew
forall (m :: * -&gt; *) a. Monad m =&gt; m a -&gt; MaybeT m a
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><a href="../../transformers-0.6.1.2-38b1/src/Control.Monad.Trans.Class.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(TcS MaybeNew -&gt; MaybeT TcS MaybeNew)
-&gt; TcS MaybeNew -&gt; MaybeT TcS MaybeNew
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">DictMap DictCt -&gt; CtLoc -&gt; Class -&gt; [Type] -&gt; Maybe DictCt
forall a. DictMap a -&gt; CtLoc -&gt; Class -&gt; [Type] -&gt; Maybe a
</span><a href="GHC.Tc.Solver.Types.html#findDict"><span class="hs-identifier hs-var">findDict</span></a></span><span> </span><span class="annot"><span class="annottext">DictMap DictCt
</span><a href="#local-6989586621683041847"><span class="hs-identifier hs-var">cache</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041805"><span class="hs-identifier hs-var">loc_w</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041849"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041850"><span class="hs-identifier hs-var">tys</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-859"></span><span>          </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621683041852"><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041852"><span class="hs-identifier hs-var">dict_ct</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">MaybeNew -&gt; TcS MaybeNew
forall a. a -&gt; TcS a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(MaybeNew -&gt; TcS MaybeNew) -&gt; MaybeNew -&gt; TcS MaybeNew
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">EvExpr -&gt; MaybeNew
</span><a href="GHC.Tc.Solver.Monad.html#Cached"><span class="hs-identifier hs-var">Cached</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; CtEvidence -&gt; EvExpr
CtEvidence -&gt; EvExpr
</span><a href="GHC.Tc.Types.Constraint.html#ctEvExpr"><span class="hs-identifier hs-var">ctEvExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DictCt -&gt; CtEvidence
</span><a href="GHC.Tc.Types.Constraint.html#dictCtEvidence"><span class="hs-identifier hs-var">dictCtEvidence</span></a></span><span> </span><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041852"><span class="hs-identifier hs-var">dict_ct</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-860"></span><span>          </span><span class="annot"><span class="annottext">Maybe DictCt
</span><span class="hs-identifier hs-var">Nothing</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; MaybeNew
</span><a href="GHC.Tc.Solver.Monad.html#Fresh"><span class="hs-identifier hs-var">Fresh</span></a></span><span> </span><span class="annot"><span class="annottext">(CtEvidence -&gt; MaybeNew) -&gt; TcS CtEvidence -&gt; TcS MaybeNew
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">CtLoc -&gt; RewriterSet -&gt; Type -&gt; TcS CtEvidence
</span><a href="GHC.Tc.Solver.Monad.html#newWantedNC"><span class="hs-identifier hs-var">newWantedNC</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041846"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtEvidence -&gt; RewriterSet
</span><a href="GHC.Tc.Types.Constraint.html#ctEvRewriters"><span class="hs-identifier hs-var">ctEvRewriters</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041845"><span class="hs-identifier hs-var">ev_w</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041848"><span class="hs-identifier hs-var">pty</span></a></span><span>
</span><span id="line-861"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">MaybeT TcS MaybeNew
forall a. MaybeT TcS a
forall (m :: * -&gt; *) a. MonadPlus m =&gt; m a
</span><span class="hs-identifier hs-var">mzero</span></span><span>
</span><span id="line-862"></span><span>
</span><span id="line-863"></span><span class="annot"><span class="hs-comment">{- *******************************************************************
*                                                                    *
         Top-level reaction for class constraints (CDictCan)
*                                                                    *
**********************************************************************-}</span></span><span>
</span><span id="line-868"></span><span>
</span><span id="line-869"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#tryInstances"><span class="hs-identifier hs-type">tryInstances</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#SolverStage"><span class="hs-identifier hs-type">SolverStage</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-870"></span><span id="tryInstances"><span class="annot"><span class="annottext">tryInstances :: DictCt -&gt; SolverStage ()
</span><a href="GHC.Tc.Solver.Dict.html#tryInstances"><span class="hs-identifier hs-var hs-var">tryInstances</span></a></span></span><span> </span><span id="local-6989586621683041858"><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041858"><span class="hs-identifier hs-var">dict_ct</span></a></span></span><span>
</span><span id="line-871"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TcS (StopOrContinue ()) -&gt; SolverStage ()
forall a. TcS (StopOrContinue a) -&gt; SolverStage a
</span><a href="GHC.Tc.Solver.Monad.html#Stage"><span class="hs-identifier hs-var">Stage</span></a></span><span> </span><span class="annot"><span class="annottext">(TcS (StopOrContinue ()) -&gt; SolverStage ())
-&gt; TcS (StopOrContinue ()) -&gt; SolverStage ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span id="local-6989586621683041859"><span class="annot"><a href="#local-6989586621683041859"><span class="hs-identifier hs-var">inerts</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TcS InertSet
</span><a href="GHC.Tc.Solver.Monad.html#getInertSet"><span class="hs-identifier hs-var">getInertSet</span></a></span><span>
</span><span id="line-872"></span><span>               </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#try_instances"><span class="hs-identifier hs-type">try_instances</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041859"><span class="hs-identifier hs-type">inerts</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041858"><span class="hs-identifier hs-type">dict_ct</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-873"></span><span>
</span><span id="line-874"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#try_instances"><span class="hs-identifier hs-type">try_instances</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.InertSet.html#InertSet"><span class="hs-identifier hs-type">InertSet</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#TcS"><span class="hs-identifier hs-type">TcS</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#StopOrContinue"><span class="hs-identifier hs-type">StopOrContinue</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-875"></span><span class="hs-comment">-- Try to use type-class instance declarations to simplify the constraint</span><span>
</span><span id="line-876"></span><span id="try_instances"><span class="annot"><span class="annottext">try_instances :: InertSet -&gt; DictCt -&gt; TcS (StopOrContinue ())
</span><a href="GHC.Tc.Solver.Dict.html#try_instances"><span class="hs-identifier hs-var hs-var">try_instances</span></a></span></span><span> </span><span id="local-6989586621683041862"><span class="annot"><span class="annottext">InertSet
</span><a href="#local-6989586621683041862"><span class="hs-identifier hs-var">inerts</span></a></span></span><span> </span><span id="local-6989586621683041863"><span class="annot"><span class="annottext">work_item :: DictCt
</span><a href="#local-6989586621683041863"><span class="hs-identifier hs-var">work_item</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">di_ev :: DictCt -&gt; CtEvidence
</span><a href="GHC.Tc.Types.Constraint.html#di_ev"><span class="hs-identifier hs-var">di_ev</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041864"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041864"><span class="hs-identifier hs-var">ev</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">di_cls :: DictCt -&gt; Class
</span><a href="GHC.Tc.Types.Constraint.html#di_cls"><span class="hs-identifier hs-var">di_cls</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041865"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041865"><span class="hs-identifier hs-var">cls</span></a></span></span><span>
</span><span id="line-877"></span><span>                                       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">di_tys :: DictCt -&gt; [Type]
</span><a href="GHC.Tc.Types.Constraint.html#di_tys"><span class="hs-identifier hs-var">di_tys</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041866"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041866"><span class="hs-identifier hs-var">xis</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-878"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; Bool
</span><a href="GHC.Tc.Types.Constraint.html#isGiven"><span class="hs-identifier hs-var">isGiven</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041864"><span class="hs-identifier hs-var">ev</span></a></span><span>   </span><span class="hs-comment">-- Never use instances for Given constraints</span><span>
</span><span id="line-879"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">() -&gt; TcS (StopOrContinue ())
forall a. a -&gt; TcS (StopOrContinue a)
</span><a href="GHC.Tc.Solver.Monad.html#continueWith"><span class="hs-identifier hs-var">continueWith</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-880"></span><span>     </span><span class="hs-comment">-- See Note [No Given/Given fundeps]</span><span>
</span><span id="line-881"></span><span>
</span><span id="line-882"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621683041867"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041867"><span class="hs-identifier hs-var">solved_ev</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">InertSet -&gt; CtLoc -&gt; Class -&gt; [Type] -&gt; Maybe CtEvidence
</span><a href="GHC.Tc.Solver.Monad.html#lookupSolvedDict"><span class="hs-identifier hs-var">lookupSolvedDict</span></a></span><span> </span><span class="annot"><span class="annottext">InertSet
</span><a href="#local-6989586621683041862"><span class="hs-identifier hs-var">inerts</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041869"><span class="hs-identifier hs-var">dict_loc</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041865"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041866"><span class="hs-identifier hs-var">xis</span></a></span><span>   </span><span class="hs-comment">-- Cached</span><span>
</span><span id="line-883"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; CanonicalEvidence -&gt; EvTerm -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#setEvBindIfWanted"><span class="hs-identifier hs-var">setEvBindIfWanted</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041864"><span class="hs-identifier hs-var">ev</span></a></span><span> </span><span class="annot"><span class="annottext">CanonicalEvidence
</span><a href="GHC.Core.InstEnv.html#EvCanonical"><span class="hs-identifier hs-var">EvCanonical</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtEvidence -&gt; EvTerm
</span><a href="GHC.Tc.Types.Constraint.html#ctEvTerm"><span class="hs-identifier hs-var">ctEvTerm</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041867"><span class="hs-identifier hs-var">solved_ev</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-884"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; String -&gt; TcS (StopOrContinue ())
forall a. CtEvidence -&gt; String -&gt; TcS (StopOrContinue a)
</span><a href="GHC.Tc.Solver.Monad.html#stopWith"><span class="hs-identifier hs-var">stopWith</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041864"><span class="hs-identifier hs-var">ev</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Dict/Top (cached)&quot;</span></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-885"></span><span>
</span><span id="line-886"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>  </span><span class="hs-comment">-- Wanted, but not cached</span><span>
</span><span id="line-887"></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span id="local-6989586621683041870"><span class="annot"><a href="#local-6989586621683041870"><span class="hs-identifier hs-var">dflags</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TcS DynFlags
forall (m :: * -&gt; *). HasDynFlags m =&gt; m DynFlags
</span><a href="GHC.Driver.DynFlags.html#getDynFlags"><span class="hs-identifier hs-var">getDynFlags</span></a></span><span>
</span><span id="line-888"></span><span>        </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683041871"><span class="annot"><a href="#local-6989586621683041871"><span class="hs-identifier hs-var">lkup_res</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#matchClassInst"><span class="hs-identifier hs-type">matchClassInst</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041870"><span class="hs-identifier hs-type">dflags</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041862"><span class="hs-identifier hs-type">inerts</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041865"><span class="hs-identifier hs-type">cls</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041866"><span class="hs-identifier hs-type">xis</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041869"><span class="hs-identifier hs-type">dict_loc</span></a></span><span>
</span><span id="line-889"></span><span>        </span><span class="hs-special">;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621683041871"><span class="hs-identifier hs-type">lkup_res</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-890"></span><span>               </span><span class="annot"><a href="GHC.Tc.Instance.Class.html#OneInst"><span class="hs-identifier hs-type">OneInst</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">cir_what :: ClsInstResult -&gt; InstanceWhat
</span><a href="GHC.Tc.Instance.Class.html#cir_what"><span class="hs-identifier hs-var">cir_what</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041873"><span class="annot"><span class="annottext">InstanceWhat
</span><a href="#local-6989586621683041873"><span class="hs-identifier hs-var">what</span></a></span></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-891"></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">InstanceWhat -&gt; DictCt -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#insertSafeOverlapFailureTcS"><span class="hs-identifier hs-var">insertSafeOverlapFailureTcS</span></a></span><span> </span><span class="annot"><span class="annottext">InstanceWhat
</span><a href="#local-6989586621683041873"><span class="hs-identifier hs-var">what</span></a></span><span> </span><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041863"><span class="hs-identifier hs-var">work_item</span></a></span><span>
</span><span id="line-892"></span><span>                        </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">InstanceWhat -&gt; DictCt -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#updSolvedDicts"><span class="hs-identifier hs-var">updSolvedDicts</span></a></span><span> </span><span class="annot"><span class="annottext">InstanceWhat
</span><a href="#local-6989586621683041873"><span class="hs-identifier hs-var">what</span></a></span><span> </span><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683041863"><span class="hs-identifier hs-var">work_item</span></a></span><span>
</span><span id="line-893"></span><span>                        </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; ClsInstResult -&gt; TcS (StopOrContinue ())
forall a. CtEvidence -&gt; ClsInstResult -&gt; TcS (StopOrContinue a)
</span><a href="GHC.Tc.Solver.Dict.html#chooseInstance"><span class="hs-identifier hs-var">chooseInstance</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041864"><span class="hs-identifier hs-var">ev</span></a></span><span> </span><span class="annot"><span class="annottext">ClsInstResult
</span><a href="#local-6989586621683041871"><span class="hs-identifier hs-var">lkup_res</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-894"></span><span>               </span><span class="annot"><span class="annottext">ClsInstResult
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-comment">-- NoInstance or NotSure</span><span>
</span><span id="line-895"></span><span>                     </span><span class="hs-comment">-- We didn't solve it; so try functional dependencies</span><span>
</span><span id="line-896"></span><span>                     </span><span class="annot"><span class="annottext">() -&gt; TcS (StopOrContinue ())
forall a. a -&gt; TcS (StopOrContinue a)
</span><a href="GHC.Tc.Solver.Monad.html#continueWith"><span class="hs-identifier hs-var">continueWith</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-897"></span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-898"></span><span>     </span><span id="local-6989586621683041869"><span class="annot"><span class="annottext">dict_loc :: CtLoc
</span><a href="#local-6989586621683041869"><span class="hs-identifier hs-var hs-var">dict_loc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; CtLoc
</span><a href="GHC.Tc.Types.Constraint.html#ctEvLoc"><span class="hs-identifier hs-var">ctEvLoc</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041864"><span class="hs-identifier hs-var">ev</span></a></span><span>
</span><span id="line-899"></span><span>
</span><span id="line-900"></span><span id="local-6989586621683041218"><span class="annot"><a href="GHC.Tc.Solver.Dict.html#chooseInstance"><span class="hs-identifier hs-type">chooseInstance</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CtEvidence"><span class="hs-identifier hs-type">CtEvidence</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Instance.Class.html#ClsInstResult"><span class="hs-identifier hs-type">ClsInstResult</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#TcS"><span class="hs-identifier hs-type">TcS</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#StopOrContinue"><span class="hs-identifier hs-type">StopOrContinue</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041218"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-901"></span><span id="chooseInstance"><span class="annot"><span class="annottext">chooseInstance :: forall a. CtEvidence -&gt; ClsInstResult -&gt; TcS (StopOrContinue a)
</span><a href="GHC.Tc.Solver.Dict.html#chooseInstance"><span class="hs-identifier hs-var hs-var">chooseInstance</span></a></span></span><span> </span><span id="local-6989586621683041897"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041897"><span class="hs-identifier hs-var">work_item</span></a></span></span><span>
</span><span id="line-902"></span><span>               </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Instance.Class.html#OneInst"><span class="hs-identifier hs-type">OneInst</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">cir_new_theta :: ClsInstResult -&gt; [Type]
</span><a href="GHC.Tc.Instance.Class.html#cir_new_theta"><span class="hs-identifier hs-var">cir_new_theta</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041898"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041898"><span class="hs-identifier hs-var">theta</span></a></span></span><span>
</span><span id="line-903"></span><span>                        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cir_what :: ClsInstResult -&gt; InstanceWhat
</span><a href="GHC.Tc.Instance.Class.html#cir_what"><span class="hs-identifier hs-var">cir_what</span></a></span><span>        </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041899"><span class="annot"><span class="annottext">InstanceWhat
</span><a href="#local-6989586621683041899"><span class="hs-identifier hs-var">what</span></a></span></span><span>
</span><span id="line-904"></span><span>                        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cir_mk_ev :: ClsInstResult -&gt; [EvExpr] -&gt; EvTerm
</span><a href="GHC.Tc.Instance.Class.html#cir_mk_ev"><span class="hs-identifier hs-var">cir_mk_ev</span></a></span><span>       </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041900"><span class="annot"><span class="annottext">[EvExpr] -&gt; EvTerm
</span><a href="#local-6989586621683041900"><span class="hs-identifier hs-var">mk_ev</span></a></span></span><span>
</span><span id="line-905"></span><span>                        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cir_canonical :: ClsInstResult -&gt; CanonicalEvidence
</span><a href="GHC.Tc.Instance.Class.html#cir_canonical"><span class="hs-identifier hs-var">cir_canonical</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041901"><span class="annot"><span class="annottext">CanonicalEvidence
</span><a href="#local-6989586621683041901"><span class="hs-identifier hs-var">canonical</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-906"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-var">traceTcS</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;doTopReact/found instance for&quot;</span></span><span> </span><span class="annot"><span class="annottext">(SDoc -&gt; TcS ()) -&gt; SDoc -&gt; TcS ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041897"><span class="hs-identifier hs-var">work_item</span></a></span><span>
</span><span id="line-907"></span><span>       </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683041902"><span class="annot"><a href="#local-6989586621683041902"><span class="hs-identifier hs-var">deeper_loc</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">CtLoc -&gt; InstanceWhat -&gt; Type -&gt; TcS CtLoc
</span><a href="GHC.Tc.Solver.Dict.html#checkInstanceOK"><span class="hs-identifier hs-var">checkInstanceOK</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041903"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="annot"><span class="annottext">InstanceWhat
</span><a href="#local-6989586621683041899"><span class="hs-identifier hs-var">what</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041904"><span class="hs-identifier hs-var">pred</span></a></span><span>
</span><span id="line-908"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#checkReductionDepth"><span class="hs-identifier hs-type">checkReductionDepth</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041902"><span class="hs-identifier hs-type">deeper_loc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041904"><span class="hs-identifier hs-type">pred</span></a></span><span>
</span><span id="line-909"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="GHC.Utils.Panic.html#assertPprM"><span class="hs-identifier hs-type">assertPprM</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#getTcEvBindsVar"><span class="hs-identifier hs-type">getTcEvBindsVar</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">&gt;&gt;=</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">.</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">not</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">.</span></span><span> </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html#isCoEvBindsVar"><span class="hs-identifier hs-type">isCoEvBindsVar</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-910"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-type">ppr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041897"><span class="hs-identifier hs-type">work_item</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-911"></span><span>       </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683041907"><span class="annot"><a href="#local-6989586621683041907"><span class="hs-identifier hs-var">evc_vars</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="hs-identifier hs-type">mapM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#newWanted"><span class="hs-identifier hs-type">newWanted</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041902"><span class="hs-identifier hs-type">deeper_loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#ctEvRewriters"><span class="hs-identifier hs-type">ctEvRewriters</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041897"><span class="hs-identifier hs-type">work_item</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621683041898"><span class="hs-identifier hs-type">theta</span></a></span><span>
</span><span id="line-912"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#setEvBindIfWanted"><span class="hs-identifier hs-type">setEvBindIfWanted</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041897"><span class="hs-identifier hs-type">work_item</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041901"><span class="hs-identifier hs-type">canonical</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621683041900"><span class="hs-identifier hs-type">mk_ev</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">map</span></span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#getEvExpr"><span class="hs-identifier hs-type">getEvExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041907"><span class="hs-identifier hs-type">evc_vars</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-913"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#emitWorkNC"><span class="hs-identifier hs-type">emitWorkNC</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#freshGoals"><span class="hs-identifier hs-type">freshGoals</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041907"><span class="hs-identifier hs-type">evc_vars</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-914"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#stopWith"><span class="hs-identifier hs-type">stopWith</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041897"><span class="hs-identifier hs-type">work_item</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;Dict/Top (solved wanted)&quot;</span></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-915"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-916"></span><span>     </span><span id="local-6989586621683041904"><span class="annot"><span class="annottext">pred :: Type
</span><a href="#local-6989586621683041904"><span class="hs-identifier hs-var hs-var">pred</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; Type
</span><a href="GHC.Tc.Types.Constraint.html#ctEvPred"><span class="hs-identifier hs-var">ctEvPred</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041897"><span class="hs-identifier hs-var">work_item</span></a></span><span>
</span><span id="line-917"></span><span>     </span><span id="local-6989586621683041903"><span class="annot"><span class="annottext">loc :: CtLoc
</span><a href="#local-6989586621683041903"><span class="hs-identifier hs-var hs-var">loc</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; CtLoc
</span><a href="GHC.Tc.Types.Constraint.html#ctEvLoc"><span class="hs-identifier hs-var">ctEvLoc</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041897"><span class="hs-identifier hs-var">work_item</span></a></span><span>
</span><span id="line-918"></span><span>
</span><span id="line-919"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#chooseInstance"><span class="hs-identifier hs-var">chooseInstance</span></a></span><span> </span><span id="local-6989586621683041910"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041910"><span class="hs-identifier hs-var">work_item</span></a></span></span><span> </span><span id="local-6989586621683041911"><span class="annot"><span class="annottext">ClsInstResult
</span><a href="#local-6989586621683041911"><span class="hs-identifier hs-var">lookup_res</span></a></span></span><span>
</span><span id="line-920"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS (StopOrContinue a)
forall a. HasCallStack =&gt; String -&gt; SDoc -&gt; a
</span><a href="GHC.Utils.Panic.html#pprPanic"><span class="hs-identifier hs-var">pprPanic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;chooseInstance&quot;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtEvidence -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041910"><span class="hs-identifier hs-var">work_item</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsDoc doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%24%24"><span class="hs-operator hs-var">$$</span></a></span><span> </span><span class="annot"><span class="annottext">ClsInstResult -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">ClsInstResult
</span><a href="#local-6989586621683041911"><span class="hs-identifier hs-var">lookup_res</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-921"></span><span>
</span><span id="line-922"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#checkInstanceOK"><span class="hs-identifier hs-type">checkInstanceOK</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.CtLoc.html#CtLoc"><span class="hs-identifier hs-type">CtLoc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Origin.html#InstanceWhat"><span class="hs-identifier hs-type">InstanceWhat</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Utils.TcType.html#TcPredType"><span class="hs-identifier hs-type">TcPredType</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#TcS"><span class="hs-identifier hs-type">TcS</span></a></span><span> </span><span class="annot"><a href="GHC.Tc.Types.CtLoc.html#CtLoc"><span class="hs-identifier hs-type">CtLoc</span></a></span><span>
</span><span id="line-923"></span><span class="hs-comment">-- Check that it's OK to use this instance:</span><span>
</span><span id="line-924"></span><span class="hs-comment">--    (a) the use is well staged in the Template Haskell sense</span><span>
</span><span id="line-925"></span><span class="hs-comment">-- Returns the CtLoc to used for sub-goals</span><span>
</span><span id="line-926"></span><span class="hs-comment">-- Probably also want to call checkReductionDepth</span><span>
</span><span id="line-927"></span><span id="checkInstanceOK"><span class="annot"><span class="annottext">checkInstanceOK :: CtLoc -&gt; InstanceWhat -&gt; Type -&gt; TcS CtLoc
</span><a href="GHC.Tc.Solver.Dict.html#checkInstanceOK"><span class="hs-identifier hs-var hs-var">checkInstanceOK</span></a></span></span><span> </span><span id="local-6989586621683041912"><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041912"><span class="hs-identifier hs-var">loc</span></a></span></span><span> </span><span id="local-6989586621683041913"><span class="annot"><span class="annottext">InstanceWhat
</span><a href="#local-6989586621683041913"><span class="hs-identifier hs-var">what</span></a></span></span><span> </span><span id="local-6989586621683041914"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041914"><span class="hs-identifier hs-var">pred</span></a></span></span><span>
</span><span id="line-928"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">CtLoc -&gt; InstanceWhat -&gt; Type -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#checkWellStagedDFun"><span class="hs-identifier hs-var">checkWellStagedDFun</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041912"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="annot"><span class="annottext">InstanceWhat
</span><a href="#local-6989586621683041913"><span class="hs-identifier hs-var">what</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041914"><span class="hs-identifier hs-var">pred</span></a></span><span>
</span><span id="line-929"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">CtLoc -&gt; TcS CtLoc
forall a. a -&gt; TcS a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041916"><span class="hs-identifier hs-var">deeper_loc</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-930"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-931"></span><span>     </span><span id="local-6989586621683041916"><span class="annot"><span class="annottext">deeper_loc :: CtLoc
</span><a href="#local-6989586621683041916"><span class="hs-identifier hs-var hs-var">deeper_loc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtLoc -&gt; CtLoc
</span><a href="#local-6989586621683041917"><span class="hs-identifier hs-var">zap_origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtLoc -&gt; CtLoc
</span><a href="GHC.Tc.Types.CtLoc.html#bumpCtLocDepth"><span class="hs-identifier hs-var">bumpCtLocDepth</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041912"><span class="hs-identifier hs-var">loc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-932"></span><span>     </span><span id="local-6989586621683041919"><span class="annot"><span class="annottext">origin :: CtOrigin
</span><a href="#local-6989586621683041919"><span class="hs-identifier hs-var hs-var">origin</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtLoc -&gt; CtOrigin
</span><a href="GHC.Tc.Types.CtLoc.html#ctLocOrigin"><span class="hs-identifier hs-var">ctLocOrigin</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041912"><span class="hs-identifier hs-var">loc</span></a></span><span>
</span><span id="line-933"></span><span>
</span><span id="line-934"></span><span>     </span><span id="local-6989586621683041917"><span class="annot"><span class="annottext">zap_origin :: CtLoc -&gt; CtLoc
</span><a href="#local-6989586621683041917"><span class="hs-identifier hs-var hs-var">zap_origin</span></a></span></span><span> </span><span id="local-6989586621683041920"><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041920"><span class="hs-identifier hs-var">loc</span></a></span></span><span>  </span><span class="hs-comment">-- After applying an instance we can set ScOrigin to</span><span>
</span><span id="line-935"></span><span>                     </span><span class="hs-comment">-- NotNakedSc, so that prohibitedSuperClassSolve never fires</span><span>
</span><span id="line-936"></span><span>                     </span><span class="hs-comment">-- See Note [Solving superclass constraints] in</span><span>
</span><span id="line-937"></span><span>                     </span><span class="hs-comment">-- GHC.Tc.TyCl.Instance, (sc1).</span><span>
</span><span id="line-938"></span><span>       </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Origin.html#ScOrigin"><span class="hs-identifier hs-type">ScOrigin</span></a></span><span> </span><span id="local-6989586621683041922"><span class="annot"><span class="annottext">ClsInstOrQC
</span><a href="#local-6989586621683041922"><span class="hs-identifier hs-var">what</span></a></span></span><span> </span><span class="annot"><span class="annottext">NakedScFlag
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">CtOrigin
</span><a href="#local-6989586621683041919"><span class="hs-identifier hs-var">origin</span></a></span><span>
</span><span id="line-939"></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtLoc -&gt; CtOrigin -&gt; CtLoc
</span><a href="GHC.Tc.Types.CtLoc.html#setCtLocOrigin"><span class="hs-identifier hs-var">setCtLocOrigin</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041920"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ClsInstOrQC -&gt; NakedScFlag -&gt; CtOrigin
</span><a href="GHC.Tc.Types.Origin.html#ScOrigin"><span class="hs-identifier hs-var">ScOrigin</span></a></span><span> </span><span class="annot"><span class="annottext">ClsInstOrQC
</span><a href="#local-6989586621683041922"><span class="hs-identifier hs-var">what</span></a></span><span> </span><span class="annot"><span class="annottext">NakedScFlag
</span><a href="GHC.Tc.Types.Origin.html#NotNakedSc"><span class="hs-identifier hs-var">NotNakedSc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-940"></span><span>       </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-941"></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041920"><span class="hs-identifier hs-var">loc</span></a></span><span>
</span><span id="line-942"></span><span>
</span><span id="line-943"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#matchClassInst"><span class="hs-identifier hs-type">matchClassInst</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Driver.DynFlags.html#DynFlags"><span class="hs-identifier hs-type">DynFlags</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.InertSet.html#InertSet"><span class="hs-identifier hs-type">InertSet</span></a></span><span>
</span><span id="line-944"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.Class.html#Class"><span class="hs-identifier hs-type">Class</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-945"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Types.CtLoc.html#CtLoc"><span class="hs-identifier hs-type">CtLoc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#TcS"><span class="hs-identifier hs-type">TcS</span></a></span><span> </span><span class="annot"><a href="GHC.Tc.Instance.Class.html#ClsInstResult"><span class="hs-identifier hs-type">ClsInstResult</span></a></span><span>
</span><span id="line-946"></span><span id="matchClassInst"><span class="annot"><span class="annottext">matchClassInst :: DynFlags
-&gt; InertSet -&gt; Class -&gt; [Type] -&gt; CtLoc -&gt; TcS ClsInstResult
</span><a href="GHC.Tc.Solver.Dict.html#matchClassInst"><span class="hs-identifier hs-var hs-var">matchClassInst</span></a></span></span><span> </span><span id="local-6989586621683041924"><span class="annot"><span class="annottext">DynFlags
</span><a href="#local-6989586621683041924"><span class="hs-identifier hs-var">dflags</span></a></span></span><span> </span><span id="local-6989586621683041925"><span class="annot"><span class="annottext">InertSet
</span><a href="#local-6989586621683041925"><span class="hs-identifier hs-var">inerts</span></a></span></span><span> </span><span id="local-6989586621683041926"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041926"><span class="hs-identifier hs-var">clas</span></a></span></span><span> </span><span id="local-6989586621683041927"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041927"><span class="hs-identifier hs-var">tys</span></a></span></span><span> </span><span id="local-6989586621683041928"><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041928"><span class="hs-identifier hs-var">loc</span></a></span></span><span>
</span><span id="line-947"></span><span class="hs-comment">-- First check whether there is an in-scope Given that could</span><span>
</span><span id="line-948"></span><span class="hs-comment">-- match this constraint.  In that case, do not use any instance</span><span>
</span><span id="line-949"></span><span class="hs-comment">-- whether top level, or local quantified constraints.</span><span>
</span><span id="line-950"></span><span class="hs-comment">-- See Note [Instance and Given overlap]</span><span>
</span><span id="line-951"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Extension -&gt; DynFlags -&gt; Bool
</span><a href="GHC.Driver.DynFlags.html#xopt"><span class="hs-identifier hs-var">xopt</span></a></span><span> </span><span class="annot"><span class="annottext">Extension
</span><span class="hs-identifier hs-var">LangExt.IncoherentInstances</span></span><span> </span><span class="annot"><span class="annottext">DynFlags
</span><a href="#local-6989586621683041924"><span class="hs-identifier hs-var">dflags</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-952"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Class -&gt; Bool
</span><a href="GHC.Core.Predicate.html#isCTupleClass"><span class="hs-identifier hs-var">isCTupleClass</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041926"><span class="hs-identifier hs-var">clas</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-953"></span><span>        </span><span class="hs-comment">-- It is always safe to unpack constraint tuples</span><span>
</span><span id="line-954"></span><span>        </span><span class="hs-comment">-- And if we don't do so, we may never solve it at all</span><span>
</span><span id="line-955"></span><span>        </span><span class="hs-comment">-- See Note [Solving tuple constraints]</span><span>
</span><span id="line-956"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">InertSet -&gt; CtLoc -&gt; Class -&gt; [Type] -&gt; Bool
</span><a href="GHC.Tc.Solver.InertSet.html#noMatchableGivenDicts"><span class="hs-identifier hs-var">noMatchableGivenDicts</span></a></span><span> </span><span class="annot"><span class="annottext">InertSet
</span><a href="#local-6989586621683041925"><span class="hs-identifier hs-var">inerts</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041928"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041926"><span class="hs-identifier hs-var">clas</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041927"><span class="hs-identifier hs-var">tys</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-957"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-var">traceTcS</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Delaying instance application&quot;</span></span><span> </span><span class="annot"><span class="annottext">(SDoc -&gt; TcS ()) -&gt; SDoc -&gt; TcS ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-958"></span><span>           </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsDoc doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#vcat"><span class="hs-identifier hs-var">vcat</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
forall doc. IsLine doc =&gt; String -&gt; doc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Work item:&quot;</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Class -&gt; [Type] -&gt; SDoc
</span><a href="GHC.Core.TyCo.Ppr.html#pprClassPred"><span class="hs-identifier hs-var">pprClassPred</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041926"><span class="hs-identifier hs-var">clas</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041927"><span class="hs-identifier hs-var">tys</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-959"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">ClsInstResult -&gt; TcS ClsInstResult
forall a. a -&gt; TcS a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">ClsInstResult
</span><a href="GHC.Tc.Instance.Class.html#NotSure"><span class="hs-identifier hs-var">NotSure</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-960"></span><span>
</span><span id="line-961"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-962"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-var">traceTcS</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;matchClassInst&quot;</span></span><span> </span><span class="annot"><span class="annottext">(SDoc -&gt; TcS ()) -&gt; SDoc -&gt; TcS ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
forall doc. IsLine doc =&gt; String -&gt; doc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;pred =&quot;</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041934"><span class="hs-identifier hs-var">pred</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
forall doc. IsLine doc =&gt; Char -&gt; doc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'{'</span></span><span>
</span><span id="line-963"></span><span>       </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683041936"><span class="annot"><a href="#local-6989586621683041936"><span class="hs-identifier hs-var">local_res</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; CtLoc -&gt; TcS ClsInstResult
</span><a href="GHC.Tc.Solver.Dict.html#matchLocalInst"><span class="hs-identifier hs-var">matchLocalInst</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041934"><span class="hs-identifier hs-var">pred</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041928"><span class="hs-identifier hs-var">loc</span></a></span><span>
</span><span id="line-964"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621683041936"><span class="hs-identifier hs-type">local_res</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-965"></span><span>           </span><span class="annot"><a href="GHC.Tc.Instance.Class.html#OneInst"><span class="hs-identifier hs-type">OneInst</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span>  </span><span class="hs-comment">-- See Note [Local instances and incoherence]</span><span>
</span><span id="line-966"></span><span>                </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-var">traceTcS</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;} matchClassInst local match&quot;</span></span><span> </span><span class="annot"><span class="annottext">(SDoc -&gt; TcS ()) -&gt; SDoc -&gt; TcS ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">ClsInstResult -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">ClsInstResult
</span><a href="#local-6989586621683041936"><span class="hs-identifier hs-var">local_res</span></a></span><span>
</span><span id="line-967"></span><span>                   </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">ClsInstResult -&gt; TcS ClsInstResult
forall a. a -&gt; TcS a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">ClsInstResult
</span><a href="#local-6989586621683041936"><span class="hs-identifier hs-var">local_res</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-968"></span><span>
</span><span id="line-969"></span><span>           </span><span class="annot"><span class="annottext">ClsInstResult
</span><a href="GHC.Tc.Instance.Class.html#NotSure"><span class="hs-identifier hs-var">NotSure</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-comment">-- In the NotSure case for local instances</span><span>
</span><span id="line-970"></span><span>                      </span><span class="hs-comment">-- we don't want to try global instances</span><span>
</span><span id="line-971"></span><span>                </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-var">traceTcS</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;} matchClassInst local not sure&quot;</span></span><span> </span><span class="annot"><span class="annottext">SDoc
forall doc. IsOutput doc =&gt; doc
</span><a href="GHC.Utils.Outputable.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span>
</span><span id="line-972"></span><span>                   </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">ClsInstResult -&gt; TcS ClsInstResult
forall a. a -&gt; TcS a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">ClsInstResult
</span><a href="#local-6989586621683041936"><span class="hs-identifier hs-var">local_res</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-973"></span><span>
</span><span id="line-974"></span><span>           </span><span class="annot"><span class="annottext">ClsInstResult
</span><a href="GHC.Tc.Instance.Class.html#NoInstance"><span class="hs-identifier hs-var">NoInstance</span></a></span><span>  </span><span class="hs-comment">-- No local instances, so try global ones</span><span>
</span><span id="line-975"></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span id="local-6989586621683041939"><span class="annot"><a href="#local-6989586621683041939"><span class="hs-identifier hs-var">global_res</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">DynFlags -&gt; Bool -&gt; Class -&gt; [Type] -&gt; CtLoc -&gt; TcS ClsInstResult
</span><a href="GHC.Tc.Solver.Monad.html#matchGlobalInst"><span class="hs-identifier hs-var">matchGlobalInst</span></a></span><span> </span><span class="annot"><span class="annottext">DynFlags
</span><a href="#local-6989586621683041924"><span class="hs-identifier hs-var">dflags</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041926"><span class="hs-identifier hs-var">clas</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041927"><span class="hs-identifier hs-var">tys</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041928"><span class="hs-identifier hs-var">loc</span></a></span><span>
</span><span id="line-976"></span><span>                    </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#warn_custom_warn_instance"><span class="hs-identifier hs-type">warn_custom_warn_instance</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041939"><span class="hs-identifier hs-type">global_res</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041928"><span class="hs-identifier hs-type">loc</span></a></span><span>
</span><span id="line-977"></span><span>                          </span><span class="hs-comment">-- See Note [Implementation of deprecated instances]</span><span>
</span><span id="line-978"></span><span>                    </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-type">traceTcS</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;} matchClassInst global result&quot;</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-type">ppr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041939"><span class="hs-identifier hs-type">global_res</span></a></span><span>
</span><span id="line-979"></span><span>                    </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="annot"><a href="#local-6989586621683041939"><span class="hs-identifier hs-type">global_res</span></a></span><span> </span><span class="hs-special">}</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-980"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-981"></span><span>    </span><span id="local-6989586621683041934"><span class="annot"><span class="annottext">pred :: Type
</span><a href="#local-6989586621683041934"><span class="hs-identifier hs-var hs-var">pred</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Class -&gt; [Type] -&gt; Type
</span><a href="GHC.Core.Predicate.html#mkClassPred"><span class="hs-identifier hs-var">mkClassPred</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683041926"><span class="hs-identifier hs-var">clas</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041927"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-982"></span><span>
</span><span id="line-983"></span><span class="hs-comment">{- Note [Implementation of deprecated instances]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This note describes the implementation of the deprecated instances GHC proposal
  https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0575-deprecated-instances.rst

In the parser, we parse deprecations/warnings attached to instances:

  instance {-# DEPRECATED &quot;msg&quot; #-} Show X
  deriving instance {-# WARNING &quot;msg2&quot; #-} Eq Y

(Note that non-standalone deriving instance declarations do not support this mechanism.)
(Note that the DEPRECATED and WARNING pragmas can be used here interchangeably.)

We store the resulting warning message in the extension field of `ClsInstDecl`
(respectively, `DerivDecl`; See Note [Trees That Grow]).

In `GHC.Tc.TyCl.Instance.tcClsInstDecl` (respectively, `GHC.Tc.Deriv.Utils.newDerivClsInst`),
we pass on that information to `ClsInst` (and eventually store it in `IfaceClsInst` too).

Next, if we solve a constraint using such an instance, in
`GHC.Tc.Instance.Class.matchInstEnv`, we pass it further into the
`Ghc.Tc.Types.Origin.InstanceWhat`.

Finally, if the instance solving function `GHC.Tc.Solver.Monad.matchGlobalInst` returns
a `Ghc.Tc.Instance.Class.ClsInstResult` with `Ghc.Tc.Types.Origin.InstanceWhat` containing
a warning, when called from either `matchClassInst` or `shortCutSolver`, we call
`warn_custom_warn_instance` that ultimately emits the warning if needed.

Note that we only emit a warning when the instance is used in a different module
than it is defined, which keeps the behaviour in line with the deprecation of
top-level identifiers.
-}</span><span>
</span><span id="line-1015"></span><span>
</span><span id="line-1016"></span><span class="hs-comment">-- | Emits the custom warning for a deprecated instance</span><span>
</span><span id="line-1017"></span><span class="hs-comment">--</span><span>
</span><span id="line-1018"></span><span class="hs-comment">-- See Note [Implementation of deprecated instances]</span><span>
</span><span id="line-1019"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#warn_custom_warn_instance"><span class="hs-identifier hs-type">warn_custom_warn_instance</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Instance.Class.html#ClsInstResult"><span class="hs-identifier hs-type">ClsInstResult</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Types.CtLoc.html#CtLoc"><span class="hs-identifier hs-type">CtLoc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#TcS"><span class="hs-identifier hs-type">TcS</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-1020"></span><span id="warn_custom_warn_instance"><span class="annot"><span class="annottext">warn_custom_warn_instance :: ClsInstResult -&gt; CtLoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Dict.html#warn_custom_warn_instance"><span class="hs-identifier hs-var hs-var">warn_custom_warn_instance</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Instance.Class.html#OneInst"><span class="hs-identifier hs-type">OneInst</span></a></span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">cir_what :: ClsInstResult -&gt; InstanceWhat
</span><a href="GHC.Tc.Instance.Class.html#cir_what"><span class="hs-identifier hs-var">cir_what</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041940"><span class="annot"><span class="annottext">InstanceWhat
</span><a href="#local-6989586621683041940"><span class="hs-identifier hs-var">what</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span id="local-6989586621683041941"><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041941"><span class="hs-identifier hs-var">ct_loc</span></a></span></span><span>
</span><span id="line-1021"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Origin.html#TopLevInstance"><span class="hs-identifier hs-type">TopLevInstance</span></a></span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">iw_dfun_id :: InstanceWhat -&gt; EvVar
</span><a href="GHC.Tc.Types.Origin.html#iw_dfun_id"><span class="hs-identifier hs-var">iw_dfun_id</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041944"><span class="annot"><span class="annottext">EvVar
</span><a href="#local-6989586621683041944"><span class="hs-identifier hs-var">dfun</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">iw_warn :: InstanceWhat -&gt; Maybe (WarningTxt GhcRn)
</span><a href="GHC.Tc.Types.Origin.html#iw_warn"><span class="hs-identifier hs-var">iw_warn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621683041946"><span class="annot"><span class="annottext">WarningTxt GhcRn
</span><a href="#local-6989586621683041946"><span class="hs-identifier hs-var">warn</span></a></span></span><span> </span><span class="hs-special">}</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">InstanceWhat
</span><a href="#local-6989586621683041940"><span class="hs-identifier hs-var">what</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1022"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621683041947"><span class="annot"><span class="annottext">mod :: Module
</span><a href="#local-6989586621683041947"><span class="hs-identifier hs-var hs-var hs-var">mod</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; Name -&gt; Module
Name -&gt; Module
</span><a href="GHC.Types.Name.html#nameModule"><span class="hs-identifier hs-var">nameModule</span></a></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Module) -&gt; Name -&gt; Module
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">EvVar -&gt; Name
forall a. NamedThing a =&gt; a -&gt; Name
</span><a href="GHC.Types.Name.html#getName"><span class="hs-identifier hs-var">getName</span></a></span><span> </span><span class="annot"><span class="annottext">EvVar
</span><a href="#local-6989586621683041944"><span class="hs-identifier hs-var">dfun</span></a></span><span>
</span><span id="line-1023"></span><span>      </span><span id="local-6989586621683041950"><span class="annot"><a href="#local-6989586621683041950"><span class="hs-identifier hs-var">this_mod</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TcS Module
forall (m :: * -&gt; *). HasModule m =&gt; m Module
</span><a href="GHC.Unit.Module.html#getModule"><span class="hs-identifier hs-var">getModule</span></a></span><span>
</span><span id="line-1024"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">when</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621683041950"><span class="hs-identifier hs-type">this_mod</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">/=</span></span><span> </span><span class="annot"><a href="#local-6989586621683041947"><span class="hs-identifier hs-type">mod</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1025"></span><span>          </span><span class="hs-comment">-- We don't emit warnings for usages inside of the same module</span><span>
</span><span id="line-1026"></span><span>          </span><span class="hs-comment">-- to prevent it being triggered for instance child declarations</span><span>
</span><span id="line-1027"></span><span>        </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#ctLocWarnTcS"><span class="hs-identifier hs-type">ctLocWarnTcS</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041941"><span class="hs-identifier hs-type">ct_loc</span></a></span><span>
</span><span id="line-1028"></span><span>          </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><a href="GHC.Tc.Errors.Types.html#TcRnPragmaWarning"><span class="hs-identifier hs-type">TcRnPragmaWarning</span></a></span><span>
</span><span id="line-1029"></span><span>              </span><span class="hs-special">{</span><span> </span><span class="annot"><a href="GHC.Tc.Errors.Types.html#pragma_warning_info"><span class="hs-identifier hs-var">pragma_warning_info</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Tc.Errors.Types.html#PragmaWarningInstance"><span class="hs-identifier hs-type">PragmaWarningInstance</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041944"><span class="hs-identifier hs-type">dfun</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.CtLoc.html#ctl_origin"><span class="hs-identifier hs-var">ctl_origin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041941"><span class="hs-identifier hs-type">ct_loc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1030"></span><span>              </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Errors.Types.html#pragma_warning_msg"><span class="hs-identifier hs-var">pragma_warning_msg</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621683041946"><span class="hs-identifier hs-type">warn</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-1031"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#warn_custom_warn_instance"><span class="hs-identifier hs-var">warn_custom_warn_instance</span></a></span><span> </span><span class="annot"><span class="annottext">ClsInstResult
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">() -&gt; TcS ()
forall a. a -&gt; TcS a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-1032"></span><span>
</span><span id="line-1033"></span><span class="hs-comment">{- Note [Instance and Given overlap]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Example, from the OutsideIn(X) paper:
       instance P x =&gt; Q [x]
       instance (x ~ y) =&gt; R y [x]

       wob :: forall a b. (Q [b], R b a) =&gt; a -&gt; Int

       g :: forall a. Q [a] =&gt; [a] -&gt; Int
       g x = wob x

From 'g' we get the implication constraint:
            forall a. Q [a] =&gt; (Q [beta], R beta [a])
If we react (Q [beta]) with its top-level axiom, we end up with a
(P beta), which we have no way of discharging. On the other hand,
if we react R beta [a] with the top-level we get  (beta ~ a), which
is solvable and can help us rewrite (Q [beta]) to (Q [a]) which is
now solvable by the given Q [a].

The partial solution is that:
  In matchClassInst (and thus in topReact), we return a matching
  instance only when there is no Given in the inerts which is
  unifiable to this particular dictionary.

  We treat any meta-tyvar as &quot;unifiable&quot; for this purpose,
  *including* untouchable ones.  But not skolems like 'a' in
  the implication constraint above.

The end effect is that, much as we do for overlapping instances, we
delay choosing a class instance if there is a possibility of another
instance OR a given to match our constraint later on. This fixes
tickets #4981 and #5002.

Other notes:

* The check is done *first*, so that it also covers classes
  with built-in instance solving, such as
     - constraint tuples
     - natural numbers
     - Typeable

* See also Note [What might equal later?] in GHC.Tc.Solver.InertSet.

* The given-overlap problem is arguably not easy to appear in practice
  due to our aggressive prioritization of equality solving over other
  constraints, but it is possible. I've added a test case in
  typecheck/should-compile/GivenOverlapping.hs

* Another &quot;live&quot; example is #10195; another is #10177.

* We ignore the overlap problem if -XIncoherentInstances is in force:
  see #6002 for a worked-out example where this makes a
  difference.

* Moreover notice that our goals here are different than the goals of
  the top-level overlapping checks. There we are interested in
  validating the following principle:

      If we inline a function f at a site where the same global
      instance environment is available as the instance environment at
      the definition site of f then we should get the same behaviour.

  But for the Given Overlap check our goal is just related to completeness of
  constraint solving.

* The solution is only a partial one.  Consider the above example with
       g :: forall a. Q [a] =&gt; [a] -&gt; Int
       g x = let v = wob x
             in v
  and suppose we have -XNoMonoLocalBinds, so that we attempt to find the most
  general type for 'v'.  When generalising v's type we'll simplify its
  Q [alpha] constraint, but we don't have Q [a] in the 'givens', so we
  will use the instance declaration after all. #11948 was a case
  in point.

All of this is disgustingly delicate, so to discourage people from writing
simplifiable class givens, we warn about signatures that contain them;
see GHC.Tc.Validity Note [Simplifiable given constraints].


Note [Local instances and incoherence]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider
   f :: forall b c. (Eq b, forall a. Eq a =&gt; Eq (c a))
                 =&gt; c b -&gt; Bool
   f x = x==x

We get [W] Eq (c b), and we must use the local instance to solve it.

BUT that wanted also unifies with the top-level Eq [a] instance,
and Eq (Maybe a) etc.  We want the local instance to &quot;win&quot;, otherwise
we can't solve the wanted at all.  So we mark it as Incohherent.
According to Note [Rules for instance lookup] in GHC.Core.InstEnv, that'll
make it win even if there are other instances that unify.

Moreover this is not a hack!  The evidence for this local instance
will be constructed by GHC at a call site... from the very instances
that unify with it here.  It is not like an incoherent user-written
instance which might have utterly different behaviour.

Consider  f :: Eq a =&gt; blah.  If we have [W] Eq a, we certainly
get it from the Eq a context, without worrying that there are
lots of top-level instances that unify with [W] Eq a!  We'll use
those instances to build evidence to pass to f. That's just the
nullary case of what's happening here.
-}</span><span>
</span><span id="line-1139"></span><span>
</span><span id="line-1140"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#matchLocalInst"><span class="hs-identifier hs-type">matchLocalInst</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Utils.TcType.html#TcPredType"><span class="hs-identifier hs-type">TcPredType</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Types.CtLoc.html#CtLoc"><span class="hs-identifier hs-type">CtLoc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#TcS"><span class="hs-identifier hs-type">TcS</span></a></span><span> </span><span class="annot"><a href="GHC.Tc.Instance.Class.html#ClsInstResult"><span class="hs-identifier hs-type">ClsInstResult</span></a></span><span>
</span><span id="line-1141"></span><span class="hs-comment">-- Look up the predicate in Given quantified constraints,</span><span>
</span><span id="line-1142"></span><span class="hs-comment">-- which are effectively just local instance declarations.</span><span>
</span><span id="line-1143"></span><span id="matchLocalInst"><span class="annot"><span class="annottext">matchLocalInst :: Type -&gt; CtLoc -&gt; TcS ClsInstResult
</span><a href="GHC.Tc.Solver.Dict.html#matchLocalInst"><span class="hs-identifier hs-var hs-var">matchLocalInst</span></a></span></span><span> </span><span id="local-6989586621683041960"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041960"><span class="hs-identifier hs-var">pred</span></a></span></span><span> </span><span id="local-6989586621683041961"><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041961"><span class="hs-identifier hs-var">loc</span></a></span></span><span>
</span><span id="line-1144"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span id="local-6989586621683041962"><span class="annot"><a href="#local-6989586621683041962"><span class="hs-identifier hs-var">inerts</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Solver.InertSet.html#IS"><span class="hs-identifier hs-type">IS</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.InertSet.html#inert_cans"><span class="hs-identifier hs-var">inert_cans</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041963"><span class="annot"><a href="#local-6989586621683041963"><span class="hs-identifier hs-var">ics</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TcS InertSet
</span><a href="GHC.Tc.Solver.Monad.html#getInertSet"><span class="hs-identifier hs-var">getInertSet</span></a></span><span>
</span><span id="line-1145"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621683041964"><span class="hs-identifier hs-type">match_local_inst</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041962"><span class="hs-identifier hs-type">inerts</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Solver.InertSet.html#inert_insts"><span class="hs-identifier hs-var">inert_insts</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041963"><span class="hs-identifier hs-type">ics</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1146"></span><span>          </span><span class="hs-special">{</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-var">traceTcS</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;No local instance for&quot;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041960"><span class="hs-identifier hs-var">pred</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1147"></span><span>                           </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">ClsInstResult -&gt; TcS ClsInstResult
forall a. a -&gt; TcS a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">ClsInstResult
</span><a href="GHC.Tc.Instance.Class.html#NoInstance"><span class="hs-identifier hs-var">NoInstance</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-1148"></span><span>          </span><span class="hs-special">;</span><span> </span><span class="hs-special">(</span><span id="local-6989586621683041966"><span class="annot"><span class="annottext">[(CtEvidence, [DFunInstType])]
</span><a href="#local-6989586621683041966"><span class="hs-identifier hs-var">matches</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621683041967"><span class="annot"><span class="annottext">[(CtEvidence, [DFunInstType])]
</span><a href="#local-6989586621683041967"><span class="hs-identifier hs-var">unifs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1149"></span><span>    </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span id="local-6989586621683041968"><span class="annot"><a href="#local-6989586621683041968"><span class="hs-identifier hs-var">matches</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">((CtEvidence, [DFunInstType]) -&gt; TcS InstDFun)
-&gt; [(CtEvidence, [DFunInstType])] -&gt; TcS [InstDFun]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">(CtEvidence, [DFunInstType]) -&gt; TcS InstDFun
</span><a href="#local-6989586621683041969"><span class="hs-identifier hs-var">mk_instDFun</span></a></span><span> </span><span class="annot"><span class="annottext">[(CtEvidence, [DFunInstType])]
</span><a href="#local-6989586621683041966"><span class="hs-identifier hs-var">matches</span></a></span><span>
</span><span id="line-1150"></span><span>       </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683041970"><span class="annot"><a href="#local-6989586621683041970"><span class="hs-identifier hs-var">unifs</span></a></span></span><span>   </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="hs-identifier hs-type">mapM</span></span><span> </span><span class="annot"><a href="#local-6989586621683041969"><span class="hs-identifier hs-type">mk_instDFun</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041967"><span class="hs-identifier hs-type">unifs</span></a></span><span>
</span><span id="line-1151"></span><span>         </span><span class="hs-comment">-- See Note [Use only the best matching quantified constraint]</span><span>
</span><span id="line-1152"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#dominatingMatch"><span class="hs-identifier hs-type">dominatingMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683041968"><span class="hs-identifier hs-type">matches</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1153"></span><span>          </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621683041972"><span class="annot"><span class="annottext">EvVar
</span><a href="#local-6989586621683041972"><span class="hs-identifier hs-var">dfun_id</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621683041973"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041973"><span class="hs-identifier hs-var">tys</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621683041974"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041974"><span class="hs-identifier hs-var">theta</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-1154"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">(InstDFun -&gt; Bool) -&gt; [InstDFun] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041974"><span class="hs-identifier hs-var">theta</span></a></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Type] -&gt; Bool
</span><a href="GHC.Tc.Solver.Dict.html#impliedBySCs"><span class="hs-operator hs-var">`impliedBySCs`</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([Type] -&gt; Bool) -&gt; (InstDFun -&gt; [Type]) -&gt; InstDFun -&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">InstDFun -&gt; [Type]
forall a b c. (a, b, c) -&gt; c
</span><a href="GHC.Utils.Misc.html#thdOf3"><span class="hs-identifier hs-var">thdOf3</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[InstDFun]
</span><a href="#local-6989586621683041970"><span class="hs-identifier hs-var">unifs</span></a></span><span>
</span><span id="line-1155"></span><span>            </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1156"></span><span>            </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621683041977"><span class="annot"><span class="annottext">result :: ClsInstResult
</span><a href="#local-6989586621683041977"><span class="hs-identifier hs-var hs-var hs-var">result</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Tc.Instance.Class.html#OneInst"><span class="hs-identifier hs-type">OneInst</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">cir_new_theta :: [Type]
</span><a href="GHC.Tc.Instance.Class.html#cir_new_theta"><span class="hs-identifier hs-var">cir_new_theta</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041974"><span class="hs-identifier hs-var">theta</span></a></span><span>
</span><span id="line-1157"></span><span>                                      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cir_mk_ev :: [EvExpr] -&gt; EvTerm
</span><a href="GHC.Tc.Instance.Class.html#cir_mk_ev"><span class="hs-identifier hs-var">cir_mk_ev</span></a></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">EvVar -&gt; [Type] -&gt; [EvExpr] -&gt; EvTerm
</span><a href="GHC.Tc.Types.Evidence.html#evDFunApp"><span class="hs-identifier hs-var">evDFunApp</span></a></span><span> </span><span class="annot"><span class="annottext">EvVar
</span><a href="#local-6989586621683041972"><span class="hs-identifier hs-var">dfun_id</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683041973"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-1158"></span><span>                                      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cir_canonical :: CanonicalEvidence
</span><a href="GHC.Tc.Instance.Class.html#cir_canonical"><span class="hs-identifier hs-var">cir_canonical</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CanonicalEvidence
</span><a href="GHC.Core.InstEnv.html#EvCanonical"><span class="hs-identifier hs-var">EvCanonical</span></a></span><span>
</span><span id="line-1159"></span><span>                                      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cir_what :: InstanceWhat
</span><a href="GHC.Tc.Instance.Class.html#cir_what"><span class="hs-identifier hs-var">cir_what</span></a></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">InstanceWhat
</span><a href="GHC.Tc.Types.Origin.html#LocalInstance"><span class="hs-identifier hs-var">LocalInstance</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-1160"></span><span>               </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-var">traceTcS</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Best local instance found:&quot;</span></span><span> </span><span class="annot"><span class="annottext">(SDoc -&gt; TcS ()) -&gt; SDoc -&gt; TcS ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-1161"></span><span>                  </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsDoc doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#vcat"><span class="hs-identifier hs-var">vcat</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
forall doc. IsLine doc =&gt; String -&gt; doc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;pred:&quot;</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041960"><span class="hs-identifier hs-var">pred</span></a></span><span>
</span><span id="line-1162"></span><span>                       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
forall doc. IsLine doc =&gt; String -&gt; doc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;result:&quot;</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">ClsInstResult -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">ClsInstResult
</span><a href="#local-6989586621683041977"><span class="hs-identifier hs-var">result</span></a></span><span>
</span><span id="line-1163"></span><span>                       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
forall doc. IsLine doc =&gt; String -&gt; doc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;matches:&quot;</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[InstDFun] -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">[InstDFun]
</span><a href="#local-6989586621683041968"><span class="hs-identifier hs-var">matches</span></a></span><span>
</span><span id="line-1164"></span><span>                       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
forall doc. IsLine doc =&gt; String -&gt; doc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;unifs:&quot;</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[InstDFun] -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">[InstDFun]
</span><a href="#local-6989586621683041970"><span class="hs-identifier hs-var">unifs</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-1165"></span><span>               </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">ClsInstResult -&gt; TcS ClsInstResult
forall a. a -&gt; TcS a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">ClsInstResult
</span><a href="#local-6989586621683041977"><span class="hs-identifier hs-var">result</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-1166"></span><span>
</span><span id="line-1167"></span><span>          </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683041980"><span class="annot"><span class="annottext">Maybe InstDFun
</span><a href="#local-6989586621683041980"><span class="hs-identifier hs-var">mb_best</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1168"></span><span>            </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-var">traceTcS</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Multiple local instances; not committing to any&quot;</span></span><span>
</span><span id="line-1169"></span><span>                  </span><span class="annot"><span class="annottext">(SDoc -&gt; TcS ()) -&gt; SDoc -&gt; TcS ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsDoc doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#vcat"><span class="hs-identifier hs-var">vcat</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
forall doc. IsLine doc =&gt; String -&gt; doc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;pred:&quot;</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041960"><span class="hs-identifier hs-var">pred</span></a></span><span>
</span><span id="line-1170"></span><span>                         </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
forall doc. IsLine doc =&gt; String -&gt; doc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;matches:&quot;</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[InstDFun] -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">[InstDFun]
</span><a href="#local-6989586621683041968"><span class="hs-identifier hs-var">matches</span></a></span><span>
</span><span id="line-1171"></span><span>                         </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
forall doc. IsLine doc =&gt; String -&gt; doc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;unifs:&quot;</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[InstDFun] -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">[InstDFun]
</span><a href="#local-6989586621683041970"><span class="hs-identifier hs-var">unifs</span></a></span><span>
</span><span id="line-1172"></span><span>                         </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
forall doc. IsLine doc =&gt; String -&gt; doc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;best_match:&quot;</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe InstDFun -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe InstDFun
</span><a href="#local-6989586621683041980"><span class="hs-identifier hs-var">mb_best</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-1173"></span><span>               </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">ClsInstResult -&gt; TcS ClsInstResult
forall a. a -&gt; TcS a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">ClsInstResult
</span><a href="GHC.Tc.Instance.Class.html#NotSure"><span class="hs-identifier hs-var">NotSure</span></a></span><span> </span><span class="hs-special">}</span><span class="hs-special">}</span><span class="hs-special">}</span><span class="hs-special">}</span><span class="hs-special">}</span><span>
</span><span id="line-1174"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1175"></span><span>    </span><span id="local-6989586621683041981"><span class="annot"><span class="annottext">pred_tv_set :: TyCoVarSet
</span><a href="#local-6989586621683041981"><span class="hs-identifier hs-var hs-var">pred_tv_set</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; TyCoVarSet
</span><a href="GHC.Core.TyCo.FVs.html#tyCoVarsOfType"><span class="hs-identifier hs-var">tyCoVarsOfType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041960"><span class="hs-identifier hs-var">pred</span></a></span><span>
</span><span id="line-1176"></span><span>
</span><span id="line-1177"></span><span>    </span><span class="annot"><a href="#local-6989586621683041969"><span class="hs-identifier hs-type">mk_instDFun</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CtEvidence"><span class="hs-identifier hs-type">CtEvidence</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.InstEnv.html#DFunInstType"><span class="hs-identifier hs-type">DFunInstType</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#TcS"><span class="hs-identifier hs-type">TcS</span></a></span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#InstDFun"><span class="hs-identifier hs-type">InstDFun</span></a></span><span>
</span><span id="line-1178"></span><span>    </span><span id="local-6989586621683041969"><span class="annot"><span class="annottext">mk_instDFun :: (CtEvidence, [DFunInstType]) -&gt; TcS InstDFun
</span><a href="#local-6989586621683041969"><span class="hs-identifier hs-var hs-var">mk_instDFun</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621683041983"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041983"><span class="hs-identifier hs-var">ev</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621683041984"><span class="annot"><span class="annottext">[DFunInstType]
</span><a href="#local-6989586621683041984"><span class="hs-identifier hs-var">tys</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1179"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621683041985"><span class="annot"><span class="annottext">dfun_id :: EvVar
</span><a href="#local-6989586621683041985"><span class="hs-identifier hs-var hs-var">dfun_id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; EvVar
</span><a href="GHC.Tc.Types.Constraint.html#ctEvEvId"><span class="hs-identifier hs-var">ctEvEvId</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041983"><span class="hs-identifier hs-var">ev</span></a></span><span>
</span><span id="line-1180"></span><span>      </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-special">(</span><span id="local-6989586621683041986"><span class="annot"><a href="#local-6989586621683041986"><span class="hs-identifier hs-var">tys</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621683041987"><span class="annot"><a href="#local-6989586621683041987"><span class="hs-identifier hs-var">theta</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">EvVar -&gt; [DFunInstType] -&gt; TcS ([Type], [Type])
</span><a href="GHC.Tc.Solver.Monad.html#instDFunType"><span class="hs-identifier hs-var">instDFunType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtEvidence -&gt; EvVar
</span><a href="GHC.Tc.Types.Constraint.html#ctEvEvId"><span class="hs-identifier hs-var">ctEvEvId</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041983"><span class="hs-identifier hs-var">ev</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[DFunInstType]
</span><a href="#local-6989586621683041984"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-1181"></span><span>            </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621683041985"><span class="hs-identifier hs-type">dfun_id</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621683041986"><span class="hs-identifier hs-type">tys</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621683041987"><span class="hs-identifier hs-type">theta</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-1182"></span><span>
</span><span id="line-1183"></span><span>    </span><span class="hs-comment">-- Compute matching and unifying local instances</span><span>
</span><span id="line-1184"></span><span>    </span><span class="annot"><a href="#local-6989586621683041964"><span class="hs-identifier hs-type">match_local_inst</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.InertSet.html#InertSet"><span class="hs-identifier hs-type">InertSet</span></a></span><span>
</span><span id="line-1185"></span><span>                     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#QCInst"><span class="hs-identifier hs-type">QCInst</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1186"></span><span>                     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CtEvidence"><span class="hs-identifier hs-type">CtEvidence</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.InstEnv.html#DFunInstType"><span class="hs-identifier hs-type">DFunInstType</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-1187"></span><span>                        </span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CtEvidence"><span class="hs-identifier hs-type">CtEvidence</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.InstEnv.html#DFunInstType"><span class="hs-identifier hs-type">DFunInstType</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-1188"></span><span>    </span><span id="local-6989586621683041964"><span class="annot"><span class="annottext">match_local_inst :: InertSet
-&gt; [QCInst]
-&gt; ([(CtEvidence, [DFunInstType])], [(CtEvidence, [DFunInstType])])
</span><a href="#local-6989586621683041964"><span class="hs-identifier hs-var hs-var">match_local_inst</span></a></span></span><span> </span><span id="local-6989586621683041989"><span class="annot"><span class="annottext">InertSet
</span><a href="#local-6989586621683041989"><span class="hs-identifier hs-var">_inerts</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-1189"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1190"></span><span>    </span><span class="annot"><a href="#local-6989586621683041964"><span class="hs-identifier hs-var">match_local_inst</span></a></span><span> </span><span id="local-6989586621683041990"><span class="annot"><span class="annottext">InertSet
</span><a href="#local-6989586621683041990"><span class="hs-identifier hs-var">inerts</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621683041991"><span class="annot"><span class="annottext">qci :: QCInst
</span><a href="#local-6989586621683041991"><span class="hs-identifier hs-var">qci</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#QCI"><span class="hs-identifier hs-type">QCI</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">qci_tvs :: QCInst -&gt; [EvVar]
</span><a href="GHC.Tc.Types.Constraint.html#qci_tvs"><span class="hs-identifier hs-var">qci_tvs</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041994"><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683041994"><span class="hs-identifier hs-var">qtvs</span></a></span></span><span>
</span><span id="line-1191"></span><span>                                      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">qci_pred :: QCInst -&gt; Type
</span><a href="GHC.Tc.Types.Constraint.html#qci_pred"><span class="hs-identifier hs-var">qci_pred</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041996"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041996"><span class="hs-identifier hs-var">qpred</span></a></span></span><span>
</span><span id="line-1192"></span><span>                                      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">qci_ev :: QCInst -&gt; CtEvidence
</span><a href="GHC.Tc.Types.Constraint.html#qci_ev"><span class="hs-identifier hs-var">qci_ev</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683041998"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041998"><span class="hs-identifier hs-var">qev</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-1193"></span><span>                            </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621683041999"><span class="annot"><span class="annottext">[QCInst]
</span><a href="#local-6989586621683041999"><span class="hs-identifier hs-var">qcis</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-1194"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621683042000"><span class="annot"><span class="annottext">in_scope :: InScopeSet
</span><a href="#local-6989586621683042000"><span class="hs-identifier hs-var hs-var">in_scope</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TyCoVarSet -&gt; InScopeSet
</span><a href="GHC.Types.Var.Env.html#mkInScopeSet"><span class="hs-identifier hs-var">mkInScopeSet</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TyCoVarSet
</span><a href="#local-6989586621683042002"><span class="hs-identifier hs-var">qtv_set</span></a></span><span> </span><span class="annot"><span class="annottext">TyCoVarSet -&gt; TyCoVarSet -&gt; TyCoVarSet
</span><a href="GHC.Types.Var.Set.html#unionVarSet"><span class="hs-operator hs-var">`unionVarSet`</span></a></span><span> </span><span class="annot"><span class="annottext">TyCoVarSet
</span><a href="#local-6989586621683041981"><span class="hs-identifier hs-var">pred_tv_set</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1195"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621683042004"><span class="annot"><span class="annottext">TvSubstEnv
</span><a href="#local-6989586621683042004"><span class="hs-identifier hs-var">tv_subst</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TyCoVarSet
-&gt; RnEnv2 -&gt; TvSubstEnv -&gt; Type -&gt; Type -&gt; Maybe TvSubstEnv
</span><a href="GHC.Core.Unify.html#ruleMatchTyKiX"><span class="hs-identifier hs-var">ruleMatchTyKiX</span></a></span><span> </span><span class="annot"><span class="annottext">TyCoVarSet
</span><a href="#local-6989586621683042002"><span class="hs-identifier hs-var">qtv_set</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">InScopeSet -&gt; RnEnv2
</span><a href="GHC.Types.Var.Env.html#mkRnEnv2"><span class="hs-identifier hs-var">mkRnEnv2</span></a></span><span> </span><span class="annot"><span class="annottext">InScopeSet
</span><a href="#local-6989586621683042000"><span class="hs-identifier hs-var">in_scope</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1196"></span><span>                                        </span><span class="annot"><span class="annottext">TvSubstEnv
</span><a href="GHC.Core.TyCo.Subst.html#emptyTvSubstEnv"><span class="hs-identifier hs-var">emptyTvSubstEnv</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041996"><span class="hs-identifier hs-var">qpred</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041960"><span class="hs-identifier hs-var">pred</span></a></span><span>
</span><span id="line-1197"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621683042007"><span class="annot"><span class="annottext">match :: (CtEvidence, [DFunInstType])
</span><a href="#local-6989586621683042007"><span class="hs-identifier hs-var hs-var">match</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041998"><span class="hs-identifier hs-var">qev</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(EvVar -&gt; DFunInstType) -&gt; [EvVar] -&gt; [DFunInstType]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TvSubstEnv -&gt; EvVar -&gt; DFunInstType
forall a. VarEnv a -&gt; EvVar -&gt; Maybe a
</span><a href="GHC.Types.Var.Env.html#lookupVarEnv"><span class="hs-identifier hs-var">lookupVarEnv</span></a></span><span> </span><span class="annot"><span class="annottext">TvSubstEnv
</span><a href="#local-6989586621683042004"><span class="hs-identifier hs-var">tv_subst</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683041994"><span class="hs-identifier hs-var">qtvs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1198"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(CtEvidence, [DFunInstType])
</span><a href="#local-6989586621683042007"><span class="hs-identifier hs-var">match</span></a></span><span class="annot"><span class="annottext">(CtEvidence, [DFunInstType])
-&gt; [(CtEvidence, [DFunInstType])] -&gt; [(CtEvidence, [DFunInstType])]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[(CtEvidence, [DFunInstType])]
</span><a href="#local-6989586621683042009"><span class="hs-identifier hs-var">matches</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[(CtEvidence, [DFunInstType])]
</span><a href="#local-6989586621683042010"><span class="hs-identifier hs-var">unifs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1199"></span><span>
</span><span id="line-1200"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-1201"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
-&gt; SDoc
-&gt; ([(CtEvidence, [DFunInstType])], [(CtEvidence, [DFunInstType])])
-&gt; ([(CtEvidence, [DFunInstType])], [(CtEvidence, [DFunInstType])])
forall a. HasCallStack =&gt; Bool -&gt; SDoc -&gt; a -&gt; a
</span><a href="GHC.Utils.Panic.html#assertPpr"><span class="hs-identifier hs-var">assertPpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TyCoVarSet -&gt; TyCoVarSet -&gt; Bool
</span><a href="GHC.Types.Var.Set.html#disjointVarSet"><span class="hs-identifier hs-var">disjointVarSet</span></a></span><span> </span><span class="annot"><span class="annottext">TyCoVarSet
</span><a href="#local-6989586621683042002"><span class="hs-identifier hs-var">qtv_set</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; TyCoVarSet
</span><a href="GHC.Core.TyCo.FVs.html#tyCoVarsOfType"><span class="hs-identifier hs-var">tyCoVarsOfType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041960"><span class="hs-identifier hs-var">pred</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1202"></span><span>                  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">QCInst -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">QCInst
</span><a href="#local-6989586621683041991"><span class="hs-identifier hs-var">qci</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsDoc doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%24%24"><span class="hs-operator hs-var">$$</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041960"><span class="hs-identifier hs-var">pred</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1203"></span><span>            </span><span class="hs-comment">-- ASSERT: unification relies on the</span><span>
</span><span id="line-1204"></span><span>            </span><span class="hs-comment">-- quantified variables being fresh</span><span>
</span><span id="line-1205"></span><span>        </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(CtEvidence, [DFunInstType])]
</span><a href="#local-6989586621683042009"><span class="hs-identifier hs-var">matches</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Maybe (CtEvidence, [DFunInstType])
</span><a href="#local-6989586621683042012"><span class="hs-identifier hs-var">this_unif</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (CtEvidence, [DFunInstType])
-&gt; [(CtEvidence, [DFunInstType])] -&gt; [(CtEvidence, [DFunInstType])]
forall {a}. Maybe a -&gt; [a] -&gt; [a]
</span><a href="#local-6989586621683042013"><span class="hs-operator hs-var">`combine`</span></a></span><span> </span><span class="annot"><span class="annottext">[(CtEvidence, [DFunInstType])]
</span><a href="#local-6989586621683042010"><span class="hs-identifier hs-var">unifs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1206"></span><span>      </span><span class="hs-keyword">where</span><span>
</span><span id="line-1207"></span><span>        </span><span id="local-6989586621683042014"><span class="annot"><span class="annottext">qloc :: CtLoc
</span><a href="#local-6989586621683042014"><span class="hs-identifier hs-var hs-var">qloc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; CtLoc
</span><a href="GHC.Tc.Types.Constraint.html#ctEvLoc"><span class="hs-identifier hs-var">ctEvLoc</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041998"><span class="hs-identifier hs-var">qev</span></a></span><span>
</span><span id="line-1208"></span><span>        </span><span id="local-6989586621683042002"><span class="annot"><span class="annottext">qtv_set :: TyCoVarSet
</span><a href="#local-6989586621683042002"><span class="hs-identifier hs-var hs-var">qtv_set</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[EvVar] -&gt; TyCoVarSet
</span><a href="GHC.Types.Var.Set.html#mkVarSet"><span class="hs-identifier hs-var">mkVarSet</span></a></span><span> </span><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683041994"><span class="hs-identifier hs-var">qtvs</span></a></span><span>
</span><span id="line-1209"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621683042009"><span class="annot"><span class="annottext">[(CtEvidence, [DFunInstType])]
</span><a href="#local-6989586621683042009"><span class="hs-identifier hs-var">matches</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621683042010"><span class="annot"><span class="annottext">[(CtEvidence, [DFunInstType])]
</span><a href="#local-6989586621683042010"><span class="hs-identifier hs-var">unifs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">InertSet
-&gt; [QCInst]
-&gt; ([(CtEvidence, [DFunInstType])], [(CtEvidence, [DFunInstType])])
</span><a href="#local-6989586621683041964"><span class="hs-identifier hs-var">match_local_inst</span></a></span><span> </span><span class="annot"><span class="annottext">InertSet
</span><a href="#local-6989586621683041990"><span class="hs-identifier hs-var">inerts</span></a></span><span> </span><span class="annot"><span class="annottext">[QCInst]
</span><a href="#local-6989586621683041999"><span class="hs-identifier hs-var">qcis</span></a></span><span>
</span><span id="line-1210"></span><span>        </span><span id="local-6989586621683042012"><span class="annot"><span class="annottext">this_unif :: Maybe (CtEvidence, [DFunInstType])
</span><a href="#local-6989586621683042012"><span class="hs-identifier hs-var hs-var">this_unif</span></a></span></span><span>
</span><span id="line-1211"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621683042016"><span class="annot"><span class="annottext">Subst
</span><a href="#local-6989586621683042016"><span class="hs-identifier hs-var">subst</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">InertSet -&gt; Type -&gt; CtLoc -&gt; Type -&gt; CtLoc -&gt; Maybe Subst
</span><a href="GHC.Tc.Solver.InertSet.html#mightEqualLater"><span class="hs-identifier hs-var">mightEqualLater</span></a></span><span> </span><span class="annot"><span class="annottext">InertSet
</span><a href="#local-6989586621683041990"><span class="hs-identifier hs-var">inerts</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041996"><span class="hs-identifier hs-var">qpred</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683042014"><span class="hs-identifier hs-var">qloc</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683041960"><span class="hs-identifier hs-var">pred</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683041961"><span class="hs-identifier hs-var">loc</span></a></span><span>
</span><span id="line-1212"></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(CtEvidence, [DFunInstType]) -&gt; Maybe (CtEvidence, [DFunInstType])
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683041998"><span class="hs-identifier hs-var">qev</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(EvVar -&gt; DFunInstType) -&gt; [EvVar] -&gt; [DFunInstType]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Subst -&gt; EvVar -&gt; DFunInstType
</span><a href="GHC.Core.TyCo.Subst.html#lookupTyVar"><span class="hs-identifier hs-var">lookupTyVar</span></a></span><span> </span><span class="annot"><span class="annottext">Subst
</span><a href="#local-6989586621683042016"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683041994"><span class="hs-identifier hs-var">qtvs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1213"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-1214"></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (CtEvidence, [DFunInstType])
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-1215"></span><span>
</span><span id="line-1216"></span><span>        </span><span id="local-6989586621683042013"><span class="annot"><span class="annottext">combine :: Maybe a -&gt; [a] -&gt; [a]
</span><a href="#local-6989586621683042013"><span class="hs-identifier hs-var hs-var">combine</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>  </span><span id="local-6989586621683042019"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621683042019"><span class="hs-identifier hs-var">us</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621683042019"><span class="hs-identifier hs-var">us</span></a></span><span>
</span><span id="line-1217"></span><span>        </span><span class="annot"><a href="#local-6989586621683042013"><span class="hs-identifier hs-var">combine</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621683042020"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621683042020"><span class="hs-identifier hs-var">u</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621683042021"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621683042021"><span class="hs-identifier hs-var">us</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621683042020"><span class="hs-identifier hs-var">u</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; [a] -&gt; [a]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621683042021"><span class="hs-identifier hs-var">us</span></a></span><span>
</span><span id="line-1218"></span><span>
</span><span id="line-1219"></span><span class="annot"><span class="hs-comment">-- | Instance dictionary function and type.</span></span><span>
</span><span id="line-1220"></span><span class="hs-keyword">type</span><span> </span><span id="InstDFun"><span class="annot"><a href="GHC.Tc.Solver.Dict.html#InstDFun"><span class="hs-identifier hs-var">InstDFun</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.Var.html#DFunId"><span class="hs-identifier hs-type">DFunId</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Tc.Utils.TcType.html#TcType"><span class="hs-identifier hs-type">TcType</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Utils.TcType.html#TcThetaType"><span class="hs-identifier hs-type">TcThetaType</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1221"></span><span>
</span><span id="line-1222"></span><span class="hs-comment">-- | Try to find a local quantified instance that dominates all others,</span><span>
</span><span id="line-1223"></span><span class="hs-comment">-- i.e. which has a weaker instance context than all the others.</span><span>
</span><span id="line-1224"></span><span class="hs-comment">--</span><span>
</span><span id="line-1225"></span><span class="hs-comment">-- See Note [Use only the best matching quantified constraint].</span><span>
</span><span id="line-1226"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#dominatingMatch"><span class="hs-identifier hs-type">dominatingMatch</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#InstDFun"><span class="hs-identifier hs-type">InstDFun</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#InstDFun"><span class="hs-identifier hs-type">InstDFun</span></a></span><span>
</span><span id="line-1227"></span><span id="dominatingMatch"><span class="annot"><span class="annottext">dominatingMatch :: [InstDFun] -&gt; Maybe InstDFun
</span><a href="GHC.Tc.Solver.Dict.html#dominatingMatch"><span class="hs-identifier hs-var hs-var">dominatingMatch</span></a></span></span><span> </span><span id="local-6989586621683042025"><span class="annot"><span class="annottext">[InstDFun]
</span><a href="#local-6989586621683042025"><span class="hs-identifier hs-var">matches</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1228"></span><span>  </span><span class="annot"><span class="annottext">[InstDFun] -&gt; Maybe InstDFun
forall a. [a] -&gt; Maybe a
</span><span class="hs-identifier hs-var">listToMaybe</span></span><span> </span><span class="annot"><span class="annottext">([InstDFun] -&gt; Maybe InstDFun) -&gt; [InstDFun] -&gt; Maybe InstDFun
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">((InstDFun, [InstDFun]) -&gt; Maybe InstDFun)
-&gt; [(InstDFun, [InstDFun])] -&gt; [InstDFun]
forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(InstDFun -&gt; [InstDFun] -&gt; Maybe InstDFun)
-&gt; (InstDFun, [InstDFun]) -&gt; Maybe InstDFun
forall a b c. (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c
</span><span class="hs-identifier hs-var">uncurry</span></span><span> </span><span class="annot"><span class="annottext">InstDFun -&gt; [InstDFun] -&gt; Maybe InstDFun
</span><a href="#local-6989586621683042027"><span class="hs-identifier hs-var">go</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[InstDFun] -&gt; [(InstDFun, [InstDFun])]
forall a. [a] -&gt; [(a, [a])]
</span><a href="GHC.Utils.Misc.html#holes"><span class="hs-identifier hs-var">holes</span></a></span><span> </span><span class="annot"><span class="annottext">[InstDFun]
</span><a href="#local-6989586621683042025"><span class="hs-identifier hs-var">matches</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1229"></span><span>  </span><span class="hs-comment">-- listToMaybe: arbitrarily pick any one context that is weaker than</span><span>
</span><span id="line-1230"></span><span>  </span><span class="hs-comment">-- all others, e.g. so that we can handle [Eq a, Num a] vs [Num a, Eq a]</span><span>
</span><span id="line-1231"></span><span>  </span><span class="hs-comment">-- (see test case T22223).</span><span>
</span><span id="line-1232"></span><span>
</span><span id="line-1233"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1234"></span><span>    </span><span class="annot"><a href="#local-6989586621683042027"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#InstDFun"><span class="hs-identifier hs-type">InstDFun</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#InstDFun"><span class="hs-identifier hs-type">InstDFun</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#InstDFun"><span class="hs-identifier hs-type">InstDFun</span></a></span><span>
</span><span id="line-1235"></span><span>    </span><span id="local-6989586621683042027"><span class="annot"><span class="annottext">go :: InstDFun -&gt; [InstDFun] -&gt; Maybe InstDFun
</span><a href="#local-6989586621683042027"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621683042029"><span class="annot"><span class="annottext">InstDFun
</span><a href="#local-6989586621683042029"><span class="hs-identifier hs-var">this</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">InstDFun -&gt; Maybe InstDFun
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">InstDFun
</span><a href="#local-6989586621683042029"><span class="hs-identifier hs-var">this</span></a></span><span>
</span><span id="line-1236"></span><span>    </span><span class="annot"><a href="#local-6989586621683042027"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621683042030"><span class="annot"><span class="annottext">this :: InstDFun
</span><a href="#local-6989586621683042030"><span class="hs-identifier hs-var">this</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><span class="annottext">EvVar
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">[Type]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span id="local-6989586621683042031"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042031"><span class="hs-identifier hs-var">this_theta</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">EvVar
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">[Type]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span id="local-6989586621683042032"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042032"><span class="hs-identifier hs-var">other_theta</span></a></span></span><span class="hs-special">)</span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621683042033"><span class="annot"><span class="annottext">[InstDFun]
</span><a href="#local-6989586621683042033"><span class="hs-identifier hs-var">others</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-1237"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042031"><span class="hs-identifier hs-var">this_theta</span></a></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Type] -&gt; Bool
</span><a href="GHC.Tc.Solver.Dict.html#impliedBySCs"><span class="hs-operator hs-var">`impliedBySCs`</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042032"><span class="hs-identifier hs-var">other_theta</span></a></span><span>
</span><span id="line-1238"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">InstDFun -&gt; [InstDFun] -&gt; Maybe InstDFun
</span><a href="#local-6989586621683042027"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">InstDFun
</span><a href="#local-6989586621683042030"><span class="hs-identifier hs-var">this</span></a></span><span> </span><span class="annot"><span class="annottext">[InstDFun]
</span><a href="#local-6989586621683042033"><span class="hs-identifier hs-var">others</span></a></span><span>
</span><span id="line-1239"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-1240"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe InstDFun
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-1241"></span><span>
</span><span id="line-1242"></span><span class="hs-comment">-- | Whether a collection of constraints is implied by another collection,</span><span>
</span><span id="line-1243"></span><span class="hs-comment">-- according to a simple superclass check.</span><span>
</span><span id="line-1244"></span><span class="hs-comment">--</span><span>
</span><span id="line-1245"></span><span class="hs-comment">-- See Note [When does a quantified instance dominate another?].</span><span>
</span><span id="line-1246"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#impliedBySCs"><span class="hs-identifier hs-type">impliedBySCs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Utils.TcType.html#TcThetaType"><span class="hs-identifier hs-type">TcThetaType</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Utils.TcType.html#TcThetaType"><span class="hs-identifier hs-type">TcThetaType</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-1247"></span><span id="impliedBySCs"><span class="annot"><span class="annottext">impliedBySCs :: [Type] -&gt; [Type] -&gt; Bool
</span><a href="GHC.Tc.Solver.Dict.html#impliedBySCs"><span class="hs-identifier hs-var hs-var">impliedBySCs</span></a></span></span><span> </span><span id="local-6989586621683042034"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042034"><span class="hs-identifier hs-var">c1</span></a></span></span><span> </span><span id="local-6989586621683042035"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042035"><span class="hs-identifier hs-var">c2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Bool) -&gt; [Type] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Bool
</span><a href="#local-6989586621683042036"><span class="hs-identifier hs-var">in_c2</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042034"><span class="hs-identifier hs-var">c1</span></a></span><span>
</span><span id="line-1248"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1249"></span><span>    </span><span class="annot"><a href="#local-6989586621683042036"><span class="hs-identifier hs-type">in_c2</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Utils.TcType.html#TcPredType"><span class="hs-identifier hs-type">TcPredType</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-1250"></span><span>    </span><span id="local-6989586621683042036"><span class="annot"><span class="annottext">in_c2 :: Type -&gt; Bool
</span><a href="#local-6989586621683042036"><span class="hs-identifier hs-var hs-var">in_c2</span></a></span></span><span> </span><span id="local-6989586621683042037"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042037"><span class="hs-identifier hs-var">pred</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Bool) -&gt; [Type] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">any</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042037"><span class="hs-identifier hs-var">pred</span></a></span><span> </span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; Type -&gt; Type -&gt; Bool
Type -&gt; Type -&gt; Bool
</span><a href="GHC.Core.TyCo.Compare.html#tcEqType"><span class="hs-operator hs-var">`tcEqType`</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042040"><span class="hs-identifier hs-var">c2_expanded</span></a></span><span>
</span><span id="line-1251"></span><span>
</span><span id="line-1252"></span><span>    </span><span class="annot"><a href="#local-6989586621683042040"><span class="hs-identifier hs-type">c2_expanded</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Tc.Utils.TcType.html#TcPredType"><span class="hs-identifier hs-type">TcPredType</span></a></span><span class="hs-special">]</span><span>  </span><span class="hs-comment">-- Includes all superclasses</span><span>
</span><span id="line-1253"></span><span>    </span><span id="local-6989586621683042040"><span class="annot"><span class="annottext">c2_expanded :: [Type]
</span><a href="#local-6989586621683042040"><span class="hs-identifier hs-var hs-var">c2_expanded</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042041"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621683042042"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042042"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042035"><span class="hs-identifier hs-var">c2</span></a></span><span class="hs-special">,</span><span> </span><span id="local-6989586621683042041"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042041"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042042"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Type] -&gt; [Type]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Type]
</span><a href="GHC.Tc.Utils.TcType.html#transSuperClasses"><span class="hs-identifier hs-var">transSuperClasses</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042042"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-1254"></span><span>
</span><span id="line-1255"></span><span>
</span><span id="line-1256"></span><span class="hs-comment">{- Note [When does a quantified instance dominate another?]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When matching local quantified instances, it's useful to be able to pick
the one with the weakest precondition, e.g. if one has both

  [G] d1: forall a b. ( Eq a, Num b, C a b  ) =&gt; D a b
  [G] d2: forall a  .                C a Int  =&gt; D a Int
  [W] {w}: D a Int

Then it makes sense to use d2 to solve w, as doing so we end up with a strictly
weaker proof obligation of `C a Int`, compared to `(Eq a, Num Int, C a Int)`
were we to use d1.

In theory, to compute whether one context implies another, we would need to
recursively invoke the constraint solver. This is expensive, so we instead do
a simple check using superclasses, implemented in impliedBySCs.

Examples:

 - [Eq a] is implied by [Ord a]
 - [Ord a] is not implied by [Eq a],
 - any context is implied by itself,
 - the empty context is implied by any context.

Note [Use only the best matching quantified constraint]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider (#20582) the ambiguity check for
  (forall a. Ord (m a), forall a. Semigroup a =&gt; Eq (m a)) =&gt; m Int

Because of eager expansion of given superclasses, we get
  [G] d1: forall a. Ord (m a)
  [G] d2: forall a. Eq (m a)
  [G] d3: forall a. Semigroup a =&gt; Eq (m a)

  [W] {w1}: forall a. Ord (m a)
  [W] {w2}: forall a. Semigroup a =&gt; Eq (m a)

The first wanted is solved straightforwardly. But the second wanted
matches *two* local instances: d2 and d3. Our general rule around multiple local
instances is that we refuse to commit to any of them. However, that
means that our type fails the ambiguity check. That's bad: the type
is perfectly fine. (This actually came up in the wild, in the streamly
library.)

The solution is to prefer local instances which are easier to prove, meaning
that they have a weaker precondition. In this case, the empty context
of d2 is a weaker constraint than the &quot;Semigroup a&quot; context of d3, so we prefer
using it when proving w2. This allows us to pass the ambiguity check here.

Our criterion for solving a Wanted by matching local quantified instances is
thus as follows:

  - There is a matching local quantified instance that dominates all others
    matches, in the sense of [When does a quantified instance dominate another?].
    Any such match do, we pick it arbitrarily (the T22223 example below says why).
  - This local quantified instance also dominates all the unifiers, as we
    wouldn't want to commit to a single match when we might have multiple,
    genuinely different matches after further unification takes place.

Some other examples:


  #15244:

    f :: (C g, D g) =&gt; ....
    class S g =&gt; C g where ...
    class S g =&gt; D g where ...
    class (forall a. Eq a =&gt; Eq (g a)) =&gt; S g where ...

  Here, in f's RHS, there are two identical quantified constraints
  available, one via the superclasses of C and one via the superclasses
  of D. Given that each implies the other, we pick one arbitrarily.


  #22216:

    class Eq a
    class Eq a =&gt; Ord a
    class (forall b. Eq b =&gt; Eq (f b)) =&gt; Eq1 f
    class (Eq1 f, forall b. Ord b =&gt; Ord (f b)) =&gt; Ord1 f

  Suppose we have

    [G] d1: Ord1 f
    [G] d2: Eq a
    [W] {w}: Eq (f a)

  Superclass expansion of d1 gives us:

    [G] d3 : Eq1 f
    [G] d4 : forall b. Ord b =&gt; Ord (f b)

  expanding d4 and d5 gives us, respectively:

    [G] d5 : forall b. Eq  b =&gt; Eq (f b)
    [G] d6 : forall b. Ord b =&gt; Eq (f b)

  Now we have two matching local instances that we could use when solving the
  Wanted. However, it's obviously silly to use d6, given that d5 provides us with
  as much information, with a strictly weaker precondition. So we pick d5 to solve
  w. If we chose d6, we would get [W] Ord a, which in this case we can't solve.


  #22223:

    [G] forall a b. (Eq a, Ord b) =&gt; C a b
    [G] forall a b. (Ord b, Eq a) =&gt; C a b
    [W] C x y

  Here we should be free to pick either quantified constraint, as they are
  equivalent up to re-ordering of the constraints in the context.
  See also Note [Do not add duplicate quantified instances]
  in GHC.Tc.Solver.Monad.

Test cases:
  typecheck/should_compile/T20582
  quantified-constraints/T15244
  quantified-constraints/T22216{a,b,c,d,e}
  quantified-constraints/T22223

Historical note: a previous solution was to instead pick the local instance
with the least superclass depth (see Note [Replacement vs keeping]),
but that doesn't work for the example from #22216.
-}</span><span>
</span><span id="line-1380"></span><span>
</span><span id="line-1381"></span><span class="annot"><span class="hs-comment">{- *********************************************************************
*                                                                      *
*          Functional dependencies, instantiation of equations
*                                                                      *
************************************************************************

When we spot an equality arising from a functional dependency,
we now use that equality (a &quot;wanted&quot;) to rewrite the work-item
constraint right away.  This avoids two dangers

 Danger 1: If we send the original constraint on down the pipeline
           it may react with an instance declaration, and in delicate
           situations (when a Given overlaps with an instance) that
           may produce new insoluble goals: see #4952

 Danger 2: If we don't rewrite the constraint, it may re-react
           with the same thing later, and produce the same equality
           again --&gt; termination worries.

To achieve this required some refactoring of GHC.Tc.Instance.FunDeps (nicer
now!).

Note [FunDep and implicit parameter reactions]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Currently, our story of interacting two dictionaries (or a dictionary
and top-level instances) for functional dependencies, and implicit
parameters, is that we simply produce new Wanted equalities.  So for example

        class D a b | a -&gt; b where ...
    Inert:
        [G] d1 : D Int Bool
    WorkItem:
        [W] d2 : D Int alpha

    We generate the extra work item
        [W] cv : alpha ~ Bool
    where 'cv' is currently unused.  However, this new item can perhaps be
    spontaneously solved to become given and react with d2,
    discharging it in favour of a new constraint d2' thus:
        [W] d2' : D Int Bool
        d2 := d2' |&gt; D Int cv
    Now d2' can be discharged from d1

We could be more aggressive and try to *immediately* solve the dictionary
using those extra equalities.

If that were the case with the same inert set and work item we might discard
d2 directly:

        [W] cv : alpha ~ Bool
        d2 := d1 |&gt; D Int cv

But in general it's a bit painful to figure out the necessary coercion,
so we just take the first approach. Here is a better example. Consider:
    class C a b c | a -&gt; b
And:
     [G]  d1 : C T Int Char
     [W] d2 : C T beta Int
In this case, it's *not even possible* to solve the wanted immediately.
So we should simply output the functional dependency and add this guy
[but NOT its superclasses] back in the worklist. Even worse:
     [G] d1 : C T Int beta
     [W] d2: C T beta Int
Then it is solvable, but its very hard to detect this on the spot.

It's exactly the same with implicit parameters, except that the
&quot;aggressive&quot; approach would be much easier to implement.

Note [Fundeps with instances, and equality orientation]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This Note describes a delicate interaction that constrains the orientation of
equalities. This one is about fundeps, but the /exact/ same thing arises for
type-family injectivity constraints: see Note [Improvement orientation].

doTopFunDepImprovement compares the constraint with all the instance
declarations, to see if we can produce any equalities. E.g
   class C2 a b | a -&gt; b
   instance C Int Bool
Then the constraint (C Int ty) generates the equality [W] ty ~ Bool.

There is a nasty corner in #19415 which led to the typechecker looping:
   class C s t b | s -&gt; t
   instance ... =&gt; C (T kx x) (T ky y) Int
   T :: forall k. k -&gt; Type

   work_item: dwrk :: C (T @ka (a::ka)) (T @kb0 (b0::kb0)) Char
      where kb0, b0 are unification vars

   ==&gt; {doTopFunDepImprovement: compare work_item with instance,
        generate /fresh/ unification variables kfresh0, yfresh0,
        emit a new Wanted, and add dwrk to inert set}

   Suppose we emit this new Wanted from the fundep:
       [W] T kb0 (b0::kb0) ~ T kfresh0 (yfresh0::kfresh0)

   ==&gt; {solve that equality kb0 := kfresh0, b0 := yfresh0}
   Now kick out dwrk, since it mentions kb0
   But now we are back to the start!  Loop!

NB1: This example relies on an instance that does not satisfy the
     coverage condition (although it may satisfy the weak coverage
     condition), and hence whose fundeps generate fresh unification
     variables.  Not satisfying the coverage condition is known to
     lead to termination trouble, but in this case it's plain silly.

NB2: In this example, the third parameter to C ensures that the
     instance doesn't actually match the Wanted, so we can't use it to
     solve the Wanted

We solve the problem by (#21703):

    carefully orienting the new Wanted so that all the
    freshly-generated unification variables are on the LHS.

    Thus we call unifyWanteds on
       T kfresh0 (yfresh0::kfresh0) ~ T kb0 (b0::kb0)
    and /NOT/
       T kb0 (b0::kb0) ~ T kfresh0 (yfresh0::kfresh0)

Now we'll unify kfresh0:=kb0, yfresh0:=b0, and all is well.  The general idea
is that we want to preferentially eliminate those freshly-generated
unification variables, rather than unifying older variables, which causes
kick-out etc.

Keeping younger variables on the left also gives very minor improvement in
the compiler performance by having less kick-outs and allocations (-0.1% on
average).  Indeed Historical Note [Eliminate younger unification variables]
in GHC.Tc.Utils.Unify describes an earlier attempt to do so systematically,
apparently now in abeyance.

But this is is a delicate solution. We must take care to /preserve/
orientation during solving. Wrinkles:

(W1) We start with
       [W] T kfresh0 (yfresh0::kfresh0) ~ T kb0 (b0::kb0)
     Decompose to
       [W] kfresh0 ~ kb0
       [W] (yfresh0::kfresh0) ~ (b0::kb0)
     Preserve orientation when decomposing!!

(W2) Suppose we happen to tackle the second Wanted from (W1)
     first. Then in canEqCanLHSHetero we emit a /kind/ equality, as
     well as a now-homogeneous type equality
       [W] kco : kfresh0 ~ kb0
       [W] (yfresh0::kfresh0) ~ (b0::kb0) |&gt; (sym kco)
     Preserve orientation in canEqCanLHSHetero!!  (Failing to
     preserve orientation here was the immediate cause of #21703.)

(W3) There is a potential interaction with the swapping done by
     GHC.Tc.Utils.Unify.swapOverTyVars.  We think it's fine, but it's
     a slight worry.  See especially Note [TyVar/TyVar orientation] in
     that module.

The trouble is that &quot;preserving orientation&quot; is a rather global invariant,
and sometimes we definitely do want to swap (e.g. Int ~ alpha), so we don't
even have a precise statement of what the invariant is.  The advantage
of the preserve-orientation plan is that it is extremely cheap to implement,
and apparently works beautifully.

--- Alternative plan (1) ---
Rather than have an ill-defined invariant, another possiblity is to
elminate those fresh unification variables at birth, when generating
the new fundep-inspired equalities.

The key idea is to call `instFlexiX` in `emitFunDepWanteds` on only those
type variables that are guaranteed to give us some progress. This means we
have to locally (without calling emitWanteds) identify the type variables
that do not give us any progress.  In the above example, we _know_ that
emitting the two wanteds `kco` and `co` is fruitless.

  Q: How do we identify such no-ops?

  1. Generate a matching substitution from LHS to RHS
        &#632; = [kb0 :-&gt; k0, b0 :-&gt;  y0]
  2. Call `instFlexiX` on only those type variables that do not appear in the domain of &#632;
        &#632;' = instFlexiX &#632; (tvs - domain &#632;)
  3. Apply &#632;' on LHS and then call emitWanteds
        unifyWanteds ... (subst &#632;' LHS) RHS

Why will this work?  The matching substitution &#632; will be a best effort
substitution that gives us all the easy solutions. It can be generated with
modified version of `Core/Unify.unify_tys` where we run it in a matching mode
and never generate `SurelyApart` and always return a `MaybeApart Subst`
instead.

The same alternative plan would work for type-family injectivity constraints:
see Note [Improvement orientation] in GHC.Tc.Solver.Equality.
--- End of Alternative plan (1) ---

--- Alternative plan (2) ---
We could have a new flavour of TcTyVar (like `TauTv`, `TyVarTv` etc; see GHC.Tc.Utils.TcType.MetaInfo)
for the fresh unification variables introduced by functional dependencies.  Say `FunDepTv`.  Then in
GHC.Tc.Utils.Unify.swapOverTyVars we could arrange to keep a `FunDepTv` on the left if possible.
Looks possible, but it's one more complication.
--- End of Alternative plan (2) ---


--- Historical note: Failed Alternative Plan (3) ---
Previously we used a flag `cc_fundeps` in `CDictCan`. It would flip to False
once we used a fun dep to hint the solver to break and to stop emitting more
wanteds.  This solution was not complete, and caused a failures while trying
to solve for transitive functional dependencies (test case: T21703)
-- End of Historical note: Failed Alternative Plan (3) --

Note [Do fundeps last]
~~~~~~~~~~~~~~~~~~~~~~
Consider T4254b:
  class FD a b | a -&gt; b where { op :: a -&gt; b }

  instance FD Int Bool

  foo :: forall a b. (a~Int,FD a b) =&gt; a -&gt; Bool
  foo = op

(DFL1) Try local fundeps first.
  From the ambiguity check on the type signature we get
    [G] FD Int b
    [W] FD Int beta
  Interacting these gives beta:=b; then we start again and solve without
  trying fundeps between the new [W] FD Int b and the top-level instance.
  If we did, we'd generate [W] b ~ Bool, which fails.

(DFL2) Try solving from top-level instances before fundeps
  From the definition `foo = op` we get
    [G] FD Int b
    [W] FD Int Bool
  We solve this from the top level instance before even trying fundeps.
  If we did try fundeps, we'd generate [W] b ~ Bool, which fails.


Note [Weird fundeps]
~~~~~~~~~~~~~~~~~~~~
Consider   class Het a b | a -&gt; b where
              het :: m (f c) -&gt; a -&gt; m b

           class GHet (a :: * -&gt; *) (b :: * -&gt; *) | a -&gt; b
           instance            GHet (K a) (K [a])
           instance Het a b =&gt; GHet (K a) (K b)

The two instances don't actually conflict on their fundeps,
although it's pretty strange.  So they are both accepted. Now
try   [W] GHet (K Int) (K Bool)
This triggers fundeps from both instance decls;
      [W] K Bool ~ K [a]
      [W] K Bool ~ K beta
And there's a risk of complaining about Bool ~ [a].  But in fact
the Wanted matches the second instance, so we never get as far
as the fundeps.

#7875 is a case in point.
-}</span></span><span>
</span><span id="line-1632"></span><span>
</span><span id="line-1633"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#doLocalFunDepImprovement"><span class="hs-identifier hs-type">doLocalFunDepImprovement</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#SolverStage"><span class="hs-identifier hs-type">SolverStage</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-1634"></span><span class="hs-comment">-- Add wanted constraints from type-class functional dependencies.</span><span>
</span><span id="line-1635"></span><span id="doLocalFunDepImprovement"><span class="annot"><span class="annottext">doLocalFunDepImprovement :: DictCt -&gt; SolverStage ()
</span><a href="GHC.Tc.Solver.Dict.html#doLocalFunDepImprovement"><span class="hs-identifier hs-var hs-var">doLocalFunDepImprovement</span></a></span></span><span> </span><span id="local-6989586621683042048"><span class="annot"><span class="annottext">dict_ct :: DictCt
</span><a href="#local-6989586621683042048"><span class="hs-identifier hs-var">dict_ct</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">di_ev :: DictCt -&gt; CtEvidence
</span><a href="GHC.Tc.Types.Constraint.html#di_ev"><span class="hs-identifier hs-var">di_ev</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683042049"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042049"><span class="hs-identifier hs-var">work_ev</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">di_cls :: DictCt -&gt; Class
</span><a href="GHC.Tc.Types.Constraint.html#di_cls"><span class="hs-identifier hs-var">di_cls</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683042050"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042050"><span class="hs-identifier hs-var">cls</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-1636"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TcS (StopOrContinue ()) -&gt; SolverStage ()
forall a. TcS (StopOrContinue a) -&gt; SolverStage a
</span><a href="GHC.Tc.Solver.Monad.html#Stage"><span class="hs-identifier hs-var">Stage</span></a></span><span> </span><span class="annot"><span class="annottext">(TcS (StopOrContinue ()) -&gt; SolverStage ())
-&gt; TcS (StopOrContinue ()) -&gt; SolverStage ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-1637"></span><span>    </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span id="local-6989586621683042051"><span class="annot"><a href="#local-6989586621683042051"><span class="hs-identifier hs-var">inerts</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TcS InertCans
</span><a href="GHC.Tc.Solver.Monad.html#getInertCans"><span class="hs-identifier hs-var">getInertCans</span></a></span><span>
</span><span id="line-1638"></span><span>       </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683042052"><span class="annot"><a href="#local-6989586621683042052"><span class="hs-identifier hs-var">imp</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="hs-identifier hs-type">foldlM</span></span><span> </span><span class="annot"><a href="#local-6989586621683042053"><span class="hs-identifier hs-type">add_fds</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">False</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Solver.Types.html#findDictsByClass"><span class="hs-identifier hs-type">findDictsByClass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Solver.InertSet.html#inert_dicts"><span class="hs-identifier hs-var">inert_dicts</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042051"><span class="hs-identifier hs-type">inerts</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621683042050"><span class="hs-identifier hs-type">cls</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1639"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><a href="#local-6989586621683042052"><span class="hs-identifier hs-type">imp</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#startAgainWith"><span class="hs-identifier hs-type">startAgainWith</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CDictCan"><span class="hs-identifier hs-type">CDictCan</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042048"><span class="hs-identifier hs-type">dict_ct</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1640"></span><span>                     </span><span class="hs-keyword">else</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#continueWith"><span class="hs-identifier hs-type">continueWith</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-1641"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1642"></span><span>    </span><span id="local-6989586621683042056"><span class="annot"><span class="annottext">work_pred :: Type
</span><a href="#local-6989586621683042056"><span class="hs-identifier hs-var hs-var">work_pred</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; Type
</span><a href="GHC.Tc.Types.Constraint.html#ctEvPred"><span class="hs-identifier hs-var">ctEvPred</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042049"><span class="hs-identifier hs-var">work_ev</span></a></span><span>
</span><span id="line-1643"></span><span>    </span><span id="local-6989586621683042057"><span class="annot"><span class="annottext">work_loc :: CtLoc
</span><a href="#local-6989586621683042057"><span class="hs-identifier hs-var hs-var">work_loc</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; CtLoc
</span><a href="GHC.Tc.Types.Constraint.html#ctEvLoc"><span class="hs-identifier hs-var">ctEvLoc</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042049"><span class="hs-identifier hs-var">work_ev</span></a></span><span>
</span><span id="line-1644"></span><span>
</span><span id="line-1645"></span><span>    </span><span class="annot"><a href="#local-6989586621683042053"><span class="hs-identifier hs-type">add_fds</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#TcS"><span class="hs-identifier hs-type">TcS</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-1646"></span><span>    </span><span id="local-6989586621683042053"><span class="annot"><span class="annottext">add_fds :: Bool -&gt; DictCt -&gt; TcS Bool
</span><a href="#local-6989586621683042053"><span class="hs-identifier hs-var hs-var">add_fds</span></a></span></span><span> </span><span id="local-6989586621683042058"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621683042058"><span class="hs-identifier hs-var">so_far</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">di_ev :: DictCt -&gt; CtEvidence
</span><a href="GHC.Tc.Types.Constraint.html#di_ev"><span class="hs-identifier hs-var">di_ev</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683042059"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042059"><span class="hs-identifier hs-var">inert_ev</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-1647"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; Bool
</span><a href="GHC.Tc.Types.Constraint.html#isGiven"><span class="hs-identifier hs-var">isGiven</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042049"><span class="hs-identifier hs-var">work_ev</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; Bool
</span><a href="GHC.Tc.Types.Constraint.html#isGiven"><span class="hs-identifier hs-var">isGiven</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042059"><span class="hs-identifier hs-var">inert_ev</span></a></span><span>
</span><span id="line-1648"></span><span>        </span><span class="hs-comment">-- Do not create FDs from Given/Given interactions: See Note [No Given/Given fundeps]</span><span>
</span><span id="line-1649"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; TcS Bool
forall a. a -&gt; TcS a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621683042058"><span class="hs-identifier hs-var">so_far</span></a></span><span>
</span><span id="line-1650"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-1651"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-var">traceTcS</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;doLocalFunDepImprovement&quot;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsDoc doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#vcat"><span class="hs-identifier hs-var">vcat</span></a></span><span>
</span><span id="line-1652"></span><span>                </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042049"><span class="hs-identifier hs-var">work_ev</span></a></span><span>
</span><span id="line-1653"></span><span>                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CtLoc -&gt; SDoc
</span><a href="GHC.Tc.Types.CtLoc.html#pprCtLoc"><span class="hs-identifier hs-var">pprCtLoc</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683042057"><span class="hs-identifier hs-var">work_loc</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtLoc -&gt; Bool
</span><a href="GHC.Tc.Types.CtLoc.html#isGivenLoc"><span class="hs-identifier hs-var">isGivenLoc</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683042057"><span class="hs-identifier hs-var">work_loc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1654"></span><span>                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CtLoc -&gt; SDoc
</span><a href="GHC.Tc.Types.CtLoc.html#pprCtLoc"><span class="hs-identifier hs-var">pprCtLoc</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683042063"><span class="hs-identifier hs-var">inert_loc</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtLoc -&gt; Bool
</span><a href="GHC.Tc.Types.CtLoc.html#isGivenLoc"><span class="hs-identifier hs-var">isGivenLoc</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683042063"><span class="hs-identifier hs-var">inert_loc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1655"></span><span>                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">CtLoc -&gt; SDoc
</span><a href="GHC.Tc.Types.CtLoc.html#pprCtLoc"><span class="hs-identifier hs-var">pprCtLoc</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683042064"><span class="hs-identifier hs-var">derived_loc</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtLoc -&gt; Bool
</span><a href="GHC.Tc.Types.CtLoc.html#isGivenLoc"><span class="hs-identifier hs-var">isGivenLoc</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683042064"><span class="hs-identifier hs-var">derived_loc</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1656"></span><span>
</span><span id="line-1657"></span><span>           </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683042065"><span class="annot"><a href="#local-6989586621683042065"><span class="hs-identifier hs-var">unifs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; [FunDepEqn (CtLoc, RewriterSet)] -&gt; TcS Bool
</span><a href="GHC.Tc.Solver.Monad.html#emitFunDepWanteds"><span class="hs-identifier hs-var">emitFunDepWanteds</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042049"><span class="hs-identifier hs-var">work_ev</span></a></span><span> </span><span class="annot"><span class="annottext">([FunDepEqn (CtLoc, RewriterSet)] -&gt; TcS Bool)
-&gt; [FunDepEqn (CtLoc, RewriterSet)] -&gt; TcS Bool
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-1658"></span><span>                      </span><span class="annot"><span class="annottext">(CtLoc, RewriterSet)
-&gt; Type -&gt; Type -&gt; [FunDepEqn (CtLoc, RewriterSet)]
forall loc. loc -&gt; Type -&gt; Type -&gt; [FunDepEqn loc]
</span><a href="GHC.Tc.Instance.FunDeps.html#improveFromAnother"><span class="hs-identifier hs-var">improveFromAnother</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683042064"><span class="hs-identifier hs-var">derived_loc</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">RewriterSet
</span><a href="#local-6989586621683042067"><span class="hs-identifier hs-var">inert_rewriters</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1659"></span><span>                                         </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042068"><span class="hs-identifier hs-var">inert_pred</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042056"><span class="hs-identifier hs-var">work_pred</span></a></span><span>
</span><span id="line-1660"></span><span>           </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621683042058"><span class="hs-identifier hs-type">so_far</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">||</span></span><span> </span><span class="annot"><a href="#local-6989586621683042065"><span class="hs-identifier hs-type">unifs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1661"></span><span>        </span><span class="hs-special">}</span><span>
</span><span id="line-1662"></span><span>      </span><span class="hs-keyword">where</span><span>
</span><span id="line-1663"></span><span>        </span><span id="local-6989586621683042068"><span class="annot"><span class="annottext">inert_pred :: Type
</span><a href="#local-6989586621683042068"><span class="hs-identifier hs-var hs-var">inert_pred</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; Type
</span><a href="GHC.Tc.Types.Constraint.html#ctEvPred"><span class="hs-identifier hs-var">ctEvPred</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042059"><span class="hs-identifier hs-var">inert_ev</span></a></span><span>
</span><span id="line-1664"></span><span>        </span><span id="local-6989586621683042063"><span class="annot"><span class="annottext">inert_loc :: CtLoc
</span><a href="#local-6989586621683042063"><span class="hs-identifier hs-var hs-var">inert_loc</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; CtLoc
</span><a href="GHC.Tc.Types.Constraint.html#ctEvLoc"><span class="hs-identifier hs-var">ctEvLoc</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042059"><span class="hs-identifier hs-var">inert_ev</span></a></span><span>
</span><span id="line-1665"></span><span>        </span><span id="local-6989586621683042067"><span class="annot"><span class="annottext">inert_rewriters :: RewriterSet
</span><a href="#local-6989586621683042067"><span class="hs-identifier hs-var hs-var">inert_rewriters</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; RewriterSet
</span><a href="GHC.Tc.Types.Constraint.html#ctEvRewriters"><span class="hs-identifier hs-var">ctEvRewriters</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042059"><span class="hs-identifier hs-var">inert_ev</span></a></span><span>
</span><span id="line-1666"></span><span>        </span><span id="local-6989586621683042064"><span class="annot"><span class="annottext">derived_loc :: CtLoc
</span><a href="#local-6989586621683042064"><span class="hs-identifier hs-var hs-var">derived_loc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683042057"><span class="hs-identifier hs-var">work_loc</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><a href="GHC.Tc.Types.CtLoc.html#ctl_depth"><span class="hs-identifier hs-var">ctl_depth</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Tc.Types.CtLoc.html#ctl_depth"><span class="hs-identifier hs-var">ctl_depth</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042057"><span class="hs-identifier hs-type">work_loc</span></a></span><span> </span><span class="annot"><a href="GHC.Tc.Types.CtLoc.html#maxSubGoalDepth"><span class="hs-operator hs-type">`maxSubGoalDepth`</span></a></span><span>
</span><span id="line-1667"></span><span>                                              </span><span class="annot"><a href="GHC.Tc.Types.CtLoc.html#ctl_depth"><span class="hs-identifier hs-var">ctl_depth</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042063"><span class="hs-identifier hs-type">inert_loc</span></a></span><span>
</span><span id="line-1668"></span><span>                               </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Types.CtLoc.html#ctl_origin"><span class="hs-identifier hs-var">ctl_origin</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Origin.html#FunDepOrigin1"><span class="hs-identifier hs-type">FunDepOrigin1</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042056"><span class="hs-identifier hs-type">work_pred</span></a></span><span>
</span><span id="line-1669"></span><span>                                                            </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.CtLoc.html#ctLocOrigin"><span class="hs-identifier hs-type">ctLocOrigin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042057"><span class="hs-identifier hs-type">work_loc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1670"></span><span>                                                            </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.CtLoc.html#ctLocSpan"><span class="hs-identifier hs-type">ctLocSpan</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042057"><span class="hs-identifier hs-type">work_loc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1671"></span><span>                                                            </span><span class="annot"><a href="#local-6989586621683042068"><span class="hs-identifier hs-type">inert_pred</span></a></span><span>
</span><span id="line-1672"></span><span>                                                            </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.CtLoc.html#ctLocOrigin"><span class="hs-identifier hs-type">ctLocOrigin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042063"><span class="hs-identifier hs-type">inert_loc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1673"></span><span>                                                            </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.CtLoc.html#ctLocSpan"><span class="hs-identifier hs-type">ctLocSpan</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042063"><span class="hs-identifier hs-type">inert_loc</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-1674"></span><span>
</span><span id="line-1675"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#doTopFunDepImprovement"><span class="hs-identifier hs-type">doTopFunDepImprovement</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#SolverStage"><span class="hs-identifier hs-type">SolverStage</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-1676"></span><span class="hs-comment">-- Try to functional-dependency improvement between the constraint</span><span>
</span><span id="line-1677"></span><span class="hs-comment">-- and the top-level instance declarations</span><span>
</span><span id="line-1678"></span><span class="hs-comment">-- See Note [Fundeps with instances, and equality orientation]</span><span>
</span><span id="line-1679"></span><span class="hs-comment">-- See also Note [Weird fundeps]</span><span>
</span><span id="line-1680"></span><span id="doTopFunDepImprovement"><span class="annot"><span class="annottext">doTopFunDepImprovement :: DictCt -&gt; SolverStage ()
</span><a href="GHC.Tc.Solver.Dict.html#doTopFunDepImprovement"><span class="hs-identifier hs-var hs-var">doTopFunDepImprovement</span></a></span></span><span> </span><span id="local-6989586621683042073"><span class="annot"><span class="annottext">dict_ct :: DictCt
</span><a href="#local-6989586621683042073"><span class="hs-identifier hs-var">dict_ct</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">di_ev :: DictCt -&gt; CtEvidence
</span><a href="GHC.Tc.Types.Constraint.html#di_ev"><span class="hs-identifier hs-var">di_ev</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683042074"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042074"><span class="hs-identifier hs-var">ev</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">di_cls :: DictCt -&gt; Class
</span><a href="GHC.Tc.Types.Constraint.html#di_cls"><span class="hs-identifier hs-var">di_cls</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683042075"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042075"><span class="hs-identifier hs-var">cls</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">di_tys :: DictCt -&gt; [Type]
</span><a href="GHC.Tc.Types.Constraint.html#di_tys"><span class="hs-identifier hs-var">di_tys</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683042076"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042076"><span class="hs-identifier hs-var">xis</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-1681"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; Bool
</span><a href="GHC.Tc.Types.Constraint.html#isGiven"><span class="hs-identifier hs-var">isGiven</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042074"><span class="hs-identifier hs-var">ev</span></a></span><span>     </span><span class="hs-comment">-- No improvement for Givens</span><span>
</span><span id="line-1682"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TcS (StopOrContinue ()) -&gt; SolverStage ()
forall a. TcS (StopOrContinue a) -&gt; SolverStage a
</span><a href="GHC.Tc.Solver.Monad.html#Stage"><span class="hs-identifier hs-var">Stage</span></a></span><span> </span><span class="annot"><span class="annottext">(TcS (StopOrContinue ()) -&gt; SolverStage ())
-&gt; TcS (StopOrContinue ()) -&gt; SolverStage ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">() -&gt; TcS (StopOrContinue ())
forall a. a -&gt; TcS (StopOrContinue a)
</span><a href="GHC.Tc.Solver.Monad.html#continueWith"><span class="hs-identifier hs-var">continueWith</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-1683"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-1684"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TcS (StopOrContinue ()) -&gt; SolverStage ()
forall a. TcS (StopOrContinue a) -&gt; SolverStage a
</span><a href="GHC.Tc.Solver.Monad.html#Stage"><span class="hs-identifier hs-var">Stage</span></a></span><span> </span><span class="annot"><span class="annottext">(TcS (StopOrContinue ()) -&gt; SolverStage ())
-&gt; TcS (StopOrContinue ()) -&gt; SolverStage ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-1685"></span><span>    </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-var">traceTcS</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;try_fundeps&quot;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DictCt -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">DictCt
</span><a href="#local-6989586621683042073"><span class="hs-identifier hs-var">dict_ct</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1686"></span><span>       </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683042077"><span class="annot"><a href="#local-6989586621683042077"><span class="hs-identifier hs-var">instEnvs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TcS InstEnvs
</span><a href="GHC.Tc.Solver.Monad.html#getInstEnvs"><span class="hs-identifier hs-var">getInstEnvs</span></a></span><span>
</span><span id="line-1687"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621683042079"><span class="annot"><a href="#local-6989586621683042079"><span class="hs-identifier hs-var hs-var">fundep_eqns</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">InstEnvs
-&gt; (ClsInst -&gt; (CtLoc, RewriterSet))
-&gt; Class
-&gt; [Type]
-&gt; [FunDepEqn (CtLoc, RewriterSet)]
forall loc.
InstEnvs -&gt; (ClsInst -&gt; loc) -&gt; Class -&gt; [Type] -&gt; [FunDepEqn loc]
</span><a href="GHC.Tc.Instance.FunDeps.html#improveFromInstEnv"><span class="hs-identifier hs-var">improveFromInstEnv</span></a></span><span> </span><span class="annot"><span class="annottext">InstEnvs
</span><a href="#local-6989586621683042077"><span class="hs-identifier hs-var">instEnvs</span></a></span><span> </span><span class="annot"><span class="annottext">ClsInst -&gt; (CtLoc, RewriterSet)
</span><a href="#local-6989586621683042081"><span class="hs-identifier hs-var">mk_ct_loc</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042075"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042076"><span class="hs-identifier hs-var">xis</span></a></span><span>
</span><span id="line-1688"></span><span>       </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683042082"><span class="annot"><a href="#local-6989586621683042082"><span class="hs-identifier hs-var">imp</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#emitFunDepWanteds"><span class="hs-identifier hs-type">emitFunDepWanteds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042074"><span class="hs-identifier hs-type">ev</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042079"><span class="hs-identifier hs-type">fundep_eqns</span></a></span><span>
</span><span id="line-1689"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><a href="#local-6989586621683042082"><span class="hs-identifier hs-type">imp</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#startAgainWith"><span class="hs-identifier hs-type">startAgainWith</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CDictCan"><span class="hs-identifier hs-type">CDictCan</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042073"><span class="hs-identifier hs-type">dict_ct</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1690"></span><span>                     </span><span class="hs-keyword">else</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#continueWith"><span class="hs-identifier hs-type">continueWith</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-1691"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1692"></span><span>     </span><span id="local-6989586621683042083"><span class="annot"><span class="annottext">dict_pred :: Type
</span><a href="#local-6989586621683042083"><span class="hs-identifier hs-var hs-var">dict_pred</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Class -&gt; [Type] -&gt; Type
</span><a href="GHC.Core.Predicate.html#mkClassPred"><span class="hs-identifier hs-var">mkClassPred</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042075"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042076"><span class="hs-identifier hs-var">xis</span></a></span><span>
</span><span id="line-1693"></span><span>     </span><span id="local-6989586621683042084"><span class="annot"><span class="annottext">dict_loc :: CtLoc
</span><a href="#local-6989586621683042084"><span class="hs-identifier hs-var hs-var">dict_loc</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; CtLoc
</span><a href="GHC.Tc.Types.Constraint.html#ctEvLoc"><span class="hs-identifier hs-var">ctEvLoc</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042074"><span class="hs-identifier hs-var">ev</span></a></span><span>
</span><span id="line-1694"></span><span>     </span><span id="local-6989586621683042085"><span class="annot"><span class="annottext">dict_origin :: CtOrigin
</span><a href="#local-6989586621683042085"><span class="hs-identifier hs-var hs-var">dict_origin</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtLoc -&gt; CtOrigin
</span><a href="GHC.Tc.Types.CtLoc.html#ctLocOrigin"><span class="hs-identifier hs-var">ctLocOrigin</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683042084"><span class="hs-identifier hs-var">dict_loc</span></a></span><span>
</span><span id="line-1695"></span><span>
</span><span id="line-1696"></span><span>     </span><span class="annot"><a href="#local-6989586621683042081"><span class="hs-identifier hs-type">mk_ct_loc</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Core.InstEnv.html#ClsInst"><span class="hs-identifier hs-type">ClsInst</span></a></span><span>   </span><span class="hs-comment">-- The instance decl</span><span>
</span><span id="line-1697"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.CtLoc.html#CtLoc"><span class="hs-identifier hs-type">CtLoc</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#RewriterSet"><span class="hs-identifier hs-type">RewriterSet</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1698"></span><span>     </span><span id="local-6989586621683042081"><span class="annot"><span class="annottext">mk_ct_loc :: ClsInst -&gt; (CtLoc, RewriterSet)
</span><a href="#local-6989586621683042081"><span class="hs-identifier hs-var hs-var">mk_ct_loc</span></a></span></span><span> </span><span id="local-6989586621683042086"><span class="annot"><span class="annottext">ClsInst
</span><a href="#local-6989586621683042086"><span class="hs-identifier hs-var">ispec</span></a></span></span><span>
</span><span id="line-1699"></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683042084"><span class="hs-identifier hs-var">dict_loc</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><a href="GHC.Tc.Types.CtLoc.html#ctl_origin"><span class="hs-identifier hs-var">ctl_origin</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Origin.html#FunDepOrigin2"><span class="hs-identifier hs-type">FunDepOrigin2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042083"><span class="hs-identifier hs-type">dict_pred</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042085"><span class="hs-identifier hs-type">dict_origin</span></a></span><span>
</span><span id="line-1700"></span><span>                                                 </span><span class="annot"><a href="#local-6989586621683042088"><span class="hs-identifier hs-type">inst_pred</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042089"><span class="hs-identifier hs-type">inst_loc</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-1701"></span><span>         </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">RewriterSet
</span><a href="GHC.Tc.Types.Constraint.html#emptyRewriterSet"><span class="hs-identifier hs-var">emptyRewriterSet</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-1702"></span><span>       </span><span class="hs-keyword">where</span><span>
</span><span id="line-1703"></span><span>         </span><span id="local-6989586621683042088"><span class="annot"><span class="annottext">inst_pred :: Type
</span><a href="#local-6989586621683042088"><span class="hs-identifier hs-var hs-var">inst_pred</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Class -&gt; [Type] -&gt; Type
</span><a href="GHC.Core.Predicate.html#mkClassPred"><span class="hs-identifier hs-var">mkClassPred</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042075"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ClsInst -&gt; [Type]
</span><a href="GHC.Core.InstEnv.html#is_tys"><span class="hs-identifier hs-var">is_tys</span></a></span><span> </span><span class="annot"><span class="annottext">ClsInst
</span><a href="#local-6989586621683042086"><span class="hs-identifier hs-var">ispec</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1704"></span><span>         </span><span id="local-6989586621683042089"><span class="annot"><span class="annottext">inst_loc :: SrcSpan
</span><a href="#local-6989586621683042089"><span class="hs-identifier hs-var hs-var">inst_loc</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">EvVar -&gt; SrcSpan
forall a. NamedThing a =&gt; a -&gt; SrcSpan
</span><a href="GHC.Types.Name.html#getSrcSpan"><span class="hs-identifier hs-var">getSrcSpan</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ClsInst -&gt; EvVar
</span><a href="GHC.Core.InstEnv.html#is_dfun"><span class="hs-identifier hs-var">is_dfun</span></a></span><span> </span><span class="annot"><span class="annottext">ClsInst
</span><a href="#local-6989586621683042086"><span class="hs-identifier hs-var">ispec</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1705"></span><span>
</span><span id="line-1706"></span><span>
</span><span id="line-1707"></span><span class="annot"><span class="hs-comment">{- *********************************************************************
*                                                                      *
*                      Superclasses
*                                                                      *
********************************************************************* -}</span></span><span>
</span><span id="line-1712"></span><span>
</span><span id="line-1713"></span><span class="hs-comment">{- Note [The superclass story]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We need to add superclass constraints for two reasons:

* For givens [G], they give us a route to proof.  E.g.
    f :: Ord a =&gt; a -&gt; Bool
    f x = x == x
  We get a Wanted (Eq a), which can only be solved from the superclass
  of the Given (Ord a).

* For wanteds [W], they may give useful
  functional dependencies.  E.g.
     class C a b | a -&gt; b where ...
     class C a b =&gt; D a b where ...
  Now a [W] constraint (D Int beta) has (C Int beta) as a superclass
  and that might tell us about beta, via C's fundeps.  We can get this
  by generating a [W] (C Int beta) constraint. We won't use the evidence,
  but it may lead to unification.

See Note [Why adding superclasses can help].

For these reasons we want to generate superclass constraints for both
Givens and Wanteds. But:

* (Minor) they are often not needed, so generating them aggressively
  is a waste of time.

* (Major) if we want recursive superclasses, there would be an infinite
  number of them.  Here is a real-life example (#10318);

     class (Frac (Frac a) ~ Frac a,
            Fractional (Frac a),
            IntegralDomain (Frac a))
         =&gt; IntegralDomain a where
      type Frac a :: *

  Notice that IntegralDomain has an associated type Frac, and one
  of IntegralDomain's superclasses is another IntegralDomain constraint.

So here's the plan:

1. Eagerly generate superclasses for given (but not wanted)
   constraints; see Note [Eagerly expand given superclasses].
   This is done using mkStrictSuperClasses in canClassNC, when
   we take a non-canonical Given constraint and cannonicalise it.

   However stop if you encounter the same class twice.  That is,
   mkStrictSuperClasses expands eagerly, but has a conservative
   termination condition: see Note [Expanding superclasses] in GHC.Tc.Utils.TcType.

2. Solve the wanteds as usual, but do no further expansion of
   superclasses for canonical CDictCans in solveSimpleGivens or
   solveSimpleWanteds; Note [Danger of adding superclasses during solving]

   However, /do/ continue to eagerly expand superclasses for new /given/
   /non-canonical/ constraints (canClassNC does this).  As #12175
   showed, a type-family application can expand to a class constraint,
   and we want to see its superclasses for just the same reason as
   Note [Eagerly expand given superclasses].

3. If we have any remaining unsolved wanteds
        (see Note [When superclasses help] in GHC.Tc.Types.Constraint)
   try harder: take both the Givens and Wanteds, and expand
   superclasses again.  See the calls to expandSuperClasses in
   GHC.Tc.Solver.simpl_loop and solveWanteds.

   This may succeed in generating (a finite number of) extra Givens,
   and extra Wanteds. Both may help the proof.

3a An important wrinkle: only expand Givens from the current level.
   Two reasons:
      - We only want to expand it once, and that is best done at
        the level it is bound, rather than repeatedly at the leaves
        of the implication tree
      - We may be inside a type where we can't create term-level
        evidence anyway, so we can't superclass-expand, say,
        (a ~ b) to get (a ~# b).  This happened in #15290.

4. Go round to (2) again.  This loop (2,3,4) is implemented
   in GHC.Tc.Solver.simpl_loop.

The cc_pend_sc field in a CDictCan records whether the superclasses of
this constraint have been expanded.  Specifically, in Step 3 we only
expand superclasses for constraints with cc_pend_sc &gt; 0
(i.e. isPendingScDict holds).
See Note [Expanding Recursive Superclasses and ExpansionFuel]

Why do we do this?  Two reasons:

* To avoid repeated work, by repeatedly expanding the superclasses of
  same constraint,

* To terminate the above loop, at least in the -XNoUndecidableSuperClasses
  case.  If there are recursive superclasses we could, in principle,
  expand forever, always encountering new constraints.

When we take a CNonCanonical or CIrredCan, but end up classifying it
as a CDictCan, we set the cc_pend_sc flag to False.

Note [Superclass loops]
~~~~~~~~~~~~~~~~~~~~~~~
Suppose we have
  class C a =&gt; D a
  class D a =&gt; C a

Then, when we expand superclasses, we'll get back to the self-same
predicate, so we have reached a fixpoint in expansion and there is no
point in fruitlessly expanding further.  This case just falls out from
our strategy.  Consider
  f :: C a =&gt; a -&gt; Bool
  f x = x==x
Then canClassNC gets the [G] d1: C a constraint, and eager emits superclasses
G] d2: D a, [G] d3: C a (psc).  (The &quot;psc&quot; means it has its cc_pend_sc has pending
expansion fuel.)
When processing d3 we find a match with d1 in the inert set, and we always
keep the inert item (d1) if possible: see Note [Replacement vs keeping] in
GHC.Tc.Solver.InertSet.  So d3 dies a quick, happy death.

Note [Eagerly expand given superclasses]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In step (1) of Note [The superclass story], why do we eagerly expand
Given superclasses by one layer?  (By &quot;one layer&quot; we mean expand transitively
until you meet the same class again -- the conservative criterion embodied
in expandSuperClasses.  So a &quot;layer&quot; might be a whole stack of superclasses.)
We do this eagerly for Givens mainly because of some very obscure
cases like this:

   instance Bad a =&gt; Eq (T a)

   f :: (Ord (T a)) =&gt; blah
   f x = ....needs Eq (T a), Ord (T a)....

Here if we can't satisfy (Eq (T a)) from the givens we'll use the
instance declaration; but then we are stuck with (Bad a).  Sigh.
This is really a case of non-confluent proofs, but to stop our users
complaining we expand one layer in advance.

See Note [Instance and Given overlap].

We also want to do this if we have

   f :: F (T a) =&gt; blah

where
   type instance F (T a) = Ord (T a)

So we may need to do a little work on the givens to expose the
class that has the superclasses.  That's why the superclass
expansion for Givens happens in canClassNC.

This same scenario happens with quantified constraints, whose superclasses
are also eagerly expanded. Test case: typecheck/should_compile/T16502b
These are handled in canForAllNC, analogously to canClassNC.

Note [Why adding superclasses can help]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Examples of how adding superclasses can help:

    --- Example 1
        class C a b | a -&gt; b
    Suppose we want to solve
         [G] C a b
         [W] C a beta
    Then adding [W] beta~b will let us solve it.

    -- Example 2 (similar but using a type-equality superclass)
        class (F a ~ b) =&gt; C a b
    And try to sllve:
         [G] C a b
         [W] C a beta
    Follow the superclass rules to add
         [G] F a ~ b
         [W] F a ~ beta
    Now we get [W] beta ~ b, and can solve that.

    -- Example (tcfail138)
      class L a b | a -&gt; b
      class (G a, L a b) =&gt; C a b

      instance C a b' =&gt; G (Maybe a)
      instance C a b  =&gt; C (Maybe a) a
      instance L (Maybe a) a

    When solving the superclasses of the (C (Maybe a) a) instance, we get
      [G] C a b, and hence by superclasses, [G] G a, [G] L a b
      [W] G (Maybe a)
    Use the instance decl to get
      [W] C a beta
    Generate its superclass
      [W] L a beta.  Now using fundeps, combine with [G] L a b to get
      [W] beta ~ b
    which is what we want.

Note [Danger of adding superclasses during solving]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Here's a serious, but now out-dated example, from #4497:

   class Num (RealOf t) =&gt; Normed t
   type family RealOf x

Assume the generated wanted constraint is:
   [W] RealOf e ~ e
   [W] Normed e

If we were to be adding the superclasses during simplification we'd get:
   [W] RealOf e ~ e
   [W] Normed e
   [W] RealOf e ~ fuv
   [W] Num fuv
==&gt;
   e := fuv, Num fuv, Normed fuv, RealOf fuv ~ fuv

While looks exactly like our original constraint. If we add the
superclass of (Normed fuv) again we'd loop.  By adding superclasses
definitely only once, during canonicalisation, this situation can't
happen.

Note [Nested quantified constraint superclasses]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider (typecheck/should_compile/T17202)

  class C1 a
  class (forall c. C1 c) =&gt; C2 a
  class (forall b. (b ~ F a) =&gt; C2 a) =&gt; C3 a

Elsewhere in the code, we get a [G] g1 :: C3 a. We expand its superclass
to get [G] g2 :: (forall b. (b ~ F a) =&gt; C2 a). This constraint has a
superclass, as well. But we now must be careful: we cannot just add
(forall c. C1 c) as a Given, because we need to remember g2's context.
That new constraint is Given only when forall b. (b ~ F a) is true.

It's tempting to make the new Given be (forall b. (b ~ F a) =&gt; forall c. C1 c),
but that's problematic, because it's nested, and ForAllPred is not capable
of representing a nested quantified constraint. (We could change ForAllPred
to allow this, but the solution in this Note is much more local and simpler.)

So, we swizzle it around to get (forall b c. (b ~ F a) =&gt; C1 c).

More generally, if we are expanding the superclasses of
  g0 :: forall tvs. theta =&gt; cls tys
and find a superclass constraint
  forall sc_tvs. sc_theta =&gt; sc_inner_pred
we must have a selector
  sel_id :: forall cls_tvs. cls cls_tvs -&gt; forall sc_tvs. sc_theta =&gt; sc_inner_pred
and thus build
  g_sc :: forall tvs sc_tvs. theta =&gt; sc_theta =&gt; sc_inner_pred
  g_sc = /\ tvs. /\ sc_tvs. \ theta_ids. \ sc_theta_ids.
         sel_id tys (g0 tvs theta_ids) sc_tvs sc_theta_ids

Actually, we cheat a bit by eta-reducing: note that sc_theta_ids are both the
last bound variables and the last arguments. This avoids the need to produce
the sc_theta_ids at all. So our final construction is

  g_sc = /\ tvs. /\ sc_tvs. \ theta_ids.
         sel_id tys (g0 tvs theta_ids) sc_tvs

  -}</span><span>
</span><span id="line-1970"></span><span>
</span><span id="line-1971"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#makeSuperClasses"><span class="hs-identifier hs-type">makeSuperClasses</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#Ct"><span class="hs-identifier hs-type">Ct</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#TcS"><span class="hs-identifier hs-type">TcS</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#Ct"><span class="hs-identifier hs-type">Ct</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1972"></span><span class="hs-comment">-- Returns strict superclasses, transitively, see Note [The superclass story]</span><span>
</span><span id="line-1973"></span><span class="hs-comment">-- The loop-breaking here follows Note [Expanding superclasses] in GHC.Tc.Utils.TcType</span><span>
</span><span id="line-1974"></span><span class="hs-comment">-- Specifically, for an incoming (C t) constraint, we return all of (C t)'s</span><span>
</span><span id="line-1975"></span><span class="hs-comment">--    superclasses, up to /and including/ the first repetition of C</span><span>
</span><span id="line-1976"></span><span class="hs-comment">--</span><span>
</span><span id="line-1977"></span><span class="hs-comment">-- Example:  class D a =&gt; C a</span><span>
</span><span id="line-1978"></span><span class="hs-comment">--           class C [a] =&gt; D a</span><span>
</span><span id="line-1979"></span><span class="hs-comment">-- makeSuperClasses (C x) will return (D x, C [x])</span><span>
</span><span id="line-1980"></span><span class="hs-comment">--</span><span>
</span><span id="line-1981"></span><span class="hs-comment">-- NB: the incoming constraint's superclass will consume a unit of fuel</span><span>
</span><span id="line-1982"></span><span class="hs-comment">-- Preconditions on `cts`: 1. They are either `CDictCan` or `CQuantCan`</span><span>
</span><span id="line-1983"></span><span class="hs-comment">--                         2. Their fuel (stored in cc_pend_sc or qci_pend_sc) is &gt; 0</span><span>
</span><span id="line-1984"></span><span id="makeSuperClasses"><span class="annot"><span class="annottext">makeSuperClasses :: [Ct] -&gt; TcS [Ct]
</span><a href="GHC.Tc.Solver.Dict.html#makeSuperClasses"><span class="hs-identifier hs-var hs-var">makeSuperClasses</span></a></span></span><span> </span><span id="local-6989586621683042094"><span class="annot"><span class="annottext">[Ct]
</span><a href="#local-6989586621683042094"><span class="hs-identifier hs-var">cts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Ct -&gt; TcS [Ct]) -&gt; [Ct] -&gt; TcS [Ct]
forall (m :: * -&gt; *) (f :: * -&gt; *) a b.
(Monad m, Traversable f) =&gt;
(a -&gt; m [b]) -&gt; f a -&gt; m [b]
</span><a href="GHC.Utils.Monad.html#concatMapM"><span class="hs-identifier hs-var">concatMapM</span></a></span><span> </span><span class="annot"><span class="annottext">Ct -&gt; TcS [Ct]
</span><a href="#local-6989586621683042095"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">[Ct]
</span><a href="#local-6989586621683042094"><span class="hs-identifier hs-var">cts</span></a></span><span>
</span><span id="line-1985"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1986"></span><span>    </span><span id="local-6989586621683042095"><span class="annot"><span class="annottext">go :: Ct -&gt; TcS [Ct]
</span><a href="#local-6989586621683042095"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CDictCan"><span class="hs-identifier hs-type">CDictCan</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">di_ev :: DictCt -&gt; CtEvidence
</span><a href="GHC.Tc.Types.Constraint.html#di_ev"><span class="hs-identifier hs-var">di_ev</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683042103"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042103"><span class="hs-identifier hs-var">ev</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">di_cls :: DictCt -&gt; Class
</span><a href="GHC.Tc.Types.Constraint.html#di_cls"><span class="hs-identifier hs-var">di_cls</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683042104"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042104"><span class="hs-identifier hs-var">cls</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">di_tys :: DictCt -&gt; [Type]
</span><a href="GHC.Tc.Types.Constraint.html#di_tys"><span class="hs-identifier hs-var">di_tys</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683042105"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042105"><span class="hs-identifier hs-var">tys</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">di_pend_sc :: DictCt -&gt; ScDepth
</span><a href="GHC.Tc.Types.Constraint.html#di_pend_sc"><span class="hs-identifier hs-var">di_pend_sc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683042106"><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042106"><span class="hs-identifier hs-var">fuel</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1987"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ScDepth -&gt; TcS [Ct] -&gt; TcS [Ct]
forall a. ScDepth -&gt; a -&gt; a
</span><a href="GHC.Tc.Types.Constraint.html#assertFuelPreconditionStrict"><span class="hs-identifier hs-var">assertFuelPreconditionStrict</span></a></span><span> </span><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042106"><span class="hs-identifier hs-var">fuel</span></a></span><span> </span><span class="annot"><span class="annottext">(TcS [Ct] -&gt; TcS [Ct]) -&gt; TcS [Ct] -&gt; TcS [Ct]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-comment">-- fuel needs to be more than 0 always</span><span>
</span><span id="line-1988"></span><span>        </span><span class="annot"><span class="annottext">ScDepth
-&gt; CtEvidence -&gt; [EvVar] -&gt; [Type] -&gt; Class -&gt; [Type] -&gt; TcS [Ct]
</span><a href="GHC.Tc.Solver.Dict.html#mkStrictSuperClasses"><span class="hs-identifier hs-var">mkStrictSuperClasses</span></a></span><span> </span><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042106"><span class="hs-identifier hs-var">fuel</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042103"><span class="hs-identifier hs-var">ev</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042104"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042105"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-1989"></span><span>    </span><span class="annot"><a href="#local-6989586621683042095"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CQuantCan"><span class="hs-identifier hs-type">CQuantCan</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#QCI"><span class="hs-identifier hs-type">QCI</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">qci_pred :: QCInst -&gt; Type
</span><a href="GHC.Tc.Types.Constraint.html#qci_pred"><span class="hs-identifier hs-var">qci_pred</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683042109"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042109"><span class="hs-identifier hs-var">pred</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">qci_ev :: QCInst -&gt; CtEvidence
</span><a href="GHC.Tc.Types.Constraint.html#qci_ev"><span class="hs-identifier hs-var">qci_ev</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683042110"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042110"><span class="hs-identifier hs-var">ev</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">qci_pend_sc :: QCInst -&gt; ScDepth
</span><a href="GHC.Tc.Types.Constraint.html#qci_pend_sc"><span class="hs-identifier hs-var">qci_pend_sc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683042112"><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042112"><span class="hs-identifier hs-var">fuel</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1990"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; SDoc -&gt; TcS [Ct] -&gt; TcS [Ct]
forall a. HasCallStack =&gt; Bool -&gt; SDoc -&gt; a -&gt; a
</span><a href="GHC.Utils.Panic.html#assertPpr"><span class="hs-identifier hs-var">assertPpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Bool
</span><a href="GHC.Core.Predicate.html#isClassPred"><span class="hs-identifier hs-var">isClassPred</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042109"><span class="hs-identifier hs-var">pred</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042109"><span class="hs-identifier hs-var">pred</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(TcS [Ct] -&gt; TcS [Ct]) -&gt; TcS [Ct] -&gt; TcS [Ct]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>  </span><span class="hs-comment">-- The cts should all have</span><span>
</span><span id="line-1991"></span><span>                                                   </span><span class="hs-comment">-- class pred heads</span><span>
</span><span id="line-1992"></span><span>        </span><span class="annot"><span class="annottext">ScDepth -&gt; TcS [Ct] -&gt; TcS [Ct]
forall a. ScDepth -&gt; a -&gt; a
</span><a href="GHC.Tc.Types.Constraint.html#assertFuelPreconditionStrict"><span class="hs-identifier hs-var">assertFuelPreconditionStrict</span></a></span><span> </span><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042112"><span class="hs-identifier hs-var">fuel</span></a></span><span> </span><span class="annot"><span class="annottext">(TcS [Ct] -&gt; TcS [Ct]) -&gt; TcS [Ct] -&gt; TcS [Ct]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-comment">-- fuel needs to be more than 0 always</span><span>
</span><span id="line-1993"></span><span>        </span><span class="annot"><span class="annottext">ScDepth
-&gt; CtEvidence -&gt; [EvVar] -&gt; [Type] -&gt; Class -&gt; [Type] -&gt; TcS [Ct]
</span><a href="GHC.Tc.Solver.Dict.html#mkStrictSuperClasses"><span class="hs-identifier hs-var">mkStrictSuperClasses</span></a></span><span> </span><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042112"><span class="hs-identifier hs-var">fuel</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042110"><span class="hs-identifier hs-var">ev</span></a></span><span> </span><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042114"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042115"><span class="hs-identifier hs-var">theta</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042116"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042117"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-1994"></span><span>      </span><span class="hs-keyword">where</span><span>
</span><span id="line-1995"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621683042114"><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042114"><span class="hs-identifier hs-var">tvs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621683042115"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042115"><span class="hs-identifier hs-var">theta</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621683042116"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042116"><span class="hs-identifier hs-var">cls</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621683042117"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042117"><span class="hs-identifier hs-var">tys</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; ([EvVar], [Type], Class, [Type])
</span><a href="GHC.Tc.Utils.TcType.html#tcSplitDFunTy"><span class="hs-identifier hs-var">tcSplitDFunTy</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtEvidence -&gt; Type
</span><a href="GHC.Tc.Types.Constraint.html#ctEvPred"><span class="hs-identifier hs-var">ctEvPred</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042110"><span class="hs-identifier hs-var">ev</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1996"></span><span>    </span><span class="annot"><a href="#local-6989586621683042095"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621683042119"><span class="annot"><span class="annottext">Ct
</span><a href="#local-6989586621683042119"><span class="hs-identifier hs-var">ct</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS [Ct]
forall a. HasCallStack =&gt; String -&gt; SDoc -&gt; a
</span><a href="GHC.Utils.Panic.html#pprPanic"><span class="hs-identifier hs-var">pprPanic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;makeSuperClasses&quot;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Ct -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">Ct
</span><a href="#local-6989586621683042119"><span class="hs-identifier hs-var">ct</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1997"></span><span>
</span><span id="line-1998"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#mkStrictSuperClasses"><span class="hs-identifier hs-type">mkStrictSuperClasses</span></a></span><span>
</span><span id="line-1999"></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#ExpansionFuel"><span class="hs-identifier hs-type">ExpansionFuel</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CtEvidence"><span class="hs-identifier hs-type">CtEvidence</span></a></span><span>
</span><span id="line-2000"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Var.html#TyVar"><span class="hs-identifier hs-type">TyVar</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#ThetaType"><span class="hs-identifier hs-type">ThetaType</span></a></span><span>  </span><span class="hs-comment">-- These two args are non-empty only when taking</span><span>
</span><span id="line-2001"></span><span>                             </span><span class="hs-comment">-- superclasses of a /quantified/ constraint</span><span>
</span><span id="line-2002"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.Class.html#Class"><span class="hs-identifier hs-type">Class</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#TcS"><span class="hs-identifier hs-type">TcS</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#Ct"><span class="hs-identifier hs-type">Ct</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2003"></span><span class="hs-comment">-- Return constraints for the strict superclasses of</span><span>
</span><span id="line-2004"></span><span class="hs-comment">--   ev :: forall as. theta =&gt; cls tys</span><span>
</span><span id="line-2005"></span><span class="hs-comment">-- Precondition: fuel &gt; 0</span><span>
</span><span id="line-2006"></span><span class="hs-comment">-- Postcondition: fuel for recursive superclass ct is one unit less than cls fuel</span><span>
</span><span id="line-2007"></span><span id="mkStrictSuperClasses"><span class="annot"><span class="annottext">mkStrictSuperClasses :: ScDepth
-&gt; CtEvidence -&gt; [EvVar] -&gt; [Type] -&gt; Class -&gt; [Type] -&gt; TcS [Ct]
</span><a href="GHC.Tc.Solver.Dict.html#mkStrictSuperClasses"><span class="hs-identifier hs-var hs-var">mkStrictSuperClasses</span></a></span></span><span> </span><span id="local-6989586621683042123"><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042123"><span class="hs-identifier hs-var">fuel</span></a></span></span><span> </span><span id="local-6989586621683042124"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042124"><span class="hs-identifier hs-var">ev</span></a></span></span><span> </span><span id="local-6989586621683042125"><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042125"><span class="hs-identifier hs-var">tvs</span></a></span></span><span> </span><span id="local-6989586621683042126"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042126"><span class="hs-identifier hs-var">theta</span></a></span></span><span> </span><span id="local-6989586621683042127"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042127"><span class="hs-identifier hs-var">cls</span></a></span></span><span> </span><span id="local-6989586621683042128"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042128"><span class="hs-identifier hs-var">tys</span></a></span></span><span>
</span><span id="line-2008"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ScDepth
-&gt; NameSet
-&gt; CtEvidence
-&gt; [EvVar]
-&gt; [Type]
-&gt; Class
-&gt; [Type]
-&gt; TcS [Ct]
</span><a href="GHC.Tc.Solver.Dict.html#mk_strict_superclasses"><span class="hs-identifier hs-var">mk_strict_superclasses</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ScDepth -&gt; ScDepth
</span><a href="GHC.Tc.Types.Constraint.html#consumeFuel"><span class="hs-identifier hs-var">consumeFuel</span></a></span><span> </span><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042123"><span class="hs-identifier hs-var">fuel</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; NameSet
</span><a href="GHC.Types.Name.Set.html#unitNameSet"><span class="hs-identifier hs-var">unitNameSet</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Class -&gt; Name
</span><a href="GHC.Core.Class.html#className"><span class="hs-identifier hs-var">className</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042127"><span class="hs-identifier hs-var">cls</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-2009"></span><span>                           </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042124"><span class="hs-identifier hs-var">ev</span></a></span><span> </span><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042125"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042126"><span class="hs-identifier hs-var">theta</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042127"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042128"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-2010"></span><span>
</span><span id="line-2011"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#mk_strict_superclasses"><span class="hs-identifier hs-type">mk_strict_superclasses</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#ExpansionFuel"><span class="hs-identifier hs-type">ExpansionFuel</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Types.Name.Set.html#NameSet"><span class="hs-identifier hs-type">NameSet</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CtEvidence"><span class="hs-identifier hs-type">CtEvidence</span></a></span><span>
</span><span id="line-2012"></span><span>                       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Var.html#TyVar"><span class="hs-identifier hs-type">TyVar</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#ThetaType"><span class="hs-identifier hs-type">ThetaType</span></a></span><span>
</span><span id="line-2013"></span><span>                       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.Class.html#Class"><span class="hs-identifier hs-type">Class</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#TcS"><span class="hs-identifier hs-type">TcS</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#Ct"><span class="hs-identifier hs-type">Ct</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2014"></span><span class="hs-comment">-- Always return the immediate superclasses of (cls tys);</span><span>
</span><span id="line-2015"></span><span class="hs-comment">-- and expand their superclasses, provided none of them are in rec_clss</span><span>
</span><span id="line-2016"></span><span class="hs-comment">-- nor are repeated</span><span>
</span><span id="line-2017"></span><span class="hs-comment">-- The caller of this function is supposed to perform fuel book keeping</span><span>
</span><span id="line-2018"></span><span class="hs-comment">-- Precondition: fuel &gt;= 0</span><span>
</span><span id="line-2019"></span><span id="mk_strict_superclasses"><span class="annot"><span class="annottext">mk_strict_superclasses :: ScDepth
-&gt; NameSet
-&gt; CtEvidence
-&gt; [EvVar]
-&gt; [Type]
-&gt; Class
-&gt; [Type]
-&gt; TcS [Ct]
</span><a href="GHC.Tc.Solver.Dict.html#mk_strict_superclasses"><span class="hs-identifier hs-var hs-var">mk_strict_superclasses</span></a></span></span><span> </span><span class="annot"><span class="annottext">ScDepth
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">NameSet
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[EvVar]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621683042133"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042133"><span class="hs-identifier hs-var">cls</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><span class="hs-identifier">_</span></span><span>
</span><span id="line-2020"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Class -&gt; Bool
</span><a href="GHC.Core.Predicate.html#isEqualityClass"><span class="hs-identifier hs-var">isEqualityClass</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042133"><span class="hs-identifier hs-var">cls</span></a></span><span>
</span><span id="line-2021"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Ct] -&gt; TcS [Ct]
forall a. a -&gt; TcS a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-2022"></span><span>
</span><span id="line-2023"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#mk_strict_superclasses"><span class="hs-identifier hs-var">mk_strict_superclasses</span></a></span><span> </span><span id="local-6989586621683042134"><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042134"><span class="hs-identifier hs-var">fuel</span></a></span></span><span> </span><span id="local-6989586621683042135"><span class="annot"><span class="annottext">NameSet
</span><a href="#local-6989586621683042135"><span class="hs-identifier hs-var">rec_clss</span></a></span></span><span>
</span><span id="line-2024"></span><span>                       </span><span id="local-6989586621683042136"><span class="annot"><span class="annottext">ev :: CtEvidence
</span><a href="#local-6989586621683042136"><span class="hs-identifier hs-var">ev</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CtGiven"><span class="hs-identifier hs-type">CtGiven</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">ctev_evar :: CtEvidence -&gt; EvVar
</span><a href="GHC.Tc.Types.Constraint.html#ctev_evar"><span class="hs-identifier hs-var">ctev_evar</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683042137"><span class="annot"><span class="annottext">EvVar
</span><a href="#local-6989586621683042137"><span class="hs-identifier hs-var">evar</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ctev_loc :: CtEvidence -&gt; CtLoc
</span><a href="GHC.Tc.Types.Constraint.html#ctev_loc"><span class="hs-identifier hs-var">ctev_loc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621683042138"><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683042138"><span class="hs-identifier hs-var">loc</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-2025"></span><span>                       </span><span id="local-6989586621683042139"><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042139"><span class="hs-identifier hs-var">tvs</span></a></span></span><span> </span><span id="local-6989586621683042140"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042140"><span class="hs-identifier hs-var">theta</span></a></span></span><span> </span><span id="local-6989586621683042141"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042141"><span class="hs-identifier hs-var">cls</span></a></span></span><span> </span><span id="local-6989586621683042142"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042142"><span class="hs-identifier hs-var">tys</span></a></span></span><span>
</span><span id="line-2026"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- Given case</span><span>
</span><span id="line-2027"></span><span>    </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-var">traceTcS</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;mk_strict&quot;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtEvidence -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042136"><span class="hs-identifier hs-var">ev</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsDoc doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%24%24"><span class="hs-operator hs-var">$$</span></a></span><span> </span><span class="annot"><span class="annottext">CtOrigin -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtLoc -&gt; CtOrigin
</span><a href="GHC.Tc.Types.CtLoc.html#ctLocOrigin"><span class="hs-identifier hs-var">ctLocOrigin</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683042138"><span class="hs-identifier hs-var">loc</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-2028"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">(EvVar -&gt; TcS [Ct]) -&gt; [EvVar] -&gt; TcS [Ct]
forall (m :: * -&gt; *) (f :: * -&gt; *) a b.
(Monad m, Traversable f) =&gt;
(a -&gt; m [b]) -&gt; f a -&gt; m [b]
</span><a href="GHC.Utils.Monad.html#concatMapM"><span class="hs-identifier hs-var">concatMapM</span></a></span><span> </span><span class="annot"><span class="annottext">EvVar -&gt; TcS [Ct]
</span><a href="#local-6989586621683042143"><span class="hs-identifier hs-var">do_one_given</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Class -&gt; [EvVar]
</span><a href="GHC.Core.Class.html#classSCSelIds"><span class="hs-identifier hs-var">classSCSelIds</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042141"><span class="hs-identifier hs-var">cls</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-2029"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-2030"></span><span>    </span><span id="local-6989586621683042144"><span class="annot"><span class="annottext">dict_ids :: [EvVar]
</span><a href="#local-6989586621683042144"><span class="hs-identifier hs-var hs-var">dict_ids</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [EvVar]
</span><a href="GHC.Types.Id.html#mkTemplateLocals"><span class="hs-identifier hs-var">mkTemplateLocals</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042140"><span class="hs-identifier hs-var">theta</span></a></span><span>
</span><span id="line-2031"></span><span>    </span><span id="local-6989586621683042145"><span class="annot"><span class="annottext">this_size :: PatersonSize
</span><a href="#local-6989586621683042145"><span class="hs-identifier hs-var hs-var">this_size</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Class -&gt; [Type] -&gt; PatersonSize
</span><a href="GHC.Tc.Utils.TcType.html#pSizeClassPred"><span class="hs-identifier hs-var">pSizeClassPred</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042141"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042142"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-2032"></span><span>
</span><span id="line-2033"></span><span>    </span><span id="local-6989586621683042143"><span class="annot"><span class="annottext">do_one_given :: EvVar -&gt; TcS [Ct]
</span><a href="#local-6989586621683042143"><span class="hs-identifier hs-var hs-var">do_one_given</span></a></span></span><span> </span><span id="local-6989586621683042147"><span class="annot"><span class="annottext">EvVar
</span><a href="#local-6989586621683042147"><span class="hs-identifier hs-var">sel_id</span></a></span></span><span>
</span><span id="line-2034"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">HasDebugCallStack =&gt; Type -&gt; Bool
Type -&gt; Bool
</span><a href="GHC.Core.Type.html#isUnliftedType"><span class="hs-identifier hs-var">isUnliftedType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042149"><span class="hs-identifier hs-var">sc_pred</span></a></span><span>
</span><span id="line-2035"></span><span>         </span><span class="hs-comment">-- NB: class superclasses are never representation-polymorphic,</span><span>
</span><span id="line-2036"></span><span>         </span><span class="hs-comment">-- so isUnliftedType is OK here.</span><span>
</span><span id="line-2037"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[EvVar] -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042139"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042140"><span class="hs-identifier hs-var">theta</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2038"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- See Note [Equality superclasses in quantified constraints]</span><span>
</span><span id="line-2039"></span><span>        </span><span class="annot"><span class="annottext">[Ct] -&gt; TcS [Ct]
forall a. a -&gt; TcS a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-2040"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-2041"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span id="local-6989586621683042151"><span class="annot"><a href="#local-6989586621683042151"><span class="hs-identifier hs-var">given_ev</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">CtLoc -&gt; (Type, EvTerm) -&gt; TcS CtEvidence
</span><a href="GHC.Tc.Solver.Monad.html#newGivenEvVar"><span class="hs-identifier hs-var">newGivenEvVar</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683042152"><span class="hs-identifier hs-var">sc_loc</span></a></span><span> </span><span class="annot"><span class="annottext">((Type, EvTerm) -&gt; TcS CtEvidence)
-&gt; (Type, EvTerm) -&gt; TcS CtEvidence
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-2042"></span><span>                         </span><span class="annot"><span class="annottext">EvVar -&gt; Type -&gt; (Type, EvTerm)
</span><a href="#local-6989586621683042153"><span class="hs-identifier hs-var">mk_given_desc</span></a></span><span> </span><span class="annot"><span class="annottext">EvVar
</span><a href="#local-6989586621683042147"><span class="hs-identifier hs-var">sel_id</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042149"><span class="hs-identifier hs-var">sc_pred</span></a></span><span>
</span><span id="line-2043"></span><span>           </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#assertFuelPrecondition"><span class="hs-identifier hs-type">assertFuelPrecondition</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042134"><span class="hs-identifier hs-type">fuel</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span>
</span><span id="line-2044"></span><span>             </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#mk_superclasses"><span class="hs-identifier hs-type">mk_superclasses</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042134"><span class="hs-identifier hs-type">fuel</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042135"><span class="hs-identifier hs-type">rec_clss</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042151"><span class="hs-identifier hs-type">given_ev</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042139"><span class="hs-identifier hs-type">tvs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042140"><span class="hs-identifier hs-type">theta</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042149"><span class="hs-identifier hs-type">sc_pred</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-2045"></span><span>      </span><span class="hs-keyword">where</span><span>
</span><span id="line-2046"></span><span>        </span><span id="local-6989586621683042149"><span class="annot"><span class="annottext">sc_pred :: Type
</span><a href="#local-6989586621683042149"><span class="hs-identifier hs-var hs-var">sc_pred</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">EvVar -&gt; [Type] -&gt; Type
</span><a href="GHC.Core.Predicate.html#classMethodInstTy"><span class="hs-identifier hs-var">classMethodInstTy</span></a></span><span> </span><span class="annot"><span class="annottext">EvVar
</span><a href="#local-6989586621683042147"><span class="hs-identifier hs-var">sel_id</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042142"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-2047"></span><span>
</span><span id="line-2048"></span><span>      </span><span class="hs-comment">-- See Note [Nested quantified constraint superclasses]</span><span>
</span><span id="line-2049"></span><span>    </span><span class="annot"><a href="#local-6989586621683042153"><span class="hs-identifier hs-type">mk_given_desc</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.Var.html#Id"><span class="hs-identifier hs-type">Id</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#PredType"><span class="hs-identifier hs-type">PredType</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#PredType"><span class="hs-identifier hs-type">PredType</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html#EvTerm"><span class="hs-identifier hs-type">EvTerm</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2050"></span><span>    </span><span id="local-6989586621683042153"><span class="annot"><span class="annottext">mk_given_desc :: EvVar -&gt; Type -&gt; (Type, EvTerm)
</span><a href="#local-6989586621683042153"><span class="hs-identifier hs-var hs-var">mk_given_desc</span></a></span></span><span> </span><span id="local-6989586621683042158"><span class="annot"><span class="annottext">EvVar
</span><a href="#local-6989586621683042158"><span class="hs-identifier hs-var">sel_id</span></a></span></span><span> </span><span id="local-6989586621683042159"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042159"><span class="hs-identifier hs-var">sc_pred</span></a></span></span><span>
</span><span id="line-2051"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042160"><span class="hs-identifier hs-var">swizzled_pred</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">EvTerm
</span><a href="#local-6989586621683042161"><span class="hs-identifier hs-var">swizzled_evterm</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2052"></span><span>      </span><span class="hs-keyword">where</span><span>
</span><span id="line-2053"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621683042162"><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042162"><span class="hs-identifier hs-var">sc_tvs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621683042163"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042163"><span class="hs-identifier hs-var">sc_rho</span></a></span></span><span class="hs-special">)</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; ([EvVar], Type)
</span><a href="GHC.Core.Type.html#splitForAllTyCoVars"><span class="hs-identifier hs-var">splitForAllTyCoVars</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042159"><span class="hs-identifier hs-var">sc_pred</span></a></span><span>
</span><span id="line-2054"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621683042165"><span class="annot"><span class="annottext">[Scaled Type]
</span><a href="#local-6989586621683042165"><span class="hs-identifier hs-var">sc_theta</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621683042166"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042166"><span class="hs-identifier hs-var">sc_inner_pred</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; ([Scaled Type], Type)
</span><a href="GHC.Core.Type.html#splitFunTys"><span class="hs-identifier hs-var">splitFunTys</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042163"><span class="hs-identifier hs-var">sc_rho</span></a></span><span>
</span><span id="line-2055"></span><span>
</span><span id="line-2056"></span><span>        </span><span id="local-6989586621683042168"><span class="annot"><span class="annottext">all_tvs :: [EvVar]
</span><a href="#local-6989586621683042168"><span class="hs-identifier hs-var hs-var">all_tvs</span></a></span></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042139"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="annot"><span class="annottext">[EvVar] -&gt; [EvVar] -&gt; [EvVar]
forall a. [a] -&gt; [a] -&gt; [a]
</span><a href="GHC.Utils.Misc.html#chkAppend"><span class="hs-operator hs-var">`chkAppend`</span></a></span><span> </span><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042162"><span class="hs-identifier hs-var">sc_tvs</span></a></span><span>
</span><span id="line-2057"></span><span>        </span><span id="local-6989586621683042170"><span class="annot"><span class="annottext">all_theta :: [Type]
</span><a href="#local-6989586621683042170"><span class="hs-identifier hs-var hs-var">all_theta</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042140"><span class="hs-identifier hs-var">theta</span></a></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Type] -&gt; [Type]
forall a. [a] -&gt; [a] -&gt; [a]
</span><a href="GHC.Utils.Misc.html#chkAppend"><span class="hs-operator hs-var">`chkAppend`</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Scaled Type -&gt; Type) -&gt; [Scaled Type] -&gt; [Type]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Scaled Type -&gt; Type
forall a. Scaled a -&gt; a
</span><a href="GHC.Core.TyCo.Rep.html#scaledThing"><span class="hs-identifier hs-var">scaledThing</span></a></span><span> </span><span class="annot"><span class="annottext">[Scaled Type]
</span><a href="#local-6989586621683042165"><span class="hs-identifier hs-var">sc_theta</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2058"></span><span>        </span><span id="local-6989586621683042160"><span class="annot"><span class="annottext">swizzled_pred :: Type
</span><a href="#local-6989586621683042160"><span class="hs-identifier hs-var hs-var">swizzled_pred</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[EvVar] -&gt; [Type] -&gt; Type -&gt; Type
HasDebugCallStack =&gt; [EvVar] -&gt; [Type] -&gt; Type -&gt; Type
</span><a href="GHC.Tc.Utils.TcType.html#mkInfSigmaTy"><span class="hs-identifier hs-var">mkInfSigmaTy</span></a></span><span> </span><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042168"><span class="hs-identifier hs-var">all_tvs</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042170"><span class="hs-identifier hs-var">all_theta</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042166"><span class="hs-identifier hs-var">sc_inner_pred</span></a></span><span>
</span><span id="line-2059"></span><span>
</span><span id="line-2060"></span><span>        </span><span class="hs-comment">-- evar :: forall tvs. theta =&gt; cls tys</span><span>
</span><span id="line-2061"></span><span>        </span><span class="hs-comment">-- sel_id :: forall cls_tvs. cls cls_tvs</span><span>
</span><span id="line-2062"></span><span>        </span><span class="hs-comment">--                        -&gt; forall sc_tvs. sc_theta =&gt; sc_inner_pred</span><span>
</span><span id="line-2063"></span><span>        </span><span class="hs-comment">-- swizzled_evterm :: forall tvs sc_tvs. theta =&gt; sc_theta =&gt; sc_inner_pred</span><span>
</span><span id="line-2064"></span><span>        </span><span id="local-6989586621683042161"><span class="annot"><span class="annottext">swizzled_evterm :: EvTerm
</span><a href="#local-6989586621683042161"><span class="hs-identifier hs-var hs-var">swizzled_evterm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">EvExpr -&gt; EvTerm
</span><a href="GHC.Tc.Types.Evidence.html#EvExpr"><span class="hs-identifier hs-var">EvExpr</span></a></span><span> </span><span class="annot"><span class="annottext">(EvExpr -&gt; EvTerm) -&gt; EvExpr -&gt; EvTerm
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-2065"></span><span>          </span><span class="annot"><span class="annottext">[EvVar] -&gt; EvExpr -&gt; EvExpr
forall b. [b] -&gt; Expr b -&gt; Expr b
</span><a href="GHC.Core.html#mkLams"><span class="hs-identifier hs-var">mkLams</span></a></span><span> </span><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042168"><span class="hs-identifier hs-var">all_tvs</span></a></span><span> </span><span class="annot"><span class="annottext">(EvExpr -&gt; EvExpr) -&gt; EvExpr -&gt; EvExpr
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-2066"></span><span>          </span><span class="annot"><span class="annottext">[EvVar] -&gt; EvExpr -&gt; EvExpr
forall b. [b] -&gt; Expr b -&gt; Expr b
</span><a href="GHC.Core.html#mkLams"><span class="hs-identifier hs-var">mkLams</span></a></span><span> </span><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042144"><span class="hs-identifier hs-var">dict_ids</span></a></span><span> </span><span class="annot"><span class="annottext">(EvExpr -&gt; EvExpr) -&gt; EvExpr -&gt; EvExpr
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-2067"></span><span>          </span><span class="annot"><span class="annottext">EvVar -&gt; EvExpr
forall b. EvVar -&gt; Expr b
</span><a href="GHC.Core.html#Var"><span class="hs-identifier hs-var">Var</span></a></span><span> </span><span class="annot"><span class="annottext">EvVar
</span><a href="#local-6989586621683042158"><span class="hs-identifier hs-var">sel_id</span></a></span><span>
</span><span id="line-2068"></span><span>            </span><span class="annot"><span class="annottext">EvExpr -&gt; [Type] -&gt; EvExpr
forall b. Expr b -&gt; [Type] -&gt; Expr b
</span><a href="GHC.Core.html#mkTyApps"><span class="hs-operator hs-var">`mkTyApps`</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042142"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-2069"></span><span>            </span><span class="annot"><span class="annottext">EvExpr -&gt; EvExpr -&gt; EvExpr
forall b. Expr b -&gt; Expr b -&gt; Expr b
</span><a href="GHC.Core.html#App"><span class="hs-operator hs-var">`App`</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">EvVar -&gt; EvExpr
</span><a href="GHC.Tc.Types.Evidence.html#evId"><span class="hs-identifier hs-var">evId</span></a></span><span> </span><span class="annot"><span class="annottext">EvVar
</span><a href="#local-6989586621683042137"><span class="hs-identifier hs-var">evar</span></a></span><span> </span><span class="annot"><span class="annottext">EvExpr -&gt; [EvVar] -&gt; EvExpr
forall b. Expr b -&gt; [EvVar] -&gt; Expr b
</span><a href="GHC.Core.html#mkVarApps"><span class="hs-operator hs-var">`mkVarApps`</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042139"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="annot"><span class="annottext">[EvVar] -&gt; [EvVar] -&gt; [EvVar]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042144"><span class="hs-identifier hs-var">dict_ids</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-2070"></span><span>            </span><span class="annot"><span class="annottext">EvExpr -&gt; [EvVar] -&gt; EvExpr
forall b. Expr b -&gt; [EvVar] -&gt; Expr b
</span><a href="GHC.Core.html#mkVarApps"><span class="hs-operator hs-var">`mkVarApps`</span></a></span><span> </span><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042162"><span class="hs-identifier hs-var">sc_tvs</span></a></span><span>
</span><span id="line-2071"></span><span>
</span><span id="line-2072"></span><span>    </span><span id="local-6989586621683042152"><span class="annot"><span class="annottext">sc_loc :: CtLoc
</span><a href="#local-6989586621683042152"><span class="hs-identifier hs-var hs-var">sc_loc</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Class -&gt; Bool
</span><a href="GHC.Core.Predicate.html#isCTupleClass"><span class="hs-identifier hs-var">isCTupleClass</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042141"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683042138"><span class="hs-identifier hs-var">loc</span></a></span><span>
</span><span id="line-2073"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683042138"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><a href="GHC.Tc.Types.CtLoc.html#ctl_origin"><span class="hs-identifier hs-var">ctl_origin</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621683042174"><span class="hs-identifier hs-type">mk_sc_origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.CtLoc.html#ctLocOrigin"><span class="hs-identifier hs-type">ctLocOrigin</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042138"><span class="hs-identifier hs-type">loc</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-2074"></span><span>           </span><span class="hs-comment">-- isCTupleClass: we don't want tuples to mess up the size calculations</span><span>
</span><span id="line-2075"></span><span>           </span><span class="hs-comment">-- of Note [Solving superclass constraints]. For tuple predicates, this</span><span>
</span><span id="line-2076"></span><span>           </span><span class="hs-comment">-- matters, because their size can be large, and we don't want to add a</span><span>
</span><span id="line-2077"></span><span>           </span><span class="hs-comment">-- big class to the size of the dictionaries in the chain. When we get</span><span>
</span><span id="line-2078"></span><span>           </span><span class="hs-comment">-- down to a base predicate, we'll include its size. See #10335.</span><span>
</span><span id="line-2079"></span><span>           </span><span class="hs-comment">-- See Note [Solving tuple constraints]</span><span>
</span><span id="line-2080"></span><span>
</span><span id="line-2081"></span><span>    </span><span class="hs-comment">-- See Note [Solving superclass constraints] in GHC.Tc.TyCl.Instance</span><span>
</span><span id="line-2082"></span><span>    </span><span class="hs-comment">-- for explanation of GivenSCOrigin and Note [Replacement vs keeping] in</span><span>
</span><span id="line-2083"></span><span>    </span><span class="hs-comment">-- GHC.Tc.Solver.InertSet for why we need depths</span><span>
</span><span id="line-2084"></span><span>    </span><span class="annot"><a href="#local-6989586621683042174"><span class="hs-identifier hs-type">mk_sc_origin</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Origin.html#CtOrigin"><span class="hs-identifier hs-type">CtOrigin</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Origin.html#CtOrigin"><span class="hs-identifier hs-type">CtOrigin</span></a></span><span>
</span><span id="line-2085"></span><span>    </span><span id="local-6989586621683042174"><span class="annot"><span class="annottext">mk_sc_origin :: CtOrigin -&gt; CtOrigin
</span><a href="#local-6989586621683042174"><span class="hs-identifier hs-var hs-var">mk_sc_origin</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Origin.html#GivenSCOrigin"><span class="hs-identifier hs-type">GivenSCOrigin</span></a></span><span> </span><span id="local-6989586621683042176"><span class="annot"><span class="annottext">SkolemInfoAnon
</span><a href="#local-6989586621683042176"><span class="hs-identifier hs-var">skol_info</span></a></span></span><span> </span><span id="local-6989586621683042177"><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042177"><span class="hs-identifier hs-var">sc_depth</span></a></span></span><span> </span><span id="local-6989586621683042178"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621683042178"><span class="hs-identifier hs-var">already_blocked</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-2086"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SkolemInfoAnon -&gt; ScDepth -&gt; Bool -&gt; CtOrigin
</span><a href="GHC.Tc.Types.Origin.html#GivenSCOrigin"><span class="hs-identifier hs-var">GivenSCOrigin</span></a></span><span> </span><span class="annot"><span class="annottext">SkolemInfoAnon
</span><a href="#local-6989586621683042176"><span class="hs-identifier hs-var">skol_info</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042177"><span class="hs-identifier hs-var">sc_depth</span></a></span><span> </span><span class="annot"><span class="annottext">ScDepth -&gt; ScDepth -&gt; ScDepth
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">ScDepth
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span>
</span><span id="line-2087"></span><span>                      </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621683042178"><span class="hs-identifier hs-var">already_blocked</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">SkolemInfoAnon -&gt; Bool
</span><a href="#local-6989586621683042180"><span class="hs-identifier hs-var">newly_blocked</span></a></span><span> </span><span class="annot"><span class="annottext">SkolemInfoAnon
</span><a href="#local-6989586621683042176"><span class="hs-identifier hs-var">skol_info</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2088"></span><span>
</span><span id="line-2089"></span><span>    </span><span class="annot"><a href="#local-6989586621683042174"><span class="hs-identifier hs-var">mk_sc_origin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Origin.html#GivenOrigin"><span class="hs-identifier hs-type">GivenOrigin</span></a></span><span> </span><span id="local-6989586621683042182"><span class="annot"><span class="annottext">SkolemInfoAnon
</span><a href="#local-6989586621683042182"><span class="hs-identifier hs-var">skol_info</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-2090"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- These cases do not already have a superclass constraint: depth starts at 1</span><span>
</span><span id="line-2091"></span><span>        </span><span class="annot"><span class="annottext">SkolemInfoAnon -&gt; ScDepth -&gt; Bool -&gt; CtOrigin
</span><a href="GHC.Tc.Types.Origin.html#GivenSCOrigin"><span class="hs-identifier hs-var">GivenSCOrigin</span></a></span><span> </span><span class="annot"><span class="annottext">SkolemInfoAnon
</span><a href="#local-6989586621683042182"><span class="hs-identifier hs-var">skol_info</span></a></span><span> </span><span class="annot"><span class="annottext">ScDepth
</span><span class="hs-number">1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SkolemInfoAnon -&gt; Bool
</span><a href="#local-6989586621683042180"><span class="hs-identifier hs-var">newly_blocked</span></a></span><span> </span><span class="annot"><span class="annottext">SkolemInfoAnon
</span><a href="#local-6989586621683042182"><span class="hs-identifier hs-var">skol_info</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2092"></span><span>
</span><span id="line-2093"></span><span>    </span><span class="annot"><a href="#local-6989586621683042174"><span class="hs-identifier hs-var">mk_sc_origin</span></a></span><span> </span><span id="local-6989586621683042183"><span class="annot"><span class="annottext">CtOrigin
</span><a href="#local-6989586621683042183"><span class="hs-identifier hs-var">other_orig</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; CtOrigin
forall a. HasCallStack =&gt; String -&gt; SDoc -&gt; a
</span><a href="GHC.Utils.Panic.html#pprPanic"><span class="hs-identifier hs-var">pprPanic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Given constraint without given origin&quot;</span></span><span> </span><span class="annot"><span class="annottext">(SDoc -&gt; CtOrigin) -&gt; SDoc -&gt; CtOrigin
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-2094"></span><span>                              </span><span class="annot"><span class="annottext">EvVar -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">EvVar
</span><a href="#local-6989586621683042137"><span class="hs-identifier hs-var">evar</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsDoc doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%24%24"><span class="hs-operator hs-var">$$</span></a></span><span> </span><span class="annot"><span class="annottext">CtOrigin -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">CtOrigin
</span><a href="#local-6989586621683042183"><span class="hs-identifier hs-var">other_orig</span></a></span><span>
</span><span id="line-2095"></span><span>
</span><span id="line-2096"></span><span>    </span><span id="local-6989586621683042180"><span class="annot"><span class="annottext">newly_blocked :: SkolemInfoAnon -&gt; Bool
</span><a href="#local-6989586621683042180"><span class="hs-identifier hs-var hs-var">newly_blocked</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Origin.html#InstSkol"><span class="hs-identifier hs-type">InstSkol</span></a></span><span> </span><span class="annot"><span class="annottext">ClsInstOrQC
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621683042185"><span class="annot"><span class="annottext">PatersonSize
</span><a href="#local-6989586621683042185"><span class="hs-identifier hs-var">head_size</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe PatersonCondFailure -&gt; Bool
forall a. Maybe a -&gt; Bool
</span><span class="hs-identifier hs-var">isJust</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">PatersonSize
</span><a href="#local-6989586621683042145"><span class="hs-identifier hs-var">this_size</span></a></span><span> </span><span class="annot"><span class="annottext">PatersonSize -&gt; PatersonSize -&gt; Maybe PatersonCondFailure
</span><a href="GHC.Tc.Utils.TcType.html#ltPatersonSize"><span class="hs-operator hs-var">`ltPatersonSize`</span></a></span><span> </span><span class="annot"><span class="annottext">PatersonSize
</span><a href="#local-6989586621683042185"><span class="hs-identifier hs-var">head_size</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2097"></span><span>    </span><span class="annot"><a href="#local-6989586621683042180"><span class="hs-identifier hs-var">newly_blocked</span></a></span><span> </span><span class="annot"><span class="annottext">SkolemInfoAnon
</span><span class="hs-identifier">_</span></span><span>                      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-2098"></span><span>
</span><span id="line-2099"></span><span class="hs-comment">-- Wanted case</span><span>
</span><span id="line-2100"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#mk_strict_superclasses"><span class="hs-identifier hs-var">mk_strict_superclasses</span></a></span><span> </span><span id="local-6989586621683042187"><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042187"><span class="hs-identifier hs-var">fuel</span></a></span></span><span> </span><span id="local-6989586621683042188"><span class="annot"><span class="annottext">NameSet
</span><a href="#local-6989586621683042188"><span class="hs-identifier hs-var">rec_clss</span></a></span></span><span> </span><span id="local-6989586621683042189"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042189"><span class="hs-identifier hs-var">ev</span></a></span></span><span> </span><span id="local-6989586621683042190"><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042190"><span class="hs-identifier hs-var">tvs</span></a></span></span><span> </span><span id="local-6989586621683042191"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042191"><span class="hs-identifier hs-var">theta</span></a></span></span><span> </span><span id="local-6989586621683042192"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042192"><span class="hs-identifier hs-var">cls</span></a></span></span><span> </span><span id="local-6989586621683042193"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042193"><span class="hs-identifier hs-var">tys</span></a></span></span><span>
</span><span id="line-2101"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Bool) -&gt; [Type] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Bool
</span><a href="GHC.Core.TyCo.FVs.html#noFreeVarsOfType"><span class="hs-identifier hs-var">noFreeVarsOfType</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042193"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-2102"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Ct] -&gt; TcS [Ct]
forall a. a -&gt; TcS a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- Wanteds with no variables yield no superclass constraints.</span><span>
</span><span id="line-2103"></span><span>              </span><span class="hs-comment">-- See Note [Improvement from Ground Wanteds]</span><span>
</span><span id="line-2104"></span><span>
</span><span id="line-2105"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-comment">-- Wanted case, just add Wanted superclasses</span><span>
</span><span id="line-2106"></span><span>              </span><span class="hs-comment">-- that can lead to improvement.</span><span>
</span><span id="line-2107"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; SDoc -&gt; TcS [Ct] -&gt; TcS [Ct]
forall a. HasCallStack =&gt; Bool -&gt; SDoc -&gt; a -&gt; a
</span><a href="GHC.Utils.Panic.html#assertPpr"><span class="hs-identifier hs-var">assertPpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[EvVar] -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042190"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042191"><span class="hs-identifier hs-var">theta</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[EvVar] -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042190"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsDoc doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%24%24"><span class="hs-operator hs-var">$$</span></a></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042191"><span class="hs-identifier hs-var">theta</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(TcS [Ct] -&gt; TcS [Ct]) -&gt; TcS [Ct] -&gt; TcS [Ct]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-2108"></span><span>    </span><span class="annot"><span class="annottext">(Type -&gt; TcS [Ct]) -&gt; [Type] -&gt; TcS [Ct]
forall (m :: * -&gt; *) (f :: * -&gt; *) a b.
(Monad m, Traversable f) =&gt;
(a -&gt; m [b]) -&gt; f a -&gt; m [b]
</span><a href="GHC.Utils.Monad.html#concatMapM"><span class="hs-identifier hs-var">concatMapM</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; TcS [Ct]
</span><a href="#local-6989586621683042195"><span class="hs-identifier hs-var">do_one</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Class -&gt; [Type] -&gt; [Type]
</span><a href="GHC.Tc.Utils.TcType.html#immSuperClasses"><span class="hs-identifier hs-var">immSuperClasses</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042192"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042193"><span class="hs-identifier hs-var">tys</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2109"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-2110"></span><span>    </span><span id="local-6989586621683042197"><span class="annot"><span class="annottext">loc :: CtLoc
</span><a href="#local-6989586621683042197"><span class="hs-identifier hs-var hs-var">loc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence -&gt; CtLoc
</span><a href="GHC.Tc.Types.Constraint.html#ctEvLoc"><span class="hs-identifier hs-var">ctEvLoc</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042189"><span class="hs-identifier hs-var">ev</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc -&gt; (CtOrigin -&gt; CtOrigin) -&gt; CtLoc
</span><a href="GHC.Tc.Types.CtLoc.html#updateCtLocOrigin"><span class="hs-operator hs-var">`updateCtLocOrigin`</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; CtOrigin -&gt; CtOrigin
</span><a href="GHC.Tc.Types.Origin.html#WantedSuperclassOrigin"><span class="hs-identifier hs-var">WantedSuperclassOrigin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtEvidence -&gt; Type
</span><a href="GHC.Tc.Types.Constraint.html#ctEvPred"><span class="hs-identifier hs-var">ctEvPred</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042189"><span class="hs-identifier hs-var">ev</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2111"></span><span>
</span><span id="line-2112"></span><span>    </span><span id="local-6989586621683042195"><span class="annot"><span class="annottext">do_one :: Type -&gt; TcS [Ct]
</span><a href="#local-6989586621683042195"><span class="hs-identifier hs-var hs-var">do_one</span></a></span></span><span> </span><span id="local-6989586621683042200"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042200"><span class="hs-identifier hs-var">sc_pred</span></a></span></span><span>
</span><span id="line-2113"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-var">traceTcS</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;mk_strict_superclasses Wanted&quot;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Class -&gt; [Type] -&gt; Type
</span><a href="GHC.Core.Predicate.html#mkClassPred"><span class="hs-identifier hs-var">mkClassPred</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042192"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042193"><span class="hs-identifier hs-var">tys</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsDoc doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%24%24"><span class="hs-operator hs-var">$$</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042200"><span class="hs-identifier hs-var">sc_pred</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2114"></span><span>           </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683042201"><span class="annot"><a href="#local-6989586621683042201"><span class="hs-identifier hs-var">sc_ev</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">CtLoc -&gt; RewriterSet -&gt; Type -&gt; TcS CtEvidence
</span><a href="GHC.Tc.Solver.Monad.html#newWantedNC"><span class="hs-identifier hs-var">newWantedNC</span></a></span><span> </span><span class="annot"><span class="annottext">CtLoc
</span><a href="#local-6989586621683042197"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">CtEvidence -&gt; RewriterSet
</span><a href="GHC.Tc.Types.Constraint.html#ctEvRewriters"><span class="hs-identifier hs-var">ctEvRewriters</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042189"><span class="hs-identifier hs-var">ev</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042200"><span class="hs-identifier hs-var">sc_pred</span></a></span><span>
</span><span id="line-2115"></span><span>           </span><span class="hs-special">;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#mk_superclasses"><span class="hs-identifier hs-type">mk_superclasses</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042187"><span class="hs-identifier hs-type">fuel</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042188"><span class="hs-identifier hs-type">rec_clss</span></a></span><span> </span><span class="annot"><a href="#local-6989586621683042201"><span class="hs-identifier hs-type">sc_ev</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><a href="#local-6989586621683042200"><span class="hs-identifier hs-type">sc_pred</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-2116"></span><span>
</span><span id="line-2117"></span><span class="hs-comment">{- Note [Improvement from Ground Wanteds]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Suppose class C b a =&gt; D a b
and consider
  [W] D Int Bool
Is there any point in emitting [W] C Bool Int?  No!  The only point of
emitting superclass constraints for W constraints is to get
improvement, extra unifications that result from functional
dependencies.  See Note [Why adding superclasses can help] above.

But no variables means no improvement; case closed.
-}</span><span>
</span><span id="line-2129"></span><span>
</span><span id="line-2130"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#mk_superclasses"><span class="hs-identifier hs-type">mk_superclasses</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#ExpansionFuel"><span class="hs-identifier hs-type">ExpansionFuel</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Types.Name.Set.html#NameSet"><span class="hs-identifier hs-type">NameSet</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CtEvidence"><span class="hs-identifier hs-type">CtEvidence</span></a></span><span>
</span><span id="line-2131"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Var.html#TyVar"><span class="hs-identifier hs-type">TyVar</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#ThetaType"><span class="hs-identifier hs-type">ThetaType</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#PredType"><span class="hs-identifier hs-type">PredType</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#TcS"><span class="hs-identifier hs-type">TcS</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#Ct"><span class="hs-identifier hs-type">Ct</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2132"></span><span class="hs-comment">-- Return this constraint, plus its superclasses, if any</span><span>
</span><span id="line-2133"></span><span class="hs-comment">-- Precondition: fuel &gt;= 0</span><span>
</span><span id="line-2134"></span><span id="mk_superclasses"><span class="annot"><span class="annottext">mk_superclasses :: ScDepth
-&gt; NameSet -&gt; CtEvidence -&gt; [EvVar] -&gt; [Type] -&gt; Type -&gt; TcS [Ct]
</span><a href="GHC.Tc.Solver.Dict.html#mk_superclasses"><span class="hs-identifier hs-var hs-var">mk_superclasses</span></a></span></span><span> </span><span id="local-6989586621683042202"><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042202"><span class="hs-identifier hs-var">fuel</span></a></span></span><span> </span><span id="local-6989586621683042203"><span class="annot"><span class="annottext">NameSet
</span><a href="#local-6989586621683042203"><span class="hs-identifier hs-var">rec_clss</span></a></span></span><span> </span><span id="local-6989586621683042204"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042204"><span class="hs-identifier hs-var">ev</span></a></span></span><span> </span><span id="local-6989586621683042205"><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042205"><span class="hs-identifier hs-var">tvs</span></a></span></span><span> </span><span id="local-6989586621683042206"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042206"><span class="hs-identifier hs-var">theta</span></a></span></span><span> </span><span id="local-6989586621683042207"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042207"><span class="hs-identifier hs-var">pred</span></a></span></span><span>
</span><span id="line-2135"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="GHC.Core.Predicate.html#ClassPred"><span class="hs-identifier hs-type">ClassPred</span></a></span><span> </span><span id="local-6989586621683042208"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042208"><span class="hs-identifier hs-var">cls</span></a></span></span><span> </span><span id="local-6989586621683042209"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042209"><span class="hs-identifier hs-var">tys</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Pred
</span><a href="GHC.Core.Predicate.html#classifyPredType"><span class="hs-identifier hs-var">classifyPredType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621683042207"><span class="hs-identifier hs-var">pred</span></a></span><span>
</span><span id="line-2136"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ScDepth -&gt; TcS [Ct] -&gt; TcS [Ct]
forall a. ScDepth -&gt; a -&gt; a
</span><a href="GHC.Tc.Types.Constraint.html#assertFuelPrecondition"><span class="hs-identifier hs-var">assertFuelPrecondition</span></a></span><span> </span><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042202"><span class="hs-identifier hs-var">fuel</span></a></span><span> </span><span class="annot"><span class="annottext">(TcS [Ct] -&gt; TcS [Ct]) -&gt; TcS [Ct] -&gt; TcS [Ct]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-2137"></span><span>    </span><span class="annot"><span class="annottext">ScDepth
-&gt; NameSet
-&gt; CtEvidence
-&gt; [EvVar]
-&gt; [Type]
-&gt; Class
-&gt; [Type]
-&gt; TcS [Ct]
</span><a href="GHC.Tc.Solver.Dict.html#mk_superclasses_of"><span class="hs-identifier hs-var">mk_superclasses_of</span></a></span><span> </span><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042202"><span class="hs-identifier hs-var">fuel</span></a></span><span> </span><span class="annot"><span class="annottext">NameSet
</span><a href="#local-6989586621683042203"><span class="hs-identifier hs-var">rec_clss</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042204"><span class="hs-identifier hs-var">ev</span></a></span><span> </span><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042205"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042206"><span class="hs-identifier hs-var">theta</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042208"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042209"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-2138"></span><span>
</span><span id="line-2139"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>   </span><span class="hs-comment">-- Superclass is not a class predicate</span><span>
</span><span id="line-2140"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Ct] -&gt; TcS [Ct]
forall a. a -&gt; TcS a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">CtEvidence -&gt; Ct
</span><a href="GHC.Tc.Types.Constraint.html#mkNonCanonical"><span class="hs-identifier hs-var">mkNonCanonical</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042204"><span class="hs-identifier hs-var">ev</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2141"></span><span>
</span><span id="line-2142"></span><span class="annot"><a href="GHC.Tc.Solver.Dict.html#mk_superclasses_of"><span class="hs-identifier hs-type">mk_superclasses_of</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#ExpansionFuel"><span class="hs-identifier hs-type">ExpansionFuel</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Types.Name.Set.html#NameSet"><span class="hs-identifier hs-type">NameSet</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#CtEvidence"><span class="hs-identifier hs-type">CtEvidence</span></a></span><span>
</span><span id="line-2143"></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Var.html#TyVar"><span class="hs-identifier hs-type">TyVar</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#ThetaType"><span class="hs-identifier hs-type">ThetaType</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.Class.html#Class"><span class="hs-identifier hs-type">Class</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2144"></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Solver.Monad.html#TcS"><span class="hs-identifier hs-type">TcS</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#Ct"><span class="hs-identifier hs-type">Ct</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2145"></span><span class="hs-comment">-- Always return this class constraint,</span><span>
</span><span id="line-2146"></span><span class="hs-comment">-- and expand its superclasses</span><span>
</span><span id="line-2147"></span><span class="hs-comment">-- Precondition: fuel &gt;= 0</span><span>
</span><span id="line-2148"></span><span id="mk_superclasses_of"><span class="annot"><span class="annottext">mk_superclasses_of :: ScDepth
-&gt; NameSet
-&gt; CtEvidence
-&gt; [EvVar]
-&gt; [Type]
-&gt; Class
-&gt; [Type]
-&gt; TcS [Ct]
</span><a href="GHC.Tc.Solver.Dict.html#mk_superclasses_of"><span class="hs-identifier hs-var hs-var">mk_superclasses_of</span></a></span></span><span> </span><span id="local-6989586621683042211"><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042211"><span class="hs-identifier hs-var">fuel</span></a></span></span><span> </span><span id="local-6989586621683042212"><span class="annot"><span class="annottext">NameSet
</span><a href="#local-6989586621683042212"><span class="hs-identifier hs-var">rec_clss</span></a></span></span><span> </span><span id="local-6989586621683042213"><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042213"><span class="hs-identifier hs-var">ev</span></a></span></span><span> </span><span id="local-6989586621683042214"><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042214"><span class="hs-identifier hs-var">tvs</span></a></span></span><span> </span><span id="local-6989586621683042215"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042215"><span class="hs-identifier hs-var">theta</span></a></span></span><span> </span><span id="local-6989586621683042216"><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042216"><span class="hs-identifier hs-var">cls</span></a></span></span><span> </span><span id="local-6989586621683042217"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042217"><span class="hs-identifier hs-var">tys</span></a></span></span><span>
</span><span id="line-2149"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621683042218"><span class="hs-identifier hs-var">loop_found</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-var">traceTcS</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;mk_superclasses_of: loop&quot;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Class -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042216"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042217"><span class="hs-identifier hs-var">tys</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2150"></span><span>                    </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">ScDepth -&gt; TcS [Ct] -&gt; TcS [Ct]
forall a. ScDepth -&gt; a -&gt; a
</span><a href="GHC.Tc.Types.Constraint.html#assertFuelPrecondition"><span class="hs-identifier hs-var">assertFuelPrecondition</span></a></span><span> </span><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042211"><span class="hs-identifier hs-var">fuel</span></a></span><span> </span><span class="annot"><span class="annottext">(TcS [Ct] -&gt; TcS [Ct]) -&gt; TcS [Ct] -&gt; TcS [Ct]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Ct] -&gt; TcS [Ct]
forall a. a -&gt; TcS a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">ScDepth -&gt; Ct
</span><a href="#local-6989586621683042219"><span class="hs-identifier hs-var">mk_this_ct</span></a></span><span> </span><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042211"><span class="hs-identifier hs-var">fuel</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-2151"></span><span>                                                  </span><span class="hs-comment">-- cc_pend_sc of returning ct = fuel</span><span>
</span><span id="line-2152"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc -&gt; TcS ()
</span><a href="GHC.Tc.Solver.Monad.html#traceTcS"><span class="hs-identifier hs-var">traceTcS</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;mk_superclasses_of&quot;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsDoc doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#vcat"><span class="hs-identifier hs-var">vcat</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">Class -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042216"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042217"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-2153"></span><span>                                                          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Class -&gt; Bool
</span><a href="GHC.Core.Predicate.html#isCTupleClass"><span class="hs-identifier hs-var">isCTupleClass</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042216"><span class="hs-identifier hs-var">cls</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2154"></span><span>                                                          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">NameSet -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">NameSet
</span><a href="#local-6989586621683042212"><span class="hs-identifier hs-var">rec_clss</span></a></span><span>
</span><span id="line-2155"></span><span>                                                          </span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-2156"></span><span>                    </span><span class="hs-special">;</span><span> </span><span id="local-6989586621683042220"><span class="annot"><a href="#local-6989586621683042220"><span class="hs-identifier hs-var">sc_cts</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ScDepth -&gt; TcS [Ct] -&gt; TcS [Ct]
forall a. ScDepth -&gt; a -&gt; a
</span><a href="GHC.Tc.Types.Constraint.html#assertFuelPrecondition"><span class="hs-identifier hs-var">assertFuelPrecondition</span></a></span><span> </span><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042211"><span class="hs-identifier hs-var">fuel</span></a></span><span> </span><span class="annot"><span class="annottext">(TcS [Ct] -&gt; TcS [Ct]) -&gt; TcS [Ct] -&gt; TcS [Ct]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-2157"></span><span>                                </span><span class="annot"><span class="annottext">ScDepth
-&gt; NameSet
-&gt; CtEvidence
-&gt; [EvVar]
-&gt; [Type]
-&gt; Class
-&gt; [Type]
-&gt; TcS [Ct]
</span><a href="GHC.Tc.Solver.Dict.html#mk_strict_superclasses"><span class="hs-identifier hs-var">mk_strict_superclasses</span></a></span><span> </span><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042211"><span class="hs-identifier hs-var">fuel</span></a></span><span> </span><span class="annot"><span class="annottext">NameSet
</span><a href="#local-6989586621683042221"><span class="hs-identifier hs-var">rec_clss'</span></a></span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042213"><span class="hs-identifier hs-var">ev</span></a></span><span> </span><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042214"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042215"><span class="hs-identifier hs-var">theta</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042216"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042217"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-2158"></span><span>                    </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621683042219"><span class="hs-identifier hs-type">mk_this_ct</span></a></span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#doNotExpand"><span class="hs-identifier hs-type">doNotExpand</span></a></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span class="annot"><a href="#local-6989586621683042220"><span class="hs-identifier hs-type">sc_cts</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-2159"></span><span>                                      </span><span class="hs-comment">-- doNotExpand: we have expanded this cls's superclasses, so</span><span>
</span><span id="line-2160"></span><span>                                      </span><span class="hs-comment">-- exhaust the associated constraint's fuel,</span><span>
</span><span id="line-2161"></span><span>                                      </span><span class="hs-comment">-- to avoid duplicate work</span><span>
</span><span id="line-2162"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-2163"></span><span>    </span><span id="local-6989586621683042222"><span class="annot"><span class="annottext">cls_nm :: Name
</span><a href="#local-6989586621683042222"><span class="hs-identifier hs-var hs-var">cls_nm</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Class -&gt; Name
</span><a href="GHC.Core.Class.html#className"><span class="hs-identifier hs-var">className</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042216"><span class="hs-identifier hs-var">cls</span></a></span><span>
</span><span id="line-2164"></span><span>    </span><span id="local-6989586621683042218"><span class="annot"><span class="annottext">loop_found :: Bool
</span><a href="#local-6989586621683042218"><span class="hs-identifier hs-var hs-var">loop_found</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Class -&gt; Bool
</span><a href="GHC.Core.Predicate.html#isCTupleClass"><span class="hs-identifier hs-var">isCTupleClass</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042216"><span class="hs-identifier hs-var">cls</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621683042222"><span class="hs-identifier hs-var">cls_nm</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; NameSet -&gt; Bool
</span><a href="GHC.Types.Name.Set.html#elemNameSet"><span class="hs-operator hs-var">`elemNameSet`</span></a></span><span> </span><span class="annot"><span class="annottext">NameSet
</span><a href="#local-6989586621683042212"><span class="hs-identifier hs-var">rec_clss</span></a></span><span>
</span><span id="line-2165"></span><span>                 </span><span class="hs-comment">-- Tuples never contribute to recursion, and can be nested</span><span>
</span><span id="line-2166"></span><span>    </span><span id="local-6989586621683042221"><span class="annot"><span class="annottext">rec_clss' :: NameSet
</span><a href="#local-6989586621683042221"><span class="hs-identifier hs-var hs-var">rec_clss'</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NameSet
</span><a href="#local-6989586621683042212"><span class="hs-identifier hs-var">rec_clss</span></a></span><span> </span><span class="annot"><span class="annottext">NameSet -&gt; Name -&gt; NameSet
</span><a href="GHC.Types.Name.Set.html#extendNameSet"><span class="hs-operator hs-var">`extendNameSet`</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621683042222"><span class="hs-identifier hs-var">cls_nm</span></a></span><span>
</span><span id="line-2167"></span><span>
</span><span id="line-2168"></span><span>    </span><span class="annot"><a href="#local-6989586621683042219"><span class="hs-identifier hs-type">mk_this_ct</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#ExpansionFuel"><span class="hs-identifier hs-type">ExpansionFuel</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#Ct"><span class="hs-identifier hs-type">Ct</span></a></span><span>
</span><span id="line-2169"></span><span>    </span><span class="hs-comment">-- We can't use CNonCanonical here because we need to tradk the fuel</span><span>
</span><span id="line-2170"></span><span>    </span><span id="local-6989586621683042219"><span class="annot"><span class="annottext">mk_this_ct :: ScDepth -&gt; Ct
</span><a href="#local-6989586621683042219"><span class="hs-identifier hs-var hs-var">mk_this_ct</span></a></span></span><span> </span><span id="local-6989586621683042225"><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042225"><span class="hs-identifier hs-var">fuel</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">[EvVar] -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042214"><span class="hs-identifier hs-var">tvs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042215"><span class="hs-identifier hs-var">theta</span></a></span><span>
</span><span id="line-2171"></span><span>                    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DictCt -&gt; Ct
</span><a href="GHC.Tc.Types.Constraint.html#CDictCan"><span class="hs-identifier hs-var">CDictCan</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#DictCt"><span class="hs-identifier hs-type">DictCt</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">di_ev :: CtEvidence
</span><a href="GHC.Tc.Types.Constraint.html#di_ev"><span class="hs-identifier hs-var">di_ev</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042213"><span class="hs-identifier hs-var">ev</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">di_cls :: Class
</span><a href="GHC.Tc.Types.Constraint.html#di_cls"><span class="hs-identifier hs-var">di_cls</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042216"><span class="hs-identifier hs-var">cls</span></a></span><span>
</span><span id="line-2172"></span><span>                                       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">di_tys :: [Type]
</span><a href="GHC.Tc.Types.Constraint.html#di_tys"><span class="hs-identifier hs-var">di_tys</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042217"><span class="hs-identifier hs-var">tys</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">di_pend_sc :: ScDepth
</span><a href="GHC.Tc.Types.Constraint.html#di_pend_sc"><span class="hs-identifier hs-var">di_pend_sc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042225"><span class="hs-identifier hs-var">fuel</span></a></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-2173"></span><span>                    </span><span class="hs-comment">-- NB: If there is a loop, we cut off, so we have not</span><span>
</span><span id="line-2174"></span><span>                    </span><span class="hs-comment">--     added the superclasses, hence cc_pend_sc = fuel</span><span>
</span><span id="line-2175"></span><span>                    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-2176"></span><span>                    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">QCInst -&gt; Ct
</span><a href="GHC.Tc.Types.Constraint.html#CQuantCan"><span class="hs-identifier hs-var">CQuantCan</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Types.Constraint.html#QCI"><span class="hs-identifier hs-type">QCI</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">qci_tvs :: [EvVar]
</span><a href="GHC.Tc.Types.Constraint.html#qci_tvs"><span class="hs-identifier hs-var">qci_tvs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[EvVar]
</span><a href="#local-6989586621683042214"><span class="hs-identifier hs-var">tvs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">qci_pred :: Type
</span><a href="GHC.Tc.Types.Constraint.html#qci_pred"><span class="hs-identifier hs-var">qci_pred</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Class -&gt; [Type] -&gt; Type
</span><a href="GHC.Core.Predicate.html#mkClassPred"><span class="hs-identifier hs-var">mkClassPred</span></a></span><span> </span><span class="annot"><span class="annottext">Class
</span><a href="#local-6989586621683042216"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621683042217"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-2177"></span><span>                                     </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">qci_ev :: CtEvidence
</span><a href="GHC.Tc.Types.Constraint.html#qci_ev"><span class="hs-identifier hs-var">qci_ev</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">CtEvidence
</span><a href="#local-6989586621683042213"><span class="hs-identifier hs-var">ev</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">qci_pend_sc :: ScDepth
</span><a href="GHC.Tc.Types.Constraint.html#qci_pend_sc"><span class="hs-identifier hs-var">qci_pend_sc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ScDepth
</span><a href="#local-6989586621683042225"><span class="hs-identifier hs-var">fuel</span></a></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-2178"></span><span>
</span><span id="line-2179"></span><span>
</span><span id="line-2180"></span><span class="hs-comment">{- Note [Equality superclasses in quantified constraints]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider (#15359, #15593, #15625)
  f :: (forall a. theta =&gt; a ~ b) =&gt; stuff

It's a bit odd to have a local, quantified constraint for `(a~b)`,
but some people want such a thing (see the tickets). And for
Coercible it is definitely useful
  f :: forall m. (forall p q. Coercible p q =&gt; Coercible (m p) (m q)))
                 =&gt; stuff

Moreover it's not hard to arrange; we just need to look up /equality/
constraints in the quantified-constraint environment, which we do in
GHC.Tc.Solver.Equality.tryQCsEqCt.

There is a wrinkle though, in the case where 'theta' is empty, so
we have
  f :: (forall a. a~b) =&gt; stuff

Now, potentially, the superclass machinery kicks in, in
makeSuperClasses, giving us a a second quantified constraint
       (forall a. a ~# b)
BUT this is an unboxed value!  And nothing has prepared us for
dictionary &quot;functions&quot; that are unboxed.  Actually it does just
about work, but the simplifier ends up with stuff like
   case (/\a. eq_sel d) of df -&gt; ...(df @Int)...
and fails to simplify that any further.  And it doesn't satisfy
isPredTy any more.

So for now we simply decline to take superclasses in the quantified
case.  Instead we have a special case in GHC.Tc.Solver.Equality.tryQCsEqCt
which looks for primitive equalities specially in the quantified
constraints.

See also Note [Evidence for quantified constraints] in GHC.Core.Predicate.
-}</span><span>
</span><span id="line-2216"></span></pre></body></html>