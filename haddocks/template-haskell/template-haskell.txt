-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Support library for Template Haskell
--   
--   This package provides modules containing facilities for manipulating
--   Haskell source code using Template Haskell.
--   
--   See <a>http://www.haskell.org/haskellwiki/Template_Haskell</a> for
--   more information.
@package template-haskell
@version 2.23.0.0


-- | Language extensions known to GHC
module Language.Haskell.TH.LanguageExtensions
data Extension
Cpp :: Extension
OverlappingInstances :: Extension
UndecidableInstances :: Extension
IncoherentInstances :: Extension
UndecidableSuperClasses :: Extension
MonomorphismRestriction :: Extension
MonoLocalBinds :: Extension
DeepSubsumption :: Extension
RelaxedPolyRec :: Extension
ExtendedDefaultRules :: Extension
NamedDefaults :: Extension
ForeignFunctionInterface :: Extension
UnliftedFFITypes :: Extension
InterruptibleFFI :: Extension
CApiFFI :: Extension
GHCForeignImportPrim :: Extension
JavaScriptFFI :: Extension
ParallelArrays :: Extension
Arrows :: Extension
TemplateHaskell :: Extension
TemplateHaskellQuotes :: Extension
QualifiedDo :: Extension
QuasiQuotes :: Extension
ImplicitParams :: Extension
ImplicitPrelude :: Extension
ScopedTypeVariables :: Extension
AllowAmbiguousTypes :: Extension
UnboxedTuples :: Extension
UnboxedSums :: Extension
UnliftedNewtypes :: Extension
UnliftedDatatypes :: Extension
BangPatterns :: Extension
TypeFamilies :: Extension
TypeFamilyDependencies :: Extension
TypeInType :: Extension
OverloadedStrings :: Extension
OverloadedLists :: Extension
NumDecimals :: Extension
DisambiguateRecordFields :: Extension
RecordWildCards :: Extension
NamedFieldPuns :: Extension
ViewPatterns :: Extension
OrPatterns :: Extension
GADTs :: Extension
GADTSyntax :: Extension
NPlusKPatterns :: Extension
DoAndIfThenElse :: Extension
BlockArguments :: Extension
RebindableSyntax :: Extension
ConstraintKinds :: Extension
PolyKinds :: Extension
DataKinds :: Extension
TypeData :: Extension
InstanceSigs :: Extension
ApplicativeDo :: Extension
LinearTypes :: Extension
RequiredTypeArguments :: Extension
StandaloneDeriving :: Extension
DeriveDataTypeable :: Extension
AutoDeriveTypeable :: Extension
DeriveFunctor :: Extension
DeriveTraversable :: Extension
DeriveFoldable :: Extension
DeriveGeneric :: Extension
DefaultSignatures :: Extension
DeriveAnyClass :: Extension
DeriveLift :: Extension
DerivingStrategies :: Extension
DerivingVia :: Extension
TypeSynonymInstances :: Extension
FlexibleContexts :: Extension
FlexibleInstances :: Extension
ConstrainedClassMethods :: Extension
MultiParamTypeClasses :: Extension
NullaryTypeClasses :: Extension
FunctionalDependencies :: Extension
UnicodeSyntax :: Extension
ExistentialQuantification :: Extension
MagicHash :: Extension
EmptyDataDecls :: Extension
KindSignatures :: Extension
RoleAnnotations :: Extension
ParallelListComp :: Extension
TransformListComp :: Extension
MonadComprehensions :: Extension
GeneralizedNewtypeDeriving :: Extension
RecursiveDo :: Extension
PostfixOperators :: Extension
TupleSections :: Extension
PatternGuards :: Extension
LiberalTypeSynonyms :: Extension
RankNTypes :: Extension
ImpredicativeTypes :: Extension
TypeOperators :: Extension
ExplicitNamespaces :: Extension
PackageImports :: Extension
ExplicitForAll :: Extension
AlternativeLayoutRule :: Extension
AlternativeLayoutRuleTransitional :: Extension
DatatypeContexts :: Extension
NondecreasingIndentation :: Extension
RelaxedLayout :: Extension
TraditionalRecordSyntax :: Extension
LambdaCase :: Extension
MultiWayIf :: Extension
BinaryLiterals :: Extension
NegativeLiterals :: Extension
HexFloatLiterals :: Extension
DuplicateRecordFields :: Extension
OverloadedLabels :: Extension
EmptyCase :: Extension
PatternSynonyms :: Extension
PartialTypeSignatures :: Extension
NamedWildCards :: Extension
StaticPointers :: Extension
TypeApplications :: Extension
Strict :: Extension
StrictData :: Extension
EmptyDataDeriving :: Extension
NumericUnderscores :: Extension
QuantifiedConstraints :: Extension
StarIsType :: Extension
ImportQualifiedPost :: Extension
CUSKs :: Extension
StandaloneKindSignatures :: Extension
LexicalNegation :: Extension
FieldSelectors :: Extension
OverloadedRecordDot :: Extension
OverloadedRecordUpdate :: Extension
TypeAbstractions :: Extension
ExtendedLiterals :: Extension
ListTuplePuns :: Extension
MultilineStrings :: Extension


-- | Language.Haskell.TH.Lib.Internal exposes some additional functionality
--   that is used internally in GHC's integration with Template Haskell.
--   This is not a part of the public API, and as such, there are no API
--   guarantees for this module from version to version.
module Language.Haskell.TH.Lib.Internal
anyclassStrategy :: Quote m => m DerivStrategy
appE :: Quote m => m Exp -> m Exp -> m Exp
appK :: Kind -> Kind -> Kind
appKindT :: Quote m => m Type -> m Kind -> m Type
appT :: Quote m => m Type -> m Type -> m Type
appTypeE :: Quote m => m Exp -> m Type -> m Exp
appsE :: Quote m => [m Exp] -> m Exp
arithSeqE :: Quote m => m Range -> m Exp
arrowK :: Kind
arrowT :: Quote m => m Type
asP :: Quote m => Name -> m Pat -> m Pat
bang :: Quote m => m SourceUnpackedness -> m SourceStrictness -> m Bang
bangP :: Quote m => m Pat -> m Pat
bangType :: Quote m => m Bang -> m Type -> m BangType
bindS :: Quote m => m Pat -> m Exp -> m Stmt
bndrInvis :: BndrVis
bndrReq :: BndrVis
bytesPrimL :: Bytes -> Lit
cApi :: Callconv
cCall :: Callconv
caseE :: Quote m => m Exp -> [m Match] -> m Exp
charL :: Char -> Lit
charPrimL :: Char -> Lit
charTyLit :: Quote m => Char -> m TyLit
classD :: Quote m => m Cxt -> Name -> [m (TyVarBndr BndrVis)] -> [FunDep] -> [m Dec] -> m Dec
classP :: Quote m => Name -> [m Type] -> m Pred
clause :: Quote m => [m Pat] -> m Body -> [m Dec] -> m Clause
closedTypeFamilyD :: Quote m => Name -> [m (TyVarBndr BndrVis)] -> m FamilyResultSig -> Maybe InjectivityAnn -> [m TySynEqn] -> m Dec
compE :: Quote m => [m Stmt] -> m Exp
conE :: Quote m => Name -> m Exp
conK :: Name -> Kind
conP :: Quote m => Name -> [m Type] -> [m Pat] -> m Pat
conT :: Quote m => Name -> m Type
condE :: Quote m => m Exp -> m Exp -> m Exp -> m Exp
constrainedE :: Quote m => [m Exp] -> m Exp -> m Exp
constraintK :: Quote m => m Kind
cxt :: Quote m => [m Pred] -> m Cxt
dataD :: Quote m => m Cxt -> Name -> [m (TyVarBndr BndrVis)] -> Maybe (m Kind) -> [m Con] -> [m DerivClause] -> m Dec
dataD_doc :: Q Cxt -> Name -> [Q (TyVarBndr BndrVis)] -> Maybe (Q Kind) -> [(Q Con, Maybe String, [Maybe String])] -> [Q DerivClause] -> Maybe String -> Q Dec
dataFamilyD :: Quote m => Name -> [m (TyVarBndr BndrVis)] -> Maybe (m Kind) -> m Dec
dataInstD :: Quote m => m Cxt -> Maybe [m (TyVarBndr ())] -> m Type -> Maybe (m Kind) -> [m Con] -> [m DerivClause] -> m Dec
dataInstD_doc :: Q Cxt -> Maybe [Q (TyVarBndr ())] -> Q Type -> Maybe (Q Kind) -> [(Q Con, Maybe String, [Maybe String])] -> [Q DerivClause] -> Maybe String -> Q Dec
defaultD :: Quote m => [m Type] -> m Dec
defaultSigD :: Quote m => Name -> m Type -> m Dec
derivClause :: Quote m => Maybe (m DerivStrategy) -> [m Pred] -> m DerivClause
doE :: Quote m => Maybe ModName -> [m Stmt] -> m Exp
docCons :: (Q Con, Maybe String, [Maybe String]) -> Q ()
doublePrimL :: Rational -> Lit
dyn :: Quote m => String -> m Exp
equalP :: Quote m => m Type -> m Type -> m Pred
equalityT :: Quote m => m Type
explBidir :: Quote m => [m Clause] -> m PatSynDir
fieldExp :: Quote m => Name -> m Exp -> m (Name, Exp)
fieldPat :: Quote m => Name -> m Pat -> m FieldPat
floatPrimL :: Rational -> Lit
forImpD :: Quote m => Callconv -> Safety -> String -> Name -> m Type -> m Dec
forallC :: Quote m => [m (TyVarBndr Specificity)] -> m Cxt -> m Con -> m Con
forallE :: Quote m => [m (TyVarBndr Specificity)] -> m Exp -> m Exp
forallT :: Quote m => [m (TyVarBndr Specificity)] -> m Cxt -> m Type -> m Type
forallVisE :: Quote m => [m (TyVarBndr ())] -> m Exp -> m Exp
forallVisT :: Quote m => [m (TyVarBndr ())] -> m Type -> m Type
fromE :: Quote m => m Exp -> m Exp
fromR :: Quote m => m Exp -> m Range
fromThenE :: Quote m => m Exp -> m Exp -> m Exp
fromThenR :: Quote m => m Exp -> m Exp -> m Range
fromThenToE :: Quote m => m Exp -> m Exp -> m Exp -> m Exp
fromThenToR :: Quote m => m Exp -> m Exp -> m Exp -> m Range
fromToE :: Quote m => m Exp -> m Exp -> m Exp
fromToR :: Quote m => m Exp -> m Exp -> m Range
funD :: Quote m => Name -> [m Clause] -> m Dec
funD_doc :: Name -> [Q Clause] -> Maybe String -> [Maybe String] -> Q Dec
funDep :: [Name] -> [Name] -> FunDep
gadtC :: Quote m => [Name] -> [m StrictType] -> m Type -> m Con
getFieldE :: Quote m => m Exp -> String -> m Exp
guardedB :: Quote m => [m (Guard, Exp)] -> m Body
implBidir :: Quote m => m PatSynDir
implicitParamBindD :: Quote m => String -> m Exp -> m Dec
implicitParamT :: Quote m => String -> m Type -> m Type
implicitParamVarE :: Quote m => String -> m Exp
inferR :: Role
inferredSpec :: Specificity
infixApp :: Quote m => m Exp -> m Exp -> m Exp -> m Exp
infixC :: Quote m => m (Bang, Type) -> Name -> m (Bang, Type) -> m Con
infixE :: Quote m => Maybe (m Exp) -> m Exp -> Maybe (m Exp) -> m Exp
infixLD :: Quote m => Int -> Name -> m Dec
infixLWithSpecD :: Quote m => Int -> NamespaceSpecifier -> Name -> m Dec
infixND :: Quote m => Int -> Name -> m Dec
infixNWithSpecD :: Quote m => Int -> NamespaceSpecifier -> Name -> m Dec
infixP :: Quote m => m Pat -> Name -> m Pat -> m Pat
infixPatSyn :: Quote m => Name -> Name -> m PatSynArgs
infixRD :: Quote m => Int -> Name -> m Dec
infixRWithSpecD :: Quote m => Int -> NamespaceSpecifier -> Name -> m Dec
infixT :: Quote m => m Type -> Name -> m Type -> m Type
injectivityAnn :: Name -> [Name] -> InjectivityAnn
instanceD :: Quote m => m Cxt -> m Type -> [m Dec] -> m Dec
instanceWithOverlapD :: Quote m => Maybe Overlap -> m Cxt -> m Type -> [m Dec] -> m Dec
intPrimL :: Integer -> Lit
integerL :: Integer -> Lit
interruptible :: Safety
invisP :: Quote m => m Type -> m Pat
isStrict :: Quote m => m Strict
javaScript :: Callconv
kiSigD :: Quote m => Name -> m Kind -> m Dec
kindSig :: Quote m => m Kind -> m FamilyResultSig
kindedBndrTV :: Quote m => Name -> BndrVis -> m Kind -> m (TyVarBndr BndrVis)
kindedInvisTV :: Quote m => Name -> Specificity -> m Kind -> m (TyVarBndr Specificity)
kindedTV :: Quote m => Name -> m Kind -> m (TyVarBndr ())
labelE :: Quote m => String -> m Exp
lam1E :: Quote m => m Pat -> m Exp -> m Exp
lamCaseE :: Quote m => [m Match] -> m Exp
lamCasesE :: Quote m => [m Clause] -> m Exp
lamE :: Quote m => [m Pat] -> m Exp -> m Exp
letE :: Quote m => [m Dec] -> m Exp -> m Exp
letS :: Quote m => [m Dec] -> m Stmt
listE :: Quote m => [m Exp] -> m Exp
listK :: Kind
listP :: Quote m => [m Pat] -> m Pat
listT :: Quote m => m Type
litE :: Quote m => Lit -> m Exp
litP :: Quote m => Lit -> m Pat
litT :: Quote m => m TyLit -> m Type
match :: Quote m => m Pat -> m Body -> [m Dec] -> m Match
mdoE :: Quote m => Maybe ModName -> [m Stmt] -> m Exp
moduleAnnotation :: AnnTarget
mulArrowT :: Quote m => m Type
multiIfE :: Quote m => [m (Guard, Exp)] -> m Exp
newtypeD :: Quote m => m Cxt -> Name -> [m (TyVarBndr BndrVis)] -> Maybe (m Kind) -> m Con -> [m DerivClause] -> m Dec
newtypeD_doc :: Q Cxt -> Name -> [Q (TyVarBndr BndrVis)] -> Maybe (Q Kind) -> (Q Con, Maybe String, [Maybe String]) -> [Q DerivClause] -> Maybe String -> Q Dec
newtypeInstD :: Quote m => m Cxt -> Maybe [m (TyVarBndr ())] -> m Type -> Maybe (m Kind) -> m Con -> [m DerivClause] -> m Dec
newtypeInstD_doc :: Q Cxt -> Maybe [Q (TyVarBndr ())] -> Q Type -> Maybe (Q Kind) -> (Q Con, Maybe String, [Maybe String]) -> [Q DerivClause] -> Maybe String -> Q Dec
newtypeStrategy :: Quote m => m DerivStrategy
noBindS :: Quote m => m Exp -> m Stmt
noSig :: Quote m => m FamilyResultSig
noSourceStrictness :: Quote m => m SourceStrictness
noSourceUnpackedness :: Quote m => m SourceUnpackedness
nominalR :: Role
normalB :: Quote m => m Exp -> m Body
normalC :: Quote m => Name -> [m BangType] -> m Con
normalG :: Quote m => m Exp -> m Guard
normalGE :: Quote m => m Exp -> m Exp -> m (Guard, Exp)
notStrict :: Quote m => m Strict
numTyLit :: Quote m => Integer -> m TyLit
openTypeFamilyD :: Quote m => Name -> [m (TyVarBndr BndrVis)] -> m FamilyResultSig -> Maybe InjectivityAnn -> m Dec
orP :: Quote m => NonEmpty (m Pat) -> m Pat
parS :: Quote m => [[m Stmt]] -> m Stmt
parensE :: Quote m => m Exp -> m Exp
parensP :: Quote m => m Pat -> m Pat
parensT :: Quote m => m Type -> m Type
patG :: Quote m => [m Stmt] -> m Guard
patGE :: Quote m => [m Stmt] -> m Exp -> m (Guard, Exp)
patSynD :: Quote m => Name -> m PatSynArgs -> m PatSynDir -> m Pat -> m Dec
patSynD_doc :: Name -> Q PatSynArgs -> Q PatSynDir -> Q Pat -> Maybe String -> [Maybe String] -> Q Dec
patSynSigD :: Quote m => Name -> m Type -> m Dec
phantomR :: Role
plainBndrTV :: Quote m => Name -> BndrVis -> m (TyVarBndr BndrVis)
plainInvisTV :: Quote m => Name -> Specificity -> m (TyVarBndr Specificity)
plainTV :: Quote m => Name -> m (TyVarBndr ())
pragAnnD :: Quote m => AnnTarget -> m Exp -> m Dec
pragCompleteD :: Quote m => [Name] -> Maybe Name -> m Dec
pragInlD :: Quote m => Name -> Inline -> RuleMatch -> Phases -> m Dec
pragLineD :: Quote m => Int -> String -> m Dec
pragOpaqueD :: Quote m => Name -> m Dec
pragRuleD :: Quote m => String -> Maybe [m (TyVarBndr ())] -> [m RuleBndr] -> m Exp -> m Exp -> Phases -> m Dec
pragSCCFunD :: Quote m => Name -> m Dec
pragSCCFunNamedD :: Quote m => Name -> String -> m Dec
pragSpecD :: Quote m => Name -> m Type -> Phases -> m Dec
pragSpecInlD :: Quote m => Name -> m Type -> Inline -> Phases -> m Dec
pragSpecInstD :: Quote m => m Type -> m Dec
prefixPatSyn :: Quote m => [Name] -> m PatSynArgs
prim :: Callconv
projectionE :: Quote m => NonEmpty String -> m Exp
promotedConsT :: Quote m => m Type
promotedInfixT :: Quote m => m Type -> Name -> m Type -> m Type
promotedNilT :: Quote m => m Type
promotedT :: Quote m => Name -> m Type
promotedTupleT :: Quote m => Int -> m Type
promotedUInfixT :: Quote m => m Type -> Name -> m Type -> m Type
rationalL :: Rational -> Lit
recC :: Quote m => Name -> [m VarBangType] -> m Con
recConE :: Quote m => Name -> [m (Name, Exp)] -> m Exp
recGadtC :: Quote m => [Name] -> [m VarStrictType] -> m Type -> m Con
recP :: Quote m => Name -> [m FieldPat] -> m Pat
recS :: Quote m => [m Stmt] -> m Stmt
recUpdE :: Quote m => m Exp -> [m (Name, Exp)] -> m Exp
recordPatSyn :: Quote m => [Name] -> m PatSynArgs
representationalR :: Role
roleAnnotD :: Quote m => Name -> [Role] -> m Dec
ruleVar :: Quote m => Name -> m RuleBndr
safe :: Safety
sectionL :: Quote m => m Exp -> m Exp -> m Exp
sectionR :: Quote m => m Exp -> m Exp -> m Exp
sigD :: Quote m => Name -> m Type -> m Dec
sigE :: Quote m => m Exp -> m Type -> m Exp
sigP :: Quote m => m Pat -> m Type -> m Pat
sigT :: Quote m => m Type -> m Kind -> m Type
sourceLazy :: Quote m => m SourceStrictness
sourceNoUnpack :: Quote m => m SourceUnpackedness
sourceStrict :: Quote m => m SourceStrictness
sourceUnpack :: Quote m => m SourceUnpackedness
specifiedSpec :: Specificity
standaloneDerivD :: Quote m => m Cxt -> m Type -> m Dec
standaloneDerivWithStrategyD :: Quote m => Maybe (m DerivStrategy) -> m Cxt -> m Type -> m Dec
starK :: Quote m => m Kind
staticE :: Quote m => m Exp -> m Exp
stdCall :: Callconv
stockStrategy :: Quote m => m DerivStrategy
strTyLit :: Quote m => String -> m TyLit
strictType :: Quote m => m Strict -> m Type -> m StrictType
stringE :: Quote m => String -> m Exp
stringL :: String -> Lit
stringPrimL :: [Word8] -> Lit
thisModule :: Q Module
tildeP :: Quote m => m Pat -> m Pat
tupE :: Quote m => [Maybe (m Exp)] -> m Exp
tupP :: Quote m => [m Pat] -> m Pat
tupleK :: Int -> Kind
tupleT :: Quote m => Int -> m Type
tySynD :: Quote m => Name -> [m (TyVarBndr BndrVis)] -> m Type -> m Dec
tySynEqn :: Quote m => Maybe [m (TyVarBndr ())] -> m Type -> m Type -> m TySynEqn
tySynInstD :: Quote m => m TySynEqn -> m Dec
tyVarSig :: Quote m => m (TyVarBndr ()) -> m FamilyResultSig
typeAnnotation :: Name -> AnnTarget
typeDataD :: Quote m => Name -> [m (TyVarBndr BndrVis)] -> Maybe (m Kind) -> [m Con] -> m Dec
typeDataD_doc :: Name -> [Q (TyVarBndr BndrVis)] -> Maybe (Q Kind) -> [(Q Con, Maybe String, [Maybe String])] -> Maybe String -> Q Dec
typeE :: Quote m => m Type -> m Exp
typeP :: Quote m => m Type -> m Pat
typedBracketE :: Quote m => m Exp -> m Exp
typedRuleVar :: Quote m => Name -> m Type -> m RuleBndr
typedSpliceE :: Quote m => m Exp -> m Exp
uInfixE :: Quote m => m Exp -> m Exp -> m Exp -> m Exp
uInfixP :: Quote m => m Pat -> Name -> m Pat -> m Pat
uInfixT :: Quote m => m Type -> Name -> m Type -> m Type
unboundVarE :: Quote m => Name -> m Exp
unboxedSumE :: Quote m => m Exp -> SumAlt -> SumArity -> m Exp
unboxedSumP :: Quote m => m Pat -> SumAlt -> SumArity -> m Pat
unboxedSumT :: Quote m => SumArity -> m Type
unboxedTupE :: Quote m => [Maybe (m Exp)] -> m Exp
unboxedTupP :: Quote m => [m Pat] -> m Pat
unboxedTupleT :: Quote m => Int -> m Type
unidir :: Quote m => m PatSynDir
unpacked :: Quote m => m Strict
unsafe :: Safety
valD :: Quote m => m Pat -> m Body -> [m Dec] -> m Dec
valueAnnotation :: Name -> AnnTarget
varBangType :: Quote m => Name -> m BangType -> m VarBangType
varE :: Quote m => Name -> m Exp
varK :: Name -> Kind
varP :: Quote m => Name -> m Pat
varStrictType :: Quote m => Name -> m StrictType -> m VarStrictType
varT :: Quote m => Name -> m Type
viaStrategy :: Quote m => m Type -> m DerivStrategy
viewP :: Quote m => m Exp -> m Pat -> m Pat
wildCardT :: Quote m => m Type
wildP :: Quote m => m Pat
withDecDoc :: String -> Q Dec -> Q Dec
withDecsDoc :: String -> Q [Dec] -> Q [Dec]
wordPrimL :: Integer -> Lit
type BangQ = Q Bang
type BangTypeQ = Q BangType
type BodyQ = Q Body
type ClauseQ = Q Clause
type CodeQ = Code Q
type ConQ = Q Con
type CxtQ = Q Cxt
type DecQ = Q Dec
type Decs = [Dec]
type DecsQ = Q [Dec]
type DerivClauseQ = Q DerivClause
type DerivStrategyQ = Q DerivStrategy
type ExpQ = Q Exp
type FamilyResultSigQ = Q FamilyResultSig
type FieldExpQ = Q FieldExp
type FieldPatQ = Q FieldPat
type GuardQ = Q Guard
type InfoQ = Q Info
type InjectivityAnn = InjectivityAnn
type KindQ = Q Kind
type MatchQ = Q Match
type PatQ = Q Pat
type PatSynArgsQ = Q PatSynArgs
type PatSynDirQ = Q PatSynDir
type PredQ = Q Pred
type RangeQ = Q Range
type Role = Role
type RuleBndrQ = Q RuleBndr
type SourceStrictnessQ = Q SourceStrictness
type SourceUnpackednessQ = Q SourceUnpackedness
type StmtQ = Q Stmt
type StrictTypeQ = Q StrictType
type TExpQ (a :: TYPE r) = Q TExp a
type TyLitQ = Q TyLit
type TySynEqnQ = Q TySynEqn
type TyVarBndrSpec = TyVarBndr Specificity
type TyVarBndrUnit = TyVarBndr ()
type TyVarBndrVis = TyVarBndr BndrVis
type TypeQ = Q Type
type VarBangTypeQ = Q VarBangType
type VarStrictTypeQ = Q VarStrictType


-- | contains a prettyprinter for the Template Haskell datatypes
module Language.Haskell.TH.Ppr


-- | Monadic front-end to Text.PrettyPrint
module Language.Haskell.TH.PprLib


-- | Template Haskell supports quasiquoting, which permits users to
--   construct program fragments by directly writing concrete syntax. A
--   quasiquoter is essentially a function with takes a string to a
--   Template Haskell AST. This module defines the <a>QuasiQuoter</a>
--   datatype, which specifies a quasiquoter <tt>q</tt> which can be
--   invoked using the syntax <tt>[q| ... string to parse ... |]</tt> when
--   the <tt>QuasiQuotes</tt> language extension is enabled, and some
--   utility functions for manipulating quasiquoters. Nota bene: this
--   package does not define any parsers, that is up to you.
module Language.Haskell.TH.Quote
data QuasiQuoter
QuasiQuoter :: (String -> Q Exp) -> (String -> Q Pat) -> (String -> Q Type) -> (String -> Q [Dec]) -> QuasiQuoter
[quoteExp] :: QuasiQuoter -> String -> Q Exp
[quotePat] :: QuasiQuoter -> String -> Q Pat
[quoteType] :: QuasiQuoter -> String -> Q Type
[quoteDec] :: QuasiQuoter -> String -> Q [Dec]

-- | <a>quoteFile</a> takes a <a>QuasiQuoter</a> and lifts it into one that
--   read the data out of a file. For example, suppose <tt>asmq</tt> is an
--   assembly-language quoter, so that you can write [asmq| ld r1, r2 |] as
--   an expression. Then if you define <tt>asmq_f = quoteFile asmq</tt>,
--   then the quote [asmq_f|foo.s|] will take input from file
--   <tt>"foo.s"</tt> instead of the inline text
quoteFile :: QuasiQuoter -> QuasiQuoter
dataToQa :: (Quote m, Data a) => (Name -> k) -> (Lit -> m q) -> (k -> [m q] -> m q) -> (forall b. Data b => b -> Maybe (m q)) -> a -> m q
dataToExpQ :: (Quote m, Data a) => (forall b. Data b => b -> Maybe (m Exp)) -> a -> m Exp
dataToPatQ :: (Quote m, Data a) => (forall b. Data b => b -> Maybe (m Pat)) -> a -> m Pat

module Language.Haskell.TH.Syntax
addCorePlugin :: String -> Q ()
addDependentFile :: FilePath -> Q ()
addForeignFile :: ForeignSrcLang -> String -> Q ()
addForeignFilePath :: ForeignSrcLang -> FilePath -> Q ()
addForeignSource :: ForeignSrcLang -> String -> Q ()
addModFinalizer :: Q () -> Q ()
addTempFile :: String -> Q FilePath
addTopDecls :: [Dec] -> Q ()
badIO :: String -> IO a
bindCode :: Monad m => m a -> (a -> Code m b) -> Code m b
bindCode_ :: Monad m => m a -> Code m b -> Code m b
cmpEq :: Ordering -> Bool
compareBytes :: Bytes -> Bytes -> Ordering
counter :: IORef Uniq
defaultFixity :: Fixity
eqBytes :: Bytes -> Bytes -> Bool
extsEnabled :: Q [Extension]
getDoc :: DocLoc -> Q (Maybe String)
getPackageRoot :: Q FilePath
getQ :: Typeable a => Q (Maybe a)
get_cons_names :: Con -> [Name]
hoistCode :: Monad m => (forall x. () => m x -> n x) -> Code m a -> Code n a
isExtEnabled :: Extension -> Q Bool
isInstance :: Name -> [Type] -> Q Bool
joinCode :: Monad m => m (Code m a) -> Code m a
liftCode :: forall a m. m (TExp a) -> Code m a
location :: Q Loc
lookupName :: Bool -> String -> Q (Maybe Name)
lookupTypeName :: String -> Q (Maybe Name)
lookupValueName :: String -> Q (Maybe Name)
manyName :: Name
maxPrecedence :: Int
memcmp :: Ptr a -> Ptr b -> CSize -> IO CInt
mkModName :: String -> ModName
mkName :: String -> Name
mkNameG :: NameSpace -> String -> String -> String -> Name
mkNameG_d :: String -> String -> String -> Name
mkNameG_fld :: String -> String -> String -> String -> Name
mkNameG_tc :: String -> String -> String -> Name
mkNameG_v :: String -> String -> String -> Name
mkNameL :: String -> Uniq -> Name
mkNameQ :: String -> String -> Name
mkNameS :: String -> Name
mkNameU :: String -> Uniq -> Name
mkOccName :: String -> OccName
mkPkgName :: String -> PkgName
mk_tup_name :: Int -> NameSpace -> Bool -> Name
modString :: ModName -> String
nameBase :: Name -> String
nameModule :: Name -> Maybe String
namePackage :: Name -> Maybe String
nameSpace :: Name -> Maybe NameSpace
newDeclarationGroup :: Q [Dec]
newNameIO :: String -> IO Name
occString :: OccName -> String
oneName :: Name
pkgString :: PkgName -> String
putDoc :: DocLoc -> String -> Q ()
putQ :: Typeable a => a -> Q ()
recover :: Q a -> Q a -> Q a
reify :: Name -> Q Info
reifyAnnotations :: Data a => AnnLookup -> Q [a]
reifyConStrictness :: Name -> Q [DecidedStrictness]
reifyFixity :: Name -> Q (Maybe Fixity)
reifyInstances :: Name -> [Type] -> Q [InstanceDec]
reifyModule :: Module -> Q ModuleInfo
reifyRoles :: Name -> Q [Role]
reifyType :: Name -> Q Type
report :: Bool -> String -> Q ()
reportError :: String -> Q ()
reportWarning :: String -> Q ()
runIO :: IO a -> Q a
runQ :: Quasi m => Q a -> m a
sequenceQ :: Monad m => forall a. () => [m a] -> m [a]
showName :: Name -> String
showName' :: NameIs -> Name -> String
thenCmp :: Ordering -> Ordering -> Ordering
tupleDataName :: Int -> Name
tupleTypeName :: Int -> Name
unTypeCode :: forall a m. Quote m => Code m a -> m Exp
unTypeQ :: forall a m. Quote m => m (TExp a) -> m Exp
unboxedSumDataName :: SumAlt -> SumArity -> Name
unboxedSumTypeName :: SumArity -> Name
unboxedTupleDataName :: Int -> Name
unboxedTupleTypeName :: Int -> Name
unsafeCodeCoerce :: forall a m. Quote m => m Exp -> Code m a
unsafeTExpCoerce :: forall a m. Quote m => m Exp -> m (TExp a)
data ForeignSrcLang
LangC :: ForeignSrcLang
LangCxx :: ForeignSrcLang
LangObjc :: ForeignSrcLang
LangObjcxx :: ForeignSrcLang
LangAsm :: ForeignSrcLang
LangJs :: ForeignSrcLang
RawObject :: ForeignSrcLang
data Extension
Cpp :: Extension
OverlappingInstances :: Extension
UndecidableInstances :: Extension
IncoherentInstances :: Extension
UndecidableSuperClasses :: Extension
MonomorphismRestriction :: Extension
MonoLocalBinds :: Extension
DeepSubsumption :: Extension
RelaxedPolyRec :: Extension
ExtendedDefaultRules :: Extension
NamedDefaults :: Extension
ForeignFunctionInterface :: Extension
UnliftedFFITypes :: Extension
InterruptibleFFI :: Extension
CApiFFI :: Extension
GHCForeignImportPrim :: Extension
JavaScriptFFI :: Extension
ParallelArrays :: Extension
Arrows :: Extension
TemplateHaskell :: Extension
TemplateHaskellQuotes :: Extension
QualifiedDo :: Extension
QuasiQuotes :: Extension
ImplicitParams :: Extension
ImplicitPrelude :: Extension
ScopedTypeVariables :: Extension
AllowAmbiguousTypes :: Extension
UnboxedTuples :: Extension
UnboxedSums :: Extension
UnliftedNewtypes :: Extension
UnliftedDatatypes :: Extension
BangPatterns :: Extension
TypeFamilies :: Extension
TypeFamilyDependencies :: Extension
TypeInType :: Extension
OverloadedStrings :: Extension
OverloadedLists :: Extension
NumDecimals :: Extension
DisambiguateRecordFields :: Extension
RecordWildCards :: Extension
NamedFieldPuns :: Extension
ViewPatterns :: Extension
OrPatterns :: Extension
GADTs :: Extension
GADTSyntax :: Extension
NPlusKPatterns :: Extension
DoAndIfThenElse :: Extension
BlockArguments :: Extension
RebindableSyntax :: Extension
ConstraintKinds :: Extension
PolyKinds :: Extension
DataKinds :: Extension
TypeData :: Extension
InstanceSigs :: Extension
ApplicativeDo :: Extension
LinearTypes :: Extension
RequiredTypeArguments :: Extension
StandaloneDeriving :: Extension
DeriveDataTypeable :: Extension
AutoDeriveTypeable :: Extension
DeriveFunctor :: Extension
DeriveTraversable :: Extension
DeriveFoldable :: Extension
DeriveGeneric :: Extension
DefaultSignatures :: Extension
DeriveAnyClass :: Extension
DeriveLift :: Extension
DerivingStrategies :: Extension
DerivingVia :: Extension
TypeSynonymInstances :: Extension
FlexibleContexts :: Extension
FlexibleInstances :: Extension
ConstrainedClassMethods :: Extension
MultiParamTypeClasses :: Extension
NullaryTypeClasses :: Extension
FunctionalDependencies :: Extension
UnicodeSyntax :: Extension
ExistentialQuantification :: Extension
MagicHash :: Extension
EmptyDataDecls :: Extension
KindSignatures :: Extension
RoleAnnotations :: Extension
ParallelListComp :: Extension
TransformListComp :: Extension
MonadComprehensions :: Extension
GeneralizedNewtypeDeriving :: Extension
RecursiveDo :: Extension
PostfixOperators :: Extension
TupleSections :: Extension
PatternGuards :: Extension
LiberalTypeSynonyms :: Extension
RankNTypes :: Extension
ImpredicativeTypes :: Extension
TypeOperators :: Extension
ExplicitNamespaces :: Extension
PackageImports :: Extension
ExplicitForAll :: Extension
AlternativeLayoutRule :: Extension
AlternativeLayoutRuleTransitional :: Extension
DatatypeContexts :: Extension
NondecreasingIndentation :: Extension
RelaxedLayout :: Extension
TraditionalRecordSyntax :: Extension
LambdaCase :: Extension
MultiWayIf :: Extension
BinaryLiterals :: Extension
NegativeLiterals :: Extension
HexFloatLiterals :: Extension
DuplicateRecordFields :: Extension
OverloadedLabels :: Extension
EmptyCase :: Extension
PatternSynonyms :: Extension
PartialTypeSignatures :: Extension
NamedWildCards :: Extension
StaticPointers :: Extension
TypeApplications :: Extension
Strict :: Extension
StrictData :: Extension
EmptyDataDeriving :: Extension
NumericUnderscores :: Extension
QuantifiedConstraints :: Extension
StarIsType :: Extension
ImportQualifiedPost :: Extension
CUSKs :: Extension
StandaloneKindSignatures :: Extension
LexicalNegation :: Extension
FieldSelectors :: Extension
OverloadedRecordDot :: Extension
OverloadedRecordUpdate :: Extension
TypeAbstractions :: Extension
ExtendedLiterals :: Extension
ListTuplePuns :: Extension
MultilineStrings :: Extension
data AnnLookup
AnnLookupModule :: Module -> AnnLookup
AnnLookupName :: Name -> AnnLookup
data AnnTarget
ModuleAnnotation :: AnnTarget
TypeAnnotation :: Name -> AnnTarget
ValueAnnotation :: Name -> AnnTarget
type Arity = Int
data Bang
Bang :: SourceUnpackedness -> SourceStrictness -> Bang
type BangType = (Bang, Type)
data BndrVis
BndrReq :: BndrVis
BndrInvis :: BndrVis
data Body
GuardedB :: [(Guard, Exp)] -> Body
NormalB :: Exp -> Body
data Bytes
Bytes :: ForeignPtr Word8 -> Word -> Word -> Bytes
[bytesPtr] :: Bytes -> ForeignPtr Word8
[bytesOffset] :: Bytes -> Word
[bytesSize] :: Bytes -> Word
data Callconv
CCall :: Callconv
StdCall :: Callconv
CApi :: Callconv
Prim :: Callconv
JavaScript :: Callconv
type CharPos = (Int, Int)
data Clause
Clause :: [Pat] -> Body -> [Dec] -> Clause
newtype Code (m :: Type -> Type) (a :: TYPE r)
Code :: m (TExp a) -> Code (m :: Type -> Type) (a :: TYPE r)
[examineCode] :: Code (m :: Type -> Type) (a :: TYPE r) -> m (TExp a)
data Con
NormalC :: Name -> [BangType] -> Con
RecC :: Name -> [VarBangType] -> Con
InfixC :: BangType -> Name -> BangType -> Con
ForallC :: [TyVarBndr Specificity] -> Cxt -> Con -> Con
GadtC :: [Name] -> [BangType] -> Type -> Con
RecGadtC :: [Name] -> [VarBangType] -> Type -> Con
type Cxt = [Pred]
data Dec
FunD :: Name -> [Clause] -> Dec
ValD :: Pat -> Body -> [Dec] -> Dec
DataD :: Cxt -> Name -> [TyVarBndr BndrVis] -> Maybe Kind -> [Con] -> [DerivClause] -> Dec
NewtypeD :: Cxt -> Name -> [TyVarBndr BndrVis] -> Maybe Kind -> Con -> [DerivClause] -> Dec
TypeDataD :: Name -> [TyVarBndr BndrVis] -> Maybe Kind -> [Con] -> Dec
TySynD :: Name -> [TyVarBndr BndrVis] -> Type -> Dec
ClassD :: Cxt -> Name -> [TyVarBndr BndrVis] -> [FunDep] -> [Dec] -> Dec
InstanceD :: Maybe Overlap -> Cxt -> Type -> [Dec] -> Dec
SigD :: Name -> Type -> Dec
KiSigD :: Name -> Kind -> Dec
ForeignD :: Foreign -> Dec
InfixD :: Fixity -> NamespaceSpecifier -> Name -> Dec
DefaultD :: [Type] -> Dec
PragmaD :: Pragma -> Dec
DataFamilyD :: Name -> [TyVarBndr BndrVis] -> Maybe Kind -> Dec
DataInstD :: Cxt -> Maybe [TyVarBndr ()] -> Type -> Maybe Kind -> [Con] -> [DerivClause] -> Dec
NewtypeInstD :: Cxt -> Maybe [TyVarBndr ()] -> Type -> Maybe Kind -> Con -> [DerivClause] -> Dec
TySynInstD :: TySynEqn -> Dec
OpenTypeFamilyD :: TypeFamilyHead -> Dec
ClosedTypeFamilyD :: TypeFamilyHead -> [TySynEqn] -> Dec
RoleAnnotD :: Name -> [Role] -> Dec
StandaloneDerivD :: Maybe DerivStrategy -> Cxt -> Type -> Dec
DefaultSigD :: Name -> Type -> Dec
PatSynD :: Name -> PatSynArgs -> PatSynDir -> Pat -> Dec
PatSynSigD :: Name -> PatSynType -> Dec
ImplicitParamBindD :: String -> Exp -> Dec
data DecidedStrictness
DecidedLazy :: DecidedStrictness
DecidedStrict :: DecidedStrictness
DecidedUnpack :: DecidedStrictness
data DerivClause
DerivClause :: Maybe DerivStrategy -> Cxt -> DerivClause
data DerivStrategy
StockStrategy :: DerivStrategy
AnyclassStrategy :: DerivStrategy
NewtypeStrategy :: DerivStrategy
ViaStrategy :: Type -> DerivStrategy
data DocLoc
ModuleDoc :: DocLoc
DeclDoc :: Name -> DocLoc
ArgDoc :: Name -> Int -> DocLoc
InstDoc :: Type -> DocLoc
data Exp
VarE :: Name -> Exp
ConE :: Name -> Exp
LitE :: Lit -> Exp
AppE :: Exp -> Exp -> Exp
AppTypeE :: Exp -> Type -> Exp
InfixE :: Maybe Exp -> Exp -> Maybe Exp -> Exp
UInfixE :: Exp -> Exp -> Exp -> Exp
ParensE :: Exp -> Exp
LamE :: [Pat] -> Exp -> Exp
LamCaseE :: [Match] -> Exp
LamCasesE :: [Clause] -> Exp
TupE :: [Maybe Exp] -> Exp
UnboxedTupE :: [Maybe Exp] -> Exp
UnboxedSumE :: Exp -> SumAlt -> SumArity -> Exp
CondE :: Exp -> Exp -> Exp -> Exp
MultiIfE :: [(Guard, Exp)] -> Exp
LetE :: [Dec] -> Exp -> Exp
CaseE :: Exp -> [Match] -> Exp
DoE :: Maybe ModName -> [Stmt] -> Exp
MDoE :: Maybe ModName -> [Stmt] -> Exp
CompE :: [Stmt] -> Exp
ArithSeqE :: Range -> Exp
ListE :: [Exp] -> Exp
SigE :: Exp -> Type -> Exp
RecConE :: Name -> [FieldExp] -> Exp
RecUpdE :: Exp -> [FieldExp] -> Exp
StaticE :: Exp -> Exp
UnboundVarE :: Name -> Exp
LabelE :: String -> Exp
ImplicitParamVarE :: String -> Exp
GetFieldE :: Exp -> String -> Exp
ProjectionE :: NonEmpty String -> Exp
TypedBracketE :: Exp -> Exp
TypedSpliceE :: Exp -> Exp
TypeE :: Type -> Exp
ForallE :: [TyVarBndr Specificity] -> Exp -> Exp
ForallVisE :: [TyVarBndr ()] -> Exp -> Exp
ConstrainedE :: [Exp] -> Exp -> Exp
data FamilyResultSig
NoSig :: FamilyResultSig
KindSig :: Kind -> FamilyResultSig
TyVarSig :: TyVarBndr () -> FamilyResultSig
type FieldExp = (Name, Exp)
type FieldPat = (Name, Pat)
data Fixity
Fixity :: Int -> FixityDirection -> Fixity
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection
data Foreign
ImportF :: Callconv -> Safety -> String -> Name -> Type -> Foreign
ExportF :: Callconv -> String -> Name -> Type -> Foreign
data FunDep
FunDep :: [Name] -> [Name] -> FunDep
data Guard
NormalG :: Exp -> Guard
PatG :: [Stmt] -> Guard
data Info
ClassI :: Dec -> [InstanceDec] -> Info
ClassOpI :: Name -> Type -> ParentName -> Info
TyConI :: Dec -> Info
FamilyI :: Dec -> [InstanceDec] -> Info
PrimTyConI :: Name -> Arity -> Unlifted -> Info
DataConI :: Name -> Type -> ParentName -> Info
PatSynI :: Name -> PatSynType -> Info
VarI :: Name -> Type -> Maybe Dec -> Info
TyVarI :: Name -> Type -> Info
data InjectivityAnn
InjectivityAnn :: Name -> [Name] -> InjectivityAnn
data Inline
NoInline :: Inline
Inline :: Inline
Inlinable :: Inline
type InstanceDec = Dec
type Kind = Type
data Lit
CharL :: Char -> Lit
StringL :: String -> Lit
IntegerL :: Integer -> Lit
RationalL :: Rational -> Lit
IntPrimL :: Integer -> Lit
WordPrimL :: Integer -> Lit
FloatPrimL :: Rational -> Lit
DoublePrimL :: Rational -> Lit
StringPrimL :: [Word8] -> Lit
BytesPrimL :: Bytes -> Lit
CharPrimL :: Char -> Lit
data Loc
Loc :: String -> String -> String -> CharPos -> CharPos -> Loc
[loc_filename] :: Loc -> String
[loc_package] :: Loc -> String
[loc_module] :: Loc -> String
[loc_start] :: Loc -> CharPos
[loc_end] :: Loc -> CharPos
data Match
Match :: Pat -> Body -> [Dec] -> Match
newtype ModName
ModName :: String -> ModName
data Module
Module :: PkgName -> ModName -> Module
data ModuleInfo
ModuleInfo :: [Module] -> ModuleInfo
data Name
Name :: OccName -> NameFlavour -> Name
data NameFlavour
NameS :: NameFlavour
NameQ :: ModName -> NameFlavour
NameU :: !Uniq -> NameFlavour
NameL :: !Uniq -> NameFlavour
NameG :: NameSpace -> PkgName -> ModName -> NameFlavour
data NameIs
Alone :: NameIs
Applied :: NameIs
Infix :: NameIs
data NameSpace
VarName :: NameSpace
DataName :: NameSpace
TcClsName :: NameSpace
FldName :: !String -> NameSpace
[fldParent] :: NameSpace -> !String
data NamespaceSpecifier
NoNamespaceSpecifier :: NamespaceSpecifier
TypeNamespaceSpecifier :: NamespaceSpecifier
DataNamespaceSpecifier :: NamespaceSpecifier
newtype OccName
OccName :: String -> OccName
data Overlap
Overlappable :: Overlap
Overlapping :: Overlap
Overlaps :: Overlap
Incoherent :: Overlap
type ParentName = Name
data Pat
LitP :: Lit -> Pat
VarP :: Name -> Pat
TupP :: [Pat] -> Pat
UnboxedTupP :: [Pat] -> Pat
UnboxedSumP :: Pat -> SumAlt -> SumArity -> Pat
ConP :: Name -> [Type] -> [Pat] -> Pat
InfixP :: Pat -> Name -> Pat -> Pat
UInfixP :: Pat -> Name -> Pat -> Pat
ParensP :: Pat -> Pat
TildeP :: Pat -> Pat
BangP :: Pat -> Pat
AsP :: Name -> Pat -> Pat
WildP :: Pat
RecP :: Name -> [FieldPat] -> Pat
ListP :: [Pat] -> Pat
SigP :: Pat -> Type -> Pat
ViewP :: Exp -> Pat -> Pat
TypeP :: Type -> Pat
InvisP :: Type -> Pat
OrP :: NonEmpty Pat -> Pat
data PatSynArgs
PrefixPatSyn :: [Name] -> PatSynArgs
InfixPatSyn :: Name -> Name -> PatSynArgs
RecordPatSyn :: [Name] -> PatSynArgs
data PatSynDir
Unidir :: PatSynDir
ImplBidir :: PatSynDir
ExplBidir :: [Clause] -> PatSynDir
type PatSynType = Type
data Phases
AllPhases :: Phases
FromPhase :: Int -> Phases
BeforePhase :: Int -> Phases
newtype PkgName
PkgName :: String -> PkgName
data Pragma
InlineP :: Name -> Inline -> RuleMatch -> Phases -> Pragma
OpaqueP :: Name -> Pragma
SpecialiseP :: Name -> Type -> Maybe Inline -> Phases -> Pragma
SpecialiseInstP :: Type -> Pragma
RuleP :: String -> Maybe [TyVarBndr ()] -> [RuleBndr] -> Exp -> Exp -> Phases -> Pragma
AnnP :: AnnTarget -> Exp -> Pragma
LineP :: Int -> String -> Pragma
CompleteP :: [Name] -> Maybe Name -> Pragma
SCCP :: Name -> Maybe String -> Pragma
type Pred = Type
newtype Q a
Q :: (forall (m :: Type -> Type). Quasi m => m a) -> Q a
[unQ] :: Q a -> forall (m :: Type -> Type). Quasi m => m a
class (MonadIO m, MonadFail m) => Quasi (m :: Type -> Type)
qNewName :: Quasi m => String -> m Name
qReport :: Quasi m => Bool -> String -> m ()
qRecover :: Quasi m => m a -> m a -> m a
qLookupName :: Quasi m => Bool -> String -> m (Maybe Name)
qReify :: Quasi m => Name -> m Info
qReifyFixity :: Quasi m => Name -> m (Maybe Fixity)
qReifyType :: Quasi m => Name -> m Type
qReifyInstances :: Quasi m => Name -> [Type] -> m [Dec]
qReifyRoles :: Quasi m => Name -> m [Role]
qReifyAnnotations :: (Quasi m, Data a) => AnnLookup -> m [a]
qReifyModule :: Quasi m => Module -> m ModuleInfo
qReifyConStrictness :: Quasi m => Name -> m [DecidedStrictness]
qLocation :: Quasi m => m Loc
qRunIO :: Quasi m => IO a -> m a
qGetPackageRoot :: Quasi m => m FilePath
qAddDependentFile :: Quasi m => FilePath -> m ()
qAddTempFile :: Quasi m => String -> m FilePath
qAddTopDecls :: Quasi m => [Dec] -> m ()
qAddForeignFilePath :: Quasi m => ForeignSrcLang -> String -> m ()
qAddModFinalizer :: Quasi m => Q () -> m ()
qAddCorePlugin :: Quasi m => String -> m ()
qGetQ :: (Quasi m, Typeable a) => m (Maybe a)
qPutQ :: (Quasi m, Typeable a) => a -> m ()
qIsExtEnabled :: Quasi m => Extension -> m Bool
qExtsEnabled :: Quasi m => m [Extension]
qPutDoc :: Quasi m => DocLoc -> String -> m ()
qGetDoc :: Quasi m => DocLoc -> m (Maybe String)
class Monad m => Quote (m :: Type -> Type)
newName :: Quote m => String -> m Name
data Range
FromR :: Exp -> Range
FromThenR :: Exp -> Exp -> Range
FromToR :: Exp -> Exp -> Range
FromThenToR :: Exp -> Exp -> Exp -> Range
data Role
NominalR :: Role
RepresentationalR :: Role
PhantomR :: Role
InferR :: Role
data RuleBndr
RuleVar :: Name -> RuleBndr
TypedRuleVar :: Name -> Type -> RuleBndr
data RuleMatch
ConLike :: RuleMatch
FunLike :: RuleMatch
data Safety
Unsafe :: Safety
Safe :: Safety
Interruptible :: Safety
data SourceStrictness
NoSourceStrictness :: SourceStrictness
SourceLazy :: SourceStrictness
SourceStrict :: SourceStrictness
data SourceUnpackedness
NoSourceUnpackedness :: SourceUnpackedness
SourceNoUnpack :: SourceUnpackedness
SourceUnpack :: SourceUnpackedness
data Specificity
SpecifiedSpec :: Specificity
InferredSpec :: Specificity
data Stmt
BindS :: Pat -> Exp -> Stmt
LetS :: [Dec] -> Stmt
NoBindS :: Exp -> Stmt
ParS :: [[Stmt]] -> Stmt
RecS :: [Stmt] -> Stmt
type Strict = Bang
type StrictType = BangType
type SumAlt = Int
type SumArity = Int
newtype TExp (a :: TYPE r)
TExp :: Exp -> TExp (a :: TYPE r)
[unType] :: TExp (a :: TYPE r) -> Exp
data TyLit
NumTyLit :: Integer -> TyLit
StrTyLit :: String -> TyLit
CharTyLit :: Char -> TyLit
data TySynEqn
TySynEqn :: Maybe [TyVarBndr ()] -> Type -> Type -> TySynEqn
data TyVarBndr flag
PlainTV :: Name -> flag -> TyVarBndr flag
KindedTV :: Name -> flag -> Kind -> TyVarBndr flag
data Type
ForallT :: [TyVarBndr Specificity] -> Cxt -> Type -> Type
ForallVisT :: [TyVarBndr ()] -> Type -> Type
AppT :: Type -> Type -> Type
AppKindT :: Type -> Kind -> Type
SigT :: Type -> Kind -> Type
VarT :: Name -> Type
ConT :: Name -> Type
PromotedT :: Name -> Type
InfixT :: Type -> Name -> Type -> Type
UInfixT :: Type -> Name -> Type -> Type
PromotedInfixT :: Type -> Name -> Type -> Type
PromotedUInfixT :: Type -> Name -> Type -> Type
ParensT :: Type -> Type
TupleT :: Int -> Type
UnboxedTupleT :: Int -> Type
UnboxedSumT :: SumArity -> Type
ArrowT :: Type
MulArrowT :: Type
EqualityT :: Type
ListT :: Type
PromotedTupleT :: Int -> Type
PromotedNilT :: Type
PromotedConsT :: Type
StarT :: Type
ConstraintT :: Type
LitT :: TyLit -> Type
WildCardT :: Type
ImplicitParamT :: String -> Type -> Type
data TypeFamilyHead
TypeFamilyHead :: Name -> [TyVarBndr BndrVis] -> FamilyResultSig -> Maybe InjectivityAnn -> TypeFamilyHead
type Uniq = Integer
type Unlifted = Bool
type VarBangType = (Name, Bang, Type)
type VarStrictType = VarBangType

-- | The input is a filepath, which if relative is offset by the package
--   root.
makeRelativeToProject :: FilePath -> Q FilePath
dataToExpQ :: (Quote m, Data a) => (forall b. Data b => b -> Maybe (m Exp)) -> a -> m Exp
dataToPatQ :: (Quote m, Data a) => (forall b. Data b => b -> Maybe (m Pat)) -> a -> m Pat
dataToQa :: (Quote m, Data a) => (Name -> k) -> (Lit -> m q) -> (k -> [m q] -> m q) -> (forall b. Data b => b -> Maybe (m q)) -> a -> m q
falseName :: Name
justName :: Name
leftName :: Name
liftData :: (Quote m, Data a) => a -> m Exp
liftString :: Quote m => String -> m Exp
nonemptyName :: Name
nothingName :: Name
rightName :: Name
trueName :: Name
class Lift (t :: TYPE r)
lift :: (Lift t, Quote m) => t -> m Exp
liftTyped :: forall (m :: Type -> Type). (Lift t, Quote m) => t -> Code m t
addrToByteArrayName :: Name
addrToByteArray :: Int -> Addr# -> ByteArray


-- | Language.Haskell.TH.Lib contains lots of useful helper functions for
--   generating and manipulating Template Haskell terms
module Language.Haskell.TH.Lib
type InfoQ = Q Info
type ExpQ = Q Exp
type TExpQ (a :: TYPE r) = Q TExp a
type CodeQ = Code Q
type DecQ = Q Dec
type DecsQ = Q [Dec]
type ConQ = Q Con
type TypeQ = Q Type
type KindQ = Q Kind
type TyLitQ = Q TyLit
type CxtQ = Q Cxt
type PredQ = Q Pred
type DerivClauseQ = Q DerivClause
type MatchQ = Q Match
type ClauseQ = Q Clause
type BodyQ = Q Body
type GuardQ = Q Guard
type StmtQ = Q Stmt
type RangeQ = Q Range
type SourceStrictnessQ = Q SourceStrictness
type SourceUnpackednessQ = Q SourceUnpackedness
type BangQ = Q Bang
type BangTypeQ = Q BangType
type VarBangTypeQ = Q VarBangType
type StrictTypeQ = Q StrictType
type VarStrictTypeQ = Q VarStrictType
type FieldExpQ = Q FieldExp
type PatQ = Q Pat
type FieldPatQ = Q FieldPat
type RuleBndrQ = Q RuleBndr
type TySynEqnQ = Q TySynEqn
type PatSynDirQ = Q PatSynDir
type PatSynArgsQ = Q PatSynArgs
type FamilyResultSigQ = Q FamilyResultSig
type DerivStrategyQ = Q DerivStrategy
type TyVarBndrUnit = TyVarBndr ()
type TyVarBndrSpec = TyVarBndr Specificity
type TyVarBndrVis = TyVarBndr BndrVis
intPrimL :: Integer -> Lit
wordPrimL :: Integer -> Lit
floatPrimL :: Rational -> Lit
doublePrimL :: Rational -> Lit
integerL :: Integer -> Lit
rationalL :: Rational -> Lit
charL :: Char -> Lit
stringL :: String -> Lit
stringPrimL :: [Word8] -> Lit
charPrimL :: Char -> Lit
bytesPrimL :: Bytes -> Lit

-- | Create a Bytes datatype representing raw bytes to be embedded into the
--   program/library binary.
mkBytes :: ForeignPtr Word8 -> Word -> Word -> Bytes
litP :: Quote m => Lit -> m Pat
varP :: Quote m => Name -> m Pat
tupP :: Quote m => [m Pat] -> m Pat
unboxedTupP :: Quote m => [m Pat] -> m Pat
unboxedSumP :: Quote m => m Pat -> SumAlt -> SumArity -> m Pat
conP :: Quote m => Name -> [m Pat] -> m Pat
uInfixP :: Quote m => m Pat -> Name -> m Pat -> m Pat
parensP :: Quote m => m Pat -> m Pat
infixP :: Quote m => m Pat -> Name -> m Pat -> m Pat
tildeP :: Quote m => m Pat -> m Pat
bangP :: Quote m => m Pat -> m Pat
asP :: Quote m => Name -> m Pat -> m Pat
wildP :: Quote m => m Pat
recP :: Quote m => Name -> [m FieldPat] -> m Pat
listP :: Quote m => [m Pat] -> m Pat
sigP :: Quote m => m Pat -> m Type -> m Pat
viewP :: Quote m => m Exp -> m Pat -> m Pat
typeP :: Quote m => m Type -> m Pat
invisP :: Quote m => m Type -> m Pat
fieldPat :: Quote m => Name -> m Pat -> m FieldPat
normalB :: Quote m => m Exp -> m Body
guardedB :: Quote m => [m (Guard, Exp)] -> m Body
normalG :: Quote m => m Exp -> m Guard
normalGE :: Quote m => m Exp -> m Exp -> m (Guard, Exp)
patG :: Quote m => [m Stmt] -> m Guard
patGE :: Quote m => [m Stmt] -> m Exp -> m (Guard, Exp)
match :: Quote m => m Pat -> m Body -> [m Dec] -> m Match
clause :: Quote m => [m Pat] -> m Body -> [m Dec] -> m Clause
dyn :: Quote m => String -> m Exp
varE :: Quote m => Name -> m Exp
unboundVarE :: Quote m => Name -> m Exp
labelE :: Quote m => String -> m Exp
implicitParamVarE :: Quote m => String -> m Exp
conE :: Quote m => Name -> m Exp
litE :: Quote m => Lit -> m Exp
staticE :: Quote m => m Exp -> m Exp
appE :: Quote m => m Exp -> m Exp -> m Exp
appTypeE :: Quote m => m Exp -> m Type -> m Exp
uInfixE :: Quote m => m Exp -> m Exp -> m Exp -> m Exp
parensE :: Quote m => m Exp -> m Exp
infixE :: Quote m => Maybe (m Exp) -> m Exp -> Maybe (m Exp) -> m Exp
infixApp :: Quote m => m Exp -> m Exp -> m Exp -> m Exp
sectionL :: Quote m => m Exp -> m Exp -> m Exp
sectionR :: Quote m => m Exp -> m Exp -> m Exp
lamE :: Quote m => [m Pat] -> m Exp -> m Exp
lam1E :: Quote m => m Pat -> m Exp -> m Exp
lamCaseE :: Quote m => [m Match] -> m Exp
lamCasesE :: Quote m => [m Clause] -> m Exp
tupE :: Quote m => [m Exp] -> m Exp
unboxedTupE :: Quote m => [m Exp] -> m Exp
unboxedSumE :: Quote m => m Exp -> SumAlt -> SumArity -> m Exp
condE :: Quote m => m Exp -> m Exp -> m Exp -> m Exp
multiIfE :: Quote m => [m (Guard, Exp)] -> m Exp
letE :: Quote m => [m Dec] -> m Exp -> m Exp
caseE :: Quote m => m Exp -> [m Match] -> m Exp
appsE :: Quote m => [m Exp] -> m Exp
listE :: Quote m => [m Exp] -> m Exp
sigE :: Quote m => m Exp -> m Type -> m Exp
recConE :: Quote m => Name -> [m (Name, Exp)] -> m Exp
recUpdE :: Quote m => m Exp -> [m (Name, Exp)] -> m Exp
stringE :: Quote m => String -> m Exp
fieldExp :: Quote m => Name -> m Exp -> m (Name, Exp)
getFieldE :: Quote m => m Exp -> String -> m Exp
projectionE :: Quote m => NonEmpty String -> m Exp
typedSpliceE :: Quote m => m Exp -> m Exp
typedBracketE :: Quote m => m Exp -> m Exp
typeE :: Quote m => m Type -> m Exp
forallE :: Quote m => [m (TyVarBndr Specificity)] -> m Exp -> m Exp
forallVisE :: Quote m => [m (TyVarBndr ())] -> m Exp -> m Exp
constrainedE :: Quote m => [m Exp] -> m Exp -> m Exp
fromE :: Quote m => m Exp -> m Exp
fromThenE :: Quote m => m Exp -> m Exp -> m Exp
fromToE :: Quote m => m Exp -> m Exp -> m Exp
fromThenToE :: Quote m => m Exp -> m Exp -> m Exp -> m Exp
arithSeqE :: Quote m => m Range -> m Exp
fromR :: Quote m => m Exp -> m Range
fromThenR :: Quote m => m Exp -> m Exp -> m Range
fromToR :: Quote m => m Exp -> m Exp -> m Range
fromThenToR :: Quote m => m Exp -> m Exp -> m Exp -> m Range
doE :: Quote m => [m Stmt] -> m Exp
mdoE :: Quote m => [m Stmt] -> m Exp
compE :: Quote m => [m Stmt] -> m Exp
bindS :: Quote m => m Pat -> m Exp -> m Stmt
letS :: Quote m => [m Dec] -> m Stmt
noBindS :: Quote m => m Exp -> m Stmt
parS :: Quote m => [[m Stmt]] -> m Stmt
recS :: Quote m => [m Stmt] -> m Stmt
forallT :: Quote m => [TyVarBndr Specificity] -> m Cxt -> m Type -> m Type
forallVisT :: Quote m => [m (TyVarBndr ())] -> m Type -> m Type
varT :: Quote m => Name -> m Type
conT :: Quote m => Name -> m Type
appT :: Quote m => m Type -> m Type -> m Type
appKindT :: Quote m => m Type -> m Kind -> m Type
arrowT :: Quote m => m Type
mulArrowT :: Quote m => m Type
infixT :: Quote m => m Type -> Name -> m Type -> m Type
uInfixT :: Quote m => m Type -> Name -> m Type -> m Type
promotedInfixT :: Quote m => m Type -> Name -> m Type -> m Type
promotedUInfixT :: Quote m => m Type -> Name -> m Type -> m Type
parensT :: Quote m => m Type -> m Type
equalityT :: Quote m => m Type
listT :: Quote m => m Type
tupleT :: Quote m => Int -> m Type
unboxedTupleT :: Quote m => Int -> m Type
unboxedSumT :: Quote m => SumArity -> m Type
sigT :: Quote m => m Type -> Kind -> m Type
litT :: Quote m => m TyLit -> m Type
wildCardT :: Quote m => m Type
promotedT :: Quote m => Name -> m Type
promotedTupleT :: Quote m => Int -> m Type
promotedNilT :: Quote m => m Type
promotedConsT :: Quote m => m Type
implicitParamT :: Quote m => String -> m Type -> m Type
numTyLit :: Quote m => Integer -> m TyLit
strTyLit :: Quote m => String -> m TyLit
charTyLit :: Quote m => Char -> m TyLit
noSourceUnpackedness :: Quote m => m SourceUnpackedness
sourceNoUnpack :: Quote m => m SourceUnpackedness
sourceUnpack :: Quote m => m SourceUnpackedness
noSourceStrictness :: Quote m => m SourceStrictness
sourceLazy :: Quote m => m SourceStrictness
sourceStrict :: Quote m => m SourceStrictness
isStrict :: Quote m => m Strict
notStrict :: Quote m => m Strict
unpacked :: Quote m => m Strict
bang :: Quote m => m SourceUnpackedness -> m SourceStrictness -> m Bang
bangType :: Quote m => m Bang -> m Type -> m BangType
varBangType :: Quote m => Name -> m BangType -> m VarBangType
strictType :: Quote m => m Strict -> m Type -> m StrictType
varStrictType :: Quote m => Name -> m StrictType -> m VarStrictType
cxt :: Quote m => [m Pred] -> m Cxt
classP :: Quote m => Name -> [m Type] -> m Pred
equalP :: Quote m => m Type -> m Type -> m Pred
normalC :: Quote m => Name -> [m BangType] -> m Con
recC :: Quote m => Name -> [m VarBangType] -> m Con
infixC :: Quote m => m (Bang, Type) -> Name -> m (Bang, Type) -> m Con
forallC :: Quote m => [TyVarBndr Specificity] -> m Cxt -> m Con -> m Con
gadtC :: Quote m => [Name] -> [m StrictType] -> m Type -> m Con
recGadtC :: Quote m => [Name] -> [m VarStrictType] -> m Type -> m Con
varK :: Name -> Kind
conK :: Name -> Kind
tupleK :: Int -> Kind
arrowK :: Kind
listK :: Kind
appK :: Kind -> Kind -> Kind
starK :: Kind
constraintK :: Kind
class DefaultBndrFlag flag
defaultBndrFlag :: DefaultBndrFlag flag => flag
plainTV :: DefaultBndrFlag flag => Name -> TyVarBndr flag
kindedTV :: DefaultBndrFlag flag => Name -> Kind -> TyVarBndr flag
plainInvisTV :: Quote m => Name -> Specificity -> m (TyVarBndr Specificity)
kindedInvisTV :: Quote m => Name -> Specificity -> m Kind -> m (TyVarBndr Specificity)
plainBndrTV :: Quote m => Name -> BndrVis -> m (TyVarBndr BndrVis)
kindedBndrTV :: Quote m => Name -> BndrVis -> m Kind -> m (TyVarBndr BndrVis)
specifiedSpec :: Specificity
inferredSpec :: Specificity
bndrReq :: BndrVis
bndrInvis :: BndrVis
nominalR :: Role
representationalR :: Role
phantomR :: Role
inferR :: Role
valD :: Quote m => m Pat -> m Body -> [m Dec] -> m Dec
funD :: Quote m => Name -> [m Clause] -> m Dec
tySynD :: Quote m => Name -> [TyVarBndr BndrVis] -> m Type -> m Dec
dataD :: Quote m => m Cxt -> Name -> [TyVarBndr BndrVis] -> Maybe Kind -> [m Con] -> [m DerivClause] -> m Dec
newtypeD :: Quote m => m Cxt -> Name -> [TyVarBndr BndrVis] -> Maybe Kind -> m Con -> [m DerivClause] -> m Dec
typeDataD :: Quote m => Name -> [TyVarBndr BndrVis] -> Maybe Kind -> [m Con] -> m Dec
derivClause :: Quote m => Maybe DerivStrategy -> [m Pred] -> m DerivClause
data DerivClause
DerivClause :: Maybe DerivStrategy -> Cxt -> DerivClause
stockStrategy :: Quote m => m DerivStrategy
anyclassStrategy :: Quote m => m DerivStrategy
newtypeStrategy :: Quote m => m DerivStrategy
viaStrategy :: Quote m => m Type -> m DerivStrategy
data DerivStrategy
StockStrategy :: DerivStrategy
AnyclassStrategy :: DerivStrategy
NewtypeStrategy :: DerivStrategy
ViaStrategy :: Type -> DerivStrategy
classD :: Quote m => m Cxt -> Name -> [TyVarBndr BndrVis] -> [FunDep] -> [m Dec] -> m Dec
instanceD :: Quote m => m Cxt -> m Type -> [m Dec] -> m Dec
instanceWithOverlapD :: Quote m => Maybe Overlap -> m Cxt -> m Type -> [m Dec] -> m Dec
data Overlap
Overlappable :: Overlap
Overlapping :: Overlap
Overlaps :: Overlap
Incoherent :: Overlap
sigD :: Quote m => Name -> m Type -> m Dec
kiSigD :: Quote m => Name -> m Kind -> m Dec
standaloneDerivD :: Quote m => m Cxt -> m Type -> m Dec
standaloneDerivWithStrategyD :: Quote m => Maybe DerivStrategy -> m Cxt -> m Type -> m Dec
defaultSigD :: Quote m => Name -> m Type -> m Dec
roleAnnotD :: Quote m => Name -> [Role] -> m Dec
dataFamilyD :: Quote m => Name -> [TyVarBndr BndrVis] -> Maybe Kind -> m Dec
openTypeFamilyD :: Quote m => Name -> [TyVarBndr BndrVis] -> FamilyResultSig -> Maybe InjectivityAnn -> m Dec
closedTypeFamilyD :: Quote m => Name -> [TyVarBndr BndrVis] -> FamilyResultSig -> Maybe InjectivityAnn -> [m TySynEqn] -> m Dec
dataInstD :: Quote m => m Cxt -> Name -> [m Type] -> Maybe Kind -> [m Con] -> [m DerivClause] -> m Dec
newtypeInstD :: Quote m => m Cxt -> Name -> [m Type] -> Maybe Kind -> m Con -> [m DerivClause] -> m Dec
tySynInstD :: Quote m => m TySynEqn -> m Dec
tySynEqn :: Quote m => Maybe [TyVarBndr ()] -> m Type -> m Type -> m TySynEqn
injectivityAnn :: Name -> [Name] -> InjectivityAnn
noSig :: FamilyResultSig
kindSig :: Kind -> FamilyResultSig
tyVarSig :: TyVarBndr () -> FamilyResultSig
infixLD :: Quote m => Int -> Name -> m Dec
infixRD :: Quote m => Int -> Name -> m Dec
infixND :: Quote m => Int -> Name -> m Dec
defaultD :: Quote m => [m Type] -> m Dec
cCall :: Callconv
stdCall :: Callconv
cApi :: Callconv
prim :: Callconv
javaScript :: Callconv
unsafe :: Safety
safe :: Safety
interruptible :: Safety
forImpD :: Quote m => Callconv -> Safety -> String -> Name -> m Type -> m Dec
funDep :: [Name] -> [Name] -> FunDep
ruleVar :: Quote m => Name -> m RuleBndr
typedRuleVar :: Quote m => Name -> m Type -> m RuleBndr
valueAnnotation :: Name -> AnnTarget
typeAnnotation :: Name -> AnnTarget
moduleAnnotation :: AnnTarget
pragInlD :: Quote m => Name -> Inline -> RuleMatch -> Phases -> m Dec
pragSpecD :: Quote m => Name -> m Type -> Phases -> m Dec
pragSpecInlD :: Quote m => Name -> m Type -> Inline -> Phases -> m Dec
pragSpecInstD :: Quote m => m Type -> m Dec
pragRuleD :: Quote m => String -> [m RuleBndr] -> m Exp -> m Exp -> Phases -> m Dec
pragAnnD :: Quote m => AnnTarget -> m Exp -> m Dec
pragLineD :: Quote m => Int -> String -> m Dec
pragCompleteD :: Quote m => [Name] -> Maybe Name -> m Dec
patSynD :: Quote m => Name -> m PatSynArgs -> m PatSynDir -> m Pat -> m Dec
patSynSigD :: Quote m => Name -> m Type -> m Dec
unidir :: Quote m => m PatSynDir
implBidir :: Quote m => m PatSynDir
explBidir :: Quote m => [m Clause] -> m PatSynDir
prefixPatSyn :: Quote m => [Name] -> m PatSynArgs
infixPatSyn :: Quote m => Name -> Name -> m PatSynArgs
recordPatSyn :: Quote m => [Name] -> m PatSynArgs
implicitParamBindD :: Quote m => String -> m Exp -> m Dec
thisModule :: Q Module
withDecDoc :: String -> Q Dec -> Q Dec
withDecsDoc :: String -> Q [Dec] -> Q [Dec]
funD_doc :: Name -> [Q Clause] -> Maybe String -> [Maybe String] -> Q Dec
dataD_doc :: Q Cxt -> Name -> [Q (TyVarBndr BndrVis)] -> Maybe (Q Kind) -> [(Q Con, Maybe String, [Maybe String])] -> [Q DerivClause] -> Maybe String -> Q Dec
newtypeD_doc :: Q Cxt -> Name -> [Q (TyVarBndr BndrVis)] -> Maybe (Q Kind) -> (Q Con, Maybe String, [Maybe String]) -> [Q DerivClause] -> Maybe String -> Q Dec
typeDataD_doc :: Name -> [Q (TyVarBndr BndrVis)] -> Maybe (Q Kind) -> [(Q Con, Maybe String, [Maybe String])] -> Maybe String -> Q Dec
dataInstD_doc :: Q Cxt -> Maybe [Q (TyVarBndr ())] -> Q Type -> Maybe (Q Kind) -> [(Q Con, Maybe String, [Maybe String])] -> [Q DerivClause] -> Maybe String -> Q Dec
newtypeInstD_doc :: Q Cxt -> Maybe [Q (TyVarBndr ())] -> Q Type -> Maybe (Q Kind) -> (Q Con, Maybe String, [Maybe String]) -> [Q DerivClause] -> Maybe String -> Q Dec
patSynD_doc :: Name -> Q PatSynArgs -> Q PatSynDir -> Q Pat -> Maybe String -> [Maybe String] -> Q Dec
instance Language.Haskell.TH.Lib.DefaultBndrFlag GHC.Internal.TH.Syntax.BndrVis
instance Language.Haskell.TH.Lib.DefaultBndrFlag GHC.Internal.TH.Syntax.Specificity
instance Language.Haskell.TH.Lib.DefaultBndrFlag ()


-- | This module exists to work nicely with the QualifiedDo extension.
--   
--   <pre>
--   import qualified Language.Haskell.TH.CodeDo as Code
--   
--   myExample :: Monad m =&gt; Code m a -&gt; Code m a -&gt; Code m a
--   myExample opt1 opt2 =
--     Code.do
--      x &lt;- someSideEffect               -- This one is of type `M Bool`
--      if x then opt1 else opt2
--   </pre>
module Language.Haskell.TH.CodeDo

-- | Module over monad operator for <a>Code</a>
(>>=) :: Monad m => m a -> (a -> Code m b) -> Code m b
(>>) :: Monad m => m a -> Code m b -> Code m b


-- | The public face of Template Haskell
--   
--   For other documentation, refer to:
--   <a>https://wiki.haskell.org/Template_Haskell</a>
module Language.Haskell.TH
data Q a
runQ :: Quasi m => Q a -> m a
class Monad m => Quote (m :: Type -> Type)
newName :: Quote m => String -> m Name
reportError :: String -> Q ()
reportWarning :: String -> Q ()
report :: Bool -> String -> Q ()
recover :: Q a -> Q a -> Q a
location :: Q Loc
data Loc
Loc :: String -> String -> String -> CharPos -> CharPos -> Loc
[loc_filename] :: Loc -> String
[loc_package] :: Loc -> String
[loc_module] :: Loc -> String
[loc_start] :: Loc -> CharPos
[loc_end] :: Loc -> CharPos
runIO :: IO a -> Q a
reify :: Name -> Q Info
reifyModule :: Module -> Q ModuleInfo
newDeclarationGroup :: Q [Dec]
data Info
ClassI :: Dec -> [InstanceDec] -> Info
ClassOpI :: Name -> Type -> ParentName -> Info
TyConI :: Dec -> Info
FamilyI :: Dec -> [InstanceDec] -> Info
PrimTyConI :: Name -> Arity -> Unlifted -> Info
DataConI :: Name -> Type -> ParentName -> Info
PatSynI :: Name -> PatSynType -> Info
VarI :: Name -> Type -> Maybe Dec -> Info
TyVarI :: Name -> Type -> Info
data ModuleInfo
ModuleInfo :: [Module] -> ModuleInfo
type InstanceDec = Dec
type ParentName = Name
type SumAlt = Int
type SumArity = Int
type Arity = Int
type Unlifted = Bool
data Extension
Cpp :: Extension
OverlappingInstances :: Extension
UndecidableInstances :: Extension
IncoherentInstances :: Extension
UndecidableSuperClasses :: Extension
MonomorphismRestriction :: Extension
MonoLocalBinds :: Extension
DeepSubsumption :: Extension
RelaxedPolyRec :: Extension
ExtendedDefaultRules :: Extension
NamedDefaults :: Extension
ForeignFunctionInterface :: Extension
UnliftedFFITypes :: Extension
InterruptibleFFI :: Extension
CApiFFI :: Extension
GHCForeignImportPrim :: Extension
JavaScriptFFI :: Extension
ParallelArrays :: Extension
Arrows :: Extension
TemplateHaskell :: Extension
TemplateHaskellQuotes :: Extension
QualifiedDo :: Extension
QuasiQuotes :: Extension
ImplicitParams :: Extension
ImplicitPrelude :: Extension
ScopedTypeVariables :: Extension
AllowAmbiguousTypes :: Extension
UnboxedTuples :: Extension
UnboxedSums :: Extension
UnliftedNewtypes :: Extension
UnliftedDatatypes :: Extension
BangPatterns :: Extension
TypeFamilies :: Extension
TypeFamilyDependencies :: Extension
TypeInType :: Extension
OverloadedStrings :: Extension
OverloadedLists :: Extension
NumDecimals :: Extension
DisambiguateRecordFields :: Extension
RecordWildCards :: Extension
NamedFieldPuns :: Extension
ViewPatterns :: Extension
OrPatterns :: Extension
GADTs :: Extension
GADTSyntax :: Extension
NPlusKPatterns :: Extension
DoAndIfThenElse :: Extension
BlockArguments :: Extension
RebindableSyntax :: Extension
ConstraintKinds :: Extension
PolyKinds :: Extension
DataKinds :: Extension
TypeData :: Extension
InstanceSigs :: Extension
ApplicativeDo :: Extension
LinearTypes :: Extension
RequiredTypeArguments :: Extension
StandaloneDeriving :: Extension
DeriveDataTypeable :: Extension
AutoDeriveTypeable :: Extension
DeriveFunctor :: Extension
DeriveTraversable :: Extension
DeriveFoldable :: Extension
DeriveGeneric :: Extension
DefaultSignatures :: Extension
DeriveAnyClass :: Extension
DeriveLift :: Extension
DerivingStrategies :: Extension
DerivingVia :: Extension
TypeSynonymInstances :: Extension
FlexibleContexts :: Extension
FlexibleInstances :: Extension
ConstrainedClassMethods :: Extension
MultiParamTypeClasses :: Extension
NullaryTypeClasses :: Extension
FunctionalDependencies :: Extension
UnicodeSyntax :: Extension
ExistentialQuantification :: Extension
MagicHash :: Extension
EmptyDataDecls :: Extension
KindSignatures :: Extension
RoleAnnotations :: Extension
ParallelListComp :: Extension
TransformListComp :: Extension
MonadComprehensions :: Extension
GeneralizedNewtypeDeriving :: Extension
RecursiveDo :: Extension
PostfixOperators :: Extension
TupleSections :: Extension
PatternGuards :: Extension
LiberalTypeSynonyms :: Extension
RankNTypes :: Extension
ImpredicativeTypes :: Extension
TypeOperators :: Extension
ExplicitNamespaces :: Extension
PackageImports :: Extension
ExplicitForAll :: Extension
AlternativeLayoutRule :: Extension
AlternativeLayoutRuleTransitional :: Extension
DatatypeContexts :: Extension
NondecreasingIndentation :: Extension
RelaxedLayout :: Extension
TraditionalRecordSyntax :: Extension
LambdaCase :: Extension
MultiWayIf :: Extension
BinaryLiterals :: Extension
NegativeLiterals :: Extension
HexFloatLiterals :: Extension
DuplicateRecordFields :: Extension
OverloadedLabels :: Extension
EmptyCase :: Extension
PatternSynonyms :: Extension
PartialTypeSignatures :: Extension
NamedWildCards :: Extension
StaticPointers :: Extension
TypeApplications :: Extension
Strict :: Extension
StrictData :: Extension
EmptyDataDeriving :: Extension
NumericUnderscores :: Extension
QuantifiedConstraints :: Extension
StarIsType :: Extension
ImportQualifiedPost :: Extension
CUSKs :: Extension
StandaloneKindSignatures :: Extension
LexicalNegation :: Extension
FieldSelectors :: Extension
OverloadedRecordDot :: Extension
OverloadedRecordUpdate :: Extension
TypeAbstractions :: Extension
ExtendedLiterals :: Extension
ListTuplePuns :: Extension
MultilineStrings :: Extension
extsEnabled :: Q [Extension]
isExtEnabled :: Extension -> Q Bool
lookupTypeName :: String -> Q (Maybe Name)
lookupValueName :: String -> Q (Maybe Name)
reifyFixity :: Name -> Q (Maybe Fixity)
reifyType :: Name -> Q Type
reifyInstances :: Name -> [Type] -> Q [InstanceDec]
isInstance :: Name -> [Type] -> Q Bool
reifyRoles :: Name -> Q [Role]
reifyAnnotations :: Data a => AnnLookup -> Q [a]
data AnnLookup
AnnLookupModule :: Module -> AnnLookup
AnnLookupName :: Name -> AnnLookup
reifyConStrictness :: Name -> Q [DecidedStrictness]
data TExp (a :: TYPE r)
unType :: TExp a -> Exp
newtype Code (m :: Type -> Type) (a :: TYPE r)
Code :: m (TExp a) -> Code (m :: Type -> Type) (a :: TYPE r)
[examineCode] :: Code (m :: Type -> Type) (a :: TYPE r) -> m (TExp a)
unTypeCode :: forall a m. Quote m => Code m a -> m Exp
unsafeCodeCoerce :: forall a m. Quote m => m Exp -> Code m a
hoistCode :: Monad m => (forall x. () => m x -> n x) -> Code m a -> Code n a
bindCode :: Monad m => m a -> (a -> Code m b) -> Code m b
bindCode_ :: Monad m => m a -> Code m b -> Code m b
joinCode :: Monad m => m (Code m a) -> Code m a
liftCode :: forall a m. m (TExp a) -> Code m a
data Name
data NameSpace
mkName :: String -> Name
nameBase :: Name -> String
nameModule :: Name -> Maybe String
namePackage :: Name -> Maybe String
nameSpace :: Name -> Maybe NameSpace
tupleTypeName :: Int -> Name
tupleDataName :: Int -> Name
unboxedTupleTypeName :: Int -> Name
unboxedTupleDataName :: Int -> Name
unboxedSumTypeName :: SumArity -> Name
unboxedSumDataName :: SumAlt -> SumArity -> Name
data Dec
FunD :: Name -> [Clause] -> Dec
ValD :: Pat -> Body -> [Dec] -> Dec
DataD :: Cxt -> Name -> [TyVarBndr BndrVis] -> Maybe Kind -> [Con] -> [DerivClause] -> Dec
NewtypeD :: Cxt -> Name -> [TyVarBndr BndrVis] -> Maybe Kind -> Con -> [DerivClause] -> Dec
TypeDataD :: Name -> [TyVarBndr BndrVis] -> Maybe Kind -> [Con] -> Dec
TySynD :: Name -> [TyVarBndr BndrVis] -> Type -> Dec
ClassD :: Cxt -> Name -> [TyVarBndr BndrVis] -> [FunDep] -> [Dec] -> Dec
InstanceD :: Maybe Overlap -> Cxt -> Type -> [Dec] -> Dec
SigD :: Name -> Type -> Dec
KiSigD :: Name -> Kind -> Dec
ForeignD :: Foreign -> Dec
InfixD :: Fixity -> NamespaceSpecifier -> Name -> Dec
DefaultD :: [Type] -> Dec
PragmaD :: Pragma -> Dec
DataFamilyD :: Name -> [TyVarBndr BndrVis] -> Maybe Kind -> Dec
DataInstD :: Cxt -> Maybe [TyVarBndr ()] -> Type -> Maybe Kind -> [Con] -> [DerivClause] -> Dec
NewtypeInstD :: Cxt -> Maybe [TyVarBndr ()] -> Type -> Maybe Kind -> Con -> [DerivClause] -> Dec
TySynInstD :: TySynEqn -> Dec
OpenTypeFamilyD :: TypeFamilyHead -> Dec
ClosedTypeFamilyD :: TypeFamilyHead -> [TySynEqn] -> Dec
RoleAnnotD :: Name -> [Role] -> Dec
StandaloneDerivD :: Maybe DerivStrategy -> Cxt -> Type -> Dec
DefaultSigD :: Name -> Type -> Dec
PatSynD :: Name -> PatSynArgs -> PatSynDir -> Pat -> Dec
PatSynSigD :: Name -> PatSynType -> Dec
ImplicitParamBindD :: String -> Exp -> Dec
data Con
NormalC :: Name -> [BangType] -> Con
RecC :: Name -> [VarBangType] -> Con
InfixC :: BangType -> Name -> BangType -> Con
ForallC :: [TyVarBndr Specificity] -> Cxt -> Con -> Con
GadtC :: [Name] -> [BangType] -> Type -> Con
RecGadtC :: [Name] -> [VarBangType] -> Type -> Con
data Clause
Clause :: [Pat] -> Body -> [Dec] -> Clause
data SourceUnpackedness
NoSourceUnpackedness :: SourceUnpackedness
SourceNoUnpack :: SourceUnpackedness
SourceUnpack :: SourceUnpackedness
data SourceStrictness
NoSourceStrictness :: SourceStrictness
SourceLazy :: SourceStrictness
SourceStrict :: SourceStrictness
data DecidedStrictness
DecidedLazy :: DecidedStrictness
DecidedStrict :: DecidedStrictness
DecidedUnpack :: DecidedStrictness
data Bang
Bang :: SourceUnpackedness -> SourceStrictness -> Bang
type Strict = Bang
data Foreign
ImportF :: Callconv -> Safety -> String -> Name -> Type -> Foreign
ExportF :: Callconv -> String -> Name -> Type -> Foreign
data Callconv
CCall :: Callconv
StdCall :: Callconv
CApi :: Callconv
Prim :: Callconv
JavaScript :: Callconv
data Safety
Unsafe :: Safety
Safe :: Safety
Interruptible :: Safety
data Pragma
InlineP :: Name -> Inline -> RuleMatch -> Phases -> Pragma
OpaqueP :: Name -> Pragma
SpecialiseP :: Name -> Type -> Maybe Inline -> Phases -> Pragma
SpecialiseInstP :: Type -> Pragma
RuleP :: String -> Maybe [TyVarBndr ()] -> [RuleBndr] -> Exp -> Exp -> Phases -> Pragma
AnnP :: AnnTarget -> Exp -> Pragma
LineP :: Int -> String -> Pragma
CompleteP :: [Name] -> Maybe Name -> Pragma
SCCP :: Name -> Maybe String -> Pragma
data Inline
NoInline :: Inline
Inline :: Inline
Inlinable :: Inline
data RuleMatch
ConLike :: RuleMatch
FunLike :: RuleMatch
data Phases
AllPhases :: Phases
FromPhase :: Int -> Phases
BeforePhase :: Int -> Phases
data RuleBndr
RuleVar :: Name -> RuleBndr
TypedRuleVar :: Name -> Type -> RuleBndr
data AnnTarget
ModuleAnnotation :: AnnTarget
TypeAnnotation :: Name -> AnnTarget
ValueAnnotation :: Name -> AnnTarget
data FunDep
FunDep :: [Name] -> [Name] -> FunDep
data TySynEqn
TySynEqn :: Maybe [TyVarBndr ()] -> Type -> Type -> TySynEqn
data TypeFamilyHead
TypeFamilyHead :: Name -> [TyVarBndr BndrVis] -> FamilyResultSig -> Maybe InjectivityAnn -> TypeFamilyHead
data Fixity
Fixity :: Int -> FixityDirection -> Fixity
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection
data NamespaceSpecifier
NoNamespaceSpecifier :: NamespaceSpecifier
TypeNamespaceSpecifier :: NamespaceSpecifier
DataNamespaceSpecifier :: NamespaceSpecifier
defaultFixity :: Fixity
maxPrecedence :: Int
data PatSynDir
Unidir :: PatSynDir
ImplBidir :: PatSynDir
ExplBidir :: [Clause] -> PatSynDir
data PatSynArgs
PrefixPatSyn :: [Name] -> PatSynArgs
InfixPatSyn :: Name -> Name -> PatSynArgs
RecordPatSyn :: [Name] -> PatSynArgs
data Exp
VarE :: Name -> Exp
ConE :: Name -> Exp
LitE :: Lit -> Exp
AppE :: Exp -> Exp -> Exp
AppTypeE :: Exp -> Type -> Exp
InfixE :: Maybe Exp -> Exp -> Maybe Exp -> Exp
UInfixE :: Exp -> Exp -> Exp -> Exp
ParensE :: Exp -> Exp
LamE :: [Pat] -> Exp -> Exp
LamCaseE :: [Match] -> Exp
LamCasesE :: [Clause] -> Exp
TupE :: [Maybe Exp] -> Exp
UnboxedTupE :: [Maybe Exp] -> Exp
UnboxedSumE :: Exp -> SumAlt -> SumArity -> Exp
CondE :: Exp -> Exp -> Exp -> Exp
MultiIfE :: [(Guard, Exp)] -> Exp
LetE :: [Dec] -> Exp -> Exp
CaseE :: Exp -> [Match] -> Exp
DoE :: Maybe ModName -> [Stmt] -> Exp
MDoE :: Maybe ModName -> [Stmt] -> Exp
CompE :: [Stmt] -> Exp
ArithSeqE :: Range -> Exp
ListE :: [Exp] -> Exp
SigE :: Exp -> Type -> Exp
RecConE :: Name -> [FieldExp] -> Exp
RecUpdE :: Exp -> [FieldExp] -> Exp
StaticE :: Exp -> Exp
UnboundVarE :: Name -> Exp
LabelE :: String -> Exp
ImplicitParamVarE :: String -> Exp
GetFieldE :: Exp -> String -> Exp
ProjectionE :: NonEmpty String -> Exp
TypedBracketE :: Exp -> Exp
TypedSpliceE :: Exp -> Exp
TypeE :: Type -> Exp
ForallE :: [TyVarBndr Specificity] -> Exp -> Exp
ForallVisE :: [TyVarBndr ()] -> Exp -> Exp
ConstrainedE :: [Exp] -> Exp -> Exp
data Match
Match :: Pat -> Body -> [Dec] -> Match
data Body
GuardedB :: [(Guard, Exp)] -> Body
NormalB :: Exp -> Body
data Guard
NormalG :: Exp -> Guard
PatG :: [Stmt] -> Guard
data Stmt
BindS :: Pat -> Exp -> Stmt
LetS :: [Dec] -> Stmt
NoBindS :: Exp -> Stmt
ParS :: [[Stmt]] -> Stmt
RecS :: [Stmt] -> Stmt
data Range
FromR :: Exp -> Range
FromThenR :: Exp -> Exp -> Range
FromToR :: Exp -> Exp -> Range
FromThenToR :: Exp -> Exp -> Exp -> Range
data Lit
CharL :: Char -> Lit
StringL :: String -> Lit
IntegerL :: Integer -> Lit
RationalL :: Rational -> Lit
IntPrimL :: Integer -> Lit
WordPrimL :: Integer -> Lit
FloatPrimL :: Rational -> Lit
DoublePrimL :: Rational -> Lit
StringPrimL :: [Word8] -> Lit
BytesPrimL :: Bytes -> Lit
CharPrimL :: Char -> Lit
data Pat
LitP :: Lit -> Pat
VarP :: Name -> Pat
TupP :: [Pat] -> Pat
UnboxedTupP :: [Pat] -> Pat
UnboxedSumP :: Pat -> SumAlt -> SumArity -> Pat
ConP :: Name -> [Type] -> [Pat] -> Pat
InfixP :: Pat -> Name -> Pat -> Pat
UInfixP :: Pat -> Name -> Pat -> Pat
ParensP :: Pat -> Pat
TildeP :: Pat -> Pat
BangP :: Pat -> Pat
AsP :: Name -> Pat -> Pat
WildP :: Pat
RecP :: Name -> [FieldPat] -> Pat
ListP :: [Pat] -> Pat
SigP :: Pat -> Type -> Pat
ViewP :: Exp -> Pat -> Pat
TypeP :: Type -> Pat
InvisP :: Type -> Pat
OrP :: NonEmpty Pat -> Pat
type FieldExp = (Name, Exp)
type FieldPat = (Name, Pat)
data Type
ForallT :: [TyVarBndr Specificity] -> Cxt -> Type -> Type
ForallVisT :: [TyVarBndr ()] -> Type -> Type
AppT :: Type -> Type -> Type
AppKindT :: Type -> Kind -> Type
SigT :: Type -> Kind -> Type
VarT :: Name -> Type
ConT :: Name -> Type
PromotedT :: Name -> Type
InfixT :: Type -> Name -> Type -> Type
UInfixT :: Type -> Name -> Type -> Type
PromotedInfixT :: Type -> Name -> Type -> Type
PromotedUInfixT :: Type -> Name -> Type -> Type
ParensT :: Type -> Type
TupleT :: Int -> Type
UnboxedTupleT :: Int -> Type
UnboxedSumT :: SumArity -> Type
ArrowT :: Type
MulArrowT :: Type
EqualityT :: Type
ListT :: Type
PromotedTupleT :: Int -> Type
PromotedNilT :: Type
PromotedConsT :: Type
StarT :: Type
ConstraintT :: Type
LitT :: TyLit -> Type
WildCardT :: Type
ImplicitParamT :: String -> Type -> Type
data TyVarBndr flag
PlainTV :: Name -> flag -> TyVarBndr flag
KindedTV :: Name -> flag -> Kind -> TyVarBndr flag
data TyLit
NumTyLit :: Integer -> TyLit
StrTyLit :: String -> TyLit
CharTyLit :: Char -> TyLit
type Kind = Type
type Cxt = [Pred]
type Pred = Type
data Role
NominalR :: Role
RepresentationalR :: Role
PhantomR :: Role
InferR :: Role
data Specificity
SpecifiedSpec :: Specificity
InferredSpec :: Specificity
data BndrVis
BndrReq :: BndrVis
BndrInvis :: BndrVis
data FamilyResultSig
NoSig :: FamilyResultSig
KindSig :: Kind -> FamilyResultSig
TyVarSig :: TyVarBndr () -> FamilyResultSig
data InjectivityAnn
InjectivityAnn :: Name -> [Name] -> InjectivityAnn
type PatSynType = Type
type BangType = (Bang, Type)
type VarBangType = (Name, Bang, Type)
putDoc :: DocLoc -> String -> Q ()
getDoc :: DocLoc -> Q (Maybe String)
data DocLoc
ModuleDoc :: DocLoc
DeclDoc :: Name -> DocLoc
ArgDoc :: Name -> Int -> DocLoc
InstDoc :: Type -> DocLoc
class Ppr a
ppr :: Ppr a => a -> Doc
ppr_list :: Ppr a => [a] -> Doc
pprint :: Ppr a => a -> String
pprExp :: Precedence -> Exp -> Doc
pprLit :: Precedence -> Lit -> Doc
pprPat :: Precedence -> Pat -> Doc
pprParendType :: Type -> Doc
