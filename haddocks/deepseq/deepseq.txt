-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Deep evaluation of data structures
--   
--   This package provides methods for fully evaluating data structures
--   ("deep evaluation"). Deep evaluation is often used for adding
--   strictness to a program, e.g. in order to force pending exceptions,
--   remove space leaks, or force lazy I/O to happen. It is also useful in
--   parallel programs, to ensure pending work does not migrate to the
--   wrong thread.
--   
--   The primary use of this package is via the <a>deepseq</a> function, a
--   "deep" version of <a>seq</a>. It is implemented on top of an
--   <a>NFData</a> typeclass ("Normal Form Data", data structures with no
--   unevaluated components) which defines strategies for fully evaluating
--   different data types. See module documentation in
--   <a>Control.DeepSeq</a> for more details.
@package deepseq
@version 1.5.1.0


-- | This module provides overloaded functions, such as <a>deepseq</a> and
--   <a>rnf</a>, for fully evaluating data structures (that is, evaluating
--   to "Normal Form").
--   
--   A typical use is to prevent resource leaks in lazy IO programs, by
--   forcing all characters from a file to be read. For example:
--   
--   <pre>
--   import System.IO
--   import Control.DeepSeq
--   import Control.Exception (evaluate)
--   
--   readFile' :: FilePath -&gt; IO String
--   readFile' fn = do
--       h &lt;- openFile fn ReadMode
--       s &lt;- hGetContents h
--       evaluate (rnf s)
--       hClose h
--       return s
--   </pre>
--   
--   <b>Note</b>: The example above should rather be written in terms of
--   <a>bracket</a> to ensure releasing file-descriptors in a timely matter
--   (see the description of <a>force</a> for an example).
--   
--   <a>deepseq</a> differs from <a>seq</a> as it traverses data structures
--   deeply, for example, <a>seq</a> will evaluate only to the first
--   constructor in the list:
--   
--   <pre>
--   &gt; [1,2,undefined] `seq` 3
--   3
--   </pre>
--   
--   While <a>deepseq</a> will force evaluation of all the list elements:
--   
--   <pre>
--   &gt; [1,2,undefined] `deepseq` 3
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   Another common use is to ensure any exceptions hidden within lazy
--   fields of a data structure do not leak outside the scope of the
--   exception handler, or to force evaluation of a data structure in one
--   thread, before passing to another thread (preventing work moving to
--   the wrong threads).
module Control.DeepSeq

-- | A class of types that can be fully evaluated.
class NFData a

-- | <a>rnf</a> should reduce its argument to normal form (that is, fully
--   evaluate all sub-components), and then return <tt>()</tt>.
--   
--   <h3><a>Generic</a> <a>NFData</a> deriving</h3>
--   
--   Starting with GHC 7.2, you can automatically derive instances for
--   types possessing a <a>Generic</a> instance.
--   
--   Note: <a>Generic1</a> can be auto-derived starting with GHC 7.4
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics (Generic, Generic1)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1)
--   
--   instance NFData a =&gt; NFData (Foo a)
--   instance NFData1 Foo
--   
--   data Colour = Red | Green | Blue
--                 deriving Generic
--   
--   instance NFData Colour
--   </pre>
--   
--   Starting with GHC 7.10, the example above can be written more
--   concisely by enabling the new <tt>DeriveAnyClass</tt> extension:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric, DeriveAnyClass #-}
--   
--   import GHC.Generics (Generic)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1, NFData, NFData1)
--   
--   data Colour = Red | Green | Blue
--                 deriving (Generic, NFData)
--   </pre>
--   
--   <h3>Compatibility with previous <tt>deepseq</tt> versions</h3>
--   
--   Prior to version 1.4.0.0, the default implementation of the <a>rnf</a>
--   method was defined as
--   
--   <pre>
--   <a>rnf</a> a = <a>seq</a> a ()
--   </pre>
--   
--   However, starting with <tt>deepseq-1.4.0.0</tt>, the default
--   implementation is based on <tt>DefaultSignatures</tt> allowing for
--   more accurate auto-derived <a>NFData</a> instances. If you need the
--   previously used exact default <a>rnf</a> method implementation
--   semantics, use
--   
--   <pre>
--   instance NFData Colour where rnf x = seq x ()
--   </pre>
--   
--   or alternatively
--   
--   <pre>
--   instance NFData Colour where rnf = rwhnf
--   </pre>
--   
--   or
--   
--   <pre>
--   {-# LANGUAGE BangPatterns #-}
--   instance NFData Colour where rnf !_ = ()
--   </pre>
rnf :: NFData a => a -> ()
($dmrnf) :: (NFData a, Generic a, GNFData Zero (Rep a)) => a -> ()

-- | <a>deepseq</a>: fully evaluates the first argument, before returning
--   the second.
--   
--   The name <a>deepseq</a> is used to illustrate the relationship to
--   <a>seq</a>: where <a>seq</a> is shallow in the sense that it only
--   evaluates the top level of its argument, <a>deepseq</a> traverses the
--   entire data structure evaluating it completely.
--   
--   <a>deepseq</a> can be useful for forcing pending exceptions,
--   eradicating space leaks, or forcing lazy I/O to happen. It is also
--   useful in conjunction with parallel Strategies (see the
--   <tt>parallel</tt> package).
--   
--   There is no guarantee about the ordering of evaluation. The
--   implementation may evaluate the components of the structure in any
--   order or in parallel. To impose an actual order on evaluation, use
--   <tt>pseq</tt> from <a>Control.Parallel</a> in the <tt>parallel</tt>
--   package.
deepseq :: NFData a => a -> b -> b
infixr 0 `deepseq`

-- | A variant of <a>deepseq</a> that is useful in some circumstances:
--   
--   <pre>
--   force x = x `deepseq` x
--   </pre>
--   
--   <tt>force x</tt> fully evaluates <tt>x</tt>, and then returns it. Note
--   that <tt>force x</tt> only performs evaluation when the value of
--   <tt>force x</tt> itself is demanded, so essentially it turns shallow
--   evaluation into deep evaluation.
--   
--   <a>force</a> can be conveniently used in combination with
--   <tt>ViewPatterns</tt>:
--   
--   <pre>
--   {-# LANGUAGE BangPatterns, ViewPatterns #-}
--   import Control.DeepSeq
--   
--   someFun :: ComplexData -&gt; SomeResult
--   someFun (force -&gt; !arg) = {- 'arg' will be fully evaluated -}
--   </pre>
--   
--   Another useful application is to combine <a>force</a> with
--   <a>evaluate</a> in order to force deep evaluation relative to other
--   <a>IO</a> operations:
--   
--   <pre>
--   import Control.Exception (evaluate)
--   import Control.DeepSeq
--   
--   main = do
--     result &lt;- evaluate $ force $ pureComputation
--     {- 'result' will be fully evaluated at this point -}
--     return ()
--   </pre>
--   
--   Finally, here's an exception safe variant of the <tt>readFile'</tt>
--   example:
--   
--   <pre>
--   readFile' :: FilePath -&gt; IO String
--   readFile' fn = bracket (openFile fn ReadMode) hClose $ \h -&gt;
--                          evaluate . force =&lt;&lt; hGetContents h
--   </pre>
force :: NFData a => a -> a

-- | The deep analogue of <a>$!</a>. <tt>f $!! x</tt> fully evaluates
--   <tt>x</tt> before returning <tt>f x</tt>.
--   
--   There is no guarantee about the ordering of evaluation. <tt>f x</tt>
--   may be evaluated before <tt>x</tt> is fully evaluated. To impose an
--   actual order on evaluation, use <tt>pseq</tt> from
--   <a>Control.Parallel</a> in the <tt>parallel</tt> package.
($!!) :: NFData a => (a -> b) -> a -> b
infixr 0 $!!

-- | Deeply strict version of <a>&lt;$&gt;</a>.
(<$!!>) :: (Monad m, NFData b) => (a -> b) -> m a -> m b
infixl 4 <$!!>

-- | Reduce to weak head normal form
--   
--   Equivalent to <tt>\x -&gt; <a>seq</a> x ()</tt>.
--   
--   Useful for defining <a>NFData</a> for types for which NF=WHNF holds.
--   
--   <pre>
--   data T = C1 | C2 | C3
--   instance NFData T where rnf = rwhnf
--   </pre>
rwhnf :: a -> ()

-- | A monoid with <tt>(&lt;&gt;) = seq</tt>.
--   
--   Its purpose is to allow reducing structures to normal form using
--   <a>foldMap</a>-like functions.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   data Three a = Three a a a
--   
--   instance Foldable Three where
--     foldMap f (Three x1 x2 x3) = f x1 &lt;&gt; f x2 &lt;&gt; f x3
--   
--   instance NFData a =&gt; NFData (Three a) where
--     rnf = runUnit . foldMap (Unit . rnf)
--   </pre>
--   
--   <pre>
--   data Tree a b
--     = NodeA a [Tree a b]
--     | NodeB b [Tree a b]
--   
--   foldMapTree :: Monoid m =&gt; (a -&gt; m) -&gt; (b -&gt; m) -&gt; Tree a b -&gt; m
--   foldMapTree f g = go
--     where
--       go (NodeA x ts) = f x &lt;&gt; foldMap go ts
--       go (NodeB y ts) = g y &lt;&gt; foldMap go ts
--   
--   instance NFData2 Tree where
--     liftRnf2 r r' = runUnit . foldMapTree (Unit . r) (Unit . r')
--   </pre>
newtype Unit
Unit :: () -> Unit
[runUnit] :: Unit -> ()

-- | A class of functors that can be fully evaluated.
--   
--   In `deepseq-1.5.0.0` this class was updated to include superclasses.
class forall a. NFData a => NFData f a => NFData1 (f :: Type -> Type)

-- | <a>liftRnf</a> should reduce its argument to normal form (that is,
--   fully evaluate all sub-components), given an argument to reduce
--   <tt>a</tt> arguments, and then return <tt>()</tt>.
--   
--   See <a>rnf</a> for the generic deriving.
liftRnf :: NFData1 f => (a -> ()) -> f a -> ()
($dmliftRnf) :: (NFData1 f, Generic1 f, GNFData One (Rep1 f)) => (a -> ()) -> f a -> ()

-- | Lift the standard <a>rnf</a> function through the type constructor.
rnf1 :: (NFData1 f, NFData a) => f a -> ()

-- | A class of bifunctors that can be fully evaluated.
--   
--   In `deepseq-1.5.0.0` this class was updated to include superclasses.
class forall a. NFData a => NFData1 p a => NFData2 (p :: Type -> Type -> Type)

-- | <a>liftRnf2</a> should reduce its argument to normal form (that is,
--   fully evaluate all sub-components), given functions to reduce
--   <tt>a</tt> and <tt>b</tt> arguments respectively, and then return
--   <tt>()</tt>.
--   
--   <b>Note</b>: Unlike for the unary <a>liftRnf</a>, there is currently
--   no support for generically deriving <a>liftRnf2</a>.
liftRnf2 :: NFData2 p => (a -> ()) -> (b -> ()) -> p a b -> ()

-- | Lift the standard <a>rnf</a> function through the type constructor.
rnf2 :: (NFData2 p, NFData a, NFData b) => p a b -> ()
instance (Control.DeepSeq.NFData1 f, Control.DeepSeq.GNFData Control.DeepSeq.One g) => Control.DeepSeq.GNFData Control.DeepSeq.One (f GHC.Internal.Generics.:.: g)
instance Control.DeepSeq.GNFData Control.DeepSeq.One GHC.Internal.Generics.Par1
instance Control.DeepSeq.NFData1 f => Control.DeepSeq.GNFData Control.DeepSeq.One (GHC.Internal.Generics.Rec1 f)
instance (Control.DeepSeq.GNFData arity a, Control.DeepSeq.GNFData arity b) => Control.DeepSeq.GNFData arity (a GHC.Internal.Generics.:*: b)
instance (Control.DeepSeq.GNFData arity a, Control.DeepSeq.GNFData arity b) => Control.DeepSeq.GNFData arity (a GHC.Internal.Generics.:+: b)
instance Control.DeepSeq.NFData a => Control.DeepSeq.GNFData arity (GHC.Internal.Generics.K1 i a)
instance Control.DeepSeq.GNFData arity a => Control.DeepSeq.GNFData arity (GHC.Internal.Generics.M1 i c a)
instance Control.DeepSeq.GNFData arity GHC.Internal.Generics.U1
instance Control.DeepSeq.GNFData arity (GHC.Internal.Generics.URec a)
instance Control.DeepSeq.GNFData arity GHC.Internal.Generics.V1
instance GHC.Internal.Base.Monoid Control.DeepSeq.Unit
instance Control.DeepSeq.NFData1 ((GHC.Internal.Data.Type.Equality.:~:) a)
instance forall k1 (a :: k1). Control.DeepSeq.NFData1 ((GHC.Internal.Data.Type.Equality.:~~:) a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData1 (Data.Semigroup.Arg a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData1 (GHC.Internal.Arr.Array a)
instance (Control.DeepSeq.NFData1 f, Control.DeepSeq.NFData1 g) => Control.DeepSeq.NFData1 (Data.Functor.Compose.Compose f g)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData1 (GHC.Internal.Data.Functor.Const.Const a)
instance Control.DeepSeq.NFData1 GHC.Internal.Data.Ord.Down
instance Control.DeepSeq.NFData1 GHC.Internal.Data.Semigroup.Internal.Dual
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData1 (GHC.Internal.Data.Either.Either a)
instance Control.DeepSeq.NFData1 Data.Semigroup.First
instance Control.DeepSeq.NFData1 GHC.Internal.Data.Monoid.First
instance Control.DeepSeq.NFData1 Data.Fixed.Fixed
instance Control.DeepSeq.NFData1 GHC.Internal.Ptr.FunPtr
instance Control.DeepSeq.NFData1 GHC.Internal.IORef.IORef
instance Control.DeepSeq.NFData1 GHC.Internal.Data.Functor.Identity.Identity
instance Control.DeepSeq.NFData1 Data.Semigroup.Last
instance Control.DeepSeq.NFData1 GHC.Internal.Data.Monoid.Last
instance Control.DeepSeq.NFData1 []
instance Control.DeepSeq.NFData1 GHC.Internal.MVar.MVar
instance Control.DeepSeq.NFData1 Data.Semigroup.Max
instance Control.DeepSeq.NFData1 GHC.Internal.Maybe.Maybe
instance Control.DeepSeq.NFData1 Data.Semigroup.Min
instance Control.DeepSeq.NFData1 GHC.Internal.Base.NonEmpty
instance Control.DeepSeq.NFData1 GHC.Internal.Data.Semigroup.Internal.Product
instance (Control.DeepSeq.NFData1 f, Control.DeepSeq.NFData1 g) => Control.DeepSeq.NFData1 (Data.Functor.Product.Product f g)
instance Control.DeepSeq.NFData1 GHC.Internal.Data.Proxy.Proxy
instance Control.DeepSeq.NFData1 GHC.Internal.Ptr.Ptr
instance Control.DeepSeq.NFData1 GHC.Internal.Real.Ratio
instance Control.DeepSeq.NFData1 (GHC.Internal.STRef.STRef s)
instance Control.DeepSeq.NFData1 GHC.Tuple.Solo
instance Control.DeepSeq.NFData1 GHC.Internal.StableName.StableName
instance Control.DeepSeq.NFData1 GHC.Internal.Data.Semigroup.Internal.Sum
instance (Control.DeepSeq.NFData1 f, Control.DeepSeq.NFData1 g) => Control.DeepSeq.NFData1 (Data.Functor.Sum.Sum f g)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData1 ((,) a)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2) => Control.DeepSeq.NFData1 ((,,) a1 a2)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3) => Control.DeepSeq.NFData1 ((,,,) a1 a2 a3)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4) => Control.DeepSeq.NFData1 ((,,,,) a1 a2 a3 a4)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5) => Control.DeepSeq.NFData1 ((,,,,,) a1 a2 a3 a4 a5)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5, Control.DeepSeq.NFData a6) => Control.DeepSeq.NFData1 ((,,,,,,) a1 a2 a3 a4 a5 a6)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5, Control.DeepSeq.NFData a6, Control.DeepSeq.NFData a7) => Control.DeepSeq.NFData1 ((,,,,,,,) a1 a2 a3 a4 a5 a6 a7)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5, Control.DeepSeq.NFData a6, Control.DeepSeq.NFData a7, Control.DeepSeq.NFData a8) => Control.DeepSeq.NFData1 ((,,,,,,,,) a1 a2 a3 a4 a5 a6 a7 a8)
instance Control.DeepSeq.NFData1 Data.Semigroup.WrappedMonoid
instance Control.DeepSeq.NFData1 GHC.Internal.Functor.ZipList.ZipList
instance Control.DeepSeq.NFData2 (GHC.Internal.Data.Type.Equality.:~:)
instance Control.DeepSeq.NFData2 (GHC.Internal.Data.Type.Equality.:~~:)
instance Control.DeepSeq.NFData2 Data.Semigroup.Arg
instance Control.DeepSeq.NFData2 GHC.Internal.Arr.Array
instance Control.DeepSeq.NFData2 GHC.Internal.Data.Functor.Const.Const
instance Control.DeepSeq.NFData2 GHC.Internal.Data.Either.Either
instance Control.DeepSeq.NFData2 GHC.Internal.STRef.STRef
instance Control.DeepSeq.NFData2 (,)
instance Control.DeepSeq.NFData a1 => Control.DeepSeq.NFData2 ((,,) a1)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2) => Control.DeepSeq.NFData2 ((,,,) a1 a2)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3) => Control.DeepSeq.NFData2 ((,,,,) a1 a2 a3)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4) => Control.DeepSeq.NFData2 ((,,,,,) a1 a2 a3 a4)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5) => Control.DeepSeq.NFData2 ((,,,,,,) a1 a2 a3 a4 a5)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5, Control.DeepSeq.NFData a6) => Control.DeepSeq.NFData2 ((,,,,,,,) a1 a2 a3 a4 a5 a6)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5, Control.DeepSeq.NFData a6, Control.DeepSeq.NFData a7) => Control.DeepSeq.NFData2 ((,,,,,,,,) a1 a2 a3 a4 a5 a6 a7)
instance forall k (a :: k) (b :: k). Control.DeepSeq.NFData (a GHC.Internal.Data.Type.Equality.:~: b)
instance forall k1 k2 (a :: k1) (b :: k2). Control.DeepSeq.NFData (a GHC.Internal.Data.Type.Equality.:~~: b)
instance Control.DeepSeq.NFData GHC.Internal.Data.Semigroup.Internal.All
instance Control.DeepSeq.NFData GHC.Internal.Data.Semigroup.Internal.Any
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b) => Control.DeepSeq.NFData (Data.Semigroup.Arg a b)
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b) => Control.DeepSeq.NFData (GHC.Internal.Arr.Array a b)
instance Control.DeepSeq.NFData GHC.Types.Bool
instance Control.DeepSeq.NFData Data.Array.Byte.ByteArray
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CBool
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CChar
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CClock
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CDouble
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CFile
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CFloat
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CFpos
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CInt
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CIntMax
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CIntPtr
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CJmpBuf
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CLLong
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CLong
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CPtrdiff
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CSChar
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CSUSeconds
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CShort
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CSigAtomic
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CSize
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CTime
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CUChar
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CUInt
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CUIntMax
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CUIntPtr
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CULLong
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CULong
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CUSeconds
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CUShort
instance Control.DeepSeq.NFData GHC.Internal.Foreign.C.Types.CWchar
instance Control.DeepSeq.NFData GHC.Internal.Stack.Types.CallStack
instance Control.DeepSeq.NFData GHC.Types.Char
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Complex.Complex a)
instance forall k k1 (f :: k -> *) (g :: k1 -> k) (a :: k1). Control.DeepSeq.NFData (f (g a)) => Control.DeepSeq.NFData (Data.Functor.Compose.Compose f g a)
instance forall k a (b :: k). Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Internal.Data.Functor.Const.Const a b)
instance Control.DeepSeq.NFData GHC.Types.Double
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Internal.Data.Ord.Down a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Internal.Data.Semigroup.Internal.Dual a)
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b) => Control.DeepSeq.NFData (GHC.Internal.Data.Either.Either a b)
instance Control.DeepSeq.NFData GHC.Internal.IO.Exception.ExitCode
instance Control.DeepSeq.NFData (a -> b)
instance Control.DeepSeq.NFData GHC.Internal.Fingerprint.Type.Fingerprint
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Semigroup.First a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Internal.Data.Monoid.First a)
instance forall k (a :: k). Control.DeepSeq.NFData (Data.Fixed.Fixed a)
instance Control.DeepSeq.NFData GHC.Types.Float
instance Control.DeepSeq.NFData (GHC.Internal.Ptr.FunPtr a)
instance Control.DeepSeq.NFData (GHC.Internal.IORef.IORef a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Internal.Data.Functor.Identity.Identity a)
instance Control.DeepSeq.NFData GHC.Types.Int
instance Control.DeepSeq.NFData GHC.Internal.Int.Int16
instance Control.DeepSeq.NFData GHC.Internal.Int.Int32
instance Control.DeepSeq.NFData GHC.Internal.Int.Int64
instance Control.DeepSeq.NFData GHC.Internal.Int.Int8
instance Control.DeepSeq.NFData GHC.Num.Integer.Integer
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Semigroup.Last a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Internal.Data.Monoid.Last a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData [a]
instance Control.DeepSeq.NFData (GHC.Internal.MVar.MVar a)
instance Control.DeepSeq.NFData GHC.Internal.IO.MaskingState
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Semigroup.Max a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Internal.Maybe.Maybe a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Semigroup.Min a)
instance Control.DeepSeq.NFData GHC.Types.Module
instance Control.DeepSeq.NFData (Data.Array.Byte.MutableByteArray s)
instance Control.DeepSeq.NFData GHC.Num.Natural.Natural
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Internal.Base.NonEmpty a)
instance Control.DeepSeq.NFData GHC.Types.Ordering
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Internal.Data.Semigroup.Internal.Product a)
instance forall k (f :: k -> *) (a :: k) (g :: k -> *). (Control.DeepSeq.NFData (f a), Control.DeepSeq.NFData (g a)) => Control.DeepSeq.NFData (Data.Functor.Product.Product f g a)
instance forall k (a :: k). Control.DeepSeq.NFData (GHC.Internal.Data.Proxy.Proxy a)
instance Control.DeepSeq.NFData (GHC.Internal.Ptr.Ptr a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Internal.Real.Ratio a)
instance Control.DeepSeq.NFData (GHC.Internal.STRef.STRef s a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Tuple.Solo a)
instance Control.DeepSeq.NFData GHC.Internal.Data.Typeable.TypeRep
instance Control.DeepSeq.NFData GHC.Internal.Stack.Types.SrcLoc
instance Control.DeepSeq.NFData (GHC.Internal.StableName.StableName a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Internal.Data.Semigroup.Internal.Sum a)
instance forall k (f :: k -> *) (a :: k) (g :: k -> *). (Control.DeepSeq.NFData (f a), Control.DeepSeq.NFData (g a)) => Control.DeepSeq.NFData (Data.Functor.Sum.Sum f g a)
instance Control.DeepSeq.NFData GHC.Internal.Conc.Sync.ThreadId
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b) => Control.DeepSeq.NFData (a, b)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3) => Control.DeepSeq.NFData (a1, a2, a3)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4) => Control.DeepSeq.NFData (a1, a2, a3, a4)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5) => Control.DeepSeq.NFData (a1, a2, a3, a4, a5)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5, Control.DeepSeq.NFData a6) => Control.DeepSeq.NFData (a1, a2, a3, a4, a5, a6)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5, Control.DeepSeq.NFData a6, Control.DeepSeq.NFData a7) => Control.DeepSeq.NFData (a1, a2, a3, a4, a5, a6, a7)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5, Control.DeepSeq.NFData a6, Control.DeepSeq.NFData a7, Control.DeepSeq.NFData a8) => Control.DeepSeq.NFData (a1, a2, a3, a4, a5, a6, a7, a8)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5, Control.DeepSeq.NFData a6, Control.DeepSeq.NFData a7, Control.DeepSeq.NFData a8, Control.DeepSeq.NFData a9) => Control.DeepSeq.NFData (a1, a2, a3, a4, a5, a6, a7, a8, a9)
instance Control.DeepSeq.NFData GHC.Types.TyCon
instance forall k (a :: k). Control.DeepSeq.NFData (GHC.Internal.Data.Typeable.Internal.TypeRep a)
instance Control.DeepSeq.NFData GHC.Internal.Data.Unique.Unique
instance Control.DeepSeq.NFData ()
instance Control.DeepSeq.NFData GHC.Internal.Data.Version.Version
instance Control.DeepSeq.NFData GHC.Internal.Base.Void
instance Control.DeepSeq.NFData GHC.Types.Word
instance Control.DeepSeq.NFData GHC.Internal.Word.Word16
instance Control.DeepSeq.NFData GHC.Internal.Word.Word32
instance Control.DeepSeq.NFData GHC.Internal.Word.Word64
instance Control.DeepSeq.NFData GHC.Internal.Word.Word8
instance Control.DeepSeq.NFData m => Control.DeepSeq.NFData (Data.Semigroup.WrappedMonoid m)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Internal.Functor.ZipList.ZipList a)
instance GHC.Internal.Base.Semigroup Control.DeepSeq.Unit
