<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>GHC.Internal.Data.Function</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">ghc-internal-9.1202.0: Basic libraries</span><ul class="links" id="page-menu"><li><a href="src/GHC.Internal.Data.Function.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>Nils Anders Danielsson 2006<br />Alexander Berntsen     2014</td></tr><tr><th>License</th><td>BSD-style (see the LICENSE file in the distribution)</td></tr><tr><th>Maintainer</th><td>libraries@haskell.org</td></tr><tr><th>Stability</th><td>stable</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>Trustworthy</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">GHC.Internal.Data.Function</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1"><a href="Prelude.html">Prelude</a> re-exports</a></li><li><a href="#g:2">Other combinators</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Simple combinators working solely on and with functions.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:id">id</a> :: a -&gt; a</li><li class="src short"><a href="#v:const">const</a> :: a -&gt; b -&gt; a</li><li class="src short"><a href="#v:.">(.)</a> :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</li><li class="src short"><a href="#v:flip">flip</a> :: <span class="keyword">forall</span> (repc :: <a href="GHC-Internal-Exts.html#t:RuntimeRep" title="GHC.Internal.Exts">RuntimeRep</a>) a b (c :: <a href="GHC-Internal-Exts.html#t:TYPE" title="GHC.Internal.Exts">TYPE</a> repc). (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</li><li class="src short"><a href="#v:-36-">($)</a> :: <span class="keyword">forall</span> (repa :: <a href="GHC-Internal-Exts.html#t:RuntimeRep" title="GHC.Internal.Exts">RuntimeRep</a>) (repb :: <a href="GHC-Internal-Exts.html#t:RuntimeRep" title="GHC.Internal.Exts">RuntimeRep</a>) (a :: <a href="GHC-Internal-Exts.html#t:TYPE" title="GHC.Internal.Exts">TYPE</a> repa) (b :: <a href="GHC-Internal-Exts.html#t:TYPE" title="GHC.Internal.Exts">TYPE</a> repb). (a -&gt; b) -&gt; a -&gt; b</li><li class="src short"><a href="#v:-38-">(&amp;)</a> :: <span class="keyword">forall</span> (r :: <a href="GHC-Internal-Exts.html#t:RuntimeRep" title="GHC.Internal.Exts">RuntimeRep</a>) a (b :: <a href="GHC-Internal-Exts.html#t:TYPE" title="GHC.Internal.Exts">TYPE</a> r). a -&gt; (a -&gt; b) -&gt; b</li><li class="src short"><a href="#v:fix">fix</a> :: (a -&gt; a) -&gt; a</li><li class="src short"><a href="#v:on">on</a> :: (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c</li><li class="src short"><a href="#v:applyWhen">applyWhen</a> :: <a href="GHC-Internal-Data-Bool.html#t:Bool" title="GHC.Internal.Data.Bool">Bool</a> -&gt; (a -&gt; a) -&gt; a -&gt; a</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1><a href="Prelude.html">Prelude</a> re-exports</h1></a><div class="top"><p class="src"><a id="v:id" class="def">id</a> :: a -&gt; a <a href="src/GHC.Internal.Base.html#id" class="link">Source</a> <a href="#v:id" class="selflink">#</a></p><div class="doc"><p>Identity function.</p><pre>id x = x</pre><p>This function might seem useless at first glance, but it can be very useful
 in a higher order context.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:id0">Examples</h4><details id="ch:id0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>length $ filter id [True, True, False, True]
</code></strong>3
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Just (Just 3) &gt;&gt;= id
</code></strong>Just 3
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>foldr id 0 [(^3), (*5), (+2)]
</code></strong>1000
</pre></details></div></div><div class="top"><p class="src"><a id="v:const" class="def">const</a> :: a -&gt; b -&gt; a <a href="src/GHC.Internal.Base.html#const" class="link">Source</a> <a href="#v:const" class="selflink">#</a></p><div class="doc"><p><code class="inline-code">const x y</code> always evaluates to <code class="inline-code">x</code>, ignoring its second argument.</p><pre>const x = \_ -&gt; x</pre><p>This function might seem useless at first glance, but it can be very useful
 in a higher order context.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:const0">Examples</h4><details id="ch:const0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>const 42 &quot;hello&quot;
</code></strong>42
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>map (const 42) [0..3]
</code></strong>[42,42,42,42]
</pre></details></div></div><div class="top"><p class="src"><a id="v:." class="def">(.)</a> :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c <span class="fixity">infixr 9</span><span class="rightedge"></span> <a href="src/GHC.Internal.Base.html#." class="link">Source</a> <a href="#v:." class="selflink">#</a></p><div class="doc"><p>Right to left function composition.</p><pre>(f . g) x = f (g x)</pre><pre>f . id = f = id . f</pre><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:.0">Examples</h4><details id="ch:.0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>map ((*2) . length) [[], [0, 1, 2], [0]]
</code></strong>[0,6,2]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>foldr (.) id [(+1), (*3), (^3)] 2
</code></strong>25
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (...) = (.).(.) in ((*2)...(+)) 5 10
</code></strong>30
</pre></details></div></div><div class="top"><p class="src"><a id="v:flip" class="def">flip</a> :: <span class="keyword">forall</span> (repc :: <a href="GHC-Internal-Exts.html#t:RuntimeRep" title="GHC.Internal.Exts">RuntimeRep</a>) a b (c :: <a href="GHC-Internal-Exts.html#t:TYPE" title="GHC.Internal.Exts">TYPE</a> repc). (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c <a href="src/GHC.Internal.Base.html#flip" class="link">Source</a> <a href="#v:flip" class="selflink">#</a></p><div class="doc"><p><code class="inline-code"><code><a href="GHC-Internal-Data-Function.html#v:flip" title="GHC.Internal.Data.Function">flip</a></code> f</code> takes its (first) two arguments in the reverse order of <code class="inline-code">f</code>.</p><pre>flip f x y = f y x</pre><pre>flip . flip = id</pre><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:flip0">Examples</h4><details id="ch:flip0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>flip (++) &quot;hello&quot; &quot;world&quot;
</code></strong>&quot;worldhello&quot;
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (.&gt;) = flip (.) in (+1) .&gt; show $ 5
</code></strong>&quot;6&quot;
</pre></details></div></div><div class="top"><p class="src"><a id="v:-36-" class="def">($)</a> :: <span class="keyword">forall</span> (repa :: <a href="GHC-Internal-Exts.html#t:RuntimeRep" title="GHC.Internal.Exts">RuntimeRep</a>) (repb :: <a href="GHC-Internal-Exts.html#t:RuntimeRep" title="GHC.Internal.Exts">RuntimeRep</a>) (a :: <a href="GHC-Internal-Exts.html#t:TYPE" title="GHC.Internal.Exts">TYPE</a> repa) (b :: <a href="GHC-Internal-Exts.html#t:TYPE" title="GHC.Internal.Exts">TYPE</a> repb). (a -&gt; b) -&gt; a -&gt; b <span class="fixity">infixr 0</span><span class="rightedge"></span> <a href="src/GHC.Internal.Base.html#%24" class="link">Source</a> <a href="#v:-36-" class="selflink">#</a></p><div class="doc"><p><code class="inline-code"><code><a href="GHC-Internal-Data-Function.html#v:-36-" title="GHC.Internal.Data.Function">($)</a></code></code> is the <strong>function application</strong> operator.</p><p>Applying <code class="inline-code"><code><a href="GHC-Internal-Data-Function.html#v:-36-" title="GHC.Internal.Data.Function">($)</a></code></code> to a function <code class="inline-code">f</code> and an argument <code class="inline-code">x</code> gives the same result as applying <code class="inline-code">f</code> to <code class="inline-code">x</code> directly. The definition is akin to this:</p><pre>($) :: (a -&gt; b) -&gt; a -&gt; b
($) f x = f x
</pre><p>This is <code class="inline-code"><code><a href="GHC-Internal-Data-Function.html#v:id" title="GHC.Internal.Data.Function">id</a></code></code> specialized from <code class="inline-code">a -&gt; a</code> to <code class="inline-code">(a -&gt; b) -&gt; (a -&gt; b)</code> which by the associativity of <code class="inline-code">(-&gt;)</code>
is the same as <code class="inline-code">(a -&gt; b) -&gt; a -&gt; b</code>.</p><p>On the face of it, this may appear pointless! But it's actually one of the most useful and important operators in Haskell.</p><p>The order of operations is very different between <code class="inline-code">($)</code> and normal function application. Normal function application has precedence 10 - higher than any operator - and associates to the left. So these two definitions are equivalent:</p><pre>expr = min 5 1 + 5
expr = ((min 5) 1) + 5
</pre><p><code class="inline-code">($)</code> has precedence 0 (the lowest) and associates to the right, so these are equivalent:</p><pre>expr = min 5 $ 1 + 5
expr = (min 5) (1 + 5)
</pre><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:-36-0">Examples</h4><details id="ch:-36-0"><summary class="hide-when-js-enabled">Expand</summary><p>A common use cases of <code class="inline-code">($)</code> is to avoid parentheses in complex expressions.</p><p>For example, instead of using nested parentheses in the following
 Haskell function:</p><pre>-- | Sum numbers in a string: strSum &quot;100  5 -7&quot; == 98
strSum :: <code><a href="GHC-Internal-Data-String.html#t:String" title="GHC.Internal.Data.String">String</a></code> -&gt; <code><a href="GHC-Internal-Exts.html#t:Int" title="GHC.Internal.Exts">Int</a></code>
strSum s = <code class="inline-code">sum</code> (<code><a href="GHC-Internal-Data-Maybe.html#v:mapMaybe" title="GHC.Internal.Data.Maybe">mapMaybe</a></code> <code><a href="GHC-Internal-Text-Read.html#v:readMaybe" title="GHC.Internal.Text.Read">readMaybe</a></code> (<code class="inline-code">words</code> s))
</pre><p>we can deploy the function application operator:</p><pre>-- | Sum numbers in a string: strSum &quot;100  5 -7&quot; == 98
strSum :: <code><a href="GHC-Internal-Data-String.html#t:String" title="GHC.Internal.Data.String">String</a></code> -&gt; <code><a href="GHC-Internal-Exts.html#t:Int" title="GHC.Internal.Exts">Int</a></code>
strSum s = <code class="inline-code">sum</code> <code><a href="GHC-Internal-Data-Function.html#v:-36-" title="GHC.Internal.Data.Function">$</a></code> <code><a href="GHC-Internal-Data-Maybe.html#v:mapMaybe" title="GHC.Internal.Data.Maybe">mapMaybe</a></code> <code><a href="GHC-Internal-Text-Read.html#v:readMaybe" title="GHC.Internal.Text.Read">readMaybe</a></code> <code><a href="GHC-Internal-Data-Function.html#v:-36-" title="GHC.Internal.Data.Function">$</a></code> <code class="inline-code">words</code> s
</pre><p><code class="inline-code">($)</code> is also used as a section (a partially applied operator), in order to indicate that we wish to apply some yet-unspecified function to a given value. For example, to apply the argument <code class="inline-code">5</code> to a list of functions:</p><pre>applyFive :: [Int]
applyFive = map ($ 5) [(+1), (2^)]
&gt;&gt;&gt; [6, 32]
</pre></details><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:-36-1">Technical Remark (Representation Polymorphism)</h4><details id="ch:-36-1"><summary class="hide-when-js-enabled">Expand</summary><p><code class="inline-code">($)</code> is fully representation-polymorphic. This allows it to also be used with arguments of unlifted and even unboxed kinds, such as unboxed integers:</p><pre>fastMod :: Int -&gt; Int -&gt; Int
fastMod (I# x) (I# m) = I# $ remInt# x m
</pre></details></div></div><a href="#g:2" id="g:2"><h1>Other combinators</h1></a><div class="top"><p class="src"><a id="v:-38-" class="def">(&amp;)</a> :: <span class="keyword">forall</span> (r :: <a href="GHC-Internal-Exts.html#t:RuntimeRep" title="GHC.Internal.Exts">RuntimeRep</a>) a (b :: <a href="GHC-Internal-Exts.html#t:TYPE" title="GHC.Internal.Exts">TYPE</a> r). a -&gt; (a -&gt; b) -&gt; b <span class="fixity">infixl 1</span><span class="rightedge"></span> <a href="src/GHC.Internal.Data.Function.html#%26" class="link">Source</a> <a href="#v:-38-" class="selflink">#</a></p><div class="doc"><p><code><a href="GHC-Internal-Data-Function.html#v:-38-" title="GHC.Internal.Data.Function">&amp;</a></code> is a reverse application operator.  This provides notational
 convenience.  Its precedence is one higher than that of the forward
 application operator <code><a href="GHC-Internal-Data-Function.html#v:-36-" title="GHC.Internal.Data.Function">$</a></code>, which allows <code><a href="GHC-Internal-Data-Function.html#v:-38-" title="GHC.Internal.Data.Function">&amp;</a></code> to be nested in <code><a href="GHC-Internal-Data-Function.html#v:-36-" title="GHC.Internal.Data.Function">$</a></code>.</p><p>This is a version of <code class="inline-code"><code><a href="GHC-Internal-Data-Function.html#v:flip" title="GHC.Internal.Data.Function">flip</a></code> <code><a href="GHC-Internal-Data-Function.html#v:id" title="GHC.Internal.Data.Function">id</a></code></code>, where <code><a href="GHC-Internal-Data-Function.html#v:id" title="GHC.Internal.Data.Function">id</a></code> is specialized from <code class="inline-code">a -&gt; a</code> to <code class="inline-code">(a -&gt; b) -&gt; (a -&gt; b)</code>
 which by the associativity of <code class="inline-code">(-&gt;)</code> is <code class="inline-code">(a -&gt; b) -&gt; a -&gt; b</code>.
 flipping this yields <code class="inline-code">a -&gt; (a -&gt; b) -&gt; b</code> which is the type signature of <code><a href="GHC-Internal-Data-Function.html#v:-38-" title="GHC.Internal.Data.Function">&amp;</a></code></p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:-38-0">Examples</h4><details id="ch:-38-0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>5 &amp; (+1) &amp; show
</code></strong>&quot;6&quot;
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sqrt $ [1 / n^2 | n &lt;- [1..1000]] &amp; sum &amp; (*6)
</code></strong>3.1406380562059946
</pre></details><p><em>Since: base-4.8.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:fix" class="def">fix</a> :: (a -&gt; a) -&gt; a <a href="src/GHC.Internal.Data.Function.html#fix" class="link">Source</a> <a href="#v:fix" class="selflink">#</a></p><div class="doc"><p><code class="inline-code"><code><a href="GHC-Internal-Data-Function.html#v:fix" title="GHC.Internal.Data.Function">fix</a></code> f</code> is the least fixed point of the function <code class="inline-code">f</code>,
 i.e. the least defined <code class="inline-code">x</code> such that <code class="inline-code">f x = x</code>.</p><p>When <code class="inline-code">f</code> is strict, this means that because, by the definition of strictness,
 <code class="inline-code">f &#8869; = &#8869;</code> and such the least defined fixed point of any strict function is <code class="inline-code">&#8869;</code>.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:fix0">Examples</h4><details id="ch:fix0"><summary class="hide-when-js-enabled">Expand</summary><p>We can write the factorial function using direct recursion as</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let fac n = if n &lt;= 1 then 1 else n * fac (n-1) in fac 5
</code></strong>120
</pre><p>This uses the fact that Haskell&#8217;s <code class="inline-code">let</code> introduces recursive bindings. We can
 rewrite this definition using <code><a href="GHC-Internal-Data-Function.html#v:fix" title="GHC.Internal.Data.Function">fix</a></code>,</p><p>Instead of making a recursive call, we introduce a dummy parameter <code class="inline-code">rec</code>;
 when used within <code><a href="GHC-Internal-Data-Function.html#v:fix" title="GHC.Internal.Data.Function">fix</a></code>, this parameter then refers to <code><a href="GHC-Internal-Data-Function.html#v:fix" title="GHC.Internal.Data.Function">fix</a></code>&#8217;s argument, hence
 the recursion is reintroduced.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fix (\rec n -&gt; if n &lt;= 1 then 1 else n * rec (n-1)) 5
</code></strong>120
</pre><p>Using <code><a href="GHC-Internal-Data-Function.html#v:fix" title="GHC.Internal.Data.Function">fix</a></code>, we can implement versions of <code><a href="GHC-Internal-Data-List.html#v:repeat" title="GHC.Internal.Data.List">repeat</a></code> as <code class="inline-code"><code><a href="GHC-Internal-Data-Function.html#v:fix" title="GHC.Internal.Data.Function">fix</a></code> <code><a href="GHC-Internal-Data-Function.html#v:." title="GHC.Internal.Data.Function">.</a></code> <code class="inline-code">(:)</code></code>
 and <code><a href="GHC-Internal-Data-List.html#v:cycle" title="GHC.Internal.Data.List">cycle</a></code> as <code class="inline-code"><code><a href="GHC-Internal-Data-Function.html#v:fix" title="GHC.Internal.Data.Function">fix</a></code> <code><a href="GHC-Internal-Data-Function.html#v:." title="GHC.Internal.Data.Function">.</a></code> <code class="inline-code">(++)</code></code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>take 10 $ fix (0:)
</code></strong>[0,0,0,0,0,0,0,0,0,0]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>map (fix (\rec n -&gt; if n &lt; 2 then n else rec (n - 1) + rec (n - 2))) [1..10]
</code></strong>[1,1,2,3,5,8,13,21,34,55]
</pre></details><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:fix1">Implementation Details</h4><details id="ch:fix1"><summary class="hide-when-js-enabled">Expand</summary><p>The current implementation of <code><a href="GHC-Internal-Data-Function.html#v:fix" title="GHC.Internal.Data.Function">fix</a></code> uses structural sharing</p><pre><code><a href="GHC-Internal-Data-Function.html#v:fix" title="GHC.Internal.Data.Function">fix</a></code> f = let x = f x in x</pre><p>A more straightforward but non-sharing version would look like</p><pre><code><a href="GHC-Internal-Data-Function.html#v:fix" title="GHC.Internal.Data.Function">fix</a></code> f = f (<code><a href="GHC-Internal-Data-Function.html#v:fix" title="GHC.Internal.Data.Function">fix</a></code> f)</pre></details></div></div><div class="top"><p class="src"><a id="v:on" class="def">on</a> :: (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c <span class="fixity">infixl 0</span><span class="rightedge"></span> <a href="src/GHC.Internal.Data.Function.html#on" class="link">Source</a> <a href="#v:on" class="selflink">#</a></p><div class="doc"><p><code class="inline-code"><code><a href="GHC-Internal-Data-Function.html#v:on" title="GHC.Internal.Data.Function">on</a></code> b u x y</code> runs the binary function <code class="inline-code">b</code> <em>on</em> the results of applying
 unary function <code class="inline-code">u</code> to two arguments <code class="inline-code">x</code> and <code class="inline-code">y</code>. From the opposite
 perspective, it transforms two inputs and combines the outputs.</p><pre>(op `<code><a href="GHC-Internal-Data-Function.html#v:on" title="GHC.Internal.Data.Function">on</a></code>` f) x y = f x `<code class="inline-code">op</code>` f y</pre><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:on0">Examples</h4><details id="ch:on0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sortBy (compare `on` length) [[0, 1, 2], [0, 1], [], [0]]
</code></strong>[[],[0],[0,1],[0,1,2]]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>((+) `on` length) [1, 2, 3] [-1]
</code></strong>4
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>((,) `on` (*2)) 2 3
</code></strong>(4,6)
</pre></details><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:on1">Algebraic properties</h4><details id="ch:on1"><summary class="hide-when-js-enabled">Expand</summary><ul><li><pre>(*) `on` <code><a href="GHC-Internal-Data-Function.html#v:id" title="GHC.Internal.Data.Function">id</a></code> = (*) -- (if (*) &#8713; {&#8869;, <code><a href="GHC-Internal-Data-Function.html#v:const" title="GHC.Internal.Data.Function">const</a></code> &#8869;})</pre></li><li><pre>((*) `on` f) `on` g = (*) `on` (f . g)</pre></li><li><pre><code><a href="GHC-Internal-Data-Function.html#v:flip" title="GHC.Internal.Data.Function">flip</a></code> on f . <code><a href="GHC-Internal-Data-Function.html#v:flip" title="GHC.Internal.Data.Function">flip</a></code> on g = <code><a href="GHC-Internal-Data-Function.html#v:flip" title="GHC.Internal.Data.Function">flip</a></code> on (g . f)</pre></li></ul></details></div></div><div class="top"><p class="src"><a id="v:applyWhen" class="def">applyWhen</a> :: <a href="GHC-Internal-Data-Bool.html#t:Bool" title="GHC.Internal.Data.Bool">Bool</a> -&gt; (a -&gt; a) -&gt; a -&gt; a <a href="src/GHC.Internal.Data.Function.html#applyWhen" class="link">Source</a> <a href="#v:applyWhen" class="selflink">#</a></p><div class="doc"><p><code><a href="GHC-Internal-Data-Function.html#v:applyWhen" title="GHC.Internal.Data.Function">applyWhen</a></code> applies a function to a value if a condition is true,
 otherwise, it returns the value unchanged.</p><p>It is equivalent to <code class="inline-code"><code><a href="GHC-Internal-Data-Function.html#v:flip" title="GHC.Internal.Data.Function">flip</a></code> (<code><a href="GHC-Internal-Data-Bool.html#v:bool" title="GHC.Internal.Data.Bool">bool</a></code> <code><a href="GHC-Internal-Data-Function.html#v:id" title="GHC.Internal.Data.Function">id</a></code>)</code>.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:applyWhen0">Examples</h4><details id="ch:applyWhen0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>map (\x -&gt; applyWhen (odd x) (*2) x) [1..10]
</code></strong>[2,2,6,4,10,6,14,8,18,10]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>map (\x -&gt; applyWhen (length x &gt; 6) ((++ &quot;...&quot;) . take 3) x) [&quot;Hi!&quot;, &quot;This is amazing&quot;, &quot;Hope you're doing well today!&quot;, &quot;:D&quot;]
</code></strong>[&quot;Hi!&quot;,&quot;Thi...&quot;,&quot;Hop...&quot;,&quot;:D&quot;]
</pre></details><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:applyWhen1">Algebraic properties</h4><details id="ch:applyWhen1"><summary class="hide-when-js-enabled">Expand</summary><ul><li><pre>applyWhen <code><a href="GHC-Internal-Data-Bool.html#v:True" title="GHC.Internal.Data.Bool">True</a></code> = <code><a href="GHC-Internal-Data-Function.html#v:id" title="GHC.Internal.Data.Function">id</a></code></pre></li><li><pre>applyWhen <code><a href="GHC-Internal-Data-Bool.html#v:False" title="GHC.Internal.Data.Bool">False</a></code> f = <code><a href="GHC-Internal-Data-Function.html#v:id" title="GHC.Internal.Data.Function">id</a></code></pre></li></ul></details><p><em>Since: base-4.18.0.0</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.30.0</p></div></body></html>