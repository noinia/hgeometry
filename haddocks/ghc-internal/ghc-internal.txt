-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Basic libraries
--   
--   This package contains the implementation of GHC's standard libraries
--   and is not intended for use by end-users. . Users should instead use
--   either the <tt>base</tt> or <tt>ghc-experimental</tt> packages
@package ghc-internal
@version 9.1202.0


-- | NB. the contents of this module are only available on Windows.
--   
--   Installing Win32 console handlers.
module GHC.Internal.ConsoleHandler


-- | Safe coercions between data types.
--   
--   More in-depth information can be found on the <a>Roles wiki page</a>
module GHC.Internal.Data.Coerce

-- | The function <a>coerce</a> allows you to safely convert between values
--   of types that have the same representation with no run-time overhead.
--   In the simplest case you can use it instead of a newtype constructor,
--   to go from the newtype's concrete type to the abstract type. But it
--   also works in more complicated settings, e.g. converting a list of
--   newtypes to a list of concrete types.
--   
--   When used in conversions involving a newtype wrapper, make sure the
--   newtype constructor is in scope.
--   
--   This function is representation-polymorphic, but the
--   <tt>RuntimeRep</tt> type argument is marked as <tt>Inferred</tt>,
--   meaning that it is not available for visible type application. This
--   means the typechecker will accept <tt><a>coerce</a> @<tt>Int</tt> @Age
--   42</tt>.
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; newtype TTL = TTL Int deriving (Eq, Ord, Show)
--   
--   &gt;&gt;&gt; newtype Age = Age Int deriving (Eq, Ord, Show)
--   
--   &gt;&gt;&gt; coerce (Age 42) :: TTL
--   TTL 42
--   
--   &gt;&gt;&gt; coerce (+ (1 :: Int)) (Age 42) :: TTL
--   TTL 43
--   
--   &gt;&gt;&gt; coerce (map (+ (1 :: Int))) [Age 42, Age 24] :: [TTL]
--   [TTL 43,TTL 25]
--   </pre>
coerce :: Coercible a b => a -> b

-- | <tt>Coercible</tt> is a two-parameter class that has instances for
--   types <tt>a</tt> and <tt>b</tt> if the compiler can infer that they
--   have the same representation. This class does not have regular
--   instances; instead they are created on-the-fly during type-checking.
--   Trying to manually declare an instance of <tt>Coercible</tt> is an
--   error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance Coercible a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class a ~R# b => Coercible (a :: k) (b :: k)


-- | Functions associated with the tuple data types.
module GHC.Internal.Data.Tuple

-- | <tt>Solo</tt> is the canonical lifted 1-tuple, just like <a>(,)</a> is
--   the canonical lifted 2-tuple (pair) and <a>(,,)</a> is the canonical
--   lifted 3-tuple (triple).
--   
--   The most important feature of <tt>Solo</tt> is that it is possible to
--   force its "outside" (usually by pattern matching) without forcing its
--   "inside", because it is defined as a datatype rather than a newtype.
--   One situation where this can be useful is when writing a function to
--   extract a value from a data structure. Suppose you write an
--   implementation of arrays and offer only this function to index into
--   them:
--   
--   <pre>
--   index :: Array a -&gt; Int -&gt; a
--   </pre>
--   
--   Now imagine that someone wants to extract a value from an array and
--   store it in a lazy-valued finite map/dictionary:
--   
--   <pre>
--   insert "hello" (arr <tt>index</tt> 12) m
--   </pre>
--   
--   This can actually lead to a space leak. The value is not actually
--   extracted from the array until that value (now buried in a map) is
--   forced. That means the entire array may be kept live by just that
--   value! Often, the solution is to use a strict map, or to force the
--   value before storing it, but for some purposes that's undesirable.
--   
--   One common solution is to include an indexing function that can
--   produce its result in an arbitrary <tt>Applicative</tt> context:
--   
--   <pre>
--   indexA :: Applicative f =&gt; Array a -&gt; Int -&gt; f a
--   </pre>
--   
--   When using <tt>indexA</tt> in a <i>pure</i> context, <tt>Solo</tt>
--   serves as a handy <tt>Applicative</tt> functor to hold the result. You
--   could write a non-leaky version of the above example thus:
--   
--   <pre>
--   case arr <tt>indexA</tt> 12 of
--     Solo a -&gt; insert "hello" a m
--   </pre>
--   
--   While such simple extraction functions are the most common uses for
--   unary tuples, they can also be useful for fine-grained control of
--   strict-spined data structure traversals, and for unifying the
--   implementations of lazy and strict mapping functions.
data Solo a
MkSolo :: a -> Solo a

-- | <i>Deprecated: The Solo constructor has been renamed to MkSolo to
--   avoid punning.</i>
pattern Solo :: a -> Solo a

-- | Extract the value from a <a>Solo</a>. Very often, values should be
--   extracted directly using pattern matching, to control just what gets
--   evaluated when. <tt>getSolo</tt> is for convenience in situations
--   where that is not the case:
--   
--   When the result is passed to a <i>strict</i> function, it makes no
--   difference whether the pattern matching is done on the "outside" or on
--   the "inside":
--   
--   <pre>
--   Data.Set.insert (getSolo sol) set === case sol of Solo v -&gt; Data.Set.insert v set
--   </pre>
--   
--   A traversal may be performed in <a>Solo</a> in order to control
--   evaluation internally, while using <tt>getSolo</tt> to extract the
--   final result. A strict mapping function, for example, could be defined
--   
--   <pre>
--   map' :: Traversable t =&gt; (a -&gt; b) -&gt; t a -&gt; t b
--   map' f = getSolo . traverse ((Solo $!) . f)
--   </pre>
getSolo :: Solo a -> a

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | Convert an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | Swap the components of a pair.
swap :: (a, b) -> (b, a)

module GHC.Internal.IO.Encoding.CodePage


-- | Compatibility module for pre ghc-bignum code.
module GHC.Internal.Integer

-- | Arbitrary precision integers. In contrast with fixed-size integral
--   types such as <a>Int</a>, the <a>Integer</a> type represents the
--   entire infinite range of integers.
--   
--   Integers are stored in a kind of sign-magnitude form, hence do not
--   expect two's complement form when using bit operations.
--   
--   If the value is small (i.e., fits into an <a>Int</a>), the <a>IS</a>
--   constructor is used. Otherwise <a>IP</a> and <a>IN</a> constructors
--   are used to store a <a>BigNat</a> representing the positive or the
--   negative value magnitude, respectively.
--   
--   Invariant: <a>IP</a> and <a>IN</a> are used iff the value does not fit
--   in <a>IS</a>.
data Integer
smallInteger :: Int# -> Integer
wordToInteger :: Word# -> Integer
integerToWord :: Integer -> Word#
integerToInt :: Integer -> Int#
encodeFloatInteger :: Integer -> Int# -> Float#
encodeDoubleInteger :: Integer -> Int# -> Double#
decodeDoubleInteger :: Double# -> (# Integer, Int# #)

-- | Used to implement <tt>(+)</tt> for the <tt>Num</tt> typeclass. This
--   gives the sum of two integers.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; plusInteger 3 2
--   5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (+) 3 2
--   5
--   </pre>
plusInteger :: Integer -> Integer -> Integer

-- | Used to implement <tt>(-)</tt> for the <tt>Num</tt> typeclass. This
--   gives the difference of two integers.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; minusInteger 3 2
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (-) 3 2
--   1
--   </pre>
minusInteger :: Integer -> Integer -> Integer

-- | Used to implement <tt>(*)</tt> for the <tt>Num</tt> typeclass. This
--   gives the product of two integers.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; timesInteger 3 2
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (*) 3 2
--   6
--   </pre>
timesInteger :: Integer -> Integer -> Integer

-- | Used to implement <tt>negate</tt> for the <tt>Num</tt> typeclass. This
--   changes the sign of whatever integer is passed into it.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; negateInteger (-6)
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; negate (-6)
--   6
--   </pre>
negateInteger :: Integer -> Integer

-- | Used to implement <tt>abs</tt> for the <tt>Num</tt> typeclass. This
--   gives the absolute value of whatever integer is passed into it.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; absInteger (-6)
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; abs (-6)
--   6
--   </pre>
absInteger :: Integer -> Integer

-- | Used to implement <tt>signum</tt> for the <tt>Num</tt> typeclass. This
--   gives 1 for a positive integer, and -1 for a negative integer.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; signumInteger 5
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; signum 5
--   1
--   </pre>
signumInteger :: Integer -> Integer

-- | Used to implement <tt>divMod</tt> for the <tt>Integral</tt> typeclass.
--   This gives a tuple equivalent to
--   
--   <pre>
--   (div x y, mod x y)
--   </pre>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; divModInteger 10 2
--   (5,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; divMod 10 2
--   (5,0)
--   </pre>
divModInteger :: Integer -> Integer -> (# Integer, Integer #)

-- | Used to implement <tt>div</tt> for the <tt>Integral</tt> typeclass.
--   This performs integer division on its two parameters, truncated
--   towards negative infinity.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 10 `divInteger` 2
--   5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 10 `div` 2
--   </pre>
divInteger :: Integer -> Integer -> Integer

-- | Used to implement <tt>mod</tt> for the <tt>Integral</tt> typeclass.
--   This performs the modulo operation, satisfying
--   
--   <pre>
--   ((x `div` y) * y) + (x `mod` y) == x
--   </pre>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 7 `modInteger` 3
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 7 `mod` 3
--   1
--   </pre>
modInteger :: Integer -> Integer -> Integer

-- | Used to implement <tt>quotRem</tt> for the <tt>Integral</tt>
--   typeclass. This gives a tuple equivalent to
--   
--   <pre>
--   (quot x y, mod x y)
--   </pre>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; quotRemInteger 10 2
--   (5,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quotRem 10 2
--   (5,0)
--   </pre>
quotRemInteger :: Integer -> Integer -> (# Integer, Integer #)

-- | Used to implement <tt>quot</tt> for the <tt>Integral</tt> typeclass.
--   This performs integer division on its two parameters, truncated
--   towards zero.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; quotInteger 10 2
--   5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quot 10 2
--   5
--   </pre>
quotInteger :: Integer -> Integer -> Integer

-- | Used to implement <tt>rem</tt> for the <tt>Integral</tt> typeclass.
--   This gives the remainder after integer division of its two parameters,
--   satisfying
--   
--   <pre>
--   ((x `quot` y) * y) + (x `rem` y) == x
--   </pre>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; remInteger 3 2
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; rem 3 2
--   1
--   </pre>
remInteger :: Integer -> Integer -> Integer

-- | Used to implement <tt>(==)</tt> for the <tt>Eq</tt> typeclass. Outputs
--   <a>True</a> if two integers are equal to each other.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 6 `eqInteger` 6
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 6 == 6
--   True
--   </pre>
eqInteger :: Integer -> Integer -> Bool

-- | Used to implement <tt>(/=)</tt> for the <tt>Eq</tt> typeclass. Outputs
--   <a>True</a> if two integers are not equal to each other.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 6 `neqInteger` 7
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 6 /= 7
--   True
--   </pre>
neqInteger :: Integer -> Integer -> Bool

-- | Used to implement <tt>(&lt;=)</tt> for the <tt>Ord</tt> typeclass.
--   Outputs <a>True</a> if the first argument is less than or equal to the
--   second.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `leInteger` 5
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 &lt;= 5
--   True
--   </pre>
leInteger :: Integer -> Integer -> Bool

-- | Used to implement <tt>(&gt;)</tt> for the <tt>Ord</tt> typeclass.
--   Outputs <a>True</a> if the first argument is greater than the second.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 5 `gtInteger` 3
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5 &gt; 3
--   True
--   </pre>
gtInteger :: Integer -> Integer -> Bool

-- | Used to implement <tt>(&lt;)</tt> for the <tt>Ord</tt> typeclass.
--   Outputs <a>True</a> if the first argument is less than the second.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `ltInteger` 5
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 &lt; 5
--   True
--   </pre>
ltInteger :: Integer -> Integer -> Bool

-- | Used to implement <tt>(&gt;=)</tt> for the <tt>Ord</tt> typeclass.
--   Outputs <a>True</a> if the first argument is greater than or equal to
--   the second.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 5 `geInteger` 3
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5 &gt;= 3
--   True
--   </pre>
geInteger :: Integer -> Integer -> Bool

-- | Used to implement <tt>compare</tt> for the <tt>Integral</tt>
--   typeclass. This takes two integers, and outputs whether the first is
--   less than, equal to, or greater than the second.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compareInteger 2 10
--   LT
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; compare 2 10
--   LT
--   </pre>
compareInteger :: Integer -> Integer -> Ordering
eqInteger# :: Integer -> Integer -> Int#
neqInteger# :: Integer -> Integer -> Int#
leInteger# :: Integer -> Integer -> Int#
gtInteger# :: Integer -> Integer -> Int#
ltInteger# :: Integer -> Integer -> Int#
geInteger# :: Integer -> Integer -> Int#
andInteger :: Integer -> Integer -> Integer
orInteger :: Integer -> Integer -> Integer
xorInteger :: Integer -> Integer -> Integer
complementInteger :: Integer -> Integer
shiftLInteger :: Integer -> Int# -> Integer
shiftRInteger :: Integer -> Int# -> Integer
testBitInteger :: Integer -> Int# -> Bool
popCountInteger :: Integer -> Int#
bitInteger :: Int# -> Integer
hashInteger :: Integer -> Int#


-- | Compatibility module for pre ghc-bignum code.
module GHC.Internal.Integer.Logarithms
wordLog2# :: Word# -> Int#
integerLog2# :: Integer -> Int#
integerLogBase# :: Integer -> Integer -> Int#


-- | Maybe type
module GHC.Internal.Maybe

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Internal.Maybe.Maybe a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Internal.Maybe.Maybe a)


-- | Compatibility module for pre ghc-bignum code.
module GHC.Internal.Natural

-- | Natural number
--   
--   Invariant: numbers &lt;= 0xffffffffffffffff use the <a>NS</a>
--   constructor
data Natural
pattern NatS# :: Word# -> Natural
pattern NatJ# :: BigNat -> Natural

-- | A lifted BigNat
--   
--   Represented as an array of limbs (Word#) stored in little-endian order
--   (Word# themselves use machine order).
--   
--   Invariant (canonical representation): higher Word# is non-zero.
--   
--   As a consequence, zero is represented with a WordArray# whose size is
--   0.
data BigNat
BN# :: BigNat# -> BigNat
[unBigNat] :: BigNat -> BigNat#

-- | Construct <a>Natural</a> value from list of <a>Word</a>s.
mkNatural :: [Word] -> Natural

-- | Test whether all internal invariants are satisfied by <a>Natural</a>
--   value
--   
--   This operation is mostly useful for test-suites and/or code which
--   constructs <a>Integer</a> values directly.
isValidNatural :: Natural -> Bool

-- | <a>Natural</a> Addition
plusNatural :: Natural -> Natural -> Natural

-- | <a>Natural</a> subtraction. May <tt><a>throw</a>
--   <a>Underflow</a></tt>.
minusNatural :: Natural -> Natural -> Natural

-- | <a>Natural</a> subtraction. Returns <a>Nothing</a>s for non-positive
--   results.
minusNaturalMaybe :: Natural -> Natural -> Maybe Natural

-- | <a>Natural</a> multiplication
timesNatural :: Natural -> Natural -> Natural
negateNatural :: Natural -> Natural
signumNatural :: Natural -> Natural
quotRemNatural :: Natural -> Natural -> (Natural, Natural)
quotNatural :: Natural -> Natural -> Natural
remNatural :: Natural -> Natural -> Natural

-- | Compute greatest common divisor.
gcdNatural :: Natural -> Natural -> Natural

-- | Compute least common multiple.
lcmNatural :: Natural -> Natural -> Natural
andNatural :: Natural -> Natural -> Natural
orNatural :: Natural -> Natural -> Natural
xorNatural :: Natural -> Natural -> Natural
bitNatural :: Int# -> Natural
testBitNatural :: Natural -> Int -> Bool
popCountNatural :: Natural -> Int
shiftLNatural :: Natural -> Int -> Natural
shiftRNatural :: Natural -> Int -> Natural

naturalToInteger :: Natural -> Integer
naturalToWord :: Natural -> Word

-- | Try downcasting <a>Natural</a> to <a>Word</a> value. Returns
--   <a>Nothing</a> if value doesn't fit in <a>Word</a>.
naturalToWordMaybe :: Natural -> Maybe Word

-- | Construct <a>Natural</a> from <a>Word</a> value.
wordToNatural :: Word -> Natural
wordToNatural# :: Word -> Natural

naturalFromInteger :: Integer -> Natural

-- | "<tt><a>powModNatural</a> <i>b</i> <i>e</i> <i>m</i></tt>" computes
--   base <tt><i>b</i></tt> raised to exponent <tt><i>e</i></tt> modulo
--   <tt><i>m</i></tt>.
powModNatural :: Natural -> Natural -> Natural -> Natural


-- | The arbitrary-precision <a>Natural</a> number type.
module GHC.Internal.Numeric.Natural

-- | Natural number
--   
--   Invariant: numbers &lt;= 0xffffffffffffffff use the <a>NS</a>
--   constructor
data Natural

-- | <a>Natural</a> subtraction. Returns <a>Nothing</a>s for non-positive
--   results.
minusNaturalMaybe :: Natural -> Natural -> Maybe Natural


-- | This module defines the <a>HasField</a> class used by the
--   <tt>OverloadedRecordDot</tt> extension. See the
--   &lt;<a>https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/hasfield.html</a>
--   user's guide&gt; for more details.
module GHC.Internal.Records

-- | Constraint representing the fact that the field <tt>x</tt> belongs to
--   the record type <tt>r</tt> and has field type <tt>a</tt>. This will be
--   solved automatically, but manual instances may be provided as well.
class HasField (x :: k) (r :: TYPE r_rep) (a :: TYPE a_rep) | x r -> a

-- | Selector function to extract the field from the record.
getField :: HasField x r a => r -> a


-- | Type definitions for implicit call-stacks. Use <a>GHC.Stack</a> from
--   the base package instead of importing this module directly.
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.Stack.Types

-- | <a>CallStack</a>s are a lightweight method of obtaining a partial
--   call-stack at any point in the program.
--   
--   A function can request its call-site with the <a>HasCallStack</a>
--   constraint. For example, we can define
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   </pre>
--   
--   as a variant of <tt>putStrLn</tt> that will get its call-site and
--   print it, along with the string given as argument. We can access the
--   call-stack inside <tt>putStrLnWithCallStack</tt> with
--   <a>callStack</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   putStrLnWithCallStack msg = do
--     putStrLn msg
--     putStrLn (prettyCallStack callStack)
--   :}
--   </pre>
--   
--   Thus, if we call <tt>putStrLnWithCallStack</tt> we will get a
--   formatted call-stack alongside our string.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLnWithCallStack "hello"
--   hello
--   CallStack (from HasCallStack):
--     putStrLnWithCallStack, called at &lt;interactive&gt;:... in interactive:Ghci...
--   </pre>
--   
--   GHC solves <a>HasCallStack</a> constraints in three steps:
--   
--   <ol>
--   <li>If there is a <a>CallStack</a> in scope -- i.e. the enclosing
--   function has a <a>HasCallStack</a> constraint -- GHC will append the
--   new call-site to the existing <a>CallStack</a>.</li>
--   <li>If there is no <a>CallStack</a> in scope -- e.g. in the GHCi
--   session above -- and the enclosing definition does not have an
--   explicit type signature, GHC will infer a <a>HasCallStack</a>
--   constraint for the enclosing definition (subject to the monomorphism
--   restriction).</li>
--   <li>If there is no <a>CallStack</a> in scope and the enclosing
--   definition has an explicit type signature, GHC will solve the
--   <a>HasCallStack</a> constraint for the singleton <a>CallStack</a>
--   containing just the current call-site.</li>
--   </ol>
--   
--   <a>CallStack</a>s do not interact with the RTS and do not require
--   compilation with <tt>-prof</tt>. On the other hand, as they are built
--   up explicitly via the <a>HasCallStack</a> constraints, they will
--   generally not contain as much information as the simulated call-stacks
--   maintained by the RTS.
--   
--   A <a>CallStack</a> is a <tt>[(String, SrcLoc)]</tt>. The
--   <tt>String</tt> is the name of function that was called, the
--   <a>SrcLoc</a> is the call-site. The list is ordered with the most
--   recently called function at the head.
--   
--   NOTE: The intrepid user may notice that <a>HasCallStack</a> is just an
--   alias for an implicit parameter <tt>?callStack :: CallStack</tt>. This
--   is an implementation detail and <b>should not</b> be considered part
--   of the <a>CallStack</a> API, we may decide to change the
--   implementation in the future.
data CallStack
EmptyCallStack :: CallStack
PushCallStack :: [Char] -> SrcLoc -> CallStack -> CallStack

-- | Freeze the stack at the given <tt>CallStack</tt>, preventing any
--   further call-sites from being pushed onto it.
FreezeCallStack :: CallStack -> CallStack

-- | Request a CallStack.
--   
--   NOTE: The implicit parameter <tt>?callStack :: CallStack</tt> is an
--   implementation detail and <b>should not</b> be considered part of the
--   <a>CallStack</a> API, we may decide to change the implementation in
--   the future.
type HasCallStack = ?callStack :: CallStack

-- | The empty <a>CallStack</a>.
emptyCallStack :: CallStack

-- | Freeze a call-stack, preventing any further call-sites from being
--   appended.
--   
--   <pre>
--   pushCallStack callSite (freezeCallStack callStack) = freezeCallStack callStack
--   </pre>
freezeCallStack :: CallStack -> CallStack

-- | Convert a list of call-sites to a <a>CallStack</a>.
fromCallSiteList :: [([Char], SrcLoc)] -> CallStack

-- | Extract a list of call-sites from the <a>CallStack</a>.
--   
--   The list is ordered by most recent call.
getCallStack :: CallStack -> [([Char], SrcLoc)]

-- | Push a call-site onto the stack.
--   
--   This function has no effect on a frozen <a>CallStack</a>.
pushCallStack :: ([Char], SrcLoc) -> CallStack -> CallStack

-- | A single location in the source code.
data SrcLoc
SrcLoc :: [Char] -> [Char] -> [Char] -> Int -> Int -> Int -> Int -> SrcLoc
[srcLocPackage] :: SrcLoc -> [Char]
[srcLocModule] :: SrcLoc -> [Char]
[srcLocFile] :: SrcLoc -> [Char]
[srcLocStartLine] :: SrcLoc -> Int
[srcLocStartCol] :: SrcLoc -> Int
[srcLocEndLine] :: SrcLoc -> Int
[srcLocEndCol] :: SrcLoc -> Int
instance GHC.Classes.Eq GHC.Internal.Stack.Types.SrcLoc


-- | The <a>GHC.Err</a> module defines the code for the wired-in error
--   functions, which have a special type in the compiler (with "open
--   tyvars").
--   
--   We cannot define these functions in a module where they might be used
--   (e.g., <a>GHC.Base</a>), because the magical wired-in type will get
--   confused with what the typechecker figures out.
module GHC.Internal.Err

-- | Used for compiler-generated error message; encoding saves bytes of
--   string junk.
absentErr :: a

-- | <a>error</a> stops execution and displays an error message.
error :: HasCallStack => [Char] -> a

-- | A variant of <a>error</a> that does not produce a stack trace.
errorWithoutStackTrace :: [Char] -> a

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: HasCallStack => a


-- | Basic data types and classes.
module GHC.Internal.Base

-- | <tt><a>($)</a></tt> is the <b>function application</b> operator.
--   
--   Applying <tt><a>($)</a></tt> to a function <tt>f</tt> and an argument
--   <tt>x</tt> gives the same result as applying <tt>f</tt> to <tt>x</tt>
--   directly. The definition is akin to this:
--   
--   <pre>
--   ($) :: (a -&gt; b) -&gt; a -&gt; b
--   ($) f x = f x
--   </pre>
--   
--   This is <tt><a>id</a></tt> specialized from <tt>a -&gt; a</tt> to
--   <tt>(a -&gt; b) -&gt; (a -&gt; b)</tt> which by the associativity of
--   <tt>(-&gt;)</tt> is the same as <tt>(a -&gt; b) -&gt; a -&gt; b</tt>.
--   
--   On the face of it, this may appear pointless! But it's actually one of
--   the most useful and important operators in Haskell.
--   
--   The order of operations is very different between <tt>($)</tt> and
--   normal function application. Normal function application has
--   precedence 10 - higher than any operator - and associates to the left.
--   So these two definitions are equivalent:
--   
--   <pre>
--   expr = min 5 1 + 5
--   expr = ((min 5) 1) + 5
--   </pre>
--   
--   <tt>($)</tt> has precedence 0 (the lowest) and associates to the
--   right, so these are equivalent:
--   
--   <pre>
--   expr = min 5 $ 1 + 5
--   expr = (min 5) (1 + 5)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use cases of <tt>($)</tt> is to avoid parentheses in complex
--   expressions.
--   
--   For example, instead of using nested parentheses in the following
--   Haskell function:
--   
--   <pre>
--   -- | Sum numbers in a string: strSum "100  5 -7" == 98
--   strSum :: <a>String</a> -&gt; <a>Int</a>
--   strSum s = <tt>sum</tt> (<a>mapMaybe</a> <a>readMaybe</a> (<tt>words</tt> s))
--   </pre>
--   
--   we can deploy the function application operator:
--   
--   <pre>
--   -- | Sum numbers in a string: strSum "100  5 -7" == 98
--   strSum :: <a>String</a> -&gt; <a>Int</a>
--   strSum s = <tt>sum</tt> <a>$</a> <a>mapMaybe</a> <a>readMaybe</a> <a>$</a> <tt>words</tt> s
--   </pre>
--   
--   <tt>($)</tt> is also used as a section (a partially applied operator),
--   in order to indicate that we wish to apply some yet-unspecified
--   function to a given value. For example, to apply the argument
--   <tt>5</tt> to a list of functions:
--   
--   <pre>
--   applyFive :: [Int]
--   applyFive = map ($ 5) [(+1), (2^)]
--   &gt;&gt;&gt; [6, 32]
--   </pre>
--   
--   <h4><b>Technical Remark (Representation Polymorphism)</b></h4>
--   
--   <tt>($)</tt> is fully representation-polymorphic. This allows it to
--   also be used with arguments of unlifted and even unboxed kinds, such
--   as unboxed integers:
--   
--   <pre>
--   fastMod :: Int -&gt; Int -&gt; Int
--   fastMod (I# x) (I# m) = I# $ remInt# x m
--   </pre>
($) :: (a -> b) -> a -> b
infixr 0 $

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: (a -> b) -> a -> b
infixr 0 $!

-- | <a>(++)</a> appends two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
--   
--   <h4><b>Performance considerations</b></h4>
--   
--   This function takes linear time in the number of elements of the
--   <b>first</b> list. Thus it is better to associate repeated
--   applications of <a>(++)</a> to the right (which is the default
--   behaviour): <tt>xs ++ (ys ++ zs)</tt> or simply <tt>xs ++ ys ++
--   zs</tt>, but not <tt>(xs ++ ys) ++ zs</tt>. For the same reason
--   <a>concat</a> <tt>=</tt> <a>foldr</a> <a>(++)</a> <tt>[]</tt> has
--   linear performance, while <a>foldl</a> <a>(++)</a> <tt>[]</tt> is
--   prone to quadratic slowdown
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1, 2, 3] ++ [4, 5, 6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ++ [1, 2, 3]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [3, 2, 1] ++ []
--   [3,2,1]
--   </pre>
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | Right to left function composition.
--   
--   <pre>
--   (f . g) x = f (g x)
--   </pre>
--   
--   <pre>
--   f . id = f = id . f
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; map ((*2) . length) [[], [0, 1, 2], [0]]
--   [0,6,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (.) id [(+1), (*3), (^3)] 2
--   25
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let (...) = (.).(.) in ((*2)...(+)) 5 10
--   30
--   </pre>
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | A variant of <a>&lt;*&gt;</a> with the types of the arguments
--   reversed. It differs from <tt><a>flip</a> <a>(&lt;*&gt;)</a></tt> in
--   that the effects are resolved in the order the arguments are
--   presented.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; (&lt;**&gt;) (print 1) (id &lt;$ print 2)
--   1
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip (&lt;*&gt;) (print 1) (id &lt;$ print 2)
--   2
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ZipList [4, 5, 6] &lt;**&gt; ZipList [(+1), (*2), (/3)]
--   ZipList {getZipList = [5.0,10.0,2.0]}
--   </pre>
(<**>) :: Applicative f => f a -> f (a -> b) -> f b
infixl 4 <**>

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
--   
--   <pre>
--   as &gt;&gt;= f == f =&lt;&lt; as
--   </pre>
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | Since <a>Void</a> values logically don't exist, this witnesses the
--   logical reasoning tool of "ex falso quodlibet".
--   
--   <pre>
--   &gt;&gt;&gt; let x :: Either Void Int; x = Right 5
--   
--   &gt;&gt;&gt; :{
--   case x of
--       Right r -&gt; r
--       Left l  -&gt; absurd l
--   :}
--   5
--   </pre>
absurd :: Void -> a

-- | In many situations, the <a>liftM</a> operations can be replaced by
--   uses of <a>ap</a>, which promotes function application.
--   
--   <pre>
--   return f `ap` x1 `ap` ... `ap` xn
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   liftM&lt;n&gt; f x1 x2 ... xn
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; pure (\x y z -&gt; x + y * z) `ap` Just 1 `ap` Just 5 `ap` Just 10
--   Just 51
--   </pre>
ap :: Monad m => m (a -> b) -> m a -> m b

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: a -> a -> a

-- | If the first argument evaluates to <a>True</a>, then the result is the
--   second argument. Otherwise an <a>AssertionFailed</a> exception is
--   raised, containing a <a>String</a> with the source file and line
--   number of the call to <a>assert</a>.
--   
--   Assertions can normally be turned on or off with a compiler flag (for
--   GHC, assertions are normally on unless optimisation is turned on with
--   <tt>-O</tt> or the <tt>-fignore-asserts</tt> option is given). When
--   assertions are turned off, the first argument to <a>assert</a> is
--   ignored, and the second argument is returned as the result.
assert :: Bool -> a -> a

-- | A list producer that can be fused with <a>foldr</a>. This function is
--   merely
--   
--   <pre>
--   augment g xs = g (:) xs
--   </pre>
--   
--   but GHC's simplifier will transform an expression of the form
--   <tt><a>foldr</a> k z (<a>augment</a> g xs)</tt>, which may arise after
--   inlining, to <tt>g k (<a>foldr</a> k z xs)</tt>, which avoids
--   producing an intermediate list.
augment :: (forall b. () => (a -> b -> b) -> b -> b) -> [a] -> [a]
bindIO :: IO a -> (a -> IO b) -> IO b
breakpoint :: a -> a
breakpointCond :: Bool -> a -> a

-- | A list producer that can be fused with <a>foldr</a>. This function is
--   merely
--   
--   <pre>
--   build g = g (:) []
--   </pre>
--   
--   but GHC's simplifier will transform an expression of the form
--   <tt><a>foldr</a> k z (<a>build</a> g)</tt>, which may arise after
--   inlining, to <tt>g k z</tt>, which avoids producing an intermediate
--   list.
build :: (forall b. () => (a -> b -> b) -> b -> b) -> [a]

-- | <tt>const x y</tt> always evaluates to <tt>x</tt>, ignoring its second
--   argument.
--   
--   <pre>
--   const x = \_ -&gt; x
--   </pre>
--   
--   This function might seem useless at first glance, but it can be very
--   useful in a higher order context.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | Used to implement <a>div</a> for the <a>Integral</a> typeclass. This
--   performs integer division on its two parameters, truncated towards
--   negative infinity.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 10 `divInt` 2
--   5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 10 `div` 2
--   5
--   </pre>
divInt :: Int -> Int -> Int

-- | Used to implement <a>divMod</a> for the <a>Integral</a> typeclass.
--   This gives a tuple equivalent to
--   
--   <pre>
--   (div x y, mod x y)
--   </pre>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; divModInt 10 2
--   (5,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; divMod 10 2
--   (5,0)
--   </pre>
divModInt :: Int -> Int -> (Int, Int)

-- | This <a>String</a> equality predicate is used when desugaring
--   pattern-matches against strings.
eqString :: String -> String -> Bool
failIO :: String -> IO a

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   flip f x y = f y x
--   </pre>
--   
--   <pre>
--   flip . flip = id
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let (.&gt;) = flip (.) in (+1) .&gt; show $ 5
--   "6"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a list, reduces
--   the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
foldr :: (a -> b -> b) -> b -> [a] -> b

-- | Returns the tag of a constructor application; this function was once
--   used by the deriving code for Eq, Ord and Enum.
getTag :: forall {lev :: Levity} (a :: TYPE ('BoxedRep lev)). DataToTag a => a -> Int#

-- | Shift the argument left by the specified number of bits (which must be
--   non-negative).
iShiftL# :: Int# -> Int# -> Int#

-- | Shift the argument right (signed) by the specified number of bits
--   (which must be non-negative). The <a>RA</a> means "right, arithmetic"
--   (as opposed to RL for logical)
iShiftRA# :: Int# -> Int# -> Int#

-- | Shift the argument right (unsigned) by the specified number of bits
--   (which must be non-negative). The <a>RL</a> means "right, logical" (as
--   opposed to RA for arithmetic)
iShiftRL# :: Int# -> Int# -> Int#

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
--   
--   This function might seem useless at first glance, but it can be very
--   useful in a higher order context.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; length $ filter id [True, True, False, True]
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just (Just 3) &gt;&gt;= id
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr id 0 [(^3), (*5), (+2)]
--   1000
--   </pre>
id :: a -> a

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
--   
--   '<tt><a>join</a> bss</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do bs &lt;- bss
--      bs
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; join [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
--   [1,2,3,4,5,6,7,8,9]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; join (Just (Just 3))
--   Just 3
--   </pre>
--   
--   A common use of <a>join</a> is to run an <a>IO</a> computation
--   returned from an <a>STM</a> transaction, since <a>STM</a> transactions
--   can't perform <a>IO</a> directly. Recall that
--   
--   <pre>
--   <a>atomically</a> :: STM a -&gt; IO a
--   </pre>
--   
--   is used to run <a>STM</a> transactions atomically. So, by specializing
--   the types of <a>atomically</a> and <a>join</a> to
--   
--   <pre>
--   <a>atomically</a> :: STM (IO b) -&gt; IO (IO b)
--   <a>join</a>       :: IO (IO b)  -&gt; IO b
--   </pre>
--   
--   we can compose them as
--   
--   <pre>
--   <a>join</a> . <a>atomically</a> :: STM (IO b) -&gt; IO b
--   </pre>
--   
--   to run an <a>STM</a> transaction and the <a>IO</a> action it returns.
join :: Monad m => m (m a) -> m a

-- | Lift a function to actions. Equivalent to Functor's <a>fmap</a> but
--   implemented using only <a>Applicative</a>'s methods: <tt><a>liftA</a>
--   f a = <a>pure</a> f <a>&lt;*&gt;</a> a</tt>
--   
--   As such this function may be used to implement a <a>Functor</a>
--   instance from an <a>Applicative</a> one.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using the Applicative instance for Lists:
--   
--   <pre>
--   &gt;&gt;&gt; liftA (+1) [1, 2]
--   [2,3]
--   </pre>
--   
--   Or the Applicative instance for <a>Maybe</a>
--   
--   <pre>
--   &gt;&gt;&gt; liftA (+1) (Just 3)
--   Just 4
--   </pre>
liftA :: Applicative f => (a -> b) -> f a -> f b

-- | Lift a ternary function to actions.
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d

-- | Promote a function to a monad. This is equivalent to <a>fmap</a> but
--   specialised to Monads.
liftM :: Monad m => (a1 -> r) -> m a1 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; liftM2 (+) [0,1] [0,2]
--   [0,2,1,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; liftM2 (+) (Just 1) Nothing
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; liftM2 (+) (+ 3) (* 2) 5
--   18
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r

-- | &lt;math&gt;. <a>map</a> <tt>f xs</tt> is the list obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   this means that <tt>map id == id</tt>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map id [1, 2, 3]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (\n -&gt; 3 * n + 1) [1, 2, 3]
--   [4,7,10]
--   </pre>
map :: (a -> b) -> [a] -> [b]
mapFB :: (elt -> lst -> lst) -> (a -> elt) -> a -> lst -> lst

-- | <tt><a>mapM</a> f</tt> is equivalent to <tt><a>sequence</a> .
--   <a>map</a> f</tt>.
mapM :: Monad m => (a -> m b) -> [a] -> m [b]
maxInt :: Int
minInt :: Int

-- | Used to implement <a>mod</a> for the <a>Integral</a> typeclass. This
--   performs the modulo operation, satisfying
--   
--   <pre>
--   ((x `div` y) * y) + (x `mod` y) == x
--   </pre>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 7 `modInt` 3
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 7 `mod` 3
--   1
--   </pre>
modInt :: Int -> Int -> Int

-- | The <a>fromEnum</a> method restricted to the type <a>Char</a>.
ord :: Char -> Int

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | Used to implement <a>quot</a> for the <a>Integral</a> typeclass. This
--   performs integer division on its two parameters, truncated towards
--   zero.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; quotInt 10 2
--   5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quot 10 2
--   5
--   </pre>
quotInt :: Int -> Int -> Int

-- | Used to implement <a>quotRem</a> for the <a>Integral</a> typeclass.
--   This gives a tuple equivalent to
--   
--   <pre>
--   (quot x y, mod x y)
--   </pre>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; quotRemInt 10 2
--   (5,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quotRem 10 2
--   (5,0)
--   </pre>
quotRemInt :: Int -> Int -> (Int, Int)

-- | Used to implement <a>rem</a> for the <a>Integral</a> typeclass. This
--   gives the remainder after integer division of its two parameters,
--   satisfying
--   
--   <pre>
--   ((x `quot` y) * y) + (x `rem` y) == x
--   </pre>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; remInt 3 2
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; rem 3 2
--   1
--   </pre>
remInt :: Int -> Int -> Int
returnIO :: a -> IO a

-- | Evaluate each action in the sequence from left to right, and collect
--   the results.
sequence :: Monad m => [m a] -> m [a]

-- | Shift the argument left by the specified number of bits (which must be
--   non-negative).
shiftL# :: Word# -> Int# -> Word#

-- | Shift the argument right by the specified number of bits (which must
--   be non-negative). The <a>RL</a> means "right, logical" (as opposed to
--   RA for arithmetic) (although an arithmetic right shift wouldn't make
--   sense for Word#)
shiftRL# :: Word# -> Int# -> Word#

-- | This function is used to implement branchless shifts. If the number of
--   bits to shift is greater than or equal to the type size in bits, then
--   the shift must return 0. Instead of doing a test, we use a mask
--   obtained via this function which is branchless too.
--   
--   shift_mask m b | b &lt; m = 0xFF..FF | otherwise = 0
shift_mask :: Int# -> Int# -> Int#
thenIO :: IO a -> IO b -> IO b
unIO :: IO a -> State# RealWorld -> (# State# RealWorld, a #)
unsafeChr :: Int -> Char

-- | <tt><a>until</a> p f</tt> yields the result of applying <tt>f</tt>
--   until <tt>p</tt> holds.
until :: (a -> Bool) -> (a -> a) -> a -> a

-- | If <a>Void</a> is uninhabited then any <a>Functor</a> that holds only
--   values of type <a>Void</a> is holding no values. It is implemented in
--   terms of <tt>fmap absurd</tt>.
vacuous :: Functor f => f Void -> f a

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
--   
--   <pre>
--   &gt;&gt;&gt; putStr "pi:" &gt;&gt; when False (print 3.14159)
--   pi:
--   </pre>
when :: Applicative f => Bool -> f () -> f ()

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre><a>some</a> v = (:) <a>&lt;$&gt;</a> v <a>&lt;*&gt;</a>
--   <a>many</a> v</pre></li>
--   <li><pre><a>many</a> v = <a>some</a> v <a>&lt;|&gt;</a> <a>pure</a>
--   []</pre></li>
--   </ul>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing &lt;|&gt; Just 42
--   Just 42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1, 2] &lt;|&gt; [3, 4]
--   [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; empty &lt;|&gt; print (2^15)
--   32768
--   </pre>
class Applicative f => Alternative (f :: Type -> Type)

-- | The identity of <a>&lt;|&gt;</a>
--   
--   <pre>
--   empty &lt;|&gt; a     == a
--   a     &lt;|&gt; empty == a
--   </pre>
empty :: Alternative f => f a

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a

-- | One or more.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; some (putStr "la")
--   lalalalalalalalala... * goes on forever *
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; some Nothing
--   nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 5 &lt;$&gt; some (Just 1)
--   * hangs forever *
--   </pre>
--   
--   Note that this function can be used with Parsers based on
--   Applicatives. In that case <tt>some parser</tt> will attempt to parse
--   <tt>parser</tt> one or more times until it fails.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; many (putStr "la")
--   lalalalalalalalala... * goes on forever *
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; many Nothing
--   Just []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 5 &lt;$&gt; many (Just 1)
--   * hangs forever *
--   </pre>
--   
--   Note that this function can be used with Parsers based on
--   Applicatives. In that case <tt>many parser</tt> will attempt to parse
--   <tt>parser</tt> zero or more times until it fails.
many :: Alternative f => f a -> f [a]
infixl 3 <|>

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value into the Structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; pure 1 :: Maybe Int
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; pure 'z' :: [Char]
--   "z"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; pure (pure ":D") :: Maybe [String]
--   Just [":D"]
--   </pre>
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt><a>(&lt;$&gt;)</a></tt>,
--   <tt><a>(&lt;*&gt;)</a></tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
--   
--   This became a typeclass method in 4.10.0.0. Prior to that, it was a
--   function defined in terms of <a>&lt;*&gt;</a> and <a>fmap</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; liftA2 (,) (Just 3) (Just 5)
--   Just (3,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; liftA2 (+) [1, 2, 3] [4, 5, 6]
--   [5,6,7,6,7,8,7,8,9]
--   </pre>
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import GHC.Internal.Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds. See these articles by <a>School of Haskell</a> or
--   <a>David Luposchainsky</a> for an explanation.
class Functor (f :: Type -> Type)

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for <a>List</a>, <a>Maybe</a> and
--   <a>IO</a> defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
--   
--   An alternative name for this function is 'bind', but some people may
--   refer to it as 'flatMap', which results from it being equivalent to
--   
--   <pre>
--   \x f -&gt; <a>join</a> (<a>fmap</a> f x) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
--   </pre>
--   
--   which can be seen as mapping a value with <tt>Monad m =&gt; m a -&gt;
--   m (m b)</tt> and then 'flattening' <tt>m (m b)</tt> to <tt>m b</tt>
--   using <a>join</a>.
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
--   
--   or in terms of <tt><a>(&gt;&gt;=)</a></tt> as
--   
--   <pre>
--   as &gt;&gt;= const bs
--   </pre>
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type. This function should <i>not</i>
--   be different from its default implementation as <a>pure</a>. The
--   justification for the existence of this function is merely historic.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus (m :: Type -> Type)

-- | The identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
--   
--   The default definition is
--   
--   <pre>
--   mzero = <a>empty</a>
--   </pre>
mzero :: MonadPlus m => m a

-- | An associative operation. The default definition is
--   
--   <pre>
--   mplus = (<a>&lt;|&gt;</a>)
--   </pre>
mplus :: MonadPlus m => m a -> m a -> m a

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   You can alternatively define <a>mconcat</a> instead of <a>mempty</a>,
--   in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>mconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>mconcat</a> (<a>join</a> xss) =
--   <a>mconcat</a> (<a>fmap</a> <a>mconcat</a> xss)</tt></li>
--   <li><i>Subclass</i> <tt><a>mconcat</a> (<tt>toList</tt> xs) =
--   <a>sconcat</a> xs</tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello world" &lt;&gt; mempty
--   "Hello world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mempty &lt;&gt; [1, 2, 3]
--   [1,2,3]
--   </pre>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
--   
--   <pre>
--   &gt;&gt;&gt; mconcat ["Hello", " ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
mconcat :: Monoid a => [a] -> a

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|
data Opaque
O :: a -> Opaque

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
--   
--   You can alternatively define <a>sconcat</a> instead of
--   (<a>&lt;&gt;</a>), in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>sconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>sconcat</a> (<a>join</a> xss) =
--   <a>sconcat</a> (<a>fmap</a> <a>sconcat</a> xss)</tt></li>
--   </ul>
class Semigroup a

-- | An associative operation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [1, 2, 3] &lt;&gt; Just [4, 5, 6]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr "Hello, " &lt;&gt; putStrLn "World!"
--   Hello, World!
--   </pre>
(<>) :: Semigroup a => a -> a -> a

-- | Reduce a non-empty list with <a>&lt;&gt;</a>
--   
--   The default definition should be sufficient, but this can be
--   overridden for efficiency.
--   
--   <h4><b>Examples</b></h4>
--   
--   For the following examples, we will assume that we have:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.List.NonEmpty (NonEmpty (..))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ "Hello" :| [" ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Just [1, 2, 3] :| [Nothing, Just [4, 5, 6]]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Left 1 :| [Right 2, Left 3, Right 4]
--   Right 2
--   </pre>
sconcat :: Semigroup a => NonEmpty a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   The default definition will raise an exception for a multiplier that
--   is <tt>&lt;= 0</tt>. This may be overridden with an implementation
--   that is total. For monoids it is preferred to use
--   <tt>stimesMonoid</tt>.
--   
--   By making this a member of the class, idempotent semigroups and
--   monoids can upgrade this to execute in &lt;math&gt; by picking
--   <tt>stimes = <a>stimesIdempotent</a></tt> or <tt>stimes =
--   <a>stimesIdempotentMonoid</a></tt> respectively.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 4 [1]
--   [1,1,1,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 5 (putStr "hi!")
--   hi!hi!hi!hi!hi!
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 3 (Right ":)")
--   Right ":)"
--   </pre>
stimes :: (Semigroup a, Integral b) => b -> a -> a
infixr 6 <>

-- | Uninhabited data type
data Void

-- | <a>String</a> is an alias for a list of characters.
--   
--   String constants in Haskell are values of type <a>String</a>. That
--   means if you write a string literal like <tt>"hello world"</tt>, it
--   will have the type <tt>[Char]</tt>, which is the same as
--   <tt>String</tt>.
--   
--   <b>Note:</b> You can ask the compiler to automatically infer different
--   types with the <tt>-XOverloadedStrings</tt> language extension, for
--   example <tt>"hello world" :: Text</tt>. See <a>IsString</a> for more
--   information.
--   
--   Because <tt>String</tt> is just a list of characters, you can use
--   normal list functions to do basic string manipulation. See
--   <a>Data.List</a> for operations on lists.
--   
--   <h3><b>Performance considerations</b></h3>
--   
--   <tt>[Char]</tt> is a relatively memory-inefficient type. It is a
--   linked list of boxed word-size characters, internally it looks
--   something like:
--   
--   <pre>
--   ╭─────┬───┬──╮  ╭─────┬───┬──╮  ╭─────┬───┬──╮  ╭────╮
--   │ (:) │   │ ─┼─&gt;│ (:) │   │ ─┼─&gt;│ (:) │   │ ─┼─&gt;│ [] │
--   ╰─────┴─┼─┴──╯  ╰─────┴─┼─┴──╯  ╰─────┴─┼─┴──╯  ╰────╯
--           v               v               v
--          'a'             'b'             'c'
--   </pre>
--   
--   The <tt>String</tt> "abc" will use <tt>5*3+1 = 16</tt> (in general
--   <tt>5n+1</tt>) words of space in memory.
--   
--   Furthermore, operations like <a>(++)</a> (string concatenation) are
--   <tt>O(n)</tt> (in the left argument).
--   
--   For historical reasons, the <tt>base</tt> library uses <tt>String</tt>
--   in a lot of places for the conceptual simplicity, but library code
--   dealing with user-data should use the <a>text</a> package for Unicode
--   text, or the the <a>bytestring</a> package for binary data.
type String = [Char]

-- | Boolean "and", lazy in the second argument
(&&) :: Bool -> Bool -> Bool
infixr 3 &&
compareInt :: Int -> Int -> Ordering
compareInt# :: Int# -> Int# -> Ordering
compareWord :: Word -> Word -> Ordering
compareWord# :: Word# -> Word# -> Ordering
divInt# :: Int# -> Int# -> Int#
divInt16# :: Int16# -> Int16# -> Int16#
divInt32# :: Int32# -> Int32# -> Int32#
divInt8# :: Int8# -> Int8# -> Int8#
divModInt# :: Int# -> Int# -> (# Int#, Int# #)
divModInt16# :: Int16# -> Int16# -> (# Int16#, Int16# #)
divModInt32# :: Int32# -> Int32# -> (# Int32#, Int32# #)
divModInt8# :: Int8# -> Int8# -> (# Int8#, Int8# #)
eqChar :: Char -> Char -> Bool
eqDouble :: Double -> Double -> Bool
eqFloat :: Float -> Float -> Bool
eqInt :: Int -> Int -> Bool
eqWord :: Word -> Word -> Bool
geInt :: Int -> Int -> Bool
geWord :: Word -> Word -> Bool
gtInt :: Int -> Int -> Bool
gtWord :: Word -> Word -> Bool
leInt :: Int -> Int -> Bool
leWord :: Word -> Word -> Bool
ltInt :: Int -> Int -> Bool
ltWord :: Word -> Word -> Bool
modInt# :: Int# -> Int# -> Int#
modInt16# :: Int16# -> Int16# -> Int16#
modInt32# :: Int32# -> Int32# -> Int32#
modInt8# :: Int8# -> Int8# -> Int8#
neChar :: Char -> Char -> Bool
neInt :: Int -> Int -> Bool
neWord :: Word -> Word -> Bool

-- | Boolean "not"
not :: Bool -> Bool

-- | Boolean "or", lazy in the second argument
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, instances
--   are encouraged to follow these properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Extensionality</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=

-- | The syntax <tt>?x :: a</tt> is desugared into <tt>IP "x" a</tt> IP is
--   declared very early, so that libraries can take advantage of the
--   implicit-call-stack feature
class IP (x :: Symbol) a | x -> a
ip :: IP x a => a

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   <a>Ord</a>, as defined by the Haskell report, implements a total order
--   and has the following properties:
--   
--   <ul>
--   <li><i><b>Comparability</b></i> <tt>x &lt;= y || y &lt;= x</tt> =
--   <a>True</a></li>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   The following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Note that (7.) and (8.) do <i>not</i> require <a>min</a> and
--   <a>max</a> to return either of their arguments. The result is merely
--   required to <i>equal</i> one of the arguments in terms of <a>(==)</a>.
--   Users who expect a stronger guarantee are advised to write their own
--   min and/or max functions.
--   
--   The nuance of the above distinction is not always fully internalized
--   by developers, and in the past (tracing back to the Haskell 1.4
--   Report) the specification for <a>Ord</a> asserted the stronger
--   property that <tt>(min x y, max x y) = (x, y)</tt> or <tt>(y, x)</tt>,
--   or in other words, that <a>min</a> and <a>max</a> <i>will</i> return
--   one of their arguments, using argument order as the tie-breaker if the
--   arguments are equal by comparison. A few list and <a>Foldable</a>
--   functions have behavior that is best understood with this assumption
--   in mind: all variations of <tt>minimumBy</tt> and <tt>maximumBy</tt>
--   (which can't use <a>min</a> and <a>max</a> in their implementations)
--   are written such that <tt>minimumBy <a>compare</a></tt> and
--   <tt>maximumBy <a>compare</a></tt> are respectively equivalent to
--   <tt>minimum</tt> and <tt>maximum</tt> (which do use <a>min</a> and
--   <a>max</a>) only if <a>min</a> and <a>max</a> adhere to this
--   tie-breaking convention. Otherwise, if there are multiple least or
--   largest elements in a container, <tt>minimum</tt> and <tt>maximum</tt>
--   may not return the <i>same</i> one that <tt>minimumBy
--   <a>compare</a></tt> and <tt>maximumBy <a>compare</a></tt> do (though
--   they should return something that is <i>equal</i>). (This is relevant
--   for types with non-extensional equality, like <a>Arg</a>, but also in
--   cases where the precise reference held matters for memory-management
--   reasons.) Unless there is a reason to deviate, it is less confusing
--   for implementors of <a>Ord</a> to respect this same convention (as the
--   default definitions of <a>min</a> and <a>max</a> do).
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 <
infix 4 <=
infix 4 >

-- | Alias for <a>tagToEnum#</a>. Returns True if its parameter is 1# and
--   False if it is 0#.
isTrue# :: Int# -> Bool

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
newtype IO a
IO :: (State# RealWorld -> (# State# RealWorld, a #)) -> IO a

-- | A de Bruijn index for a binder within a <a>KindRep</a>.
type KindBndr = Int

-- | The representation produced by GHC for conjuring up the kind of a
--   <a>TypeRep</a>.
data KindRep
KindRepTyConApp :: TyCon -> [KindRep] -> KindRep
KindRepVar :: !KindBndr -> KindRep
KindRepApp :: KindRep -> KindRep -> KindRep
KindRepFun :: KindRep -> KindRep -> KindRep
KindRepTYPE :: !RuntimeRep -> KindRep
KindRepTypeLitS :: TypeLitSort -> Addr# -> KindRep
KindRepTypeLitD :: TypeLitSort -> [Char] -> KindRep
data Module
Module :: TrName -> TrName -> Module
type family MultMul (a :: Multiplicity) (b :: Multiplicity) :: Multiplicity
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | <a>SPEC</a> is used by GHC in the <tt>SpecConstr</tt> pass in order to
--   inform the compiler when to be particularly aggressive. In particular,
--   it tells GHC to specialize regardless of size or the number of
--   specializations. However, not all loops fall into this category.
--   
--   Libraries can specify this by using <a>SPEC</a> data type to inform
--   which loops should be aggressively specialized. For example, instead
--   of
--   
--   <pre>
--   loop x where loop arg = ...
--   </pre>
--   
--   write
--   
--   <pre>
--   loop SPEC x where loop !_ arg = ...
--   </pre>
--   
--   There is no semantic difference between <a>SPEC</a> and <a>SPEC2</a>,
--   we just need a type with two constructors lest it is optimised away
--   before <tt>SpecConstr</tt>.
--   
--   This type is reexported from <a>GHC.Exts</a> since GHC 9.0 and
--   <tt>base-4.15</tt>. For compatibility with earlier releases import it
--   from <a>GHC.Types</a> in <tt>ghc-prim</tt> package.
data SPEC
SPEC :: SPEC
SPEC2 :: SPEC
data TrName

-- | Static
TrNameS :: Addr# -> TrName

-- | Dynamic
TrNameD :: [Char] -> TrName
data TyCon
TyCon :: Word64# -> Word64# -> Module -> TrName -> Int# -> KindRep -> TyCon
data TypeLitSort
TypeLitSymbol :: TypeLitSort
TypeLitNat :: TypeLitSort
TypeLitChar :: TypeLitSort

-- | <i>Deprecated: Void# is now an alias for the unboxed tuple (# #).</i>
type Void# = (# #)
data CONSTRAINT (a :: RuntimeRep)
data TYPE (a :: RuntimeRep)

-- | The type constructor <tt>Any :: forall k. k</tt> is a type to which
--   you can unsafely coerce any type, and back.
--   
--   For <tt>unsafeCoerce</tt> this means for all lifted types <tt>t</tt>
--   that <tt>unsafeCoerce (unsafeCoerce x :: Any) :: t</tt> is equivalent
--   to <tt>x</tt> and safe.
--   
--   The same is true for *all* types when using <tt> unsafeCoerce# ::
--   forall (r1 :: RuntimeRep) (r2 :: RuntimeRep) (a :: TYPE r1) (b :: TYPE
--   r2). a -&gt; b </tt> but <i>only</i> if you instantiate <tt>r1</tt>
--   and <tt>r2</tt> to the <i>same</i> runtime representation. For example
--   using <tt>(unsafeCoerce# :: forall (a :: TYPE IntRep) (b :: TYPE
--   IntRep). a -&gt; b) x</tt> is fine, but <tt>(unsafeCoerce# :: forall
--   (a :: TYPE IntRep) (b :: TYPE FloatRep). a -&gt; b)</tt> will likely
--   cause seg-faults or worse. For this resason, users should always
--   prefer unsafeCoerce over unsafeCoerce# when possible.
--   
--   Here are some more examples: <tt> bad_a1 :: Any </tt>(TYPE 'IntRep)
--   bad_a1 = unsafeCoerce# True
--   
--   bad_a2 :: Any <tt>(TYPE ('BoxedRep 'UnliftedRep)) bad_a2 =
--   unsafeCoerce# True </tt> Here <tt>bad_a1</tt> is bad because we
--   started with <tt>True :: (Bool :: Type)</tt>, represented by a boxed
--   heap pointer, and coerced it to <tt>a1 :: Any </tt>(TYPE 'IntRep)<tt>,
--   whose representation is a non-pointer integer. That's why we had to
--   use <tt>unsafeCoerce#</tt>; it is really unsafe because it can change
--   representations. Similarly </tt>bad_a2<tt> is bad because although
--   both </tt>True<tt> and </tt>bad_a2<tt> are represented by a heap
--   pointer, </tt>True<tt> is lifted but </tt>bad_a2@ is not; bugs here
--   may be rather subtle.
--   
--   If you must use unsafeCoerce# to cast to <a>Any</a>, type annotations
--   are recommended to make sure that <tt>Any</tt> has the correct kind.
--   As casting between different runtimereps is unsound. For example to
--   cast a <tt>ByteArray#</tt> to <tt>Any</tt> you might use: <tt>
--   unsafeCoerce# b :: (Any :: TYPE ('BoxedRep 'Unlifted)) </tt>
type family Any :: k
data Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> represents Unicode codespace and its
--   elements are code points as in definitions <a>D9 and D10 of the
--   Unicode Standard</a>.
--   
--   Character literals in Haskell are single-quoted: <tt>'Q'</tt>,
--   <tt>'Я'</tt> or <tt>'Ω'</tt>. To represent a single quote itself use
--   <tt>'\''</tt>, and to represent a backslash use <tt>'\\'</tt>. The
--   full grammar can be found in the section 2.6 of the <a>Haskell 2010
--   Language Report</a>.
--   
--   To specify a character by its code point one can use decimal,
--   hexadecimal or octal notation: <tt>'\65'</tt>, <tt>'\x41'</tt> and
--   <tt>'\o101'</tt> are all alternative forms of <tt>'A'</tt>. The
--   largest code point is <tt>'\x10ffff'</tt>.
--   
--   There is a special escape syntax for ASCII control characters:
--   
--   TODO: table
--   
--   <a>Data.Char</a> provides utilities to work with <a>Char</a>.
data Char
C# :: Char# -> Char

-- | <tt>Coercible</tt> is a two-parameter class that has instances for
--   types <tt>a</tt> and <tt>b</tt> if the compiler can infer that they
--   have the same representation. This class does not have regular
--   instances; instead they are created on-the-fly during type-checking.
--   Trying to manually declare an instance of <tt>Coercible</tt> is an
--   error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance Coercible a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class a ~R# b => Coercible (a :: k) (b :: k)

-- | The kind of lifted constraints
type Constraint = CONSTRAINT LiftedRep

-- | Data type <tt>Dict</tt> provides a simple way to wrap up a (lifted)
--   constraint as a type
data DictBox a
MkDictBox :: DictBox a

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double
D# :: Double# -> Double
data DoubleBox (a :: TYPE 'DoubleRep)
MkDoubleBox :: a -> DoubleBox (a :: TYPE 'DoubleRep)

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float
F# :: Float# -> Float
data FloatBox (a :: TYPE 'FloatRep)
MkFloatBox :: a -> FloatBox (a :: TYPE 'FloatRep)

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int
I# :: Int# -> Int
data IntBox (a :: TYPE 'IntRep)
MkIntBox :: a -> IntBox (a :: TYPE 'IntRep)

-- | Whether a boxed type is lifted or unlifted.
data Levity
Lifted :: Levity
Unlifted :: Levity

-- | The runtime representation of lifted types.
type LiftedRep = 'BoxedRep 'Lifted

-- | The builtin linked list type.
--   
--   In Haskell, lists are one of the most important data types as they are
--   often used analogous to loops in imperative programming languages.
--   These lists are singly linked, which makes them unsuited for
--   operations that require &lt;math&gt; access. Instead, they are
--   intended to be traversed.
--   
--   You can use <tt>List a</tt> or <tt>[a]</tt> in type signatures:
--   
--   <pre>
--   length :: [a] -&gt; Int
--   </pre>
--   
--   or
--   
--   <pre>
--   length :: List a -&gt; Int
--   </pre>
--   
--   They are fully equivalent, and <tt>List a</tt> will be normalised to
--   <tt>[a]</tt>.
--   
--   <h4>Usage</h4>
--   
--   Lists are constructed recursively using the right-associative
--   constructor operator (or <i>cons</i>) <tt>(:) :: a -&gt; [a] -&gt;
--   [a]</tt>, which prepends an element to a list, and the empty list
--   <tt>[]</tt>.
--   
--   <pre>
--   (1 : 2 : 3 : []) == (1 : (2 : (3 : []))) == [1, 2, 3]
--   </pre>
--   
--   Lists can also be constructed using list literals of the form
--   <tt>[x_1, x_2, ..., x_n]</tt> which are syntactic sugar and, unless
--   <tt>-XOverloadedLists</tt> is enabled, are translated into uses of
--   <tt>(:)</tt> and <tt>[]</tt>
--   
--   <a>String</a> literals, like <tt>"I 💜 hs"</tt>, are translated into
--   Lists of characters, <tt>['I', ' ', '💜', ' ', 'h', 's']</tt>.
--   
--   <h4><b>Implementation</b></h4>
--   
--   Internally and in memory, all the above are represented like this,
--   with arrows being pointers to locations in memory.
--   
--   <pre>
--   ╭───┬───┬──╮   ╭───┬───┬──╮   ╭───┬───┬──╮   ╭────╮
--   │(:)│   │ ─┼──&gt;│(:)│   │ ─┼──&gt;│(:)│   │ ─┼──&gt;│ [] │
--   ╰───┴─┼─┴──╯   ╰───┴─┼─┴──╯   ╰───┴─┼─┴──╯   ╰────╯
--         v              v              v
--         1              2              3
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; ['H', 'a', 's', 'k', 'e', 'l', 'l']
--   "Haskell"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 : [4, 1, 5, 9]
--   [1,4,1,5,9]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] : [] : []
--   [[],[]]
--   </pre>
data [] a
data Multiplicity
One :: Multiplicity
Many :: Multiplicity

-- | GHC maintains a property that the kind of all inhabited types (as
--   distinct from type constructors or type-level data) tells us the
--   runtime representation of values of that type. This datatype encodes
--   the choice of runtime value. Note that <a>TYPE</a> is parameterised by
--   <a>RuntimeRep</a>; this is precisely what we mean by the fact that a
--   type's kind encodes the runtime representation.
--   
--   For boxed values (that is, values that are represented by a pointer),
--   a further distinction is made, between lifted types (that contain ⊥),
--   and unlifted ones (that don't).
data RuntimeRep

-- | a SIMD vector type
VecRep :: VecCount -> VecElem -> RuntimeRep

-- | An unboxed tuple of the given reps
TupleRep :: [RuntimeRep] -> RuntimeRep

-- | An unboxed sum of the given reps
SumRep :: [RuntimeRep] -> RuntimeRep

-- | boxed; represented by a pointer
BoxedRep :: Levity -> RuntimeRep

-- | signed, word-sized value
IntRep :: RuntimeRep

-- | signed, 8-bit value
Int8Rep :: RuntimeRep

-- | signed, 16-bit value
Int16Rep :: RuntimeRep

-- | signed, 32-bit value
Int32Rep :: RuntimeRep

-- | signed, 64-bit value
Int64Rep :: RuntimeRep

-- | unsigned, word-sized value
WordRep :: RuntimeRep

-- | unsigned, 8-bit value
Word8Rep :: RuntimeRep

-- | unsigned, 16-bit value
Word16Rep :: RuntimeRep

-- | unsigned, 32-bit value
Word32Rep :: RuntimeRep

-- | unsigned, 64-bit value
Word64Rep :: RuntimeRep

-- | A pointer, but <i>not</i> to a Haskell value
AddrRep :: RuntimeRep

-- | a 32-bit floating point number
FloatRep :: RuntimeRep

-- | a 64-bit floating point number
DoubleRep :: RuntimeRep

-- | (Kind) This is the kind of type-level symbols.
data Symbol

-- | The kind of types with lifted values. For example <tt>Int ::
--   Type</tt>.
type Type = TYPE LiftedRep

-- | The runtime representation of unlifted types.
type UnliftedRep = 'BoxedRep 'Unlifted

-- | The kind of boxed, unlifted values, for example <tt>Array#</tt> or a
--   user-defined unlifted data type, using <tt>-XUnliftedDataTypes</tt>.
type UnliftedType = TYPE UnliftedRep

-- | Length of a SIMD vector type
data VecCount
Vec2 :: VecCount
Vec4 :: VecCount
Vec8 :: VecCount
Vec16 :: VecCount
Vec32 :: VecCount
Vec64 :: VecCount

-- | Element of a SIMD vector type
data VecElem
Int8ElemRep :: VecElem
Int16ElemRep :: VecElem
Int32ElemRep :: VecElem
Int64ElemRep :: VecElem
Word8ElemRep :: VecElem
Word16ElemRep :: VecElem
Word32ElemRep :: VecElem
Word64ElemRep :: VecElem
FloatElemRep :: VecElem
DoubleElemRep :: VecElem

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word
W# :: Word# -> Word
data WordBox (a :: TYPE 'WordRep)
MkWordBox :: a -> WordBox (a :: TYPE 'WordRep)

-- | The runtime representation of a zero-width tuple, represented by no
--   bits at all
type ZeroBitRep = 'TupleRep '[] :: [RuntimeRep]

-- | The kind of the empty unboxed tuple type (# #)
type ZeroBitType = TYPE ZeroBitRep

-- | Lifted, homogeneous equality. By lifted, we mean that it can be bogus
--   (deferred type error). By homogeneous, the two types <tt>a</tt> and
--   <tt>b</tt> must have the same kinds.
class a ~# b => (a :: k) ~ (b :: k)
infix 4 ~

-- | Lifted, heterogeneous equality. By lifted, we mean that it can be
--   bogus (deferred type error). By heterogeneous, the two types
--   <tt>a</tt> and <tt>b</tt> might have different kinds. Because
--   <tt>~~</tt> can appear unexpectedly in error messages to users who do
--   not care about the difference between heterogeneous equality
--   <tt>~~</tt> and homogeneous equality <tt>~</tt>, this is printed as
--   <tt>~</tt> unless <tt>-fprint-equality-relations</tt> is set.
--   
--   In <tt>0.7.0</tt>, the fixity was set to <tt>infix 4</tt> to match the
--   fixity of <a>:~~:</a>.
class a ~# b => (a :: k0) ~~ (b :: k1)
infix 4 ~~

-- | Low word of signed integer multiply.
(*#) :: Int# -> Int# -> Int#
infixl 7 *#
(*##) :: Double# -> Double# -> Double#
infixl 7 *##

-- | Exponentiation.
(**##) :: Double# -> Double# -> Double#
(+#) :: Int# -> Int# -> Int#
infixl 6 +#
(+##) :: Double# -> Double# -> Double#
infixl 6 +##
(-#) :: Int# -> Int# -> Int#
infixl 6 -#
(-##) :: Double# -> Double# -> Double#
infixl 6 -##
(/##) :: Double# -> Double# -> Double#
infixl 7 /##
(/=#) :: Int# -> Int# -> Int#
infix 4 /=#
(/=##) :: Double# -> Double# -> Int#
infix 4 /=##
(<#) :: Int# -> Int# -> Int#
infix 4 <#
(<##) :: Double# -> Double# -> Int#
infix 4 <##
(<=#) :: Int# -> Int# -> Int#
infix 4 <=#
(<=##) :: Double# -> Double# -> Int#
infix 4 <=##
(==#) :: Int# -> Int# -> Int#
infix 4 ==#
(==##) :: Double# -> Double# -> Int#
infix 4 ==##
(>#) :: Int# -> Int# -> Int#
infix 4 >#
(>##) :: Double# -> Double# -> Int#
infix 4 >##
(>=#) :: Int# -> Int# -> Int#
infix 4 >=#
(>=##) :: Double# -> Double# -> Int#
infix 4 >=##
acosDouble# :: Double# -> Double#
acosFloat# :: Float# -> Float#
acoshDouble# :: Double# -> Double#
acoshFloat# :: Float# -> Float#

-- | <tt><a>addCFinalizerToWeak#</a> fptr ptr flag eptr w</tt> attaches a C
--   function pointer <tt>fptr</tt> to a weak pointer <tt>w</tt> as a
--   finalizer. If <tt>flag</tt> is zero, <tt>fptr</tt> will be called with
--   one argument, <tt>ptr</tt>. Otherwise, it will be called with two
--   arguments, <tt>eptr</tt> and <tt>ptr</tt>. <a>addCFinalizerToWeak#</a>
--   returns 1 on success, or 0 if <tt>w</tt> is already dead.
addCFinalizerToWeak# :: forall {k :: Levity} (b :: TYPE ('BoxedRep k)). Addr# -> Addr# -> Int# -> Addr# -> Weak# b -> State# RealWorld -> (# State# RealWorld, Int# #)

-- | Add signed integers reporting overflow. First member of result is the
--   sum truncated to an <a>Int#</a>; second member is zero if the true sum
--   fits in an <a>Int#</a>, nonzero if overflow occurred (the sum is
--   either too large or too small to fit in an <a>Int#</a>).
addIntC# :: Int# -> Int# -> (# Int#, Int# #)

-- | Add unsigned integers reporting overflow. The first element of the
--   pair is the result. The second element is the carry flag, which is
--   nonzero on overflow. See also <a>plusWord2#</a>.
addWordC# :: Word# -> Word# -> (# Word#, Int# #)

-- | Coerce directly from address to int. Users are discouraged from using
--   this operation as it makes little sense on platforms with tagged
--   pointers.
addr2Int# :: Addr# -> Int#

-- | Convert an <a>Addr#</a> to a followable Any type.
addrToAny# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Addr# -> (# a #)
and# :: Word# -> Word# -> Word#
and64# :: Word64# -> Word64# -> Word64#

-- | Bitwise "and".
andI# :: Int# -> Int# -> Int#
andWord16# :: Word16# -> Word16# -> Word16#
andWord32# :: Word32# -> Word32# -> Word32#
andWord8# :: Word8# -> Word8# -> Word8#

-- | Retrieve the address of any Haskell value. This is essentially an
--   <tt>unsafeCoerce#</tt>, but if implemented as such the core lint pass
--   complains and fails to compile. As a primop, it is opaque to core/stg,
--   and only appears in cmm (where the copy propagation pass will get rid
--   of it). Note that "a" must be a value, not a thunk! It's too late for
--   strictness analysis to enforce this, so you're on your own to
--   guarantee this. Also note that <a>Addr#</a> is not a GC pointer - up
--   to you to guarantee that it does not become a dangling pointer
--   immediately after you get it.
anyToAddr# :: a -> State# RealWorld -> (# State# RealWorld, Addr# #)
asinDouble# :: Double# -> Double#
asinFloat# :: Float# -> Float#
asinhDouble# :: Double# -> Double#
asinhFloat# :: Float# -> Float#
atanDouble# :: Double# -> Double#
atanFloat# :: Float# -> Float#
atanhDouble# :: Double# -> Double#
atanhFloat# :: Float# -> Float#

-- | Compare and swap on a word-sized memory location.
--   
--   Use as: s -&gt; atomicCasAddrAddr# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasAddrAddr# :: Addr# -> Addr# -> Addr# -> State# d -> (# State# d, Addr# #)

-- | Compare and swap on a 16 bit-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr16# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWord16Addr# :: Addr# -> Word16# -> Word16# -> State# d -> (# State# d, Word16# #)

-- | Compare and swap on a 32 bit-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr32# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWord32Addr# :: Addr# -> Word32# -> Word32# -> State# d -> (# State# d, Word32# #)

-- | Compare and swap on a 64 bit-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr64# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWord64Addr# :: Addr# -> Word64# -> Word64# -> State# d -> (# State# d, Word64# #)

-- | Compare and swap on a 8 bit-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr8# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWord8Addr# :: Addr# -> Word8# -> Word8# -> State# d -> (# State# d, Word8# #)

-- | Compare and swap on a word-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWordAddr# :: Addr# -> Word# -> Word# -> State# d -> (# State# d, Word# #)

-- | The atomic exchange operation. Atomically exchanges the value at the
--   first address with the Addr# given as second argument. Implies a read
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicExchangeAddrAddr# :: Addr# -> Addr# -> State# d -> (# State# d, Addr# #)

-- | The atomic exchange operation. Atomically exchanges the value at the
--   address with the given value. Returns the old value. Implies a read
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicExchangeWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Modify the contents of a <a>MutVar#</a>, returning the previous
--   contents <tt>x :: a</tt> and the result of applying the given function
--   to the previous contents <tt>f x :: c</tt>.
--   
--   The <tt>data</tt> type <tt>c</tt> (not a <tt>newtype</tt>!) must be a
--   record whose first field is of lifted type <tt>a :: Type</tt> and is
--   not unpacked. For example, product types <tt>c ~ Solo a</tt> or <tt>c
--   ~ (a, b)</tt> work well. If the record type is both monomorphic and
--   strict in its first field, it's recommended to mark the latter <tt>{-#
--   NOUNPACK #-}</tt> explicitly.
--   
--   Under the hood <a>atomicModifyMutVar2#</a> atomically replaces a
--   pointer to an old <tt>x :: a</tt> with a pointer to a selector thunk
--   <tt>fst r</tt>, where <tt>fst</tt> is a selector for the first field
--   of the record and <tt>r</tt> is a function application thunk <tt>r = f
--   x</tt>.
--   
--   <tt>atomicModifyIORef2Native</tt> from <tt>atomic-modify-general</tt>
--   package makes an effort to reflect restrictions on <tt>c</tt>
--   faithfully, providing a well-typed high-level wrapper.
atomicModifyMutVar2# :: MutVar# d a -> (a -> c) -> State# d -> (# State# d, a, c #)

-- | Modify the contents of a <a>MutVar#</a>, returning the previous
--   contents and the result of applying the given function to the previous
--   contents.
atomicModifyMutVar_# :: MutVar# d a -> (a -> a) -> State# d -> (# State# d, a, a #)

-- | Given an array and an offset in machine words, read an element. The
--   index is assumed to be in bounds. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicReadIntArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an address, read a machine word. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicReadWordAddr# :: Addr# -> State# d -> (# State# d, Word# #)

-- | Atomically exchange the value of a <a>MutVar#</a>.
atomicSwapMutVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutVar# d a -> a -> State# d -> (# State# d, a #)

-- | Given an array and an offset in machine words, write an element. The
--   index is assumed to be in bounds. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicWriteIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Given an address, write a machine word. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicWriteWordAddr# :: Addr# -> Word# -> State# d -> State# d
atomically# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)

-- | Reverse the order of the bits in a word.
bitReverse# :: Word# -> Word#

-- | Reverse the order of the bits in a 16-bit word.
bitReverse16# :: Word# -> Word#

-- | Reverse the order of the bits in a 32-bit word.
bitReverse32# :: Word# -> Word#

-- | Reverse the order of the bits in a 64-bit word.
bitReverse64# :: Word64# -> Word64#

-- | Reverse the order of the bits in a 8-bit word.
bitReverse8# :: Word# -> Word#

-- | Broadcast a scalar to all elements of a vector.
broadcastDoubleX2# :: Double# -> DoubleX2#

-- | Broadcast a scalar to all elements of a vector.
broadcastDoubleX4# :: Double# -> DoubleX4#

-- | Broadcast a scalar to all elements of a vector.
broadcastDoubleX8# :: Double# -> DoubleX8#

-- | Broadcast a scalar to all elements of a vector.
broadcastFloatX16# :: Float# -> FloatX16#

-- | Broadcast a scalar to all elements of a vector.
broadcastFloatX4# :: Float# -> FloatX4#

-- | Broadcast a scalar to all elements of a vector.
broadcastFloatX8# :: Float# -> FloatX8#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt16X16# :: Int16# -> Int16X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt16X32# :: Int16# -> Int16X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt16X8# :: Int16# -> Int16X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt32X16# :: Int32# -> Int32X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt32X4# :: Int32# -> Int32X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt32X8# :: Int32# -> Int32X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt64X2# :: Int64# -> Int64X2#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt64X4# :: Int64# -> Int64X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt64X8# :: Int64# -> Int64X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt8X16# :: Int8# -> Int8X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt8X32# :: Int8# -> Int8X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt8X64# :: Int8# -> Int8X64#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord16X16# :: Word16# -> Word16X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord16X32# :: Word16# -> Word16X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord16X8# :: Word16# -> Word16X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord32X16# :: Word32# -> Word32X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord32X4# :: Word32# -> Word32X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord32X8# :: Word32# -> Word32X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord64X2# :: Word64# -> Word64X2#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord64X4# :: Word64# -> Word64X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord64X8# :: Word64# -> Word64X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord8X16# :: Word8# -> Word8X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord8X32# :: Word8# -> Word8X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord8X64# :: Word8# -> Word8X64#

-- | Intended for use with pinned arrays; otherwise very unsafe!
byteArrayContents# :: ByteArray# -> Addr#

-- | Swap bytes in a word.
byteSwap# :: Word# -> Word#

-- | Swap bytes in the lower 16 bits of a word. The higher bytes are
--   undefined.
byteSwap16# :: Word# -> Word#

-- | Swap bytes in the lower 32 bits of a word. The higher bytes are
--   undefined.
byteSwap32# :: Word# -> Word#

-- | Swap bytes in a 64 bits of a word.
byteSwap64# :: Word64# -> Word64#

-- | Given an array, an offset, the expected old value, and the new value,
--   perform an atomic compare and swap (i.e. write the new value if the
--   current value and the old value are the same pointer). Returns 0 if
--   the swap succeeds and 1 if it fails. Additionally, returns the element
--   at the offset after the operation completes. This means that on a
--   success the new value is returned, and on a failure the actual old
--   value (not the expected one) is returned. Implies a full memory
--   barrier. The use of a pointer equality on a boxed value makes this
--   function harder to use correctly than <a>casIntArray#</a>. All of the
--   difficulties of using <a>reallyUnsafePtrEquality#</a> correctly apply
--   to <a>casArray#</a> as well.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)

-- | Given an array, an offset in 16 bit units, the expected old value, and
--   the new value, perform an atomic compare and swap i.e. write the new
--   value if the current value matches the provided old value. Returns the
--   value of the element before the operation. Implies a full memory
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casInt16Array# :: MutableByteArray# d -> Int# -> Int16# -> Int16# -> State# d -> (# State# d, Int16# #)

-- | Given an array, an offset in 32 bit units, the expected old value, and
--   the new value, perform an atomic compare and swap i.e. write the new
--   value if the current value matches the provided old value. Returns the
--   value of the element before the operation. Implies a full memory
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casInt32Array# :: MutableByteArray# d -> Int# -> Int32# -> Int32# -> State# d -> (# State# d, Int32# #)

-- | Given an array, an offset in 64 bit units, the expected old value, and
--   the new value, perform an atomic compare and swap i.e. write the new
--   value if the current value matches the provided old value. Returns the
--   value of the element before the operation. Implies a full memory
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casInt64Array# :: MutableByteArray# d -> Int# -> Int64# -> Int64# -> State# d -> (# State# d, Int64# #)

-- | Given an array, an offset in bytes, the expected old value, and the
--   new value, perform an atomic compare and swap i.e. write the new value
--   if the current value matches the provided old value. Returns the value
--   of the element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casInt8Array# :: MutableByteArray# d -> Int# -> Int8# -> Int8# -> State# d -> (# State# d, Int8# #)

-- | Given an array, an offset in machine words, the expected old value,
--   and the new value, perform an atomic compare and swap i.e. write the
--   new value if the current value matches the provided old value. Returns
--   the value of the element before the operation. Implies a full memory
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casIntArray# :: MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Compare-and-swap: perform a pointer equality test between the first
--   value passed to this function and the value stored inside the
--   <a>MutVar#</a>. If the pointers are equal, replace the stored value
--   with the second value passed to this function, otherwise do nothing.
--   Returns the final value stored inside the <a>MutVar#</a>. The
--   <a>Int#</a> indicates whether a swap took place, with <tt>1#</tt>
--   meaning that we didn't swap, and <tt>0#</tt> that we did. Implies a
--   full memory barrier. Because the comparison is done on the level of
--   pointers, all of the difficulties of using
--   <a>reallyUnsafePtrEquality#</a> correctly apply to <a>casMutVar#</a>
--   as well.
casMutVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutVar# d a -> a -> a -> State# d -> (# State# d, Int#, a #)

-- | Unsafe, machine-level atomic compare and swap on an element within an
--   array. See the documentation of <a>casArray#</a>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casSmallArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)

-- | Bitcast a <a>Double#</a> into a <a>Word64#</a>
castDoubleToWord64# :: Double# -> Word64#

-- | Bitcast a <a>Float#</a> into a <a>Word32#</a>
castFloatToWord32# :: Float# -> Word32#

-- | Bitcast a <a>Word32#</a> into a <a>Float#</a>
castWord32ToFloat# :: Word32# -> Float#

-- | Bitcast a <a>Word64#</a> into a <a>Double#</a>
castWord64ToDouble# :: Word64# -> Double#

-- | <tt><a>catch#</a> k handler s</tt> evaluates <tt>k s</tt>, invoking
--   <tt>handler</tt> on any exceptions thrown.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
catch# :: forall {k :: Levity} a (b :: TYPE ('BoxedRep k)). (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
catchRetry# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). (State# RealWorld -> (# State# RealWorld, a #)) -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
catchSTM# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) b. (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
chr# :: Int# -> Char#

-- | Run the supplied IO action with an empty CCS. For example, this is
--   used by the interpreter to run an interpreted computation without the
--   call stack showing that it was invoked from GHC.
clearCCS# :: (State# d -> (# State# d, a #)) -> State# d -> (# State# d, a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Array# a -> Int# -> Int# -> Array# a

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). SmallArray# a -> Int# -> Int# -> SmallArray# a

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)

-- | <tt><a>closureSize#</a> closure</tt> returns the size of the given
--   closure in machine words.
closureSize# :: a -> Int#

-- | Count leading zeros in a word.
clz# :: Word# -> Word#

-- | Count leading zeros in the lower 16 bits of a word.
clz16# :: Word# -> Word#

-- | Count leading zeros in the lower 32 bits of a word.
clz32# :: Word# -> Word#

-- | Count leading zeros in a 64-bit word.
clz64# :: Word64# -> Word#

-- | Count leading zeros in the lower 8 bits of a word.
clz8# :: Word# -> Word#

-- | The function <a>coerce</a> allows you to safely convert between values
--   of types that have the same representation with no run-time overhead.
--   In the simplest case you can use it instead of a newtype constructor,
--   to go from the newtype's concrete type to the abstract type. But it
--   also works in more complicated settings, e.g. converting a list of
--   newtypes to a list of concrete types.
--   
--   When used in conversions involving a newtype wrapper, make sure the
--   newtype constructor is in scope.
--   
--   This function is representation-polymorphic, but the
--   <tt>RuntimeRep</tt> type argument is marked as <tt>Inferred</tt>,
--   meaning that it is not available for visible type application. This
--   means the typechecker will accept <tt><a>coerce</a> @<tt>Int</tt> @Age
--   42</tt>.
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; newtype TTL = TTL Int deriving (Eq, Ord, Show)
--   
--   &gt;&gt;&gt; newtype Age = Age Int deriving (Eq, Ord, Show)
--   
--   &gt;&gt;&gt; coerce (Age 42) :: TTL
--   TTL 42
--   
--   &gt;&gt;&gt; coerce (+ (1 :: Int)) (Age 42) :: TTL
--   TTL 43
--   
--   &gt;&gt;&gt; coerce (map (+ (1 :: Int))) [Age 42, Age 24] :: [TTL]
--   [TTL 43,TTL 25]
--   </pre>
coerce :: Coercible a b => a -> b

-- | Recursively add a closure and its transitive closure to a
--   <a>Compact#</a> (a CNF), evaluating any unevaluated components at the
--   same time. Note: <a>compactAdd#</a> is not thread-safe, so only one
--   thread may call <a>compactAdd#</a> with a particular <a>Compact#</a>
--   at any given time. The primop does not enforce any mutual exclusion;
--   the caller is expected to arrange this.
compactAdd# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)

-- | Like <a>compactAdd#</a>, but retains sharing and cycles during
--   compaction.
compactAddWithSharing# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)

-- | Attempt to allocate a compact block with the capacity (in bytes) given
--   by the first argument. The <a>Addr#</a> is a pointer to previous
--   compact block of the CNF or <a>nullAddr#</a> to create a new CNF with
--   a single compact block.
--   
--   The resulting block is not known to the GC until
--   <a>compactFixupPointers#</a> is called on it, and care must be taken
--   so that the address does not escape or memory will be leaked.
compactAllocateBlock# :: Word# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr# #)

-- | Returns 1# if the object is contained in the CNF, 0# otherwise.
compactContains# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, Int# #)

-- | Returns 1# if the object is in any CNF at all, 0# otherwise.
compactContainsAny# :: a -> State# RealWorld -> (# State# RealWorld, Int# #)

-- | Given the pointer to the first block of a CNF and the address of the
--   root object in the old address space, fix up the internal pointers
--   inside the CNF to account for a different position in memory than when
--   it was serialized. This method must be called exactly once after
--   importing a serialized CNF. It returns the new CNF and the new
--   adjusted root address.
compactFixupPointers# :: Addr# -> Addr# -> State# RealWorld -> (# State# RealWorld, Compact#, Addr# #)

-- | Returns the address and the utilized size (in bytes) of the first
--   compact block of a CNF.
compactGetFirstBlock# :: Compact# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)

-- | Given a CNF and the address of one its compact blocks, returns the
--   next compact block and its utilized size, or <a>nullAddr#</a> if the
--   argument was the last compact block in the CNF.
compactGetNextBlock# :: Compact# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)

-- | Create a new CNF with a single compact block. The argument is the
--   capacity of the compact block (in bytes, not words). The capacity is
--   rounded up to a multiple of the allocator block size and is capped to
--   one mega block.
compactNew# :: Word# -> State# RealWorld -> (# State# RealWorld, Compact# #)

-- | Set the new allocation size of the CNF. This value (in bytes)
--   determines the capacity of each compact block in the CNF. It does not
--   retroactively affect existing compact blocks in the CNF.
compactResize# :: Compact# -> Word# -> State# RealWorld -> State# RealWorld

-- | Return the total capacity (in bytes) of all the compact blocks in the
--   CNF.
compactSize# :: Compact# -> State# RealWorld -> (# State# RealWorld, Word# #)

-- | <tt><a>compareByteArrays#</a> src1 src1_ofs src2 src2_ofs n</tt>
--   compares <tt>n</tt> bytes starting at offset <tt>src1_ofs</tt> in the
--   first <a>ByteArray#</a> <tt>src1</tt> to the range of <tt>n</tt> bytes
--   (i.e. same length) starting at offset <tt>src2_ofs</tt> of the second
--   <a>ByteArray#</a> <tt>src2</tt>. Both arrays must fully contain the
--   specified ranges, but this is not checked. Returns an <a>Int#</a> less
--   than, equal to, or greater than zero if the range is found,
--   respectively, to be byte-wise lexicographically less than, to match,
--   or be greater than the second range.
compareByteArrays# :: ByteArray# -> Int# -> ByteArray# -> Int# -> Int# -> Int#

-- | See <a>GHC.Prim#continuations</a>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
control0# :: PromptTag# a -> (((State# RealWorld -> (# State# RealWorld, b #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, b #)

-- | <tt><a>copyAddrToAddr#</a> src dest len</tt> copies <tt>len</tt> bytes
--   from <tt>src</tt> to <tt>dest</tt>. These two memory ranges are
--   allowed to overlap.
--   
--   Analogous to the standard C function <tt>memmove</tt>, but with a
--   different argument order.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyAddrToAddr# :: Addr# -> Addr# -> Int# -> State# RealWorld -> State# RealWorld

-- | <tt><a>copyAddrToAddrNonOverlapping#</a> src dest len</tt> copies
--   <tt>len</tt> bytes from <tt>src</tt> to <tt>dest</tt>. As the name
--   suggests, these two memory ranges <i>must not overlap</i>, although
--   this pre-condition is not checked.
--   
--   Analogous to the standard C function <tt>memcpy</tt>, but with a
--   different argument order.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyAddrToAddrNonOverlapping# :: Addr# -> Addr# -> Int# -> State# RealWorld -> State# RealWorld

-- | Copy a memory range starting at the Addr# to the specified range in
--   the MutableByteArray#. The memory region at Addr# and the ByteArray#
--   must fully contain the specified ranges, but this is not checked. The
--   Addr# must not point into the MutableByteArray# (e.g. if the
--   MutableByteArray# were pinned), but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyAddrToByteArray# :: Addr# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. The two arrays must not be the same array in different
--   states, but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. Array# a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d

-- | <tt><a>copyByteArray#</a> src src_ofs dst dst_ofs len</tt> copies the
--   range starting at offset <tt>src_ofs</tt> of length <tt>len</tt> from
--   the <a>ByteArray#</a> <tt>src</tt> to the <a>MutableByteArray#</a>
--   <tt>dst</tt> starting at offset <tt>dst_ofs</tt>. Both arrays must
--   fully contain the specified ranges, but this is not checked. The two
--   arrays must not be the same array in different states, but this is not
--   checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyByteArray# :: ByteArray# -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Copy a range of the ByteArray# to the memory range starting at the
--   Addr#. The ByteArray# and the memory region at Addr# must fully
--   contain the specified ranges, but this is not checked. The Addr# must
--   not point into the ByteArray# (e.g. if the ByteArray# were pinned),
--   but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyByteArrayToAddr# :: ByteArray# -> Int# -> Addr# -> Int# -> State# d -> State# d

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. In the case where the source and destination are the
--   same array the source and destination regions may overlap.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d

-- | <tt><a>copyMutableByteArray#</a> src src_ofs dst dst_ofs len</tt>
--   copies the range starting at offset <tt>src_ofs</tt> of length
--   <tt>len</tt> from the <a>MutableByteArray#</a> <tt>src</tt> to the
--   <a>MutableByteArray#</a> <tt>dst</tt> starting at offset
--   <tt>dst_ofs</tt>. Both arrays must fully contain the specified ranges,
--   but this is not checked. The regions are allowed to overlap, although
--   this is only possible when the same array is provided as both the
--   source and the destination.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableByteArray# :: MutableByteArray# d -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | <tt><a>copyMutableByteArrayNonOverlapping#</a> src src_ofs dst dst_ofs
--   len</tt> copies the range starting at offset <tt>src_ofs</tt> of
--   length <tt>len</tt> from the <a>MutableByteArray#</a> <tt>src</tt> to
--   the <a>MutableByteArray#</a> <tt>dst</tt> starting at offset
--   <tt>dst_ofs</tt>. Both arrays must fully contain the specified ranges,
--   but this is not checked. The regions are <i>not</i> allowed to
--   overlap, but this is also not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableByteArrayNonOverlapping# :: MutableByteArray# d -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Copy a range of the MutableByteArray# to the memory range starting at
--   the Addr#. The MutableByteArray# and the memory region at Addr# must
--   fully contain the specified ranges, but this is not checked. The Addr#
--   must not point into the MutableByteArray# (e.g. if the
--   MutableByteArray# were pinned), but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableByteArrayToAddr# :: MutableByteArray# d -> Int# -> Addr# -> Int# -> State# d -> State# d

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. The two arrays must not be the same array in different
--   states, but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copySmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. SmallArray# a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. The source and destination arrays can refer to the same array.
--   Both arrays must fully contain the specified ranges, but this is not
--   checked. The regions are allowed to overlap, although this is only
--   possible when the same array is provided as both the source and the
--   destination.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copySmallMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d
cosDouble# :: Double# -> Double#
cosFloat# :: Float# -> Float#
coshDouble# :: Double# -> Double#
coshFloat# :: Float# -> Float#

-- | Count trailing zeros in a word.
ctz# :: Word# -> Word#

-- | Count trailing zeros in the lower 16 bits of a word.
ctz16# :: Word# -> Word#

-- | Count trailing zeros in the lower 32 bits of a word.
ctz32# :: Word# -> Word#

-- | Count trailing zeros in a 64-bit word.
ctz64# :: Word64# -> Word#

-- | Count trailing zeros in the lower 8 bits of a word.
ctz8# :: Word# -> Word#
deRefStablePtr# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). StablePtr# a -> State# RealWorld -> (# State# RealWorld, a #)
deRefWeak# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, a #)

-- | Convert to integer. First component of the result is -1 or 1,
--   indicating the sign of the mantissa. The next two are the high and low
--   32 bits of the mantissa respectively, and the last is the exponent.
decodeDouble_2Int# :: Double# -> (# Int#, Word#, Word#, Int# #)

-- | Decode <a>Double#</a> into mantissa and base-2 exponent.
decodeDouble_Int64# :: Double# -> (# Int64#, Int# #)

-- | Convert to integers. First <a>Int#</a> in result is the mantissa;
--   second is the exponent.
decodeFloat_Int# :: Float# -> (# Int#, Int# #)

-- | Sleep specified number of microseconds.
delay# :: Int# -> State# d -> State# d

-- | Divide two vectors element-wise.
divideDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Divide two vectors element-wise.
divideDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Divide two vectors element-wise.
divideDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
divideFloat# :: Float# -> Float# -> Float#

-- | Divide two vectors element-wise.
divideFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Divide two vectors element-wise.
divideFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Divide two vectors element-wise.
divideFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
double2Float# :: Double# -> Float#

-- | Truncates a <a>Double#</a> value to the nearest <a>Int#</a>. Results
--   are undefined if the truncation if truncation yields a value outside
--   the range of <a>Int#</a>.
double2Int# :: Double# -> Int#
eqAddr# :: Addr# -> Addr# -> Int#
eqChar# :: Char# -> Char# -> Int#
eqFloat# :: Float# -> Float# -> Int#
eqInt16# :: Int16# -> Int16# -> Int#
eqInt32# :: Int32# -> Int32# -> Int#
eqInt64# :: Int64# -> Int64# -> Int#
eqInt8# :: Int8# -> Int8# -> Int#
eqStablePtr# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). StablePtr# a -> StablePtr# a -> Int#
eqWord# :: Word# -> Word# -> Int#
eqWord16# :: Word16# -> Word16# -> Int#
eqWord32# :: Word32# -> Word32# -> Int#
eqWord64# :: Word64# -> Word64# -> Int#
eqWord8# :: Word8# -> Word8# -> Int#
expDouble# :: Double# -> Double#
expFloat# :: Float# -> Float#
expm1Double# :: Double# -> Double#
expm1Float# :: Float# -> Float#
fabsDouble# :: Double# -> Double#
fabsFloat# :: Float# -> Float#

-- | Given an array, and offset in machine words, and a value to add,
--   atomically add the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAddIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an address, and a value to add, atomically add the value to the
--   element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAddWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Given an array, and offset in machine words, and a value to AND,
--   atomically AND the value into the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAndIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an address, and a value to AND, atomically AND the value into
--   the element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAndWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Given an array, and offset in machine words, and a value to NAND,
--   atomically NAND the value into the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchNandIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an address, and a value to NAND, atomically NAND the value into
--   the element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchNandWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Given an array, and offset in machine words, and a value to OR,
--   atomically OR the value into the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchOrIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an address, and a value to OR, atomically OR the value into the
--   element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchOrWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Given an array, and offset in machine words, and a value to subtract,
--   atomically subtract the value from the element. Returns the value of
--   the element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchSubIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an address, and a value to subtract, atomically subtract the
--   value from the element. Returns the value of the element before the
--   operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchSubWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Given an array, and offset in machine words, and a value to XOR,
--   atomically XOR the value into the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchXorIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an address, and a value to XOR, atomically XOR the value into
--   the element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchXorWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Finalize a weak pointer. The return value is an unboxed tuple
--   containing the new state of the world and an "unboxed Maybe",
--   represented by an <a>Int#</a> and a (possibly invalid) finalization
--   action. An <a>Int#</a> of <tt>1</tt> indicates that the finalizer is
--   valid. The return value <tt>b</tt> from the finalizer should be
--   ignored.
finalizeWeak# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) b. Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, State# RealWorld -> (# State# RealWorld, b #) #)
float2Double# :: Float# -> Double#

-- | Truncates a <a>Float#</a> value to the nearest <a>Int#</a>. Results
--   are undefined if the truncation if truncation yields a value outside
--   the range of <a>Int#</a>.
float2Int# :: Float# -> Int#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddDouble# :: Double# -> Double# -> Double# -> Double#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddFloat# :: Float# -> Float# -> Float# -> Float#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddFloatX16# :: FloatX16# -> FloatX16# -> FloatX16# -> FloatX16#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddFloatX4# :: FloatX4# -> FloatX4# -> FloatX4# -> FloatX4#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddFloatX8# :: FloatX8# -> FloatX8# -> FloatX8# -> FloatX8#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubDouble# :: Double# -> Double# -> Double# -> Double#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubFloat# :: Float# -> Float# -> Float# -> Float#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubFloatX16# :: FloatX16# -> FloatX16# -> FloatX16# -> FloatX16#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubFloatX4# :: FloatX4# -> FloatX4# -> FloatX4# -> FloatX4#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubFloatX8# :: FloatX8# -> FloatX8# -> FloatX8# -> FloatX8#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddDouble# :: Double# -> Double# -> Double# -> Double#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddFloat# :: Float# -> Float# -> Float# -> Float#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddFloatX16# :: FloatX16# -> FloatX16# -> FloatX16# -> FloatX16#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddFloatX4# :: FloatX4# -> FloatX4# -> FloatX4# -> FloatX4#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddFloatX8# :: FloatX8# -> FloatX8# -> FloatX8# -> FloatX8#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubDouble# :: Double# -> Double# -> Double# -> Double#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubFloat# :: Float# -> Float# -> Float# -> Float#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubFloatX16# :: FloatX16# -> FloatX16# -> FloatX16# -> FloatX16#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubFloatX4# :: FloatX4# -> FloatX4# -> FloatX4# -> FloatX4#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubFloatX8# :: FloatX8# -> FloatX8# -> FloatX8# -> FloatX8#
fork# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
forkOn# :: Int# -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
freezeArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, Array# a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
freezeSmallArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallArray# a #)
geAddr# :: Addr# -> Addr# -> Int#
geChar# :: Char# -> Char# -> Int#
geFloat# :: Float# -> Float# -> Int#
geInt16# :: Int16# -> Int16# -> Int#
geInt32# :: Int32# -> Int32# -> Int#
geInt64# :: Int64# -> Int64# -> Int#
geInt8# :: Int8# -> Int8# -> Int#
geWord# :: Word# -> Word# -> Int#
geWord16# :: Word16# -> Word16# -> Int#
geWord32# :: Word32# -> Word32# -> Int#
geWord64# :: Word64# -> Word64# -> Int#
geWord8# :: Word8# -> Word8# -> Int#
getApStackVal# :: a -> Int# -> (# Int#, b #)
getCCSOf# :: a -> State# d -> (# State# d, Addr# #)

-- | Returns the current <tt>CostCentreStack</tt> (value is <tt>NULL</tt>
--   if not profiling). Takes a dummy argument which can be used to avoid
--   the call to <a>getCurrentCCS#</a> being floated out by the simplifier,
--   which would result in an uninformative stack (<a>CAF</a>).
getCurrentCCS# :: a -> State# d -> (# State# d, Addr# #)
getMaskingState# :: State# RealWorld -> (# State# RealWorld, Int# #)

-- | Return the number of elements in the array, correctly accounting for
--   the effect of <a>shrinkMutableByteArray#</a> and
--   <a>resizeMutableByteArray#</a>.
getSizeofMutableByteArray# :: MutableByteArray# d -> State# d -> (# State# d, Int# #)

-- | Return the number of elements in the array, correctly accounting for
--   the effect of <a>shrinkSmallMutableArray#</a> and
--   <tt>resizeSmallMutableArray#</tt>.
getSizeofSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> State# d -> (# State# d, Int# #)
getSpark# :: State# d -> (# State# d, Int#, a #)
gtAddr# :: Addr# -> Addr# -> Int#
gtChar# :: Char# -> Char# -> Int#
gtFloat# :: Float# -> Float# -> Int#
gtInt16# :: Int16# -> Int16# -> Int#
gtInt32# :: Int32# -> Int32# -> Int#
gtInt64# :: Int64# -> Int64# -> Int#
gtInt8# :: Int8# -> Int8# -> Int#
gtWord# :: Word# -> Word# -> Int#
gtWord16# :: Word16# -> Word16# -> Int#
gtWord32# :: Word32# -> Word32# -> Int#
gtWord64# :: Word64# -> Word64# -> Int#
gtWord8# :: Word8# -> Word8# -> Int#

-- | Read a machine address from immutable array; offset in machine words.
indexAddrArray# :: ByteArray# -> Int# -> Addr#

-- | Read a machine address from immutable address; offset in machine
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexAddrOffAddr# :: Addr# -> Int# -> Addr#

-- | Read from the specified index of an immutable array. The result is
--   packaged into an unboxed unary tuple; the result itself is not yet
--   evaluated. Pattern matching on the tuple forces the indexing of the
--   array to happen but does not evaluate the element itself. Evaluating
--   the thunk prevents additional thunks from building up on the heap.
--   Avoiding these thunks, in turn, reduces references to the argument
--   array, allowing it to be garbage collected more promptly.
indexArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Array# a -> Int# -> (# a #)

-- | Read an 8-bit character from immutable array; offset in bytes.
indexCharArray# :: ByteArray# -> Int# -> Char#

-- | Read an 8-bit character from immutable address; offset in bytes.
indexCharOffAddr# :: Addr# -> Int# -> Char#

-- | Read a double-precision floating-point value from immutable array;
--   offset in 8-byte words.
indexDoubleArray# :: ByteArray# -> Int# -> Double#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexDoubleArrayAsDoubleX2# :: ByteArray# -> Int# -> DoubleX2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexDoubleArrayAsDoubleX4# :: ByteArray# -> Int# -> DoubleX4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexDoubleArrayAsDoubleX8# :: ByteArray# -> Int# -> DoubleX8#

-- | Read a double-precision floating-point value from immutable address;
--   offset in 8-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexDoubleOffAddr# :: Addr# -> Int# -> Double#

-- | Reads vector; offset in scalar elements.
indexDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2#

-- | Reads vector; offset in scalar elements.
indexDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4#

-- | Reads vector; offset in scalar elements.
indexDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8#

-- | Read a vector from specified index of immutable array.
indexDoubleX2Array# :: ByteArray# -> Int# -> DoubleX2#

-- | Reads vector; offset in bytes.
indexDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2#

-- | Read a vector from specified index of immutable array.
indexDoubleX4Array# :: ByteArray# -> Int# -> DoubleX4#

-- | Reads vector; offset in bytes.
indexDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4#

-- | Read a vector from specified index of immutable array.
indexDoubleX8Array# :: ByteArray# -> Int# -> DoubleX8#

-- | Reads vector; offset in bytes.
indexDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8#

-- | Read a single-precision floating-point value from immutable array;
--   offset in 4-byte words.
indexFloatArray# :: ByteArray# -> Int# -> Float#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexFloatArrayAsFloatX16# :: ByteArray# -> Int# -> FloatX16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexFloatArrayAsFloatX4# :: ByteArray# -> Int# -> FloatX4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexFloatArrayAsFloatX8# :: ByteArray# -> Int# -> FloatX8#

-- | Read a single-precision floating-point value from immutable address;
--   offset in 4-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexFloatOffAddr# :: Addr# -> Int# -> Float#

-- | Reads vector; offset in scalar elements.
indexFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16#

-- | Reads vector; offset in scalar elements.
indexFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4#

-- | Reads vector; offset in scalar elements.
indexFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8#

-- | Read a vector from specified index of immutable array.
indexFloatX16Array# :: ByteArray# -> Int# -> FloatX16#

-- | Reads vector; offset in bytes.
indexFloatX16OffAddr# :: Addr# -> Int# -> FloatX16#

-- | Read a vector from specified index of immutable array.
indexFloatX4Array# :: ByteArray# -> Int# -> FloatX4#

-- | Reads vector; offset in bytes.
indexFloatX4OffAddr# :: Addr# -> Int# -> FloatX4#

-- | Read a vector from specified index of immutable array.
indexFloatX8Array# :: ByteArray# -> Int# -> FloatX8#

-- | Reads vector; offset in bytes.
indexFloatX8OffAddr# :: Addr# -> Int# -> FloatX8#

-- | Read a 16-bit signed integer from immutable array; offset in 2-byte
--   words.
indexInt16Array# :: ByteArray# -> Int# -> Int16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt16ArrayAsInt16X16# :: ByteArray# -> Int# -> Int16X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt16ArrayAsInt16X32# :: ByteArray# -> Int# -> Int16X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt16ArrayAsInt16X8# :: ByteArray# -> Int# -> Int16X8#

-- | Read a 16-bit signed integer from immutable address; offset in 2-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexInt16OffAddr# :: Addr# -> Int# -> Int16#

-- | Reads vector; offset in scalar elements.
indexInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16#

-- | Reads vector; offset in scalar elements.
indexInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32#

-- | Reads vector; offset in scalar elements.
indexInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8#

-- | Read a vector from specified index of immutable array.
indexInt16X16Array# :: ByteArray# -> Int# -> Int16X16#

-- | Reads vector; offset in bytes.
indexInt16X16OffAddr# :: Addr# -> Int# -> Int16X16#

-- | Read a vector from specified index of immutable array.
indexInt16X32Array# :: ByteArray# -> Int# -> Int16X32#

-- | Reads vector; offset in bytes.
indexInt16X32OffAddr# :: Addr# -> Int# -> Int16X32#

-- | Read a vector from specified index of immutable array.
indexInt16X8Array# :: ByteArray# -> Int# -> Int16X8#

-- | Reads vector; offset in bytes.
indexInt16X8OffAddr# :: Addr# -> Int# -> Int16X8#

-- | Read a 32-bit signed integer from immutable array; offset in 4-byte
--   words.
indexInt32Array# :: ByteArray# -> Int# -> Int32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt32ArrayAsInt32X16# :: ByteArray# -> Int# -> Int32X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt32ArrayAsInt32X4# :: ByteArray# -> Int# -> Int32X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt32ArrayAsInt32X8# :: ByteArray# -> Int# -> Int32X8#

-- | Read a 32-bit signed integer from immutable address; offset in 4-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexInt32OffAddr# :: Addr# -> Int# -> Int32#

-- | Reads vector; offset in scalar elements.
indexInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16#

-- | Reads vector; offset in scalar elements.
indexInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4#

-- | Reads vector; offset in scalar elements.
indexInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8#

-- | Read a vector from specified index of immutable array.
indexInt32X16Array# :: ByteArray# -> Int# -> Int32X16#

-- | Reads vector; offset in bytes.
indexInt32X16OffAddr# :: Addr# -> Int# -> Int32X16#

-- | Read a vector from specified index of immutable array.
indexInt32X4Array# :: ByteArray# -> Int# -> Int32X4#

-- | Reads vector; offset in bytes.
indexInt32X4OffAddr# :: Addr# -> Int# -> Int32X4#

-- | Read a vector from specified index of immutable array.
indexInt32X8Array# :: ByteArray# -> Int# -> Int32X8#

-- | Reads vector; offset in bytes.
indexInt32X8OffAddr# :: Addr# -> Int# -> Int32X8#

-- | Read a 64-bit signed integer from immutable array; offset in 8-byte
--   words.
indexInt64Array# :: ByteArray# -> Int# -> Int64#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt64ArrayAsInt64X2# :: ByteArray# -> Int# -> Int64X2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt64ArrayAsInt64X4# :: ByteArray# -> Int# -> Int64X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt64ArrayAsInt64X8# :: ByteArray# -> Int# -> Int64X8#

-- | Read a 64-bit signed integer from immutable address; offset in 8-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexInt64OffAddr# :: Addr# -> Int# -> Int64#

-- | Reads vector; offset in scalar elements.
indexInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2#

-- | Reads vector; offset in scalar elements.
indexInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4#

-- | Reads vector; offset in scalar elements.
indexInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8#

-- | Read a vector from specified index of immutable array.
indexInt64X2Array# :: ByteArray# -> Int# -> Int64X2#

-- | Reads vector; offset in bytes.
indexInt64X2OffAddr# :: Addr# -> Int# -> Int64X2#

-- | Read a vector from specified index of immutable array.
indexInt64X4Array# :: ByteArray# -> Int# -> Int64X4#

-- | Reads vector; offset in bytes.
indexInt64X4OffAddr# :: Addr# -> Int# -> Int64X4#

-- | Read a vector from specified index of immutable array.
indexInt64X8Array# :: ByteArray# -> Int# -> Int64X8#

-- | Reads vector; offset in bytes.
indexInt64X8OffAddr# :: Addr# -> Int# -> Int64X8#

-- | Read an 8-bit signed integer from immutable array; offset in bytes.
indexInt8Array# :: ByteArray# -> Int# -> Int8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt8ArrayAsInt8X16# :: ByteArray# -> Int# -> Int8X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt8ArrayAsInt8X32# :: ByteArray# -> Int# -> Int8X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt8ArrayAsInt8X64# :: ByteArray# -> Int# -> Int8X64#

-- | Read an 8-bit signed integer from immutable address; offset in bytes.
indexInt8OffAddr# :: Addr# -> Int# -> Int8#

-- | Reads vector; offset in scalar elements.
indexInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16#

-- | Reads vector; offset in scalar elements.
indexInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32#

-- | Reads vector; offset in scalar elements.
indexInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64#

-- | Read a vector from specified index of immutable array.
indexInt8X16Array# :: ByteArray# -> Int# -> Int8X16#

-- | Reads vector; offset in bytes.
indexInt8X16OffAddr# :: Addr# -> Int# -> Int8X16#

-- | Read a vector from specified index of immutable array.
indexInt8X32Array# :: ByteArray# -> Int# -> Int8X32#

-- | Reads vector; offset in bytes.
indexInt8X32OffAddr# :: Addr# -> Int# -> Int8X32#

-- | Read a vector from specified index of immutable array.
indexInt8X64Array# :: ByteArray# -> Int# -> Int8X64#

-- | Reads vector; offset in bytes.
indexInt8X64OffAddr# :: Addr# -> Int# -> Int8X64#

-- | Read a word-sized integer from immutable array; offset in machine
--   words.
indexIntArray# :: ByteArray# -> Int# -> Int#

-- | Read a word-sized integer from immutable address; offset in machine
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexIntOffAddr# :: Addr# -> Int# -> Int#

-- | Read from specified index of immutable array. Result is packaged into
--   an unboxed singleton; the result itself is not yet evaluated.
indexSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). SmallArray# a -> Int# -> (# a #)

-- | Read a <a>StablePtr#</a> value from immutable array; offset in machine
--   words.
indexStablePtrArray# :: ByteArray# -> Int# -> StablePtr# a

-- | Read a <a>StablePtr#</a> value from immutable address; offset in
--   machine words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a

-- | Read a 32-bit character from immutable array; offset in 4-byte words.
indexWideCharArray# :: ByteArray# -> Int# -> Char#

-- | Read a 32-bit character from immutable address; offset in 4-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexWideCharOffAddr# :: Addr# -> Int# -> Char#

-- | Read a 16-bit unsigned integer from immutable array; offset in 2-byte
--   words.
indexWord16Array# :: ByteArray# -> Int# -> Word16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord16ArrayAsWord16X16# :: ByteArray# -> Int# -> Word16X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord16ArrayAsWord16X32# :: ByteArray# -> Int# -> Word16X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord16ArrayAsWord16X8# :: ByteArray# -> Int# -> Word16X8#

-- | Read a 16-bit unsigned integer from immutable address; offset in
--   2-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexWord16OffAddr# :: Addr# -> Int# -> Word16#

-- | Reads vector; offset in scalar elements.
indexWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16#

-- | Reads vector; offset in scalar elements.
indexWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32#

-- | Reads vector; offset in scalar elements.
indexWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8#

-- | Read a vector from specified index of immutable array.
indexWord16X16Array# :: ByteArray# -> Int# -> Word16X16#

-- | Reads vector; offset in bytes.
indexWord16X16OffAddr# :: Addr# -> Int# -> Word16X16#

-- | Read a vector from specified index of immutable array.
indexWord16X32Array# :: ByteArray# -> Int# -> Word16X32#

-- | Reads vector; offset in bytes.
indexWord16X32OffAddr# :: Addr# -> Int# -> Word16X32#

-- | Read a vector from specified index of immutable array.
indexWord16X8Array# :: ByteArray# -> Int# -> Word16X8#

-- | Reads vector; offset in bytes.
indexWord16X8OffAddr# :: Addr# -> Int# -> Word16X8#

-- | Read a 32-bit unsigned integer from immutable array; offset in 4-byte
--   words.
indexWord32Array# :: ByteArray# -> Int# -> Word32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord32ArrayAsWord32X16# :: ByteArray# -> Int# -> Word32X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord32ArrayAsWord32X4# :: ByteArray# -> Int# -> Word32X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord32ArrayAsWord32X8# :: ByteArray# -> Int# -> Word32X8#

-- | Read a 32-bit unsigned integer from immutable address; offset in
--   4-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexWord32OffAddr# :: Addr# -> Int# -> Word32#

-- | Reads vector; offset in scalar elements.
indexWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16#

-- | Reads vector; offset in scalar elements.
indexWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4#

-- | Reads vector; offset in scalar elements.
indexWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8#

-- | Read a vector from specified index of immutable array.
indexWord32X16Array# :: ByteArray# -> Int# -> Word32X16#

-- | Reads vector; offset in bytes.
indexWord32X16OffAddr# :: Addr# -> Int# -> Word32X16#

-- | Read a vector from specified index of immutable array.
indexWord32X4Array# :: ByteArray# -> Int# -> Word32X4#

-- | Reads vector; offset in bytes.
indexWord32X4OffAddr# :: Addr# -> Int# -> Word32X4#

-- | Read a vector from specified index of immutable array.
indexWord32X8Array# :: ByteArray# -> Int# -> Word32X8#

-- | Reads vector; offset in bytes.
indexWord32X8OffAddr# :: Addr# -> Int# -> Word32X8#

-- | Read a 64-bit unsigned integer from immutable array; offset in 8-byte
--   words.
indexWord64Array# :: ByteArray# -> Int# -> Word64#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord64ArrayAsWord64X2# :: ByteArray# -> Int# -> Word64X2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord64ArrayAsWord64X4# :: ByteArray# -> Int# -> Word64X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord64ArrayAsWord64X8# :: ByteArray# -> Int# -> Word64X8#

-- | Read a 64-bit unsigned integer from immutable address; offset in
--   8-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexWord64OffAddr# :: Addr# -> Int# -> Word64#

-- | Reads vector; offset in scalar elements.
indexWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2#

-- | Reads vector; offset in scalar elements.
indexWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4#

-- | Reads vector; offset in scalar elements.
indexWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8#

-- | Read a vector from specified index of immutable array.
indexWord64X2Array# :: ByteArray# -> Int# -> Word64X2#

-- | Reads vector; offset in bytes.
indexWord64X2OffAddr# :: Addr# -> Int# -> Word64X2#

-- | Read a vector from specified index of immutable array.
indexWord64X4Array# :: ByteArray# -> Int# -> Word64X4#

-- | Reads vector; offset in bytes.
indexWord64X4OffAddr# :: Addr# -> Int# -> Word64X4#

-- | Read a vector from specified index of immutable array.
indexWord64X8Array# :: ByteArray# -> Int# -> Word64X8#

-- | Reads vector; offset in bytes.
indexWord64X8OffAddr# :: Addr# -> Int# -> Word64X8#

-- | Read an 8-bit unsigned integer from immutable array; offset in bytes.
indexWord8Array# :: ByteArray# -> Int# -> Word8#

-- | Read a machine address from immutable array; offset in bytes.
indexWord8ArrayAsAddr# :: ByteArray# -> Int# -> Addr#

-- | Read an 8-bit character from immutable array; offset in bytes.
indexWord8ArrayAsChar# :: ByteArray# -> Int# -> Char#

-- | Read a double-precision floating-point value from immutable array;
--   offset in bytes.
indexWord8ArrayAsDouble# :: ByteArray# -> Int# -> Double#

-- | Read a single-precision floating-point value from immutable array;
--   offset in bytes.
indexWord8ArrayAsFloat# :: ByteArray# -> Int# -> Float#

-- | Read a word-sized integer from immutable array; offset in bytes.
indexWord8ArrayAsInt# :: ByteArray# -> Int# -> Int#

-- | Read a 16-bit signed integer from immutable array; offset in bytes.
indexWord8ArrayAsInt16# :: ByteArray# -> Int# -> Int16#

-- | Read a 32-bit signed integer from immutable array; offset in bytes.
indexWord8ArrayAsInt32# :: ByteArray# -> Int# -> Int32#

-- | Read a 64-bit signed integer from immutable array; offset in bytes.
indexWord8ArrayAsInt64# :: ByteArray# -> Int# -> Int64#

-- | Read a <a>StablePtr#</a> value from immutable array; offset in bytes.
indexWord8ArrayAsStablePtr# :: ByteArray# -> Int# -> StablePtr# a

-- | Read a 32-bit character from immutable array; offset in bytes.
indexWord8ArrayAsWideChar# :: ByteArray# -> Int# -> Char#

-- | Read a word-sized unsigned integer from immutable array; offset in
--   bytes.
indexWord8ArrayAsWord# :: ByteArray# -> Int# -> Word#

-- | Read a 16-bit unsigned integer from immutable array; offset in bytes.
indexWord8ArrayAsWord16# :: ByteArray# -> Int# -> Word16#

-- | Read a 32-bit unsigned integer from immutable array; offset in bytes.
indexWord8ArrayAsWord32# :: ByteArray# -> Int# -> Word32#

-- | Read a 64-bit unsigned integer from immutable array; offset in bytes.
indexWord8ArrayAsWord64# :: ByteArray# -> Int# -> Word64#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord8ArrayAsWord8X16# :: ByteArray# -> Int# -> Word8X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord8ArrayAsWord8X32# :: ByteArray# -> Int# -> Word8X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord8ArrayAsWord8X64# :: ByteArray# -> Int# -> Word8X64#

-- | Read an 8-bit unsigned integer from immutable address; offset in
--   bytes.
indexWord8OffAddr# :: Addr# -> Int# -> Word8#

-- | Read a machine address from immutable address; offset in bytes.
indexWord8OffAddrAsAddr# :: Addr# -> Int# -> Addr#

-- | Read an 8-bit character from immutable address; offset in bytes.
indexWord8OffAddrAsChar# :: Addr# -> Int# -> Char#

-- | Read a double-precision floating-point value from immutable address;
--   offset in bytes.
indexWord8OffAddrAsDouble# :: Addr# -> Int# -> Double#

-- | Read a single-precision floating-point value from immutable address;
--   offset in bytes.
indexWord8OffAddrAsFloat# :: Addr# -> Int# -> Float#

-- | Read a word-sized integer from immutable address; offset in bytes.
indexWord8OffAddrAsInt# :: Addr# -> Int# -> Int#

-- | Read a 16-bit signed integer from immutable address; offset in bytes.
indexWord8OffAddrAsInt16# :: Addr# -> Int# -> Int16#

-- | Read a 32-bit signed integer from immutable address; offset in bytes.
indexWord8OffAddrAsInt32# :: Addr# -> Int# -> Int32#

-- | Read a 64-bit signed integer from immutable address; offset in bytes.
indexWord8OffAddrAsInt64# :: Addr# -> Int# -> Int64#

-- | Read a <a>StablePtr#</a> value from immutable address; offset in
--   bytes.
indexWord8OffAddrAsStablePtr# :: Addr# -> Int# -> StablePtr# a

-- | Read a 32-bit character from immutable address; offset in bytes.
indexWord8OffAddrAsWideChar# :: Addr# -> Int# -> Char#

-- | Read a word-sized unsigned integer from immutable address; offset in
--   bytes.
indexWord8OffAddrAsWord# :: Addr# -> Int# -> Word#

-- | Read a 16-bit unsigned integer from immutable address; offset in
--   bytes.
indexWord8OffAddrAsWord16# :: Addr# -> Int# -> Word16#

-- | Read a 32-bit unsigned integer from immutable address; offset in
--   bytes.
indexWord8OffAddrAsWord32# :: Addr# -> Int# -> Word32#

-- | Read a 64-bit unsigned integer from immutable address; offset in
--   bytes.
indexWord8OffAddrAsWord64# :: Addr# -> Int# -> Word64#

-- | Reads vector; offset in scalar elements.
indexWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16#

-- | Reads vector; offset in scalar elements.
indexWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32#

-- | Reads vector; offset in scalar elements.
indexWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64#

-- | Read a vector from specified index of immutable array.
indexWord8X16Array# :: ByteArray# -> Int# -> Word8X16#

-- | Reads vector; offset in bytes.
indexWord8X16OffAddr# :: Addr# -> Int# -> Word8X16#

-- | Read a vector from specified index of immutable array.
indexWord8X32Array# :: ByteArray# -> Int# -> Word8X32#

-- | Reads vector; offset in bytes.
indexWord8X32OffAddr# :: Addr# -> Int# -> Word8X32#

-- | Read a vector from specified index of immutable array.
indexWord8X64Array# :: ByteArray# -> Int# -> Word8X64#

-- | Reads vector; offset in bytes.
indexWord8X64OffAddr# :: Addr# -> Int# -> Word8X64#

-- | Read a word-sized unsigned integer from immutable array; offset in
--   machine words.
indexWordArray# :: ByteArray# -> Int# -> Word#

-- | Read a word-sized unsigned integer from immutable address; offset in
--   machine words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexWordOffAddr# :: Addr# -> Int# -> Word#

-- | Insert a scalar at the given position in a vector.
insertDoubleX2# :: DoubleX2# -> Double# -> Int# -> DoubleX2#

-- | Insert a scalar at the given position in a vector.
insertDoubleX4# :: DoubleX4# -> Double# -> Int# -> DoubleX4#

-- | Insert a scalar at the given position in a vector.
insertDoubleX8# :: DoubleX8# -> Double# -> Int# -> DoubleX8#

-- | Insert a scalar at the given position in a vector.
insertFloatX16# :: FloatX16# -> Float# -> Int# -> FloatX16#

-- | Insert a scalar at the given position in a vector.
insertFloatX4# :: FloatX4# -> Float# -> Int# -> FloatX4#

-- | Insert a scalar at the given position in a vector.
insertFloatX8# :: FloatX8# -> Float# -> Int# -> FloatX8#

-- | Insert a scalar at the given position in a vector.
insertInt16X16# :: Int16X16# -> Int16# -> Int# -> Int16X16#

-- | Insert a scalar at the given position in a vector.
insertInt16X32# :: Int16X32# -> Int16# -> Int# -> Int16X32#

-- | Insert a scalar at the given position in a vector.
insertInt16X8# :: Int16X8# -> Int16# -> Int# -> Int16X8#

-- | Insert a scalar at the given position in a vector.
insertInt32X16# :: Int32X16# -> Int32# -> Int# -> Int32X16#

-- | Insert a scalar at the given position in a vector.
insertInt32X4# :: Int32X4# -> Int32# -> Int# -> Int32X4#

-- | Insert a scalar at the given position in a vector.
insertInt32X8# :: Int32X8# -> Int32# -> Int# -> Int32X8#

-- | Insert a scalar at the given position in a vector.
insertInt64X2# :: Int64X2# -> Int64# -> Int# -> Int64X2#

-- | Insert a scalar at the given position in a vector.
insertInt64X4# :: Int64X4# -> Int64# -> Int# -> Int64X4#

-- | Insert a scalar at the given position in a vector.
insertInt64X8# :: Int64X8# -> Int64# -> Int# -> Int64X8#

-- | Insert a scalar at the given position in a vector.
insertInt8X16# :: Int8X16# -> Int8# -> Int# -> Int8X16#

-- | Insert a scalar at the given position in a vector.
insertInt8X32# :: Int8X32# -> Int8# -> Int# -> Int8X32#

-- | Insert a scalar at the given position in a vector.
insertInt8X64# :: Int8X64# -> Int8# -> Int# -> Int8X64#

-- | Insert a scalar at the given position in a vector.
insertWord16X16# :: Word16X16# -> Word16# -> Int# -> Word16X16#

-- | Insert a scalar at the given position in a vector.
insertWord16X32# :: Word16X32# -> Word16# -> Int# -> Word16X32#

-- | Insert a scalar at the given position in a vector.
insertWord16X8# :: Word16X8# -> Word16# -> Int# -> Word16X8#

-- | Insert a scalar at the given position in a vector.
insertWord32X16# :: Word32X16# -> Word32# -> Int# -> Word32X16#

-- | Insert a scalar at the given position in a vector.
insertWord32X4# :: Word32X4# -> Word32# -> Int# -> Word32X4#

-- | Insert a scalar at the given position in a vector.
insertWord32X8# :: Word32X8# -> Word32# -> Int# -> Word32X8#

-- | Insert a scalar at the given position in a vector.
insertWord64X2# :: Word64X2# -> Word64# -> Int# -> Word64X2#

-- | Insert a scalar at the given position in a vector.
insertWord64X4# :: Word64X4# -> Word64# -> Int# -> Word64X4#

-- | Insert a scalar at the given position in a vector.
insertWord64X8# :: Word64X8# -> Word64# -> Int# -> Word64X8#

-- | Insert a scalar at the given position in a vector.
insertWord8X16# :: Word8X16# -> Word8# -> Int# -> Word8X16#

-- | Insert a scalar at the given position in a vector.
insertWord8X32# :: Word8X32# -> Word8# -> Int# -> Word8X32#

-- | Insert a scalar at the given position in a vector.
insertWord8X64# :: Word8X64# -> Word8# -> Int# -> Word8X64#
int16ToInt# :: Int16# -> Int#
int16ToWord16# :: Int16# -> Word16#

-- | Coerce directly from int to address. Users are discouraged from using
--   this operation as it makes little sense on platforms with tagged
--   pointers.
int2Addr# :: Int# -> Addr#

-- | Convert an <a>Int#</a> to the corresponding <a>Double#</a> with the
--   same integral value (up to truncation due to floating-point
--   precision). e.g. <tt><a>int2Double#</a> 1# == 1.0##</tt>
int2Double# :: Int# -> Double#

-- | Convert an <a>Int#</a> to the corresponding <a>Float#</a> with the
--   same integral value (up to truncation due to floating-point
--   precision). e.g. <tt><a>int2Float#</a> 1# == 1.0#</tt>
int2Float# :: Int# -> Float#
int2Word# :: Int# -> Word#
int32ToInt# :: Int32# -> Int#
int32ToWord32# :: Int32# -> Word32#
int64ToInt# :: Int64# -> Int#
int64ToWord64# :: Int64# -> Word64#
int8ToInt# :: Int8# -> Int#
int8ToWord8# :: Int8# -> Word8#
intToInt16# :: Int# -> Int16#
intToInt32# :: Int# -> Int32#
intToInt64# :: Int# -> Int64#
intToInt8# :: Int# -> Int8#

-- | Determine whether a <a>ByteArray#</a> is guaranteed not to move.
isByteArrayPinned# :: ByteArray# -> Int#

-- | Similar to <a>isByteArrayPinned#</a>. Weakly pinned byte arrays are
--   allowed to be copied into compact regions by the user, potentially
--   invalidating the results of earlier calls to
--   <a>byteArrayContents#</a>.
--   
--   See the section `Pinned Byte Arrays` in the user guide for more
--   information.
--   
--   This function also returns true for regular pinned bytearrays.
isByteArrayWeaklyPinned# :: ByteArray# -> Int#
isCurrentThreadBound# :: State# RealWorld -> (# State# RealWorld, Int# #)

-- | Return 1 if <a>MVar#</a> is empty; 0 otherwise.
isEmptyMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> State# d -> (# State# d, Int# #)

-- | Determine whether a <a>MutableByteArray#</a> is guaranteed not to move
--   during GC.
isMutableByteArrayPinned# :: MutableByteArray# d -> Int#

-- | <a>isByteArrayWeaklyPinned#</a> but for mutable arrays.
isMutableByteArrayWeaklyPinned# :: MutableByteArray# d -> Int#

-- | <tt><a>keepAlive#</a> x s k</tt> keeps the value <tt>x</tt> alive
--   during the execution of the computation <tt>k</tt>.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
keepAlive# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d b. a -> State# d -> (State# d -> b) -> b
killThread# :: ThreadId# -> a -> State# RealWorld -> State# RealWorld

-- | Set the label of the given thread. The <tt>ByteArray#</tt> should
--   contain a UTF-8-encoded string.
labelThread# :: ThreadId# -> ByteArray# -> State# RealWorld -> State# RealWorld
leAddr# :: Addr# -> Addr# -> Int#
leChar# :: Char# -> Char# -> Int#
leFloat# :: Float# -> Float# -> Int#
leInt16# :: Int16# -> Int16# -> Int#
leInt32# :: Int32# -> Int32# -> Int#
leInt64# :: Int64# -> Int64# -> Int#
leInt8# :: Int8# -> Int8# -> Int#
leWord# :: Word# -> Word# -> Int#
leWord16# :: Word16# -> Word16# -> Int#
leWord32# :: Word32# -> Word32# -> Int#
leWord64# :: Word64# -> Word64# -> Int#
leWord8# :: Word8# -> Word8# -> Int#
leftSection :: forall {n :: Multiplicity} a b. (a %n -> b) -> a %n -> b

-- | Returns an array of the threads started by the program. Note that this
--   threads which have finished execution may or may not be present in
--   this list, depending upon whether they have been collected by the
--   garbage collector.
listThreads# :: State# RealWorld -> (# State# RealWorld, Array# ThreadId# #)
log1pDouble# :: Double# -> Double#
log1pFloat# :: Float# -> Float#
logDouble# :: Double# -> Double#
logFloat# :: Float# -> Float#
ltAddr# :: Addr# -> Addr# -> Int#
ltChar# :: Char# -> Char# -> Int#
ltFloat# :: Float# -> Float# -> Int#
ltInt16# :: Int16# -> Int16# -> Int#
ltInt32# :: Int32# -> Int32# -> Int#
ltInt64# :: Int64# -> Int64# -> Int#
ltInt8# :: Int8# -> Int8# -> Int#
ltWord# :: Word# -> Word# -> Int#
ltWord16# :: Word16# -> Word16# -> Int#
ltWord32# :: Word32# -> Word32# -> Int#
ltWord64# :: Word64# -> Word64# -> Int#
ltWord8# :: Word8# -> Word8# -> Int#
makeStableName# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). a -> State# RealWorld -> (# State# RealWorld, StableName# a #)
makeStablePtr# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). a -> State# RealWorld -> (# State# RealWorld, StablePtr# a #)

-- | <tt><a>maskAsyncExceptions#</a> k s</tt> evaluates <tt>k s</tt> such
--   that asynchronous exceptions are deferred until after evaluation has
--   finished.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
maskAsyncExceptions# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)

-- | <tt><a>maskUninterruptible#</a> k s</tt> evaluates <tt>k s</tt> such
--   that asynchronous exceptions are deferred until after evaluation has
--   finished.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
maskUninterruptible# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
maxDouble# :: Double# -> Double# -> Double#

-- | Component-wise maximum of two vectors.
maxDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Component-wise maximum of two vectors.
maxDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Component-wise maximum of two vectors.
maxDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
maxFloat# :: Float# -> Float# -> Float#

-- | Component-wise maximum of two vectors.
maxFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Component-wise maximum of two vectors.
maxFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Component-wise maximum of two vectors.
maxFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Component-wise maximum of two vectors.
maxInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Component-wise maximum of two vectors.
maxInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Component-wise maximum of two vectors.
maxInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Component-wise maximum of two vectors.
maxInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Component-wise maximum of two vectors.
maxInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Component-wise maximum of two vectors.
maxInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Component-wise maximum of two vectors.
maxInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Component-wise maximum of two vectors.
maxInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Component-wise maximum of two vectors.
maxInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Component-wise maximum of two vectors.
maxInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Component-wise maximum of two vectors.
maxInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Component-wise maximum of two vectors.
maxInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Component-wise maximum of two vectors.
maxWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Component-wise maximum of two vectors.
maxWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Component-wise maximum of two vectors.
maxWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Component-wise maximum of two vectors.
maxWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Component-wise maximum of two vectors.
maxWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Component-wise maximum of two vectors.
maxWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Component-wise maximum of two vectors.
maxWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Component-wise maximum of two vectors.
maxWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Component-wise maximum of two vectors.
maxWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Component-wise maximum of two vectors.
maxWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Component-wise maximum of two vectors.
maxWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Component-wise maximum of two vectors.
maxWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
minDouble# :: Double# -> Double# -> Double#

-- | Component-wise minimum of two vectors.
minDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Component-wise minimum of two vectors.
minDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Component-wise minimum of two vectors.
minDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
minFloat# :: Float# -> Float# -> Float#

-- | Component-wise minimum of two vectors.
minFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Component-wise minimum of two vectors.
minFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Component-wise minimum of two vectors.
minFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Component-wise minimum of two vectors.
minInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Component-wise minimum of two vectors.
minInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Component-wise minimum of two vectors.
minInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Component-wise minimum of two vectors.
minInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Component-wise minimum of two vectors.
minInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Component-wise minimum of two vectors.
minInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Component-wise minimum of two vectors.
minInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Component-wise minimum of two vectors.
minInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Component-wise minimum of two vectors.
minInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Component-wise minimum of two vectors.
minInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Component-wise minimum of two vectors.
minInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Component-wise minimum of two vectors.
minInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Component-wise minimum of two vectors.
minWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Component-wise minimum of two vectors.
minWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Component-wise minimum of two vectors.
minWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Component-wise minimum of two vectors.
minWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Component-wise minimum of two vectors.
minWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Component-wise minimum of two vectors.
minWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Component-wise minimum of two vectors.
minWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Component-wise minimum of two vectors.
minWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Component-wise minimum of two vectors.
minWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Component-wise minimum of two vectors.
minWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Component-wise minimum of two vectors.
minWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Component-wise minimum of two vectors.
minWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Result is meaningless if two <a>Addr#</a>s are so far apart that their
--   difference doesn't fit in an <a>Int#</a>.
minusAddr# :: Addr# -> Addr# -> Int#

-- | Subtract two vectors element-wise.
minusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Subtract two vectors element-wise.
minusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Subtract two vectors element-wise.
minusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
minusFloat# :: Float# -> Float# -> Float#

-- | Subtract two vectors element-wise.
minusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Subtract two vectors element-wise.
minusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Subtract two vectors element-wise.
minusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Subtract two vectors element-wise.
minusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Subtract two vectors element-wise.
minusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Subtract two vectors element-wise.
minusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Subtract two vectors element-wise.
minusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Subtract two vectors element-wise.
minusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Subtract two vectors element-wise.
minusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Subtract two vectors element-wise.
minusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Subtract two vectors element-wise.
minusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Subtract two vectors element-wise.
minusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Subtract two vectors element-wise.
minusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Subtract two vectors element-wise.
minusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Subtract two vectors element-wise.
minusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
minusWord# :: Word# -> Word# -> Word#

-- | Subtract two vectors element-wise.
minusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Subtract two vectors element-wise.
minusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Subtract two vectors element-wise.
minusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Subtract two vectors element-wise.
minusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Subtract two vectors element-wise.
minusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Subtract two vectors element-wise.
minusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Subtract two vectors element-wise.
minusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Subtract two vectors element-wise.
minusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Subtract two vectors element-wise.
minusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Subtract two vectors element-wise.
minusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Subtract two vectors element-wise.
minusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Subtract two vectors element-wise.
minusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Wrap a BCO in a <tt>AP_UPD</tt> thunk which will be updated with the
--   value of the BCO when evaluated.
mkApUpd0# :: BCO -> (# a #)

-- | <tt><a>mkWeak#</a> k v finalizer s</tt> creates a weak reference to
--   value <tt>k</tt>, with an associated reference to some value
--   <tt>v</tt>. If <tt>k</tt> is still alive then <tt>v</tt> can be
--   retrieved using <a>deRefWeak#</a>. Note that the type of <tt>k</tt>
--   must be represented by a pointer (i.e. of kind <tt><tt>TYPE</tt>
--   '<tt>LiftedRep</tt> or </tt><tt>TYPE</tt> '<tt>UnliftedRep</tt>@).
mkWeak# :: forall {l :: Levity} {k :: Levity} (a :: TYPE ('BoxedRep l)) (b :: TYPE ('BoxedRep k)) c. a -> b -> (State# RealWorld -> (# State# RealWorld, c #)) -> State# RealWorld -> (# State# RealWorld, Weak# b #)
mkWeakNoFinalizer# :: forall {l :: Levity} {k :: Levity} (a :: TYPE ('BoxedRep l)) (b :: TYPE ('BoxedRep k)). a -> b -> State# RealWorld -> (# State# RealWorld, Weak# b #)

-- | Return non-zero if there is any possibility that the upper word of a
--   signed integer multiply might contain useful information. Return zero
--   only if you are completely sure that no overflow can occur. On a
--   32-bit platform, the recommended implementation is to do a 32 x 32
--   -&gt; 64 signed multiply, and subtract result[63:32] from (result[31]
--   &gt;&gt;signed 31). If this is zero, meaning that the upper word is
--   merely a sign extension of the lower one, no overflow can occur.
--   
--   On a 64-bit platform it is not always possible to acquire the top 64
--   bits of the result. Therefore, a recommended implementation is to take
--   the absolute value of both operands, and return 0 iff bits[63:31] of
--   them are zero, since that means that their magnitudes fit within 31
--   bits, so the magnitude of the product must fit into 62 bits.
--   
--   If in doubt, return non-zero, but do make an effort to create the
--   correct answer for small args, since otherwise the performance of
--   <tt>(*) :: Integer -&gt; Integer -&gt; Integer</tt> will be poor.
mulIntMayOflo# :: Int# -> Int# -> Int#

-- | Intended for use with pinned arrays; otherwise very unsafe!
mutableByteArrayContents# :: MutableByteArray# d -> Addr#
myThreadId# :: State# RealWorld -> (# State# RealWorld, ThreadId# #)
narrow16Int# :: Int# -> Int#
narrow16Word# :: Word# -> Word#
narrow32Int# :: Int# -> Int#
narrow32Word# :: Word# -> Word#
narrow8Int# :: Int# -> Int#
narrow8Word# :: Word# -> Word#
neAddr# :: Addr# -> Addr# -> Int#
neChar# :: Char# -> Char# -> Int#
neFloat# :: Float# -> Float# -> Int#
neInt16# :: Int16# -> Int16# -> Int#
neInt32# :: Int32# -> Int32# -> Int#
neInt64# :: Int64# -> Int64# -> Int#
neInt8# :: Int8# -> Int8# -> Int#
neWord# :: Word# -> Word# -> Int#
neWord16# :: Word16# -> Word16# -> Int#
neWord32# :: Word32# -> Word32# -> Int#
neWord64# :: Word64# -> Word64# -> Int#
neWord8# :: Word8# -> Word8# -> Int#
negateDouble# :: Double# -> Double#

-- | Negate element-wise.
negateDoubleX2# :: DoubleX2# -> DoubleX2#

-- | Negate element-wise.
negateDoubleX4# :: DoubleX4# -> DoubleX4#

-- | Negate element-wise.
negateDoubleX8# :: DoubleX8# -> DoubleX8#
negateFloat# :: Float# -> Float#

-- | Negate element-wise.
negateFloatX16# :: FloatX16# -> FloatX16#

-- | Negate element-wise.
negateFloatX4# :: FloatX4# -> FloatX4#

-- | Negate element-wise.
negateFloatX8# :: FloatX8# -> FloatX8#

-- | Unary negation. Since the negative <a>Int#</a> range extends one
--   further than the positive range, <a>negateInt#</a> of the most
--   negative number is an identity operation. This way, <a>negateInt#</a>
--   is always its own inverse.
negateInt# :: Int# -> Int#
negateInt16# :: Int16# -> Int16#

-- | Negate element-wise.
negateInt16X16# :: Int16X16# -> Int16X16#

-- | Negate element-wise.
negateInt16X32# :: Int16X32# -> Int16X32#

-- | Negate element-wise.
negateInt16X8# :: Int16X8# -> Int16X8#
negateInt32# :: Int32# -> Int32#

-- | Negate element-wise.
negateInt32X16# :: Int32X16# -> Int32X16#

-- | Negate element-wise.
negateInt32X4# :: Int32X4# -> Int32X4#

-- | Negate element-wise.
negateInt32X8# :: Int32X8# -> Int32X8#
negateInt64# :: Int64# -> Int64#

-- | Negate element-wise.
negateInt64X2# :: Int64X2# -> Int64X2#

-- | Negate element-wise.
negateInt64X4# :: Int64X4# -> Int64X4#

-- | Negate element-wise.
negateInt64X8# :: Int64X8# -> Int64X8#
negateInt8# :: Int8# -> Int8#

-- | Negate element-wise.
negateInt8X16# :: Int8X16# -> Int8X16#

-- | Negate element-wise.
negateInt8X32# :: Int8X32# -> Int8X32#

-- | Negate element-wise.
negateInt8X64# :: Int8X64# -> Int8X64#

-- | Like <a>newPinnedByteArray#</a> but allow specifying an arbitrary
--   alignment, which must be a power of two.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
newAlignedPinnedByteArray# :: Int# -> Int# -> State# d -> (# State# d, MutableByteArray# d #)

-- | Create a new mutable array with the specified number of elements, in
--   the specified state thread, with each element containing the specified
--   initial value.
newArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. Int# -> a -> State# d -> (# State# d, MutableArray# d a #)

-- | <tt><a>newBCO#</a> instrs lits ptrs arity bitmap</tt> creates a new
--   bytecode object. The resulting object encodes a function of the given
--   arity with the instructions encoded in <tt>instrs</tt>, and a static
--   reference table usage bitmap given by <tt>bitmap</tt>.
newBCO# :: ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# d -> (# State# d, BCO #)

-- | Create a new mutable byte array of specified size (in bytes), in the
--   specified state thread. The size of the memory underlying the array
--   will be rounded up to the platform's word size.
newByteArray# :: Int# -> State# d -> (# State# d, MutableByteArray# d #)

-- | Create new <a>IOPort#</a>; initially empty.
newIOPort# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). State# d -> (# State# d, IOPort# d a #)

-- | Create new <a>MVar#</a>; initially empty.
newMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). State# d -> (# State# d, MVar# d a #)

-- | Create <a>MutVar#</a> with specified initial value in specified state
--   thread.
newMutVar# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. a -> State# d -> (# State# d, MutVar# d a #)

-- | Like <a>newByteArray#</a> but GC guarantees not to move it.
newPinnedByteArray# :: Int# -> State# d -> (# State# d, MutableByteArray# d #)

-- | See <a>GHC.Prim#continuations</a>.
newPromptTag# :: State# RealWorld -> (# State# RealWorld, PromptTag# a #)

-- | Create a new mutable array with the specified number of elements, in
--   the specified state thread, with each element containing the specified
--   initial value.
newSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. Int# -> a -> State# d -> (# State# d, SmallMutableArray# d a #)

-- | Create a new <a>TVar#</a> holding a specified initial value.
newTVar# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. a -> State# d -> (# State# d, TVar# d a #)
noDuplicate# :: State# d -> State# d
not# :: Word# -> Word#
not64# :: Word64# -> Word64#

-- | Bitwise "not", also known as the binary complement.
notI# :: Int# -> Int#
notWord16# :: Word16# -> Word16#
notWord32# :: Word32# -> Word32#
notWord8# :: Word8# -> Word8#

-- | The null address.
nullAddr# :: Addr#

-- | Returns the number of sparks in the local spark pool.
numSparks# :: State# d -> (# State# d, Int# #)
or# :: Word# -> Word# -> Word#
or64# :: Word64# -> Word64# -> Word64#

-- | Bitwise "or".
orI# :: Int# -> Int# -> Int#
orWord16# :: Word16# -> Word16# -> Word16#
orWord32# :: Word32# -> Word32# -> Word32#
orWord8# :: Word8# -> Word8# -> Word8#
ord# :: Char# -> Int#

-- | Pack the elements of an unboxed tuple into a vector.
packDoubleX2# :: (# Double#, Double# #) -> DoubleX2#

-- | Pack the elements of an unboxed tuple into a vector.
packDoubleX4# :: (# Double#, Double#, Double#, Double# #) -> DoubleX4#

-- | Pack the elements of an unboxed tuple into a vector.
packDoubleX8# :: (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #) -> DoubleX8#

-- | Pack the elements of an unboxed tuple into a vector.
packFloatX16# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX16#

-- | Pack the elements of an unboxed tuple into a vector.
packFloatX4# :: (# Float#, Float#, Float#, Float# #) -> FloatX4#

-- | Pack the elements of an unboxed tuple into a vector.
packFloatX8# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX8#

-- | Pack the elements of an unboxed tuple into a vector.
packInt16X16# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X16#

-- | Pack the elements of an unboxed tuple into a vector.
packInt16X32# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X32#

-- | Pack the elements of an unboxed tuple into a vector.
packInt16X8# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X8#

-- | Pack the elements of an unboxed tuple into a vector.
packInt32X16# :: (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #) -> Int32X16#

-- | Pack the elements of an unboxed tuple into a vector.
packInt32X4# :: (# Int32#, Int32#, Int32#, Int32# #) -> Int32X4#

-- | Pack the elements of an unboxed tuple into a vector.
packInt32X8# :: (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #) -> Int32X8#

-- | Pack the elements of an unboxed tuple into a vector.
packInt64X2# :: (# Int64#, Int64# #) -> Int64X2#

-- | Pack the elements of an unboxed tuple into a vector.
packInt64X4# :: (# Int64#, Int64#, Int64#, Int64# #) -> Int64X4#

-- | Pack the elements of an unboxed tuple into a vector.
packInt64X8# :: (# Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64# #) -> Int64X8#

-- | Pack the elements of an unboxed tuple into a vector.
packInt8X16# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X16#

-- | Pack the elements of an unboxed tuple into a vector.
packInt8X32# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X32#

-- | Pack the elements of an unboxed tuple into a vector.
packInt8X64# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X64#

-- | Pack the elements of an unboxed tuple into a vector.
packWord16X16# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X16#

-- | Pack the elements of an unboxed tuple into a vector.
packWord16X32# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X32#

-- | Pack the elements of an unboxed tuple into a vector.
packWord16X8# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X8#

-- | Pack the elements of an unboxed tuple into a vector.
packWord32X16# :: (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #) -> Word32X16#

-- | Pack the elements of an unboxed tuple into a vector.
packWord32X4# :: (# Word32#, Word32#, Word32#, Word32# #) -> Word32X4#

-- | Pack the elements of an unboxed tuple into a vector.
packWord32X8# :: (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #) -> Word32X8#

-- | Pack the elements of an unboxed tuple into a vector.
packWord64X2# :: (# Word64#, Word64# #) -> Word64X2#

-- | Pack the elements of an unboxed tuple into a vector.
packWord64X4# :: (# Word64#, Word64#, Word64#, Word64# #) -> Word64X4#

-- | Pack the elements of an unboxed tuple into a vector.
packWord64X8# :: (# Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64# #) -> Word64X8#

-- | Pack the elements of an unboxed tuple into a vector.
packWord8X16# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X16#

-- | Pack the elements of an unboxed tuple into a vector.
packWord8X32# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X32#

-- | Pack the elements of an unboxed tuple into a vector.
packWord8X64# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X64#

-- | Create a new spark evaluating the given argument. The return value
--   should always be 1. Users are encouraged to use spark# instead.
par# :: a -> Int#

-- | Deposit bits to a word at locations specified by a mask, aka
--   <a>parallel bit deposit</a>.
--   
--   Software emulation:
--   
--   <pre>
--   pdep :: Word -&gt; Word -&gt; Word
--   pdep src mask = go 0 src mask
--     where
--       go :: Word -&gt; Word -&gt; Word -&gt; Word
--       go result _ 0 = result
--       go result src mask = go newResult newSrc newMask
--         where
--           maskCtz   = countTrailingZeros mask
--           newResult = if testBit src 0 then setBit result maskCtz else result
--           newSrc    = src `shiftR` 1
--           newMask   = clearBit mask maskCtz
--   </pre>
pdep# :: Word# -> Word# -> Word#

-- | Deposit bits to lower 16 bits of a word at locations specified by a
--   mask.
pdep16# :: Word# -> Word# -> Word#

-- | Deposit bits to lower 32 bits of a word at locations specified by a
--   mask.
pdep32# :: Word# -> Word# -> Word#

-- | Deposit bits to a word at locations specified by a mask.
pdep64# :: Word64# -> Word64# -> Word64#

-- | Deposit bits to lower 8 bits of a word at locations specified by a
--   mask.
pdep8# :: Word# -> Word# -> Word#

-- | Extract bits from a word at locations specified by a mask, aka
--   <a>parallel bit extract</a>.
--   
--   Software emulation:
--   
--   <pre>
--   pext :: Word -&gt; Word -&gt; Word
--   pext src mask = loop 0 0 0
--     where
--       loop i count result
--         | i &gt;= finiteBitSize (0 :: Word)
--         = result
--         | testBit mask i
--         = loop (i + 1) (count + 1) (if testBit src i then setBit result count else result)
--         | otherwise
--         = loop (i + 1) count result
--   </pre>
pext# :: Word# -> Word# -> Word#

-- | Extract bits from lower 16 bits of a word at locations specified by a
--   mask.
pext16# :: Word# -> Word# -> Word#

-- | Extract bits from lower 32 bits of a word at locations specified by a
--   mask.
pext32# :: Word# -> Word# -> Word#

-- | Extract bits from a word at locations specified by a mask.
pext64# :: Word64# -> Word64# -> Word64#

-- | Extract bits from lower 8 bits of a word at locations specified by a
--   mask.
pext8# :: Word# -> Word# -> Word#
plusAddr# :: Addr# -> Int# -> Addr#

-- | Add two vectors element-wise.
plusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Add two vectors element-wise.
plusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Add two vectors element-wise.
plusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
plusFloat# :: Float# -> Float# -> Float#

-- | Add two vectors element-wise.
plusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Add two vectors element-wise.
plusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Add two vectors element-wise.
plusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
plusInt16# :: Int16# -> Int16# -> Int16#

-- | Add two vectors element-wise.
plusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Add two vectors element-wise.
plusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Add two vectors element-wise.
plusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
plusInt32# :: Int32# -> Int32# -> Int32#

-- | Add two vectors element-wise.
plusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Add two vectors element-wise.
plusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Add two vectors element-wise.
plusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
plusInt64# :: Int64# -> Int64# -> Int64#

-- | Add two vectors element-wise.
plusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Add two vectors element-wise.
plusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Add two vectors element-wise.
plusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
plusInt8# :: Int8# -> Int8# -> Int8#

-- | Add two vectors element-wise.
plusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Add two vectors element-wise.
plusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Add two vectors element-wise.
plusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
plusWord# :: Word# -> Word# -> Word#
plusWord16# :: Word16# -> Word16# -> Word16#

-- | Add two vectors element-wise.
plusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Add two vectors element-wise.
plusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Add two vectors element-wise.
plusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Add unsigned integers, with the high part (carry) in the first
--   component of the returned pair and the low part in the second
--   component of the pair. See also <a>addWordC#</a>.
plusWord2# :: Word# -> Word# -> (# Word#, Word# #)
plusWord32# :: Word32# -> Word32# -> Word32#

-- | Add two vectors element-wise.
plusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Add two vectors element-wise.
plusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Add two vectors element-wise.
plusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
plusWord64# :: Word64# -> Word64# -> Word64#

-- | Add two vectors element-wise.
plusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Add two vectors element-wise.
plusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Add two vectors element-wise.
plusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
plusWord8# :: Word8# -> Word8# -> Word8#

-- | Add two vectors element-wise.
plusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Add two vectors element-wise.
plusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Add two vectors element-wise.
plusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Count the number of set bits in a word.
popCnt# :: Word# -> Word#

-- | Count the number of set bits in the lower 16 bits of a word.
popCnt16# :: Word# -> Word#

-- | Count the number of set bits in the lower 32 bits of a word.
popCnt32# :: Word# -> Word#

-- | Count the number of set bits in a 64-bit word.
popCnt64# :: Word64# -> Word#

-- | Count the number of set bits in the lower 8 bits of a word.
popCnt8# :: Word# -> Word#
powerFloat# :: Float# -> Float# -> Float#
prefetchAddr0# :: Addr# -> Int# -> State# d -> State# d
prefetchAddr1# :: Addr# -> Int# -> State# d -> State# d
prefetchAddr2# :: Addr# -> Int# -> State# d -> State# d
prefetchAddr3# :: Addr# -> Int# -> State# d -> State# d
prefetchByteArray0# :: ByteArray# -> Int# -> State# d -> State# d
prefetchByteArray1# :: ByteArray# -> Int# -> State# d -> State# d
prefetchByteArray2# :: ByteArray# -> Int# -> State# d -> State# d
prefetchByteArray3# :: ByteArray# -> Int# -> State# d -> State# d
prefetchMutableByteArray0# :: MutableByteArray# d -> Int# -> State# d -> State# d
prefetchMutableByteArray1# :: MutableByteArray# d -> Int# -> State# d -> State# d
prefetchMutableByteArray2# :: MutableByteArray# d -> Int# -> State# d -> State# d
prefetchMutableByteArray3# :: MutableByteArray# d -> Int# -> State# d -> State# d
prefetchValue0# :: a -> State# d -> State# d
prefetchValue1# :: a -> State# d -> State# d
prefetchValue2# :: a -> State# d -> State# d
prefetchValue3# :: a -> State# d -> State# d

-- | See <a>GHC.Prim#continuations</a>.
prompt# :: PromptTag# a -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)

-- | Witness for an unboxed <a>Proxy#</a> value, which has no runtime
--   representation.
proxy# :: forall {k} (a :: k). Proxy# a

-- | If <a>MVar#</a> is full, block until it becomes empty. Then store
--   value arg as its new contents.
putMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> a -> State# d -> State# d

-- | Rounds towards zero. The behavior is undefined if the second argument
--   is zero.
quotInt# :: Int# -> Int# -> Int#
quotInt16# :: Int16# -> Int16# -> Int16#

-- | Rounds towards zero element-wise.
quotInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Rounds towards zero element-wise.
quotInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Rounds towards zero element-wise.
quotInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
quotInt32# :: Int32# -> Int32# -> Int32#

-- | Rounds towards zero element-wise.
quotInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Rounds towards zero element-wise.
quotInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Rounds towards zero element-wise.
quotInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
quotInt64# :: Int64# -> Int64# -> Int64#

-- | Rounds towards zero element-wise.
quotInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Rounds towards zero element-wise.
quotInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Rounds towards zero element-wise.
quotInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
quotInt8# :: Int8# -> Int8# -> Int8#

-- | Rounds towards zero element-wise.
quotInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Rounds towards zero element-wise.
quotInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Rounds towards zero element-wise.
quotInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Rounds towards zero.
quotRemInt# :: Int# -> Int# -> (# Int#, Int# #)
quotRemInt16# :: Int16# -> Int16# -> (# Int16#, Int16# #)
quotRemInt32# :: Int32# -> Int32# -> (# Int32#, Int32# #)
quotRemInt8# :: Int8# -> Int8# -> (# Int8#, Int8# #)
quotRemWord# :: Word# -> Word# -> (# Word#, Word# #)
quotRemWord16# :: Word16# -> Word16# -> (# Word16#, Word16# #)

-- | Takes high word of dividend, then low word of dividend, then divisor.
--   Requires that high word &lt; divisor.
quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#, Word# #)
quotRemWord32# :: Word32# -> Word32# -> (# Word32#, Word32# #)
quotRemWord8# :: Word8# -> Word8# -> (# Word8#, Word8# #)
quotWord# :: Word# -> Word# -> Word#
quotWord16# :: Word16# -> Word16# -> Word16#

-- | Rounds towards zero element-wise.
quotWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Rounds towards zero element-wise.
quotWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Rounds towards zero element-wise.
quotWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
quotWord32# :: Word32# -> Word32# -> Word32#

-- | Rounds towards zero element-wise.
quotWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Rounds towards zero element-wise.
quotWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Rounds towards zero element-wise.
quotWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
quotWord64# :: Word64# -> Word64# -> Word64#

-- | Rounds towards zero element-wise.
quotWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Rounds towards zero element-wise.
quotWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Rounds towards zero element-wise.
quotWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
quotWord8# :: Word8# -> Word8# -> Word8#

-- | Rounds towards zero element-wise.
quotWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Rounds towards zero element-wise.
quotWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Rounds towards zero element-wise.
quotWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
raise# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) b. a -> b
raiseDivZero# :: (# #) -> b
raiseIO# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) b. a -> State# RealWorld -> (# State# RealWorld, b #)
raiseOverflow# :: (# #) -> b
raiseUnderflow# :: (# #) -> b

-- | Read a machine address from mutable array; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readAddrArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)

-- | Read a machine address from mutable address; offset in machine words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readAddrOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Addr# #)

-- | Read from specified index of mutable array. Result is not yet
--   evaluated.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> State# d -> (# State# d, a #)

-- | Read an 8-bit character from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readCharArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)

-- | Read an 8-bit character from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readCharOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a double-precision floating-point value from mutable array;
--   offset in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleArrayAsDoubleX2# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleArrayAsDoubleX4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleArrayAsDoubleX8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)

-- | Read a double-precision floating-point value from mutable address;
--   offset in 8-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Double# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleX2Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleX2OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleX4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleX4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleX8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleX8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)

-- | Read a single-precision floating-point value from mutable array;
--   offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatArrayAsFloatX16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatArrayAsFloatX4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatArrayAsFloatX8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)

-- | Read a single-precision floating-point value from mutable address;
--   offset in 4-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Float# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatOffAddrAsFloatX16# :: Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatOffAddrAsFloatX4# :: Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatOffAddrAsFloatX8# :: Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatX16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatX16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatX4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatX4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatX8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatX8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)

-- | If <a>IOPort#</a> is empty, block until it becomes full. Then remove
--   and return its contents, and set it empty. Throws an
--   <tt>IOPortException</tt> if another thread is already waiting to read
--   this <a>IOPort#</a>.
readIOPort# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). IOPort# d a -> State# d -> (# State# d, a #)

-- | Read a 16-bit signed integer from mutable array; offset in 2-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16ArrayAsInt16X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16ArrayAsInt16X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16ArrayAsInt16X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)

-- | Read a 16-bit signed integer from mutable address; offset in 2-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16OffAddrAsInt16X16# :: Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16OffAddrAsInt16X32# :: Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16OffAddrAsInt16X8# :: Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)

-- | Read a 32-bit signed integer from mutable array; offset in 4-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32ArrayAsInt32X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32ArrayAsInt32X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32ArrayAsInt32X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)

-- | Read a 32-bit signed integer from mutable address; offset in 4-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32OffAddrAsInt32X16# :: Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32OffAddrAsInt32X4# :: Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32OffAddrAsInt32X8# :: Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)

-- | Read a 64-bit signed integer from mutable array; offset in 8-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64ArrayAsInt64X2# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64ArrayAsInt64X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64ArrayAsInt64X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)

-- | Read a 64-bit signed integer from mutable address; offset in 8-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64OffAddrAsInt64X2# :: Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64OffAddrAsInt64X4# :: Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64OffAddrAsInt64X8# :: Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64X2Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64X2OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)

-- | Read an 8-bit signed integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8ArrayAsInt8X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8ArrayAsInt8X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8ArrayAsInt8X64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)

-- | Read an 8-bit signed integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8OffAddrAsInt8X16# :: Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8OffAddrAsInt8X32# :: Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8OffAddrAsInt8X64# :: Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8X64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8X64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)

-- | Read a word-sized integer from mutable array; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readIntArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)

-- | Read a word-sized integer from mutable address; offset in machine
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readIntOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int# #)

-- | If <a>MVar#</a> is empty, block until it becomes full. Then read its
--   contents without modifying the MVar, without possibility of
--   intervention from other threads.
readMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> State# d -> (# State# d, a #)

-- | Read contents of <a>MutVar#</a>. Result is not yet evaluated.
readMutVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutVar# d a -> State# d -> (# State# d, a #)

-- | Read from specified index of mutable array. Result is not yet
--   evaluated.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readSmallArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> State# d -> (# State# d, a #)

-- | Read a <a>StablePtr#</a> value from mutable array; offset in machine
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readStablePtrArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)

-- | Read a <a>StablePtr#</a> value from mutable address; offset in machine
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readStablePtrOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, StablePtr# a #)

-- | Read contents of <a>TVar#</a> inside an STM transaction, i.e. within a
--   call to <a>atomically#</a>. Does not force evaluation of the result.
readTVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). TVar# d a -> State# d -> (# State# d, a #)

-- | Read contents of <a>TVar#</a> outside an STM transaction. Does not
--   force evaluation of the result.
readTVarIO# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). TVar# d a -> State# d -> (# State# d, a #)

-- | Read a 32-bit character from mutable array; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWideCharArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a 32-bit character from mutable address; offset in 4-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWideCharOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a 16-bit unsigned integer from mutable array; offset in 2-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16ArrayAsWord16X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16ArrayAsWord16X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16ArrayAsWord16X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)

-- | Read a 16-bit unsigned integer from mutable address; offset in 2-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16OffAddrAsWord16X16# :: Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16OffAddrAsWord16X32# :: Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16OffAddrAsWord16X8# :: Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)

-- | Read a 32-bit unsigned integer from mutable array; offset in 4-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32ArrayAsWord32X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32ArrayAsWord32X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32ArrayAsWord32X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)

-- | Read a 32-bit unsigned integer from mutable address; offset in 4-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32OffAddrAsWord32X16# :: Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32OffAddrAsWord32X4# :: Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32OffAddrAsWord32X8# :: Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)

-- | Read a 64-bit unsigned integer from mutable array; offset in 8-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64ArrayAsWord64X2# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64ArrayAsWord64X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64ArrayAsWord64X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)

-- | Read a 64-bit unsigned integer from mutable address; offset in 8-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64OffAddrAsWord64X2# :: Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64OffAddrAsWord64X4# :: Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64OffAddrAsWord64X8# :: Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64X2Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64X2OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)

-- | Read an 8-bit unsigned integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8# #)

-- | Read a machine address from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsAddr# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)

-- | Read an 8-bit character from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsChar# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a double-precision floating-point value from mutable array;
--   offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsDouble# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)

-- | Read a single-precision floating-point value from mutable array;
--   offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsFloat# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)

-- | Read a word-sized integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)

-- | Read a 16-bit signed integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16# #)

-- | Read a 32-bit signed integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32# #)

-- | Read a 64-bit signed integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64# #)

-- | Read a <a>StablePtr#</a> value from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsStablePtr# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)

-- | Read a 32-bit character from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWideChar# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a word-sized unsigned integer from mutable array; offset in
--   bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)

-- | Read a 16-bit unsigned integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16# #)

-- | Read a 32-bit unsigned integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32# #)

-- | Read a 64-bit unsigned integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord8X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord8X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord8X64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)

-- | Read an 8-bit unsigned integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8# #)

-- | Read a machine address from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsAddr# :: Addr# -> Int# -> State# d -> (# State# d, Addr# #)

-- | Read an 8-bit character from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsChar# :: Addr# -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a double-precision floating-point value from mutable address;
--   offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsDouble# :: Addr# -> Int# -> State# d -> (# State# d, Double# #)

-- | Read a single-precision floating-point value from mutable address;
--   offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsFloat# :: Addr# -> Int# -> State# d -> (# State# d, Float# #)

-- | Read a word-sized integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsInt# :: Addr# -> Int# -> State# d -> (# State# d, Int# #)

-- | Read a 16-bit signed integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsInt16# :: Addr# -> Int# -> State# d -> (# State# d, Int16# #)

-- | Read a 32-bit signed integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsInt32# :: Addr# -> Int# -> State# d -> (# State# d, Int32# #)

-- | Read a 64-bit signed integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsInt64# :: Addr# -> Int# -> State# d -> (# State# d, Int64# #)

-- | Read a <a>StablePtr#</a> value from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsStablePtr# :: Addr# -> Int# -> State# d -> (# State# d, StablePtr# a #)

-- | Read a 32-bit character from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWideChar# :: Addr# -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a word-sized unsigned integer from mutable address; offset in
--   bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWord# :: Addr# -> Int# -> State# d -> (# State# d, Word# #)

-- | Read a 16-bit unsigned integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWord16# :: Addr# -> Int# -> State# d -> (# State# d, Word16# #)

-- | Read a 32-bit unsigned integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWord32# :: Addr# -> Int# -> State# d -> (# State# d, Word32# #)

-- | Read a 64-bit unsigned integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWord64# :: Addr# -> Int# -> State# d -> (# State# d, Word64# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWord8X16# :: Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWord8X32# :: Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWord8X64# :: Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8X64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8X64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)

-- | Read a word-sized unsigned integer from mutable array; offset in
--   machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWordArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)

-- | Read a word-sized unsigned integer from mutable address; offset in
--   machine words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWordOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word# #)

-- | The token used in the implementation of the IO monad as a state monad.
--   It does not pass any information at runtime. See also <a>runRW#</a>.
realWorld# :: State# RealWorld

-- | Returns <tt>1#</tt> if the given pointers are equal and <tt>0#</tt>
--   otherwise.
reallyUnsafePtrEquality# :: forall {l :: Levity} {k :: Levity} (a :: TYPE ('BoxedRep l)) (b :: TYPE ('BoxedRep k)). a -> b -> Int#

-- | Return the remainder when the <a>Addr#</a> arg, treated like an
--   <a>Int#</a>, is divided by the <a>Int#</a> arg.
remAddr# :: Addr# -> Int# -> Int#

-- | Satisfies <tt>(<a>quotInt#</a> x y) <a>*#</a> y <a>+#</a>
--   (<a>remInt#</a> x y) == x</tt>. The behavior is undefined if the
--   second argument is zero.
remInt# :: Int# -> Int# -> Int#
remInt16# :: Int16# -> Int16# -> Int16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
remInt32# :: Int32# -> Int32# -> Int32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
remInt64# :: Int64# -> Int64# -> Int64#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
remInt8# :: Int8# -> Int8# -> Int8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
remWord# :: Word# -> Word# -> Word#
remWord16# :: Word16# -> Word16# -> Word16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
remWord32# :: Word32# -> Word32# -> Word32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
remWord64# :: Word64# -> Word64# -> Word64#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
remWord8# :: Word8# -> Word8# -> Word8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Resize mutable byte array to new specified size (in bytes), shrinking
--   or growing it. The returned <a>MutableByteArray#</a> is either the
--   original <a>MutableByteArray#</a> resized in-place or, if not
--   possible, a newly allocated (unpinned) <a>MutableByteArray#</a> (with
--   the original content copied over).
--   
--   To avoid undefined behaviour, the original <a>MutableByteArray#</a>
--   shall not be accessed anymore after a <a>resizeMutableByteArray#</a>
--   has been performed. Moreover, no reference to the old one should be
--   kept in order to allow garbage collection of the original
--   <a>MutableByteArray#</a> in case a new <a>MutableByteArray#</a> had to
--   be allocated.
resizeMutableByteArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, MutableByteArray# d #)
retry# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). State# RealWorld -> (# State# RealWorld, a #)
rightSection :: forall {n :: Multiplicity} {o :: Multiplicity} a b c. (a %n -> b %o -> c) -> b %o -> a %n -> c

-- | The value of <tt><a>seq</a> a b</tt> is bottom if <tt>a</tt> is
--   bottom, and otherwise equal to <tt>b</tt>. In other words, it
--   evaluates the first argument <tt>a</tt> to weak head normal form
--   (WHNF). <a>seq</a> is usually introduced to improve performance by
--   avoiding unneeded laziness.
--   
--   A note on evaluation order: the expression <tt><a>seq</a> a b</tt>
--   does <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <a>seq</a> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <a>seq</a> returns
--   a value. In particular, this means that <tt>b</tt> may be evaluated
--   before <tt>a</tt>. If you need to guarantee a specific order of
--   evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: a -> b -> b
infixr 0 `seq`

-- | <tt><a>setAddrRange#</a> dest len c</tt> sets all of the bytes in
--   <tt>[dest, dest+len)</tt> to the value <tt>c</tt>.
--   
--   Analogous to the standard C function <tt>memset</tt>, but with a
--   different argument order.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
setAddrRange# :: Addr# -> Int# -> Int# -> State# RealWorld -> State# RealWorld

-- | <tt><a>setByteArray#</a> ba off len c</tt> sets the byte range
--   <tt>[off, off+len)</tt> of the <a>MutableByteArray#</a> to the byte
--   <tt>c</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
setByteArray# :: MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> State# d

-- | Sets the allocation counter for the current thread to the given value.
setThreadAllocationCounter# :: Int64# -> State# RealWorld -> State# RealWorld

-- | Shrink mutable byte array to new specified size (in bytes), in the
--   specified state thread. The new size argument must be less than or
--   equal to the current size as reported by
--   <a>getSizeofMutableByteArray#</a>.
--   
--   Assuming the non-profiling RTS, this primitive compiles to an O(1)
--   operation in C--, modifying the array in-place. Backends bypassing C--
--   representation (such as JavaScript) might behave differently.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
shrinkMutableByteArray# :: MutableByteArray# d -> Int# -> State# d -> State# d

-- | Shrink mutable array to new specified size, in the specified state
--   thread. The new size argument must be less than or equal to the
--   current size as reported by <a>getSizeofSmallMutableArray#</a>.
--   
--   Assuming the non-profiling RTS, for the copying garbage collector
--   (default) this primitive compiles to an O(1) operation in C--,
--   modifying the array in-place. For the non-moving garbage collector,
--   however, the time is proportional to the number of elements shrinked
--   out. Backends bypassing C-- representation (such as JavaScript) might
--   behave differently.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
shrinkSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> State# d -> State# d

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleDoubleX2# :: DoubleX2# -> DoubleX2# -> (# Int#, Int# #) -> DoubleX2#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleDoubleX4# :: DoubleX4# -> DoubleX4# -> (# Int#, Int#, Int#, Int# #) -> DoubleX4#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleDoubleX8# :: DoubleX8# -> DoubleX8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> DoubleX8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleFloatX16# :: FloatX16# -> FloatX16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> FloatX16#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleFloatX4# :: FloatX4# -> FloatX4# -> (# Int#, Int#, Int#, Int# #) -> FloatX4#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleFloatX8# :: FloatX8# -> FloatX8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> FloatX8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt16X16# :: Int16X16# -> Int16X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X16#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt16X32# :: Int16X32# -> Int16X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X32#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt16X8# :: Int16X8# -> Int16X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt32X16# :: Int32X16# -> Int32X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int32X16#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt32X4# :: Int32X4# -> Int32X4# -> (# Int#, Int#, Int#, Int# #) -> Int32X4#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt32X8# :: Int32X8# -> Int32X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int32X8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt64X2# :: Int64X2# -> Int64X2# -> (# Int#, Int# #) -> Int64X2#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt64X4# :: Int64X4# -> Int64X4# -> (# Int#, Int#, Int#, Int# #) -> Int64X4#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt64X8# :: Int64X8# -> Int64X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int64X8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt8X16# :: Int8X16# -> Int8X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X16#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt8X32# :: Int8X32# -> Int8X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X32#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt8X64# :: Int8X64# -> Int8X64# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X64#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord16X16# :: Word16X16# -> Word16X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word16X16#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord16X32# :: Word16X32# -> Word16X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word16X32#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord16X8# :: Word16X8# -> Word16X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word16X8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord32X16# :: Word32X16# -> Word32X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word32X16#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord32X4# :: Word32X4# -> Word32X4# -> (# Int#, Int#, Int#, Int# #) -> Word32X4#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord32X8# :: Word32X8# -> Word32X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word32X8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord64X2# :: Word64X2# -> Word64X2# -> (# Int#, Int# #) -> Word64X2#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord64X4# :: Word64X4# -> Word64X4# -> (# Int#, Int#, Int#, Int# #) -> Word64X4#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord64X8# :: Word64X8# -> Word64X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word64X8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord8X16# :: Word8X16# -> Word8X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word8X16#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord8X32# :: Word8X32# -> Word8X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word8X32#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord8X64# :: Word8X64# -> Word8X64# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word8X64#
sinDouble# :: Double# -> Double#
sinFloat# :: Float# -> Float#
sinhDouble# :: Double# -> Double#
sinhFloat# :: Float# -> Float#

-- | Return the number of elements in the array.
sizeofArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Array# a -> Int#

-- | Return the size of the array in bytes.
sizeofByteArray# :: ByteArray# -> Int#

-- | Return the number of elements in the array.
sizeofMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int#

-- | Return the size of the array in bytes. <b>Deprecated</b>, it is unsafe
--   in the presence of <a>shrinkMutableByteArray#</a> and
--   <a>resizeMutableByteArray#</a> operations on the same mutable byte
--   array.

-- | <i>Deprecated: Use <a>getSizeofMutableByteArray#</a> instead </i>
sizeofMutableByteArray# :: MutableByteArray# d -> Int#

-- | Return the number of elements in the array.
sizeofSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). SmallArray# a -> Int#

-- | Return the number of elements in the array. <b>Deprecated</b>, it is
--   unsafe in the presence of <a>shrinkSmallMutableArray#</a> and
--   <tt>resizeSmallMutableArray#</tt> operations on the same small mutable
--   array.

-- | <i>Deprecated: Use <a>getSizeofSmallMutableArray#</a> instead </i>
sizeofSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int#
spark# :: a -> State# d -> (# State# d, a #)
sqrtDouble# :: Double# -> Double#
sqrtFloat# :: Float# -> Float#
stableNameToInt# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). StableName# a -> Int#
subInt16# :: Int16# -> Int16# -> Int16#
subInt32# :: Int32# -> Int32# -> Int32#
subInt64# :: Int64# -> Int64# -> Int64#
subInt8# :: Int8# -> Int8# -> Int8#

-- | Subtract signed integers reporting overflow. First member of result is
--   the difference truncated to an <a>Int#</a>; second member is zero if
--   the true difference fits in an <a>Int#</a>, nonzero if overflow
--   occurred (the difference is either too large or too small to fit in an
--   <a>Int#</a>).
subIntC# :: Int# -> Int# -> (# Int#, Int# #)
subWord16# :: Word16# -> Word16# -> Word16#
subWord32# :: Word32# -> Word32# -> Word32#
subWord64# :: Word64# -> Word64# -> Word64#
subWord8# :: Word8# -> Word8# -> Word8#

-- | Subtract unsigned integers reporting overflow. The first element of
--   the pair is the result. The second element is the carry flag, which is
--   nonzero on overflow.
subWordC# :: Word# -> Word# -> (# Word#, Int# #)
tagToEnum# :: Int# -> a

-- | If <a>MVar#</a> is empty, block until it becomes full. Then remove and
--   return its contents, and set it empty.
takeMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> State# d -> (# State# d, a #)
tanDouble# :: Double# -> Double#
tanFloat# :: Float# -> Float#
tanhDouble# :: Double# -> Double#
tanhFloat# :: Float# -> Float#

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
thawArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. Array# a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
thawSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. SmallArray# a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)

-- | Get the label of the given thread. Morally of type <tt>ThreadId# -&gt;
--   IO (Maybe ByteArray#)</tt>, with a <tt>1#</tt> tag denoting
--   <tt>Just</tt>.
threadLabel# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, ByteArray# #)

-- | Get the status of the given thread. Result is <tt>(ThreadStatus,
--   Capability, Locked)</tt> where <tt>ThreadStatus</tt> is one of the
--   status constants defined in <tt>rts/Constants.h</tt>,
--   <tt>Capability</tt> is the number of the capability which currently
--   owns the thread, and <tt>Locked</tt> is a boolean indicating whether
--   the thread is bound to that capability.
threadStatus# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, Int#, Int# #)

-- | Multiply two vectors element-wise.
timesDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Multiply two vectors element-wise.
timesDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Multiply two vectors element-wise.
timesDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
timesFloat# :: Float# -> Float# -> Float#

-- | Multiply two vectors element-wise.
timesFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Multiply two vectors element-wise.
timesFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Multiply two vectors element-wise.
timesFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
timesInt16# :: Int16# -> Int16# -> Int16#

-- | Multiply two vectors element-wise.
timesInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Multiply two vectors element-wise.
timesInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Multiply two vectors element-wise.
timesInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Return a triple (isHighNeeded,high,low) where high and low are
--   respectively the high and low bits of the double-word result.
--   isHighNeeded is a cheap way to test if the high word is a
--   sign-extension of the low word (isHighNeeded = 0#) or not
--   (isHighNeeded = 1#).
timesInt2# :: Int# -> Int# -> (# Int#, Int#, Int# #)
timesInt32# :: Int32# -> Int32# -> Int32#

-- | Multiply two vectors element-wise.
timesInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Multiply two vectors element-wise.
timesInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Multiply two vectors element-wise.
timesInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
timesInt64# :: Int64# -> Int64# -> Int64#

-- | Multiply two vectors element-wise.
timesInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Multiply two vectors element-wise.
timesInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Multiply two vectors element-wise.
timesInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
timesInt8# :: Int8# -> Int8# -> Int8#

-- | Multiply two vectors element-wise.
timesInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Multiply two vectors element-wise.
timesInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Multiply two vectors element-wise.
timesInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
timesWord# :: Word# -> Word# -> Word#
timesWord16# :: Word16# -> Word16# -> Word16#

-- | Multiply two vectors element-wise.
timesWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Multiply two vectors element-wise.
timesWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Multiply two vectors element-wise.
timesWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
timesWord2# :: Word# -> Word# -> (# Word#, Word# #)
timesWord32# :: Word32# -> Word32# -> Word32#

-- | Multiply two vectors element-wise.
timesWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Multiply two vectors element-wise.
timesWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Multiply two vectors element-wise.
timesWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
timesWord64# :: Word64# -> Word64# -> Word64#

-- | Multiply two vectors element-wise.
timesWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Multiply two vectors element-wise.
timesWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Multiply two vectors element-wise.
timesWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
timesWord8# :: Word8# -> Word8# -> Word8#

-- | Multiply two vectors element-wise.
timesWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Multiply two vectors element-wise.
timesWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Multiply two vectors element-wise.
timesWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
touch# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. a -> State# d -> State# d

-- | Emits an event via the RTS tracing framework. The contents of the
--   event is the binary object passed as the first argument with the given
--   length passed as the second argument. The event will be emitted to the
--   <tt>.eventlog</tt> file.
traceBinaryEvent# :: Addr# -> Int# -> State# d -> State# d

-- | Emits an event via the RTS tracing framework. The contents of the
--   event is the zero-terminated byte string passed as the first argument.
--   The event will be emitted either to the <tt>.eventlog</tt> file, or to
--   stderr, depending on the runtime RTS flags.
traceEvent# :: Addr# -> State# d -> State# d

-- | Emits a marker event via the RTS tracing framework. The contents of
--   the event is the zero-terminated byte string passed as the first
--   argument. The event will be emitted either to the <tt>.eventlog</tt>
--   file, or to stderr, depending on the runtime RTS flags.
traceMarker# :: Addr# -> State# d -> State# d

-- | If <a>MVar#</a> is full, immediately return with integer 0. Otherwise,
--   store value arg as 'MVar#''s new contents, and return with integer 1.
tryPutMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> a -> State# d -> (# State# d, Int# #)

-- | If <a>MVar#</a> is empty, immediately return with integer 0 and value
--   undefined. Otherwise, return with integer 1 and contents of
--   <a>MVar#</a>.
tryReadMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> State# d -> (# State# d, Int#, a #)

-- | If <a>MVar#</a> is empty, immediately return with integer 0 and value
--   undefined. Otherwise, return with integer 1 and contents of
--   <a>MVar#</a>, and set <a>MVar#</a> empty.
tryTakeMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> State# d -> (# State# d, Int#, a #)

-- | Shift left. Result undefined if shift amount is not in the range 0 to
--   word size - 1 inclusive.
uncheckedIShiftL# :: Int# -> Int# -> Int#
uncheckedIShiftL64# :: Int64# -> Int# -> Int64#

-- | Shift right arithmetic. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedIShiftRA# :: Int# -> Int# -> Int#
uncheckedIShiftRA64# :: Int64# -> Int# -> Int64#

-- | Shift right logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedIShiftRL# :: Int# -> Int# -> Int#
uncheckedIShiftRL64# :: Int64# -> Int# -> Int64#

-- | Shift left logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedShiftL# :: Word# -> Int# -> Word#
uncheckedShiftL64# :: Word64# -> Int# -> Word64#
uncheckedShiftLInt16# :: Int16# -> Int# -> Int16#
uncheckedShiftLInt32# :: Int32# -> Int# -> Int32#
uncheckedShiftLInt8# :: Int8# -> Int# -> Int8#
uncheckedShiftLWord16# :: Word16# -> Int# -> Word16#
uncheckedShiftLWord32# :: Word32# -> Int# -> Word32#
uncheckedShiftLWord8# :: Word8# -> Int# -> Word8#
uncheckedShiftRAInt16# :: Int16# -> Int# -> Int16#
uncheckedShiftRAInt32# :: Int32# -> Int# -> Int32#
uncheckedShiftRAInt8# :: Int8# -> Int# -> Int8#

-- | Shift right logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedShiftRL# :: Word# -> Int# -> Word#
uncheckedShiftRL64# :: Word64# -> Int# -> Word64#
uncheckedShiftRLInt16# :: Int16# -> Int# -> Int16#
uncheckedShiftRLInt32# :: Int32# -> Int# -> Int32#
uncheckedShiftRLInt8# :: Int8# -> Int# -> Int8#
uncheckedShiftRLWord16# :: Word16# -> Int# -> Word16#
uncheckedShiftRLWord32# :: Word32# -> Int# -> Word32#
uncheckedShiftRLWord8# :: Word8# -> Int# -> Word8#

-- | <tt><tt>unmaskAsyncUninterruptible#</tt> k s</tt> evaluates <tt>k
--   s</tt> such that asynchronous exceptions are unmasked.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
unmaskAsyncExceptions# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)

-- | <tt><a>unpackClosure#</a> closure</tt> copies the closure and pointers
--   in the payload of the given closure into two new arrays, and returns a
--   pointer to the first word of the closure's info table, a non-pointer
--   array for the raw bytes of the closure, and a pointer array for the
--   pointers in the payload.
unpackClosure# :: a -> (# Addr#, ByteArray#, Array# b #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackDoubleX2# :: DoubleX2# -> (# Double#, Double# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackDoubleX4# :: DoubleX4# -> (# Double#, Double#, Double#, Double# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackDoubleX8# :: DoubleX8# -> (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackFloatX16# :: FloatX16# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackFloatX4# :: FloatX4# -> (# Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackFloatX8# :: FloatX8# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt16X16# :: Int16X16# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt16X32# :: Int16X32# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt16X8# :: Int16X8# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt32X16# :: Int32X16# -> (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt32X4# :: Int32X4# -> (# Int32#, Int32#, Int32#, Int32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt32X8# :: Int32X8# -> (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt64X2# :: Int64X2# -> (# Int64#, Int64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt64X4# :: Int64X4# -> (# Int64#, Int64#, Int64#, Int64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt64X8# :: Int64X8# -> (# Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt8X16# :: Int8X16# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt8X32# :: Int8X32# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt8X64# :: Int8X64# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord16X16# :: Word16X16# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord16X32# :: Word16X32# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord16X8# :: Word16X8# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord32X16# :: Word32X16# -> (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord32X4# :: Word32X4# -> (# Word32#, Word32#, Word32#, Word32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord32X8# :: Word32X8# -> (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord64X2# :: Word64X2# -> (# Word64#, Word64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord64X4# :: Word64X4# -> (# Word64#, Word64#, Word64#, Word64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord64X8# :: Word64X8# -> (# Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord8X16# :: Word8X16# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord8X32# :: Word8X32# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord8X64# :: Word8X64# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)

-- | Make a mutable array immutable, without copying.
unsafeFreezeArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> State# d -> (# State# d, Array# a #)

-- | Make a mutable byte array immutable, without copying.
unsafeFreezeByteArray# :: MutableByteArray# d -> State# d -> (# State# d, ByteArray# #)

-- | Make a mutable array immutable, without copying.
unsafeFreezeSmallArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> State# d -> (# State# d, SmallArray# a #)

-- | Make an immutable array mutable, without copying.
unsafeThawArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. Array# a -> State# d -> (# State# d, MutableArray# d a #)

-- | Make an immutable byte array mutable, without copying.
unsafeThawByteArray# :: ByteArray# -> State# d -> (# State# d, MutableByteArray# d #)

-- | Make an immutable array mutable, without copying.
unsafeThawSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. SmallArray# a -> State# d -> (# State# d, SmallMutableArray# d a #)

-- | This is an alias for the unboxed unit tuple constructor. In earlier
--   versions of GHC, <a>void#</a> was a value of the primitive type
--   <tt>Void#</tt>, which is now defined to be <tt>(# #)</tt>.

-- | <i>Deprecated: Use an unboxed unit tuple instead </i>
void# :: (# #)

-- | Block until input is available on specified file descriptor.
waitRead# :: Int# -> State# d -> State# d

-- | Block until output is possible on specified file descriptor.
waitWrite# :: Int# -> State# d -> State# d
word16ToInt16# :: Word16# -> Int16#
word16ToWord# :: Word16# -> Word#

-- | Convert an <a>Word#</a> to the corresponding <a>Double#</a> with the
--   same integral value (up to truncation due to floating-point
--   precision). e.g. <tt><a>word2Double#</a> 1## == 1.0##</tt>
word2Double# :: Word# -> Double#

-- | Convert an <a>Word#</a> to the corresponding <a>Float#</a> with the
--   same integral value (up to truncation due to floating-point
--   precision). e.g. <tt><a>word2Float#</a> 1## == 1.0#</tt>
word2Float# :: Word# -> Float#
word2Int# :: Word# -> Int#
word32ToInt32# :: Word32# -> Int32#
word32ToWord# :: Word32# -> Word#
word64ToInt64# :: Word64# -> Int64#
word64ToWord# :: Word64# -> Word#
word8ToInt8# :: Word8# -> Int8#
word8ToWord# :: Word8# -> Word#
wordToWord16# :: Word# -> Word16#
wordToWord32# :: Word# -> Word32#
wordToWord64# :: Word# -> Word64#
wordToWord8# :: Word# -> Word8#

-- | Write a machine address to mutable array; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeAddrArray# :: MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d

-- | Write a machine address to mutable address; offset in machine words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeAddrOffAddr# :: Addr# -> Int# -> Addr# -> State# d -> State# d

-- | Write to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> a -> State# d -> State# d

-- | Write an 8-bit character to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeCharArray# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d

-- | Write an 8-bit character to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeCharOffAddr# :: Addr# -> Int# -> Char# -> State# d -> State# d

-- | Write a double-precision floating-point value to mutable array; offset
--   in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleArray# :: MutableByteArray# d -> Int# -> Double# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleArrayAsDoubleX2# :: MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleArrayAsDoubleX4# :: MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleArrayAsDoubleX8# :: MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d

-- | Write a double-precision floating-point value to mutable address;
--   offset in 8-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleOffAddr# :: Addr# -> Int# -> Double# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleX2Array# :: MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleX4Array# :: MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleX8Array# :: MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8# -> State# d -> State# d

-- | Write a single-precision floating-point value to mutable array; offset
--   in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatArray# :: MutableByteArray# d -> Int# -> Float# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatArrayAsFloatX16# :: MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatArrayAsFloatX4# :: MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatArrayAsFloatX8# :: MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d

-- | Write a single-precision floating-point value to mutable address;
--   offset in 4-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatOffAddr# :: Addr# -> Int# -> Float# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatX16Array# :: MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatX16OffAddr# :: Addr# -> Int# -> FloatX16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatX4Array# :: MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatX4OffAddr# :: Addr# -> Int# -> FloatX4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatX8Array# :: MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatX8OffAddr# :: Addr# -> Int# -> FloatX8# -> State# d -> State# d

-- | If <a>IOPort#</a> is full, immediately return with integer 0, throwing
--   an <tt>IOPortException</tt>. Otherwise, store value arg as 'IOPort#''s
--   new contents, and return with integer 1.
writeIOPort# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). IOPort# d a -> a -> State# d -> (# State# d, Int# #)

-- | Write a 16-bit signed integer to mutable array; offset in 2-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16Array# :: MutableByteArray# d -> Int# -> Int16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16ArrayAsInt16X16# :: MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16ArrayAsInt16X32# :: MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16ArrayAsInt16X8# :: MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d

-- | Write a 16-bit signed integer to mutable address; offset in 2-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16OffAddr# :: Addr# -> Int# -> Int16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16X16Array# :: MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16X16OffAddr# :: Addr# -> Int# -> Int16X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16X32Array# :: MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16X32OffAddr# :: Addr# -> Int# -> Int16X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16X8Array# :: MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16X8OffAddr# :: Addr# -> Int# -> Int16X8# -> State# d -> State# d

-- | Write a 32-bit signed integer to mutable array; offset in 4-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32Array# :: MutableByteArray# d -> Int# -> Int32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32ArrayAsInt32X16# :: MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32ArrayAsInt32X4# :: MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32ArrayAsInt32X8# :: MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d

-- | Write a 32-bit signed integer to mutable address; offset in 4-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32OffAddr# :: Addr# -> Int# -> Int32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32X16Array# :: MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32X16OffAddr# :: Addr# -> Int# -> Int32X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32X4Array# :: MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32X4OffAddr# :: Addr# -> Int# -> Int32X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32X8Array# :: MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32X8OffAddr# :: Addr# -> Int# -> Int32X8# -> State# d -> State# d

-- | Write a 64-bit signed integer to mutable array; offset in 8-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64Array# :: MutableByteArray# d -> Int# -> Int64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64ArrayAsInt64X2# :: MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64ArrayAsInt64X4# :: MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64ArrayAsInt64X8# :: MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d

-- | Write a 64-bit signed integer to mutable address; offset in 8-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64OffAddr# :: Addr# -> Int# -> Int64# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64X2Array# :: MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64X2OffAddr# :: Addr# -> Int# -> Int64X2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64X4Array# :: MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64X4OffAddr# :: Addr# -> Int# -> Int64X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64X8Array# :: MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64X8OffAddr# :: Addr# -> Int# -> Int64X8# -> State# d -> State# d

-- | Write an 8-bit signed integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8Array# :: MutableByteArray# d -> Int# -> Int8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8ArrayAsInt8X16# :: MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8ArrayAsInt8X32# :: MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8ArrayAsInt8X64# :: MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d

-- | Write an 8-bit signed integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8OffAddr# :: Addr# -> Int# -> Int8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8X16Array# :: MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8X16OffAddr# :: Addr# -> Int# -> Int8X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8X32Array# :: MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8X32OffAddr# :: Addr# -> Int# -> Int8X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8X64Array# :: MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8X64OffAddr# :: Addr# -> Int# -> Int8X64# -> State# d -> State# d

-- | Write a word-sized integer to mutable array; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Write a word-sized integer to mutable address; offset in machine
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeIntOffAddr# :: Addr# -> Int# -> Int# -> State# d -> State# d

-- | Write contents of <a>MutVar#</a>.
writeMutVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutVar# d a -> a -> State# d -> State# d

-- | Write to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeSmallArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> a -> State# d -> State# d

-- | Write a <a>StablePtr#</a> value to mutable array; offset in machine
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeStablePtrArray# :: MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d

-- | Write a <a>StablePtr#</a> value to mutable address; offset in machine
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a -> State# d -> State# d

-- | Write contents of <a>TVar#</a>.
writeTVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). TVar# d a -> a -> State# d -> State# d

-- | Write a 32-bit character to mutable array; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWideCharArray# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d

-- | Write a 32-bit character to mutable address; offset in 4-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWideCharOffAddr# :: Addr# -> Int# -> Char# -> State# d -> State# d

-- | Write a 16-bit unsigned integer to mutable array; offset in 2-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16Array# :: MutableByteArray# d -> Int# -> Word16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16ArrayAsWord16X16# :: MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16ArrayAsWord16X32# :: MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16ArrayAsWord16X8# :: MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d

-- | Write a 16-bit unsigned integer to mutable address; offset in 2-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16OffAddr# :: Addr# -> Int# -> Word16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16X16Array# :: MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16X16OffAddr# :: Addr# -> Int# -> Word16X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16X32Array# :: MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16X32OffAddr# :: Addr# -> Int# -> Word16X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16X8Array# :: MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16X8OffAddr# :: Addr# -> Int# -> Word16X8# -> State# d -> State# d

-- | Write a 32-bit unsigned integer to mutable array; offset in 4-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32Array# :: MutableByteArray# d -> Int# -> Word32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32ArrayAsWord32X16# :: MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32ArrayAsWord32X4# :: MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32ArrayAsWord32X8# :: MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d

-- | Write a 32-bit unsigned integer to mutable address; offset in 4-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32OffAddr# :: Addr# -> Int# -> Word32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32X16Array# :: MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32X16OffAddr# :: Addr# -> Int# -> Word32X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32X4Array# :: MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32X4OffAddr# :: Addr# -> Int# -> Word32X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32X8Array# :: MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32X8OffAddr# :: Addr# -> Int# -> Word32X8# -> State# d -> State# d

-- | Write a 64-bit unsigned integer to mutable array; offset in 8-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64Array# :: MutableByteArray# d -> Int# -> Word64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64ArrayAsWord64X2# :: MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64ArrayAsWord64X4# :: MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64ArrayAsWord64X8# :: MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d

-- | Write a 64-bit unsigned integer to mutable address; offset in 8-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64OffAddr# :: Addr# -> Int# -> Word64# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64X2Array# :: MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64X2OffAddr# :: Addr# -> Int# -> Word64X2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64X4Array# :: MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64X4OffAddr# :: Addr# -> Int# -> Word64X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64X8Array# :: MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64X8OffAddr# :: Addr# -> Int# -> Word64X8# -> State# d -> State# d

-- | Write an 8-bit unsigned integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8Array# :: MutableByteArray# d -> Int# -> Word8# -> State# d -> State# d

-- | Write a machine address to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsAddr# :: MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d

-- | Write an 8-bit character to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsChar# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d

-- | Write a double-precision floating-point value to mutable array; offset
--   in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsDouble# :: MutableByteArray# d -> Int# -> Double# -> State# d -> State# d

-- | Write a single-precision floating-point value to mutable array; offset
--   in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsFloat# :: MutableByteArray# d -> Int# -> Float# -> State# d -> State# d

-- | Write a word-sized integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt# :: MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Write a 16-bit signed integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt16# :: MutableByteArray# d -> Int# -> Int16# -> State# d -> State# d

-- | Write a 32-bit signed integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt32# :: MutableByteArray# d -> Int# -> Int32# -> State# d -> State# d

-- | Write a 64-bit signed integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt64# :: MutableByteArray# d -> Int# -> Int64# -> State# d -> State# d

-- | Write a <a>StablePtr#</a> value to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsStablePtr# :: MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d

-- | Write a 32-bit character to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWideChar# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d

-- | Write a word-sized unsigned integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord# :: MutableByteArray# d -> Int# -> Word# -> State# d -> State# d

-- | Write a 16-bit unsigned integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord16# :: MutableByteArray# d -> Int# -> Word16# -> State# d -> State# d

-- | Write a 32-bit unsigned integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord32# :: MutableByteArray# d -> Int# -> Word32# -> State# d -> State# d

-- | Write a 64-bit unsigned integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord64# :: MutableByteArray# d -> Int# -> Word64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord8X16# :: MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord8X32# :: MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord8X64# :: MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d

-- | Write an 8-bit unsigned integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddr# :: Addr# -> Int# -> Word8# -> State# d -> State# d

-- | Write a machine address to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsAddr# :: Addr# -> Int# -> Addr# -> State# d -> State# d

-- | Write an 8-bit character to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsChar# :: Addr# -> Int# -> Char# -> State# d -> State# d

-- | Write a double-precision floating-point value to mutable address;
--   offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsDouble# :: Addr# -> Int# -> Double# -> State# d -> State# d

-- | Write a single-precision floating-point value to mutable address;
--   offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsFloat# :: Addr# -> Int# -> Float# -> State# d -> State# d

-- | Write a word-sized integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsInt# :: Addr# -> Int# -> Int# -> State# d -> State# d

-- | Write a 16-bit signed integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsInt16# :: Addr# -> Int# -> Int16# -> State# d -> State# d

-- | Write a 32-bit signed integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsInt32# :: Addr# -> Int# -> Int32# -> State# d -> State# d

-- | Write a 64-bit signed integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsInt64# :: Addr# -> Int# -> Int64# -> State# d -> State# d

-- | Write a <a>StablePtr#</a> value to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsStablePtr# :: Addr# -> Int# -> StablePtr# a -> State# d -> State# d

-- | Write a 32-bit character to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWideChar# :: Addr# -> Int# -> Char# -> State# d -> State# d

-- | Write a word-sized unsigned integer to mutable address; offset in
--   bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWord# :: Addr# -> Int# -> Word# -> State# d -> State# d

-- | Write a 16-bit unsigned integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWord16# :: Addr# -> Int# -> Word16# -> State# d -> State# d

-- | Write a 32-bit unsigned integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWord32# :: Addr# -> Int# -> Word32# -> State# d -> State# d

-- | Write a 64-bit unsigned integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWord64# :: Addr# -> Int# -> Word64# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8X16Array# :: MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8X16OffAddr# :: Addr# -> Int# -> Word8X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8X32Array# :: MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8X32OffAddr# :: Addr# -> Int# -> Word8X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8X64Array# :: MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8X64OffAddr# :: Addr# -> Int# -> Word8X64# -> State# d -> State# d

-- | Write a word-sized unsigned integer to mutable array; offset in
--   machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWordArray# :: MutableByteArray# d -> Int# -> Word# -> State# d -> State# d

-- | Write a word-sized unsigned integer to mutable address; offset in
--   machine words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWordOffAddr# :: Addr# -> Int# -> Word# -> State# d -> State# d
xor# :: Word# -> Word# -> Word#
xor64# :: Word64# -> Word64# -> Word64#

-- | Bitwise "xor".
xorI# :: Int# -> Int# -> Int#
xorWord16# :: Word16# -> Word16# -> Word16#
xorWord32# :: Word32# -> Word32# -> Word32#
xorWord8# :: Word8# -> Word8# -> Word8#
yield# :: State# RealWorld -> State# RealWorld

-- | An arbitrary machine address assumed to point outside the
--   garbage-collected heap.
data Addr# :: TYPE 'AddrRep
data Array# (a :: TYPE 'BoxedRep l) :: UnliftedType

-- | Primitive bytecode type.
data BCO

-- | A boxed, unlifted datatype representing a region of raw memory in the
--   garbage-collected heap, which is not scanned for pointers during
--   garbage collection.
--   
--   It is created by freezing a <a>MutableByteArray#</a> with
--   <a>unsafeFreezeByteArray#</a>. Freezing is essentially a no-op, as
--   <a>MutableByteArray#</a> and <a>ByteArray#</a> share the same heap
--   structure under the hood.
--   
--   The immutable and mutable variants are commonly used for scenarios
--   requiring high-performance data structures, like <tt>Text</tt>,
--   <tt>Primitive Vector</tt>, <tt>Unboxed Array</tt>, and
--   <tt>ShortByteString</tt>.
--   
--   Another application of fundamental importance is <tt>Integer</tt>,
--   which is backed by <a>ByteArray#</a>.
--   
--   The representation on the heap of a Byte Array is:
--   
--   <pre>
--   +------------+-----------------+-----------------------+
--   |            |                 |                       |
--   |   HEADER   | SIZE (in bytes) |       PAYLOAD         |
--   |            |                 |                       |
--   +------------+-----------------+-----------------------+
--   </pre>
--   
--   To obtain a pointer to actual payload (e.g., for FFI purposes) use
--   <a>byteArrayContents#</a> or <a>mutableByteArrayContents#</a>.
--   
--   Alternatively, enabling the <tt>UnliftedFFITypes</tt> extension allows
--   to mention <a>ByteArray#</a> and <a>MutableByteArray#</a> in FFI type
--   signatures directly.
data ByteArray# :: UnliftedType
data CONSTRAINT (a :: RuntimeRep)
data Char# :: TYPE 'WordRep
data Compact# :: UnliftedType
data Double# :: TYPE 'DoubleRep
data DoubleX2# :: TYPE 'VecRep 'Vec2 'DoubleElemRep
data DoubleX4# :: TYPE 'VecRep 'Vec4 'DoubleElemRep
data DoubleX8# :: TYPE 'VecRep 'Vec8 'DoubleElemRep

-- | The builtin function type, written in infix form as <tt>a % m -&gt;
--   b</tt>. Values of this type are functions taking inputs of type
--   <tt>a</tt> and producing outputs of type <tt>b</tt>. The multiplicity
--   of the input is <tt>m</tt>.
--   
--   Note that <tt><a>FUN</a> m a b</tt> permits representation
--   polymorphism in both <tt>a</tt> and <tt>b</tt>, so that types like
--   <tt><a>Int#</a> -&gt; <a>Int#</a></tt> can still be well-kinded.
data FUN
data Float# :: TYPE 'FloatRep
data FloatX16# :: TYPE 'VecRep 'Vec16 'FloatElemRep
data FloatX4# :: TYPE 'VecRep 'Vec4 'FloatElemRep
data FloatX8# :: TYPE 'VecRep 'Vec8 'FloatElemRep

-- | A shared I/O port is almost the same as an <a>MVar#</a>. The main
--   difference is that IOPort has no deadlock detection or deadlock
--   breaking code that forcibly releases the lock.
data IOPort# a (b :: TYPE 'BoxedRep l) :: UnliftedType
data Int# :: TYPE 'IntRep
data Int16# :: TYPE 'Int16Rep
data Int16X16# :: TYPE 'VecRep 'Vec16 'Int16ElemRep
data Int16X32# :: TYPE 'VecRep 'Vec32 'Int16ElemRep
data Int16X8# :: TYPE 'VecRep 'Vec8 'Int16ElemRep
data Int32# :: TYPE 'Int32Rep
data Int32X16# :: TYPE 'VecRep 'Vec16 'Int32ElemRep
data Int32X4# :: TYPE 'VecRep 'Vec4 'Int32ElemRep
data Int32X8# :: TYPE 'VecRep 'Vec8 'Int32ElemRep
data Int64# :: TYPE 'Int64Rep
data Int64X2# :: TYPE 'VecRep 'Vec2 'Int64ElemRep
data Int64X4# :: TYPE 'VecRep 'Vec4 'Int64ElemRep
data Int64X8# :: TYPE 'VecRep 'Vec8 'Int64ElemRep
data Int8# :: TYPE 'Int8Rep
data Int8X16# :: TYPE 'VecRep 'Vec16 'Int8ElemRep
data Int8X32# :: TYPE 'VecRep 'Vec32 'Int8ElemRep
data Int8X64# :: TYPE 'VecRep 'Vec64 'Int8ElemRep

-- | A shared mutable variable (<i>not</i> the same as a <a>MutVar#</a>!).
--   (Note: in a non-concurrent implementation, <tt>(<a>MVar#</a> a)</tt>
--   can be represented by <tt>(<a>MutVar#</a> (Maybe a))</tt>.)
data MVar# a (b :: TYPE 'BoxedRep l) :: UnliftedType

-- | A <a>MutVar#</a> behaves like a single-element mutable array.
data MutVar# a (b :: TYPE 'BoxedRep l) :: UnliftedType
data MutableArray# a (b :: TYPE 'BoxedRep l) :: UnliftedType

-- | A mutable <tt>ByteAray#</tt>. It can be created in three ways:
--   
--   <ul>
--   <li><a>newByteArray#</a>: Create an unpinned array.</li>
--   <li><a>newPinnedByteArray#</a>: This will create a pinned array,</li>
--   <li><a>newAlignedPinnedByteArray#</a>: This will create a pinned
--   array, with a custom alignment.</li>
--   </ul>
--   
--   Unpinned arrays can be moved around during garbage collection, so you
--   must not store or pass pointers to these values if there is a chance
--   for the garbage collector to kick in. That said, even unpinned arrays
--   can be passed to unsafe FFI calls, because no garbage collection
--   happens during these unsafe calls (see <a>Guaranteed Call Safety</a>
--   in the GHC Manual). For safe FFI calls, byte arrays must be not only
--   pinned, but also kept alive by means of the keepAlive# function for
--   the duration of a call (that's because garbage collection cannot move
--   a pinned array, but is free to scrap it altogether).
data MutableByteArray# a :: UnliftedType

-- | See <a>GHC.Prim#continuations</a>.
data PromptTag# a :: UnliftedType

-- | The type constructor <a>Proxy#</a> is used to bear witness to some
--   type variable. It's used when you want to pass around proxy values for
--   doing things like modelling type applications. A <a>Proxy#</a> is not
--   only unboxed, it also has a polymorphic kind, and has no runtime
--   representation, being totally free.
data Proxy# (a :: k) :: ZeroBitType

-- | <a>RealWorld</a> is deeply magical. It is <i>primitive</i>, but it is
--   not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <a>RealWorld</a>; it's only used in the type system, to
--   parameterise <a>State#</a>.
data RealWorld
data SmallArray# (a :: TYPE 'BoxedRep l) :: UnliftedType
data SmallMutableArray# a (b :: TYPE 'BoxedRep l) :: UnliftedType
data StableName# (a :: TYPE 'BoxedRep l) :: UnliftedType
data StablePtr# (a :: TYPE 'BoxedRep l) :: TYPE 'AddrRep

-- | Haskell representation of a <tt>StgStack*</tt> that was created
--   (cloned) with a function in <a>GHC.Stack.CloneStack</a>. Please check
--   the documentation in that module for more detailed explanations.
data StackSnapshot# :: UnliftedType

-- | <a>State#</a> is the primitive, unlifted type of states. It has one
--   type parameter, thus <tt><a>State#</a> <a>RealWorld</a></tt>, or
--   <tt><a>State#</a> s</tt>, where s is a type variable. The only purpose
--   of the type parameter is to keep different state threads separate. It
--   is represented by nothing at all.
data State# a :: ZeroBitType
data TVar# a (b :: TYPE 'BoxedRep l) :: UnliftedType
data TYPE (a :: RuntimeRep)

-- | (In a non-concurrent implementation, this can be a singleton type,
--   whose (unique) value is returned by <a>myThreadId#</a>. The other
--   operations can be omitted.)
data ThreadId# :: UnliftedType
data Weak# (a :: TYPE 'BoxedRep l) :: UnliftedType
data Word# :: TYPE 'WordRep
data Word16# :: TYPE 'Word16Rep
data Word16X16# :: TYPE 'VecRep 'Vec16 'Word16ElemRep
data Word16X32# :: TYPE 'VecRep 'Vec32 'Word16ElemRep
data Word16X8# :: TYPE 'VecRep 'Vec8 'Word16ElemRep
data Word32# :: TYPE 'Word32Rep
data Word32X16# :: TYPE 'VecRep 'Vec16 'Word32ElemRep
data Word32X4# :: TYPE 'VecRep 'Vec4 'Word32ElemRep
data Word32X8# :: TYPE 'VecRep 'Vec8 'Word32ElemRep
data Word64# :: TYPE 'Word64Rep
data Word64X2# :: TYPE 'VecRep 'Vec2 'Word64ElemRep
data Word64X4# :: TYPE 'VecRep 'Vec4 'Word64ElemRep
data Word64X8# :: TYPE 'VecRep 'Vec8 'Word64ElemRep
data Word8# :: TYPE 'Word8Rep
data Word8X16# :: TYPE 'VecRep 'Vec16 'Word8ElemRep
data Word8X32# :: TYPE 'VecRep 'Vec32 'Word8ElemRep
data Word8X64# :: TYPE 'VecRep 'Vec64 'Word8ElemRep
instance GHC.Internal.Base.Alternative GHC.Types.IO
instance GHC.Internal.Base.Alternative []
instance GHC.Internal.Base.Alternative GHC.Internal.Maybe.Maybe
instance GHC.Internal.Base.Applicative ((->) r)
instance GHC.Internal.Base.Applicative GHC.Types.IO
instance GHC.Internal.Base.Applicative []
instance GHC.Internal.Base.Applicative GHC.Internal.Maybe.Maybe
instance GHC.Internal.Base.Applicative GHC.Internal.Base.NonEmpty
instance GHC.Internal.Base.Applicative GHC.Tuple.Solo
instance GHC.Internal.Base.Monoid a => GHC.Internal.Base.Applicative ((,) a)
instance (GHC.Internal.Base.Monoid a, GHC.Internal.Base.Monoid b) => GHC.Internal.Base.Applicative ((,,) a b)
instance (GHC.Internal.Base.Monoid a, GHC.Internal.Base.Monoid b, GHC.Internal.Base.Monoid c) => GHC.Internal.Base.Applicative ((,,,) a b c)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Internal.Base.NonEmpty a)
instance GHC.Classes.Eq GHC.Internal.Base.Void
instance GHC.Internal.Base.Functor ((->) r)
instance GHC.Internal.Base.Functor GHC.Types.IO
instance GHC.Internal.Base.Functor []
instance GHC.Internal.Base.Functor GHC.Internal.Maybe.Maybe
instance GHC.Internal.Base.Functor GHC.Internal.Base.NonEmpty
instance GHC.Internal.Base.Functor GHC.Tuple.Solo
instance GHC.Internal.Base.Functor ((,) a)
instance GHC.Internal.Base.Functor ((,,) a b)
instance GHC.Internal.Base.Functor ((,,,) a b c)
instance GHC.Internal.Base.Functor ((,,,,) a b c d)
instance GHC.Internal.Base.Functor ((,,,,,) a b c d e)
instance GHC.Internal.Base.Functor ((,,,,,,) a b c d e f)
instance GHC.Internal.Base.MonadPlus GHC.Types.IO
instance GHC.Internal.Base.MonadPlus []
instance GHC.Internal.Base.MonadPlus GHC.Internal.Maybe.Maybe
instance GHC.Internal.Base.Monad ((->) r)
instance GHC.Internal.Base.Monad GHC.Types.IO
instance GHC.Internal.Base.Monad []
instance GHC.Internal.Base.Monad GHC.Internal.Maybe.Maybe
instance GHC.Internal.Base.Monad GHC.Internal.Base.NonEmpty
instance GHC.Internal.Base.Monad GHC.Tuple.Solo
instance GHC.Internal.Base.Monoid a => GHC.Internal.Base.Monad ((,) a)
instance (GHC.Internal.Base.Monoid a, GHC.Internal.Base.Monoid b) => GHC.Internal.Base.Monad ((,,) a b)
instance (GHC.Internal.Base.Monoid a, GHC.Internal.Base.Monoid b, GHC.Internal.Base.Monoid c) => GHC.Internal.Base.Monad ((,,,) a b c)
instance GHC.Internal.Base.Monoid b => GHC.Internal.Base.Monoid (a -> b)
instance GHC.Internal.Base.Monoid a => GHC.Internal.Base.Monoid (GHC.Types.IO a)
instance GHC.Internal.Base.Monoid [a]
instance GHC.Internal.Base.Semigroup a => GHC.Internal.Base.Monoid (GHC.Internal.Maybe.Maybe a)
instance GHC.Internal.Base.Monoid GHC.Types.Ordering
instance GHC.Internal.Base.Monoid a => GHC.Internal.Base.Monoid (GHC.Tuple.Solo a)
instance (GHC.Internal.Base.Monoid a, GHC.Internal.Base.Monoid b) => GHC.Internal.Base.Monoid (a, b)
instance (GHC.Internal.Base.Monoid a, GHC.Internal.Base.Monoid b, GHC.Internal.Base.Monoid c) => GHC.Internal.Base.Monoid (a, b, c)
instance (GHC.Internal.Base.Monoid a, GHC.Internal.Base.Monoid b, GHC.Internal.Base.Monoid c, GHC.Internal.Base.Monoid d) => GHC.Internal.Base.Monoid (a, b, c, d)
instance (GHC.Internal.Base.Monoid a, GHC.Internal.Base.Monoid b, GHC.Internal.Base.Monoid c, GHC.Internal.Base.Monoid d, GHC.Internal.Base.Monoid e) => GHC.Internal.Base.Monoid (a, b, c, d, e)
instance GHC.Internal.Base.Monoid ()
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Internal.Base.NonEmpty a)
instance GHC.Classes.Ord GHC.Internal.Base.Void
instance GHC.Internal.Base.Semigroup b => GHC.Internal.Base.Semigroup (a -> b)
instance GHC.Internal.Base.Semigroup a => GHC.Internal.Base.Semigroup (GHC.Types.IO a)
instance GHC.Internal.Base.Semigroup [a]
instance GHC.Internal.Base.Semigroup a => GHC.Internal.Base.Semigroup (GHC.Internal.Maybe.Maybe a)
instance GHC.Internal.Base.Semigroup (GHC.Internal.Base.NonEmpty a)
instance GHC.Internal.Base.Semigroup GHC.Types.Ordering
instance GHC.Internal.Base.Semigroup a => GHC.Internal.Base.Semigroup (GHC.Tuple.Solo a)
instance (GHC.Internal.Base.Semigroup a, GHC.Internal.Base.Semigroup b) => GHC.Internal.Base.Semigroup (a, b)
instance (GHC.Internal.Base.Semigroup a, GHC.Internal.Base.Semigroup b, GHC.Internal.Base.Semigroup c) => GHC.Internal.Base.Semigroup (a, b, c)
instance (GHC.Internal.Base.Semigroup a, GHC.Internal.Base.Semigroup b, GHC.Internal.Base.Semigroup c, GHC.Internal.Base.Semigroup d) => GHC.Internal.Base.Semigroup (a, b, c, d)
instance (GHC.Internal.Base.Semigroup a, GHC.Internal.Base.Semigroup b, GHC.Internal.Base.Semigroup c, GHC.Internal.Base.Semigroup d, GHC.Internal.Base.Semigroup e) => GHC.Internal.Base.Semigroup (a, b, c, d, e)
instance GHC.Internal.Base.Semigroup ()
instance GHC.Internal.Base.Semigroup GHC.Internal.Base.Void


module GHC.Internal.Profiling

-- | Start attributing ticks to cost centres. This is called by the RTS on
--   startup but can be disabled using the rts flag
--   <tt>--no-automatic-time-samples</tt>.
startProfTimer :: IO ()

-- | Stop attributing ticks to cost centres. Allocations will still be
--   attributed.
stopProfTimer :: IO ()

-- | Start heap profiling. This is called normally by the RTS on start-up,
--   but can be disabled using the rts flag
--   <tt>--no-automatic-heap-samples</tt>.
--   
--   Note: This won't do anything unless you also specify a profiling mode
--   on the command line using the normal RTS options.
startHeapProfTimer :: IO ()

-- | Stop heap profiling.
--   
--   Note: This won't do anything unless you also specify a profiling mode
--   on the command line using the normal RTS options.
stopHeapProfTimer :: IO ()

-- | Request a heap census on the next context switch. The census can be
--   requested whether or not the heap profiling timer is running.
--   
--   Note: This won't do anything unless you also specify a profiling mode
--   on the command line using the normal RTS options.
requestHeapCensus :: IO ()


-- | This module defines the <a>IsLabel</a> class used by the
--   <tt>OverloadedLabels</tt> extension. See the <a>wiki page</a> for more
--   details.
--   
--   When <tt>OverloadedLabels</tt> is enabled, if GHC sees an occurrence
--   of the overloaded label syntax <tt>#foo</tt>, it is replaced with
--   
--   <pre>
--   fromLabel @"foo" :: alpha
--   </pre>
--   
--   plus a wanted constraint <tt>IsLabel "foo" alpha</tt>.
--   
--   Note that if <tt>RebindableSyntax</tt> is enabled, the desugaring of
--   overloaded label syntax will make use of whatever <tt>fromLabel</tt>
--   is in scope.
module GHC.Internal.OverloadedLabels
class IsLabel (x :: Symbol) a
fromLabel :: IsLabel x a => a


-- | The <a>Num</a> class and the <a>Integer</a> type.
module GHC.Internal.Num

-- | Basic numeric class.
--   
--   The Haskell Report defines no laws for <a>Num</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a ring and have the following properties:
--   
--   <ul>
--   <li><i><b>Associativity of <tt>(<a>+</a>)</tt></b></i> <tt>(x + y) +
--   z</tt> = <tt>x + (y + z)</tt></li>
--   <li><i><b>Commutativity of <tt>(<a>+</a>)</tt></b></i> <tt>x + y</tt>
--   = <tt>y + x</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 0</tt> is the additive
--   identity</b></i> <tt>x + fromInteger 0</tt> = <tt>x</tt></li>
--   <li><i><b><a>negate</a> gives the additive inverse</b></i> <tt>x +
--   negate x</tt> = <tt>fromInteger 0</tt></li>
--   <li><i><b>Associativity of <tt>(<a>*</a>)</tt></b></i> <tt>(x * y) *
--   z</tt> = <tt>x * (y * z)</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 1</tt> is the multiplicative
--   identity</b></i> <tt>x * fromInteger 1</tt> = <tt>x</tt> and
--   <tt>fromInteger 1 * x</tt> = <tt>x</tt></li>
--   <li><i><b>Distributivity of <tt>(<a>*</a>)</tt> with respect to
--   <tt>(<a>+</a>)</tt></b></i> <tt>a * (b + c)</tt> = <tt>(a * b) + (a *
--   c)</tt> and <tt>(b + c) * a</tt> = <tt>(b * a) + (c * a)</tt></li>
--   <li><i><b>Coherence with <tt>toInteger</tt></b></i> if the type also
--   implements <a>Integral</a>, then <a>fromInteger</a> is a left inverse
--   for <a>toInteger</a>, i.e. <tt>fromInteger (toInteger i) ==
--   i</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   both <a>Num</a> and <a>Ord</a> implement an ordered ring. Indeed, in
--   <tt>base</tt> only <a>Integer</a> and <a>Rational</a> do.
class Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a
infixl 6 -
infixl 6 +
infixl 7 *

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: Num a => a -> a -> a

-- | <i>Deprecated: Use integerQuotRem# instead</i>
quotRemInteger :: Integer -> Integer -> (# Integer, Integer #)

-- | Natural number
--   
--   Invariant: numbers &lt;= 0xffffffffffffffff use the <a>NS</a>
--   constructor
data Natural

-- | Arbitrary precision integers. In contrast with fixed-size integral
--   types such as <a>Int</a>, the <a>Integer</a> type represents the
--   entire infinite range of integers.
--   
--   Integers are stored in a kind of sign-magnitude form, hence do not
--   expect two's complement form when using bit operations.
--   
--   If the value is small (i.e., fits into an <a>Int</a>), the <a>IS</a>
--   constructor is used. Otherwise <a>IP</a> and <a>IN</a> constructors
--   are used to store a <a>BigNat</a> representing the positive or the
--   negative value magnitude, respectively.
--   
--   Invariant: <a>IP</a> and <a>IN</a> are used iff the value does not fit
--   in <a>IS</a>.
data Integer
instance GHC.Internal.Num.Num GHC.Types.Int
instance GHC.Internal.Num.Num GHC.Num.Integer.Integer
instance GHC.Internal.Num.Num GHC.Num.Natural.Natural
instance GHC.Internal.Num.Num GHC.Types.Word


-- | Unsafe IO operations
module GHC.Internal.IO.Unsafe

-- | This is the "back door" into the <a>IO</a> monad, allowing <a>IO</a>
--   computation to be performed at any time. For this to be safe, the
--   <a>IO</a> computation should be free of side effects and independent
--   of its environment.
--   
--   If the I/O computation wrapped in <a>unsafePerformIO</a> performs side
--   effects, then the relative order in which those side effects take
--   place (relative to the main I/O trunk, or other calls to
--   <a>unsafePerformIO</a>) is indeterminate. Furthermore, when using
--   <a>unsafePerformIO</a> to cause side-effects, you should take the
--   following precautions to ensure the side effects are performed as many
--   times as you expect them to be. Note that these precautions are
--   necessary for GHC, but may not be sufficient, and other compilers may
--   require different precautions:
--   
--   <ul>
--   <li>Use <tt>{-# NOINLINE foo #-}</tt> as a pragma on any function
--   <tt>foo</tt> that calls <a>unsafePerformIO</a>. If the call is
--   inlined, the I/O may be performed more than once.</li>
--   <li>Use the compiler flag <tt>-fno-cse</tt> to prevent common
--   sub-expression elimination being performed on the module, which might
--   combine two side effects that were meant to be separate. A good
--   example is using multiple global variables (like <tt>test</tt> in the
--   example below).</li>
--   <li>Make sure that the either you switch off let-floating
--   (<tt>-fno-full-laziness</tt>), or that the call to
--   <a>unsafePerformIO</a> cannot float outside a lambda. For example, if
--   you say: <tt> f x = unsafePerformIO (newIORef []) </tt> you may get
--   only one reference cell shared between all calls to <tt>f</tt>. Better
--   would be <tt> f x = unsafePerformIO (newIORef [x]) </tt> because now
--   it can't float outside the lambda.</li>
--   </ul>
--   
--   It is less well known that <a>unsafePerformIO</a> is not type safe.
--   For example:
--   
--   <pre>
--   test :: IORef [a]
--   test = unsafePerformIO $ newIORef []
--   
--   main = do
--           writeIORef test [42]
--           bang &lt;- readIORef test
--           print (bang :: [Char])
--   </pre>
--   
--   This program will core dump. This problem with polymorphic references
--   is well known in the ML community, and does not arise with normal
--   monadic use of references. There is no easy way to make it impossible
--   once you use <a>unsafePerformIO</a>. Indeed, it is possible to write
--   <tt>coerce :: a -&gt; b</tt> with the help of <a>unsafePerformIO</a>.
--   So be careful!
--   
--   WARNING: If you're looking for "a way to get a <a>String</a> from an
--   'IO String'", then <a>unsafePerformIO</a> is not the way to go. Learn
--   about do-notation and the <tt>&lt;-</tt> syntax element before you
--   proceed.
unsafePerformIO :: IO a -> a

-- | <a>unsafeInterleaveIO</a> allows an <a>IO</a> computation to be
--   deferred lazily. When passed a value of type <tt>IO a</tt>, the
--   <a>IO</a> will only be performed when the value of the <tt>a</tt> is
--   demanded. This is used to implement lazy file reading, see
--   <a>hGetContents</a>.
unsafeInterleaveIO :: IO a -> IO a

-- | This version of <a>unsafePerformIO</a> is more efficient because it
--   omits the check that the IO is only being performed by a single
--   thread. Hence, when you use <a>unsafeDupablePerformIO</a>, there is a
--   possibility that the IO action may be performed multiple times (on a
--   multiprocessor), and you should therefore ensure that it gives the
--   same results each time. It may even happen that one of the duplicated
--   IO actions is only run partially, and then interrupted in the middle
--   without an exception being raised. Therefore, functions like
--   <a>bracket</a> cannot be used safely within
--   <a>unsafeDupablePerformIO</a>.
unsafeDupablePerformIO :: IO a -> a

-- | <a>unsafeDupableInterleaveIO</a> allows an <a>IO</a> computation to be
--   deferred lazily. When passed a value of type <tt>IO a</tt>, the
--   <a>IO</a> will only be performed when the value of the <tt>a</tt> is
--   demanded.
--   
--   The computation may be performed multiple times by different threads,
--   possibly at the same time. To ensure that the computation is performed
--   only once, use <a>unsafeInterleaveIO</a> instead.
unsafeDupableInterleaveIO :: IO a -> IO a

-- | Ensures that the suspensions under evaluation by the current thread
--   are unique; that is, the current thread is not evaluating anything
--   that is also under evaluation by another thread that has also executed
--   <a>noDuplicate</a>.
--   
--   This operation is used in the definition of <a>unsafePerformIO</a> to
--   prevent the IO action from being executed multiple times, which is
--   usually undesirable.
noDuplicate :: IO ()


-- | The GHCi Monad lifting interface.
--   
--   EXPERIMENTAL! DON'T USE.
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.GHCi

-- | A monad that can execute GHCi statements by lifting them out of m into
--   the IO monad. (e.g state monads)
class Monad m => GHCiSandboxIO (m :: Type -> Type)
ghciStepIO :: GHCiSandboxIO m => m a -> IO a

-- | A monad that doesn't allow any IO.
data NoIO a
instance GHC.Internal.Base.Applicative GHC.Internal.GHCi.NoIO
instance GHC.Internal.Base.Functor GHC.Internal.GHCi.NoIO
instance GHC.Internal.GHCi.GHCiSandboxIO GHC.Types.IO
instance GHC.Internal.GHCi.GHCiSandboxIO GHC.Internal.GHCi.NoIO
instance GHC.Internal.Base.Monad GHC.Internal.GHCi.NoIO


-- | Methods for the RealFrac instances for <a>Float</a> and <a>Double</a>,
--   with specialised versions for <a>Int</a>.
--   
--   Moved to their own module to not bloat <a>GHC.Float</a> further.
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.Float.RealFracMethods
properFractionDoubleInteger :: Double -> (Integer, Double)
truncateDoubleInteger :: Double -> Integer
floorDoubleInteger :: Double -> Integer
ceilingDoubleInteger :: Double -> Integer
roundDoubleInteger :: Double -> Integer
properFractionDoubleInt :: Double -> (Int, Double)
floorDoubleInt :: Double -> Int
ceilingDoubleInt :: Double -> Int
roundDoubleInt :: Double -> Int
double2Int :: Double -> Int
int2Double :: Int -> Double
properFractionFloatInteger :: Float -> (Integer, Float)
truncateFloatInteger :: Float -> Integer
floorFloatInteger :: Float -> Integer
ceilingFloatInteger :: Float -> Integer
roundFloatInteger :: Float -> Integer
properFractionFloatInt :: Float -> (Int, Float)
floorFloatInt :: Float -> Int
ceilingFloatInt :: Float -> Int
roundFloatInt :: Float -> Int
float2Int :: Float -> Int
int2Float :: Int -> Float


-- | Utilities for conversion between Double/Float and Rational
module GHC.Internal.Float.ConversionUtils
elimZerosInteger :: Integer -> Int# -> (# Integer, Int# #)
elimZerosInt# :: Int# -> Int# -> (# Integer, Int# #)


-- | A logically uninhabited data type, used to indicate that a given term
--   should not exist.
module GHC.Internal.Data.Void

-- | Uninhabited data type
data Void

-- | Since <a>Void</a> values logically don't exist, this witnesses the
--   logical reasoning tool of "ex falso quodlibet".
--   
--   <pre>
--   &gt;&gt;&gt; let x :: Either Void Int; x = Right 5
--   
--   &gt;&gt;&gt; :{
--   case x of
--       Right r -&gt; r
--       Left l  -&gt; absurd l
--   :}
--   5
--   </pre>
absurd :: Void -> a

-- | If <a>Void</a> is uninhabited then any <a>Functor</a> that holds only
--   values of type <a>Void</a> is holding no values. It is implemented in
--   terms of <tt>fmap absurd</tt>.
vacuous :: Functor f => f Void -> f a


-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt>, lets you apply any
--   function of type <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Just 1)  --  (a   -&gt; b)      -&gt; f a       -&gt; f b
--   Just "1"                --  (Int -&gt; String) -&gt; Maybe Int -&gt; Maybe String
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing   --  (a   -&gt; b)      -&gt; f a       -&gt; f b
--   Nothing                 --  (Int -&gt; String) -&gt; Maybe Int -&gt; Maybe String
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fmap show [1,2,3]   --  (a   -&gt; b)      -&gt; f a       -&gt; f b
--   ["1","2","3"]           --  (Int -&gt; String) -&gt; [Int]     -&gt; [String]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fmap show []        --  (a   -&gt; b)      -&gt; f a       -&gt; f b
--   []                      --  (Int -&gt; String) -&gt; [Int]     -&gt; [String]
--   </pre>
--   
--   The <a>fmap</a> function is also available as the infix operator
--   <a>&lt;$&gt;</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Just 1) --  (Int -&gt; String) -&gt; Maybe Int -&gt; Maybe String
--   Just "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; (Just 1)  --  (Int -&gt; String) -&gt; Maybe Int -&gt; Maybe String
--   Just "1"
--   </pre>
module GHC.Internal.Data.Functor

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds. See these articles by <a>School of Haskell</a> or
--   <a>David Luposchainsky</a> for an explanation.
class Functor (f :: Type -> Type)

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with a
--   constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with a constant <a>String</a>, resulting in an
--   <tt><a>Either</a> <a>Int</a> <a>String</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | Generalization of <tt>Data.List.</tt><a>unzip</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unzip (Just ("Hello", "World"))
--   (Just "Hello",Just "World")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unzip [("I", "love"), ("really", "haskell")]
--   (["I","really"],["love","haskell"])
--   </pre>
unzip :: Functor f => f (a, b) -> (f a, f b)

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with unit, resulting in an <tt><a>Either</a>
--   <a>Int</a> <tt>()</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()


-- | Equality
module GHC.Internal.Data.Eq

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, instances
--   are encouraged to follow these properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Extensionality</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=


-- | The <a>Bool</a> type and related functions.
module GHC.Internal.Data.Bool
data Bool
False :: Bool
True :: Bool

-- | Boolean "and", lazy in the second argument
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or", lazy in the second argument
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "not"
not :: Bool -> Bool

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | Case analysis for the <a>Bool</a> type. <tt><a>bool</a> f t p</tt>
--   evaluates to <tt>f</tt> when <tt>p</tt> is <a>False</a>, and evaluates
--   to <tt>t</tt> when <tt>p</tt> is <a>True</a>.
--   
--   This is equivalent to <tt>if p then t else f</tt>; that is, one can
--   think of it as an if-then-else construct with its arguments reordered.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bool "foo" "bar" True
--   "bar"
--   
--   &gt;&gt;&gt; bool "foo" "bar" False
--   "foo"
--   </pre>
--   
--   Confirm that <tt><a>bool</a> f t p</tt> and <tt>if p then t else
--   f</tt> are equivalent:
--   
--   <pre>
--   &gt;&gt;&gt; let p = True; f = "bar"; t = "foo"
--   
--   &gt;&gt;&gt; bool f t p == if p then t else f
--   True
--   
--   &gt;&gt;&gt; let p = False
--   
--   &gt;&gt;&gt; bool f t p == if p then t else f
--   True
--   </pre>
bool :: a -> a -> Bool -> a


-- | Basic operations on type-level Booleans.
module GHC.Internal.Data.Type.Bool

-- | Type-level <a>If</a>. <tt>If True a b</tt> ==&gt; <tt>a</tt>; <tt>If
--   False a b</tt> ==&gt; <tt>b</tt>
type family If (cond :: Bool) (tru :: k) (fls :: k) :: k

-- | Type-level "and"
type family (a :: Bool) && (b :: Bool) :: Bool
infixr 3 &&

-- | Type-level "or"
type family (a :: Bool) || (b :: Bool) :: Bool
infixr 2 ||

-- | Type-level "not". An injective type family since <tt>4.10.0.0</tt>.
type family Not (a :: Bool) = (res :: Bool) | res -> a


-- | Simple combinators working solely on and with functions.
module GHC.Internal.Data.Function

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
--   
--   This function might seem useless at first glance, but it can be very
--   useful in a higher order context.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; length $ filter id [True, True, False, True]
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just (Just 3) &gt;&gt;= id
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr id 0 [(^3), (*5), (+2)]
--   1000
--   </pre>
id :: a -> a

-- | <tt>const x y</tt> always evaluates to <tt>x</tt>, ignoring its second
--   argument.
--   
--   <pre>
--   const x = \_ -&gt; x
--   </pre>
--   
--   This function might seem useless at first glance, but it can be very
--   useful in a higher order context.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | Right to left function composition.
--   
--   <pre>
--   (f . g) x = f (g x)
--   </pre>
--   
--   <pre>
--   f . id = f = id . f
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; map ((*2) . length) [[], [0, 1, 2], [0]]
--   [0,6,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (.) id [(+1), (*3), (^3)] 2
--   25
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let (...) = (.).(.) in ((*2)...(+)) 5 10
--   30
--   </pre>
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   flip f x y = f y x
--   </pre>
--   
--   <pre>
--   flip . flip = id
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let (.&gt;) = flip (.) in (+1) .&gt; show $ 5
--   "6"
--   </pre>
flip :: forall (repc :: RuntimeRep) a b (c :: TYPE repc). (a -> b -> c) -> b -> a -> c

-- | <tt><a>($)</a></tt> is the <b>function application</b> operator.
--   
--   Applying <tt><a>($)</a></tt> to a function <tt>f</tt> and an argument
--   <tt>x</tt> gives the same result as applying <tt>f</tt> to <tt>x</tt>
--   directly. The definition is akin to this:
--   
--   <pre>
--   ($) :: (a -&gt; b) -&gt; a -&gt; b
--   ($) f x = f x
--   </pre>
--   
--   This is <tt><a>id</a></tt> specialized from <tt>a -&gt; a</tt> to
--   <tt>(a -&gt; b) -&gt; (a -&gt; b)</tt> which by the associativity of
--   <tt>(-&gt;)</tt> is the same as <tt>(a -&gt; b) -&gt; a -&gt; b</tt>.
--   
--   On the face of it, this may appear pointless! But it's actually one of
--   the most useful and important operators in Haskell.
--   
--   The order of operations is very different between <tt>($)</tt> and
--   normal function application. Normal function application has
--   precedence 10 - higher than any operator - and associates to the left.
--   So these two definitions are equivalent:
--   
--   <pre>
--   expr = min 5 1 + 5
--   expr = ((min 5) 1) + 5
--   </pre>
--   
--   <tt>($)</tt> has precedence 0 (the lowest) and associates to the
--   right, so these are equivalent:
--   
--   <pre>
--   expr = min 5 $ 1 + 5
--   expr = (min 5) (1 + 5)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use cases of <tt>($)</tt> is to avoid parentheses in complex
--   expressions.
--   
--   For example, instead of using nested parentheses in the following
--   Haskell function:
--   
--   <pre>
--   -- | Sum numbers in a string: strSum "100  5 -7" == 98
--   strSum :: <a>String</a> -&gt; <a>Int</a>
--   strSum s = <tt>sum</tt> (<a>mapMaybe</a> <a>readMaybe</a> (<tt>words</tt> s))
--   </pre>
--   
--   we can deploy the function application operator:
--   
--   <pre>
--   -- | Sum numbers in a string: strSum "100  5 -7" == 98
--   strSum :: <a>String</a> -&gt; <a>Int</a>
--   strSum s = <tt>sum</tt> <a>$</a> <a>mapMaybe</a> <a>readMaybe</a> <a>$</a> <tt>words</tt> s
--   </pre>
--   
--   <tt>($)</tt> is also used as a section (a partially applied operator),
--   in order to indicate that we wish to apply some yet-unspecified
--   function to a given value. For example, to apply the argument
--   <tt>5</tt> to a list of functions:
--   
--   <pre>
--   applyFive :: [Int]
--   applyFive = map ($ 5) [(+1), (2^)]
--   &gt;&gt;&gt; [6, 32]
--   </pre>
--   
--   <h4><b>Technical Remark (Representation Polymorphism)</b></h4>
--   
--   <tt>($)</tt> is fully representation-polymorphic. This allows it to
--   also be used with arguments of unlifted and even unboxed kinds, such
--   as unboxed integers:
--   
--   <pre>
--   fastMod :: Int -&gt; Int -&gt; Int
--   fastMod (I# x) (I# m) = I# $ remInt# x m
--   </pre>
($) :: forall (repa :: RuntimeRep) (repb :: RuntimeRep) (a :: TYPE repa) (b :: TYPE repb). (a -> b) -> a -> b
infixr 0 $

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   This is a version of <tt><a>flip</a> <a>id</a></tt>, where <a>id</a>
--   is specialized from <tt>a -&gt; a</tt> to <tt>(a -&gt; b) -&gt; (a
--   -&gt; b)</tt> which by the associativity of <tt>(-&gt;)</tt> is <tt>(a
--   -&gt; b) -&gt; a -&gt; b</tt>. flipping this yields <tt>a -&gt; (a
--   -&gt; b) -&gt; b</tt> which is the type signature of <a>&amp;</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sqrt $ [1 / n^2 | n &lt;- [1..1000]] &amp; sum &amp; (*6)
--   3.1406380562059946
--   </pre>
(&) :: forall (r :: RuntimeRep) a (b :: TYPE r). a -> (a -> b) -> b
infixl 1 &

-- | <tt><a>fix</a> f</tt> is the least fixed point of the function
--   <tt>f</tt>, i.e. the least defined <tt>x</tt> such that <tt>f x =
--   x</tt>.
--   
--   When <tt>f</tt> is strict, this means that because, by the definition
--   of strictness, <tt>f ⊥ = ⊥</tt> and such the least defined fixed point
--   of any strict function is <tt>⊥</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We can write the factorial function using direct recursion as
--   
--   <pre>
--   &gt;&gt;&gt; let fac n = if n &lt;= 1 then 1 else n * fac (n-1) in fac 5
--   120
--   </pre>
--   
--   This uses the fact that Haskell’s <tt>let</tt> introduces recursive
--   bindings. We can rewrite this definition using <a>fix</a>,
--   
--   Instead of making a recursive call, we introduce a dummy parameter
--   <tt>rec</tt>; when used within <a>fix</a>, this parameter then refers
--   to <a>fix</a>’s argument, hence the recursion is reintroduced.
--   
--   <pre>
--   &gt;&gt;&gt; fix (\rec n -&gt; if n &lt;= 1 then 1 else n * rec (n-1)) 5
--   120
--   </pre>
--   
--   Using <a>fix</a>, we can implement versions of <a>repeat</a> as
--   <tt><a>fix</a> <a>.</a> <tt>(:)</tt></tt> and <a>cycle</a> as
--   <tt><a>fix</a> <a>.</a> <tt>(++)</tt></tt>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ fix (0:)
--   [0,0,0,0,0,0,0,0,0,0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (fix (\rec n -&gt; if n &lt; 2 then n else rec (n - 1) + rec (n - 2))) [1..10]
--   [1,1,2,3,5,8,13,21,34,55]
--   </pre>
--   
--   <h4><b>Implementation Details</b></h4>
--   
--   The current implementation of <a>fix</a> uses structural sharing
--   
--   <pre>
--   <a>fix</a> f = let x = f x in x
--   </pre>
--   
--   A more straightforward but non-sharing version would look like
--   
--   <pre>
--   <a>fix</a> f = f (<a>fix</a> f)
--   </pre>
fix :: (a -> a) -> a

-- | <tt><a>on</a> b u x y</tt> runs the binary function <tt>b</tt>
--   <i>on</i> the results of applying unary function <tt>u</tt> to two
--   arguments <tt>x</tt> and <tt>y</tt>. From the opposite perspective, it
--   transforms two inputs and combines the outputs.
--   
--   <pre>
--   (op `<a>on</a>` f) x y = f x `<tt>op</tt>` f y
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sortBy (compare `on` length) [[0, 1, 2], [0, 1], [], [0]]
--   [[],[0],[0,1],[0,1,2]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ((+) `on` length) [1, 2, 3] [-1]
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ((,) `on` (*2)) 2 3
--   (4,6)
--   </pre>
--   
--   <h4><b>Algebraic properties</b></h4>
--   
--   <ul>
--   <li><pre>(*) `on` <a>id</a> = (*) -- (if (*) ∉ {⊥, <a>const</a>
--   ⊥})</pre></li>
--   </ul>
--   
--   <ul>
--   <li><pre>((*) `on` f) `on` g = (*) `on` (f . g)</pre></li>
--   <li><pre><a>flip</a> on f . <a>flip</a> on g = <a>flip</a> on (g .
--   f)</pre></li>
--   </ul>
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
infixl 0 `on`

-- | <a>applyWhen</a> applies a function to a value if a condition is true,
--   otherwise, it returns the value unchanged.
--   
--   It is equivalent to <tt><a>flip</a> (<a>bool</a> <a>id</a>)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; map (\x -&gt; applyWhen (odd x) (*2) x) [1..10]
--   [2,2,6,4,10,6,14,8,18,10]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (\x -&gt; applyWhen (length x &gt; 6) ((++ "...") . take 3) x) ["Hi!", "This is amazing", "Hope you're doing well today!", ":D"]
--   ["Hi!","Thi...","Hop...",":D"]
--   </pre>
--   
--   <h4><b>Algebraic properties</b></h4>
--   
--   <ul>
--   <li><pre>applyWhen <a>True</a> = <a>id</a></pre></li>
--   </ul>
--   
--   <ul>
--   <li><pre>applyWhen <a>False</a> f = <a>id</a></pre></li>
--   </ul>
applyWhen :: Bool -> (a -> a) -> a -> a


-- | Class of monads based on <tt>IO</tt>.
module GHC.Internal.Control.Monad.IO.Class

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad. This allows us to run IO
--   computations in any monadic stack, so long as it supports these kinds
--   of operations (i.e. <a>IO</a> is the base monad for the stack).
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   import Control.Monad.Trans.State -- from the "transformers" library
--   
--   printState :: Show s =&gt; StateT s IO ()
--   printState = do
--     state &lt;- get
--     liftIO $ print state
--   </pre>
--   
--   Had we omitted <tt><a>liftIO</a></tt>, we would have ended up with
--   this error:
--   
--   <pre>
--   • Couldn't match type ‘IO’ with ‘StateT s IO’
--    Expected type: StateT s IO ()
--      Actual type: IO ()
--   </pre>
--   
--   The important part here is the mismatch between <tt>StateT s IO
--   ()</tt> and <tt><a>IO</a> ()</tt>.
--   
--   Luckily, we know of a function that takes an <tt><a>IO</a> a</tt> and
--   returns an <tt>(m a)</tt>: <tt><a>liftIO</a></tt>, enabling us to run
--   the program and see the expected results:
--   
--   <pre>
--   &gt; evalStateT printState "hello"
--   "hello"
--   
--   &gt; evalStateT printState 3
--   3
--   </pre>
liftIO :: MonadIO m => IO a -> m a
instance GHC.Internal.Control.Monad.IO.Class.MonadIO GHC.Types.IO


module GHC.Internal.Control.Monad.Fail

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
--   
--   <tt>fail s</tt> should be an action that runs in the monad itself, not
--   an exception (except in instances of <tt>MonadIO</tt>). In particular,
--   <tt>fail</tt> should not be implemented in terms of <tt>error</tt>.
class Monad m => MonadFail (m :: Type -> Type)
fail :: MonadFail m => String -> m a
instance GHC.Internal.Control.Monad.Fail.MonadFail GHC.Types.IO
instance GHC.Internal.Control.Monad.Fail.MonadFail []
instance GHC.Internal.Control.Monad.Fail.MonadFail GHC.Internal.Maybe.Maybe


-- | The Maybe type, and associated operations.
module GHC.Internal.Data.Maybe

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import GHC.Internal.Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: Maybe a -> Bool

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just ())
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just Nothing)
--   False
--   </pre>
isNothing :: Maybe a -> Bool

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromJust (Just 1)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust (Just 10))
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust Nothing)
--   *** Exception: Maybe.fromJust: Nothing
--   ...
--   </pre>
--   
--   WARNING: This function is partial. You can use case-matching instead.
fromJust :: HasCallStack => Maybe a -> a

-- | The <a>fromMaybe</a> function takes a default value and a <a>Maybe</a>
--   value. If the <a>Maybe</a> is <a>Nothing</a>, it returns the default
--   value; otherwise, it returns the value contained in the <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import GHC.Internal.Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: a -> Maybe a -> a

-- | The <a>listToMaybe</a> function returns <a>Nothing</a> on an empty
--   list or <tt><a>Just</a> a</tt> where <tt>a</tt> is the first element
--   of the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [9]
--   Just 9
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [1,2,3]
--   Just 1
--   </pre>
--   
--   Composing <a>maybeToList</a> with <a>listToMaybe</a> should be the
--   identity on singleton/empty lists:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [5]
--   [5]
--   
--   &gt;&gt;&gt; maybeToList $ listToMaybe []
--   []
--   </pre>
--   
--   But not on lists with more than one element:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [1,2,3]
--   [1]
--   </pre>
listToMaybe :: [a] -> Maybe a

-- | The <a>maybeToList</a> function returns an empty list when given
--   <a>Nothing</a> or a singleton list when given <a>Just</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList (Just 7)
--   [7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList Nothing
--   []
--   </pre>
--   
--   One can use <a>maybeToList</a> to avoid pattern matching when combined
--   with a function that (safely) works on lists:
--   
--   <pre>
--   &gt;&gt;&gt; import GHC.Internal.Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "3")
--   3
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "")
--   0
--   </pre>
maybeToList :: Maybe a -> [a]

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import GHC.Internal.Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: [Maybe a] -> [a]

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import GHC.Internal.Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: (a -> Maybe b) -> [a] -> [b]


-- | The List data type and its operations
module GHC.Internal.List

-- | The builtin linked list type.
--   
--   In Haskell, lists are one of the most important data types as they are
--   often used analogous to loops in imperative programming languages.
--   These lists are singly linked, which makes them unsuited for
--   operations that require &lt;math&gt; access. Instead, they are
--   intended to be traversed.
--   
--   You can use <tt>List a</tt> or <tt>[a]</tt> in type signatures:
--   
--   <pre>
--   length :: [a] -&gt; Int
--   </pre>
--   
--   or
--   
--   <pre>
--   length :: List a -&gt; Int
--   </pre>
--   
--   They are fully equivalent, and <tt>List a</tt> will be normalised to
--   <tt>[a]</tt>.
--   
--   <h4>Usage</h4>
--   
--   Lists are constructed recursively using the right-associative
--   constructor operator (or <i>cons</i>) <tt>(:) :: a -&gt; [a] -&gt;
--   [a]</tt>, which prepends an element to a list, and the empty list
--   <tt>[]</tt>.
--   
--   <pre>
--   (1 : 2 : 3 : []) == (1 : (2 : (3 : []))) == [1, 2, 3]
--   </pre>
--   
--   Lists can also be constructed using list literals of the form
--   <tt>[x_1, x_2, ..., x_n]</tt> which are syntactic sugar and, unless
--   <tt>-XOverloadedLists</tt> is enabled, are translated into uses of
--   <tt>(:)</tt> and <tt>[]</tt>
--   
--   <a>String</a> literals, like <tt>"I 💜 hs"</tt>, are translated into
--   Lists of characters, <tt>['I', ' ', '💜', ' ', 'h', 's']</tt>.
--   
--   <h4><b>Implementation</b></h4>
--   
--   Internally and in memory, all the above are represented like this,
--   with arrows being pointers to locations in memory.
--   
--   <pre>
--   ╭───┬───┬──╮   ╭───┬───┬──╮   ╭───┬───┬──╮   ╭────╮
--   │(:)│   │ ─┼──&gt;│(:)│   │ ─┼──&gt;│(:)│   │ ─┼──&gt;│ [] │
--   ╰───┴─┼─┴──╯   ╰───┴─┼─┴──╯   ╰───┴─┼─┴──╯   ╰────╯
--         v              v              v
--         1              2              3
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; ['H', 'a', 's', 'k', 'e', 'l', 'l']
--   "Haskell"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 : [4, 1, 5, 9]
--   [1,4,1,5,9]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] : [] : []
--   [[],[]]
--   </pre>
data [] a

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a list, reduces
--   the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
foldr :: (a -> b -> b) -> b -> [a] -> b

-- | <a>foldr'</a> is a variant of <a>foldr</a> that begins list reduction
--   from the last element and evaluates the accumulator strictly as it
--   unwinds the stack back to the beginning of the list. The input list
--   <i>must</i> be finite, otherwise <a>foldr'</a> runs out of space
--   (<i>diverges</i>).
--   
--   Note that if the function that combines the accumulated value with
--   each element is strict in the accumulator, other than a possible
--   improvement in the constant factor, you get the same &lt;math&gt;
--   space cost as with just <a>foldr</a>.
--   
--   If you want a strict right fold in constant space, you need a
--   structure that supports faster than &lt;math&gt; access to the
--   right-most element, such as <tt>Seq</tt> from the <tt>containers</tt>
--   package.
--   
--   Use of this function is a hint that the <tt>[]</tt> structure may be a
--   poor fit for the task at hand. If the order in which the elements are
--   combined is not important, use <a>foldl'</a> instead.
--   
--   <pre>
--   &gt;&gt;&gt; foldr' (+) [1..4]  -- Use foldl' instead!
--   10
--   
--   &gt;&gt;&gt; foldr' (&amp;&amp;) [True, False, True, True] -- Use foldr instead!
--   False
--   
--   &gt;&gt;&gt; foldr' (||) [False, False, True, True] -- Use foldr instead!
--   True
--   </pre>
foldr' :: (a -> b -> b) -> b -> [a] -> b

-- | <a>foldr1</a> is a variant of <a>foldr</a> that has no starting value
--   argument, and thus must be applied to non-empty lists. Note that
--   unlike <a>foldr</a>, the accumulated value must be of the same type as
--   the list elements.
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..4]
--   10
--   
--   &gt;&gt;&gt; foldr1 (+) []
--   *** Exception: Prelude.foldr1: empty list
--   
--   &gt;&gt;&gt; foldr1 (-) [1..4]
--   -2
--   
--   &gt;&gt;&gt; foldr1 (&amp;&amp;) [True, False, True, True]
--   False
--   
--   &gt;&gt;&gt; foldr1 (||) [False, False, True, True]
--   True
--   
--   &gt;&gt;&gt; force $ foldr1 (+) [1..]
--   *** Exception: stack overflow
--   </pre>
foldr1 :: HasCallStack => (a -> a -> a) -> [a] -> a

-- | <a>foldl</a>, applied to a binary operator, a starting value
--   (typically the left-identity of the operator), and a list, reduces the
--   list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   The list must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (+) 0 [1..4]
--   10
--   
--   &gt;&gt;&gt; foldl (+) 42 []
--   42
--   
--   &gt;&gt;&gt; foldl (-) 100 [1..4]
--   90
--   
--   &gt;&gt;&gt; foldl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   "dcbafoo"
--   
--   &gt;&gt;&gt; foldl (+) 0 [1..]
--   * Hangs forever *
--   </pre>
foldl :: forall a b. (b -> a -> b) -> b -> [a] -> b

-- | A strict version of <a>foldl</a>.
foldl' :: forall a b. (b -> a -> b) -> b -> [a] -> b

-- | <a>foldl1</a> is a variant of <a>foldl</a> that has no starting value
--   argument, and thus must be applied to non-empty lists. Note that
--   unlike <a>foldl</a>, the accumulated value must be of the same type as
--   the list elements.
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..4]
--   10
--   
--   &gt;&gt;&gt; foldl1 (+) []
--   *** Exception: Prelude.foldl1: empty list
--   
--   &gt;&gt;&gt; foldl1 (-) [1..4]
--   -8
--   
--   &gt;&gt;&gt; foldl1 (&amp;&amp;) [True, False, True, True]
--   False
--   
--   &gt;&gt;&gt; foldl1 (||) [False, False, True, True]
--   True
--   
--   &gt;&gt;&gt; foldl1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldl1 :: HasCallStack => (a -> a -> a) -> [a] -> a

-- | &lt;math&gt;. Test whether a list is empty.
--   
--   <pre>
--   &gt;&gt;&gt; null []
--   True
--   
--   &gt;&gt;&gt; null [1]
--   False
--   
--   &gt;&gt;&gt; null [1..]
--   False
--   </pre>
null :: [a] -> Bool

-- | &lt;math&gt;. <a>length</a> returns the length of a finite list as an
--   <a>Int</a>. It is an instance of the more general
--   <a>genericLength</a>, the result type of which may be any kind of
--   number.
--   
--   <pre>
--   &gt;&gt;&gt; length []
--   0
--   
--   &gt;&gt;&gt; length ['a', 'b', 'c']
--   3
--   
--   &gt;&gt;&gt; length [1..]
--   * Hangs forever *
--   </pre>
length :: [a] -> Int

-- | <a>elem</a> is the list membership predicate, usually written in infix
--   form, e.g., <tt>x `elem` xs</tt>. For the result to be <a>False</a>,
--   the list must be finite; <a>True</a>, however, results from an element
--   equal to <tt>x</tt> found at a finite index of a finite or infinite
--   list.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2,3,4,5]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [4..]
--   * Hangs forever *
--   </pre>
elem :: Eq a => a -> [a] -> Bool
infix 4 `elem`

-- | <a>notElem</a> is the negation of <a>elem</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2,3,4,5]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [4..]
--   * Hangs forever *
--   </pre>
notElem :: Eq a => a -> [a] -> Bool
infix 4 `notElem`

-- | <a>maximum</a> returns the maximum value from a list, which must be
--   non-empty, finite, and of an ordered type. This function is equivalent
--   to <tt><a>foldr1</a> <a>max</a></tt>, and its behavior on lists with
--   multiple maxima depends on the relevant implementation of <a>max</a>.
--   For the default implementation of <a>max</a>, list order is used as a
--   tie-breaker: if there are multiple maxima, the rightmost of them is
--   chosen (this is equivalent to <tt><a>maximumBy</a>
--   <a>compare</a></tt>).
--   
--   <pre>
--   &gt;&gt;&gt; maximum []
--   *** Exception: Prelude.maximum: empty list
--   
--   &gt;&gt;&gt; maximum [42]
--   42
--   
--   &gt;&gt;&gt; maximum [55, -12, 7, 0, -89]
--   55
--   
--   &gt;&gt;&gt; maximum [1..]
--   * Hangs forever *
--   </pre>
maximum :: (Ord a, HasCallStack) => [a] -> a

-- | <a>minimum</a> returns the minimum value from a list, which must be
--   non-empty, finite, and of an ordered type. This function is equivalent
--   to <tt><a>foldr1</a> <a>min</a></tt>, and its behavior on lists with
--   multiple minima depends on the relevant implementation of <a>min</a>.
--   For the default implementation of <a>min</a>, list order is used as a
--   tie-breaker: if there are multiple minima, the leftmost of them is
--   chosen (this is equivalent to <tt><a>minimumBy</a>
--   <a>compare</a></tt>).
--   
--   <pre>
--   &gt;&gt;&gt; minimum []
--   *** Exception: Prelude.minimum: empty list
--   
--   &gt;&gt;&gt; minimum [42]
--   42
--   
--   &gt;&gt;&gt; minimum [55, -12, 7, 0, -89]
--   -89
--   
--   &gt;&gt;&gt; minimum [1..]
--   * Hangs forever *
--   </pre>
minimum :: (Ord a, HasCallStack) => [a] -> a

-- | The <a>sum</a> function computes the sum of a finite list of numbers.
--   
--   <pre>
--   &gt;&gt;&gt; sum []
--   0
--   
--   &gt;&gt;&gt; sum [42]
--   42
--   
--   &gt;&gt;&gt; sum [1..10]
--   55
--   
--   &gt;&gt;&gt; sum [4.1, 2.0, 1.7]
--   7.8
--   
--   &gt;&gt;&gt; sum [1..]
--   * Hangs forever *
--   </pre>
sum :: Num a => [a] -> a

-- | The <a>product</a> function computes the product of a finite list of
--   numbers.
--   
--   <pre>
--   &gt;&gt;&gt; product []
--   1
--   
--   &gt;&gt;&gt; product [42]
--   42
--   
--   &gt;&gt;&gt; product [1..10]
--   3628800
--   
--   &gt;&gt;&gt; product [4.1, 2.0, 1.7]
--   13.939999999999998
--   
--   &gt;&gt;&gt; product [1..]
--   * Hangs forever *
--   </pre>
product :: Num a => [a] -> a

-- | <a>and</a> returns the conjunction of a Boolean list. For the result
--   to be <a>True</a>, the list must be finite; <a>False</a>, however,
--   results from a <a>False</a> value at a finite index of a finite or
--   infinite list.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; and []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True, True, False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,True,True,True...
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (repeat True)
--   * Hangs forever *
--   </pre>
and :: [Bool] -> Bool

-- | <a>or</a> returns the disjunction of a Boolean list. For the result to
--   be <a>False</a>, the list must be finite; <a>True</a>, however,
--   results from a <a>True</a> value at a finite index of a finite or
--   infinite list.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; or []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (True : repeat False) -- Infinite list [True,False,False,False,False,False,False...
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (repeat False)
--   * Hangs forever *
--   </pre>
or :: [Bool] -> Bool

-- | Applied to a predicate and a list, <a>any</a> determines if any
--   element of the list satisfies the predicate. For the result to be
--   <a>False</a>, the list must be finite; <a>True</a>, however, results
--   from a <a>True</a> value for the predicate applied to an element at a
--   finite index of a finite or infinite list.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2,3,4,5]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [0, -1..]
--   * Hangs forever *
--   </pre>
any :: (a -> Bool) -> [a] -> Bool

-- | Applied to a predicate and a list, <a>all</a> determines if all
--   elements of the list satisfy the predicate. For the result to be
--   <a>True</a>, the list must be finite; <a>False</a>, however, results
--   from a <a>False</a> value for the predicate applied to an element at a
--   finite index of a finite or infinite list.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2,3,4,5]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [4..]
--   * Hangs forever *
--   </pre>
all :: (a -> Bool) -> [a] -> Bool

-- | A strict version of <a>foldl1</a>.
foldl1' :: HasCallStack => (a -> a -> a) -> [a] -> a

-- | Concatenate a list of lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; concat [[1,2,3], [4,5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat [[42]]
--   [42]
--   </pre>
concat :: [[a]] -> [a]

-- | Map a function returning a list over a list and concatenate the
--   results. <a>concatMap</a> can be seen as the composition of
--   <a>concat</a> and <a>map</a>.
--   
--   <pre>
--   concatMap f xs == (concat . map f) xs
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (\i -&gt; [-i,i]) []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (\i -&gt; [-i, i]) [1, 2, 3]
--   [-1,1,-2,2,-3,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap ('replicate' 3) [0, 2, 4]
--   [0,0,0,2,2,2,4,4,4]
--   </pre>
concatMap :: (a -> [b]) -> [a] -> [b]

-- | &lt;math&gt;. <a>map</a> <tt>f xs</tt> is the list obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   this means that <tt>map id == id</tt>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map id [1, 2, 3]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (\n -&gt; 3 * n + 1) [1, 2, 3]
--   [4,7,10]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | <a>(++)</a> appends two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
--   
--   <h4><b>Performance considerations</b></h4>
--   
--   This function takes linear time in the number of elements of the
--   <b>first</b> list. Thus it is better to associate repeated
--   applications of <a>(++)</a> to the right (which is the default
--   behaviour): <tt>xs ++ (ys ++ zs)</tt> or simply <tt>xs ++ ys ++
--   zs</tt>, but not <tt>(xs ++ ys) ++ zs</tt>. For the same reason
--   <a>concat</a> <tt>=</tt> <a>foldr</a> <a>(++)</a> <tt>[]</tt> has
--   linear performance, while <a>foldl</a> <a>(++)</a> <tt>[]</tt> is
--   prone to quadratic slowdown
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1, 2, 3] ++ [4, 5, 6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ++ [1, 2, 3]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [3, 2, 1] ++ []
--   [3,2,1]
--   </pre>
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | &lt;math&gt;. <a>filter</a>, applied to a predicate and a list,
--   returns the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter (\l -&gt; length l &gt; 3) ["Hello", ", ", "World", "!"]
--   ["Hello","World"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter (/= 3) [1, 2, 3, 4, 3, 2, 1]
--   [1,2,4,2,1]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | &lt;math&gt;. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list. For the result to be <a>Nothing</a>, the list must
--   be finite.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 [(1, "first")]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | &lt;math&gt;. Extract the first element of a list, which must be
--   non-empty.
--   
--   To disable the warning about partiality put <tt>{-# OPTIONS_GHC
--   -Wno-x-partial -Wno-unrecognised-warning-flags #-}</tt> at the top of
--   the file. To disable it throughout a package put the same options into
--   <tt>ghc-options</tt> section of Cabal file. To disable it in GHCi put
--   <tt>:set -Wno-x-partial -Wno-unrecognised-warning-flags</tt> into
--   <tt>~/.ghci</tt> config file. See also the <a>migration guide</a>.
--   
--   <h5><b>Examples</b></h5>
--   
--   <pre>
--   &gt;&gt;&gt; head [1, 2, 3]
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; head [1..]
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; head []
--   *** Exception: Prelude.head: empty list
--   </pre>

-- | <i>Warning: This is a partial function, it throws an error on empty
--   lists. Use pattern matching, <a>uncons</a> or <a>listToMaybe</a>
--   instead. Consider refactoring to use <a>Data.List.NonEmpty</a>.</i>
head :: HasCallStack => [a] -> a

-- | &lt;math&gt;. Extract the last element of a list, which must be finite
--   and non-empty.
--   
--   WARNING: This function is partial. Consider using <a>unsnoc</a>
--   instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; last [1, 2, 3]
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; last [1..]
--   * Hangs forever *
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; last []
--   *** Exception: Prelude.last: empty list
--   </pre>
last :: HasCallStack => [a] -> a

-- | &lt;math&gt;. Extract the elements after the head of a list, which
--   must be non-empty.
--   
--   To disable the warning about partiality put <tt>{-# OPTIONS_GHC
--   -Wno-x-partial -Wno-unrecognised-warning-flags #-}</tt> at the top of
--   the file. To disable it throughout a package put the same options into
--   <tt>ghc-options</tt> section of Cabal file. To disable it in GHCi put
--   <tt>:set -Wno-x-partial -Wno-unrecognised-warning-flags</tt> into
--   <tt>~/.ghci</tt> config file. See also the <a>migration guide</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; tail [1, 2, 3]
--   [2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tail [1]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tail []
--   *** Exception: Prelude.tail: empty list
--   </pre>

-- | <i>Warning: This is a partial function, it throws an error on empty
--   lists. Replace it with <a>drop</a> 1, or use pattern matching or
--   <a>uncons</a> instead. Consider refactoring to use
--   <a>Data.List.NonEmpty</a>.</i>
tail :: HasCallStack => [a] -> [a]

-- | &lt;math&gt;. Return all the elements of a list except the last one.
--   The list must be non-empty.
--   
--   WARNING: This function is partial. Consider using <a>unsnoc</a>
--   instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; init [1, 2, 3]
--   [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; init [1]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; init []
--   *** Exception: Prelude.init: empty list
--   </pre>
init :: HasCallStack => [a] -> [a]

-- | &lt;math&gt;. Decompose a list into its <a>head</a> and <a>tail</a>.
--   
--   <ul>
--   <li>If the list is empty, returns <a>Nothing</a>.</li>
--   <li>If the list is non-empty, returns <tt><a>Just</a> (x, xs)</tt>,
--   where <tt>x</tt> is the <a>head</a> of the list and <tt>xs</tt> its
--   <a>tail</a>.</li>
--   </ul>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncons []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncons [1]
--   Just (1,[])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncons [1, 2, 3]
--   Just (1,[2,3])
--   </pre>
uncons :: [a] -> Maybe (a, [a])

-- | &lt;math&gt;. Decompose a list into <a>init</a> and <a>last</a>.
--   
--   <ul>
--   <li>If the list is empty, returns <a>Nothing</a>.</li>
--   <li>If the list is non-empty, returns <tt><a>Just</a> (xs, x)</tt>,
--   where <tt>xs</tt> is the <a>init</a>ial part of the list and
--   <tt>x</tt> is its <a>last</a> element.</li>
--   </ul>
--   
--   <a>unsnoc</a> is dual to <a>uncons</a>: for a finite list <tt>xs</tt>
--   
--   <pre>
--   unsnoc xs = (\(hd, tl) -&gt; (reverse tl, hd)) &lt;$&gt; uncons (reverse xs)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc [1]
--   Just ([],1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc [1, 2, 3]
--   Just ([1,2],3)
--   </pre>
--   
--   <h4><b>Laziness</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; fst &lt;$&gt; unsnoc [undefined]
--   Just []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; head . fst &lt;$&gt; unsnoc (1 : undefined)
--   Just *** Exception: Prelude.undefined
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; head . fst &lt;$&gt; unsnoc (1 : 2 : undefined)
--   Just 1
--   </pre>
unsnoc :: [a] -> Maybe ([a], a)

-- | List index (subscript) operator, starting from 0. Returns
--   <a>Nothing</a> if the index is out of bounds
--   
--   This is the total variant of the partial <a>!!</a> operator.
--   
--   WARNING: This function takes linear time in the index.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !? 0
--   Just 'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !? 2
--   Just 'c'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !? 3
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !? (-1)
--   Nothing
--   </pre>
(!?) :: [a] -> Int -> Maybe a
infixl 9 !?

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
--   
--   WARNING: This function is partial, and should only be used if you are
--   sure that the indexing will not fail. Otherwise, use <a>!?</a>.
--   
--   WARNING: This function takes linear time in the index.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 0
--   'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 2
--   'c'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 3
--   *** Exception: Prelude.!!: index too large
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! (-1)
--   *** Exception: Prelude.!!: negative index
--   </pre>
(!!) :: HasCallStack => [a] -> Int -> a
infixl 9 !!

-- | &lt;math&gt;. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (+) 0 [1..4]
--   [0,1,3,6,10]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (+) 42 []
--   [42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (-) 100 [1..4]
--   [100,99,97,94,90]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["foo","afoo","bafoo","cbafoo","dcbafoo"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 (scanl (+) 0 [1..])
--   [0,1,3,6,10,15,21,28,36,45]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (scanl undefined 'a' undefined)
--   "a"
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (+) [1..4]
--   [1,3,6,10]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (+) []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (-) [1..4]
--   [1,-1,-4,-8]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (&amp;&amp;) [True, False, True, True]
--   [True,False,False,False]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (||) [False, False, True, True]
--   [False,False,True,True]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 (scanl1 (+) [1..])
--   [1,3,6,10,15,21,28,36,45,55]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (scanl1 undefined ('a' : undefined))
--   "a"
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. A strict version of <a>scanl</a>.
scanl' :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that the order of parameters on the accumulating function are
--   reversed compared to <a>scanl</a>. Also note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (+) 0 [1..4]
--   [10,9,7,4,0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (+) 42 []
--   [42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (-) 100 [1..4]
--   [98,-97,99,-96,100]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (\nextChar reversedString -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["abcdfoo","bcdfoo","cdfoo","dfoo","foo"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; force $ scanr (+) 0 [1..]
--   *** Exception: stack overflow
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (+) [1..4]
--   [10,9,7,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (+) []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (-) [1..4]
--   [-2,3,-1,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (&amp;&amp;) [True, False, True, True]
--   [False,False,True,True]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (||) [True, True, False, False]
--   [True,True,False,False]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; force $ scanr1 (+) [1..]
--   *** Exception: stack overflow
--   </pre>
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   <h4><b>Laziness</b></h4>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
--   
--   <pre>
--   &gt;&gt;&gt; take 1 $ iterate undefined 42
--   [42]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ iterate not True
--   [True,False,True,False,True,False,True,False,True,False]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ iterate (+3) 42
--   [42,45,48,51,54,57,60,63,66,69]
--   </pre>
--   
--   <tt>iterate id == <a>repeat</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ iterate id 1
--   [1,1,1,1,1,1,1,1,1,1]
--   </pre>
iterate :: (a -> a) -> a -> [a]

-- | <a>iterate'</a> is the strict version of <a>iterate</a>.
--   
--   It forces the result of each application of the function to weak head
--   normal form (WHNF) before proceeding.
--   
--   <pre>
--   &gt;&gt;&gt; take 1 $ iterate' undefined 42
--   *** Exception: Prelude.undefined
--   </pre>
iterate' :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ repeat 17
--   [17,17,17,17,17,17,17,17,17, 17]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; repeat undefined
--   [*** Exception: Prelude.undefined
--   </pre>
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; replicate 0 True
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate (-1) True
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate 4 True
--   [True,True,True,True]
--   </pre>
replicate :: Int -> a -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; cycle []
--   *** Exception: Prelude.cycle: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 (cycle [42])
--   [42,42,42,42,42,42,42,42,42,42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 (cycle [2, 5, 7])
--   [2,5,7,2,5,7,2,5,7,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (cycle (42 : undefined))
--   [42]
--   </pre>
cycle :: HasCallStack => [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt;= <a>length</a> xs</tt>.
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; take 0 undefined
--   []
--   
--   &gt;&gt;&gt; take 2 (1 : 2 : undefined)
--   [1,2]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; take 5 "Hello World!"
--   "Hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 3 [1,2,3,4,5]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 3 [1,2]
--   [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 3 []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take (-1) [1,2]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 0 [1,2]
--   []
--   </pre>
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt;= <a>length</a>
--   xs</tt>.
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; drop 6 "Hello World!"
--   "World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; drop 3 [1,2,3,4,5]
--   [4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; drop 3 [1,2]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; drop 3 []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; drop (-1) [1,2]
--   [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; drop 0 [1,2]
--   [1,2]
--   </pre>
drop :: Int -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
--   
--   <h4><b>Laziness</b></h4>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt>
--   unless <tt>n</tt> is <tt>_|_</tt>: <tt>splitAt _|_ xs = _|_</tt>, not
--   <tt>(_|_, _|_)</tt>).
--   
--   The first component of the tuple is produced lazily:
--   
--   <pre>
--   &gt;&gt;&gt; fst (splitAt 0 undefined)
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (fst (splitAt 10 (1 : undefined)))
--   [1]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 6 "Hello World!"
--   ("Hello ","World!")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 3 [1,2,3,4,5]
--   ([1,2,3],[4,5])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 1 [1,2,3]
--   ([1],[2,3])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 3 [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 4 [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 0 [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitAt (-1) [1,2,3]
--   ([],[1,2,3])
--   </pre>
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (const False) undefined
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (const False) (undefined : undefined)
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (takeWhile (const True) (1 : undefined))
--   [1]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 3) [1,2,3,4,1,2,3,4]
--   [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 9) [1,2,3]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 0) [1,2,3]
--   []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 3) [1,2,3,4,5,1,2,3]
--   [3,4,5,1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 9) [1,2,3]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 0) [1,2,3]
--   [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is the longest prefix (possibly
--   empty) of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second
--   element is the remainder of the list:
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>, even if <tt>p</tt> is <tt>_|_</tt>.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; span undefined []
--   ([],[])
--   
--   &gt;&gt;&gt; fst (span (const False) undefined)
--   *** Exception: Prelude.undefined
--   
--   &gt;&gt;&gt; fst (span (const False) (undefined : undefined))
--   []
--   
--   &gt;&gt;&gt; take 1 (fst (span (const True) (1 : undefined)))
--   [1]
--   </pre>
--   
--   <a>span</a> produces the first component of the tuple lazily:
--   
--   <pre>
--   &gt;&gt;&gt; take 10 (fst (span (const True) [1..]))
--   [1,2,3,4,5,6,7,8,9,10]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2],[3,4,1,2,3,4])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 9) [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 0) [1,2,3]
--   ([],[1,2,3])
--   </pre>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt> and consequently to <tt>(<a>takeWhile</a> (<a>not</a> . p) xs,
--   <a>dropWhile</a> (<a>not</a> . p) xs)</tt>, even if <tt>p</tt> is
--   <tt>_|_</tt>.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; break undefined []
--   ([],[])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fst (break (const True) undefined)
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fst (break (const True) (undefined : undefined))
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (fst (break (const False) (1 : undefined)))
--   [1]
--   </pre>
--   
--   <a>break</a> produces the first component of the tuple lazily:
--   
--   <pre>
--   &gt;&gt;&gt; take 10 (fst (break (const False) [1..]))
--   [1,2,3,4,5,6,7,8,9,10]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; break (&gt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2,3],[4,1,2,3,4])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; break (&lt; 9) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; break (&gt; 9) [1,2,3]
--   ([1,2,3],[])
--   </pre>
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | &lt;math&gt;. <a>reverse</a> <tt>xs</tt> returns the elements of
--   <tt>xs</tt> in reverse order. <tt>xs</tt> must be finite.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <a>reverse</a> is lazy in its elements.
--   
--   <pre>
--   &gt;&gt;&gt; head (reverse [undefined, 1])
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reverse (1 : 2 : undefined)
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; reverse []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reverse [42]
--   [42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reverse [2,5,7]
--   [7,5,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reverse [1..]
--   * Hangs forever *
--   </pre>
reverse :: [a] -> [a]

-- | &lt;math&gt;. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; zip [] undefined
--   []
--   
--   &gt;&gt;&gt; zip undefined []
--   *** Exception: Prelude.undefined
--   ...
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; zip [1, 2, 3] ['a', 'b', 'c']
--   [(1,'a'),(2,'b'),(3,'c')]
--   </pre>
--   
--   If one input list is shorter than the other, excess elements of the
--   longer list are discarded, even if one of the lists is infinite:
--   
--   <pre>
--   &gt;&gt;&gt; zip [1] ['a', 'b']
--   [(1,'a')]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zip [1, 2] ['a']
--   [(1,'a')]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zip [] [1..]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zip [1..] []
--   []
--   </pre>
zip :: [a] -> [b] -> [(a, b)]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | &lt;math&gt;. <a>zipWith</a> generalises <a>zip</a> by zipping with
--   the function given as the first argument, instead of a tupling
--   function.
--   
--   <pre>
--   zipWith (,) xs ys == zip xs ys
--   zipWith f [x1,x2,x3..] [y1,y2,y3..] == [f x1 y1, f x2 y2, f x3 y3..]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; let f = undefined
--   
--   &gt;&gt;&gt; zipWith f [] undefined
--   []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
--   
--   <h4><b>Examples</b></h4>
--   
--   <tt><a>zipWith</a> <a>(+)</a></tt> can be applied to two lists to
--   produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (++) ["hello ", "foo"] ["world!", "bar"]
--   ["hello world!","foobar"]
--   </pre>
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | &lt;math&gt;. The <a>zipWith3</a> function takes a function which
--   combines three elements, as well as three lists and returns a list of
--   the function applied to corresponding elements, analogous to
--   <a>zipWith</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
--   
--   <pre>
--   zipWith3 (,,) xs ys zs == zip3 xs ys zs
--   zipWith3 f [x1,x2,x3..] [y1,y2,y3..] [z1,z2,z3..] == [f x1 y1 z1, f x2 y2 z2, f x3 y3 z3..]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; zipWith3 (\x y z -&gt; [x, y, z]) "123" "abc" "xyz"
--   ["1ax","2by","3cz"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zipWith3 (\x y z -&gt; (x * y) + z) [1, 2, 3] [4, 5, 6] [7, 8, 9]
--   [11,18,27]
--   </pre>
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unzip []
--   ([],[])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unzip [(1, 'a'), (2, 'b')]
--   ([1,2],"ab")
--   </pre>
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists of the respective components, analogous to <a>unzip</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unzip3 []
--   ([],[],[])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unzip3 [(1, 'a', True), (2, 'b', False)]
--   ([1,2],"ab",[True,False])
--   </pre>
unzip3 :: [(a, b, c)] -> ([a], [b], [c])
errorEmptyList :: HasCallStack => String -> a

-- | A list producer that can be fused with <a>foldr</a>. This function is
--   merely
--   
--   <pre>
--   augment g xs = g (:) xs
--   </pre>
--   
--   but GHC's simplifier will transform an expression of the form
--   <tt><a>foldr</a> k z (<a>augment</a> g xs)</tt>, which may arise after
--   inlining, to <tt>g k (<a>foldr</a> k z xs)</tt>, which avoids
--   producing an intermediate list.
augment :: (forall b. () => (a -> b -> b) -> b -> b) -> [a] -> [a]

-- | A list producer that can be fused with <a>foldr</a>. This function is
--   merely
--   
--   <pre>
--   build g = g (:) []
--   </pre>
--   
--   but GHC's simplifier will transform an expression of the form
--   <tt><a>foldr</a> k z (<a>build</a> g)</tt>, which may arise after
--   inlining, to <tt>g k z</tt>, which avoids producing an intermediate
--   list.
build :: (forall b. () => (a -> b -> b) -> b -> b) -> [a]


-- | The <a>Show</a> class, and related operations.
module GHC.Internal.Show

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: Show a => a -> ShowS

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | Like <a>showLitString</a> (expand escape characters using Haskell
--   escape conventions), but * break the string into multiple lines * wrap
--   the entire thing in double quotes Example: <tt>showMultiLineString
--   "hellongoodbyenblah"</tt> returns <tt>[""hello\n\", "\goodbyen\",
--   "\blah""]</tt>
showMultiLineString :: String -> [String]

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS
showList__ :: (a -> ShowS) -> [a] -> ShowS
showCommaSpace :: ShowS
showSpace :: ShowS

-- | Convert a character to a string using only printable characters, using
--   Haskell source-language escape conventions. For example:
--   
--   <pre>
--   showLitChar '\n' s  =  "\\n" ++ s
--   </pre>
showLitChar :: Char -> ShowS

-- | Same as <a>showLitChar</a>, but for strings It converts the string to
--   a string using Haskell escape conventions for non-printable
--   characters. Does not add double-quotes around the whole thing; the
--   caller should do that. The main difference from showLitChar (apart
--   from the fact that the argument is a string not a list) is that we
--   must escape double-quotes
showLitString :: String -> ShowS
protectEsc :: (Char -> Bool) -> ShowS -> ShowS

-- | Convert an <a>Int</a> in the range <tt>0</tt>..<tt>15</tt> to the
--   corresponding single digit <a>Char</a>. This function fails on other
--   inputs, and generates lower-case hexadecimal digits.
intToDigit :: Int -> Char
showSignedInt :: Int -> Int -> ShowS
appPrec :: Int
appPrec1 :: Int
asciiTab :: [String]
instance GHC.Internal.Show.Show GHC.Types.Bool
instance GHC.Internal.Show.Show GHC.Internal.Stack.Types.CallStack
instance GHC.Internal.Show.Show GHC.Types.Char
instance GHC.Internal.Show.Show GHC.Types.Int
instance GHC.Internal.Show.Show GHC.Num.Integer.Integer
instance GHC.Internal.Show.Show GHC.Types.KindRep
instance GHC.Internal.Show.Show GHC.Types.Levity
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show [a]
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Internal.Maybe.Maybe a)
instance GHC.Internal.Show.Show GHC.Types.Module
instance GHC.Internal.Show.Show GHC.Num.Natural.Natural
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Internal.Base.NonEmpty a)
instance GHC.Internal.Show.Show GHC.Types.Ordering
instance GHC.Internal.Show.Show GHC.Types.RuntimeRep
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Tuple.Solo a)
instance GHC.Internal.Show.Show GHC.Internal.Stack.Types.SrcLoc
instance GHC.Internal.Show.Show GHC.Types.TrName
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b, GHC.Internal.Show.Show c, GHC.Internal.Show.Show d, GHC.Internal.Show.Show e, GHC.Internal.Show.Show f, GHC.Internal.Show.Show g, GHC.Internal.Show.Show h, GHC.Internal.Show.Show i, GHC.Internal.Show.Show j) => GHC.Internal.Show.Show (a, b, c, d, e, f, g, h, i, j)
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b, GHC.Internal.Show.Show c, GHC.Internal.Show.Show d, GHC.Internal.Show.Show e, GHC.Internal.Show.Show f, GHC.Internal.Show.Show g, GHC.Internal.Show.Show h, GHC.Internal.Show.Show i, GHC.Internal.Show.Show j, GHC.Internal.Show.Show k) => GHC.Internal.Show.Show (a, b, c, d, e, f, g, h, i, j, k)
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b, GHC.Internal.Show.Show c, GHC.Internal.Show.Show d, GHC.Internal.Show.Show e, GHC.Internal.Show.Show f, GHC.Internal.Show.Show g, GHC.Internal.Show.Show h, GHC.Internal.Show.Show i, GHC.Internal.Show.Show j, GHC.Internal.Show.Show k, GHC.Internal.Show.Show l) => GHC.Internal.Show.Show (a, b, c, d, e, f, g, h, i, j, k, l)
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b, GHC.Internal.Show.Show c, GHC.Internal.Show.Show d, GHC.Internal.Show.Show e, GHC.Internal.Show.Show f, GHC.Internal.Show.Show g, GHC.Internal.Show.Show h, GHC.Internal.Show.Show i, GHC.Internal.Show.Show j, GHC.Internal.Show.Show k, GHC.Internal.Show.Show l, GHC.Internal.Show.Show m) => GHC.Internal.Show.Show (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b, GHC.Internal.Show.Show c, GHC.Internal.Show.Show d, GHC.Internal.Show.Show e, GHC.Internal.Show.Show f, GHC.Internal.Show.Show g, GHC.Internal.Show.Show h, GHC.Internal.Show.Show i, GHC.Internal.Show.Show j, GHC.Internal.Show.Show k, GHC.Internal.Show.Show l, GHC.Internal.Show.Show m, GHC.Internal.Show.Show n) => GHC.Internal.Show.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b, GHC.Internal.Show.Show c, GHC.Internal.Show.Show d, GHC.Internal.Show.Show e, GHC.Internal.Show.Show f, GHC.Internal.Show.Show g, GHC.Internal.Show.Show h, GHC.Internal.Show.Show i, GHC.Internal.Show.Show j, GHC.Internal.Show.Show k, GHC.Internal.Show.Show l, GHC.Internal.Show.Show m, GHC.Internal.Show.Show n, GHC.Internal.Show.Show o) => GHC.Internal.Show.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b) => GHC.Internal.Show.Show (a, b)
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b, GHC.Internal.Show.Show c) => GHC.Internal.Show.Show (a, b, c)
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b, GHC.Internal.Show.Show c, GHC.Internal.Show.Show d) => GHC.Internal.Show.Show (a, b, c, d)
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b, GHC.Internal.Show.Show c, GHC.Internal.Show.Show d, GHC.Internal.Show.Show e) => GHC.Internal.Show.Show (a, b, c, d, e)
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b, GHC.Internal.Show.Show c, GHC.Internal.Show.Show d, GHC.Internal.Show.Show e, GHC.Internal.Show.Show f) => GHC.Internal.Show.Show (a, b, c, d, e, f)
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b, GHC.Internal.Show.Show c, GHC.Internal.Show.Show d, GHC.Internal.Show.Show e, GHC.Internal.Show.Show f, GHC.Internal.Show.Show g) => GHC.Internal.Show.Show (a, b, c, d, e, f, g)
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b, GHC.Internal.Show.Show c, GHC.Internal.Show.Show d, GHC.Internal.Show.Show e, GHC.Internal.Show.Show f, GHC.Internal.Show.Show g, GHC.Internal.Show.Show h) => GHC.Internal.Show.Show (a, b, c, d, e, f, g, h)
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b, GHC.Internal.Show.Show c, GHC.Internal.Show.Show d, GHC.Internal.Show.Show e, GHC.Internal.Show.Show f, GHC.Internal.Show.Show g, GHC.Internal.Show.Show h, GHC.Internal.Show.Show i) => GHC.Internal.Show.Show (a, b, c, d, e, f, g, h, i)
instance GHC.Internal.Show.Show GHC.Types.TyCon
instance GHC.Internal.Show.Show GHC.Types.TypeLitSort
instance GHC.Internal.Show.Show ()
instance GHC.Internal.Show.Show GHC.Types.VecCount
instance GHC.Internal.Show.Show GHC.Types.VecElem
instance GHC.Internal.Show.Show GHC.Internal.Base.Void
instance GHC.Internal.Show.Show GHC.Types.Word


-- | The <a>ST</a> Monad.
module GHC.Internal.ST

-- | The strict <a>ST</a> monad. The <a>ST</a> monad allows for destructive
--   updates, but is escapable (unlike IO). A computation of type
--   <tt><a>ST</a> s a</tt> returns a value of type <tt>a</tt>, and execute
--   in "thread" <tt>s</tt>. The <tt>s</tt> parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are strict in the
--   state (though not in values stored in the state). For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= f) = _|_
--   </pre>
newtype ST s a
ST :: STRep s a -> ST s a
data STret s a
STret :: State# s -> a -> STret s a
type STRep s a = State# s -> (# State# s, a #)

-- | Return the value computed by a state thread. The <tt>forall</tt>
--   ensures that the internal state used by the <a>ST</a> computation is
--   inaccessible to the rest of the program.
runST :: (forall s. () => ST s a) -> a
liftST :: ST s a -> State# s -> STret s a

-- | <a>unsafeInterleaveST</a> allows an <a>ST</a> computation to be
--   deferred lazily. When passed a value of type <tt>ST a</tt>, the
--   <a>ST</a> computation will only be performed when the value of the
--   <tt>a</tt> is demanded.
unsafeInterleaveST :: ST s a -> ST s a

-- | <a>unsafeDupableInterleaveST</a> allows an <a>ST</a> computation to be
--   deferred lazily. When passed a value of type <tt>ST a</tt>, the
--   <a>ST</a> computation will only be performed when the value of the
--   <tt>a</tt> is demanded.
--   
--   The computation may be performed multiple times by different threads,
--   possibly at the same time. To prevent this, use
--   <a>unsafeInterleaveST</a> instead.
unsafeDupableInterleaveST :: ST s a -> ST s a
instance GHC.Internal.Base.Applicative (GHC.Internal.ST.ST s)
instance GHC.Internal.Base.Functor (GHC.Internal.ST.ST s)
instance GHC.Internal.Base.Monad (GHC.Internal.ST.ST s)
instance GHC.Internal.Base.Monoid a => GHC.Internal.Base.Monoid (GHC.Internal.ST.ST s a)
instance GHC.Internal.Base.Semigroup a => GHC.Internal.Base.Semigroup (GHC.Internal.ST.ST s a)
instance GHC.Internal.Show.Show (GHC.Internal.ST.ST s a)


-- | References in the <a>ST</a> monad.
module GHC.Internal.STRef

-- | a value of type <tt>STRef s a</tt> is a mutable variable in state
--   thread <tt>s</tt>, containing a value of type <tt>a</tt>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   runST (do
--       ref &lt;- newSTRef "hello"
--       x &lt;- readSTRef ref
--       writeSTRef ref (x ++ "world")
--       readSTRef ref )
--   :}
--   "helloworld"
--   </pre>
data STRef s a
STRef :: MutVar# s a -> STRef s a

-- | Build a new <a>STRef</a> in the current state thread
newSTRef :: a -> ST s (STRef s a)

-- | Read the value of an <a>STRef</a>
readSTRef :: STRef s a -> ST s a

-- | Write a new value into an <a>STRef</a>
writeSTRef :: STRef s a -> a -> ST s ()
instance GHC.Classes.Eq (GHC.Internal.STRef.STRef s a)


-- | Mutable references in the (strict) ST monad.
module GHC.Internal.Data.STRef

-- | a value of type <tt>STRef s a</tt> is a mutable variable in state
--   thread <tt>s</tt>, containing a value of type <tt>a</tt>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   runST (do
--       ref &lt;- newSTRef "hello"
--       x &lt;- readSTRef ref
--       writeSTRef ref (x ++ "world")
--       readSTRef ref )
--   :}
--   "helloworld"
--   </pre>
data STRef s a

-- | Build a new <a>STRef</a> in the current state thread
newSTRef :: a -> ST s (STRef s a)

-- | Read the value of an <a>STRef</a>
readSTRef :: STRef s a -> ST s a

-- | Write a new value into an <a>STRef</a>
writeSTRef :: STRef s a -> a -> ST s ()

-- | Mutate the contents of an <a>STRef</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   runST (do
--       ref &lt;- newSTRef ""
--       modifySTRef ref (const "world")
--       modifySTRef ref (++ "!")
--       modifySTRef ref ("Hello, " ++)
--       readSTRef ref )
--   :}
--   "Hello, world!"
--   </pre>
--   
--   Be warned that <a>modifySTRef</a> does not apply the function
--   strictly. This means if the program calls <a>modifySTRef</a> many
--   times, but seldom uses the value, thunks will pile up in memory
--   resulting in a space leak. This is a common mistake made when using an
--   <a>STRef</a> as a counter. For example, the following will leak memory
--   and may produce a stack overflow:
--   
--   <pre>
--   &gt;&gt;&gt; import GHC.Internal.Control.Monad (replicateM_)
--   
--   &gt;&gt;&gt; :{
--   print (runST (do
--       ref &lt;- newSTRef 0
--       replicateM_ 1000 $ modifySTRef ref (+1)
--       readSTRef ref ))
--   :}
--   1000
--   </pre>
--   
--   To avoid this problem, use <a>modifySTRef'</a> instead.
modifySTRef :: STRef s a -> (a -> a) -> ST s ()

-- | Strict version of <a>modifySTRef</a>
modifySTRef' :: STRef s a -> (a -> a) -> ST s ()


-- | Mutable references in the (strict) ST monad (re-export of
--   <a>Data.STRef</a>)
module GHC.Internal.Data.STRef.Strict

module GHC.Internal.Char

-- | The <a>toEnum</a> method restricted to the type <a>Char</a>.
chr :: Int -> Char
eqChar :: Char -> Char -> Bool
neChar :: Char -> Char -> Bool


-- | The <a>Enum</a> and <a>Bounded</a> classes.
module GHC.Internal.Enum

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class Enum a

-- | Successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

-- | Predecessor of a value. For numeric types, <a>pred</a> subtracts 1.
pred :: Enum a => a -> a

-- | Convert from an <a>Int</a>.
toEnum :: Enum a => Int -> a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | Used in Haskell's translation of <tt>[n..]</tt> with <tt>[n..] =
--   enumFrom n</tt>, a possible implementation being <tt>enumFrom n = n :
--   enumFrom (succ n)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <ul>
--   <li><pre>enumFrom 4 :: [Integer] = [4,5,6,7,...]</pre></li>
--   <li><pre>enumFrom 6 :: [Int] = [6,7,8,9,...,maxBound ::
--   Int]</pre></li>
--   </ul>
enumFrom :: Enum a => a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..]</tt> with <tt>[n,n'..] =
--   enumFromThen n n'</tt>, a possible implementation being
--   <tt>enumFromThen n n' = n : n' : worker (f x) (f x n')</tt>,
--   <tt>worker s v = v : worker s (s v)</tt>, <tt>x = fromEnum n' -
--   fromEnum n</tt> and
--   
--   <pre>
--   f n y
--     | n &gt; 0 = f (n - 1) (succ y)
--     | n &lt; 0 = f (n + 1) (pred y)
--     | otherwise = y
--   
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <ul>
--   <li><pre>enumFromThen 4 6 :: [Integer] = [4,6,8,10...]</pre></li>
--   <li><pre>enumFromThen 6 2 :: [Int] = [6,2,-2,-6,...,minBound ::
--   Int]</pre></li>
--   </ul>
enumFromThen :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n..m]</tt> with <tt>[n..m] =
--   enumFromTo n m</tt>, a possible implementation being
--   
--   <pre>
--   enumFromTo n m
--      | n &lt;= m = n : enumFromTo (succ n) m
--      | otherwise = []
--   
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <ul>
--   <li><pre>enumFromTo 6 10 :: [Int] = [6,7,8,9,10]</pre></li>
--   <li><pre>enumFromTo 42 1 :: [Integer] = []</pre></li>
--   </ul>
enumFromTo :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..m]</tt> with <tt>[n,n'..m]
--   = enumFromThenTo n n' m</tt>, a possible implementation being
--   <tt>enumFromThenTo n n' m = worker (f x) (c x) n m</tt>, <tt>x =
--   fromEnum n' - fromEnum n</tt>, <tt>c x = bool (&gt;=) (<a>(x</a>
--   0)</tt>
--   
--   <pre>
--   f n y
--      | n &gt; 0 = f (n - 1) (succ y)
--      | n &lt; 0 = f (n + 1) (pred y)
--      | otherwise = y
--   
--   </pre>
--   
--   and
--   
--   <pre>
--   worker s c v m
--      | c v m = v : worker s c (s v) m
--      | otherwise = []
--   
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <ul>
--   <li><pre>enumFromThenTo 4 2 -6 :: [Integer] =
--   [4,2,0,-2,-4,-6]</pre></li>
--   <li><pre>enumFromThenTo 6 8 2 :: [Int] = []</pre></li>
--   </ul>
enumFromThenTo :: Enum a => a -> a -> a -> [a]
boundedEnumFrom :: (Enum a, Bounded a) => a -> [a]
boundedEnumFromThen :: (Enum a, Bounded a) => a -> a -> [a]
toEnumError :: Show a => String -> Int -> (a, a) -> b
fromEnumError :: Show a => String -> a -> b
succError :: String -> a
predError :: String -> a

-- | Convert an Int into a Word (used in derived Enum instances)
enumIntToWord :: Int -> Word
instance GHC.Internal.Enum.Bounded GHC.Types.Bool
instance GHC.Internal.Enum.Bounded GHC.Types.Char
instance GHC.Internal.Enum.Bounded GHC.Types.Int
instance GHC.Internal.Enum.Bounded GHC.Types.Levity
instance GHC.Internal.Enum.Bounded GHC.Types.Ordering
instance GHC.Internal.Enum.Bounded a => GHC.Internal.Enum.Bounded (GHC.Tuple.Solo a)
instance (GHC.Internal.Enum.Bounded a, GHC.Internal.Enum.Bounded b, GHC.Internal.Enum.Bounded c, GHC.Internal.Enum.Bounded d, GHC.Internal.Enum.Bounded e, GHC.Internal.Enum.Bounded f, GHC.Internal.Enum.Bounded g, GHC.Internal.Enum.Bounded h, GHC.Internal.Enum.Bounded i, GHC.Internal.Enum.Bounded j) => GHC.Internal.Enum.Bounded (a, b, c, d, e, f, g, h, i, j)
instance (GHC.Internal.Enum.Bounded a, GHC.Internal.Enum.Bounded b, GHC.Internal.Enum.Bounded c, GHC.Internal.Enum.Bounded d, GHC.Internal.Enum.Bounded e, GHC.Internal.Enum.Bounded f, GHC.Internal.Enum.Bounded g, GHC.Internal.Enum.Bounded h, GHC.Internal.Enum.Bounded i, GHC.Internal.Enum.Bounded j, GHC.Internal.Enum.Bounded k) => GHC.Internal.Enum.Bounded (a, b, c, d, e, f, g, h, i, j, k)
instance (GHC.Internal.Enum.Bounded a, GHC.Internal.Enum.Bounded b, GHC.Internal.Enum.Bounded c, GHC.Internal.Enum.Bounded d, GHC.Internal.Enum.Bounded e, GHC.Internal.Enum.Bounded f, GHC.Internal.Enum.Bounded g, GHC.Internal.Enum.Bounded h, GHC.Internal.Enum.Bounded i, GHC.Internal.Enum.Bounded j, GHC.Internal.Enum.Bounded k, GHC.Internal.Enum.Bounded l) => GHC.Internal.Enum.Bounded (a, b, c, d, e, f, g, h, i, j, k, l)
instance (GHC.Internal.Enum.Bounded a, GHC.Internal.Enum.Bounded b, GHC.Internal.Enum.Bounded c, GHC.Internal.Enum.Bounded d, GHC.Internal.Enum.Bounded e, GHC.Internal.Enum.Bounded f, GHC.Internal.Enum.Bounded g, GHC.Internal.Enum.Bounded h, GHC.Internal.Enum.Bounded i, GHC.Internal.Enum.Bounded j, GHC.Internal.Enum.Bounded k, GHC.Internal.Enum.Bounded l, GHC.Internal.Enum.Bounded m) => GHC.Internal.Enum.Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (GHC.Internal.Enum.Bounded a, GHC.Internal.Enum.Bounded b, GHC.Internal.Enum.Bounded c, GHC.Internal.Enum.Bounded d, GHC.Internal.Enum.Bounded e, GHC.Internal.Enum.Bounded f, GHC.Internal.Enum.Bounded g, GHC.Internal.Enum.Bounded h, GHC.Internal.Enum.Bounded i, GHC.Internal.Enum.Bounded j, GHC.Internal.Enum.Bounded k, GHC.Internal.Enum.Bounded l, GHC.Internal.Enum.Bounded m, GHC.Internal.Enum.Bounded n) => GHC.Internal.Enum.Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (GHC.Internal.Enum.Bounded a, GHC.Internal.Enum.Bounded b, GHC.Internal.Enum.Bounded c, GHC.Internal.Enum.Bounded d, GHC.Internal.Enum.Bounded e, GHC.Internal.Enum.Bounded f, GHC.Internal.Enum.Bounded g, GHC.Internal.Enum.Bounded h, GHC.Internal.Enum.Bounded i, GHC.Internal.Enum.Bounded j, GHC.Internal.Enum.Bounded k, GHC.Internal.Enum.Bounded l, GHC.Internal.Enum.Bounded m, GHC.Internal.Enum.Bounded n, GHC.Internal.Enum.Bounded o) => GHC.Internal.Enum.Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance (GHC.Internal.Enum.Bounded a, GHC.Internal.Enum.Bounded b) => GHC.Internal.Enum.Bounded (a, b)
instance (GHC.Internal.Enum.Bounded a, GHC.Internal.Enum.Bounded b, GHC.Internal.Enum.Bounded c) => GHC.Internal.Enum.Bounded (a, b, c)
instance (GHC.Internal.Enum.Bounded a, GHC.Internal.Enum.Bounded b, GHC.Internal.Enum.Bounded c, GHC.Internal.Enum.Bounded d) => GHC.Internal.Enum.Bounded (a, b, c, d)
instance (GHC.Internal.Enum.Bounded a, GHC.Internal.Enum.Bounded b, GHC.Internal.Enum.Bounded c, GHC.Internal.Enum.Bounded d, GHC.Internal.Enum.Bounded e) => GHC.Internal.Enum.Bounded (a, b, c, d, e)
instance (GHC.Internal.Enum.Bounded a, GHC.Internal.Enum.Bounded b, GHC.Internal.Enum.Bounded c, GHC.Internal.Enum.Bounded d, GHC.Internal.Enum.Bounded e, GHC.Internal.Enum.Bounded f) => GHC.Internal.Enum.Bounded (a, b, c, d, e, f)
instance (GHC.Internal.Enum.Bounded a, GHC.Internal.Enum.Bounded b, GHC.Internal.Enum.Bounded c, GHC.Internal.Enum.Bounded d, GHC.Internal.Enum.Bounded e, GHC.Internal.Enum.Bounded f, GHC.Internal.Enum.Bounded g) => GHC.Internal.Enum.Bounded (a, b, c, d, e, f, g)
instance (GHC.Internal.Enum.Bounded a, GHC.Internal.Enum.Bounded b, GHC.Internal.Enum.Bounded c, GHC.Internal.Enum.Bounded d, GHC.Internal.Enum.Bounded e, GHC.Internal.Enum.Bounded f, GHC.Internal.Enum.Bounded g, GHC.Internal.Enum.Bounded h) => GHC.Internal.Enum.Bounded (a, b, c, d, e, f, g, h)
instance (GHC.Internal.Enum.Bounded a, GHC.Internal.Enum.Bounded b, GHC.Internal.Enum.Bounded c, GHC.Internal.Enum.Bounded d, GHC.Internal.Enum.Bounded e, GHC.Internal.Enum.Bounded f, GHC.Internal.Enum.Bounded g, GHC.Internal.Enum.Bounded h, GHC.Internal.Enum.Bounded i) => GHC.Internal.Enum.Bounded (a, b, c, d, e, f, g, h, i)
instance GHC.Internal.Enum.Bounded ()
instance GHC.Internal.Enum.Bounded GHC.Types.VecCount
instance GHC.Internal.Enum.Bounded GHC.Types.VecElem
instance GHC.Internal.Enum.Bounded GHC.Types.Word
instance GHC.Internal.Enum.Enum GHC.Types.Bool
instance GHC.Internal.Enum.Enum GHC.Types.Char
instance GHC.Internal.Enum.Enum GHC.Types.Int
instance GHC.Internal.Enum.Enum GHC.Num.Integer.Integer
instance GHC.Internal.Enum.Enum GHC.Types.Levity
instance GHC.Internal.Enum.Enum GHC.Num.Natural.Natural
instance GHC.Internal.Enum.Enum GHC.Types.Ordering
instance GHC.Internal.Enum.Enum a => GHC.Internal.Enum.Enum (GHC.Tuple.Solo a)
instance GHC.Internal.Enum.Enum ()
instance GHC.Internal.Enum.Enum GHC.Types.VecCount
instance GHC.Internal.Enum.Enum GHC.Types.VecElem
instance GHC.Internal.Enum.Enum GHC.Types.Word


-- | The <a>IoSubSystem</a> control interface. These methods can be used to
--   disambiguate between the two operations.
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.IO.SubSystem
withIoSubSystem :: (IoSubSystem -> IO a) -> IO a
withIoSubSystem' :: (IoSubSystem -> a) -> a
whenIoSubSystem :: IoSubSystem -> IO () -> IO ()

-- | The <a>IoSubSystem</a> in use.
--   
--   This is needed to optimize support for different IO Managers on
--   Windows. GHC supports both the new WinIO manager as well as the old
--   MIO (threaded), and ancient win32-legacy (non-threaded) ones. The
--   WinIO manager uses native Win32 HANDLEs, whereas the other two use
--   posix style FDs (via translation layers).
--   
--   In many places in the I/O base library code, for correctness or
--   performance on Windows, we have to take different code paths depending
--   on which style of IO manager is in use. The IO manager is set on RTS
--   startup (and the default choice can be overridden using RTS flags). On
--   Windows this value is obtained by reading a global variable that is
--   set by the RTS IOManager on startup.
--   
--   On non-Windows systems this value is always <a>IoPOSIX</a>.
ioSubSystem :: IoSubSystem

-- | The I/O SubSystem to use in the program.
data IoSubSystem

-- | Use a POSIX I/O Sub-System
IoPOSIX :: IoSubSystem

-- | Use platform native Sub-System. For unix OSes this is the same as
--   IoPOSIX, but on Windows this means use the Windows native APIs for
--   I/O, including IOCP and RIO.
IoNative :: IoSubSystem

-- | Conditionally execute an action depending on the configured I/O
--   subsystem. On POSIX systems always execute the first action. On
--   Windows execute the second action if WINIO as active, otherwise fall
--   back to the first action.
conditional :: a -> a -> a

-- | Infix version of <a>conditional</a>. posix <a>!</a> windows ==
--   conditional posix windows
(<!>) :: a -> a -> a
infixl 7 <!>
isWindowsNativeIO :: Bool
instance GHC.Internal.Enum.Enum GHC.Internal.IO.SubSystem.IoSubSystem
instance GHC.Classes.Eq GHC.Internal.IO.SubSystem.IoSubSystem
instance GHC.Internal.Show.Show GHC.Internal.IO.SubSystem.IoSubSystem


-- | The types <a>Ratio</a> and <a>Rational</a>, and the classes
--   <a>Real</a>, <a>Fractional</a>, <a>Integral</a>, and <a>RealFrac</a>.
module GHC.Internal.Real

-- | Real numbers.
--   
--   The Haskell report defines no laws for <a>Real</a>, however
--   <a>Real</a> instances are customarily expected to adhere to the
--   following law:
--   
--   <ul>
--   <li><i><b>Coherence with <a>fromRational</a></b></i> if the type also
--   implements <a>Fractional</a>, then <a>fromRational</a> is a left
--   inverse for <a>toRational</a>, i.e. <tt>fromRational (toRational i) =
--   i</tt></li>
--   </ul>
--   
--   The law does not hold for <a>Float</a>, <a>Double</a>, <a>CFloat</a>,
--   <a>CDouble</a>, etc., because these types contain non-finite values,
--   which cannot be roundtripped through <a>Rational</a>.
class (Num a, Ord a) => Real a

-- | Rational equivalent of its real argument with full precision.
toRational :: Real a => a -> Rational

-- | Integral numbers, supporting integer division.
--   
--   The Haskell Report defines no laws for <a>Integral</a>. However,
--   <a>Integral</a> instances are customarily expected to define a
--   Euclidean domain and have the following properties for the
--   <a>div</a>/<a>mod</a> and <a>quot</a>/<a>rem</a> pairs, given suitable
--   Euclidean functions <tt>f</tt> and <tt>g</tt>:
--   
--   <ul>
--   <li><tt>x</tt> = <tt>y * quot x y + rem x y</tt> with <tt>rem x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>g (rem x y)</tt> &lt; <tt>g
--   y</tt></li>
--   <li><tt>x</tt> = <tt>y * div x y + mod x y</tt> with <tt>mod x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>f (mod x y)</tt> &lt; <tt>f
--   y</tt></li>
--   </ul>
--   
--   An example of a suitable Euclidean function, for <a>Integer</a>'s
--   instance, is <a>abs</a>.
--   
--   In addition, <tt>toInteger</tt> should be total, and
--   <a>fromInteger</a> should be a left inverse for it, i.e.
--   <tt>fromInteger (toInteger i) = i</tt>.
class (Real a, Enum a) => Integral a

-- | Integer division truncated toward zero.
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
quot :: Integral a => a -> a -> a

-- | Integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
rem :: Integral a => a -> a -> a

-- | Integer division truncated toward negative infinity.
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
div :: Integral a => a -> a -> a

-- | Integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
mod :: Integral a => a -> a -> a

-- | Simultaneous <a>quot</a> and <a>rem</a>.
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>.
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
divMod :: Integral a => a -> a -> (a, a)

-- | Conversion to <a>Integer</a>.
toInteger :: Integral a => a -> Integer
infixl 7 `quot`
infixl 7 `rem`
infixl 7 `div`
infixl 7 `mod`

-- | Fractional numbers, supporting real division.
--   
--   The Haskell Report defines no laws for <a>Fractional</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a division ring and have the following properties:
--   
--   <ul>
--   <li><i><b><a>recip</a> gives the multiplicative inverse</b></i> <tt>x
--   * recip x</tt> = <tt>recip x * x</tt> = <tt>fromInteger 1</tt></li>
--   <li><i><b>Totality of <a>toRational</a></b></i> <a>toRational</a> is
--   total</li>
--   <li><i><b>Coherence with <a>toRational</a></b></i> if the type also
--   implements <a>Real</a>, then <a>fromRational</a> is a left inverse for
--   <a>toRational</a>, i.e. <tt>fromRational (toRational i) = i</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   <a>Fractional</a> implement a field. However, all instances in
--   <tt>base</tt> do.
class Num a => Fractional a

-- | Fractional division.
(/) :: Fractional a => a -> a -> a

-- | Reciprocal fraction.
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a
infixl 7 /

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | General coercion from <a>Integral</a> types.
--   
--   WARNING: This function performs silent truncation if the result type
--   is not at least as big as the argument's type.
fromIntegral :: (Integral a, Num b) => a -> b

-- | General coercion to <a>Fractional</a> types.
--   
--   WARNING: This function goes through the <a>Rational</a> type, which
--   does not have values for <tt>NaN</tt> for example. This means it does
--   not round-trip.
--   
--   For <a>Double</a> it also behaves differently with or without -O0:
--   
--   <pre>
--   Prelude&gt; realToFrac nan -- With -O0
--   -Infinity
--   Prelude&gt; realToFrac nan
--   NaN
--   </pre>
realToFrac :: (Real a, Fractional b) => a -> b

-- | Converts a possibly-negative <a>Real</a> value to a string.
showSigned :: Real a => (a -> ShowS) -> Int -> a -> ShowS
even :: Integral a => a -> Bool
odd :: Integral a => a -> Bool

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: Integral a => a -> a -> a

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => a -> a -> a

-- | Rational numbers, with numerator and denominator of some
--   <a>Integral</a> type.
--   
--   Note that <a>Ratio</a>'s instances inherit the deficiencies from the
--   type parameter's. For example, <tt>Ratio Natural</tt>'s <a>Num</a>
--   instance has similar problems to <a>Natural</a>'s.
data Ratio a
(:%) :: !a -> !a -> Ratio a

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer
infinity :: Rational
notANumber :: Rational
numericEnumFrom :: Fractional a => a -> [a]
numericEnumFromThen :: Fractional a => a -> a -> [a]
numericEnumFromTo :: (Ord a, Fractional a) => a -> a -> [a]
numericEnumFromThenTo :: (Ord a, Fractional a) => a -> a -> a -> [a]
integralEnumFrom :: (Integral a, Bounded a) => a -> [a]
integralEnumFromThen :: (Integral a, Bounded a) => a -> a -> [a]
integralEnumFromTo :: Integral a => a -> a -> [a]
integralEnumFromThenTo :: Integral a => a -> a -> a -> [a]

-- | Forms the ratio of two integral numbers.
(%) :: Integral a => a -> a -> Ratio a
infixl 7 %

-- | Extract the numerator of the ratio in reduced form: the numerator and
--   denominator have no common factor and the denominator is positive.
numerator :: Ratio a -> a

-- | Extract the denominator of the ratio in reduced form: the numerator
--   and denominator have no common factor and the denominator is positive.
denominator :: Ratio a -> a

-- | <a>reduce</a> is a subsidiary function used only in this module. It
--   normalises a ratio by dividing both numerator and denominator by their
--   greatest common divisor.
reduce :: Integral a => a -> a -> Ratio a
ratioPrec :: Int
ratioPrec1 :: Int
divZeroError :: a
ratioZeroDenominatorError :: a
overflowError :: a
underflowError :: a
mkRationalBase2 :: Rational -> Integer -> Rational
mkRationalBase10 :: Rational -> Integer -> Rational
data FractionalExponentBase
Base2 :: FractionalExponentBase
Base10 :: FractionalExponentBase
(^%^) :: Integral a => Rational -> a -> Rational
(^^%^^) :: Integral a => Rational -> a -> Rational
mkRationalWithExponentBase :: Rational -> Integer -> FractionalExponentBase -> Rational
powImpl :: (Num a, Integral b) => a -> b -> a
powImplAcc :: (Num a, Integral b) => a -> b -> a -> a
instance GHC.Internal.Real.Integral a => GHC.Internal.Enum.Enum (GHC.Internal.Real.Ratio a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Internal.Real.Ratio a)
instance GHC.Internal.Real.Integral a => GHC.Internal.Real.Fractional (GHC.Internal.Real.Ratio a)
instance GHC.Internal.Real.Integral GHC.Types.Int
instance GHC.Internal.Real.Integral GHC.Num.Integer.Integer
instance GHC.Internal.Real.Integral GHC.Num.Natural.Natural
instance GHC.Internal.Real.Integral GHC.Types.Word
instance GHC.Internal.Real.Integral a => GHC.Internal.Num.Num (GHC.Internal.Real.Ratio a)
instance GHC.Internal.Real.Integral a => GHC.Classes.Ord (GHC.Internal.Real.Ratio a)
instance GHC.Internal.Real.Integral a => GHC.Internal.Real.RealFrac (GHC.Internal.Real.Ratio a)
instance GHC.Internal.Real.Real GHC.Types.Int
instance GHC.Internal.Real.Real GHC.Num.Integer.Integer
instance GHC.Internal.Real.Real GHC.Num.Natural.Natural
instance GHC.Internal.Real.Integral a => GHC.Internal.Real.Real (GHC.Internal.Real.Ratio a)
instance GHC.Internal.Real.Real GHC.Types.Word
instance GHC.Internal.Show.Show GHC.Internal.Real.FractionalExponentBase
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Internal.Real.Ratio a)


-- | GHC's Ix typeclass implementation.
module GHC.Internal.Ix

-- | The <a>Ix</a> class is used to map a contiguous subrange of values in
--   a type onto integers. It is used primarily for array indexing (see the
--   array package).
--   
--   The first argument <tt>(l,u)</tt> of each of these operations is a
--   pair specifying the lower and upper bounds of a contiguous subrange of
--   values.
--   
--   An implementation is entitled to assume the following laws about these
--   operations:
--   
--   <ul>
--   <li><tt><a>inRange</a> (l,u) i == <tt>elem</tt> i (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   <li><tt><a>range</a> (l,u) <tt>!!</tt> <a>index</a> (l,u) i == i</tt>,
--   when <tt><a>inRange</a> (l,u) i</tt></li>
--   <li><tt><a>map</a> (<a>index</a> (l,u)) (<a>range</a> (l,u))) ==
--   [0..<a>rangeSize</a> (l,u)-1]</tt> <tt> </tt></li>
--   <li><tt><a>rangeSize</a> (l,u) == <tt>length</tt> (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   </ul>
class Ord a => Ix a

-- | The list of values in the subrange defined by a bounding pair.
range :: Ix a => (a, a) -> [a]

-- | The position of a subscript in the subrange.
index :: Ix a => (a, a) -> a -> Int

-- | Like <a>index</a>, but without checking that the value is in range.
unsafeIndex :: Ix a => (a, a) -> a -> Int

-- | Returns <a>True</a> the given subscript lies in the range defined the
--   bounding pair.
inRange :: Ix a => (a, a) -> a -> Bool

-- | The size of the subrange defined by a bounding pair.
rangeSize :: Ix a => (a, a) -> Int

-- | like <a>rangeSize</a>, but without checking that the upper bound is in
--   range.
unsafeRangeSize :: Ix a => (a, a) -> Int
indexError :: Show a => (a, a) -> a -> String -> b
instance GHC.Internal.Ix.Ix GHC.Types.Bool
instance GHC.Internal.Ix.Ix GHC.Types.Char
instance GHC.Internal.Ix.Ix GHC.Types.Int
instance GHC.Internal.Ix.Ix GHC.Num.Integer.Integer
instance GHC.Internal.Ix.Ix GHC.Num.Natural.Natural
instance GHC.Internal.Ix.Ix GHC.Types.Ordering
instance GHC.Internal.Ix.Ix a => GHC.Internal.Ix.Ix (GHC.Tuple.Solo a)
instance (GHC.Internal.Ix.Ix a1, GHC.Internal.Ix.Ix a2, GHC.Internal.Ix.Ix a3, GHC.Internal.Ix.Ix a4, GHC.Internal.Ix.Ix a5, GHC.Internal.Ix.Ix a6, GHC.Internal.Ix.Ix a7, GHC.Internal.Ix.Ix a8, GHC.Internal.Ix.Ix a9, GHC.Internal.Ix.Ix aA) => GHC.Internal.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA)
instance (GHC.Internal.Ix.Ix a1, GHC.Internal.Ix.Ix a2, GHC.Internal.Ix.Ix a3, GHC.Internal.Ix.Ix a4, GHC.Internal.Ix.Ix a5, GHC.Internal.Ix.Ix a6, GHC.Internal.Ix.Ix a7, GHC.Internal.Ix.Ix a8, GHC.Internal.Ix.Ix a9, GHC.Internal.Ix.Ix aA, GHC.Internal.Ix.Ix aB) => GHC.Internal.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB)
instance (GHC.Internal.Ix.Ix a1, GHC.Internal.Ix.Ix a2, GHC.Internal.Ix.Ix a3, GHC.Internal.Ix.Ix a4, GHC.Internal.Ix.Ix a5, GHC.Internal.Ix.Ix a6, GHC.Internal.Ix.Ix a7, GHC.Internal.Ix.Ix a8, GHC.Internal.Ix.Ix a9, GHC.Internal.Ix.Ix aA, GHC.Internal.Ix.Ix aB, GHC.Internal.Ix.Ix aC) => GHC.Internal.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB, aC)
instance (GHC.Internal.Ix.Ix a1, GHC.Internal.Ix.Ix a2, GHC.Internal.Ix.Ix a3, GHC.Internal.Ix.Ix a4, GHC.Internal.Ix.Ix a5, GHC.Internal.Ix.Ix a6, GHC.Internal.Ix.Ix a7, GHC.Internal.Ix.Ix a8, GHC.Internal.Ix.Ix a9, GHC.Internal.Ix.Ix aA, GHC.Internal.Ix.Ix aB, GHC.Internal.Ix.Ix aC, GHC.Internal.Ix.Ix aD) => GHC.Internal.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB, aC, aD)
instance (GHC.Internal.Ix.Ix a1, GHC.Internal.Ix.Ix a2, GHC.Internal.Ix.Ix a3, GHC.Internal.Ix.Ix a4, GHC.Internal.Ix.Ix a5, GHC.Internal.Ix.Ix a6, GHC.Internal.Ix.Ix a7, GHC.Internal.Ix.Ix a8, GHC.Internal.Ix.Ix a9, GHC.Internal.Ix.Ix aA, GHC.Internal.Ix.Ix aB, GHC.Internal.Ix.Ix aC, GHC.Internal.Ix.Ix aD, GHC.Internal.Ix.Ix aE) => GHC.Internal.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB, aC, aD, aE)
instance (GHC.Internal.Ix.Ix a1, GHC.Internal.Ix.Ix a2, GHC.Internal.Ix.Ix a3, GHC.Internal.Ix.Ix a4, GHC.Internal.Ix.Ix a5, GHC.Internal.Ix.Ix a6, GHC.Internal.Ix.Ix a7, GHC.Internal.Ix.Ix a8, GHC.Internal.Ix.Ix a9, GHC.Internal.Ix.Ix aA, GHC.Internal.Ix.Ix aB, GHC.Internal.Ix.Ix aC, GHC.Internal.Ix.Ix aD, GHC.Internal.Ix.Ix aE, GHC.Internal.Ix.Ix aF) => GHC.Internal.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB, aC, aD, aE, aF)
instance (GHC.Internal.Ix.Ix a, GHC.Internal.Ix.Ix b) => GHC.Internal.Ix.Ix (a, b)
instance (GHC.Internal.Ix.Ix a1, GHC.Internal.Ix.Ix a2, GHC.Internal.Ix.Ix a3) => GHC.Internal.Ix.Ix (a1, a2, a3)
instance (GHC.Internal.Ix.Ix a1, GHC.Internal.Ix.Ix a2, GHC.Internal.Ix.Ix a3, GHC.Internal.Ix.Ix a4) => GHC.Internal.Ix.Ix (a1, a2, a3, a4)
instance (GHC.Internal.Ix.Ix a1, GHC.Internal.Ix.Ix a2, GHC.Internal.Ix.Ix a3, GHC.Internal.Ix.Ix a4, GHC.Internal.Ix.Ix a5) => GHC.Internal.Ix.Ix (a1, a2, a3, a4, a5)
instance (GHC.Internal.Ix.Ix a1, GHC.Internal.Ix.Ix a2, GHC.Internal.Ix.Ix a3, GHC.Internal.Ix.Ix a4, GHC.Internal.Ix.Ix a5, GHC.Internal.Ix.Ix a6) => GHC.Internal.Ix.Ix (a1, a2, a3, a4, a5, a6)
instance (GHC.Internal.Ix.Ix a1, GHC.Internal.Ix.Ix a2, GHC.Internal.Ix.Ix a3, GHC.Internal.Ix.Ix a4, GHC.Internal.Ix.Ix a5, GHC.Internal.Ix.Ix a6, GHC.Internal.Ix.Ix a7) => GHC.Internal.Ix.Ix (a1, a2, a3, a4, a5, a6, a7)
instance (GHC.Internal.Ix.Ix a1, GHC.Internal.Ix.Ix a2, GHC.Internal.Ix.Ix a3, GHC.Internal.Ix.Ix a4, GHC.Internal.Ix.Ix a5, GHC.Internal.Ix.Ix a6, GHC.Internal.Ix.Ix a7, GHC.Internal.Ix.Ix a8) => GHC.Internal.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8)
instance (GHC.Internal.Ix.Ix a1, GHC.Internal.Ix.Ix a2, GHC.Internal.Ix.Ix a3, GHC.Internal.Ix.Ix a4, GHC.Internal.Ix.Ix a5, GHC.Internal.Ix.Ix a6, GHC.Internal.Ix.Ix a7, GHC.Internal.Ix.Ix a8, GHC.Internal.Ix.Ix a9) => GHC.Internal.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9)
instance GHC.Internal.Ix.Ix ()
instance GHC.Internal.Ix.Ix GHC.Internal.Base.Void
instance GHC.Internal.Ix.Ix GHC.Types.Word


-- | The <a>Ix</a> class is used to map a contiguous subrange of values in
--   type onto integers. It is used primarily for array indexing (see the
--   array package). <a>Ix</a> uses row-major order.
module GHC.Internal.Data.Ix

-- | The <a>Ix</a> class is used to map a contiguous subrange of values in
--   a type onto integers. It is used primarily for array indexing (see the
--   array package).
--   
--   The first argument <tt>(l,u)</tt> of each of these operations is a
--   pair specifying the lower and upper bounds of a contiguous subrange of
--   values.
--   
--   An implementation is entitled to assume the following laws about these
--   operations:
--   
--   <ul>
--   <li><tt><a>inRange</a> (l,u) i == <tt>elem</tt> i (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   <li><tt><a>range</a> (l,u) <tt>!!</tt> <a>index</a> (l,u) i == i</tt>,
--   when <tt><a>inRange</a> (l,u) i</tt></li>
--   <li><tt><a>map</a> (<a>index</a> (l,u)) (<a>range</a> (l,u))) ==
--   [0..<a>rangeSize</a> (l,u)-1]</tt> <tt> </tt></li>
--   <li><tt><a>rangeSize</a> (l,u) == <tt>length</tt> (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   </ul>
class Ord a => Ix a

-- | The list of values in the subrange defined by a bounding pair.
range :: Ix a => (a, a) -> [a]

-- | The position of a subscript in the subrange.
index :: Ix a => (a, a) -> a -> Int

-- | Returns <a>True</a> the given subscript lies in the range defined the
--   bounding pair.
inRange :: Ix a => (a, a) -> a -> Bool

-- | The size of the subrange defined by a bounding pair.
rangeSize :: Ix a => (a, a) -> Int

module GHC.Internal.Data.Functor.Utils
newtype Max a
Max :: Maybe a -> Max a
[getMax] :: Max a -> Maybe a
newtype Min a
Min :: Maybe a -> Min a
[getMin] :: Min a -> Maybe a
newtype StateL s a
StateL :: (s -> (s, a)) -> StateL s a
[runStateL] :: StateL s a -> s -> (s, a)
newtype StateR s a
StateR :: (s -> (s, a)) -> StateR s a
[runStateR] :: StateR s a -> s -> (s, a)

-- | A state transformer monad parameterized by the state and inner monad.
--   The implementation is copied from the transformers package with the
--   return tuple swapped.
newtype StateT s (m :: Type -> Type) a
StateT :: (s -> m (s, a)) -> StateT s (m :: Type -> Type) a
[runStateT] :: StateT s (m :: Type -> Type) a -> s -> m (s, a)
(#.) :: Coercible b c => (b -> c) -> (a -> b) -> a -> c
instance GHC.Internal.Base.Applicative (GHC.Internal.Data.Functor.Utils.StateL s)
instance GHC.Internal.Base.Applicative (GHC.Internal.Data.Functor.Utils.StateR s)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Applicative (GHC.Internal.Data.Functor.Utils.StateT s m)
instance GHC.Internal.Base.Functor (GHC.Internal.Data.Functor.Utils.StateL s)
instance GHC.Internal.Base.Functor (GHC.Internal.Data.Functor.Utils.StateR s)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Functor (GHC.Internal.Data.Functor.Utils.StateT s m)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (GHC.Internal.Data.Functor.Utils.StateT s m)
instance GHC.Classes.Ord a => GHC.Internal.Base.Monoid (GHC.Internal.Data.Functor.Utils.Max a)
instance GHC.Classes.Ord a => GHC.Internal.Base.Monoid (GHC.Internal.Data.Functor.Utils.Min a)
instance GHC.Classes.Ord a => GHC.Internal.Base.Semigroup (GHC.Internal.Data.Functor.Utils.Max a)
instance GHC.Classes.Ord a => GHC.Internal.Base.Semigroup (GHC.Internal.Data.Functor.Utils.Min a)


-- | GHC's array implementation.
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.Arr

-- | The <a>Ix</a> class is used to map a contiguous subrange of values in
--   a type onto integers. It is used primarily for array indexing (see the
--   array package).
--   
--   The first argument <tt>(l,u)</tt> of each of these operations is a
--   pair specifying the lower and upper bounds of a contiguous subrange of
--   values.
--   
--   An implementation is entitled to assume the following laws about these
--   operations:
--   
--   <ul>
--   <li><tt><a>inRange</a> (l,u) i == <tt>elem</tt> i (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   <li><tt><a>range</a> (l,u) <tt>!!</tt> <a>index</a> (l,u) i == i</tt>,
--   when <tt><a>inRange</a> (l,u) i</tt></li>
--   <li><tt><a>map</a> (<a>index</a> (l,u)) (<a>range</a> (l,u))) ==
--   [0..<a>rangeSize</a> (l,u)-1]</tt> <tt> </tt></li>
--   <li><tt><a>rangeSize</a> (l,u) == <tt>length</tt> (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   </ul>
class Ord a => Ix a

-- | The list of values in the subrange defined by a bounding pair.
range :: Ix a => (a, a) -> [a]

-- | The position of a subscript in the subrange.
index :: Ix a => (a, a) -> a -> Int

-- | Like <a>index</a>, but without checking that the value is in range.
unsafeIndex :: Ix a => (a, a) -> a -> Int

-- | Returns <a>True</a> the given subscript lies in the range defined the
--   bounding pair.
inRange :: Ix a => (a, a) -> a -> Bool

-- | The size of the subrange defined by a bounding pair.
rangeSize :: Ix a => (a, a) -> Int

-- | like <a>rangeSize</a>, but without checking that the upper bound is in
--   range.
unsafeRangeSize :: Ix a => (a, a) -> Int

-- | The type of immutable non-strict (boxed) arrays with indices in
--   <tt>i</tt> and elements in <tt>e</tt>.
data Array i e
Array :: !i -> !i -> {-# UNPACK #-} !Int -> Array# e -> Array i e

-- | Mutable, boxed, non-strict arrays in the <a>ST</a> monad. The type
--   arguments are as follows:
--   
--   <ul>
--   <li><tt>s</tt>: the state variable argument for the <a>ST</a>
--   type</li>
--   <li><tt>i</tt>: the index type of the array (should be an instance of
--   <a>Ix</a>)</li>
--   <li><tt>e</tt>: the element type of the array.</li>
--   </ul>
data STArray s i e
STArray :: !i -> !i -> {-# UNPACK #-} !Int -> MutableArray# s e -> STArray s i e
arrEleBottom :: a

-- | Construct an array with the specified bounds and containing values for
--   given indices within these bounds.
--   
--   The array is undefined (i.e. bottom) if any index in the list is out
--   of bounds. The Haskell 2010 Report further specifies that if any two
--   associations in the list have the same index, the value at that index
--   is undefined (i.e. bottom). However in GHC's implementation, the value
--   at such an index is the value part of the last association with that
--   index in the list.
--   
--   Because the indices must be checked for these errors, <a>array</a> is
--   strict in the bounds argument and in the indices of the association
--   list, but non-strict in the values. Thus, recurrences such as the
--   following are possible:
--   
--   <pre>
--   a = array (1,100) ((1,1) : [(i, i * a!(i-1)) | i &lt;- [2..100]])
--   </pre>
--   
--   Not every index within the bounds of the array need appear in the
--   association list, but the values associated with indices that do not
--   appear will be undefined (i.e. bottom).
--   
--   If, in any dimension, the lower bound is greater than the upper bound,
--   then the array is legal, but empty. Indexing an empty array always
--   gives an array-bounds error, but <a>bounds</a> still yields the bounds
--   with which the array was constructed.
array :: Ix i => (i, i) -> [(i, e)] -> Array i e

-- | Construct an array from a pair of bounds and a list of values in index
--   order.
listArray :: Ix i => (i, i) -> [e] -> Array i e

-- | The value at the given index in an array.
(!) :: Ix i => Array i e -> i -> e
infixl 9 !
safeRangeSize :: Ix i => (i, i) -> Int
negRange :: Int
safeIndex :: Ix i => (i, i) -> Int -> i -> Int

-- | Used to throw exceptions in array bounds-checking functions.
--   
--   ⚠ This function throws <tt>SomeException</tt> in all cases.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; badSafeIndex 2 5
--   *** Exception: Error in array index; 2 not in range [0..5)
--   </pre>
badSafeIndex :: Int -> Int -> Int

-- | The bounds with which an array was constructed.
bounds :: Array i e -> (i, i)

-- | The number of elements in the array.
numElements :: Array i e -> Int
numElementsSTArray :: STArray s i e -> Int

-- | The list of indices of an array in ascending order.
indices :: Ix i => Array i e -> [i]

-- | The list of elements of an array in index order.
elems :: Array i e -> [e]

-- | The list of associations of an array in index order.
assocs :: Ix i => Array i e -> [(i, e)]

-- | The <a>accumArray</a> function deals with repeated indices in the
--   association list using an <i>accumulating function</i> which combines
--   the values of associations with the same index.
--   
--   For example, given a list of values of some index type, <tt>hist</tt>
--   produces a histogram of the number of occurrences of each index within
--   a specified range:
--   
--   <pre>
--   hist :: (Ix a, Num b) =&gt; (a,a) -&gt; [a] -&gt; Array a b
--   hist bnds is = accumArray (+) 0 bnds [(i, 1) | i&lt;-is, inRange bnds i]
--   </pre>
--   
--   <tt>accumArray</tt> is strict in each result of applying the
--   accumulating function, although it is lazy in the initial value. Thus,
--   unlike arrays built with <a>array</a>, accumulated arrays should not
--   in general be recursive.
accumArray :: Ix i => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
adjust :: (e -> a -> e) -> MutableArray# s e -> (Int, a) -> STRep s b -> STRep s b

-- | Constructs an array identical to the first argument except that it has
--   been updated by the associations in the right argument. For example,
--   if <tt>m</tt> is a 1-origin, <tt>n</tt> by <tt>n</tt> matrix, then
--   
--   <pre>
--   m//[((i,i), 0) | i &lt;- [1..n]]
--   </pre>
--   
--   is the same matrix, except with the diagonal zeroed.
--   
--   Repeated indices in the association list are handled as for
--   <a>array</a>: Haskell 2010 specifies that the resulting array is
--   undefined (i.e. bottom), but GHC's implementation uses the last
--   association for each index.
(//) :: Ix i => Array i e -> [(i, e)] -> Array i e
infixl 9 //

-- | <tt><a>accum</a> f</tt> takes an array and an association list and
--   accumulates pairs from the list into the array with the accumulating
--   function <tt>f</tt>. Thus <a>accumArray</a> can be defined using
--   <a>accum</a>:
--   
--   <pre>
--   accumArray f z b = accum f (array b [(i, z) | i &lt;- range b])
--   </pre>
--   
--   <tt>accum</tt> is strict in all the results of applying the
--   accumulation. However, it is lazy in the initial values of the array.
accum :: Ix i => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e
amap :: (a -> b) -> Array i a -> Array i b

-- | <a>ixmap</a> allows for transformations on array indices. It may be
--   thought of as providing function composition on the right with the
--   mapping that the original array embodies.
--   
--   A similar transformation of array values may be achieved using
--   <a>fmap</a> from the <a>Array</a> instance of the <a>Functor</a>
--   class.
ixmap :: (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
eqArray :: (Ix i, Eq e) => Array i e -> Array i e -> Bool
cmpArray :: (Ix i, Ord e) => Array i e -> Array i e -> Ordering
cmpIntArray :: Ord e => Array Int e -> Array Int e -> Ordering
newSTArray :: Ix i => (i, i) -> e -> ST s (STArray s i e)
boundsSTArray :: STArray s i e -> (i, i)
readSTArray :: Ix i => STArray s i e -> i -> ST s e
writeSTArray :: Ix i => STArray s i e -> i -> e -> ST s ()
freezeSTArray :: STArray s i e -> ST s (Array i e)
thawSTArray :: Array i e -> ST s (STArray s i e)

-- | A left fold over the elements
foldlElems :: (b -> a -> b) -> b -> Array i a -> b

-- | A strict left fold over the elements
foldlElems' :: (b -> a -> b) -> b -> Array i a -> b

-- | A left fold over the elements with no starting value
foldl1Elems :: (a -> a -> a) -> Array i a -> a

-- | A right fold over the elements
foldrElems :: (a -> b -> b) -> b -> Array i a -> b

-- | A strict right fold over the elements
foldrElems' :: (a -> b -> b) -> b -> Array i a -> b

-- | A right fold over the elements with no starting value
foldr1Elems :: (a -> a -> a) -> Array i a -> a
fill :: MutableArray# s e -> (Int, e) -> STRep s a -> STRep s a
done :: i -> i -> Int -> MutableArray# s e -> STRep s (Array i e)
unsafeArray :: Ix i => (i, i) -> [(Int, e)] -> Array i e
unsafeArray' :: (i, i) -> Int -> [(Int, e)] -> Array i e
lessSafeIndex :: Ix i => (i, i) -> Int -> i -> Int
unsafeAt :: Array i e -> Int -> e
unsafeReplace :: Array i e -> [(Int, e)] -> Array i e
unsafeAccumArray :: Ix i => (e -> a -> e) -> e -> (i, i) -> [(Int, a)] -> Array i e
unsafeAccumArray' :: (e -> a -> e) -> e -> (i, i) -> Int -> [(Int, a)] -> Array i e
unsafeAccum :: (e -> a -> e) -> Array i e -> [(Int, a)] -> Array i e
unsafeReadSTArray :: STArray s i e -> Int -> ST s e
unsafeWriteSTArray :: STArray s i e -> Int -> e -> ST s ()
unsafeFreezeSTArray :: STArray s i e -> ST s (Array i e)
unsafeThawSTArray :: Array i e -> ST s (STArray s i e)
instance (GHC.Internal.Ix.Ix i, GHC.Classes.Eq e) => GHC.Classes.Eq (GHC.Internal.Arr.Array i e)
instance GHC.Classes.Eq (GHC.Internal.Arr.STArray s i e)
instance GHC.Internal.Base.Functor (GHC.Internal.Arr.Array i)
instance (GHC.Internal.Ix.Ix i, GHC.Classes.Ord e) => GHC.Classes.Ord (GHC.Internal.Arr.Array i e)
instance (GHC.Internal.Ix.Ix a, GHC.Internal.Show.Show a, GHC.Internal.Show.Show b) => GHC.Internal.Show.Show (GHC.Internal.Arr.Array a b)


-- | This module defines bitwise operations for signed and unsigned
--   integers. Instances of the class <a>Bits</a> for the <a>Int</a> and
--   <a>Integer</a> types are available from this module, and instances for
--   explicitly sized integral types are available from the <a>Data.Int</a>
--   and <a>Data.Word</a> modules.
module GHC.Internal.Bits

-- | The <a>Bits</a> class defines bitwise operations over integral types.
--   
--   <ul>
--   <li>Bits are numbered from 0 with bit 0 being the least significant
--   bit.</li>
--   </ul>
class Eq a => Bits a

-- | Bitwise "and"
(.&.) :: Bits a => a -> a -> a

-- | Bitwise "or"
(.|.) :: Bits a => a -> a -> a

-- | Bitwise "xor"
xor :: Bits a => a -> a -> a

-- | Reverse all the bits in the argument
complement :: Bits a => a -> a

-- | <tt><a>shift</a> x i</tt> shifts <tt>x</tt> left by <tt>i</tt> bits if
--   <tt>i</tt> is positive, or right by <tt>-i</tt> bits otherwise. Right
--   shifts perform sign extension on signed number types; i.e. they fill
--   the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   An instance can define either this unified <a>shift</a> or
--   <a>shiftL</a> and <a>shiftR</a>, depending on which is more convenient
--   for the type in question.
shift :: Bits a => a -> Int -> a

-- | <tt><a>rotate</a> x i</tt> rotates <tt>x</tt> left by <tt>i</tt> bits
--   if <tt>i</tt> is positive, or right by <tt>-i</tt> bits otherwise.
--   
--   For unbounded types like <a>Integer</a>, <a>rotate</a> is equivalent
--   to <a>shift</a>.
--   
--   An instance can define either this unified <a>rotate</a> or
--   <a>rotateL</a> and <a>rotateR</a>, depending on which is more
--   convenient for the type in question.
rotate :: Bits a => a -> Int -> a

-- | <a>zeroBits</a> is the value with all bits unset.
--   
--   The following laws ought to hold (for all valid bit indices
--   <tt><i>n</i></tt>):
--   
--   <ul>
--   <li><pre><a>clearBit</a> <a>zeroBits</a> <i>n</i> ==
--   <a>zeroBits</a></pre></li>
--   <li><pre><a>setBit</a> <a>zeroBits</a> <i>n</i> == <a>bit</a>
--   <i>n</i></pre></li>
--   <li><pre><a>testBit</a> <a>zeroBits</a> <i>n</i> == False</pre></li>
--   <li><pre><a>popCount</a> <a>zeroBits</a> == 0</pre></li>
--   </ul>
--   
--   This method uses <tt><a>clearBit</a> (<a>bit</a> 0) 0</tt> as its
--   default implementation (which ought to be equivalent to
--   <a>zeroBits</a> for types which possess a 0th bit).
zeroBits :: Bits a => a

-- | <tt>bit <i>i</i></tt> is a value with the <tt><i>i</i></tt>th bit set
--   and all other bits clear.
--   
--   Can be implemented using <tt>bitDefault</tt> if <tt>a</tt> is also an
--   instance of <a>Num</a>.
--   
--   See also <a>zeroBits</a>.
bit :: Bits a => Int -> a

-- | <tt>x `setBit` i</tt> is the same as <tt>x .|. bit i</tt>
setBit :: Bits a => a -> Int -> a

-- | <tt>x `clearBit` i</tt> is the same as <tt>x .&amp;. complement (bit
--   i)</tt>
clearBit :: Bits a => a -> Int -> a

-- | <tt>x `complementBit` i</tt> is the same as <tt>x `xor` bit i</tt>
complementBit :: Bits a => a -> Int -> a

-- | <tt>x `testBit` i</tt> is the same as <tt>x .&amp;. bit n /= 0</tt>
--   
--   In other words it returns True if the bit at offset @n is set.
--   
--   Can be implemented using <tt>testBitDefault</tt> if <tt>a</tt> is also
--   an instance of <a>Num</a>.
testBit :: Bits a => a -> Int -> Bool

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. Returns Nothing for types that do
--   not have a fixed bitsize, like <a>Integer</a>.
bitSizeMaybe :: Bits a => a -> Maybe Int

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. The function <a>bitSize</a> is
--   undefined for types that do not have a fixed bitsize, like
--   <a>Integer</a>.
--   
--   Default implementation based upon <a>bitSizeMaybe</a> provided since
--   4.12.0.0.

-- | <i>Deprecated: Use <a>bitSizeMaybe</a> or <a>finiteBitSize</a>
--   instead</i>
bitSize :: Bits a => a -> Int

-- | Return <a>True</a> if the argument is a signed type. The actual value
--   of the argument is ignored
isSigned :: Bits a => a -> Bool

-- | Shift the argument left by the specified number of bits (which must be
--   non-negative). Some instances may throw an <a>Overflow</a> exception
--   if given a negative input.
--   
--   An instance can define either this and <a>shiftR</a> or the unified
--   <a>shift</a>, depending on which is more convenient for the type in
--   question.
shiftL :: Bits a => a -> Int -> a

-- | Shift the argument left by the specified number of bits. The result is
--   undefined for negative shift amounts and shift amounts greater or
--   equal to the <a>bitSize</a>.
--   
--   Defaults to <a>shiftL</a> unless defined explicitly by an instance.
unsafeShiftL :: Bits a => a -> Int -> a

-- | Shift the first argument right by the specified number of bits. The
--   result is undefined for negative shift amounts and shift amounts
--   greater or equal to the <a>bitSize</a>. Some instances may throw an
--   <a>Overflow</a> exception if given a negative input.
--   
--   Right shifts perform sign extension on signed number types; i.e. they
--   fill the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   An instance can define either this and <a>shiftL</a> or the unified
--   <a>shift</a>, depending on which is more convenient for the type in
--   question.
shiftR :: Bits a => a -> Int -> a

-- | Shift the first argument right by the specified number of bits, which
--   must be non-negative and smaller than the number of bits in the type.
--   
--   Right shifts perform sign extension on signed number types; i.e. they
--   fill the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   Defaults to <a>shiftR</a> unless defined explicitly by an instance.
unsafeShiftR :: Bits a => a -> Int -> a

-- | Rotate the argument left by the specified number of bits (which must
--   be non-negative).
--   
--   An instance can define either this and <a>rotateR</a> or the unified
--   <a>rotate</a>, depending on which is more convenient for the type in
--   question.
rotateL :: Bits a => a -> Int -> a

-- | Rotate the argument right by the specified number of bits (which must
--   be non-negative).
--   
--   An instance can define either this and <a>rotateL</a> or the unified
--   <a>rotate</a>, depending on which is more convenient for the type in
--   question.
rotateR :: Bits a => a -> Int -> a

-- | Return the number of set bits in the argument. This number is known as
--   the population count or the Hamming weight.
--   
--   Can be implemented using <tt>popCountDefault</tt> if <tt>a</tt> is
--   also an instance of <a>Num</a>.
popCount :: Bits a => a -> Int
infixl 7 .&.
infixl 5 .|.
infixl 6 `xor`
infixl 8 `shift`
infixl 8 `rotate`
infixl 8 `shiftL`
infixl 8 `shiftR`
infixl 8 `rotateL`
infixl 8 `rotateR`

-- | The <a>FiniteBits</a> class denotes types with a finite, fixed number
--   of bits.
class Bits b => FiniteBits b

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. Moreover, <a>finiteBitSize</a> is
--   total, in contrast to the deprecated <a>bitSize</a> function it
--   replaces.
--   
--   <pre>
--   <a>finiteBitSize</a> = <a>bitSize</a>
--   <a>bitSizeMaybe</a> = <a>Just</a> . <a>finiteBitSize</a>
--   </pre>
finiteBitSize :: FiniteBits b => b -> Int

-- | Count number of zero bits preceding the most significant set bit.
--   
--   <pre>
--   <a>countLeadingZeros</a> (<a>zeroBits</a> :: a) = finiteBitSize (<a>zeroBits</a> :: a)
--   </pre>
--   
--   <a>countLeadingZeros</a> can be used to compute log base 2 via
--   
--   <pre>
--   logBase2 x = <a>finiteBitSize</a> x - 1 - <a>countLeadingZeros</a> x
--   </pre>
--   
--   Note: The default implementation for this method is intentionally
--   naive. However, the instances provided for the primitive integral
--   types are implemented using CPU specific machine instructions.
countLeadingZeros :: FiniteBits b => b -> Int

-- | Count number of zero bits following the least significant set bit.
--   
--   <pre>
--   <a>countTrailingZeros</a> (<a>zeroBits</a> :: a) = finiteBitSize (<a>zeroBits</a> :: a)
--   <a>countTrailingZeros</a> . <a>negate</a> = <a>countTrailingZeros</a>
--   </pre>
--   
--   The related <a>find-first-set operation</a> can be expressed in terms
--   of <a>countTrailingZeros</a> as follows
--   
--   <pre>
--   findFirstSet x = 1 + <a>countTrailingZeros</a> x
--   </pre>
--   
--   Note: The default implementation for this method is intentionally
--   naive. However, the instances provided for the primitive integral
--   types are implemented using CPU specific machine instructions.
countTrailingZeros :: FiniteBits b => b -> Int

-- | Default implementation for <a>bit</a>.
--   
--   Note that: <tt>bitDefault i = 1 <a>shiftL</a> i</tt>
bitDefault :: (Bits a, Num a) => Int -> a

-- | Default implementation for <a>testBit</a>.
--   
--   Note that: <tt>testBitDefault x i = (x .&amp;. bit i) /= 0</tt>
testBitDefault :: (Bits a, Num a) => a -> Int -> Bool

-- | Default implementation for <a>popCount</a>.
--   
--   This implementation is intentionally naive. Instances are expected to
--   provide an optimized implementation for their size.
popCountDefault :: (Bits a, Num a) => a -> Int

-- | Attempt to convert an <a>Integral</a> type <tt>a</tt> to an
--   <a>Integral</a> type <tt>b</tt> using the size of the types as
--   measured by <a>Bits</a> methods.
--   
--   A simpler version of this function is:
--   
--   <pre>
--   toIntegral :: (Integral a, Integral b) =&gt; a -&gt; Maybe b
--   toIntegral x
--     | toInteger x == toInteger y = Just y
--     | otherwise                  = Nothing
--     where
--       y = fromIntegral x
--   </pre>
--   
--   This version requires going through <a>Integer</a>, which can be
--   inefficient. However, <tt>toIntegralSized</tt> is optimized to allow
--   GHC to statically determine the relative type sizes (as measured by
--   <a>bitSizeMaybe</a> and <a>isSigned</a>) and avoid going through
--   <a>Integer</a> for many types. (The implementation uses
--   <a>fromIntegral</a>, which is itself optimized with rules for
--   <tt>base</tt> types but may go through <a>Integer</a> for some type
--   pairs.)
toIntegralSized :: (Integral a, Integral b, Bits a, Bits b) => a -> Maybe b
instance GHC.Internal.Bits.Bits GHC.Types.Bool
instance GHC.Internal.Bits.Bits GHC.Types.Int
instance GHC.Internal.Bits.Bits GHC.Num.Integer.Integer
instance GHC.Internal.Bits.Bits GHC.Num.Natural.Natural
instance GHC.Internal.Bits.Bits GHC.Types.Word
instance GHC.Internal.Bits.FiniteBits GHC.Types.Bool
instance GHC.Internal.Bits.FiniteBits GHC.Types.Int
instance GHC.Internal.Bits.FiniteBits GHC.Types.Word


-- | Converting values to readable strings: the <a>Show</a> class and
--   associated functions.
module GHC.Internal.Text.Show

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: Show a => a -> ShowS

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS

-- | Show a list (using square brackets and commas), given a function for
--   showing elements.
showListWith :: (a -> ShowS) -> [a] -> ShowS


-- | This module exports:
--   
--   <ul>
--   <li>The <a>TypeError</a> type family, which is used to provide custom
--   type errors. This is a type-level analogue to the term level error
--   function.</li>
--   <li>The <a>ErrorMessage</a> kind, used to define custom error
--   messages.</li>
--   <li>The <a>Unsatisfiable</a> constraint, a more principled variant of
--   <a>TypeError</a> which gives a more predictable way of reporting
--   custom type errors.</li>
--   </ul>
module GHC.Internal.TypeError

-- | A description of a custom type error.
data ErrorMessage

-- | Show the text as is.
Text :: Symbol -> ErrorMessage

-- | Pretty print the type. <tt>ShowType :: k -&gt; ErrorMessage</tt>
ShowType :: t -> ErrorMessage

-- | Put two pieces of error message next to each other.
(:<>:) :: ErrorMessage -> ErrorMessage -> ErrorMessage

-- | Stack two pieces of error message on top of each other.
(:$$:) :: ErrorMessage -> ErrorMessage -> ErrorMessage
infixl 6 :<>:
infixl 5 :$$:

-- | The type-level equivalent of <a>error</a>.
--   
--   The polymorphic kind of this type allows it to be used in several
--   settings. For instance, it can be used as a constraint, e.g. to
--   provide a better error message for a non-existent instance,
--   
--   <pre>
--   -- in a context
--   instance TypeError (Text "Cannot <tt>Show</tt> functions." :$$:
--                       Text "Perhaps there is a missing argument?")
--         =&gt; Show (a -&gt; b) where
--       showsPrec = error "unreachable"
--   </pre>
--   
--   It can also be placed on the right-hand side of a type-level function
--   to provide an error for an invalid case,
--   
--   <pre>
--   type family ByteSize x where
--      ByteSize Word16   = 2
--      ByteSize Word8    = 1
--      ByteSize a        = TypeError (Text "The type " :&lt;&gt;: ShowType a :&lt;&gt;:
--                                     Text " is not exportable.")
--   </pre>
type family TypeError (a :: ErrorMessage) :: b

-- | A type-level assert function.
--   
--   If the first argument evaluates to true, then the empty constraint is
--   returned, otherwise the second argument (which is intended to be
--   something which reduces to <a>TypeError</a> is used).
--   
--   For example, given some type level predicate <tt>P' :: Type -&gt;
--   Bool</tt>, it is possible to write the type synonym
--   
--   <pre>
--   type P a = Assert (P' a) (NotPError a)
--   </pre>
--   
--   where <tt>NotPError</tt> reduces to a <tt>TypeError</tt> which is
--   reported if the assertion fails.
type family Assert (check :: Bool) errMsg

-- | An unsatisfiable constraint. Similar to <a>TypeError</a> when used at
--   the <a>Constraint</a> kind, but reports errors in a more predictable
--   manner.
--   
--   See also the <a>unsatisfiable</a> function.
--   
--   <tt>since base-4.19.0.0</tt>.
class Unsatisfiable (msg :: ErrorMessage)

-- | Prove anything within a context with an <a>Unsatisfiable</a>
--   constraint.
--   
--   This is useful for filling in instance methods when there is an
--   <a>Unsatisfiable</a> constraint in the instance head, e.g.:
--   
--   <pre>
--   instance Unsatisfiable (Text "No Eq instance for functions") =&gt; Eq (a -&gt; b) where
--   </pre>
--   
--   (==) = unsatisfiable
--   
--   <tt>since base-4.19.0.0</tt>.
unsatisfiable :: forall (msg :: ErrorMessage) a. Unsatisfiable msg => a


-- | <b>Do not use this module.</b> Use <a>GHC.TypeLits</a> instead.
--   
--   This module is internal-only and was exposed by accident. It may be
--   removed without warning in a future version.
--   
--   <i>The API of this module is unstable and is tightly coupled to GHC's
--   internals.</i> If depend on it, make sure to use a tight upper bound,
--   e.g., <tt>base &lt; 4.X</tt> rather than <tt>base &lt; 5</tt>, because
--   the interface can change rapidly without much warning.
--   
--   The technical reason for this module's existence is that it is needed
--   to prevent module cycles while still allowing these identifiers to be
--   imported in <a>Data.Type.Ord</a>.
module GHC.Internal.TypeLits.Internal

-- | (Kind) This is the kind of type-level symbols.
data Symbol

-- | Comparison of type-level symbols, as a function.
type family CmpSymbol (a :: Symbol) (b :: Symbol) :: Ordering

-- | Comparison of type-level characters.
type family CmpChar (a :: Char) (b :: Char) :: Ordering

module GHC.Internal.TypeNats.Internal

-- | Natural number
--   
--   Invariant: numbers &lt;= 0xffffffffffffffff use the <a>NS</a>
--   constructor
data Natural

-- | Comparison of type-level naturals, as a function.
type family CmpNat (a :: Natural) (b :: Natural) :: Ordering

module GHC.Internal.Unsafe.Coerce

-- | <a>unsafeCoerce</a> coerces a value from one type to another,
--   bypassing the type-checker.
--   
--   There are several legitimate ways to use <a>unsafeCoerce</a>:
--   
--   <ol>
--   <li>To coerce a lifted type such as <tt>Int</tt> to <tt>Any</tt>, put
--   it in a list of <tt>Any</tt>, and then later coerce it back to
--   <tt>Int</tt> before using it.</li>
--   <li>To produce e.g. <tt>(a+b) :~: (b+a)</tt> from <tt>unsafeCoerce
--   Refl</tt>. Here the two sides really are the same type -- so nothing
--   unsafe is happening -- but GHC is not clever enough to see it.</li>
--   <li>In <tt>Data.Typeable</tt> we have</li>
--   </ol>
--   
--   <pre>
--   eqTypeRep :: forall k1 k2 (a :: k1) (b :: k2).
--                TypeRep a -&gt; TypeRep b -&gt; Maybe (a :~~: b)
--   eqTypeRep a b
--     | sameTypeRep a b = Just (unsafeCoerce HRefl)
--     | otherwise       = Nothing
--   
--   </pre>
--   
--   Here again, the <tt>unsafeCoerce HRefl</tt> is safe, because the two
--   types really are the same -- but the proof of that relies on the
--   complex, trusted implementation of <tt>Typeable</tt>.
--   
--   <ol>
--   <li>(superseded) The "reflection trick", which takes advantage of the
--   fact that in <tt>class C a where { op :: ty }</tt>, we can safely
--   coerce between <tt>C a</tt> and <tt>ty</tt> (which have different
--   kinds!) because it's really just a newtype. Note: there is <i>no
--   guarantee, at all</i> that this behavior will be supported into
--   perpetuity. It is now preferred to use <a>withDict</a> in
--   <tt>GHC.Magic.Dict</tt>, which is type-safe. See Note [withDict] in
--   GHC.Tc.Instance.Class for details.</li>
--   <li>(superseded) Casting between two types which have exactly the same
--   structure: between a newtype of T and T, or between types which differ
--   only in "phantom" type parameters. It is now preferred to use
--   <a>coerce</a> from <tt>Data.Coerce</tt>, which is type-safe.</li>
--   </ol>
--   
--   Other uses of <a>unsafeCoerce</a> are undefined. In particular, you
--   should not use <a>unsafeCoerce</a> to cast a T to an algebraic data
--   type D, unless T is also an algebraic data type. For example, do not
--   cast <tt><a>Int</a>-&gt;<a>Int</a></tt> to <a>Bool</a>, even if you
--   later cast that <a>Bool</a> back to <tt><a>Int</a>-&gt;<a>Int</a></tt>
--   before applying it. The reasons have to do with GHC's internal
--   representation details (for the cognoscenti, data values can be
--   entered but function closures cannot). If you want a safe type to cast
--   things to, use <a>Any</a>, which is not an algebraic data type.
unsafeCoerce :: a -> b
unsafeCoerceUnlifted :: forall (a :: UnliftedType) (b :: UnliftedType). a -> b
unsafeCoerceAddr :: forall (a :: TYPE 'AddrRep) (b :: TYPE 'AddrRep). a -> b
unsafeEqualityProof :: forall {k} (a :: k) (b :: k). UnsafeEquality a b

-- | This type is treated magically within GHC. Any pattern match of the
--   form <tt>case unsafeEqualityProof of UnsafeRefl -&gt; body</tt> gets
--   transformed just into <tt>body</tt>. This is ill-typed, but the
--   transformation takes place after type-checking is complete. It is used
--   to implement <a>unsafeCoerce</a>. You probably don't want to use
--   <a>UnsafeRefl</a> in an expression, but you might conceivably want to
--   pattern-match on it. Use <a>unsafeEqualityProof</a> to create one of
--   these.
data UnsafeEquality (a :: k) (b :: k)
[UnsafeRefl] :: forall {k} (a :: k). UnsafeEquality a a

-- | Highly, terribly dangerous coercion from one representation type to
--   another. Misuse of this function can invite the garbage collector to
--   trounce upon your data and then laugh in your face. You don't want
--   this function. Really.
--   
--   This becomes more obvious when looking at its actual type: <tt>forall
--   (r1 :: RuntimeRep) (r2 :: RuntimeRep) (a :: TYPE r1) (b :: TYPE r2). a
--   -&gt; b</tt> Which often get's rendered as <tt>a -&gt; b</tt> in
--   haddock for technical reasons.
unsafeCoerce# :: a -> b


-- | Legacy interface for arrays of arrays. Deprecated, because the
--   <a>Array#</a> type can now store arrays directly. Consider simply
--   using <a>Array#</a> instead of <a>ArrayArray#</a>.
--   
--   Use GHC.Internal.Exts instead of importing this module directly.
module GHC.Internal.ArrayArray
newtype ArrayArray# :: UnliftedType
ArrayArray# :: Array# ByteArray# -> ArrayArray#
newtype MutableArrayArray# s :: UnliftedType
MutableArrayArray# :: MutableArray# s ByteArray# -> MutableArrayArray# s

-- | Create a new mutable array of arrays with the specified number of
--   elements, in the specified state thread, with each element recursively
--   referring to the newly created array.
newArrayArray# :: Int# -> State# s -> (# State# s, MutableArrayArray# s #)

-- | Make a mutable array of arrays immutable, without copying.
unsafeFreezeArrayArray# :: MutableArrayArray# s -> State# s -> (# State# s, ArrayArray# #)

-- | Return the number of elements in the array.
sizeofArrayArray# :: ArrayArray# -> Int#

-- | Return the number of elements in the array.
sizeofMutableArrayArray# :: MutableArrayArray# s -> Int#
indexByteArrayArray# :: ArrayArray# -> Int# -> ByteArray#
indexArrayArrayArray# :: ArrayArray# -> Int# -> ArrayArray#
readByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ByteArray# #)
readMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
readArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ArrayArray# #)
readMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableArrayArray# s #)
writeByteArrayArray# :: MutableArrayArray# s -> Int# -> ByteArray# -> State# s -> State# s
writeMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> MutableByteArray# s -> State# s -> State# s
writeArrayArrayArray# :: MutableArrayArray# s -> Int# -> ArrayArray# -> State# s -> State# s
writeMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> State# s -> State# s

-- | Copy a range of the <a>ArrayArray#</a> to the specified region in the
--   <a>MutableArrayArray#</a>. Both arrays must fully contain the
--   specified ranges, but this is not checked. The two arrays must not be
--   the same array in different states, but this is not checked either.
copyArrayArray# :: ArrayArray# -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s

-- | Copy a range of the first MutableArrayArray# to the specified region
--   in the second MutableArrayArray#. Both arrays must fully contain the
--   specified ranges, but this is not checked. The regions are allowed to
--   overlap, although this is only possible when the same array is
--   provided as both the source and the destination.
copyMutableArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s

-- | Compare the underlying pointers of two arrays of arrays.
sameArrayArray# :: ArrayArray# -> ArrayArray# -> Int#

-- | Compare the underlying pointers of two mutable arrays of arrays.
sameMutableArrayArray# :: MutableArrayArray# s -> MutableArrayArray# s -> Int#


-- | Sized unsigned integral types: <a>Word</a>, <a>Word8</a>,
--   <a>Word16</a>, <a>Word32</a>, and <a>Word64</a>.
module GHC.Internal.Word

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word
W# :: Word# -> Word

-- | 8-bit unsigned integer type
data Word8
W8# :: Word8# -> Word8

-- | 16-bit unsigned integer type
data Word16
W16# :: Word16# -> Word16

-- | 32-bit unsigned integer type
data Word32
W32# :: Word32# -> Word32

-- | 64-bit unsigned integer type
data Word64
W64# :: Word64# -> Word64
uncheckedShiftL64# :: Word64# -> Int# -> Word64#
uncheckedShiftRL64# :: Word64# -> Int# -> Word64#

-- | Reverse order of bytes in <a>Word16</a>.
byteSwap16 :: Word16 -> Word16

-- | Reverse order of bytes in <a>Word32</a>.
byteSwap32 :: Word32 -> Word32

-- | Reverse order of bytes in <a>Word64</a>.
byteSwap64 :: Word64 -> Word64

-- | Reverse the order of the bits in a <a>Word8</a>.
bitReverse8 :: Word8 -> Word8

-- | Reverse the order of the bits in a <a>Word16</a>.
bitReverse16 :: Word16 -> Word16

-- | Reverse the order of the bits in a <a>Word32</a>.
bitReverse32 :: Word32 -> Word32

-- | Reverse the order of the bits in a <a>Word64</a>.
bitReverse64 :: Word64 -> Word64
eqWord :: Word -> Word -> Bool
neWord :: Word -> Word -> Bool
gtWord :: Word -> Word -> Bool
geWord :: Word -> Word -> Bool
ltWord :: Word -> Word -> Bool
leWord :: Word -> Word -> Bool
eqWord8 :: Word8 -> Word8 -> Bool
neWord8 :: Word8 -> Word8 -> Bool
gtWord8 :: Word8 -> Word8 -> Bool
geWord8 :: Word8 -> Word8 -> Bool
ltWord8 :: Word8 -> Word8 -> Bool
leWord8 :: Word8 -> Word8 -> Bool
eqWord16 :: Word16 -> Word16 -> Bool
neWord16 :: Word16 -> Word16 -> Bool
gtWord16 :: Word16 -> Word16 -> Bool
geWord16 :: Word16 -> Word16 -> Bool
ltWord16 :: Word16 -> Word16 -> Bool
leWord16 :: Word16 -> Word16 -> Bool
eqWord32 :: Word32 -> Word32 -> Bool
neWord32 :: Word32 -> Word32 -> Bool
gtWord32 :: Word32 -> Word32 -> Bool
geWord32 :: Word32 -> Word32 -> Bool
ltWord32 :: Word32 -> Word32 -> Bool
leWord32 :: Word32 -> Word32 -> Bool
eqWord64 :: Word64 -> Word64 -> Bool
neWord64 :: Word64 -> Word64 -> Bool
gtWord64 :: Word64 -> Word64 -> Bool
geWord64 :: Word64 -> Word64 -> Bool
ltWord64 :: Word64 -> Word64 -> Bool
leWord64 :: Word64 -> Word64 -> Bool
instance GHC.Internal.Bits.Bits GHC.Internal.Word.Word16
instance GHC.Internal.Bits.Bits GHC.Internal.Word.Word32
instance GHC.Internal.Bits.Bits GHC.Internal.Word.Word64
instance GHC.Internal.Bits.Bits GHC.Internal.Word.Word8
instance GHC.Internal.Enum.Bounded GHC.Internal.Word.Word16
instance GHC.Internal.Enum.Bounded GHC.Internal.Word.Word32
instance GHC.Internal.Enum.Bounded GHC.Internal.Word.Word64
instance GHC.Internal.Enum.Bounded GHC.Internal.Word.Word8
instance GHC.Internal.Enum.Enum GHC.Internal.Word.Word16
instance GHC.Internal.Enum.Enum GHC.Internal.Word.Word32
instance GHC.Internal.Enum.Enum GHC.Internal.Word.Word64
instance GHC.Internal.Enum.Enum GHC.Internal.Word.Word8
instance GHC.Classes.Eq GHC.Internal.Word.Word16
instance GHC.Classes.Eq GHC.Internal.Word.Word32
instance GHC.Classes.Eq GHC.Internal.Word.Word64
instance GHC.Classes.Eq GHC.Internal.Word.Word8
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Word.Word16
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Word.Word32
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Word.Word64
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Word.Word8
instance GHC.Internal.Real.Integral GHC.Internal.Word.Word16
instance GHC.Internal.Real.Integral GHC.Internal.Word.Word32
instance GHC.Internal.Real.Integral GHC.Internal.Word.Word64
instance GHC.Internal.Real.Integral GHC.Internal.Word.Word8
instance GHC.Internal.Ix.Ix GHC.Internal.Word.Word16
instance GHC.Internal.Ix.Ix GHC.Internal.Word.Word32
instance GHC.Internal.Ix.Ix GHC.Internal.Word.Word64
instance GHC.Internal.Ix.Ix GHC.Internal.Word.Word8
instance GHC.Internal.Num.Num GHC.Internal.Word.Word16
instance GHC.Internal.Num.Num GHC.Internal.Word.Word32
instance GHC.Internal.Num.Num GHC.Internal.Word.Word64
instance GHC.Internal.Num.Num GHC.Internal.Word.Word8
instance GHC.Classes.Ord GHC.Internal.Word.Word16
instance GHC.Classes.Ord GHC.Internal.Word.Word32
instance GHC.Classes.Ord GHC.Internal.Word.Word64
instance GHC.Classes.Ord GHC.Internal.Word.Word8
instance GHC.Internal.Real.Real GHC.Internal.Word.Word16
instance GHC.Internal.Real.Real GHC.Internal.Word.Word32
instance GHC.Internal.Real.Real GHC.Internal.Word.Word64
instance GHC.Internal.Real.Real GHC.Internal.Word.Word8
instance GHC.Internal.Show.Show GHC.Internal.Word.Word16
instance GHC.Internal.Show.Show GHC.Internal.Word.Word32
instance GHC.Internal.Show.Show GHC.Internal.Word.Word64
instance GHC.Internal.Show.Show GHC.Internal.Word.Word8


-- | Implementations for the character predicates (isLower, isUpper, etc.)
--   and the conversions (toUpper, toLower). The implementation uses
--   libunicode on Unix systems if that is available.
module GHC.Internal.Unicode

-- | Version of Unicode standard used by <tt>base</tt>: <a>16.0.0</a>.
unicodeVersion :: Version

-- | Unicode General Categories (column 2 of the UnicodeData table) in the
--   order they are listed in the Unicode standard (the Unicode Character
--   Database, in particular).
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; :t OtherLetter
--   OtherLetter :: GeneralCategory
--   </pre>
--   
--   <a>Eq</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; UppercaseLetter == UppercaseLetter
--   True
--   
--   &gt;&gt;&gt; UppercaseLetter == LowercaseLetter
--   False
--   </pre>
--   
--   <a>Ord</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; NonSpacingMark &lt;= MathSymbol
--   True
--   </pre>
--   
--   <a>Enum</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; enumFromTo ModifierLetter SpacingCombiningMark
--   [ModifierLetter,OtherLetter,NonSpacingMark,SpacingCombiningMark]
--   </pre>
--   
--   <a>Read</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; read "DashPunctuation" :: GeneralCategory
--   DashPunctuation
--   
--   &gt;&gt;&gt; read "17" :: GeneralCategory
--   *** Exception: Prelude.read: no parse
--   </pre>
--   
--   <a>Show</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; show EnclosingMark
--   "EnclosingMark"
--   </pre>
--   
--   <a>Bounded</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; minBound :: GeneralCategory
--   UppercaseLetter
--   
--   &gt;&gt;&gt; maxBound :: GeneralCategory
--   NotAssigned
--   </pre>
--   
--   <a>Ix</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; import GHC.Internal.Data.Ix ( index )
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) FinalQuote
--   12
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) Format
--   *** Exception: Error in array index
--   </pre>
data GeneralCategory

-- | Lu: Letter, Uppercase
UppercaseLetter :: GeneralCategory

-- | Ll: Letter, Lowercase
LowercaseLetter :: GeneralCategory

-- | Lt: Letter, Titlecase
TitlecaseLetter :: GeneralCategory

-- | Lm: Letter, Modifier
ModifierLetter :: GeneralCategory

-- | Lo: Letter, Other
OtherLetter :: GeneralCategory

-- | Mn: Mark, Non-Spacing
NonSpacingMark :: GeneralCategory

-- | Mc: Mark, Spacing Combining
SpacingCombiningMark :: GeneralCategory

-- | Me: Mark, Enclosing
EnclosingMark :: GeneralCategory

-- | Nd: Number, Decimal
DecimalNumber :: GeneralCategory

-- | Nl: Number, Letter
LetterNumber :: GeneralCategory

-- | No: Number, Other
OtherNumber :: GeneralCategory

-- | Pc: Punctuation, Connector
ConnectorPunctuation :: GeneralCategory

-- | Pd: Punctuation, Dash
DashPunctuation :: GeneralCategory

-- | Ps: Punctuation, Open
OpenPunctuation :: GeneralCategory

-- | Pe: Punctuation, Close
ClosePunctuation :: GeneralCategory

-- | Pi: Punctuation, Initial quote
InitialQuote :: GeneralCategory

-- | Pf: Punctuation, Final quote
FinalQuote :: GeneralCategory

-- | Po: Punctuation, Other
OtherPunctuation :: GeneralCategory

-- | Sm: Symbol, Math
MathSymbol :: GeneralCategory

-- | Sc: Symbol, Currency
CurrencySymbol :: GeneralCategory

-- | Sk: Symbol, Modifier
ModifierSymbol :: GeneralCategory

-- | So: Symbol, Other
OtherSymbol :: GeneralCategory

-- | Zs: Separator, Space
Space :: GeneralCategory

-- | Zl: Separator, Line
LineSeparator :: GeneralCategory

-- | Zp: Separator, Paragraph
ParagraphSeparator :: GeneralCategory

-- | Cc: Other, Control
Control :: GeneralCategory

-- | Cf: Other, Format
Format :: GeneralCategory

-- | Cs: Other, Surrogate
Surrogate :: GeneralCategory

-- | Co: Other, Private Use
PrivateUse :: GeneralCategory

-- | Cn: Other, Not Assigned
NotAssigned :: GeneralCategory

-- | The Unicode general category of the character. This relies on the
--   <a>Enum</a> instance of <a>GeneralCategory</a>, which must remain in
--   the same order as the categories are presented in the Unicode
--   standard.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; generalCategory 'a'
--   LowercaseLetter
--   
--   &gt;&gt;&gt; generalCategory 'A'
--   UppercaseLetter
--   
--   &gt;&gt;&gt; generalCategory '0'
--   DecimalNumber
--   
--   &gt;&gt;&gt; generalCategory '%'
--   OtherPunctuation
--   
--   &gt;&gt;&gt; generalCategory '♥'
--   OtherSymbol
--   
--   &gt;&gt;&gt; generalCategory '\31'
--   Control
--   
--   &gt;&gt;&gt; generalCategory ' '
--   Space
--   </pre>
generalCategory :: Char -> GeneralCategory

-- | Selects the first 128 characters of the Unicode character set,
--   corresponding to the ASCII character set.
isAscii :: Char -> Bool

-- | Selects the first 256 characters of the Unicode character set,
--   corresponding to the ISO 8859-1 (Latin-1) character set.
isLatin1 :: Char -> Bool

-- | Selects control characters, which are the non-printing characters of
--   the Latin-1 subset of Unicode.
isControl :: Char -> Bool

-- | Selects ASCII upper-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isUpper</a>.
isAsciiUpper :: Char -> Bool

-- | Selects ASCII lower-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isLower</a>.
isAsciiLower :: Char -> Bool

-- | Selects printable Unicode characters (letters, numbers, marks,
--   punctuation, symbols and spaces).
--   
--   This function returns <a>False</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>True</a> otherwise:
--   
--   <ul>
--   <li><a>LineSeparator</a></li>
--   <li><a>ParagraphSeparator</a></li>
--   <li><a>Control</a></li>
--   <li><a>Format</a></li>
--   <li><a>Surrogate</a></li>
--   <li><a>PrivateUse</a></li>
--   <li><a>NotAssigned</a></li>
--   </ul>
isPrint :: Char -> Bool

-- | Returns <a>True</a> for any Unicode space character, and the control
--   characters <tt>\t</tt>, <tt>\n</tt>, <tt>\r</tt>, <tt>\f</tt>,
--   <tt>\v</tt>.
isSpace :: Char -> Bool

-- | Selects upper-case or title-case alphabetic Unicode characters
--   (letters). Title case is used by a small number of letter ligatures
--   like the single-character form of <i>Lj</i>.
--   
--   <b>Note:</b> this predicate does <i>not</i> work for letter-like
--   characters such as: <tt>'Ⓐ'</tt> (<tt>U+24B6</tt> circled Latin
--   capital letter A) and <tt>'Ⅳ'</tt> (<tt>U+2163</tt> Roman numeral
--   four). This is due to selecting only characters with the
--   <a>GeneralCategory</a> <a>UppercaseLetter</a> or
--   <a>TitlecaseLetter</a>.
--   
--   See <a>isUpperCase</a> for a more intuitive predicate. Note that
--   unlike <a>isUpperCase</a>, <a>isUpper</a> does select
--   <i>title-case</i> characters such as <tt>'ǅ'</tt> (<tt>U+01C5</tt>
--   Latin capital letter d with small letter z with caron) or <tt>'ᾯ'</tt>
--   (<tt>U+1FAF</tt> Greek capital letter omega with dasia and perispomeni
--   and prosgegrammeni).
isUpper :: Char -> Bool

-- | Selects upper-case Unicode letter-like characters.
--   
--   <b>Note:</b> this predicate selects characters with the Unicode
--   property <tt>Uppercase</tt>, which include letter-like characters such
--   as: <tt>'Ⓐ'</tt> (<tt>U+24B6</tt> circled Latin capital letter A) and
--   <tt>'Ⅳ'</tt> (<tt>U+2163</tt> Roman numeral four).
--   
--   See <a>isUpper</a> for the legacy predicate. Note that unlike
--   <a>isUpperCase</a>, <a>isUpper</a> does select <i>title-case</i>
--   characters such as <tt>'ǅ'</tt> (<tt>U+01C5</tt> Latin capital letter
--   d with small letter z with caron) or <tt>'ᾯ'</tt> (<tt>U+1FAF</tt>
--   Greek capital letter omega with dasia and perispomeni and
--   prosgegrammeni).
isUpperCase :: Char -> Bool

-- | Selects lower-case alphabetic Unicode characters (letters).
--   
--   <b>Note:</b> this predicate does <i>not</i> work for letter-like
--   characters such as: <tt>'ⓐ'</tt> (<tt>U+24D0</tt> circled Latin small
--   letter a) and <tt>'ⅳ'</tt> (<tt>U+2173</tt> small Roman numeral four).
--   This is due to selecting only characters with the
--   <a>GeneralCategory</a> <a>LowercaseLetter</a>.
--   
--   See <a>isLowerCase</a> for a more intuitive predicate.
isLower :: Char -> Bool

-- | Selects lower-case Unicode letter-like characters.
--   
--   <b>Note:</b> this predicate selects characters with the Unicode
--   property <tt>Lowercase</tt>, which includes letter-like characters
--   such as: <tt>'ⓐ'</tt> (<tt>U+24D0</tt> circled Latin small letter a)
--   and <tt>'ⅳ'</tt> (<tt>U+2173</tt> small Roman numeral four).
--   
--   See <a>isLower</a> for the legacy predicate.
isLowerCase :: Char -> Bool

-- | Selects alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters). This function is equivalent to <a>isLetter</a>.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>UppercaseLetter</a></li>
--   <li><a>LowercaseLetter</a></li>
--   <li><a>TitlecaseLetter</a></li>
--   <li><a>ModifierLetter</a></li>
--   <li><a>OtherLetter</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Letter".
isAlpha :: Char -> Bool

-- | Selects ASCII digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>.
isDigit :: Char -> Bool

-- | Selects ASCII octal digits, i.e. <tt>'0'</tt>..<tt>'7'</tt>.
isOctDigit :: Char -> Bool

-- | Selects ASCII hexadecimal digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>,
--   <tt>'a'</tt>..<tt>'f'</tt>, <tt>'A'</tt>..<tt>'F'</tt>.
isHexDigit :: Char -> Bool

-- | Selects alphabetic or numeric Unicode characters.
--   
--   Note that numeric digits outside the ASCII range, as well as numeric
--   characters which aren't digits, are selected by this function but not
--   by <a>isDigit</a>. Such characters may be part of identifiers but are
--   not used by the printer and reader to represent numbers, e.g., Roman
--   numerals like <tt><tt>V</tt></tt>, full-width digits like <tt>'１'</tt>
--   (aka <tt>'65297'</tt>).
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>UppercaseLetter</a></li>
--   <li><a>LowercaseLetter</a></li>
--   <li><a>TitlecaseLetter</a></li>
--   <li><a>ModifierLetter</a></li>
--   <li><a>OtherLetter</a></li>
--   <li><a>DecimalNumber</a></li>
--   <li><a>LetterNumber</a></li>
--   <li><a>OtherNumber</a></li>
--   </ul>
isAlphaNum :: Char -> Bool

-- | Selects Unicode punctuation characters, including various kinds of
--   connectors, brackets and quotes.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>ConnectorPunctuation</a></li>
--   <li><a>DashPunctuation</a></li>
--   <li><a>OpenPunctuation</a></li>
--   <li><a>ClosePunctuation</a></li>
--   <li><a>InitialQuote</a></li>
--   <li><a>FinalQuote</a></li>
--   <li><a>OtherPunctuation</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Punctuation".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isPunctuation 'a'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '7'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '♥'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '"'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '?'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '—'
--   True
--   </pre>
isPunctuation :: Char -> Bool

-- | Selects Unicode symbol characters, including mathematical and currency
--   symbols.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>MathSymbol</a></li>
--   <li><a>CurrencySymbol</a></li>
--   <li><a>ModifierSymbol</a></li>
--   <li><a>OtherSymbol</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Symbol".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol 'a'
--   False
--   
--   &gt;&gt;&gt; isSymbol '6'
--   False
--   
--   &gt;&gt;&gt; isSymbol '='
--   True
--   </pre>
--   
--   The definition of "math symbol" may be a little counter-intuitive
--   depending on one's background:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol '+'
--   True
--   
--   &gt;&gt;&gt; isSymbol '-'
--   False
--   </pre>
isSymbol :: Char -> Bool

-- | Convert a letter to the corresponding upper-case letter, if any. Any
--   other character is returned unchanged.
toUpper :: Char -> Char

-- | Convert a letter to the corresponding lower-case letter, if any. Any
--   other character is returned unchanged.
toLower :: Char -> Char

-- | Convert a letter to the corresponding title-case or upper-case letter,
--   if any. (Title case differs from upper case only for a small number of
--   ligature letters.) Any other character is returned unchanged.
toTitle :: Char -> Char
instance GHC.Internal.Enum.Bounded GHC.Internal.Unicode.GeneralCategory
instance GHC.Internal.Enum.Enum GHC.Internal.Unicode.GeneralCategory
instance GHC.Classes.Eq GHC.Internal.Unicode.GeneralCategory
instance GHC.Internal.Ix.Ix GHC.Internal.Unicode.GeneralCategory
instance GHC.Classes.Ord GHC.Internal.Unicode.GeneralCategory
instance GHC.Internal.Show.Show GHC.Internal.Unicode.GeneralCategory


-- | This is a library of parser combinators, originally written by Koen
--   Claessen. It parses all alternatives in parallel, so it never keeps
--   hold of the beginning of the input string, a common source of space
--   leaks with other parsers. The <tt>(<a>+++</a>)</tt> choice combinator
--   is genuinely commutative; it makes no difference which branch is
--   "shorter".
module GHC.Internal.Text.ParserCombinators.ReadP
data ReadP a

-- | Consumes and returns the next character. Fails if there is no input
--   left.
get :: ReadP Char

-- | Look-ahead: returns the part of the input that is left, without
--   consuming it.
look :: ReadP String

-- | Symmetric choice.
(+++) :: ReadP a -> ReadP a -> ReadP a
infixr 5 +++

-- | Local, exclusive, left-biased choice: If left parser locally produces
--   any result at all, then right parser is not used.
(<++) :: ReadP a -> ReadP a -> ReadP a
infixr 5 <++

-- | Transforms a parser into one that does the same, but in addition
--   returns the exact characters read. IMPORTANT NOTE: <a>gather</a> gives
--   a runtime error if its first argument is built using any occurrences
--   of readS_to_P.
gather :: ReadP a -> ReadP (String, a)

-- | Always fails.
pfail :: ReadP a

-- | Succeeds iff we are at the end of input
eof :: ReadP ()

-- | Consumes and returns the next character, if it satisfies the specified
--   predicate.
satisfy :: (Char -> Bool) -> ReadP Char

-- | Parses and returns the specified character.
char :: Char -> ReadP Char

-- | Parses and returns the specified string.
string :: String -> ReadP String

-- | Parses the first zero or more characters satisfying the predicate.
--   Always succeeds, exactly once having consumed all the characters Hence
--   NOT the same as (many (satisfy p))
munch :: (Char -> Bool) -> ReadP String

-- | Parses the first one or more characters satisfying the predicate.
--   Fails if none, else succeeds exactly once having consumed all the
--   characters Hence NOT the same as (many1 (satisfy p))
munch1 :: (Char -> Bool) -> ReadP String

-- | Skips all whitespace.
skipSpaces :: ReadP ()

-- | Combines all parsers in the specified list.
choice :: [ReadP a] -> ReadP a

-- | <tt>count n p</tt> parses <tt>n</tt> occurrences of <tt>p</tt> in
--   sequence. A list of results is returned.
count :: Int -> ReadP a -> ReadP [a]

-- | <tt>between open close p</tt> parses <tt>open</tt>, followed by
--   <tt>p</tt> and finally <tt>close</tt>. Only the value of <tt>p</tt> is
--   returned.
between :: ReadP open -> ReadP close -> ReadP a -> ReadP a

-- | <tt>option x p</tt> will either parse <tt>p</tt> or return <tt>x</tt>
--   without consuming any input.
option :: a -> ReadP a -> ReadP a

-- | <tt>optional p</tt> optionally parses <tt>p</tt> and always returns
--   <tt>()</tt>.
optional :: ReadP a -> ReadP ()

-- | Parses zero or more occurrences of the given parser.
many :: ReadP a -> ReadP [a]

-- | Parses one or more occurrences of the given parser.
many1 :: ReadP a -> ReadP [a]

-- | Like <a>many</a>, but discards the result.
skipMany :: ReadP a -> ReadP ()

-- | Like <a>many1</a>, but discards the result.
skipMany1 :: ReadP a -> ReadP ()

-- | <tt>sepBy p sep</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated by <tt>sep</tt>. Returns a list of values returned by
--   <tt>p</tt>.
sepBy :: ReadP a -> ReadP sep -> ReadP [a]

-- | <tt>sepBy1 p sep</tt> parses one or more occurrences of <tt>p</tt>,
--   separated by <tt>sep</tt>. Returns a list of values returned by
--   <tt>p</tt>.
sepBy1 :: ReadP a -> ReadP sep -> ReadP [a]

-- | <tt>endBy p sep</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated and ended by <tt>sep</tt>.
endBy :: ReadP a -> ReadP sep -> ReadP [a]

-- | <tt>endBy p sep</tt> parses one or more occurrences of <tt>p</tt>,
--   separated and ended by <tt>sep</tt>.
endBy1 :: ReadP a -> ReadP sep -> ReadP [a]

-- | <tt>chainr p op x</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated by <tt>op</tt>. Returns a value produced by a <i>right</i>
--   associative application of all functions returned by <tt>op</tt>. If
--   there are no occurrences of <tt>p</tt>, <tt>x</tt> is returned.
chainr :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a

-- | <tt>chainl p op x</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated by <tt>op</tt>. Returns a value produced by a <i>left</i>
--   associative application of all functions returned by <tt>op</tt>. If
--   there are no occurrences of <tt>p</tt>, <tt>x</tt> is returned.
chainl :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a

-- | Like <a>chainl</a>, but parses one or more occurrences of <tt>p</tt>.
chainl1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a

-- | Like <a>chainr</a>, but parses one or more occurrences of <tt>p</tt>.
chainr1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a

-- | <tt>manyTill p end</tt> parses zero or more occurrences of <tt>p</tt>,
--   until <tt>end</tt> succeeds. Returns a list of values returned by
--   <tt>p</tt>.
manyTill :: ReadP a -> ReadP end -> ReadP [a]

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | Converts a parser into a Haskell ReadS-style function. This is the
--   main way in which you can "run" a <a>ReadP</a> parser: the expanded
--   type is <tt> readP_to_S :: ReadP a -&gt; String -&gt; [(a,String)]
--   </tt>
readP_to_S :: ReadP a -> ReadS a

-- | Converts a Haskell ReadS-style function into a parser. Warning: This
--   introduces local backtracking in the resulting parser, and therefore a
--   possible inefficiency.
readS_to_P :: ReadS a -> ReadP a
instance GHC.Internal.Base.Alternative GHC.Internal.Text.ParserCombinators.ReadP.P
instance GHC.Internal.Base.Alternative GHC.Internal.Text.ParserCombinators.ReadP.ReadP
instance GHC.Internal.Base.Applicative GHC.Internal.Text.ParserCombinators.ReadP.P
instance GHC.Internal.Base.Applicative GHC.Internal.Text.ParserCombinators.ReadP.ReadP
instance GHC.Internal.Base.Functor GHC.Internal.Text.ParserCombinators.ReadP.P
instance GHC.Internal.Base.Functor GHC.Internal.Text.ParserCombinators.ReadP.ReadP
instance GHC.Internal.Control.Monad.Fail.MonadFail GHC.Internal.Text.ParserCombinators.ReadP.P
instance GHC.Internal.Control.Monad.Fail.MonadFail GHC.Internal.Text.ParserCombinators.ReadP.ReadP
instance GHC.Internal.Base.MonadPlus GHC.Internal.Text.ParserCombinators.ReadP.P
instance GHC.Internal.Base.MonadPlus GHC.Internal.Text.ParserCombinators.ReadP.ReadP
instance GHC.Internal.Base.Monad GHC.Internal.Text.ParserCombinators.ReadP.P
instance GHC.Internal.Base.Monad GHC.Internal.Text.ParserCombinators.ReadP.ReadP


-- | The cut-down Haskell lexer, used by GHC.Internal.Text.Read
module GHC.Internal.Text.Read.Lex
data Lexeme

-- | Character literal
Char :: Char -> Lexeme

-- | String literal, with escapes interpreted
String :: String -> Lexeme

-- | Punctuation or reserved symbol, e.g. <tt>(</tt>, <tt>::</tt>
Punc :: String -> Lexeme

-- | Haskell identifier, e.g. <tt>foo</tt>, <tt>Baz</tt>
Ident :: String -> Lexeme

-- | Haskell symbol, e.g. <tt>&gt;&gt;</tt>, <tt>:%</tt>
Symbol :: String -> Lexeme

Number :: Number -> Lexeme
EOF :: Lexeme

data Number

numberToInteger :: Number -> Maybe Integer

numberToFixed :: Integer -> Number -> Maybe (Integer, Integer)

numberToRational :: Number -> Rational

numberToRangedRational :: (Int, Int) -> Number -> Maybe Rational
lex :: ReadP Lexeme

expect :: Lexeme -> ReadP ()

-- | Haskell lexer: returns the lexed string, rather than the lexeme
hsLex :: ReadP String
lexChar :: ReadP Char
readBinP :: (Eq a, Num a) => ReadP a
readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
readOctP :: (Eq a, Num a) => ReadP a
readDecP :: (Eq a, Num a) => ReadP a
readHexP :: (Eq a, Num a) => ReadP a
isSymbolChar :: Char -> Bool
instance GHC.Classes.Eq GHC.Internal.Text.Read.Lex.Lexeme
instance GHC.Classes.Eq GHC.Internal.Text.Read.Lex.Number
instance GHC.Internal.Show.Show GHC.Internal.Text.Read.Lex.Lexeme
instance GHC.Internal.Show.Show GHC.Internal.Text.Read.Lex.Number


-- | This library defines parser combinators for precedence parsing.
module GHC.Internal.Text.ParserCombinators.ReadPrec
data ReadPrec a
type Prec = Int
minPrec :: Prec

-- | Lift a precedence-insensitive <a>ReadP</a> to a <a>ReadPrec</a>.
lift :: ReadP a -> ReadPrec a

-- | <tt>(prec n p)</tt> checks whether the precedence context is less than
--   or equal to <tt>n</tt>, and
--   
--   <ul>
--   <li>if not, fails</li>
--   <li>if so, parses <tt>p</tt> in context <tt>n</tt>.</li>
--   </ul>
prec :: Prec -> ReadPrec a -> ReadPrec a

-- | Increases the precedence context by one.
step :: ReadPrec a -> ReadPrec a

-- | Resets the precedence context to zero.
reset :: ReadPrec a -> ReadPrec a

-- | Consumes and returns the next character. Fails if there is no input
--   left.
get :: ReadPrec Char

-- | Look-ahead: returns the part of the input that is left, without
--   consuming it.
look :: ReadPrec String

-- | Symmetric choice.
(+++) :: ReadPrec a -> ReadPrec a -> ReadPrec a

-- | Local, exclusive, left-biased choice: If left parser locally produces
--   any result at all, then right parser is not used.
(<++) :: ReadPrec a -> ReadPrec a -> ReadPrec a

-- | Always fails.
pfail :: ReadPrec a

-- | Combines all parsers in the specified list.
choice :: [ReadPrec a] -> ReadPrec a
readPrec_to_P :: ReadPrec a -> Int -> ReadP a
readP_to_Prec :: (Int -> ReadP a) -> ReadPrec a
readPrec_to_S :: ReadPrec a -> Int -> ReadS a
readS_to_Prec :: (Int -> ReadS a) -> ReadPrec a
instance GHC.Internal.Base.Alternative GHC.Internal.Text.ParserCombinators.ReadPrec.ReadPrec
instance GHC.Internal.Base.Applicative GHC.Internal.Text.ParserCombinators.ReadPrec.ReadPrec
instance GHC.Internal.Base.Functor GHC.Internal.Text.ParserCombinators.ReadPrec.ReadPrec
instance GHC.Internal.Control.Monad.Fail.MonadFail GHC.Internal.Text.ParserCombinators.ReadPrec.ReadPrec
instance GHC.Internal.Base.MonadPlus GHC.Internal.Text.ParserCombinators.ReadPrec.ReadPrec
instance GHC.Internal.Base.Monad GHC.Internal.Text.ParserCombinators.ReadPrec.ReadPrec


-- | Functions to evaluate whether or not a string is a valid identifier.
module GHC.Internal.Lexeme
startsVarSym :: Char -> Bool
startsVarId :: Char -> Bool
startsConSym :: Char -> Bool
startsConId :: Char -> Bool
startsVarSymASCII :: Char -> Bool
isVarSymChar :: Char -> Bool

-- | Is this character acceptable in a symbol (after the first char)? See
--   alexGetByte in GHC.Parser.Lexer
okSymChar :: Char -> Bool


-- | The types <a>Float</a> and <a>Double</a>, the classes <a>Floating</a>
--   and <a>RealFloat</a> and casting between Word32 and Float and Word64
--   and Double.
module GHC.Internal.Float

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   <tt>(<a>+</a>)</tt>, <tt>(<a>*</a>)</tt> and <a>exp</a> are
--   customarily expected to define an exponential field and have the
--   following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = <tt>exp a * exp b</tt></li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class Fractional a => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a

-- | <tt><a>log1p</a> x</tt> computes <tt><a>log</a> (1 + x)</tt>, but
--   provides more precise results for small (absolute) values of
--   <tt>x</tt> if possible.
log1p :: Floating a => a -> a

-- | <tt><a>expm1</a> x</tt> computes <tt><a>exp</a> x - 1</tt>, but
--   provides more precise results for small (absolute) values of
--   <tt>x</tt> if possible.
expm1 :: Floating a => a -> a

-- | <tt><a>log1pexp</a> x</tt> computes <tt><a>log</a> (1 + <a>exp</a>
--   x)</tt>, but provides more precise results if possible.
--   
--   Examples:
--   
--   <ul>
--   <li>if <tt>x</tt> is a large negative number, <tt><a>log</a> (1 +
--   <a>exp</a> x)</tt> will be imprecise for the reasons given in
--   <a>log1p</a>.</li>
--   <li>if <tt><a>exp</a> x</tt> is close to <tt>-1</tt>, <tt><a>log</a>
--   (1 + <a>exp</a> x)</tt> will be imprecise for the reasons given in
--   <a>expm1</a>.</li>
--   </ul>
log1pexp :: Floating a => a -> a

-- | <tt><a>log1mexp</a> x</tt> computes <tt><a>log</a> (1 - <a>exp</a>
--   x)</tt>, but provides more precise results if possible.
--   
--   Examples:
--   
--   <ul>
--   <li>if <tt>x</tt> is a large negative number, <tt><a>log</a> (1 -
--   <a>exp</a> x)</tt> will be imprecise for the reasons given in
--   <a>log1p</a>.</li>
--   <li>if <tt><a>exp</a> x</tt> is close to <tt>1</tt>, <tt><a>log</a> (1
--   - <a>exp</a> x)</tt> will be imprecise for the reasons given in
--   <a>expm1</a>.</li>
--   </ul>
log1mexp :: Floating a => a -> a
infixr 8 **

-- | Efficient, machine-independent access to the components of a
--   floating-point number.
class (RealFrac a, Floating a) => RealFloat a

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | a constant function, returning the number of digits of
--   <a>floatRadix</a> in the significand
floatDigits :: RealFloat a => a -> Int

-- | a constant function, returning the lowest and highest values the
--   exponent may assume
floatRange :: RealFloat a => a -> (Int, Int)

-- | The function <a>decodeFloat</a> applied to a real floating-point
--   number returns the significand expressed as an <a>Integer</a> and an
--   appropriately scaled exponent (an <a>Int</a>). If
--   <tt><a>decodeFloat</a> x</tt> yields <tt>(m,n)</tt>, then <tt>x</tt>
--   is equal in value to <tt>m*b^^n</tt>, where <tt>b</tt> is the
--   floating-point radix, and furthermore, either <tt>m</tt> and
--   <tt>n</tt> are both zero or else <tt>b^(d-1) &lt;= <a>abs</a> m &lt;
--   b^d</tt>, where <tt>d</tt> is the value of <tt><a>floatDigits</a>
--   x</tt>. In particular, <tt><a>decodeFloat</a> 0 = (0,0)</tt>. If the
--   type contains a negative zero, also <tt><a>decodeFloat</a> (-0.0) =
--   (0,0)</tt>. <i>The result of</i> <tt><a>decodeFloat</a> x</tt> <i>is
--   unspecified if either of</i> <tt><a>isNaN</a> x</tt> <i>or</i>
--   <tt><a>isInfinite</a> x</tt> <i>is</i> <a>True</a>.
decodeFloat :: RealFloat a => a -> (Integer, Int)

-- | <a>encodeFloat</a> performs the inverse of <a>decodeFloat</a> in the
--   sense that for finite <tt>x</tt> with the exception of <tt>-0.0</tt>,
--   <tt><a>uncurry</a> <a>encodeFloat</a> (<a>decodeFloat</a> x) = x</tt>.
--   <tt><a>encodeFloat</a> m n</tt> is one of the two closest
--   representable floating-point numbers to <tt>m*b^^n</tt> (or
--   <tt>±Infinity</tt> if overflow occurs); usually the closer, but if
--   <tt>m</tt> contains too many bits, the result may be rounded in the
--   wrong direction.
encodeFloat :: RealFloat a => Integer -> Int -> a

-- | <a>exponent</a> corresponds to the second component of
--   <a>decodeFloat</a>. <tt><a>exponent</a> 0 = 0</tt> and for finite
--   nonzero <tt>x</tt>, <tt><a>exponent</a> x = snd (<a>decodeFloat</a> x)
--   + <a>floatDigits</a> x</tt>. If <tt>x</tt> is a finite floating-point
--   number, it is equal in value to <tt><a>significand</a> x * b ^^
--   <a>exponent</a> x</tt>, where <tt>b</tt> is the floating-point radix.
--   The behaviour is unspecified on infinite or <tt>NaN</tt> values.
exponent :: RealFloat a => a -> Int

-- | The first component of <a>decodeFloat</a>, scaled to lie in the open
--   interval (<tt>-1</tt>,<tt>1</tt>), either <tt>0.0</tt> or of absolute
--   value <tt>&gt;= 1/b</tt>, where <tt>b</tt> is the floating-point
--   radix. The behaviour is unspecified on infinite or <tt>NaN</tt>
--   values.
significand :: RealFloat a => a -> a

-- | multiplies a floating-point number by an integer power of the radix
scaleFloat :: RealFloat a => Int -> a -> a

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE negative zero
isNegativeZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE floating point number
isIEEE :: RealFloat a => a -> Bool

-- | a version of arctangent taking two real floating-point arguments. For
--   real floating <tt>x</tt> and <tt>y</tt>, <tt><a>atan2</a> y x</tt>
--   computes the angle (from the positive x-axis) of the vector from the
--   origin to the point <tt>(x,y)</tt>. <tt><a>atan2</a> y x</tt> returns
--   a value in the range [<tt>-pi</tt>, <tt>pi</tt>]. It follows the
--   Common Lisp semantics for the origin when signed zeroes are supported.
--   <tt><a>atan2</a> y 1</tt>, with <tt>y</tt> in a type that is
--   <a>RealFloat</a>, should return the same value as <tt><a>atan</a>
--   y</tt>. A default definition of <a>atan2</a> is provided, but
--   implementors can provide a more accurate implementation.
atan2 :: RealFloat a => a -> a -> a

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float
F# :: Float# -> Float
data Float# :: TYPE 'FloatRep
float2Int :: Float -> Int
int2Float :: Int -> Float
word2Float :: Word -> Float

-- | Convert an Integer to a Float#
integerToFloat# :: Integer -> Float#

-- | Convert a Natural to a Float#
naturalToFloat# :: Natural -> Float#
rationalToFloat :: Integer -> Integer -> Float

-- | <tt><a>castWord32ToFloat</a> w</tt> does a bit-for-bit copy from an
--   integral value to a floating-point value.
castWord32ToFloat :: Word32 -> Float

-- | <tt><a>castFloatToWord32</a> f</tt> does a bit-for-bit copy from a
--   floating-point value to an integral value.
castFloatToWord32 :: Float -> Word32

-- | Bitcast a <a>Word32#</a> into a <a>Float#</a>
castWord32ToFloat# :: Word32# -> Float#

-- | Bitcast a <a>Float#</a> into a <a>Word32#</a>
castFloatToWord32# :: Float# -> Word32#
float2Double :: Float -> Double
floorFloat :: Integral b => Float -> b
ceilingFloat :: Integral b => Float -> b
truncateFloat :: Integral b => Float -> b
roundFloat :: Integral b => Float -> b
properFractionFloat :: Integral b => Float -> (b, Float)
isFloatDenormalized :: Float -> Int
isFloatFinite :: Float -> Int
isFloatInfinite :: Float -> Int
isFloatNaN :: Float -> Int
isFloatNegativeZero :: Float -> Int
gtFloat :: Float -> Float -> Bool
geFloat :: Float -> Float -> Bool
leFloat :: Float -> Float -> Bool
ltFloat :: Float -> Float -> Bool
plusFloat :: Float -> Float -> Float
minusFloat :: Float -> Float -> Float
timesFloat :: Float -> Float -> Float
divideFloat :: Float -> Float -> Float
negateFloat :: Float -> Float
expFloat :: Float -> Float
expm1Float :: Float -> Float
logFloat :: Float -> Float
log1pFloat :: Float -> Float
sqrtFloat :: Float -> Float
fabsFloat :: Float -> Float
sinFloat :: Float -> Float
cosFloat :: Float -> Float
tanFloat :: Float -> Float
asinFloat :: Float -> Float
acosFloat :: Float -> Float
atanFloat :: Float -> Float
sinhFloat :: Float -> Float
coshFloat :: Float -> Float
tanhFloat :: Float -> Float
asinhFloat :: Float -> Float
acoshFloat :: Float -> Float
atanhFloat :: Float -> Float

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double
D# :: Double# -> Double
data Double# :: TYPE 'DoubleRep
double2Int :: Double -> Int
int2Double :: Int -> Double
word2Double :: Word -> Double

-- | Convert an Integer to a Double#
integerToDouble# :: Integer -> Double#

-- | Encode a Natural (mantissa) into a Double#
naturalToDouble# :: Natural -> Double#
rationalToDouble :: Integer -> Integer -> Double

-- | <tt><a>castWord64ToDouble</a> w</tt> does a bit-for-bit copy from an
--   integral value to a floating-point value.
castWord64ToDouble :: Word64 -> Double

-- | <tt><a>castDoubleToWord64</a> f</tt> does a bit-for-bit copy from a
--   floating-point value to an integral value.
castDoubleToWord64 :: Double -> Word64

-- | Bitcast a <a>Word64#</a> into a <a>Double#</a>
castWord64ToDouble# :: Word64# -> Double#

-- | Bitcast a <a>Double#</a> into a <a>Word64#</a>
castDoubleToWord64# :: Double# -> Word64#
double2Float :: Double -> Float
floorDouble :: Integral b => Double -> b
ceilingDouble :: Integral b => Double -> b
truncateDouble :: Integral b => Double -> b
roundDouble :: Integral b => Double -> b
properFractionDouble :: Integral b => Double -> (b, Double)
isDoubleDenormalized :: Double -> Int
isDoubleFinite :: Double -> Int
isDoubleInfinite :: Double -> Int
isDoubleNaN :: Double -> Int
isDoubleNegativeZero :: Double -> Int
gtDouble :: Double -> Double -> Bool
geDouble :: Double -> Double -> Bool
leDouble :: Double -> Double -> Bool
ltDouble :: Double -> Double -> Bool
plusDouble :: Double -> Double -> Double
minusDouble :: Double -> Double -> Double
timesDouble :: Double -> Double -> Double
divideDouble :: Double -> Double -> Double
negateDouble :: Double -> Double
expDouble :: Double -> Double
expm1Double :: Double -> Double
logDouble :: Double -> Double
log1pDouble :: Double -> Double
sqrtDouble :: Double -> Double
fabsDouble :: Double -> Double
sinDouble :: Double -> Double
cosDouble :: Double -> Double
tanDouble :: Double -> Double
asinDouble :: Double -> Double
acosDouble :: Double -> Double
atanDouble :: Double -> Double
sinhDouble :: Double -> Double
coshDouble :: Double -> Double
tanhDouble :: Double -> Double
asinhDouble :: Double -> Double
acoshDouble :: Double -> Double
atanhDouble :: Double -> Double

-- | Show a signed <a>RealFloat</a> value to full precision using standard
--   decimal notation for arguments whose absolute value lies between
--   <tt>0.1</tt> and <tt>9,999,999</tt>, and scientific notation
--   otherwise.
showFloat :: RealFloat a => a -> ShowS
data FFFormat
FFExponent :: FFFormat
FFFixed :: FFFormat
FFGeneric :: FFFormat
formatRealFloat :: RealFloat a => FFFormat -> Maybe Int -> a -> String
formatRealFloatAlt :: RealFloat a => FFFormat -> Maybe Int -> Bool -> a -> String
showSignedFloat :: RealFloat a => (a -> ShowS) -> Int -> a -> ShowS

-- | Default implementation for <tt><a>log1mexp</a></tt> requiring
--   <tt><a>Ord</a></tt> to test against a threshold to decide which
--   implementation variant to use.
log1mexpOrd :: (Ord a, Floating a) => a -> a
roundTo :: Int -> Int -> [Int] -> (Int, [Int])

-- | <a>floatToDigits</a> takes a base and a non-negative <a>RealFloat</a>
--   number, and returns a list of digits and an exponent. In particular,
--   if <tt>x&gt;=0</tt>, and
--   
--   <pre>
--   floatToDigits base x = ([d1,d2,...,dn], e)
--   </pre>
--   
--   then
--   
--   <ol>
--   <li><pre>n &gt;= 1</pre></li>
--   <li><pre>x = 0.d1d2...dn * (base**e)</pre></li>
--   <li><pre>0 &lt;= di &lt;= base-1</pre></li>
--   </ol>
floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)

-- | Converts a positive integer to a floating-point value.
--   
--   The value nearest to the argument will be returned. If there are two
--   such values, the one with an even significand will be returned (i.e.
--   IEEE roundTiesToEven).
--   
--   The argument must be strictly positive, and <tt>floatRadix (undefined
--   :: a)</tt> must be 2.
integerToBinaryFloat' :: RealFloat a => Integer -> a

-- | Converts a <a>Rational</a> value into any type in class
--   <a>RealFloat</a>.
fromRat :: RealFloat a => Rational -> a
fromRat' :: RealFloat a => Rational -> a
roundingMode# :: Integer -> Int# -> Int#
eqFloat :: Float -> Float -> Bool
eqDouble :: Double -> Double -> Bool

-- | Used to prevent exponent over/underflow when encoding floating point
--   numbers. This is also the same as
--   
--   <pre>
--   \(x,y) -&gt; max (-x) (min x y)
--   </pre>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; clamp (-10) 5
--   10
--   </pre>
clamp :: Int -> Int -> Int
expt :: Integer -> Int -> Integer
expts :: Array Int Integer
expts10 :: Array Int Integer
fromRat'' :: RealFloat a => Int -> Int -> Integer -> Integer -> a
maxExpt :: Int
maxExpt10 :: Int
minExpt :: Int
powerDouble :: Double -> Double -> Double
powerFloat :: Float -> Float -> Float

-- | <i>Deprecated: Use castDoubleToWord64# instead</i>
stgDoubleToWord64 :: Double# -> Word64#

-- | <i>Deprecated: Use castFloatToWord32# instead</i>
stgFloatToWord32 :: Float# -> Word32#

-- | <i>Deprecated: Use castWord64ToDouble# instead</i>
stgWord64ToDouble :: Word64# -> Double#

-- | <i>Deprecated: Use castWord32ToFloat# instead</i>
stgWord32ToFloat :: Word32# -> Float#
instance GHC.Internal.Enum.Enum GHC.Types.Double
instance GHC.Internal.Enum.Enum GHC.Types.Float
instance GHC.Internal.Float.Floating GHC.Types.Double
instance GHC.Internal.Float.Floating GHC.Types.Float
instance GHC.Internal.Real.Fractional GHC.Types.Double
instance GHC.Internal.Real.Fractional GHC.Types.Float
instance GHC.Internal.Num.Num GHC.Types.Double
instance GHC.Internal.Num.Num GHC.Types.Float
instance GHC.Internal.Real.Real GHC.Types.Double
instance GHC.Internal.Real.Real GHC.Types.Float
instance GHC.Internal.Float.RealFloat GHC.Types.Double
instance GHC.Internal.Float.RealFloat GHC.Types.Float
instance GHC.Internal.Real.RealFrac GHC.Types.Double
instance GHC.Internal.Real.RealFrac GHC.Types.Float
instance GHC.Internal.Show.Show GHC.Types.Double
instance GHC.Internal.Show.Show GHC.Types.Float


-- | The <a>Read</a> class and instances for basic data types.
module GHC.Internal.Read

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class Read a

-- | attempts to parse a value from the front of the string, returning a
--   list of (parsed value, remaining string) pairs. If there is no
--   successful parse, the returned list is empty.
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
readsPrec :: Read a => Int -> ReadS a

-- | The method <a>readList</a> is provided to allow the programmer to give
--   a specialised way of parsing lists of values. For example, this is
--   used by the predefined <a>Read</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> are expected to use double quotes,
--   rather than square brackets.
readList :: Read a => ReadS [a]

-- | Proposed replacement for <a>readsPrec</a> using new-style parsers (GHC
--   only).
readPrec :: Read a => ReadPrec a

-- | Proposed replacement for <a>readList</a> using new-style parsers (GHC
--   only). The default definition uses <a>readList</a>. Instances that
--   define <a>readPrec</a> should also define <a>readListPrec</a> as
--   <a>readListPrecDefault</a>.
readListPrec :: Read a => ReadPrec [a]

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions. For example:
--   
--   <pre>
--   lexLitChar  "\\nHello"  =  [("\\n", "Hello")]
--   </pre>
lexLitChar :: ReadS String

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions, and convert it to the character
--   that it encodes. For example:
--   
--   <pre>
--   readLitChar "\\nHello"  =  [('\n', "Hello")]
--   </pre>
readLitChar :: ReadS Char

-- | Reads a non-empty string of decimal digits.
lexDigits :: ReadS String

-- | Parse a single lexeme
lexP :: ReadPrec Lexeme
expectP :: Lexeme -> ReadPrec ()

-- | <tt>(paren p)</tt> parses "(P0)" where <tt>p</tt> parses "P0" in
--   precedence context zero
paren :: ReadPrec a -> ReadPrec a

-- | <tt>(parens p)</tt> parses "P", "(P0)", "((P0))", etc, where
--   <tt>p</tt> parses "P" in the current precedence context and parses
--   "P0" in precedence context zero
parens :: ReadPrec a -> ReadPrec a

-- | <tt>(list p)</tt> parses a list of things parsed by <tt>p</tt>, using
--   the usual square-bracket syntax.
list :: ReadPrec a -> ReadPrec [a]

-- | Parse the specified lexeme and continue as specified. Esp useful for
--   nullary constructors; e.g. <tt>choose [("A", return A), ("B", return
--   B)]</tt> We match both Ident and Symbol because the constructor might
--   be an operator eg <tt>(:~:)</tt>
choose :: [(String, ReadPrec a)] -> ReadPrec a

-- | A possible replacement definition for the <a>readList</a> method (GHC
--   only). This is only needed for GHC, and even then only for <a>Read</a>
--   instances where <a>readListPrec</a> isn't defined as
--   <a>readListPrecDefault</a>.
readListDefault :: Read a => ReadS [a]

-- | A possible replacement definition for the <a>readListPrec</a> method,
--   defined using <a>readPrec</a> (GHC only).
readListPrecDefault :: Read a => ReadPrec [a]
readNumber :: Num a => (Lexeme -> ReadPrec a) -> ReadPrec a

-- | <a>Read</a> parser for a record field, of the form
--   <tt>fieldName=value</tt>. The <tt>fieldName</tt> must be an
--   alphanumeric identifier; for symbols (operator-style) field names,
--   e.g. <tt>(#)</tt>, use <a>readSymField</a>). The second argument is a
--   parser for the field value.
readField :: String -> ReadPrec a -> ReadPrec a

-- | <a>Read</a> parser for a record field, of the form
--   <tt>fieldName#=value</tt>. That is, an alphanumeric identifier
--   <tt>fieldName</tt> followed by the symbol <tt>#</tt>. The second
--   argument is a parser for the field value.
--   
--   Note that <a>readField</a> does not suffice for this purpose due to
--   <a>#5041</a>.
readFieldHash :: String -> ReadPrec a -> ReadPrec a

-- | <a>Read</a> parser for a symbol record field, of the form
--   <tt>(###)=value</tt> (where <tt>###</tt> is the field name). The field
--   name must be a symbol (operator-style), e.g. <tt>(#)</tt>. For regular
--   (alphanumeric) field names, use <a>readField</a>. The second argument
--   is a parser for the field value.
readSymField :: String -> ReadPrec a -> ReadPrec a

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: Bool -> ReadS a -> ReadS a
instance (GHC.Internal.Ix.Ix a, GHC.Internal.Read.Read a, GHC.Internal.Read.Read b) => GHC.Internal.Read.Read (GHC.Internal.Arr.Array a b)
instance GHC.Internal.Read.Read GHC.Types.Bool
instance GHC.Internal.Read.Read GHC.Types.Char
instance GHC.Internal.Read.Read GHC.Types.Double
instance GHC.Internal.Read.Read GHC.Types.Float
instance GHC.Internal.Read.Read GHC.Internal.Unicode.GeneralCategory
instance GHC.Internal.Read.Read GHC.Types.Int
instance GHC.Internal.Read.Read GHC.Num.Integer.Integer
instance GHC.Internal.Read.Read GHC.Internal.Text.Read.Lex.Lexeme
instance GHC.Internal.Read.Read a => GHC.Internal.Read.Read [a]
instance GHC.Internal.Read.Read a => GHC.Internal.Read.Read (GHC.Internal.Maybe.Maybe a)
instance GHC.Internal.Read.Read GHC.Num.Natural.Natural
instance GHC.Internal.Read.Read a => GHC.Internal.Read.Read (GHC.Internal.Base.NonEmpty a)
instance GHC.Internal.Read.Read GHC.Types.Ordering
instance (GHC.Internal.Real.Integral a, GHC.Internal.Read.Read a) => GHC.Internal.Read.Read (GHC.Internal.Real.Ratio a)
instance GHC.Internal.Read.Read a => GHC.Internal.Read.Read (GHC.Tuple.Solo a)
instance (GHC.Internal.Read.Read a, GHC.Internal.Read.Read b, GHC.Internal.Read.Read c, GHC.Internal.Read.Read d, GHC.Internal.Read.Read e, GHC.Internal.Read.Read f, GHC.Internal.Read.Read g, GHC.Internal.Read.Read h, GHC.Internal.Read.Read i, GHC.Internal.Read.Read j) => GHC.Internal.Read.Read (a, b, c, d, e, f, g, h, i, j)
instance (GHC.Internal.Read.Read a, GHC.Internal.Read.Read b, GHC.Internal.Read.Read c, GHC.Internal.Read.Read d, GHC.Internal.Read.Read e, GHC.Internal.Read.Read f, GHC.Internal.Read.Read g, GHC.Internal.Read.Read h, GHC.Internal.Read.Read i, GHC.Internal.Read.Read j, GHC.Internal.Read.Read k) => GHC.Internal.Read.Read (a, b, c, d, e, f, g, h, i, j, k)
instance (GHC.Internal.Read.Read a, GHC.Internal.Read.Read b, GHC.Internal.Read.Read c, GHC.Internal.Read.Read d, GHC.Internal.Read.Read e, GHC.Internal.Read.Read f, GHC.Internal.Read.Read g, GHC.Internal.Read.Read h, GHC.Internal.Read.Read i, GHC.Internal.Read.Read j, GHC.Internal.Read.Read k, GHC.Internal.Read.Read l) => GHC.Internal.Read.Read (a, b, c, d, e, f, g, h, i, j, k, l)
instance (GHC.Internal.Read.Read a, GHC.Internal.Read.Read b, GHC.Internal.Read.Read c, GHC.Internal.Read.Read d, GHC.Internal.Read.Read e, GHC.Internal.Read.Read f, GHC.Internal.Read.Read g, GHC.Internal.Read.Read h, GHC.Internal.Read.Read i, GHC.Internal.Read.Read j, GHC.Internal.Read.Read k, GHC.Internal.Read.Read l, GHC.Internal.Read.Read m) => GHC.Internal.Read.Read (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (GHC.Internal.Read.Read a, GHC.Internal.Read.Read b, GHC.Internal.Read.Read c, GHC.Internal.Read.Read d, GHC.Internal.Read.Read e, GHC.Internal.Read.Read f, GHC.Internal.Read.Read g, GHC.Internal.Read.Read h, GHC.Internal.Read.Read i, GHC.Internal.Read.Read j, GHC.Internal.Read.Read k, GHC.Internal.Read.Read l, GHC.Internal.Read.Read m, GHC.Internal.Read.Read n) => GHC.Internal.Read.Read (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (GHC.Internal.Read.Read a, GHC.Internal.Read.Read b, GHC.Internal.Read.Read c, GHC.Internal.Read.Read d, GHC.Internal.Read.Read e, GHC.Internal.Read.Read f, GHC.Internal.Read.Read g, GHC.Internal.Read.Read h, GHC.Internal.Read.Read i, GHC.Internal.Read.Read j, GHC.Internal.Read.Read k, GHC.Internal.Read.Read l, GHC.Internal.Read.Read m, GHC.Internal.Read.Read n, GHC.Internal.Read.Read o) => GHC.Internal.Read.Read (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance (GHC.Internal.Read.Read a, GHC.Internal.Read.Read b) => GHC.Internal.Read.Read (a, b)
instance (GHC.Internal.Read.Read a, GHC.Internal.Read.Read b, GHC.Internal.Read.Read c) => GHC.Internal.Read.Read (a, b, c)
instance (GHC.Internal.Read.Read a, GHC.Internal.Read.Read b, GHC.Internal.Read.Read c, GHC.Internal.Read.Read d) => GHC.Internal.Read.Read (a, b, c, d)
instance (GHC.Internal.Read.Read a, GHC.Internal.Read.Read b, GHC.Internal.Read.Read c, GHC.Internal.Read.Read d, GHC.Internal.Read.Read e) => GHC.Internal.Read.Read (a, b, c, d, e)
instance (GHC.Internal.Read.Read a, GHC.Internal.Read.Read b, GHC.Internal.Read.Read c, GHC.Internal.Read.Read d, GHC.Internal.Read.Read e, GHC.Internal.Read.Read f) => GHC.Internal.Read.Read (a, b, c, d, e, f)
instance (GHC.Internal.Read.Read a, GHC.Internal.Read.Read b, GHC.Internal.Read.Read c, GHC.Internal.Read.Read d, GHC.Internal.Read.Read e, GHC.Internal.Read.Read f, GHC.Internal.Read.Read g) => GHC.Internal.Read.Read (a, b, c, d, e, f, g)
instance (GHC.Internal.Read.Read a, GHC.Internal.Read.Read b, GHC.Internal.Read.Read c, GHC.Internal.Read.Read d, GHC.Internal.Read.Read e, GHC.Internal.Read.Read f, GHC.Internal.Read.Read g, GHC.Internal.Read.Read h) => GHC.Internal.Read.Read (a, b, c, d, e, f, g, h)
instance (GHC.Internal.Read.Read a, GHC.Internal.Read.Read b, GHC.Internal.Read.Read c, GHC.Internal.Read.Read d, GHC.Internal.Read.Read e, GHC.Internal.Read.Read f, GHC.Internal.Read.Read g, GHC.Internal.Read.Read h, GHC.Internal.Read.Read i) => GHC.Internal.Read.Read (a, b, c, d, e, f, g, h, i)
instance GHC.Internal.Read.Read ()
instance GHC.Internal.Read.Read GHC.Internal.Base.Void
instance GHC.Internal.Read.Read GHC.Types.Word
instance GHC.Internal.Read.Read GHC.Internal.Word.Word16
instance GHC.Internal.Read.Read GHC.Internal.Word.Word32
instance GHC.Internal.Read.Read GHC.Internal.Word.Word64
instance GHC.Internal.Read.Read GHC.Internal.Word.Word8


-- | The IOMode type
module GHC.Internal.IO.IOMode

-- | See <a>openFile</a>
data IOMode
ReadMode :: IOMode
WriteMode :: IOMode
AppendMode :: IOMode
ReadWriteMode :: IOMode
instance GHC.Internal.Enum.Enum GHC.Internal.IO.IOMode.IOMode
instance GHC.Classes.Eq GHC.Internal.IO.IOMode.IOMode
instance GHC.Internal.Ix.Ix GHC.Internal.IO.IOMode.IOMode
instance GHC.Classes.Ord GHC.Internal.IO.IOMode.IOMode
instance GHC.Internal.Read.Read GHC.Internal.IO.IOMode.IOMode
instance GHC.Internal.Show.Show GHC.Internal.IO.IOMode.IOMode


-- | Definition of propositional equality <tt>(<a>:~:</a>)</tt>.
--   Pattern-matching on a variable of type <tt>(a <a>:~:</a> b)</tt>
--   produces a proof that <tt>a <tt>~</tt> b</tt>.
module GHC.Internal.Data.Type.Equality

-- | Lifted, homogeneous equality. By lifted, we mean that it can be bogus
--   (deferred type error). By homogeneous, the two types <tt>a</tt> and
--   <tt>b</tt> must have the same kinds.
class a ~# b => (a :: k) ~ (b :: k)
infix 4 ~

-- | Lifted, heterogeneous equality. By lifted, we mean that it can be
--   bogus (deferred type error). By heterogeneous, the two types
--   <tt>a</tt> and <tt>b</tt> might have different kinds. Because
--   <tt>~~</tt> can appear unexpectedly in error messages to users who do
--   not care about the difference between heterogeneous equality
--   <tt>~~</tt> and homogeneous equality <tt>~</tt>, this is printed as
--   <tt>~</tt> unless <tt>-fprint-equality-relations</tt> is set.
--   
--   In <tt>0.7.0</tt>, the fixity was set to <tt>infix 4</tt> to match the
--   fixity of <a>:~~:</a>.
class a ~# b => (a :: k0) ~~ (b :: k1)
infix 4 ~~

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data (a :: k) :~: (b :: k)
[Refl] :: forall {k} (a :: k). a :~: a
infix 4 :~:

-- | Kind heterogeneous propositional equality. Like <a>:~:</a>, <tt>a :~~:
--   b</tt> is inhabited by a terminating value if and only if <tt>a</tt>
--   is the same type as <tt>b</tt>.
data (a :: k1) :~~: (b :: k2)
[HRefl] :: forall {k1} (a :: k1). a :~~: a
infix 4 :~~:

-- | Symmetry of equality
sym :: forall {k} (a :: k) (b :: k). (a :~: b) -> b :~: a

-- | Transitivity of equality
trans :: forall {k} (a :: k) (b :: k) (c :: k). (a :~: b) -> (b :~: c) -> a :~: c

-- | Type-safe cast, using propositional equality
castWith :: (a :~: b) -> a -> b

-- | Generalized form of type-safe cast using propositional equality
gcastWith :: forall {k} (a :: k) (b :: k) r. (a :~: b) -> (a ~ b => r) -> r

-- | Apply one equality to another, respectively
apply :: forall {k1} {k2} (f :: k1 -> k2) (g :: k1 -> k2) (a :: k1) (b :: k1). (f :~: g) -> (a :~: b) -> f a :~: g b

-- | Extract equality of the arguments from an equality of applied types
inner :: forall {k1} {k2} (f :: k1 -> k2) (a :: k1) (g :: k1 -> k2) (b :: k1). (f a :~: g b) -> a :~: b

-- | Extract equality of type constructors from an equality of applied
--   types
outer :: forall {k1} {k2} (f :: k1 -> k2) (a :: k1) (g :: k1 -> k2) (b :: k1). (f a :~: g b) -> f :~: g

-- | This class contains types where you can learn the equality of two
--   types from information contained in <i>terms</i>.
--   
--   The result should be <tt>Just Refl</tt> if and only if the types
--   applied to <tt>f</tt> are equal:
--   
--   <pre>
--   testEquality (x :: f a) (y :: f b) = Just Refl ⟺ a = b
--   </pre>
--   
--   Typically, only singleton types should inhabit this class. In that
--   case type argument equality coincides with term equality:
--   
--   <pre>
--   testEquality (x :: f a) (y :: f b) = Just Refl ⟺ a = b ⟺ x = y
--   </pre>
--   
--   <pre>
--   isJust (testEquality x y) = x == y
--   </pre>
--   
--   Singleton types are not required, however, and so the latter two
--   would-be laws are not in fact valid in general.
class TestEquality (f :: k -> Type)

-- | Conditionally prove the equality of <tt>a</tt> and <tt>b</tt>.
testEquality :: forall (a :: k) (b :: k). TestEquality f => f a -> f b -> Maybe (a :~: b)

-- | A type family to compute Boolean equality.
type family (a :: k) == (b :: k) :: Bool
infix 4 ==
instance forall k (a :: k) (b :: k). (a GHC.Types.~ b) => GHC.Internal.Enum.Bounded (a GHC.Internal.Data.Type.Equality.:~: b)
instance forall k1 k2 (a :: k1) (b :: k2). (a GHC.Types.~~ b) => GHC.Internal.Enum.Bounded (a GHC.Internal.Data.Type.Equality.:~~: b)
instance forall k (a :: k) (b :: k). (a GHC.Types.~ b) => GHC.Internal.Enum.Enum (a GHC.Internal.Data.Type.Equality.:~: b)
instance forall k1 k2 (a :: k1) (b :: k2). (a GHC.Types.~~ b) => GHC.Internal.Enum.Enum (a GHC.Internal.Data.Type.Equality.:~~: b)
instance forall k (a :: k) (b :: k). GHC.Classes.Eq (a GHC.Internal.Data.Type.Equality.:~: b)
instance forall k1 k2 (a :: k1) (b :: k2). GHC.Classes.Eq (a GHC.Internal.Data.Type.Equality.:~~: b)
instance forall k (a :: k) (b :: k). GHC.Classes.Ord (a GHC.Internal.Data.Type.Equality.:~: b)
instance forall k1 k2 (a :: k1) (b :: k2). GHC.Classes.Ord (a GHC.Internal.Data.Type.Equality.:~~: b)
instance forall k (a :: k) (b :: k). (a GHC.Types.~ b) => GHC.Internal.Read.Read (a GHC.Internal.Data.Type.Equality.:~: b)
instance forall k1 k2 (a :: k1) (b :: k2). (a GHC.Types.~~ b) => GHC.Internal.Read.Read (a GHC.Internal.Data.Type.Equality.:~~: b)
instance forall k (a :: k) (b :: k). GHC.Internal.Show.Show (a GHC.Internal.Data.Type.Equality.:~: b)
instance forall k1 k2 (a :: k1) (b :: k2). GHC.Internal.Show.Show (a GHC.Internal.Data.Type.Equality.:~~: b)
instance forall k (a :: k). GHC.Internal.Data.Type.Equality.TestEquality ((GHC.Internal.Data.Type.Equality.:~:) a)
instance forall k1 k (a :: k1). GHC.Internal.Data.Type.Equality.TestEquality ((GHC.Internal.Data.Type.Equality.:~~:) a)


-- | Definition of representational equality (<a>Coercion</a>).
module GHC.Internal.Data.Type.Coercion

-- | Representational equality. If <tt>Coercion a b</tt> is inhabited by
--   some terminating value, then the type <tt>a</tt> has the same
--   underlying representation as the type <tt>b</tt>.
--   
--   To use this equality in practice, pattern-match on the <tt>Coercion a
--   b</tt> to get out the <tt>Coercible a b</tt> instance, and then use
--   <a>coerce</a> to apply it.
data Coercion (a :: k) (b :: k)
[Coercion] :: forall {k} (a :: k) (b :: k). Coercible a b => Coercion a b

-- | Type-safe cast, using representational equality
coerceWith :: Coercion a b -> a -> b

-- | Generalized form of type-safe cast using representational equality
gcoerceWith :: forall {k} (a :: k) (b :: k) r. Coercion a b -> (Coercible a b => r) -> r

-- | Symmetry of representational equality
sym :: forall {k} (a :: k) (b :: k). Coercion a b -> Coercion b a

-- | Transitivity of representational equality
trans :: forall {k} (a :: k) (b :: k) (c :: k). Coercion a b -> Coercion b c -> Coercion a c

-- | Convert propositional (nominal) equality to representational equality
repr :: forall {k} (a :: k) (b :: k). (a :~: b) -> Coercion a b

-- | This class contains types where you can learn the equality of two
--   types from information contained in <i>terms</i>. Typically, only
--   singleton types should inhabit this class.
class TestCoercion (f :: k -> Type)

-- | Conditionally prove the representational equality of <tt>a</tt> and
--   <tt>b</tt>.
testCoercion :: forall (a :: k) (b :: k). TestCoercion f => f a -> f b -> Maybe (Coercion a b)
instance forall k (a :: k) (b :: k). GHC.Types.Coercible a b => GHC.Internal.Enum.Bounded (GHC.Internal.Data.Type.Coercion.Coercion a b)
instance forall k (a :: k) (b :: k). GHC.Types.Coercible a b => GHC.Internal.Enum.Enum (GHC.Internal.Data.Type.Coercion.Coercion a b)
instance forall k (a :: k) (b :: k). GHC.Classes.Eq (GHC.Internal.Data.Type.Coercion.Coercion a b)
instance forall k (a :: k) (b :: k). GHC.Classes.Ord (GHC.Internal.Data.Type.Coercion.Coercion a b)
instance forall k (a :: k) (b :: k). GHC.Types.Coercible a b => GHC.Internal.Read.Read (GHC.Internal.Data.Type.Coercion.Coercion a b)
instance forall k (a :: k) (b :: k). GHC.Internal.Show.Show (GHC.Internal.Data.Type.Coercion.Coercion a b)
instance forall k (a :: k). GHC.Internal.Data.Type.Coercion.TestCoercion ((GHC.Internal.Data.Type.Equality.:~:) a)
instance forall k1 k (a :: k1). GHC.Internal.Data.Type.Coercion.TestCoercion ((GHC.Internal.Data.Type.Equality.:~~:) a)
instance forall k (a :: k). GHC.Internal.Data.Type.Coercion.TestCoercion (GHC.Internal.Data.Type.Coercion.Coercion a)


module GHC.Internal.Control.Category

-- | A class for categories.
--   
--   In mathematics, a <i>category</i> is defined as a collection of
--   <i>objects</i> and a collection of <i>morphisms</i> between objects,
--   together with an <i>identity morphism</i> <a>id</a> for every object
--   and an operation <a>(.)</a> that <i>composes</i> compatible morphisms.
--   
--   This class is defined in an analogous way. The collection of morphisms
--   is represented by a type parameter <tt>cat</tt>, which has kind <tt>k
--   -&gt; k -&gt; <a>Type</a></tt> for some kind variable <tt>k</tt> that
--   represents the collection of objects; most of the time the choice of
--   <tt>k</tt> will be <a>Type</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   As the method names suggest, there's a category of functions:
--   
--   <pre>
--   instance Category <tt>(-&gt;)</tt> where
--     id = \x -&gt; x
--     f . g = \x -&gt; f (g x)
--   </pre>
--   
--   Isomorphisms form a category as well:
--   
--   <pre>
--   data Iso a b = Iso (a -&gt; b) (b -&gt; a)
--   
--   instance Category Iso where
--     id = Iso id id
--     Iso f1 g1 . Iso f2 g2 = Iso (f1 . f2) (g2 . g1)
--   </pre>
--   
--   Natural transformations are another important example:
--   
--   <pre>
--   newtype f ~&gt; g = NatTransform (forall x. f x -&gt; g x)
--   
--   instance Category (~&gt;) where
--     id = NatTransform id
--     NatTransform f . NatTransform g = NatTransform (f . g)
--   </pre>
--   
--   Using the <tt>TypeData</tt> language extension, we can also make a
--   category where <tt>k</tt> isn't <tt>Type</tt>, but a custom kind
--   <tt>Door</tt> instead:
--   
--   <pre>
--   type data Door = DoorOpen | DoorClosed
--   
--   data Action (before :: Door) (after :: Door) where
--     DoNothing :: Action door door
--     OpenDoor :: Action start DoorClosed -&gt; Action start DoorOpen
--     CloseDoor :: Action start DoorOpen -&gt; Action start DoorClosed
--   
--   instance Category Action where
--     id = DoNothing
--   
--     DoNothing . action = action
--     OpenDoor rest . action = OpenDoor (rest . action)
--     CloseDoor rest . action = CloseDoor (rest . action)
--   </pre>
class Category (cat :: k -> k -> Type)

-- | The identity morphism. Implementations should satisfy two laws:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>f <a>.</a> <a>id</a> = f</tt></li>
--   <li><i>Left identity</i> <tt><a>id</a> <a>.</a> f = f</tt></li>
--   </ul>
--   
--   These essentially state that <a>id</a> should "do nothing".
id :: forall (a :: k). Category cat => cat a a

-- | Morphism composition. Implementations should satisfy the law:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>f <a>.</a> (g <a>.</a> h) = (f <a>.</a>
--   g) <a>.</a> h</tt></li>
--   </ul>
--   
--   This means that the way morphisms are grouped is irrelevant, so it is
--   unambiguous to write a composition of morphisms as <tt>f <a>.</a> g
--   <a>.</a> h</tt>, without parentheses.
(.) :: forall (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
infixr 9 .

-- | Right-to-left composition. This is a synonym for <a>(.)</a>, but it
--   can be useful to make the order of composition more apparent.
(<<<) :: forall {k} cat (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
infixr 1 <<<

-- | Left-to-right composition. This is useful if you want to write a
--   morphism as a pipeline going from left to right.
(>>>) :: forall {k} cat (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
infixr 1 >>>
instance GHC.Internal.Control.Category.Category (->)
instance GHC.Internal.Control.Category.Category (GHC.Internal.Data.Type.Equality.:~:)
instance GHC.Internal.Control.Category.Category (GHC.Internal.Data.Type.Equality.:~~:)
instance GHC.Internal.Control.Category.Category GHC.Internal.Data.Type.Coercion.Coercion


-- | Definition of a Proxy type (poly-kinded in GHC)
module GHC.Internal.Data.Proxy

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt><a>undefined</a> :: a</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data Proxy (t :: k)
Proxy :: Proxy (t :: k)

-- | <a>asProxyTypeOf</a> is a type-restricted version of <a>const</a>. It
--   is usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   tag of the second.
--   
--   <pre>
--   &gt;&gt;&gt; import GHC.Internal.Word
--   
--   &gt;&gt;&gt; :type asProxyTypeOf 123 (Proxy :: Proxy Word8)
--   asProxyTypeOf 123 (Proxy :: Proxy Word8) :: Word8
--   </pre>
--   
--   Note the lower-case <tt>proxy</tt> in the definition. This allows any
--   type constructor with just one argument to be passed to the function,
--   for example we could also write
--   
--   <pre>
--   &gt;&gt;&gt; import GHC.Internal.Word
--   
--   &gt;&gt;&gt; :type asProxyTypeOf 123 (Just (undefined :: Word8))
--   asProxyTypeOf 123 (Just (undefined :: Word8)) :: Word8
--   </pre>
asProxyTypeOf :: a -> proxy a -> a

-- | A concrete, promotable proxy type, for use at the kind level. There
--   are no instances for this because it is intended at the kind level
--   only
data KProxy t
KProxy :: KProxy t
instance GHC.Internal.Base.Alternative GHC.Internal.Data.Proxy.Proxy
instance GHC.Internal.Base.Applicative GHC.Internal.Data.Proxy.Proxy
instance forall k (t :: k). GHC.Internal.Enum.Bounded (GHC.Internal.Data.Proxy.Proxy t)
instance forall k (s :: k). GHC.Internal.Enum.Enum (GHC.Internal.Data.Proxy.Proxy s)
instance forall k (s :: k). GHC.Classes.Eq (GHC.Internal.Data.Proxy.Proxy s)
instance GHC.Internal.Base.Functor GHC.Internal.Data.Proxy.Proxy
instance forall k (s :: k). GHC.Internal.Ix.Ix (GHC.Internal.Data.Proxy.Proxy s)
instance GHC.Internal.Base.MonadPlus GHC.Internal.Data.Proxy.Proxy
instance GHC.Internal.Base.Monad GHC.Internal.Data.Proxy.Proxy
instance forall k (s :: k). GHC.Internal.Base.Monoid (GHC.Internal.Data.Proxy.Proxy s)
instance forall k (s :: k). GHC.Classes.Ord (GHC.Internal.Data.Proxy.Proxy s)
instance forall k (t :: k). GHC.Internal.Read.Read (GHC.Internal.Data.Proxy.Proxy t)
instance forall k (s :: k). GHC.Internal.Base.Semigroup (GHC.Internal.Data.Proxy.Proxy s)
instance forall k (s :: k). GHC.Internal.Show.Show (GHC.Internal.Data.Proxy.Proxy s)


-- | The Either type, and associated operations.
module GHC.Internal.Data.Either

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | Extracts from a list of <a>Either</a> all the <a>Left</a> elements.
--   All the <a>Left</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; lefts list
--   ["foo","bar","baz"]
--   </pre>
lefts :: [Either a b] -> [a]

-- | Extracts from a list of <a>Either</a> all the <a>Right</a> elements.
--   All the <a>Right</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; rights list
--   [3,7]
--   </pre>
rights :: [Either a b] -> [b]

-- | Return <a>True</a> if the given value is a <a>Left</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLeft (Left "foo")
--   True
--   
--   &gt;&gt;&gt; isLeft (Right 3)
--   False
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isLeft</a> to write a very simple error-reporting function that
--   does absolutely nothing in the case of success, and outputs "ERROR" if
--   any error occurred.
--   
--   This example shows how <a>isLeft</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isLeft e) $ putStrLn "ERROR"
--   
--   &gt;&gt;&gt; report (Right 1)
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   ERROR
--   </pre>
isLeft :: Either a b -> Bool

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isRight (Left "foo")
--   False
--   
--   &gt;&gt;&gt; isRight (Right 3)
--   True
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isRight</a> to write a very simple reporting function that only
--   outputs "SUCCESS" when a computation has succeeded.
--   
--   This example shows how <a>isRight</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isRight e) $ putStrLn "SUCCESS"
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   
--   &gt;&gt;&gt; report (Right 1)
--   SUCCESS
--   </pre>
isRight :: Either a b -> Bool

-- | Return the contents of a <a>Left</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromLeft 1 (Left 3)
--   3
--   
--   &gt;&gt;&gt; fromLeft 1 (Right "foo")
--   1
--   </pre>
fromLeft :: a -> Either a b -> a

-- | Return the contents of a <a>Right</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromRight 1 (Right 3)
--   3
--   
--   &gt;&gt;&gt; fromRight 1 (Left "foo")
--   1
--   </pre>
fromRight :: b -> Either a b -> b

-- | Partitions a list of <a>Either</a> into two lists. All the <a>Left</a>
--   elements are extracted, in order, to the first component of the
--   output. Similarly the <a>Right</a> elements are extracted to the
--   second component of the output.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list
--   (["foo","bar","baz"],[3,7])
--   </pre>
--   
--   The pair returned by <tt><a>partitionEithers</a> x</tt> should be the
--   same pair as <tt>(<a>lefts</a> x, <a>rights</a> x)</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list == (lefts list, rights list)
--   True
--   </pre>
partitionEithers :: [Either a b] -> ([a], [b])
instance GHC.Internal.Base.Applicative (GHC.Internal.Data.Either.Either e)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (GHC.Internal.Data.Either.Either a b)
instance GHC.Internal.Base.Functor (GHC.Internal.Data.Either.Either a)
instance GHC.Internal.Base.Monad (GHC.Internal.Data.Either.Either e)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (GHC.Internal.Data.Either.Either a b)
instance (GHC.Internal.Read.Read a, GHC.Internal.Read.Read b) => GHC.Internal.Read.Read (GHC.Internal.Data.Either.Either a b)
instance GHC.Internal.Base.Semigroup (GHC.Internal.Data.Either.Either a b)
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b) => GHC.Internal.Show.Show (GHC.Internal.Data.Either.Either a b)


-- | Converting strings to values.
--   
--   The <a>Text.Read</a> library is the canonical library to import for
--   <a>Read</a>-class facilities. For GHC only, it offers an extended and
--   much improved <a>Read</a> class, which constitutes a proposed
--   alternative to the Haskell 2010 <a>Read</a>. In particular, writing
--   parsers is easier, and the parsers are much more efficient.
module GHC.Internal.Text.Read

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class Read a

-- | attempts to parse a value from the front of the string, returning a
--   list of (parsed value, remaining string) pairs. If there is no
--   successful parse, the returned list is empty.
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
readsPrec :: Read a => Int -> ReadS a

-- | The method <a>readList</a> is provided to allow the programmer to give
--   a specialised way of parsing lists of values. For example, this is
--   used by the predefined <a>Read</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> are expected to use double quotes,
--   rather than square brackets.
readList :: Read a => ReadS [a]

-- | Proposed replacement for <a>readsPrec</a> using new-style parsers (GHC
--   only).
readPrec :: Read a => ReadPrec a

-- | Proposed replacement for <a>readList</a> using new-style parsers (GHC
--   only). The default definition uses <a>readList</a>. Instances that
--   define <a>readPrec</a> should also define <a>readListPrec</a> as
--   <a>readListPrecDefault</a>.
readListPrec :: Read a => ReadPrec [a]

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process. <a>read</a> fails with an
--   <a>error</a> if the parse is unsuccessful, and it is therefore
--   discouraged from being used in real applications. Use <a>readMaybe</a>
--   or <a>readEither</a> for safe alternatives.
--   
--   <pre>
--   &gt;&gt;&gt; read "123" :: Int
--   123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "hello" :: Int
--   *** Exception: Prelude.read: no parse
--   </pre>
read :: Read a => String -> a

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: Bool -> ReadS a -> ReadS a

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String
data Lexeme

-- | Character literal
Char :: Char -> Lexeme

-- | String literal, with escapes interpreted
String :: String -> Lexeme

-- | Punctuation or reserved symbol, e.g. <tt>(</tt>, <tt>::</tt>
Punc :: String -> Lexeme

-- | Haskell identifier, e.g. <tt>foo</tt>, <tt>Baz</tt>
Ident :: String -> Lexeme

-- | Haskell symbol, e.g. <tt>&gt;&gt;</tt>, <tt>:%</tt>
Symbol :: String -> Lexeme

Number :: Number -> Lexeme
EOF :: Lexeme

-- | Parse a single lexeme
lexP :: ReadPrec Lexeme

-- | <tt>(parens p)</tt> parses "P", "(P0)", "((P0))", etc, where
--   <tt>p</tt> parses "P" in the current precedence context and parses
--   "P0" in precedence context zero
parens :: ReadPrec a -> ReadPrec a

-- | A possible replacement definition for the <a>readList</a> method (GHC
--   only). This is only needed for GHC, and even then only for <a>Read</a>
--   instances where <a>readListPrec</a> isn't defined as
--   <a>readListPrecDefault</a>.
readListDefault :: Read a => ReadS [a]

-- | A possible replacement definition for the <a>readListPrec</a> method,
--   defined using <a>readPrec</a> (GHC only).
readListPrecDefault :: Read a => ReadPrec [a]

-- | Parse a string using the <a>Read</a> instance. Succeeds if there is
--   exactly one valid result. A <a>Left</a> value indicates a parse error.
--   
--   <pre>
--   &gt;&gt;&gt; readEither "123" :: Either String Int
--   Right 123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; readEither "hello" :: Either String Int
--   Left "Prelude.read: no parse"
--   </pre>
readEither :: Read a => String -> Either String a

-- | Parse a string using the <a>Read</a> instance. Succeeds if there is
--   exactly one valid result.
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "123" :: Maybe Int
--   Just 123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "hello" :: Maybe Int
--   Nothing
--   </pre>
readMaybe :: Read a => String -> Maybe a


-- | This module defines bitwise operations for signed and unsigned
--   integers. Instances of the class <a>Bits</a> for the <a>Int</a> and
--   <tt>Integer</tt> types are available from this module, and instances
--   for explicitly sized integral types are available from the
--   <a>Data.Int</a> and <a>Data.Word</a> modules.
module GHC.Internal.Data.Bits

-- | The <a>Bits</a> class defines bitwise operations over integral types.
--   
--   <ul>
--   <li>Bits are numbered from 0 with bit 0 being the least significant
--   bit.</li>
--   </ul>
class Eq a => Bits a

-- | Bitwise "and"
(.&.) :: Bits a => a -> a -> a

-- | Bitwise "or"
(.|.) :: Bits a => a -> a -> a

-- | Bitwise "xor"
xor :: Bits a => a -> a -> a

-- | Reverse all the bits in the argument
complement :: Bits a => a -> a

-- | <tt><a>shift</a> x i</tt> shifts <tt>x</tt> left by <tt>i</tt> bits if
--   <tt>i</tt> is positive, or right by <tt>-i</tt> bits otherwise. Right
--   shifts perform sign extension on signed number types; i.e. they fill
--   the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   An instance can define either this unified <a>shift</a> or
--   <a>shiftL</a> and <a>shiftR</a>, depending on which is more convenient
--   for the type in question.
shift :: Bits a => a -> Int -> a

-- | <tt><a>rotate</a> x i</tt> rotates <tt>x</tt> left by <tt>i</tt> bits
--   if <tt>i</tt> is positive, or right by <tt>-i</tt> bits otherwise.
--   
--   For unbounded types like <a>Integer</a>, <a>rotate</a> is equivalent
--   to <a>shift</a>.
--   
--   An instance can define either this unified <a>rotate</a> or
--   <a>rotateL</a> and <a>rotateR</a>, depending on which is more
--   convenient for the type in question.
rotate :: Bits a => a -> Int -> a

-- | <a>zeroBits</a> is the value with all bits unset.
--   
--   The following laws ought to hold (for all valid bit indices
--   <tt><i>n</i></tt>):
--   
--   <ul>
--   <li><pre><a>clearBit</a> <a>zeroBits</a> <i>n</i> ==
--   <a>zeroBits</a></pre></li>
--   <li><pre><a>setBit</a> <a>zeroBits</a> <i>n</i> == <a>bit</a>
--   <i>n</i></pre></li>
--   <li><pre><a>testBit</a> <a>zeroBits</a> <i>n</i> == False</pre></li>
--   <li><pre><a>popCount</a> <a>zeroBits</a> == 0</pre></li>
--   </ul>
--   
--   This method uses <tt><a>clearBit</a> (<a>bit</a> 0) 0</tt> as its
--   default implementation (which ought to be equivalent to
--   <a>zeroBits</a> for types which possess a 0th bit).
zeroBits :: Bits a => a

-- | <tt>bit <i>i</i></tt> is a value with the <tt><i>i</i></tt>th bit set
--   and all other bits clear.
--   
--   Can be implemented using <tt>bitDefault</tt> if <tt>a</tt> is also an
--   instance of <a>Num</a>.
--   
--   See also <a>zeroBits</a>.
bit :: Bits a => Int -> a

-- | <tt>x `setBit` i</tt> is the same as <tt>x .|. bit i</tt>
setBit :: Bits a => a -> Int -> a

-- | <tt>x `clearBit` i</tt> is the same as <tt>x .&amp;. complement (bit
--   i)</tt>
clearBit :: Bits a => a -> Int -> a

-- | <tt>x `complementBit` i</tt> is the same as <tt>x `xor` bit i</tt>
complementBit :: Bits a => a -> Int -> a

-- | <tt>x `testBit` i</tt> is the same as <tt>x .&amp;. bit n /= 0</tt>
--   
--   In other words it returns True if the bit at offset @n is set.
--   
--   Can be implemented using <tt>testBitDefault</tt> if <tt>a</tt> is also
--   an instance of <a>Num</a>.
testBit :: Bits a => a -> Int -> Bool

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. Returns Nothing for types that do
--   not have a fixed bitsize, like <a>Integer</a>.
bitSizeMaybe :: Bits a => a -> Maybe Int

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. The function <a>bitSize</a> is
--   undefined for types that do not have a fixed bitsize, like
--   <a>Integer</a>.
--   
--   Default implementation based upon <a>bitSizeMaybe</a> provided since
--   4.12.0.0.

-- | <i>Deprecated: Use <a>bitSizeMaybe</a> or <a>finiteBitSize</a>
--   instead</i>
bitSize :: Bits a => a -> Int

-- | Return <a>True</a> if the argument is a signed type. The actual value
--   of the argument is ignored
isSigned :: Bits a => a -> Bool

-- | Shift the argument left by the specified number of bits (which must be
--   non-negative). Some instances may throw an <a>Overflow</a> exception
--   if given a negative input.
--   
--   An instance can define either this and <a>shiftR</a> or the unified
--   <a>shift</a>, depending on which is more convenient for the type in
--   question.
shiftL :: Bits a => a -> Int -> a

-- | Shift the argument left by the specified number of bits. The result is
--   undefined for negative shift amounts and shift amounts greater or
--   equal to the <a>bitSize</a>.
--   
--   Defaults to <a>shiftL</a> unless defined explicitly by an instance.
unsafeShiftL :: Bits a => a -> Int -> a

-- | Shift the first argument right by the specified number of bits. The
--   result is undefined for negative shift amounts and shift amounts
--   greater or equal to the <a>bitSize</a>. Some instances may throw an
--   <a>Overflow</a> exception if given a negative input.
--   
--   Right shifts perform sign extension on signed number types; i.e. they
--   fill the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   An instance can define either this and <a>shiftL</a> or the unified
--   <a>shift</a>, depending on which is more convenient for the type in
--   question.
shiftR :: Bits a => a -> Int -> a

-- | Shift the first argument right by the specified number of bits, which
--   must be non-negative and smaller than the number of bits in the type.
--   
--   Right shifts perform sign extension on signed number types; i.e. they
--   fill the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   Defaults to <a>shiftR</a> unless defined explicitly by an instance.
unsafeShiftR :: Bits a => a -> Int -> a

-- | Rotate the argument left by the specified number of bits (which must
--   be non-negative).
--   
--   An instance can define either this and <a>rotateR</a> or the unified
--   <a>rotate</a>, depending on which is more convenient for the type in
--   question.
rotateL :: Bits a => a -> Int -> a

-- | Rotate the argument right by the specified number of bits (which must
--   be non-negative).
--   
--   An instance can define either this and <a>rotateL</a> or the unified
--   <a>rotate</a>, depending on which is more convenient for the type in
--   question.
rotateR :: Bits a => a -> Int -> a

-- | Return the number of set bits in the argument. This number is known as
--   the population count or the Hamming weight.
--   
--   Can be implemented using <tt>popCountDefault</tt> if <tt>a</tt> is
--   also an instance of <a>Num</a>.
popCount :: Bits a => a -> Int
infixl 7 .&.
infixl 5 .|.
infixl 6 `xor`
infixl 8 `shift`
infixl 8 `rotate`
infixl 8 `shiftL`
infixl 8 `shiftR`
infixl 8 `rotateL`
infixl 8 `rotateR`

-- | The <a>FiniteBits</a> class denotes types with a finite, fixed number
--   of bits.
class Bits b => FiniteBits b

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. Moreover, <a>finiteBitSize</a> is
--   total, in contrast to the deprecated <a>bitSize</a> function it
--   replaces.
--   
--   <pre>
--   <a>finiteBitSize</a> = <a>bitSize</a>
--   <a>bitSizeMaybe</a> = <a>Just</a> . <a>finiteBitSize</a>
--   </pre>
finiteBitSize :: FiniteBits b => b -> Int

-- | Count number of zero bits preceding the most significant set bit.
--   
--   <pre>
--   <a>countLeadingZeros</a> (<a>zeroBits</a> :: a) = finiteBitSize (<a>zeroBits</a> :: a)
--   </pre>
--   
--   <a>countLeadingZeros</a> can be used to compute log base 2 via
--   
--   <pre>
--   logBase2 x = <a>finiteBitSize</a> x - 1 - <a>countLeadingZeros</a> x
--   </pre>
--   
--   Note: The default implementation for this method is intentionally
--   naive. However, the instances provided for the primitive integral
--   types are implemented using CPU specific machine instructions.
countLeadingZeros :: FiniteBits b => b -> Int

-- | Count number of zero bits following the least significant set bit.
--   
--   <pre>
--   <a>countTrailingZeros</a> (<a>zeroBits</a> :: a) = finiteBitSize (<a>zeroBits</a> :: a)
--   <a>countTrailingZeros</a> . <a>negate</a> = <a>countTrailingZeros</a>
--   </pre>
--   
--   The related <a>find-first-set operation</a> can be expressed in terms
--   of <a>countTrailingZeros</a> as follows
--   
--   <pre>
--   findFirstSet x = 1 + <a>countTrailingZeros</a> x
--   </pre>
--   
--   Note: The default implementation for this method is intentionally
--   naive. However, the instances provided for the primitive integral
--   types are implemented using CPU specific machine instructions.
countTrailingZeros :: FiniteBits b => b -> Int

-- | Default implementation for <a>bit</a>.
--   
--   Note that: <tt>bitDefault i = 1 <a>shiftL</a> i</tt>
bitDefault :: (Bits a, Num a) => Int -> a

-- | Default implementation for <a>testBit</a>.
--   
--   Note that: <tt>testBitDefault x i = (x .&amp;. bit i) /= 0</tt>
testBitDefault :: (Bits a, Num a) => a -> Int -> Bool

-- | Default implementation for <a>popCount</a>.
--   
--   This implementation is intentionally naive. Instances are expected to
--   provide an optimized implementation for their size.
popCountDefault :: (Bits a, Num a) => a -> Int

-- | Attempt to convert an <a>Integral</a> type <tt>a</tt> to an
--   <a>Integral</a> type <tt>b</tt> using the size of the types as
--   measured by <a>Bits</a> methods.
--   
--   A simpler version of this function is:
--   
--   <pre>
--   toIntegral :: (Integral a, Integral b) =&gt; a -&gt; Maybe b
--   toIntegral x
--     | toInteger x == toInteger y = Just y
--     | otherwise                  = Nothing
--     where
--       y = fromIntegral x
--   </pre>
--   
--   This version requires going through <a>Integer</a>, which can be
--   inefficient. However, <tt>toIntegralSized</tt> is optimized to allow
--   GHC to statically determine the relative type sizes (as measured by
--   <a>bitSizeMaybe</a> and <a>isSigned</a>) and avoid going through
--   <a>Integer</a> for many types. (The implementation uses
--   <a>fromIntegral</a>, which is itself optimized with rules for
--   <tt>base</tt> types but may go through <a>Integer</a> for some type
--   pairs.)
toIntegralSized :: (Integral a, Integral b, Bits a, Bits b) => a -> Maybe b

-- | A more concise version of <tt>complement zeroBits</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; complement (zeroBits :: Word) == (oneBits :: Word)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; complement (oneBits :: Word) == (zeroBits :: Word)
--   True
--   </pre>
--   
--   <h1>Note</h1>
--   
--   The constraint on <a>oneBits</a> is arguably too strong. However, as
--   some types (such as <tt>Natural</tt>) have undefined
--   <a>complement</a>, this is the only safe choice.
oneBits :: FiniteBits a => a

-- | Infix version of <a>xor</a>.
(.^.) :: Bits a => a -> a -> a
infixl 6 .^.

-- | Infix version of <a>shiftR</a>.
(.>>.) :: Bits a => a -> Int -> a
infixl 8 .>>.

-- | Infix version of <a>shiftL</a>.
(.<<.) :: Bits a => a -> Int -> a
infixl 8 .<<.

-- | Infix version of <a>unsafeShiftR</a>.
(!>>.) :: Bits a => a -> Int -> a
infixl 8 !>>.

-- | Infix version of <a>unsafeShiftL</a>.
(!<<.) :: Bits a => a -> Int -> a
infixl 8 !<<.

-- | Monoid under bitwise AND.
--   
--   <pre>
--   &gt;&gt;&gt; getAnd (And 0xab &lt;&gt; And 0x12) :: Word8
--   2
--   </pre>
newtype And a
And :: a -> And a
[getAnd] :: And a -> a

-- | Monoid under bitwise inclusive OR.
--   
--   <pre>
--   &gt;&gt;&gt; getIor (Ior 0xab &lt;&gt; Ior 0x12) :: Word8
--   187
--   </pre>
newtype Ior a
Ior :: a -> Ior a
[getIor] :: Ior a -> a

-- | Monoid under bitwise XOR.
--   
--   <pre>
--   &gt;&gt;&gt; getXor (Xor 0xab &lt;&gt; Xor 0x12) :: Word8
--   185
--   </pre>
newtype Xor a
Xor :: a -> Xor a
[getXor] :: Xor a -> a

-- | Monoid under bitwise 'equality'; defined as <tt>1</tt> if the
--   corresponding bits match, and <tt>0</tt> otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; getIff (Iff 0xab &lt;&gt; Iff 0x12) :: Word8
--   70
--   </pre>
newtype Iff a
Iff :: a -> Iff a
[getIff] :: Iff a -> a
instance GHC.Internal.Bits.Bits a => GHC.Internal.Bits.Bits (GHC.Internal.Data.Bits.And a)
instance GHC.Internal.Bits.Bits a => GHC.Internal.Bits.Bits (GHC.Internal.Data.Bits.Iff a)
instance GHC.Internal.Bits.Bits a => GHC.Internal.Bits.Bits (GHC.Internal.Data.Bits.Ior a)
instance GHC.Internal.Bits.Bits a => GHC.Internal.Bits.Bits (GHC.Internal.Data.Bits.Xor a)
instance GHC.Internal.Enum.Bounded a => GHC.Internal.Enum.Bounded (GHC.Internal.Data.Bits.And a)
instance GHC.Internal.Enum.Bounded a => GHC.Internal.Enum.Bounded (GHC.Internal.Data.Bits.Iff a)
instance GHC.Internal.Enum.Bounded a => GHC.Internal.Enum.Bounded (GHC.Internal.Data.Bits.Ior a)
instance GHC.Internal.Enum.Bounded a => GHC.Internal.Enum.Bounded (GHC.Internal.Data.Bits.Xor a)
instance GHC.Internal.Enum.Enum a => GHC.Internal.Enum.Enum (GHC.Internal.Data.Bits.And a)
instance GHC.Internal.Enum.Enum a => GHC.Internal.Enum.Enum (GHC.Internal.Data.Bits.Iff a)
instance GHC.Internal.Enum.Enum a => GHC.Internal.Enum.Enum (GHC.Internal.Data.Bits.Ior a)
instance GHC.Internal.Enum.Enum a => GHC.Internal.Enum.Enum (GHC.Internal.Data.Bits.Xor a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Internal.Data.Bits.And a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Internal.Data.Bits.Iff a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Internal.Data.Bits.Ior a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Internal.Data.Bits.Xor a)
instance GHC.Internal.Bits.FiniteBits a => GHC.Internal.Bits.FiniteBits (GHC.Internal.Data.Bits.And a)
instance GHC.Internal.Bits.FiniteBits a => GHC.Internal.Bits.FiniteBits (GHC.Internal.Data.Bits.Iff a)
instance GHC.Internal.Bits.FiniteBits a => GHC.Internal.Bits.FiniteBits (GHC.Internal.Data.Bits.Ior a)
instance GHC.Internal.Bits.FiniteBits a => GHC.Internal.Bits.FiniteBits (GHC.Internal.Data.Bits.Xor a)
instance GHC.Internal.Bits.FiniteBits a => GHC.Internal.Base.Monoid (GHC.Internal.Data.Bits.And a)
instance GHC.Internal.Bits.FiniteBits a => GHC.Internal.Base.Monoid (GHC.Internal.Data.Bits.Iff a)
instance GHC.Internal.Bits.Bits a => GHC.Internal.Base.Monoid (GHC.Internal.Data.Bits.Ior a)
instance GHC.Internal.Bits.Bits a => GHC.Internal.Base.Monoid (GHC.Internal.Data.Bits.Xor a)
instance GHC.Internal.Read.Read a => GHC.Internal.Read.Read (GHC.Internal.Data.Bits.And a)
instance GHC.Internal.Read.Read a => GHC.Internal.Read.Read (GHC.Internal.Data.Bits.Iff a)
instance GHC.Internal.Read.Read a => GHC.Internal.Read.Read (GHC.Internal.Data.Bits.Ior a)
instance GHC.Internal.Read.Read a => GHC.Internal.Read.Read (GHC.Internal.Data.Bits.Xor a)
instance GHC.Internal.Bits.Bits a => GHC.Internal.Base.Semigroup (GHC.Internal.Data.Bits.And a)
instance GHC.Internal.Bits.FiniteBits a => GHC.Internal.Base.Semigroup (GHC.Internal.Data.Bits.Iff a)
instance GHC.Internal.Bits.Bits a => GHC.Internal.Base.Semigroup (GHC.Internal.Data.Bits.Ior a)
instance GHC.Internal.Bits.Bits a => GHC.Internal.Base.Semigroup (GHC.Internal.Data.Bits.Xor a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Internal.Data.Bits.And a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Internal.Data.Bits.Iff a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Internal.Data.Bits.Ior a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Internal.Data.Bits.Xor a)


-- | The sized integral datatypes, <a>Int8</a>, <a>Int16</a>, <a>Int32</a>,
--   and <a>Int64</a>.
module GHC.Internal.Int

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int
I# :: Int# -> Int

-- | 8-bit signed integer type
data Int8
I8# :: Int8# -> Int8

-- | 16-bit signed integer type
data Int16
I16# :: Int16# -> Int16

-- | 32-bit signed integer type
data Int32
I32# :: Int32# -> Int32

-- | 64-bit signed integer type
data Int64
I64# :: Int64# -> Int64
uncheckedIShiftL64# :: Int64# -> Int# -> Int64#
uncheckedIShiftRA64# :: Int64# -> Int# -> Int64#
shiftRLInt8# :: Int8# -> Int# -> Int8#
shiftRLInt16# :: Int16# -> Int# -> Int16#
shiftRLInt32# :: Int32# -> Int# -> Int32#
eqInt :: Int -> Int -> Bool
neInt :: Int -> Int -> Bool
gtInt :: Int -> Int -> Bool
geInt :: Int -> Int -> Bool
ltInt :: Int -> Int -> Bool
leInt :: Int -> Int -> Bool
eqInt8 :: Int8 -> Int8 -> Bool
neInt8 :: Int8 -> Int8 -> Bool
gtInt8 :: Int8 -> Int8 -> Bool
geInt8 :: Int8 -> Int8 -> Bool
ltInt8 :: Int8 -> Int8 -> Bool
leInt8 :: Int8 -> Int8 -> Bool
eqInt16 :: Int16 -> Int16 -> Bool
neInt16 :: Int16 -> Int16 -> Bool
gtInt16 :: Int16 -> Int16 -> Bool
geInt16 :: Int16 -> Int16 -> Bool
ltInt16 :: Int16 -> Int16 -> Bool
leInt16 :: Int16 -> Int16 -> Bool
eqInt32 :: Int32 -> Int32 -> Bool
neInt32 :: Int32 -> Int32 -> Bool
gtInt32 :: Int32 -> Int32 -> Bool
geInt32 :: Int32 -> Int32 -> Bool
ltInt32 :: Int32 -> Int32 -> Bool
leInt32 :: Int32 -> Int32 -> Bool
eqInt64 :: Int64 -> Int64 -> Bool
neInt64 :: Int64 -> Int64 -> Bool
gtInt64 :: Int64 -> Int64 -> Bool
geInt64 :: Int64 -> Int64 -> Bool
ltInt64 :: Int64 -> Int64 -> Bool
leInt64 :: Int64 -> Int64 -> Bool
instance GHC.Internal.Bits.Bits GHC.Internal.Int.Int16
instance GHC.Internal.Bits.Bits GHC.Internal.Int.Int32
instance GHC.Internal.Bits.Bits GHC.Internal.Int.Int64
instance GHC.Internal.Bits.Bits GHC.Internal.Int.Int8
instance GHC.Internal.Enum.Bounded GHC.Internal.Int.Int16
instance GHC.Internal.Enum.Bounded GHC.Internal.Int.Int32
instance GHC.Internal.Enum.Bounded GHC.Internal.Int.Int64
instance GHC.Internal.Enum.Bounded GHC.Internal.Int.Int8
instance GHC.Internal.Enum.Enum GHC.Internal.Int.Int16
instance GHC.Internal.Enum.Enum GHC.Internal.Int.Int32
instance GHC.Internal.Enum.Enum GHC.Internal.Int.Int64
instance GHC.Internal.Enum.Enum GHC.Internal.Int.Int8
instance GHC.Classes.Eq GHC.Internal.Int.Int16
instance GHC.Classes.Eq GHC.Internal.Int.Int32
instance GHC.Classes.Eq GHC.Internal.Int.Int64
instance GHC.Classes.Eq GHC.Internal.Int.Int8
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Int.Int16
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Int.Int32
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Int.Int64
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Int.Int8
instance GHC.Internal.Real.Integral GHC.Internal.Int.Int16
instance GHC.Internal.Real.Integral GHC.Internal.Int.Int32
instance GHC.Internal.Real.Integral GHC.Internal.Int.Int64
instance GHC.Internal.Real.Integral GHC.Internal.Int.Int8
instance GHC.Internal.Ix.Ix GHC.Internal.Int.Int16
instance GHC.Internal.Ix.Ix GHC.Internal.Int.Int32
instance GHC.Internal.Ix.Ix GHC.Internal.Int.Int64
instance GHC.Internal.Ix.Ix GHC.Internal.Int.Int8
instance GHC.Internal.Num.Num GHC.Internal.Int.Int16
instance GHC.Internal.Num.Num GHC.Internal.Int.Int32
instance GHC.Internal.Num.Num GHC.Internal.Int.Int64
instance GHC.Internal.Num.Num GHC.Internal.Int.Int8
instance GHC.Classes.Ord GHC.Internal.Int.Int16
instance GHC.Classes.Ord GHC.Internal.Int.Int32
instance GHC.Classes.Ord GHC.Internal.Int.Int64
instance GHC.Classes.Ord GHC.Internal.Int.Int8
instance GHC.Internal.Read.Read GHC.Internal.Int.Int16
instance GHC.Internal.Read.Read GHC.Internal.Int.Int32
instance GHC.Internal.Read.Read GHC.Internal.Int.Int64
instance GHC.Internal.Read.Read GHC.Internal.Int.Int8
instance GHC.Internal.Real.Real GHC.Internal.Int.Int16
instance GHC.Internal.Real.Real GHC.Internal.Int.Int32
instance GHC.Internal.Real.Real GHC.Internal.Int.Int64
instance GHC.Internal.Real.Real GHC.Internal.Int.Int8
instance GHC.Internal.Show.Show GHC.Internal.Int.Int16
instance GHC.Internal.Show.Show GHC.Internal.Int.Int32
instance GHC.Internal.Show.Show GHC.Internal.Int.Int64
instance GHC.Internal.Show.Show GHC.Internal.Int.Int8


-- | Odds and ends, mostly functions for reading and showing
--   <a>RealFloat</a>-like kind of values.
module GHC.Internal.Numeric

-- | Converts a possibly-negative <a>Real</a> value to a string.
showSigned :: Real a => (a -> ShowS) -> Int -> a -> ShowS

-- | Shows a <i>non-negative</i> <a>Integral</a> number using the base
--   specified by the first argument, and the character representation
--   specified by the second.
showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS

-- | Show <i>non-negative</i> <a>Integral</a> numbers in base 10.
showInt :: Integral a => a -> ShowS

-- | Show <i>non-negative</i> <a>Integral</a> numbers in base 2.
showBin :: Integral a => a -> ShowS

-- | Show <i>non-negative</i> <a>Integral</a> numbers in base 16.
showHex :: Integral a => a -> ShowS

-- | Show <i>non-negative</i> <a>Integral</a> numbers in base 8.
showOct :: Integral a => a -> ShowS

-- | Show a signed <a>RealFloat</a> value using scientific (exponential)
--   notation (e.g. <tt>2.45e2</tt>, <tt>1.5e-3</tt>).
--   
--   In the call <tt><a>showEFloat</a> digs val</tt>, if <tt>digs</tt> is
--   <a>Nothing</a>, the value is shown to full precision; if <tt>digs</tt>
--   is <tt><a>Just</a> d</tt>, then at most <tt>d</tt> digits after the
--   decimal point are shown.
showEFloat :: RealFloat a => Maybe Int -> a -> ShowS

-- | Show a signed <a>RealFloat</a> value using standard decimal notation
--   (e.g. <tt>245000</tt>, <tt>0.0015</tt>).
--   
--   In the call <tt><a>showFFloat</a> digs val</tt>, if <tt>digs</tt> is
--   <a>Nothing</a>, the value is shown to full precision; if <tt>digs</tt>
--   is <tt><a>Just</a> d</tt>, then at most <tt>d</tt> digits after the
--   decimal point are shown.
showFFloat :: RealFloat a => Maybe Int -> a -> ShowS

-- | Show a signed <a>RealFloat</a> value using standard decimal notation
--   for arguments whose absolute value lies between <tt>0.1</tt> and
--   <tt>9,999,999</tt>, and scientific notation otherwise.
--   
--   In the call <tt><a>showGFloat</a> digs val</tt>, if <tt>digs</tt> is
--   <a>Nothing</a>, the value is shown to full precision; if <tt>digs</tt>
--   is <tt><a>Just</a> d</tt>, then at most <tt>d</tt> digits after the
--   decimal point are shown.
showGFloat :: RealFloat a => Maybe Int -> a -> ShowS

-- | Show a signed <a>RealFloat</a> value using standard decimal notation
--   (e.g. <tt>245000</tt>, <tt>0.0015</tt>).
--   
--   This behaves as <a>showFFloat</a>, except that a decimal point is
--   always guaranteed, even if not needed.
showFFloatAlt :: RealFloat a => Maybe Int -> a -> ShowS

-- | Show a signed <a>RealFloat</a> value using standard decimal notation
--   for arguments whose absolute value lies between <tt>0.1</tt> and
--   <tt>9,999,999</tt>, and scientific notation otherwise.
--   
--   This behaves as <a>showFFloat</a>, except that a decimal point is
--   always guaranteed, even if not needed.
showGFloatAlt :: RealFloat a => Maybe Int -> a -> ShowS

-- | Show a signed <a>RealFloat</a> value to full precision using standard
--   decimal notation for arguments whose absolute value lies between
--   <tt>0.1</tt> and <tt>9,999,999</tt>, and scientific notation
--   otherwise.
showFloat :: RealFloat a => a -> ShowS

-- | Show a floating-point value in the hexadecimal format, similar to the
--   <tt>%a</tt> specifier in C's printf.
--   
--   <pre>
--   &gt;&gt;&gt; showHFloat (212.21 :: Double) ""
--   "0x1.a86b851eb851fp7"
--   
--   &gt;&gt;&gt; showHFloat (-12.76 :: Float) ""
--   "-0x1.9851ecp3"
--   
--   &gt;&gt;&gt; showHFloat (-0 :: Double) ""
--   "-0x0p+0"
--   </pre>
showHFloat :: RealFloat a => a -> ShowS

-- | <a>floatToDigits</a> takes a base and a non-negative <a>RealFloat</a>
--   number, and returns a list of digits and an exponent. In particular,
--   if <tt>x&gt;=0</tt>, and
--   
--   <pre>
--   floatToDigits base x = ([d1,d2,...,dn], e)
--   </pre>
--   
--   then
--   
--   <ol>
--   <li><pre>n &gt;= 1</pre></li>
--   <li><pre>x = 0.d1d2...dn * (base**e)</pre></li>
--   <li><pre>0 &lt;= di &lt;= base-1</pre></li>
--   </ol>
floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)

-- | Reads a <i>signed</i> <a>Real</a> value, given a reader for an
--   unsigned value.
readSigned :: Real a => ReadS a -> ReadS a

-- | Reads an <i>unsigned</i> integral value in an arbitrary base.
readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a

-- | Read an unsigned number in binary notation.
--   
--   <pre>
--   &gt;&gt;&gt; readBin "10011"
--   [(19,"")]
--   </pre>
readBin :: (Eq a, Num a) => ReadS a

-- | Read an unsigned number in decimal notation.
--   
--   <pre>
--   &gt;&gt;&gt; readDec "0644"
--   [(644,"")]
--   </pre>
readDec :: (Eq a, Num a) => ReadS a

-- | Read an unsigned number in octal notation.
--   
--   <pre>
--   &gt;&gt;&gt; readOct "0644"
--   [(420,"")]
--   </pre>
readOct :: (Eq a, Num a) => ReadS a

-- | Read an unsigned number in hexadecimal notation. Both upper or lower
--   case letters are allowed.
--   
--   <pre>
--   &gt;&gt;&gt; readHex "deadbeef"
--   [(3735928559,"")]
--   </pre>
readHex :: (Eq a, Num a) => ReadS a

-- | Reads an <i>unsigned</i> <a>RealFrac</a> value, expressed in decimal
--   scientific notation.
--   
--   Note that this function takes time linear in the magnitude of its
--   input which can scale exponentially with input size (e.g.
--   <tt>"1e100000000"</tt> is a very large number while having a very
--   small textual form). For this reason, users should take care to avoid
--   using this function on untrusted input. Users needing to parse
--   floating point values (e.g. <a>Float</a>) are encouraged to instead
--   use <tt>read</tt>, which does not suffer from this issue.
readFloat :: RealFrac a => ReadS a

-- | Reads a non-empty string of decimal digits.
lexDigits :: ReadS String

-- | Converts a <a>Rational</a> value into any type in class
--   <a>RealFloat</a>.
fromRat :: RealFloat a => Rational -> a

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   <tt>(<a>+</a>)</tt>, <tt>(<a>*</a>)</tt> and <a>exp</a> are
--   customarily expected to define an exponential field and have the
--   following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = <tt>exp a * exp b</tt></li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class Fractional a => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a

-- | <tt><a>log1p</a> x</tt> computes <tt><a>log</a> (1 + x)</tt>, but
--   provides more precise results for small (absolute) values of
--   <tt>x</tt> if possible.
log1p :: Floating a => a -> a

-- | <tt><a>expm1</a> x</tt> computes <tt><a>exp</a> x - 1</tt>, but
--   provides more precise results for small (absolute) values of
--   <tt>x</tt> if possible.
expm1 :: Floating a => a -> a

-- | <tt><a>log1pexp</a> x</tt> computes <tt><a>log</a> (1 + <a>exp</a>
--   x)</tt>, but provides more precise results if possible.
--   
--   Examples:
--   
--   <ul>
--   <li>if <tt>x</tt> is a large negative number, <tt><a>log</a> (1 +
--   <a>exp</a> x)</tt> will be imprecise for the reasons given in
--   <a>log1p</a>.</li>
--   <li>if <tt><a>exp</a> x</tt> is close to <tt>-1</tt>, <tt><a>log</a>
--   (1 + <a>exp</a> x)</tt> will be imprecise for the reasons given in
--   <a>expm1</a>.</li>
--   </ul>
log1pexp :: Floating a => a -> a

-- | <tt><a>log1mexp</a> x</tt> computes <tt><a>log</a> (1 - <a>exp</a>
--   x)</tt>, but provides more precise results if possible.
--   
--   Examples:
--   
--   <ul>
--   <li>if <tt>x</tt> is a large negative number, <tt><a>log</a> (1 -
--   <a>exp</a> x)</tt> will be imprecise for the reasons given in
--   <a>log1p</a>.</li>
--   <li>if <tt><a>exp</a> x</tt> is close to <tt>1</tt>, <tt><a>log</a> (1
--   - <a>exp</a> x)</tt> will be imprecise for the reasons given in
--   <a>expm1</a>.</li>
--   </ul>
log1mexp :: Floating a => a -> a
infixr 8 **


-- | The <a>Ptr</a> and <a>FunPtr</a> types and operations.
module GHC.Internal.Ptr

-- | A value of type <tt><a>Ptr</a> a</tt> represents a pointer to an
--   object, or an array of objects, which may be marshalled to or from
--   Haskell values of type <tt>a</tt>.
--   
--   The type <tt>a</tt> will often be an instance of class <a>Storable</a>
--   which provides the marshalling operations. However this is not
--   essential, and you can provide your own operations to access the
--   pointer. For example you might write small foreign functions to get or
--   set the fields of a C <tt>struct</tt>.
data Ptr a
Ptr :: Addr# -> Ptr a

-- | A value of type <tt><a>FunPtr</a> a</tt> is a pointer to a function
--   callable from foreign code. The type <tt>a</tt> will normally be a
--   <i>foreign type</i>, a function type with zero or more arguments where
--   
--   <ul>
--   <li>the argument types are <i>marshallable foreign types</i>, i.e.
--   <a>Char</a>, <a>Int</a>, <a>Double</a>, <a>Float</a>, <a>Bool</a>,
--   <a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>, <a>Word8</a>,
--   <a>Word16</a>, <a>Word32</a>, <a>Word64</a>, <tt><a>Ptr</a> a</tt>,
--   <tt><a>FunPtr</a> a</tt>, <tt><a>StablePtr</a> a</tt> or a renaming of
--   any of these using <tt>newtype</tt>.</li>
--   <li>the return type is either a marshallable foreign type or has the
--   form <tt><a>IO</a> t</tt> where <tt>t</tt> is a marshallable foreign
--   type or <tt>()</tt>.</li>
--   </ul>
--   
--   A value of type <tt><a>FunPtr</a> a</tt> may be a pointer to a foreign
--   function, either returned by another foreign function or imported with
--   a a static address import like
--   
--   <pre>
--   foreign import ccall "stdlib.h &amp;free"
--     p_free :: FunPtr (Ptr a -&gt; IO ())
--   </pre>
--   
--   or a pointer to a Haskell function created using a <i>wrapper</i> stub
--   declared to produce a <a>FunPtr</a> of the correct type. For example:
--   
--   <pre>
--   type Compare = Int -&gt; Int -&gt; Bool
--   foreign import ccall "wrapper"
--     mkCompare :: Compare -&gt; IO (FunPtr Compare)
--   </pre>
--   
--   Calls to wrapper stubs like <tt>mkCompare</tt> allocate storage, which
--   should be released with <a>freeHaskellFunPtr</a> when no longer
--   required.
--   
--   To convert <a>FunPtr</a> values to corresponding Haskell functions,
--   one can define a <i>dynamic</i> stub for the specific foreign type,
--   e.g.
--   
--   <pre>
--   type IntFunction = CInt -&gt; IO ()
--   foreign import ccall "dynamic"
--     mkFun :: FunPtr IntFunction -&gt; IntFunction
--   </pre>
data FunPtr a
FunPtr :: Addr# -> FunPtr a

-- | The constant <a>nullPtr</a> contains a distinguished value of
--   <a>Ptr</a> that is not associated with a valid memory location.
nullPtr :: Ptr a

-- | The <a>castPtr</a> function casts a pointer from one type to another.
castPtr :: Ptr a -> Ptr b

-- | Advances the given address by the given offset in bytes.
plusPtr :: Ptr a -> Int -> Ptr b

-- | Given an arbitrary address and an alignment constraint,
--   <a>alignPtr</a> yields the next higher address that fulfills the
--   alignment constraint. An alignment constraint <tt>x</tt> is fulfilled
--   by any address divisible by <tt>x</tt>. This operation is idempotent.
alignPtr :: Ptr a -> Int -> Ptr a

-- | Computes the offset required to get from the second to the first
--   argument. We have
--   
--   <pre>
--   p2 == p1 `plusPtr` (p2 `minusPtr` p1)
--   </pre>
minusPtr :: Ptr a -> Ptr b -> Int

-- | The constant <a>nullFunPtr</a> contains a distinguished value of
--   <a>FunPtr</a> that is not associated with a valid memory location.
nullFunPtr :: FunPtr a

-- | Casts a <a>FunPtr</a> to a <a>FunPtr</a> of a different type.
castFunPtr :: FunPtr a -> FunPtr b

-- | Casts a <a>FunPtr</a> to a <a>Ptr</a>.
--   
--   <i>Note:</i> this is valid only on architectures where data and
--   function pointers range over the same set of addresses, and should
--   only be used for bindings to external libraries whose interface
--   already relies on this assumption.
castFunPtrToPtr :: FunPtr a -> Ptr b

-- | Casts a <a>Ptr</a> to a <a>FunPtr</a>.
--   
--   <i>Note:</i> this is valid only on architectures where data and
--   function pointers range over the same set of addresses, and should
--   only be used for bindings to external libraries whose interface
--   already relies on this assumption.
castPtrToFunPtr :: Ptr a -> FunPtr b
instance GHC.Classes.Eq (GHC.Internal.Ptr.FunPtr a)
instance GHC.Classes.Eq (GHC.Internal.Ptr.Ptr a)
instance GHC.Classes.Ord (GHC.Internal.Ptr.FunPtr a)
instance GHC.Classes.Ord (GHC.Internal.Ptr.Ptr a)
instance GHC.Internal.Show.Show (GHC.Internal.Ptr.FunPtr a)
instance GHC.Internal.Show.Show (GHC.Internal.Ptr.Ptr a)


-- | Stable pointers.
module GHC.Internal.Stable

-- | A <i>stable pointer</i> is a reference to a Haskell expression that is
--   guaranteed not to be affected by garbage collection, i.e., it will
--   neither be deallocated nor will the value of the stable pointer itself
--   change during garbage collection (ordinary references may be relocated
--   during garbage collection). Consequently, stable pointers can be
--   passed to foreign code, which can treat it as an opaque reference to a
--   Haskell value.
--   
--   The <tt>StablePtr</tt> 0 is reserved for representing NULL in foreign
--   code.
--   
--   A value of type <tt>StablePtr a</tt> is a stable pointer to a Haskell
--   expression of type <tt>a</tt>.
data StablePtr a
StablePtr :: StablePtr# a -> StablePtr a

-- | Create a stable pointer referring to the given Haskell value.
newStablePtr :: a -> IO (StablePtr a)

-- | Obtain the Haskell value referenced by a stable pointer, i.e., the
--   same value that was passed to the corresponding call to
--   <a>newStablePtr</a>. If the argument to <a>deRefStablePtr</a> has
--   already been freed using <a>freeStablePtr</a>, the behaviour of
--   <a>deRefStablePtr</a> is undefined.
deRefStablePtr :: StablePtr a -> IO a

-- | Dissolve the association between the stable pointer and the Haskell
--   value. Afterwards, if the stable pointer is passed to
--   <a>deRefStablePtr</a> or <a>freeStablePtr</a>, the behaviour is
--   undefined. However, the stable pointer may still be passed to
--   <a>castStablePtrToPtr</a>, but the <tt><a>Ptr</a> ()</tt> value
--   returned by <a>castStablePtrToPtr</a>, in this case, is undefined (in
--   particular, it may be <a>nullPtr</a>). Nevertheless, the call to
--   <a>castStablePtrToPtr</a> is guaranteed not to diverge.
freeStablePtr :: StablePtr a -> IO ()

-- | Coerce a stable pointer to an address. No guarantees are made about
--   the resulting value, except that the original stable pointer can be
--   recovered by <a>castPtrToStablePtr</a>. In particular, the address
--   might not refer to an accessible memory location and any attempt to
--   pass it to the member functions of the class <a>Storable</a> leads to
--   undefined behaviour.
castStablePtrToPtr :: StablePtr a -> Ptr ()

-- | The inverse of <a>castStablePtrToPtr</a>, i.e., we have the identity
--   
--   <pre>
--   sp == castPtrToStablePtr (castStablePtrToPtr sp)
--   </pre>
--   
--   for any stable pointer <tt>sp</tt> on which <a>freeStablePtr</a> has
--   not been executed yet. Moreover, <a>castPtrToStablePtr</a> may only be
--   applied to pointers that have been produced by
--   <a>castStablePtrToPtr</a>.
castPtrToStablePtr :: Ptr () -> StablePtr a
instance GHC.Classes.Eq (GHC.Internal.Stable.StablePtr a)


-- | Helper functions for <a>Foreign.Storable</a>
module GHC.Internal.Storable
readWideCharOffPtr :: Ptr Char -> Int -> IO Char
readIntOffPtr :: Ptr Int -> Int -> IO Int
readWordOffPtr :: Ptr Word -> Int -> IO Word
readPtrOffPtr :: Ptr (Ptr a) -> Int -> IO (Ptr a)
readFunPtrOffPtr :: Ptr (FunPtr a) -> Int -> IO (FunPtr a)
readFloatOffPtr :: Ptr Float -> Int -> IO Float
readDoubleOffPtr :: Ptr Double -> Int -> IO Double
readStablePtrOffPtr :: Ptr (StablePtr a) -> Int -> IO (StablePtr a)
readInt8OffPtr :: Ptr Int8 -> Int -> IO Int8
readInt16OffPtr :: Ptr Int16 -> Int -> IO Int16
readInt32OffPtr :: Ptr Int32 -> Int -> IO Int32
readInt64OffPtr :: Ptr Int64 -> Int -> IO Int64
readWord8OffPtr :: Ptr Word8 -> Int -> IO Word8
readWord16OffPtr :: Ptr Word16 -> Int -> IO Word16
readWord32OffPtr :: Ptr Word32 -> Int -> IO Word32
readWord64OffPtr :: Ptr Word64 -> Int -> IO Word64
writeWideCharOffPtr :: Ptr Char -> Int -> Char -> IO ()
writeIntOffPtr :: Ptr Int -> Int -> Int -> IO ()
writeWordOffPtr :: Ptr Word -> Int -> Word -> IO ()
writePtrOffPtr :: Ptr (Ptr a) -> Int -> Ptr a -> IO ()
writeFunPtrOffPtr :: Ptr (FunPtr a) -> Int -> FunPtr a -> IO ()
writeFloatOffPtr :: Ptr Float -> Int -> Float -> IO ()
writeDoubleOffPtr :: Ptr Double -> Int -> Double -> IO ()
writeStablePtrOffPtr :: Ptr (StablePtr a) -> Int -> StablePtr a -> IO ()
writeInt8OffPtr :: Ptr Int8 -> Int -> Int8 -> IO ()
writeInt16OffPtr :: Ptr Int16 -> Int -> Int16 -> IO ()
writeInt32OffPtr :: Ptr Int32 -> Int -> Int32 -> IO ()
writeInt64OffPtr :: Ptr Int64 -> Int -> Int64 -> IO ()
writeWord8OffPtr :: Ptr Word8 -> Int -> Word8 -> IO ()
writeWord16OffPtr :: Ptr Word16 -> Int -> Word16 -> IO ()
writeWord32OffPtr :: Ptr Word32 -> Int -> Word32 -> IO ()
writeWord64OffPtr :: Ptr Word64 -> Int -> Word64 -> IO ()


-- | The MVar type
module GHC.Internal.MVar

-- | An <a>MVar</a> (pronounced "em-var") is a synchronising variable, used
--   for communication between concurrent threads. It can be thought of as
--   a box, which may be empty or full.
data MVar a
MVar :: MVar# RealWorld a -> MVar a

-- | Create an <a>MVar</a> which contains the supplied value.
newMVar :: a -> IO (MVar a)

-- | Create an <a>MVar</a> which is initially empty.
newEmptyMVar :: IO (MVar a)

-- | Return the contents of the <a>MVar</a>. If the <a>MVar</a> is
--   currently empty, <a>takeMVar</a> will wait until it is full. After a
--   <a>takeMVar</a>, the <a>MVar</a> is left empty.
--   
--   There are two further important properties of <a>takeMVar</a>:
--   
--   <ul>
--   <li><a>takeMVar</a> is single-wakeup. That is, if there are multiple
--   threads blocked in <a>takeMVar</a>, and the <a>MVar</a> becomes full,
--   only one thread will be woken up. The runtime guarantees that the
--   woken thread completes its <a>takeMVar</a> operation.</li>
--   <li>When multiple threads are blocked on an <a>MVar</a>, they are
--   woken up in FIFO order. This is useful for providing fairness
--   properties of abstractions built using <a>MVar</a>s.</li>
--   </ul>
takeMVar :: MVar a -> IO a

-- | Atomically read the contents of an <a>MVar</a>. If the <a>MVar</a> is
--   currently empty, <a>readMVar</a> will wait until it is full.
--   <a>readMVar</a> is guaranteed to receive the next <a>putMVar</a>.
--   
--   <a>readMVar</a> is multiple-wakeup, so when multiple readers are
--   blocked on an <a>MVar</a>, all of them are woken up at the same time.
--   The runtime guarantees that all woken threads complete their
--   <a>readMVar</a> operation.
--   
--   <i>Compatibility note:</i> Prior to base 4.7, <a>readMVar</a> was a
--   combination of <a>takeMVar</a> and <a>putMVar</a>. This mean that in
--   the presence of other threads attempting to <a>putMVar</a>,
--   <a>readMVar</a> could block. Furthermore, <a>readMVar</a> would not
--   receive the next <a>putMVar</a> if there was already a pending thread
--   blocked on <a>takeMVar</a>. The old behavior can be recovered by
--   implementing 'readMVar as follows:
--   
--   <pre>
--   readMVar :: MVar a -&gt; IO a
--   readMVar m =
--     mask_ $ do
--       a &lt;- takeMVar m
--       putMVar m a
--       return a
--   </pre>
readMVar :: MVar a -> IO a

-- | Put a value into an <a>MVar</a>. If the <a>MVar</a> is currently full,
--   <a>putMVar</a> will wait until it becomes empty.
--   
--   There are two further important properties of <a>putMVar</a>:
--   
--   <ul>
--   <li><a>putMVar</a> is single-wakeup. That is, if there are multiple
--   threads blocked in <a>putMVar</a>, and the <a>MVar</a> becomes empty,
--   only one thread will be woken up. The runtime guarantees that the
--   woken thread completes its <a>putMVar</a> operation.</li>
--   <li>When multiple threads are blocked on an <a>MVar</a>, they are
--   woken up in FIFO order. This is useful for providing fairness
--   properties of abstractions built using <a>MVar</a>s.</li>
--   </ul>
putMVar :: MVar a -> a -> IO ()

-- | A non-blocking version of <a>takeMVar</a>. The <a>tryTakeMVar</a>
--   function returns immediately, with <a>Nothing</a> if the <a>MVar</a>
--   was empty, or <tt><a>Just</a> a</tt> if the <a>MVar</a> was full with
--   contents <tt>a</tt>. After <a>tryTakeMVar</a>, the <a>MVar</a> is left
--   empty.
tryTakeMVar :: MVar a -> IO (Maybe a)

-- | A non-blocking version of <a>putMVar</a>. The <a>tryPutMVar</a>
--   function attempts to put the value <tt>a</tt> into the <a>MVar</a>,
--   returning <a>True</a> if it was successful, or <a>False</a> otherwise.
tryPutMVar :: MVar a -> a -> IO Bool

-- | A non-blocking version of <a>readMVar</a>. The <a>tryReadMVar</a>
--   function returns immediately, with <a>Nothing</a> if the <a>MVar</a>
--   was empty, or <tt><a>Just</a> a</tt> if the <a>MVar</a> was full with
--   contents <tt>a</tt>.
tryReadMVar :: MVar a -> IO (Maybe a)

-- | Check whether a given <a>MVar</a> is empty.
--   
--   Notice that the boolean value returned is just a snapshot of the state
--   of the MVar. By the time you get to react on its result, the MVar may
--   have been filled (or emptied) - so be extremely careful when using
--   this operation. Use <a>tryTakeMVar</a> instead if possible.
isEmptyMVar :: MVar a -> IO Bool

-- | Add a finalizer to an <a>MVar</a> (GHC only). See
--   <a>Foreign.ForeignPtr</a> and <a>System.Mem.Weak</a> for more about
--   finalizers.
addMVarFinalizer :: MVar a -> IO () -> IO ()
data PrimMVar

-- | Make a <a>StablePtr</a> that can be passed to the C function
--   <tt>hs_try_putmvar()</tt>. The RTS wants a <a>StablePtr</a> to the
--   underlying <a>MVar#</a>, but a <a>StablePtr#</a> can only refer to
--   lifted types, so we have to cheat by coercing.
newStablePtrPrimMVar :: MVar a -> IO (StablePtr PrimMVar)
instance GHC.Classes.Eq (GHC.Internal.MVar.MVar a)


-- | This module is part of the Foreign Function Interface (FFI) and will
--   usually be imported via the module <a>Foreign</a>.
module GHC.Internal.Foreign.StablePtr

-- | A <i>stable pointer</i> is a reference to a Haskell expression that is
--   guaranteed not to be affected by garbage collection, i.e., it will
--   neither be deallocated nor will the value of the stable pointer itself
--   change during garbage collection (ordinary references may be relocated
--   during garbage collection). Consequently, stable pointers can be
--   passed to foreign code, which can treat it as an opaque reference to a
--   Haskell value.
--   
--   The <tt>StablePtr</tt> 0 is reserved for representing NULL in foreign
--   code.
--   
--   A value of type <tt>StablePtr a</tt> is a stable pointer to a Haskell
--   expression of type <tt>a</tt>.
data StablePtr a

-- | Create a stable pointer referring to the given Haskell value.
newStablePtr :: a -> IO (StablePtr a)

-- | Obtain the Haskell value referenced by a stable pointer, i.e., the
--   same value that was passed to the corresponding call to
--   <a>newStablePtr</a>. If the argument to <a>deRefStablePtr</a> has
--   already been freed using <a>freeStablePtr</a>, the behaviour of
--   <a>deRefStablePtr</a> is undefined.
deRefStablePtr :: StablePtr a -> IO a

-- | Dissolve the association between the stable pointer and the Haskell
--   value. Afterwards, if the stable pointer is passed to
--   <a>deRefStablePtr</a> or <a>freeStablePtr</a>, the behaviour is
--   undefined. However, the stable pointer may still be passed to
--   <a>castStablePtrToPtr</a>, but the <tt><a>Ptr</a> ()</tt> value
--   returned by <a>castStablePtrToPtr</a>, in this case, is undefined (in
--   particular, it may be <a>nullPtr</a>). Nevertheless, the call to
--   <a>castStablePtrToPtr</a> is guaranteed not to diverge.
freeStablePtr :: StablePtr a -> IO ()

-- | Coerce a stable pointer to an address. No guarantees are made about
--   the resulting value, except that the original stable pointer can be
--   recovered by <a>castPtrToStablePtr</a>. In particular, the address
--   might not refer to an accessible memory location and any attempt to
--   pass it to the member functions of the class <a>Storable</a> leads to
--   undefined behaviour.
castStablePtrToPtr :: StablePtr a -> Ptr ()

-- | The inverse of <a>castStablePtrToPtr</a>, i.e., we have the identity
--   
--   <pre>
--   sp == castPtrToStablePtr (castStablePtrToPtr sp)
--   </pre>
--   
--   for any stable pointer <tt>sp</tt> on which <a>freeStablePtr</a> has
--   not been executed yet. Moreover, <a>castPtrToStablePtr</a> may only be
--   applied to pointers that have been produced by
--   <a>castStablePtrToPtr</a>.
castPtrToStablePtr :: Ptr () -> StablePtr a


-- | ⚠ Warning: Starting <tt>base-4.18</tt>, this module is being
--   deprecated. See
--   <a>https://gitlab.haskell.org/ghc/ghc/-/issues/21461</a> for more
--   information.
--   
--   This module provides a small set of low-level functions for packing
--   and unpacking a chunk of bytes. Used by code emitted by the compiler
--   plus the prelude libraries.
--   
--   The programmer level view of packed strings is provided by a GHC
--   system library PackedString.
module GHC.Internal.Pack
packCString# :: [Char] -> ByteArray#
unpackCString :: Ptr a -> [Char]
unpackCString# :: Addr# -> [Char]
unpackNBytes# :: Addr# -> Int# -> [Char]
unpackFoldrCString# :: Addr# -> (Char -> a -> a) -> a -> a
unpackAppendCString# :: Addr# -> [Char] -> [Char]


-- | This module provides typed <tt>const</tt> pointers to foreign data. It
--   is part of the Foreign Function Interface (FFI).
module GHC.Internal.Foreign.C.ConstPtr

-- | A pointer with the C <tt>const</tt> qualifier. For instance, an
--   argument of type <tt>ConstPtr CInt</tt> would be marshalled as
--   <tt>const int*</tt>.
--   
--   While <tt>const</tt>-ness generally does not matter for <tt>ccall</tt>
--   imports (since <tt>const</tt> and non-<tt>const</tt> pointers
--   typically have equivalent calling conventions), it does matter for
--   <tt>capi</tt> imports. See GHC #22043.
newtype ConstPtr a
ConstPtr :: Ptr a -> ConstPtr a
[unConstPtr] :: ConstPtr a -> Ptr a
instance GHC.Classes.Eq (GHC.Internal.Foreign.C.ConstPtr.ConstPtr a)
instance GHC.Classes.Ord (GHC.Internal.Foreign.C.ConstPtr.ConstPtr a)
instance GHC.Internal.Show.Show (GHC.Internal.Foreign.C.ConstPtr.ConstPtr a)


-- | Fingerprints for recompilation checking and ABI versioning, and
--   implementing fast comparison of Typeable.
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.Fingerprint.Type
data Fingerprint
Fingerprint :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> Fingerprint
instance GHC.Classes.Eq GHC.Internal.Fingerprint.Type.Fingerprint
instance GHC.Classes.Ord GHC.Internal.Fingerprint.Type.Fingerprint
instance GHC.Internal.Show.Show GHC.Internal.Fingerprint.Type.Fingerprint


-- | The module <a>Foreign.Storable</a> provides most elementary support
--   for marshalling and is part of the language-independent portion of the
--   Foreign Function Interface (FFI), and will normally be imported via
--   the <a>Foreign</a> module.
module GHC.Internal.Foreign.Storable

-- | The member functions of this class facilitate writing values of
--   primitive types to raw memory (which may have been allocated with the
--   above mentioned routines) and reading values from blocks of raw
--   memory. The class, furthermore, includes support for computing the
--   storage requirements and alignment restrictions of storable types.
--   
--   Memory addresses are represented as values of type <tt><a>Ptr</a>
--   a</tt>, for some <tt>a</tt> which is an instance of class
--   <a>Storable</a>. The type argument to <a>Ptr</a> helps provide some
--   valuable type safety in FFI code (you can't mix pointers of different
--   types without an explicit cast), while helping the Haskell type system
--   figure out which marshalling method is needed for a given pointer.
--   
--   All marshalling between Haskell and a foreign language ultimately
--   boils down to translating Haskell data structures into the binary
--   representation of a corresponding data structure of the foreign
--   language and vice versa. To code this marshalling in Haskell, it is
--   necessary to manipulate primitive data types stored in unstructured
--   memory blocks. The class <a>Storable</a> facilitates this manipulation
--   on all types for which it is instantiated, which are the standard
--   basic types of Haskell, the fixed size <tt>Int</tt> types
--   (<a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>), the fixed
--   size <tt>Word</tt> types (<a>Word8</a>, <a>Word16</a>, <a>Word32</a>,
--   <a>Word64</a>), <a>StablePtr</a>, all types from
--   <a>Foreign.C.Types</a>, as well as <a>Ptr</a>.
class Storable a

-- | Computes the storage requirements (in bytes) of the argument. The
--   value of the argument is not used.
sizeOf :: Storable a => a -> Int

-- | Computes the alignment constraint of the argument. An alignment
--   constraint <tt>x</tt> is fulfilled by any address divisible by
--   <tt>x</tt>. The alignment must be a power of two if this instance is
--   to be used with <tt>alloca</tt> or <tt>allocaArray</tt>. The value of
--   the argument is not used.
alignment :: Storable a => a -> Int

-- | Read a value from a memory area regarded as an array of values of the
--   same kind. The first argument specifies the start address of the array
--   and the second the index into the array (the first element of the
--   array has index <tt>0</tt>). The following equality holds,
--   
--   <pre>
--   peekElemOff addr idx = IOExts.fixIO $ \result -&gt;
--     peek (addr `plusPtr` (idx * sizeOf result))
--   </pre>
--   
--   Note that this is only a specification, not necessarily the concrete
--   implementation of the function.
peekElemOff :: Storable a => Ptr a -> Int -> IO a

-- | Write a value to a memory area regarded as an array of values of the
--   same kind. The following equality holds:
--   
--   <pre>
--   pokeElemOff addr idx x =
--     poke (addr `plusPtr` (idx * sizeOf x)) x
--   </pre>
pokeElemOff :: Storable a => Ptr a -> Int -> a -> IO ()

-- | Read a value from a memory location given by a base address and
--   offset. The following equality holds:
--   
--   <pre>
--   peekByteOff addr off = peek (addr `plusPtr` off)
--   </pre>
peekByteOff :: Storable a => Ptr b -> Int -> IO a

-- | Write a value to a memory location given by a base address and offset.
--   The following equality holds:
--   
--   <pre>
--   pokeByteOff addr off x = poke (addr `plusPtr` off) x
--   </pre>
pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()

-- | Read a value from the given memory location.
--   
--   Note that the peek and poke functions might require properly aligned
--   addresses to function correctly. This is architecture dependent; thus,
--   portable code should ensure that when peeking or poking values of some
--   type <tt>a</tt>, the alignment constraint for <tt>a</tt>, as given by
--   the function <a>alignment</a> is fulfilled.
peek :: Storable a => Ptr a -> IO a

-- | Write the given value to the given memory location. Alignment
--   restrictions might apply; see <a>peek</a>.
poke :: Storable a => Ptr a -> a -> IO ()
instance GHC.Internal.Foreign.Storable.Storable GHC.Types.Bool
instance GHC.Internal.Foreign.Storable.Storable GHC.Types.Char
instance GHC.Internal.Foreign.Storable.Storable (GHC.Internal.Foreign.C.ConstPtr.ConstPtr a)
instance GHC.Internal.Foreign.Storable.Storable GHC.Types.Double
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Fingerprint.Type.Fingerprint
instance GHC.Internal.Foreign.Storable.Storable GHC.Types.Float
instance GHC.Internal.Foreign.Storable.Storable (GHC.Internal.Ptr.FunPtr a)
instance GHC.Internal.Foreign.Storable.Storable GHC.Types.Int
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Int.Int16
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Int.Int32
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Int.Int64
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Int.Int8
instance GHC.Internal.Foreign.Storable.Storable (GHC.Internal.Ptr.Ptr a)
instance (GHC.Internal.Foreign.Storable.Storable a, GHC.Internal.Real.Integral a) => GHC.Internal.Foreign.Storable.Storable (GHC.Internal.Real.Ratio a)
instance GHC.Internal.Foreign.Storable.Storable (GHC.Internal.Stable.StablePtr a)
instance GHC.Internal.Foreign.Storable.Storable ()
instance GHC.Internal.Foreign.Storable.Storable GHC.Types.Word
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Word.Word16
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Word.Word32
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Word.Word64
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Word.Word8


-- | This module provides typed pointers to foreign data. It is part of the
--   Foreign Function Interface (FFI) and will normally be imported via the
--   <a>Foreign</a> module.
module GHC.Internal.Foreign.Ptr

-- | A value of type <tt><a>Ptr</a> a</tt> represents a pointer to an
--   object, or an array of objects, which may be marshalled to or from
--   Haskell values of type <tt>a</tt>.
--   
--   The type <tt>a</tt> will often be an instance of class <a>Storable</a>
--   which provides the marshalling operations. However this is not
--   essential, and you can provide your own operations to access the
--   pointer. For example you might write small foreign functions to get or
--   set the fields of a C <tt>struct</tt>.
data Ptr a

-- | The constant <a>nullPtr</a> contains a distinguished value of
--   <a>Ptr</a> that is not associated with a valid memory location.
nullPtr :: Ptr a

-- | The <a>castPtr</a> function casts a pointer from one type to another.
castPtr :: Ptr a -> Ptr b

-- | Advances the given address by the given offset in bytes.
plusPtr :: Ptr a -> Int -> Ptr b

-- | Given an arbitrary address and an alignment constraint,
--   <a>alignPtr</a> yields the next higher address that fulfills the
--   alignment constraint. An alignment constraint <tt>x</tt> is fulfilled
--   by any address divisible by <tt>x</tt>. This operation is idempotent.
alignPtr :: Ptr a -> Int -> Ptr a

-- | Computes the offset required to get from the second to the first
--   argument. We have
--   
--   <pre>
--   p2 == p1 `plusPtr` (p2 `minusPtr` p1)
--   </pre>
minusPtr :: Ptr a -> Ptr b -> Int

-- | A value of type <tt><a>FunPtr</a> a</tt> is a pointer to a function
--   callable from foreign code. The type <tt>a</tt> will normally be a
--   <i>foreign type</i>, a function type with zero or more arguments where
--   
--   <ul>
--   <li>the argument types are <i>marshallable foreign types</i>, i.e.
--   <a>Char</a>, <a>Int</a>, <a>Double</a>, <a>Float</a>, <a>Bool</a>,
--   <a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>, <a>Word8</a>,
--   <a>Word16</a>, <a>Word32</a>, <a>Word64</a>, <tt><a>Ptr</a> a</tt>,
--   <tt><a>FunPtr</a> a</tt>, <tt><a>StablePtr</a> a</tt> or a renaming of
--   any of these using <tt>newtype</tt>.</li>
--   <li>the return type is either a marshallable foreign type or has the
--   form <tt><a>IO</a> t</tt> where <tt>t</tt> is a marshallable foreign
--   type or <tt>()</tt>.</li>
--   </ul>
--   
--   A value of type <tt><a>FunPtr</a> a</tt> may be a pointer to a foreign
--   function, either returned by another foreign function or imported with
--   a a static address import like
--   
--   <pre>
--   foreign import ccall "stdlib.h &amp;free"
--     p_free :: FunPtr (Ptr a -&gt; IO ())
--   </pre>
--   
--   or a pointer to a Haskell function created using a <i>wrapper</i> stub
--   declared to produce a <a>FunPtr</a> of the correct type. For example:
--   
--   <pre>
--   type Compare = Int -&gt; Int -&gt; Bool
--   foreign import ccall "wrapper"
--     mkCompare :: Compare -&gt; IO (FunPtr Compare)
--   </pre>
--   
--   Calls to wrapper stubs like <tt>mkCompare</tt> allocate storage, which
--   should be released with <a>freeHaskellFunPtr</a> when no longer
--   required.
--   
--   To convert <a>FunPtr</a> values to corresponding Haskell functions,
--   one can define a <i>dynamic</i> stub for the specific foreign type,
--   e.g.
--   
--   <pre>
--   type IntFunction = CInt -&gt; IO ()
--   foreign import ccall "dynamic"
--     mkFun :: FunPtr IntFunction -&gt; IntFunction
--   </pre>
data FunPtr a

-- | The constant <a>nullFunPtr</a> contains a distinguished value of
--   <a>FunPtr</a> that is not associated with a valid memory location.
nullFunPtr :: FunPtr a

-- | Casts a <a>FunPtr</a> to a <a>FunPtr</a> of a different type.
castFunPtr :: FunPtr a -> FunPtr b

-- | Casts a <a>FunPtr</a> to a <a>Ptr</a>.
--   
--   <i>Note:</i> this is valid only on architectures where data and
--   function pointers range over the same set of addresses, and should
--   only be used for bindings to external libraries whose interface
--   already relies on this assumption.
castFunPtrToPtr :: FunPtr a -> Ptr b

-- | Casts a <a>Ptr</a> to a <a>FunPtr</a>.
--   
--   <i>Note:</i> this is valid only on architectures where data and
--   function pointers range over the same set of addresses, and should
--   only be used for bindings to external libraries whose interface
--   already relies on this assumption.
castPtrToFunPtr :: Ptr a -> FunPtr b

-- | Release the storage associated with the given <a>FunPtr</a>, which
--   must have been obtained from a wrapper stub. This should be called
--   whenever the return value from a foreign import wrapper function is no
--   longer required; otherwise, the storage it uses will leak.
freeHaskellFunPtr :: FunPtr a -> IO ()

-- | A signed integral type that can be losslessly converted to and from
--   <tt>Ptr</tt>. This type is also compatible with the C99 type
--   <tt>intptr_t</tt>, and can be marshalled to and from that type safely.
newtype IntPtr
IntPtr :: Int -> IntPtr

-- | casts a <tt>Ptr</tt> to an <tt>IntPtr</tt>
ptrToIntPtr :: Ptr a -> IntPtr

-- | casts an <tt>IntPtr</tt> to a <tt>Ptr</tt>
intPtrToPtr :: IntPtr -> Ptr a

-- | An unsigned integral type that can be losslessly converted to and from
--   <tt>Ptr</tt>. This type is also compatible with the C99 type
--   <tt>uintptr_t</tt>, and can be marshalled to and from that type
--   safely.
newtype WordPtr
WordPtr :: Word -> WordPtr

-- | casts a <tt>Ptr</tt> to a <tt>WordPtr</tt>
ptrToWordPtr :: Ptr a -> WordPtr

-- | casts a <tt>WordPtr</tt> to a <tt>Ptr</tt>
wordPtrToPtr :: WordPtr -> Ptr a
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.Ptr.IntPtr
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.Ptr.WordPtr
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.Ptr.IntPtr
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.Ptr.WordPtr
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.Ptr.IntPtr
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.Ptr.WordPtr
instance GHC.Classes.Eq GHC.Internal.Foreign.Ptr.IntPtr
instance GHC.Classes.Eq GHC.Internal.Foreign.Ptr.WordPtr
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.Ptr.IntPtr
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.Ptr.WordPtr
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.Ptr.IntPtr
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.Ptr.WordPtr
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.Ptr.IntPtr
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.Ptr.WordPtr
instance GHC.Internal.Num.Num GHC.Internal.Foreign.Ptr.IntPtr
instance GHC.Internal.Num.Num GHC.Internal.Foreign.Ptr.WordPtr
instance GHC.Classes.Ord GHC.Internal.Foreign.Ptr.IntPtr
instance GHC.Classes.Ord GHC.Internal.Foreign.Ptr.WordPtr
instance GHC.Internal.Read.Read GHC.Internal.Foreign.Ptr.IntPtr
instance GHC.Internal.Read.Read GHC.Internal.Foreign.Ptr.WordPtr
instance GHC.Internal.Real.Real GHC.Internal.Foreign.Ptr.IntPtr
instance GHC.Internal.Real.Real GHC.Internal.Foreign.Ptr.WordPtr
instance GHC.Internal.Show.Show GHC.Internal.Foreign.Ptr.IntPtr
instance GHC.Internal.Show.Show GHC.Internal.Foreign.Ptr.WordPtr
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.Ptr.IntPtr
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.Ptr.WordPtr


-- | Mapping of C types to corresponding Haskell types.
module GHC.Internal.Foreign.C.Types

-- | Haskell type representing the C <tt>char</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype CChar
CChar :: Int8 -> CChar

-- | Haskell type representing the C <tt>signed char</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype CSChar
CSChar :: Int8 -> CSChar

-- | Haskell type representing the C <tt>unsigned char</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype CUChar
CUChar :: Word8 -> CUChar

-- | Haskell type representing the C <tt>short</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype CShort
CShort :: Int16 -> CShort

-- | Haskell type representing the C <tt>unsigned short</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype CUShort
CUShort :: Word16 -> CUShort

-- | Haskell type representing the C <tt>int</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype CInt
CInt :: Int32 -> CInt

-- | Haskell type representing the C <tt>unsigned int</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype CUInt
CUInt :: Word32 -> CUInt

-- | Haskell type representing the C <tt>long</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype CLong
CLong :: Int64 -> CLong

-- | Haskell type representing the C <tt>unsigned long</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype CULong
CULong :: Word64 -> CULong

-- | Haskell type representing the C <tt>ptrdiff_t</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype CPtrdiff
CPtrdiff :: Int64 -> CPtrdiff

-- | Haskell type representing the C <tt>size_t</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype CSize
CSize :: Word64 -> CSize

-- | Haskell type representing the C <tt>wchar_t</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype CWchar
CWchar :: Int32 -> CWchar

-- | Haskell type representing the C <tt>sig_atomic_t</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i> See Note [Lack of signals on wasm32-wasi].
newtype CSigAtomic
CSigAtomic :: Int32 -> CSigAtomic

-- | Haskell type representing the C <tt>long long</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype CLLong
CLLong :: Int64 -> CLLong

-- | Haskell type representing the C <tt>unsigned long long</tt> type.
--   <i>(The concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype CULLong
CULLong :: Word64 -> CULLong

-- | Haskell type representing the C <tt>bool</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype CBool
CBool :: Word8 -> CBool
newtype CIntPtr
CIntPtr :: Int64 -> CIntPtr
newtype CUIntPtr
CUIntPtr :: Word64 -> CUIntPtr
newtype CIntMax
CIntMax :: Int64 -> CIntMax
newtype CUIntMax
CUIntMax :: Word64 -> CUIntMax

-- | Haskell type representing the C <tt>clock_t</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype CClock
CClock :: Int64 -> CClock

-- | Haskell type representing the C <tt>time_t</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype CTime
CTime :: Int64 -> CTime

-- | Haskell type representing the C <tt>useconds_t</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype CUSeconds
CUSeconds :: Word32 -> CUSeconds

-- | Haskell type representing the C <tt>suseconds_t</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype CSUSeconds
CSUSeconds :: Int64 -> CSUSeconds

-- | Haskell type representing the C <tt>float</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype CFloat
CFloat :: Float -> CFloat

-- | Haskell type representing the C <tt>double</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype CDouble
CDouble :: Double -> CDouble

-- | Haskell type representing the C <tt>FILE</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
data CFile

-- | Haskell type representing the C <tt>fpos_t</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
data CFpos

-- | Haskell type representing the C <tt>jmp_buf</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
data CJmpBuf
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.C.Types.CBool
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.C.Types.CChar
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.C.Types.CInt
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.C.Types.CIntMax
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.C.Types.CIntPtr
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.C.Types.CLLong
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.C.Types.CLong
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.C.Types.CPtrdiff
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.C.Types.CSChar
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.C.Types.CShort
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.C.Types.CSigAtomic
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.C.Types.CSize
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.C.Types.CUChar
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.C.Types.CUInt
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.C.Types.CUIntMax
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.C.Types.CUIntPtr
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.C.Types.CULLong
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.C.Types.CULong
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.C.Types.CUShort
instance GHC.Internal.Bits.Bits GHC.Internal.Foreign.C.Types.CWchar
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.C.Types.CBool
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.C.Types.CChar
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.C.Types.CInt
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.C.Types.CIntMax
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.C.Types.CIntPtr
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.C.Types.CLLong
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.C.Types.CLong
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.C.Types.CPtrdiff
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.C.Types.CSChar
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.C.Types.CShort
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.C.Types.CSigAtomic
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.C.Types.CSize
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.C.Types.CUChar
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.C.Types.CUInt
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.C.Types.CUIntMax
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.C.Types.CUIntPtr
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.C.Types.CULLong
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.C.Types.CULong
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.C.Types.CUShort
instance GHC.Internal.Enum.Bounded GHC.Internal.Foreign.C.Types.CWchar
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CBool
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CChar
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CClock
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CDouble
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CFloat
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CInt
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CIntMax
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CIntPtr
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CLLong
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CLong
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CPtrdiff
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CSChar
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CSUSeconds
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CShort
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CSigAtomic
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CSize
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CTime
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CUChar
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CUInt
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CUIntMax
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CUIntPtr
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CULLong
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CULong
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CUSeconds
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CUShort
instance GHC.Internal.Enum.Enum GHC.Internal.Foreign.C.Types.CWchar
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CBool
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CChar
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CClock
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CDouble
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CFloat
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CInt
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CIntMax
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CIntPtr
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CLLong
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CLong
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CPtrdiff
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CSChar
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CSUSeconds
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CShort
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CSigAtomic
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CSize
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CTime
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CUChar
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CUInt
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CUIntMax
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CUIntPtr
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CULLong
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CULong
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CUSeconds
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CUShort
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Types.CWchar
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.C.Types.CBool
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.C.Types.CChar
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.C.Types.CInt
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.C.Types.CIntMax
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.C.Types.CIntPtr
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.C.Types.CLLong
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.C.Types.CLong
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.C.Types.CPtrdiff
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.C.Types.CSChar
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.C.Types.CShort
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.C.Types.CSigAtomic
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.C.Types.CSize
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.C.Types.CUChar
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.C.Types.CUInt
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.C.Types.CUIntMax
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.C.Types.CUIntPtr
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.C.Types.CULLong
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.C.Types.CULong
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.C.Types.CUShort
instance GHC.Internal.Bits.FiniteBits GHC.Internal.Foreign.C.Types.CWchar
instance GHC.Internal.Float.Floating GHC.Internal.Foreign.C.Types.CDouble
instance GHC.Internal.Float.Floating GHC.Internal.Foreign.C.Types.CFloat
instance GHC.Internal.Real.Fractional GHC.Internal.Foreign.C.Types.CDouble
instance GHC.Internal.Real.Fractional GHC.Internal.Foreign.C.Types.CFloat
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.C.Types.CBool
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.C.Types.CChar
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.C.Types.CInt
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.C.Types.CIntMax
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.C.Types.CIntPtr
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.C.Types.CLLong
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.C.Types.CLong
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.C.Types.CPtrdiff
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.C.Types.CSChar
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.C.Types.CShort
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.C.Types.CSigAtomic
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.C.Types.CSize
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.C.Types.CUChar
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.C.Types.CUInt
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.C.Types.CUIntMax
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.C.Types.CUIntPtr
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.C.Types.CULLong
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.C.Types.CULong
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.C.Types.CUShort
instance GHC.Internal.Real.Integral GHC.Internal.Foreign.C.Types.CWchar
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.C.Types.CBool
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.C.Types.CChar
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.C.Types.CInt
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.C.Types.CIntMax
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.C.Types.CIntPtr
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.C.Types.CLLong
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.C.Types.CLong
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.C.Types.CPtrdiff
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.C.Types.CSChar
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.C.Types.CShort
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.C.Types.CSigAtomic
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.C.Types.CSize
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.C.Types.CUChar
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.C.Types.CUInt
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.C.Types.CUIntMax
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.C.Types.CUIntPtr
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.C.Types.CULLong
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.C.Types.CULong
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.C.Types.CUShort
instance GHC.Internal.Ix.Ix GHC.Internal.Foreign.C.Types.CWchar
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CBool
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CChar
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CClock
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CDouble
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CFloat
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CInt
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CIntMax
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CIntPtr
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CLLong
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CLong
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CPtrdiff
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CSChar
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CSUSeconds
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CShort
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CSigAtomic
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CSize
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CTime
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CUChar
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CUInt
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CUIntMax
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CUIntPtr
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CULLong
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CULong
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CUSeconds
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CUShort
instance GHC.Internal.Num.Num GHC.Internal.Foreign.C.Types.CWchar
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CBool
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CChar
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CClock
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CDouble
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CFloat
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CInt
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CIntMax
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CIntPtr
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CLLong
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CLong
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CPtrdiff
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CSChar
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CSUSeconds
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CShort
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CSigAtomic
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CSize
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CTime
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CUChar
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CUInt
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CUIntMax
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CUIntPtr
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CULLong
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CULong
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CUSeconds
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CUShort
instance GHC.Classes.Ord GHC.Internal.Foreign.C.Types.CWchar
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CBool
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CChar
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CClock
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CDouble
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CFloat
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CInt
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CIntMax
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CIntPtr
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CLLong
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CLong
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CPtrdiff
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CSChar
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CSUSeconds
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CShort
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CSigAtomic
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CSize
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CTime
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CUChar
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CUInt
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CUIntMax
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CUIntPtr
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CULLong
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CULong
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CUSeconds
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CUShort
instance GHC.Internal.Read.Read GHC.Internal.Foreign.C.Types.CWchar
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CBool
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CChar
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CClock
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CDouble
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CFloat
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CInt
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CIntMax
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CIntPtr
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CLLong
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CLong
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CPtrdiff
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CSChar
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CSUSeconds
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CShort
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CSigAtomic
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CSize
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CTime
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CUChar
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CUInt
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CUIntMax
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CUIntPtr
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CULLong
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CULong
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CUSeconds
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CUShort
instance GHC.Internal.Real.Real GHC.Internal.Foreign.C.Types.CWchar
instance GHC.Internal.Float.RealFloat GHC.Internal.Foreign.C.Types.CDouble
instance GHC.Internal.Float.RealFloat GHC.Internal.Foreign.C.Types.CFloat
instance GHC.Internal.Real.RealFrac GHC.Internal.Foreign.C.Types.CDouble
instance GHC.Internal.Real.RealFrac GHC.Internal.Foreign.C.Types.CFloat
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CBool
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CChar
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CClock
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CDouble
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CFloat
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CInt
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CIntMax
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CIntPtr
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CLLong
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CLong
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CPtrdiff
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CSChar
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CSUSeconds
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CShort
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CSigAtomic
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CSize
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CTime
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CUChar
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CUInt
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CUIntMax
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CUIntPtr
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CULLong
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CULong
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CUSeconds
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CUShort
instance GHC.Internal.Show.Show GHC.Internal.Foreign.C.Types.CWchar
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CBool
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CChar
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CClock
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CDouble
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CFloat
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CInt
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CIntMax
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CIntPtr
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CLLong
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CLong
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CPtrdiff
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CSChar
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CSUSeconds
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CShort
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CSigAtomic
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CSize
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CTime
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CUChar
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CUInt
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CUIntMax
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CUIntPtr
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CULLong
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CULong
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CUSeconds
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CUShort
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.Foreign.C.Types.CWchar


-- | POSIX data types: Haskell equivalents of the types defined by the
--   <tt>&lt;sys/types.h&gt;</tt> C header on a POSIX system.
module GHC.Internal.System.Posix.Types
newtype CDev
CDev :: Word64 -> CDev
newtype CIno
CIno :: Word64 -> CIno
newtype CMode
CMode :: Word32 -> CMode
newtype COff
COff :: Int64 -> COff
newtype CPid
CPid :: Int32 -> CPid
newtype CSsize
CSsize :: Int64 -> CSsize
newtype CGid
CGid :: Word32 -> CGid
newtype CNlink
CNlink :: Word64 -> CNlink
newtype CUid
CUid :: Word32 -> CUid
newtype CCc
CCc :: Word8 -> CCc
newtype CSpeed
CSpeed :: Word32 -> CSpeed
newtype CTcflag
CTcflag :: Word32 -> CTcflag
newtype CRLim
CRLim :: Word64 -> CRLim

newtype CBlkSize
CBlkSize :: Int64 -> CBlkSize

newtype CBlkCnt
CBlkCnt :: Int64 -> CBlkCnt

newtype CClockId
CClockId :: Int32 -> CClockId

newtype CFsBlkCnt
CFsBlkCnt :: Word64 -> CFsBlkCnt

newtype CFsFilCnt
CFsFilCnt :: Word64 -> CFsFilCnt

newtype CId
CId :: Word32 -> CId

newtype CKey
CKey :: Int32 -> CKey

newtype CTimer
CTimer :: CUIntPtr -> CTimer

newtype CSocklen
CSocklen :: Word32 -> CSocklen

newtype CNfds
CNfds :: Word64 -> CNfds
newtype Fd
Fd :: CInt -> Fd
type LinkCount = CNlink
type UserID = CUid
type GroupID = CGid
type ByteCount = CSize
type ClockTick = CClock
type EpochTime = CTime
type FileOffset = COff
type ProcessID = CPid
type ProcessGroupID = CPid
type DeviceID = CDev
type FileID = CIno
type FileMode = CMode
type Limit = CLong
instance GHC.Internal.Bits.Bits GHC.Internal.System.Posix.Types.CBlkCnt
instance GHC.Internal.Bits.Bits GHC.Internal.System.Posix.Types.CBlkSize
instance GHC.Internal.Bits.Bits GHC.Internal.System.Posix.Types.CClockId
instance GHC.Internal.Bits.Bits GHC.Internal.System.Posix.Types.CDev
instance GHC.Internal.Bits.Bits GHC.Internal.System.Posix.Types.CFsBlkCnt
instance GHC.Internal.Bits.Bits GHC.Internal.System.Posix.Types.CFsFilCnt
instance GHC.Internal.Bits.Bits GHC.Internal.System.Posix.Types.CGid
instance GHC.Internal.Bits.Bits GHC.Internal.System.Posix.Types.CId
instance GHC.Internal.Bits.Bits GHC.Internal.System.Posix.Types.CIno
instance GHC.Internal.Bits.Bits GHC.Internal.System.Posix.Types.CKey
instance GHC.Internal.Bits.Bits GHC.Internal.System.Posix.Types.CMode
instance GHC.Internal.Bits.Bits GHC.Internal.System.Posix.Types.CNfds
instance GHC.Internal.Bits.Bits GHC.Internal.System.Posix.Types.CNlink
instance GHC.Internal.Bits.Bits GHC.Internal.System.Posix.Types.COff
instance GHC.Internal.Bits.Bits GHC.Internal.System.Posix.Types.CPid
instance GHC.Internal.Bits.Bits GHC.Internal.System.Posix.Types.CRLim
instance GHC.Internal.Bits.Bits GHC.Internal.System.Posix.Types.CSocklen
instance GHC.Internal.Bits.Bits GHC.Internal.System.Posix.Types.CSsize
instance GHC.Internal.Bits.Bits GHC.Internal.System.Posix.Types.CTcflag
instance GHC.Internal.Bits.Bits GHC.Internal.System.Posix.Types.CUid
instance GHC.Internal.Bits.Bits GHC.Internal.System.Posix.Types.Fd
instance GHC.Internal.Enum.Bounded GHC.Internal.System.Posix.Types.CBlkCnt
instance GHC.Internal.Enum.Bounded GHC.Internal.System.Posix.Types.CBlkSize
instance GHC.Internal.Enum.Bounded GHC.Internal.System.Posix.Types.CClockId
instance GHC.Internal.Enum.Bounded GHC.Internal.System.Posix.Types.CDev
instance GHC.Internal.Enum.Bounded GHC.Internal.System.Posix.Types.CFsBlkCnt
instance GHC.Internal.Enum.Bounded GHC.Internal.System.Posix.Types.CFsFilCnt
instance GHC.Internal.Enum.Bounded GHC.Internal.System.Posix.Types.CGid
instance GHC.Internal.Enum.Bounded GHC.Internal.System.Posix.Types.CId
instance GHC.Internal.Enum.Bounded GHC.Internal.System.Posix.Types.CIno
instance GHC.Internal.Enum.Bounded GHC.Internal.System.Posix.Types.CKey
instance GHC.Internal.Enum.Bounded GHC.Internal.System.Posix.Types.CMode
instance GHC.Internal.Enum.Bounded GHC.Internal.System.Posix.Types.CNfds
instance GHC.Internal.Enum.Bounded GHC.Internal.System.Posix.Types.CNlink
instance GHC.Internal.Enum.Bounded GHC.Internal.System.Posix.Types.COff
instance GHC.Internal.Enum.Bounded GHC.Internal.System.Posix.Types.CPid
instance GHC.Internal.Enum.Bounded GHC.Internal.System.Posix.Types.CRLim
instance GHC.Internal.Enum.Bounded GHC.Internal.System.Posix.Types.CSocklen
instance GHC.Internal.Enum.Bounded GHC.Internal.System.Posix.Types.CSsize
instance GHC.Internal.Enum.Bounded GHC.Internal.System.Posix.Types.CTcflag
instance GHC.Internal.Enum.Bounded GHC.Internal.System.Posix.Types.CUid
instance GHC.Internal.Enum.Bounded GHC.Internal.System.Posix.Types.Fd
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.CBlkCnt
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.CBlkSize
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.CCc
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.CClockId
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.CDev
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.CFsBlkCnt
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.CFsFilCnt
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.CGid
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.CId
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.CIno
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.CKey
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.CMode
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.CNfds
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.CNlink
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.COff
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.CPid
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.CRLim
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.CSocklen
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.CSpeed
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.CSsize
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.CTcflag
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.CUid
instance GHC.Internal.Enum.Enum GHC.Internal.System.Posix.Types.Fd
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CBlkCnt
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CBlkSize
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CCc
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CClockId
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CDev
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CFsBlkCnt
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CFsFilCnt
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CGid
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CId
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CIno
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CKey
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CMode
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CNfds
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CNlink
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.COff
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CPid
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CRLim
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CSocklen
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CSpeed
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CSsize
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CTcflag
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CTimer
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.CUid
instance GHC.Classes.Eq GHC.Internal.System.Posix.Types.Fd
instance GHC.Internal.Bits.FiniteBits GHC.Internal.System.Posix.Types.CBlkCnt
instance GHC.Internal.Bits.FiniteBits GHC.Internal.System.Posix.Types.CBlkSize
instance GHC.Internal.Bits.FiniteBits GHC.Internal.System.Posix.Types.CClockId
instance GHC.Internal.Bits.FiniteBits GHC.Internal.System.Posix.Types.CDev
instance GHC.Internal.Bits.FiniteBits GHC.Internal.System.Posix.Types.CFsBlkCnt
instance GHC.Internal.Bits.FiniteBits GHC.Internal.System.Posix.Types.CFsFilCnt
instance GHC.Internal.Bits.FiniteBits GHC.Internal.System.Posix.Types.CGid
instance GHC.Internal.Bits.FiniteBits GHC.Internal.System.Posix.Types.CId
instance GHC.Internal.Bits.FiniteBits GHC.Internal.System.Posix.Types.CIno
instance GHC.Internal.Bits.FiniteBits GHC.Internal.System.Posix.Types.CKey
instance GHC.Internal.Bits.FiniteBits GHC.Internal.System.Posix.Types.CMode
instance GHC.Internal.Bits.FiniteBits GHC.Internal.System.Posix.Types.CNfds
instance GHC.Internal.Bits.FiniteBits GHC.Internal.System.Posix.Types.CNlink
instance GHC.Internal.Bits.FiniteBits GHC.Internal.System.Posix.Types.COff
instance GHC.Internal.Bits.FiniteBits GHC.Internal.System.Posix.Types.CPid
instance GHC.Internal.Bits.FiniteBits GHC.Internal.System.Posix.Types.CRLim
instance GHC.Internal.Bits.FiniteBits GHC.Internal.System.Posix.Types.CSocklen
instance GHC.Internal.Bits.FiniteBits GHC.Internal.System.Posix.Types.CSsize
instance GHC.Internal.Bits.FiniteBits GHC.Internal.System.Posix.Types.CTcflag
instance GHC.Internal.Bits.FiniteBits GHC.Internal.System.Posix.Types.CUid
instance GHC.Internal.Bits.FiniteBits GHC.Internal.System.Posix.Types.Fd
instance GHC.Internal.Real.Integral GHC.Internal.System.Posix.Types.CBlkCnt
instance GHC.Internal.Real.Integral GHC.Internal.System.Posix.Types.CBlkSize
instance GHC.Internal.Real.Integral GHC.Internal.System.Posix.Types.CClockId
instance GHC.Internal.Real.Integral GHC.Internal.System.Posix.Types.CDev
instance GHC.Internal.Real.Integral GHC.Internal.System.Posix.Types.CFsBlkCnt
instance GHC.Internal.Real.Integral GHC.Internal.System.Posix.Types.CFsFilCnt
instance GHC.Internal.Real.Integral GHC.Internal.System.Posix.Types.CGid
instance GHC.Internal.Real.Integral GHC.Internal.System.Posix.Types.CId
instance GHC.Internal.Real.Integral GHC.Internal.System.Posix.Types.CIno
instance GHC.Internal.Real.Integral GHC.Internal.System.Posix.Types.CKey
instance GHC.Internal.Real.Integral GHC.Internal.System.Posix.Types.CMode
instance GHC.Internal.Real.Integral GHC.Internal.System.Posix.Types.CNfds
instance GHC.Internal.Real.Integral GHC.Internal.System.Posix.Types.CNlink
instance GHC.Internal.Real.Integral GHC.Internal.System.Posix.Types.COff
instance GHC.Internal.Real.Integral GHC.Internal.System.Posix.Types.CPid
instance GHC.Internal.Real.Integral GHC.Internal.System.Posix.Types.CRLim
instance GHC.Internal.Real.Integral GHC.Internal.System.Posix.Types.CSocklen
instance GHC.Internal.Real.Integral GHC.Internal.System.Posix.Types.CSsize
instance GHC.Internal.Real.Integral GHC.Internal.System.Posix.Types.CTcflag
instance GHC.Internal.Real.Integral GHC.Internal.System.Posix.Types.CUid
instance GHC.Internal.Real.Integral GHC.Internal.System.Posix.Types.Fd
instance GHC.Internal.Ix.Ix GHC.Internal.System.Posix.Types.CBlkCnt
instance GHC.Internal.Ix.Ix GHC.Internal.System.Posix.Types.CBlkSize
instance GHC.Internal.Ix.Ix GHC.Internal.System.Posix.Types.CClockId
instance GHC.Internal.Ix.Ix GHC.Internal.System.Posix.Types.CDev
instance GHC.Internal.Ix.Ix GHC.Internal.System.Posix.Types.CFsBlkCnt
instance GHC.Internal.Ix.Ix GHC.Internal.System.Posix.Types.CFsFilCnt
instance GHC.Internal.Ix.Ix GHC.Internal.System.Posix.Types.CGid
instance GHC.Internal.Ix.Ix GHC.Internal.System.Posix.Types.CId
instance GHC.Internal.Ix.Ix GHC.Internal.System.Posix.Types.CIno
instance GHC.Internal.Ix.Ix GHC.Internal.System.Posix.Types.CKey
instance GHC.Internal.Ix.Ix GHC.Internal.System.Posix.Types.CMode
instance GHC.Internal.Ix.Ix GHC.Internal.System.Posix.Types.CNfds
instance GHC.Internal.Ix.Ix GHC.Internal.System.Posix.Types.CNlink
instance GHC.Internal.Ix.Ix GHC.Internal.System.Posix.Types.COff
instance GHC.Internal.Ix.Ix GHC.Internal.System.Posix.Types.CPid
instance GHC.Internal.Ix.Ix GHC.Internal.System.Posix.Types.CRLim
instance GHC.Internal.Ix.Ix GHC.Internal.System.Posix.Types.CSocklen
instance GHC.Internal.Ix.Ix GHC.Internal.System.Posix.Types.CSsize
instance GHC.Internal.Ix.Ix GHC.Internal.System.Posix.Types.CTcflag
instance GHC.Internal.Ix.Ix GHC.Internal.System.Posix.Types.CUid
instance GHC.Internal.Ix.Ix GHC.Internal.System.Posix.Types.Fd
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.CBlkCnt
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.CBlkSize
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.CCc
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.CClockId
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.CDev
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.CFsBlkCnt
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.CFsFilCnt
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.CGid
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.CId
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.CIno
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.CKey
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.CMode
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.CNfds
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.CNlink
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.COff
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.CPid
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.CRLim
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.CSocklen
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.CSpeed
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.CSsize
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.CTcflag
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.CUid
instance GHC.Internal.Num.Num GHC.Internal.System.Posix.Types.Fd
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CBlkCnt
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CBlkSize
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CCc
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CClockId
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CDev
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CFsBlkCnt
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CFsFilCnt
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CGid
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CId
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CIno
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CKey
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CMode
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CNfds
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CNlink
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.COff
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CPid
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CRLim
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CSocklen
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CSpeed
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CSsize
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CTcflag
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CTimer
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.CUid
instance GHC.Classes.Ord GHC.Internal.System.Posix.Types.Fd
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.CBlkCnt
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.CBlkSize
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.CCc
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.CClockId
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.CDev
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.CFsBlkCnt
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.CFsFilCnt
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.CGid
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.CId
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.CIno
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.CKey
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.CMode
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.CNfds
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.CNlink
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.COff
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.CPid
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.CRLim
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.CSocklen
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.CSpeed
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.CSsize
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.CTcflag
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.CUid
instance GHC.Internal.Read.Read GHC.Internal.System.Posix.Types.Fd
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.CBlkCnt
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.CBlkSize
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.CCc
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.CClockId
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.CDev
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.CFsBlkCnt
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.CFsFilCnt
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.CGid
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.CId
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.CIno
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.CKey
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.CMode
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.CNfds
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.CNlink
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.COff
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.CPid
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.CRLim
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.CSocklen
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.CSpeed
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.CSsize
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.CTcflag
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.CUid
instance GHC.Internal.Real.Real GHC.Internal.System.Posix.Types.Fd
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CBlkCnt
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CBlkSize
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CCc
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CClockId
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CDev
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CFsBlkCnt
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CFsFilCnt
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CGid
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CId
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CIno
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CKey
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CMode
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CNfds
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CNlink
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.COff
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CPid
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CRLim
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CSocklen
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CSpeed
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CSsize
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CTcflag
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CTimer
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.CUid
instance GHC.Internal.Show.Show GHC.Internal.System.Posix.Types.Fd
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CBlkCnt
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CBlkSize
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CCc
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CClockId
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CDev
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CFsBlkCnt
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CFsFilCnt
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CGid
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CId
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CIno
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CKey
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CMode
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CNfds
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CNlink
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.COff
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CPid
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CRLim
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CSocklen
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CSpeed
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CSsize
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CTcflag
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CTimer
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.CUid
instance GHC.Internal.Foreign.Storable.Storable GHC.Internal.System.Posix.Types.Fd


-- | Orderings
module GHC.Internal.Data.Ord

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   <a>Ord</a>, as defined by the Haskell report, implements a total order
--   and has the following properties:
--   
--   <ul>
--   <li><i><b>Comparability</b></i> <tt>x &lt;= y || y &lt;= x</tt> =
--   <a>True</a></li>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   The following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Note that (7.) and (8.) do <i>not</i> require <a>min</a> and
--   <a>max</a> to return either of their arguments. The result is merely
--   required to <i>equal</i> one of the arguments in terms of <a>(==)</a>.
--   Users who expect a stronger guarantee are advised to write their own
--   min and/or max functions.
--   
--   The nuance of the above distinction is not always fully internalized
--   by developers, and in the past (tracing back to the Haskell 1.4
--   Report) the specification for <a>Ord</a> asserted the stronger
--   property that <tt>(min x y, max x y) = (x, y)</tt> or <tt>(y, x)</tt>,
--   or in other words, that <a>min</a> and <a>max</a> <i>will</i> return
--   one of their arguments, using argument order as the tie-breaker if the
--   arguments are equal by comparison. A few list and <a>Foldable</a>
--   functions have behavior that is best understood with this assumption
--   in mind: all variations of <tt>minimumBy</tt> and <tt>maximumBy</tt>
--   (which can't use <a>min</a> and <a>max</a> in their implementations)
--   are written such that <tt>minimumBy <a>compare</a></tt> and
--   <tt>maximumBy <a>compare</a></tt> are respectively equivalent to
--   <tt>minimum</tt> and <tt>maximum</tt> (which do use <a>min</a> and
--   <a>max</a>) only if <a>min</a> and <a>max</a> adhere to this
--   tie-breaking convention. Otherwise, if there are multiple least or
--   largest elements in a container, <tt>minimum</tt> and <tt>maximum</tt>
--   may not return the <i>same</i> one that <tt>minimumBy
--   <a>compare</a></tt> and <tt>maximumBy <a>compare</a></tt> do (though
--   they should return something that is <i>equal</i>). (This is relevant
--   for types with non-extensional equality, like <a>Arg</a>, but also in
--   cases where the precise reference held matters for memory-management
--   reasons.) Unless there is a reason to deviate, it is less confusing
--   for implementors of <a>Ord</a> to respect this same convention (as the
--   default definitions of <a>min</a> and <a>max</a> do).
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 <
infix 4 <=
infix 4 >
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | The <a>Down</a> type allows you to reverse sort order conveniently. A
--   value of type <tt><a>Down</a> a</tt> contains a value of type
--   <tt>a</tt> (represented as <tt><a>Down</a> a</tt>).
--   
--   If <tt>a</tt> has an <tt><a>Ord</a></tt> instance associated with it
--   then comparing two values thus wrapped will give you the opposite of
--   their normal sort order. This is particularly useful when sorting in
--   generalised list comprehensions, as in: <tt>then sortWith by
--   <a>Down</a> x</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; compare True False
--   GT
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; compare (Down True) (Down False)
--   LT
--   </pre>
--   
--   If <tt>a</tt> has a <tt><a>Bounded</a></tt> instance then the wrapped
--   instance also respects the reversed ordering by exchanging the values
--   of <tt><a>minBound</a></tt> and <tt><a>maxBound</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; minBound :: Int
--   -9223372036854775808
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minBound :: Down Int
--   Down 9223372036854775807
--   </pre>
--   
--   All other instances of <tt><a>Down</a> a</tt> behave as they do for
--   <tt>a</tt>.
newtype Down a
Down :: a -> Down a

[getDown] :: Down a -> a

-- | <pre>
--   comparing p x y = compare (p x) (p y)
--   </pre>
--   
--   Useful combinator for use in conjunction with the <tt>xxxBy</tt>
--   family of functions from <a>Data.List</a>, for example:
--   
--   <pre>
--   ... sortBy (comparing fst) ...
--   </pre>
comparing :: Ord a => (b -> a) -> b -> b -> Ordering

-- | <pre>
--   clamp (low, high) a = min high (max a low)
--   </pre>
--   
--   Function for ensuring the value <tt>a</tt> is within the inclusive
--   bounds given by <tt>low</tt> and <tt>high</tt>. If it is, <tt>a</tt>
--   is returned unchanged. The result is otherwise <tt>low</tt> if <tt>a
--   &lt;= low</tt>, or <tt>high</tt> if <tt>high &lt;= a</tt>.
--   
--   When clamp is used at Double and Float, it has NaN propagating
--   semantics in its second argument. That is, <tt>clamp (l,h) NaN =
--   NaN</tt>, but <tt>clamp (NaN, NaN) x = x</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; clamp (0, 10) 2
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; clamp ('a', 'm') 'x'
--   'm'
--   </pre>
clamp :: Ord a => (a, a) -> a -> a
instance GHC.Internal.Base.Applicative GHC.Internal.Data.Ord.Down
instance GHC.Internal.Bits.Bits a => GHC.Internal.Bits.Bits (GHC.Internal.Data.Ord.Down a)
instance GHC.Internal.Enum.Bounded a => GHC.Internal.Enum.Bounded (GHC.Internal.Data.Ord.Down a)
instance (GHC.Internal.Enum.Enum a, GHC.Internal.Enum.Bounded a, GHC.Classes.Eq a) => GHC.Internal.Enum.Enum (GHC.Internal.Data.Ord.Down a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Internal.Data.Ord.Down a)
instance GHC.Internal.Bits.FiniteBits a => GHC.Internal.Bits.FiniteBits (GHC.Internal.Data.Ord.Down a)
instance GHC.Internal.Float.Floating a => GHC.Internal.Float.Floating (GHC.Internal.Data.Ord.Down a)
instance GHC.Internal.Real.Fractional a => GHC.Internal.Real.Fractional (GHC.Internal.Data.Ord.Down a)
instance GHC.Internal.Base.Functor GHC.Internal.Data.Ord.Down
instance GHC.Internal.Ix.Ix a => GHC.Internal.Ix.Ix (GHC.Internal.Data.Ord.Down a)
instance GHC.Internal.Base.Monad GHC.Internal.Data.Ord.Down
instance GHC.Internal.Base.Monoid a => GHC.Internal.Base.Monoid (GHC.Internal.Data.Ord.Down a)
instance GHC.Internal.Num.Num a => GHC.Internal.Num.Num (GHC.Internal.Data.Ord.Down a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Internal.Data.Ord.Down a)
instance GHC.Internal.Read.Read a => GHC.Internal.Read.Read (GHC.Internal.Data.Ord.Down a)
instance GHC.Internal.Real.Real a => GHC.Internal.Real.Real (GHC.Internal.Data.Ord.Down a)
instance GHC.Internal.Float.RealFloat a => GHC.Internal.Float.RealFloat (GHC.Internal.Data.Ord.Down a)
instance GHC.Internal.Real.RealFrac a => GHC.Internal.Real.RealFrac (GHC.Internal.Data.Ord.Down a)
instance GHC.Internal.Base.Semigroup a => GHC.Internal.Base.Semigroup (GHC.Internal.Data.Ord.Down a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Internal.Data.Ord.Down a)
instance GHC.Internal.Foreign.Storable.Storable a => GHC.Internal.Foreign.Storable.Storable (GHC.Internal.Data.Ord.Down a)


-- | Basic operations on type-level Orderings.
module GHC.Internal.Data.Type.Ord

-- | <a>Compare</a> branches on the kind of its arguments to either compare
--   by <a>Symbol</a> or <tt>Nat</tt>.
type family Compare (a :: k) (b :: k) :: Ordering

-- | Ordering data type for type literals that provides proof of their
--   ordering.
data OrderingI (a :: k) (b :: k)
[LTI] :: forall {k} (a :: k) (b :: k). Compare a b ~ 'LT => OrderingI a b
[EQI] :: forall {k} (a :: k). Compare a a ~ 'EQ => OrderingI a a
[GTI] :: forall {k} (a :: k) (b :: k). Compare a b ~ 'GT => OrderingI a b

-- | Comparison (&lt;=) of comparable types, as a constraint.
type (x :: t) <= (y :: t) = Assert x <=? y LeErrMsg x y :: Constraint
infix 4 <=

-- | Comparison (&lt;=) of comparable types, as a function.
type (m :: k) <=? (n :: k) = OrdCond Compare m n 'True 'True 'False
infix 4 <=?

-- | Comparison (&gt;=) of comparable types, as a constraint.
type (x :: t) >= (y :: t) = Assert x >=? y GeErrMsg x y :: Constraint
infix 4 >=

-- | Comparison (&gt;=) of comparable types, as a function.
type (m :: k) >=? (n :: k) = OrdCond Compare m n 'False 'True 'True
infix 4 >=?

-- | Comparison (&gt;) of comparable types, as a constraint.
type (x :: t) > (y :: t) = Assert x >? y GtErrMsg x y :: Constraint
infix 4 >

-- | Comparison (&gt;) of comparable types, as a function.
type (m :: k) >? (n :: k) = OrdCond Compare m n 'False 'False 'True
infix 4 >?

-- | Comparison (&lt;) of comparable types, as a constraint.
type (x :: t) < (y :: t) = Assert x <? y LtErrMsg x y :: Constraint
infix 4 <

-- | Comparison (&lt;) of comparable types, as a function.
type (m :: k) <? (n :: k) = OrdCond Compare m n 'True 'False 'False
infix 4 <?

-- | Maximum between two comparable types.
type Max (m :: k) (n :: k) = OrdCond Compare m n n n m

-- | Minimum between two comparable types.
type Min (m :: k) (n :: k) = OrdCond Compare m n m m n

-- | A case statement on <a>Ordering</a>.
--   
--   <tt>OrdCond c l e g</tt> is <tt>l</tt> when <tt>c ~ LT</tt>,
--   <tt>e</tt> when <tt>c ~ EQ</tt>, and <tt>g</tt> when <tt>c ~ GT</tt>.
type family OrdCond (o :: Ordering) (lt :: k) (eq :: k) (gt :: k) :: k
instance forall k (a :: k) (b :: k). GHC.Classes.Eq (GHC.Internal.Data.Type.Ord.OrderingI a b)
instance forall k (a :: k) (b :: k). GHC.Internal.Show.Show (GHC.Internal.Data.Type.Ord.OrderingI a b)


-- | This module is an internal GHC module. It declares the constants used
--   in the implementation of type-level natural numbers. The programmer
--   interface for working with type-level naturals should be defined in a
--   separate library.
module GHC.Internal.TypeNats

-- | Natural number
--   
--   Invariant: numbers &lt;= 0xffffffffffffffff use the <a>NS</a>
--   constructor
data Natural

-- | A type synonym for <a>Natural</a>.
--   
--   Previously, this was an opaque data type, but it was changed to a type
--   synonym.
type Nat = Natural

-- | This class gives the integer associated with a type-level natural.
--   There are instances of the class for every concrete literal: 0, 1, 2,
--   etc.
class KnownNat (n :: Nat)
natSing :: KnownNat n => SNat n

natVal :: forall (n :: Nat) proxy. KnownNat n => proxy n -> Natural

natVal' :: forall (n :: Nat). KnownNat n => Proxy# n -> Natural

-- | This type represents unknown type-level natural numbers.
data SomeNat
SomeNat :: Proxy n -> SomeNat

-- | Convert an integer into an unknown type-level natural.
someNatVal :: Natural -> SomeNat

-- | We either get evidence that this function was instantiated with the
--   same type-level numbers, or <a>Nothing</a>.
sameNat :: forall (a :: Nat) (b :: Nat) proxy1 proxy2. (KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> Maybe (a :~: b)

-- | We either get evidence that this function was instantiated with the
--   same type-level numbers, or that the type-level numbers are distinct.
decideNat :: forall (a :: Nat) (b :: Nat) proxy1 proxy2. (KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> Either ((a :~: b) -> Void) (a :~: b)

-- | A value-level witness for a type-level natural number. This is
--   commonly referred to as a <i>singleton</i> type, as for each
--   <tt>n</tt>, there is a single value that inhabits the type
--   <tt><a>SNat</a> n</tt> (aside from bottom).
--   
--   The definition of <a>SNat</a> is intentionally left abstract. To
--   obtain an <a>SNat</a> value, use one of the following:
--   
--   <ol>
--   <li>The <a>natSing</a> method of <a>KnownNat</a>.</li>
--   <li>The <tt>SNat</tt> pattern synonym.</li>
--   <li>The <a>withSomeSNat</a> function, which creates an <a>SNat</a>
--   from a <a>Natural</a> number.</li>
--   </ol>
data SNat (n :: Nat)

-- | A pattern that can be used to manipulate the <a>Natural</a> that an
--   <tt>SNat n</tt> contains under the hood.
--   
--   When using this pattern to construct an <tt>SNat n</tt>, the actual
--   <tt>Natural</tt> being stored in the <tt>SNat n</tt> <i>must</i> be
--   equal to <tt>n</tt>. The compiler will not help you verify this, hence
--   the 'unsafe' name.
pattern UnsafeSNat :: Natural -> SNat n

-- | A explicitly bidirectional pattern synonym relating an <a>SNat</a> to
--   a <a>KnownNat</a> constraint.
--   
--   As an <b>expression</b>: Constructs an explicit <tt><a>SNat</a> n</tt>
--   value from an implicit <tt><a>KnownNat</a> n</tt> constraint:
--   
--   <pre>
--   SNat @n :: <a>KnownNat</a> n =&gt; <a>SNat</a> n
--   </pre>
--   
--   As a <b>pattern</b>: Matches on an explicit <tt><a>SNat</a> n</tt>
--   value bringing an implicit <tt><a>KnownNat</a> n</tt> constraint into
--   scope:
--   
--   <pre>
--   f :: <a>SNat</a> n -&gt; ..
--   f SNat = {- KnownNat n in scope -}
--   </pre>
pattern SNat :: () => KnownNat n => SNat n

-- | Return the <a>Natural</a> number corresponding to <tt>n</tt> in an
--   <tt><a>SNat</a> n</tt> value.
fromSNat :: forall (n :: Nat). SNat n -> Natural

-- | Convert a <a>Natural</a> number into an <tt><a>SNat</a> n</tt> value,
--   where <tt>n</tt> is a fresh type-level natural number.
withSomeSNat :: Natural -> (forall (n :: Nat). () => SNat n -> r) -> r

-- | Convert an explicit <tt><a>SNat</a> n</tt> value into an implicit
--   <tt><a>KnownNat</a> n</tt> constraint.
withKnownNat :: forall (n :: Nat) r. SNat n -> (KnownNat n => r) -> r

-- | <a>unsafeWithSNatCo</a> allows uses of <tt>coerce</tt> in its argument
--   to see the real representation of <tt>SNat n</tt>, without undermining
--   the type-safety of <tt>coerce</tt> elsewhere in the module.
--   
--   See also the documentation for <a>UnsafeSNat</a>.
unsafeWithSNatCo :: ((forall (n :: Nat). () => Coercible (SNat n) Natural) => r) -> r

-- | Comparison (&lt;=) of comparable types, as a constraint.
type (x :: t) <= (y :: t) = Assert x <=? y LeErrMsg x y :: Constraint
infix 4 <=

-- | Comparison (&lt;=) of comparable types, as a function.
type (m :: k) <=? (n :: k) = OrdCond Compare m n 'True 'True 'False
infix 4 <=?

-- | Addition of type-level naturals.
type family (a :: Natural) + (b :: Natural) :: Natural
infixl 6 +

-- | Multiplication of type-level naturals.
type family (a :: Natural) * (b :: Natural) :: Natural
infixl 7 *

-- | Exponentiation of type-level naturals.
type family (a :: Natural) ^ (b :: Natural) :: Natural
infixr 8 ^

-- | Subtraction of type-level naturals.
type family (a :: Natural) - (b :: Natural) :: Natural
infixl 6 -

-- | Comparison of type-level naturals, as a function.
type family CmpNat (a :: Natural) (b :: Natural) :: Ordering

-- | Like <a>sameNat</a>, but if the numbers aren't equal, this
--   additionally provides proof of LT or GT.
cmpNat :: forall (a :: Nat) (b :: Nat) proxy1 proxy2. (KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> OrderingI a b

-- | Division (round down) of natural numbers. <tt>Div x 0</tt> is
--   undefined (i.e., it cannot be reduced).
type family Div (a :: Natural) (b :: Natural) :: Natural
infixl 7 `Div`

-- | Modulus of natural numbers. <tt>Mod x 0</tt> is undefined (i.e., it
--   cannot be reduced).
type family Mod (a :: Natural) (b :: Natural) :: Natural
infixl 7 `Mod`

-- | Log base 2 (round down) of natural numbers. <tt>Log 0</tt> is
--   undefined (i.e., it cannot be reduced).
type family Log2 (a :: Natural) :: Natural
instance GHC.Classes.Eq (GHC.Internal.TypeNats.SNat n)
instance GHC.Classes.Eq GHC.Internal.TypeNats.SomeNat
instance GHC.Classes.Ord (GHC.Internal.TypeNats.SNat n)
instance GHC.Classes.Ord GHC.Internal.TypeNats.SomeNat
instance GHC.Internal.Read.Read GHC.Internal.TypeNats.SomeNat
instance GHC.Internal.Show.Show (GHC.Internal.TypeNats.SNat n)
instance GHC.Internal.Show.Show GHC.Internal.TypeNats.SomeNat
instance GHC.Internal.Data.Type.Coercion.TestCoercion GHC.Internal.TypeNats.SNat
instance GHC.Internal.Data.Type.Equality.TestEquality GHC.Internal.TypeNats.SNat


-- | GHC's <tt>DataKinds</tt> language extension lifts data constructors,
--   natural numbers, and strings to the type level. This module provides
--   the primitives needed for working with type-level numbers (the
--   <tt>Nat</tt> kind), strings (the <a>Symbol</a> kind), and characters
--   (the <a>Char</a> kind). It also defines the <a>TypeError</a> type
--   family, a feature that makes use of type-level strings to support user
--   defined type errors.
--   
--   For now, this module is the API for working with type-level literals.
--   However, please note that it is a work in progress and is subject to
--   change. Once the design of the <tt>DataKinds</tt> feature is more
--   stable, this will be considered only an internal GHC module, and the
--   programmer interface for working with type-level data will be defined
--   in a separate library.
module GHC.Internal.TypeLits

-- | Natural number
--   
--   Invariant: numbers &lt;= 0xffffffffffffffff use the <a>NS</a>
--   constructor
data Natural

-- | A type synonym for <a>Natural</a>.
--   
--   Previously, this was an opaque data type, but it was changed to a type
--   synonym.
type Nat = Natural

-- | (Kind) This is the kind of type-level symbols.
data Symbol

-- | This class gives the integer associated with a type-level natural.
--   There are instances of the class for every concrete literal: 0, 1, 2,
--   etc.
class KnownNat (n :: Nat)
natSing :: KnownNat n => SNat n

natVal :: forall (n :: Nat) proxy. KnownNat n => proxy n -> Integer

natVal' :: forall (n :: Nat). KnownNat n => Proxy# n -> Integer

-- | This class gives the string associated with a type-level symbol. There
--   are instances of the class for every concrete literal: "hello", etc.
class KnownSymbol (n :: Symbol)
symbolSing :: KnownSymbol n => SSymbol n

symbolVal :: forall (n :: Symbol) proxy. KnownSymbol n => proxy n -> String

symbolVal' :: forall (n :: Symbol). KnownSymbol n => Proxy# n -> String

class KnownChar (n :: Char)
charSing :: KnownChar n => SChar n
charVal :: forall (n :: Char) proxy. KnownChar n => proxy n -> Char
charVal' :: forall (n :: Char). KnownChar n => Proxy# n -> Char

-- | This type represents unknown type-level natural numbers.
data SomeNat
SomeNat :: Proxy n -> SomeNat

-- | This type represents unknown type-level symbols.
data SomeSymbol

SomeSymbol :: Proxy n -> SomeSymbol
data SomeChar
SomeChar :: Proxy n -> SomeChar

-- | Convert an integer into an unknown type-level natural.
someNatVal :: Integer -> Maybe SomeNat

-- | Convert a string into an unknown type-level symbol.
someSymbolVal :: String -> SomeSymbol

-- | Convert a character into an unknown type-level char.
someCharVal :: Char -> SomeChar

-- | We either get evidence that this function was instantiated with the
--   same type-level numbers, or <a>Nothing</a>.
sameNat :: forall (a :: Nat) (b :: Nat) proxy1 proxy2. (KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> Maybe (a :~: b)

-- | We either get evidence that this function was instantiated with the
--   same type-level symbols, or <a>Nothing</a>.
sameSymbol :: forall (a :: Symbol) (b :: Symbol) proxy1 proxy2. (KnownSymbol a, KnownSymbol b) => proxy1 a -> proxy2 b -> Maybe (a :~: b)

-- | We either get evidence that this function was instantiated with the
--   same type-level characters, or <a>Nothing</a>.
sameChar :: forall (a :: Char) (b :: Char) proxy1 proxy2. (KnownChar a, KnownChar b) => proxy1 a -> proxy2 b -> Maybe (a :~: b)

-- | We either get evidence that this function was instantiated with the
--   same type-level numbers, or that the type-level numbers are distinct.
decideNat :: forall (a :: Nat) (b :: Nat) proxy1 proxy2. (KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> Either ((a :~: b) -> Void) (a :~: b)

-- | We either get evidence that this function was instantiated with the
--   same type-level symbols, or that the type-level symbols are distinct.
decideSymbol :: forall (a :: Symbol) (b :: Symbol) proxy1 proxy2. (KnownSymbol a, KnownSymbol b) => proxy1 a -> proxy2 b -> Either ((a :~: b) -> Void) (a :~: b)

-- | We either get evidence that this function was instantiated with the
--   same type-level characters, or that the type-level characters are
--   distinct.
decideChar :: forall (a :: Char) (b :: Char) proxy1 proxy2. (KnownChar a, KnownChar b) => proxy1 a -> proxy2 b -> Either ((a :~: b) -> Void) (a :~: b)

-- | Ordering data type for type literals that provides proof of their
--   ordering.
data OrderingI (a :: k) (b :: k)
[LTI] :: forall {k} (a :: k) (b :: k). Compare a b ~ 'LT => OrderingI a b
[EQI] :: forall {k} (a :: k). Compare a a ~ 'EQ => OrderingI a a
[GTI] :: forall {k} (a :: k) (b :: k). Compare a b ~ 'GT => OrderingI a b

-- | Like <a>sameNat</a>, but if the numbers aren't equal, this
--   additionally provides proof of LT or GT.
cmpNat :: forall (a :: Nat) (b :: Nat) proxy1 proxy2. (KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> OrderingI a b

-- | Like <a>sameSymbol</a>, but if the symbols aren't equal, this
--   additionally provides proof of LT or GT.
cmpSymbol :: forall (a :: Symbol) (b :: Symbol) proxy1 proxy2. (KnownSymbol a, KnownSymbol b) => proxy1 a -> proxy2 b -> OrderingI a b

-- | Like <a>sameChar</a>, but if the Chars aren't equal, this additionally
--   provides proof of LT or GT.
cmpChar :: forall (a :: Char) (b :: Char) proxy1 proxy2. (KnownChar a, KnownChar b) => proxy1 a -> proxy2 b -> OrderingI a b

-- | A value-level witness for a type-level natural number. This is
--   commonly referred to as a <i>singleton</i> type, as for each
--   <tt>n</tt>, there is a single value that inhabits the type
--   <tt><a>SNat</a> n</tt> (aside from bottom).
--   
--   The definition of <a>SNat</a> is intentionally left abstract. To
--   obtain an <a>SNat</a> value, use one of the following:
--   
--   <ol>
--   <li>The <a>natSing</a> method of <a>KnownNat</a>.</li>
--   <li>The <tt>SNat</tt> pattern synonym.</li>
--   <li>The <a>withSomeSNat</a> function, which creates an <a>SNat</a>
--   from a <a>Natural</a> number.</li>
--   </ol>
data SNat (n :: Nat)

-- | A pattern that can be used to manipulate the <a>Natural</a> that an
--   <tt>SNat n</tt> contains under the hood.
--   
--   When using this pattern to construct an <tt>SNat n</tt>, the actual
--   <tt>Natural</tt> being stored in the <tt>SNat n</tt> <i>must</i> be
--   equal to <tt>n</tt>. The compiler will not help you verify this, hence
--   the 'unsafe' name.
pattern UnsafeSNat :: Natural -> SNat n

-- | A value-level witness for a type-level symbol. This is commonly
--   referred to as a <i>singleton</i> type, as for each <tt>s</tt>, there
--   is a single value that inhabits the type <tt><a>SSymbol</a> s</tt>
--   (aside from bottom).
--   
--   The definition of <a>SSymbol</a> is intentionally left abstract. To
--   obtain an <a>SSymbol</a> value, use one of the following:
--   
--   <ol>
--   <li>The <a>symbolSing</a> method of <a>KnownSymbol</a>.</li>
--   <li>The <tt>SSymbol</tt> pattern synonym.</li>
--   <li>The <a>withSomeSSymbol</a> function, which creates an
--   <a>SSymbol</a> from a <a>String</a>.</li>
--   </ol>
data SSymbol (s :: Symbol)

-- | A pattern that can be used to manipulate the <a>String</a> that an
--   <tt>SSymbol s</tt> contains under the hood.
--   
--   When using this pattern to construct an <tt>SSymbol s</tt>, the actual
--   <tt>String</tt> being stored in the <tt>SSymbol</tt> <i>must</i> be
--   equal to (the contents of) <tt>s</tt>. The compiler will not help you
--   verify this, hence the 'unsafe' name.
pattern UnsafeSSymbol :: String -> SSymbol s

-- | A value-level witness for a type-level character. This is commonly
--   referred to as a <i>singleton</i> type, as for each <tt>c</tt>, there
--   is a single value that inhabits the type <tt><a>SChar</a> c</tt>
--   (aside from bottom).
--   
--   The definition of <a>SChar</a> is intentionally left abstract. To
--   obtain an <a>SChar</a> value, use one of the following:
--   
--   <ol>
--   <li>The <a>charSing</a> method of <a>KnownChar</a>.</li>
--   <li>The <tt>SChar</tt> pattern synonym.</li>
--   <li>The <a>withSomeSChar</a> function, which creates an <a>SChar</a>
--   from a <a>Char</a>.</li>
--   </ol>
data SChar (s :: Char)

-- | A pattern that can be used to manipulate the <a>Char</a> that an
--   <tt>SChar c</tt> contains under the hood.
--   
--   When using this pattern to construct an <tt>SChar c</tt>, the actual
--   <tt>Char</tt> being stored in the <tt>SChar c</tt> <i>must</i> be
--   equal to <tt>c</tt>. The compiler will not help you verify this, hence
--   the 'unsafe' name.
pattern UnsafeSChar :: Char -> SChar c

-- | A explicitly bidirectional pattern synonym relating an <a>SNat</a> to
--   a <a>KnownNat</a> constraint.
--   
--   As an <b>expression</b>: Constructs an explicit <tt><a>SNat</a> n</tt>
--   value from an implicit <tt><a>KnownNat</a> n</tt> constraint:
--   
--   <pre>
--   SNat @n :: <a>KnownNat</a> n =&gt; <a>SNat</a> n
--   </pre>
--   
--   As a <b>pattern</b>: Matches on an explicit <tt><a>SNat</a> n</tt>
--   value bringing an implicit <tt><a>KnownNat</a> n</tt> constraint into
--   scope:
--   
--   <pre>
--   f :: <a>SNat</a> n -&gt; ..
--   f SNat = {- KnownNat n in scope -}
--   </pre>
pattern SNat :: () => KnownNat n => SNat n

-- | A explicitly bidirectional pattern synonym relating an <a>SSymbol</a>
--   to a <a>KnownSymbol</a> constraint.
--   
--   As an <b>expression</b>: Constructs an explicit <tt><a>SSymbol</a>
--   s</tt> value from an implicit <tt><a>KnownSymbol</a> s</tt>
--   constraint:
--   
--   <pre>
--   SSymbol @s :: <a>KnownSymbol</a> s =&gt; <a>SSymbol</a> s
--   </pre>
--   
--   As a <b>pattern</b>: Matches on an explicit <tt><a>SSymbol</a> s</tt>
--   value bringing an implicit <tt><a>KnownSymbol</a> s</tt> constraint
--   into scope:
--   
--   <pre>
--   f :: <a>SSymbol</a> s -&gt; ..
--   f SSymbol = {- KnownSymbol s in scope -}
--   </pre>
pattern SSymbol :: () => KnownSymbol s => SSymbol s

-- | A explicitly bidirectional pattern synonym relating an <a>SChar</a> to
--   a <a>KnownChar</a> constraint.
--   
--   As an <b>expression</b>: Constructs an explicit <tt><a>SChar</a>
--   c</tt> value from an implicit <tt><a>KnownChar</a> c</tt> constraint:
--   
--   <pre>
--   SChar @c :: <a>KnownChar</a> c =&gt; <a>SChar</a> c
--   </pre>
--   
--   As a <b>pattern</b>: Matches on an explicit <tt><a>SChar</a> c</tt>
--   value bringing an implicit <tt><a>KnownChar</a> c</tt> constraint into
--   scope:
--   
--   <pre>
--   f :: <a>SChar</a> c -&gt; ..
--   f SChar = {- KnownChar c in scope -}
--   </pre>
pattern SChar :: () => KnownChar c => SChar c

-- | Return the <a>Integer</a> corresponding to <tt>n</tt> in an
--   <tt><tt>SNat</tt> n</tt> value. The returned <a>Integer</a> is always
--   non-negative.
--   
--   For a version of this function that returns a <tt>Natural</tt> instead
--   of an <a>Integer</a>, see <a>fromSNat</a> in <a>GHC.TypeNats</a>.
fromSNat :: forall (n :: Nat). SNat n -> Integer

-- | Return the String corresponding to <tt>s</tt> in an <tt><a>SSymbol</a>
--   s</tt> value.
fromSSymbol :: forall (s :: Symbol). SSymbol s -> String

-- | Return the <a>Char</a> corresponding to <tt>c</tt> in an
--   <tt><a>SChar</a> c</tt> value.
fromSChar :: forall (c :: Char). SChar c -> Char

-- | Attempt to convert an <a>Integer</a> into an <tt><tt>SNat</tt> n</tt>
--   value, where <tt>n</tt> is a fresh type-level natural number. If the
--   <a>Integer</a> argument is non-negative, invoke the continuation with
--   <tt>Just sn</tt>, where <tt>sn</tt> is the <tt><tt>SNat</tt> n</tt>
--   value. If the <a>Integer</a> argument is negative, invoke the
--   continuation with <a>Nothing</a>.
--   
--   For a version of this function where the continuation uses
--   <tt>'SNat</tt> n<tt> instead of </tt><a>Maybe</a> (<tt>SNat</tt> n)@,
--   see <a>withSomeSNat</a> in <a>GHC.TypeNats</a>.
withSomeSNat :: Integer -> (forall (n :: Nat). () => Maybe (SNat n) -> r) -> r

-- | Convert a <a>String</a> into an <tt><a>SSymbol</a> s</tt> value, where
--   <tt>s</tt> is a fresh type-level symbol.
withSomeSSymbol :: String -> (forall (s :: Symbol). () => SSymbol s -> r) -> r

-- | Convert a <a>Char</a> into an <tt><a>SChar</a> c</tt> value, where
--   <tt>c</tt> is a fresh type-level character.
withSomeSChar :: Char -> (forall (c :: Char). () => SChar c -> r) -> r

-- | Convert an explicit <tt><a>SNat</a> n</tt> value into an implicit
--   <tt><a>KnownNat</a> n</tt> constraint.
withKnownNat :: forall (n :: Nat) r. SNat n -> (KnownNat n => r) -> r

-- | Convert an explicit <tt><a>SSymbol</a> s</tt> value into an implicit
--   <tt><a>KnownSymbol</a> s</tt> constraint.
withKnownSymbol :: forall (s :: Symbol) r. SSymbol s -> (KnownSymbol s => r) -> r

-- | Convert an explicit <tt><a>SChar</a> c</tt> value into an implicit
--   <tt><a>KnownChar</a> c</tt> constraint.
withKnownChar :: forall (c :: Char) r. SChar c -> (KnownChar c => r) -> r

-- | <a>unsafeWithSNatCo</a> allows uses of <tt>coerce</tt> in its argument
--   to see the real representation of <tt>SNat n</tt>, without undermining
--   the type-safety of <tt>coerce</tt> elsewhere in the module.
--   
--   See also the documentation for <a>UnsafeSNat</a>.
unsafeWithSNatCo :: ((forall (n :: Nat). () => Coercible (SNat n) Natural) => r) -> r

-- | <a>unsafeWithSSymbolCo</a> allows uses of <tt>coerce</tt> in its
--   argument to see the real representation of <tt>SSymbol s</tt>, without
--   undermining the type-safety of <tt>coerce</tt> elsewhere in the
--   module.
--   
--   See also the documentation for <a>UnsafeSSymbol</a>.
unsafeWithSSymbolCo :: ((forall (s :: Symbol). () => Coercible (SSymbol s) String) => r) -> r

-- | <a>unsafeWithSCharCo</a> allows uses of <tt>coerce</tt> in its
--   argument to see the real representation of <tt>SChar c</tt>, without
--   undermining the type-safety of <tt>coerce</tt> elsewhere in the
--   module.
--   
--   See also the documentation for <a>UnsafeSChar</a>.
unsafeWithSCharCo :: ((forall (c :: Char). () => Coercible (SChar c) Char) => r) -> r

-- | Comparison (&lt;=) of comparable types, as a constraint.
type (x :: t) <= (y :: t) = Assert x <=? y LeErrMsg x y :: Constraint
infix 4 <=

-- | Comparison (&lt;=) of comparable types, as a function.
type (m :: k) <=? (n :: k) = OrdCond Compare m n 'True 'True 'False
infix 4 <=?

-- | Addition of type-level naturals.
type family (a :: Natural) + (b :: Natural) :: Natural
infixl 6 +

-- | Multiplication of type-level naturals.
type family (a :: Natural) * (b :: Natural) :: Natural
infixl 7 *

-- | Exponentiation of type-level naturals.
type family (a :: Natural) ^ (b :: Natural) :: Natural
infixr 8 ^

-- | Subtraction of type-level naturals.
type family (a :: Natural) - (b :: Natural) :: Natural
infixl 6 -

-- | Division (round down) of natural numbers. <tt>Div x 0</tt> is
--   undefined (i.e., it cannot be reduced).
type family Div (a :: Natural) (b :: Natural) :: Natural
infixl 7 `Div`

-- | Modulus of natural numbers. <tt>Mod x 0</tt> is undefined (i.e., it
--   cannot be reduced).
type family Mod (a :: Natural) (b :: Natural) :: Natural
infixl 7 `Mod`

-- | Log base 2 (round down) of natural numbers. <tt>Log 0</tt> is
--   undefined (i.e., it cannot be reduced).
type family Log2 (a :: Natural) :: Natural

-- | Concatenation of type-level symbols.
type family AppendSymbol (a :: Symbol) (b :: Symbol) :: Symbol

-- | Comparison of type-level naturals, as a function.
type family CmpNat (a :: Natural) (b :: Natural) :: Ordering

-- | Comparison of type-level symbols, as a function.
type family CmpSymbol (a :: Symbol) (b :: Symbol) :: Ordering

-- | Comparison of type-level characters.
type family CmpChar (a :: Char) (b :: Char) :: Ordering

-- | Extending a type-level symbol with a type-level character
type family ConsSymbol (a :: Char) (b :: Symbol) :: Symbol

-- | This type family yields type-level <a>Just</a> storing the first
--   character of a symbol and its tail if it is defined and <a>Nothing</a>
--   otherwise.
type family UnconsSymbol (a :: Symbol) :: Maybe (Char, Symbol)

-- | Convert a character to its Unicode code point (cf. <a>ord</a>)
type family CharToNat (a :: Char) :: Natural

-- | Convert a Unicode code point to a character (cf. <a>chr</a>)
type family NatToChar (a :: Natural) :: Char

-- | The type-level equivalent of <a>error</a>.
--   
--   The polymorphic kind of this type allows it to be used in several
--   settings. For instance, it can be used as a constraint, e.g. to
--   provide a better error message for a non-existent instance,
--   
--   <pre>
--   -- in a context
--   instance TypeError (Text "Cannot <tt>Show</tt> functions." :$$:
--                       Text "Perhaps there is a missing argument?")
--         =&gt; Show (a -&gt; b) where
--       showsPrec = error "unreachable"
--   </pre>
--   
--   It can also be placed on the right-hand side of a type-level function
--   to provide an error for an invalid case,
--   
--   <pre>
--   type family ByteSize x where
--      ByteSize Word16   = 2
--      ByteSize Word8    = 1
--      ByteSize a        = TypeError (Text "The type " :&lt;&gt;: ShowType a :&lt;&gt;:
--                                     Text " is not exportable.")
--   </pre>
type family TypeError (a :: ErrorMessage) :: b

-- | A description of a custom type error.
data ErrorMessage

-- | Show the text as is.
Text :: Symbol -> ErrorMessage

-- | Pretty print the type. <tt>ShowType :: k -&gt; ErrorMessage</tt>
ShowType :: t -> ErrorMessage

-- | Put two pieces of error message next to each other.
(:<>:) :: ErrorMessage -> ErrorMessage -> ErrorMessage

-- | Stack two pieces of error message on top of each other.
(:$$:) :: ErrorMessage -> ErrorMessage -> ErrorMessage
infixl 6 :<>:
infixl 5 :$$:
instance GHC.Classes.Eq (GHC.Internal.TypeLits.SChar c)
instance GHC.Classes.Eq (GHC.Internal.TypeLits.SSymbol s)
instance GHC.Classes.Eq GHC.Internal.TypeLits.SomeChar
instance GHC.Classes.Eq GHC.Internal.TypeLits.SomeSymbol
instance GHC.Classes.Ord (GHC.Internal.TypeLits.SChar c)
instance GHC.Classes.Ord (GHC.Internal.TypeLits.SSymbol s)
instance GHC.Classes.Ord GHC.Internal.TypeLits.SomeChar
instance GHC.Classes.Ord GHC.Internal.TypeLits.SomeSymbol
instance GHC.Internal.Read.Read GHC.Internal.TypeLits.SomeChar
instance GHC.Internal.Read.Read GHC.Internal.TypeLits.SomeSymbol
instance GHC.Internal.Show.Show (GHC.Internal.TypeLits.SChar c)
instance GHC.Internal.Show.Show (GHC.Internal.TypeLits.SSymbol s)
instance GHC.Internal.Show.Show GHC.Internal.TypeLits.SomeChar
instance GHC.Internal.Show.Show GHC.Internal.TypeLits.SomeSymbol
instance GHC.Internal.Data.Type.Coercion.TestCoercion GHC.Internal.TypeLits.SChar
instance GHC.Internal.Data.Type.Coercion.TestCoercion GHC.Internal.TypeLits.SSymbol
instance GHC.Internal.Data.Type.Equality.TestEquality GHC.Internal.TypeLits.SChar
instance GHC.Internal.Data.Type.Equality.TestEquality GHC.Internal.TypeLits.SSymbol


-- | If you're using <tt>GHC.Generics</tt>, you should consider using the
--   <a>http://hackage.haskell.org/package/generic-deriving</a> package,
--   which contains many useful generic functions.
module GHC.Internal.Generics

-- | Void: used for datatypes without constructors
data V1 (p :: k)

-- | Unit: used for constructors without arguments
data U1 (p :: k)
U1 :: U1 (p :: k)

-- | Used for marking occurrences of the parameter
newtype Par1 p
Par1 :: p -> Par1 p
[unPar1] :: Par1 p -> p

-- | Recursive calls of kind <tt>* -&gt; *</tt> (or kind <tt>k -&gt;
--   *</tt>, when <tt>PolyKinds</tt> is enabled)
newtype Rec1 (f :: k -> Type) (p :: k)
Rec1 :: f p -> Rec1 (f :: k -> Type) (p :: k)
[unRec1] :: Rec1 (f :: k -> Type) (p :: k) -> f p

-- | Constants, additional parameters and recursion of kind <tt>*</tt>
newtype K1 i c (p :: k)
K1 :: c -> K1 i c (p :: k)
[unK1] :: K1 i c (p :: k) -> c

-- | Meta-information (constructor names, etc.)
newtype M1 i (c :: Meta) (f :: k -> Type) (p :: k)
M1 :: f p -> M1 i (c :: Meta) (f :: k -> Type) (p :: k)
[unM1] :: M1 i (c :: Meta) (f :: k -> Type) (p :: k) -> f p

-- | Sums: encode choice between constructors
data ( (f :: k -> Type) :+: (g :: k -> Type) ) (p :: k)
L1 :: f p -> (:+:) (f :: k -> Type) (g :: k -> Type) (p :: k)
R1 :: g p -> (:+:) (f :: k -> Type) (g :: k -> Type) (p :: k)
infixr 5 :+:

-- | Products: encode multiple arguments to constructors
data ( (f :: k -> Type) :*: (g :: k -> Type) ) (p :: k)
(:*:) :: f p -> g p -> (:*:) (f :: k -> Type) (g :: k -> Type) (p :: k)
infixr 6 :*:
infixr 6 :*:

-- | Composition of functors
newtype ( (f :: k2 -> Type) :.: (g :: k1 -> k2) ) (p :: k1)
Comp1 :: f (g p) -> (:.:) (f :: k2 -> Type) (g :: k1 -> k2) (p :: k1)
[unComp1] :: (:.:) (f :: k2 -> Type) (g :: k1 -> k2) (p :: k1) -> f (g p)
infixr 7 :.:

-- | Constants of unlifted kinds
data family URec a (p :: k)

-- | Type synonym for <tt><a>URec</a> <a>Addr#</a></tt>
type UAddr = URec Ptr () :: k -> Type

-- | Type synonym for <tt><a>URec</a> <a>Char#</a></tt>
type UChar = URec Char :: k -> Type

-- | Type synonym for <tt><a>URec</a> <a>Double#</a></tt>
type UDouble = URec Double :: k -> Type

-- | Type synonym for <tt><a>URec</a> <a>Float#</a></tt>
type UFloat = URec Float :: k -> Type

-- | Type synonym for <tt><a>URec</a> <a>Int#</a></tt>
type UInt = URec Int :: k -> Type

-- | Type synonym for <tt><a>URec</a> <a>Word#</a></tt>
type UWord = URec Word :: k -> Type

-- | Type synonym for encoding recursion (of kind <tt>Type</tt>)
type Rec0 = K1 R :: Type -> k -> Type

-- | Tag for K1: recursion (of kind <tt>Type</tt>)
data R

-- | Type synonym for encoding meta-information for datatypes
type D1 = M1 D :: Meta -> k -> Type -> k -> Type

-- | Type synonym for encoding meta-information for constructors
type C1 = M1 C :: Meta -> k -> Type -> k -> Type

-- | Type synonym for encoding meta-information for record selectors
type S1 = M1 S :: Meta -> k -> Type -> k -> Type

-- | Tag for M1: datatype
data D

-- | Tag for M1: constructor
data C

-- | Tag for M1: record selector
data S

-- | Class for datatypes that represent datatypes
class Datatype (d :: k)

-- | The name of the datatype (unqualified)
datatypeName :: forall k1 t (f :: k1 -> Type) (a :: k1). Datatype d => t d f a -> [Char]

-- | The fully-qualified name of the module where the type is declared
moduleName :: forall k1 t (f :: k1 -> Type) (a :: k1). Datatype d => t d f a -> [Char]

-- | The package name of the module where the type is declared
packageName :: forall k1 t (f :: k1 -> Type) (a :: k1). Datatype d => t d f a -> [Char]

-- | Marks if the datatype is actually a newtype
isNewtype :: forall k1 t (f :: k1 -> Type) (a :: k1). Datatype d => t d f a -> Bool

-- | Class for datatypes that represent data constructors
class Constructor (c :: k)

-- | The name of the constructor
conName :: forall k1 t (f :: k1 -> Type) (a :: k1). Constructor c => t c f a -> [Char]

-- | The fixity of the constructor
conFixity :: forall k1 t (f :: k1 -> Type) (a :: k1). Constructor c => t c f a -> Fixity

-- | Marks if this constructor is a record
conIsRecord :: forall k1 t (f :: k1 -> Type) (a :: k1). Constructor c => t c f a -> Bool

-- | Class for datatypes that represent records
class Selector (s :: k)

-- | The name of the selector
selName :: forall k1 t (f :: k1 -> Type) (a :: k1). Selector s => t s f a -> [Char]

-- | The selector's unpackedness annotation (if any)
selSourceUnpackedness :: forall k1 t (f :: k1 -> Type) (a :: k1). Selector s => t s f a -> SourceUnpackedness

-- | The selector's strictness annotation (if any)
selSourceStrictness :: forall k1 t (f :: k1 -> Type) (a :: k1). Selector s => t s f a -> SourceStrictness

-- | The strictness that the compiler inferred for the selector
selDecidedStrictness :: forall k1 t (f :: k1 -> Type) (a :: k1). Selector s => t s f a -> DecidedStrictness

-- | Datatype to represent the fixity of a constructor. An infix |
--   declaration directly corresponds to an application of <a>Infix</a>.
data Fixity
Prefix :: Fixity
Infix :: Associativity -> Int -> Fixity

-- | This variant of <a>Fixity</a> appears at the type level.
data FixityI
PrefixI :: FixityI
InfixI :: Associativity -> Nat -> FixityI

-- | Datatype to represent the associativity of a constructor
data Associativity
LeftAssociative :: Associativity
RightAssociative :: Associativity
NotAssociative :: Associativity

-- | Get the precedence of a fixity value.
prec :: Fixity -> Int

-- | The unpackedness of a field as the user wrote it in the source code.
--   For example, in the following data type:
--   
--   <pre>
--   data E = ExampleConstructor     Int
--              {-# NOUNPACK #-} Int
--              {-#   UNPACK #-} Int
--   </pre>
--   
--   The fields of <tt>ExampleConstructor</tt> have
--   <a>NoSourceUnpackedness</a>, <a>SourceNoUnpack</a>, and
--   <a>SourceUnpack</a>, respectively.
data SourceUnpackedness
NoSourceUnpackedness :: SourceUnpackedness
SourceNoUnpack :: SourceUnpackedness
SourceUnpack :: SourceUnpackedness

-- | The strictness of a field as the user wrote it in the source code. For
--   example, in the following data type:
--   
--   <pre>
--   data E = ExampleConstructor Int ~Int !Int
--   </pre>
--   
--   The fields of <tt>ExampleConstructor</tt> have
--   <a>NoSourceStrictness</a>, <a>SourceLazy</a>, and <a>SourceStrict</a>,
--   respectively.
data SourceStrictness
NoSourceStrictness :: SourceStrictness
SourceLazy :: SourceStrictness
SourceStrict :: SourceStrictness

-- | The strictness that GHC infers for a field during compilation. Whereas
--   there are nine different combinations of <a>SourceUnpackedness</a> and
--   <a>SourceStrictness</a>, the strictness that GHC decides will
--   ultimately be one of lazy, strict, or unpacked. What GHC decides is
--   affected both by what the user writes in the source code and by GHC
--   flags. As an example, consider this data type:
--   
--   <pre>
--   data E = ExampleConstructor {-# UNPACK #-} !Int !Int Int
--   </pre>
--   
--   <ul>
--   <li>If compiled without optimization or other language extensions,
--   then the fields of <tt>ExampleConstructor</tt> will have
--   <a>DecidedStrict</a>, <a>DecidedStrict</a>, and <a>DecidedLazy</a>,
--   respectively.</li>
--   <li>If compiled with <tt>-XStrictData</tt> enabled, then the fields
--   will have <a>DecidedStrict</a>, <a>DecidedStrict</a>, and
--   <a>DecidedStrict</a>, respectively.</li>
--   <li>If compiled with <tt>-O2</tt> enabled, then the fields will have
--   <a>DecidedUnpack</a>, <a>DecidedStrict</a>, and <a>DecidedLazy</a>,
--   respectively.</li>
--   </ul>
data DecidedStrictness
DecidedLazy :: DecidedStrictness
DecidedStrict :: DecidedStrictness
DecidedUnpack :: DecidedStrictness

-- | Datatype to represent metadata associated with a datatype
--   (<tt>MetaData</tt>), constructor (<tt>MetaCons</tt>), or field
--   selector (<tt>MetaSel</tt>).
--   
--   <ul>
--   <li>In <tt>MetaData n m p nt</tt>, <tt>n</tt> is the datatype's name,
--   <tt>m</tt> is the module in which the datatype is defined, <tt>p</tt>
--   is the package in which the datatype is defined, and <tt>nt</tt> is
--   <tt>'True</tt> if the datatype is a <tt>newtype</tt>.</li>
--   <li>In <tt>MetaCons n f s</tt>, <tt>n</tt> is the constructor's name,
--   <tt>f</tt> is its fixity, and <tt>s</tt> is <tt>'True</tt> if the
--   constructor contains record selectors.</li>
--   <li>In <tt>MetaSel mn su ss ds</tt>, if the field uses record syntax,
--   then <tt>mn</tt> is <a>Just</a> the record name. Otherwise,
--   <tt>mn</tt> is <a>Nothing</a>. <tt>su</tt> and <tt>ss</tt> are the
--   field's unpackedness and strictness annotations, and <tt>ds</tt> is
--   the strictness that GHC infers for the field.</li>
--   </ul>
data Meta
MetaData :: Symbol -> Symbol -> Symbol -> Bool -> Meta
MetaCons :: Symbol -> FixityI -> Bool -> Meta
MetaSel :: Maybe Symbol -> SourceUnpackedness -> SourceStrictness -> DecidedStrictness -> Meta

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class Generic a where {
    
    -- | Generic representation type
    type Rep a :: Type -> Type;
}

-- | Convert from the datatype to its representation
from :: Generic a => a -> Rep a x

-- | Convert from the representation to the datatype
to :: Generic a => Rep a x -> a

-- | Representable types of kind <tt>* -&gt; *</tt> (or kind <tt>k -&gt;
--   *</tt>, when <tt>PolyKinds</tt> is enabled). This class is derivable
--   in GHC with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic1</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from1</a> . <a>to1</a> ≡ <a>id</a>
--   <a>to1</a> . <a>from1</a> ≡ <a>id</a>
--   </pre>
class Generic1 (f :: k -> Type) where {
    
    -- | Generic representation type
    type Rep1 (f :: k -> Type) :: k -> Type;
}

-- | Convert from the datatype to its representation
from1 :: forall (a :: k). Generic1 f => f a -> Rep1 f a

-- | Convert from the representation to the datatype
to1 :: forall (a :: k). Generic1 f => Rep1 f a -> f a

-- | A datatype whose instances are defined generically, using the
--   <a>Generic</a> representation. <a>Generically1</a> is a higher-kinded
--   version of <a>Generically</a> that uses <a>Generic1</a>.
--   
--   Generic instances can be derived via <tt><a>Generically</a> A</tt>
--   using <tt>-XDerivingVia</tt>.
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric      #-}
--   {-# LANGUAGE DerivingStrategies #-}
--   {-# LANGUAGE DerivingVia        #-}
--   
--   import GHC.Generics (Generic)
--   
--   data V4 a = V4 a a a a
--     deriving stock Generic
--   
--     deriving (Semigroup, Monoid)
--     via Generically (V4 a)
--   </pre>
--   
--   This corresponds to <a>Semigroup</a> and <a>Monoid</a> instances
--   defined by pointwise lifting:
--   
--   <pre>
--   instance Semigroup a =&gt; Semigroup (V4 a) where
--     (&lt;&gt;) :: V4 a -&gt; V4 a -&gt; V4 a
--     V4 a1 b1 c1 d1 &lt;&gt; V4 a2 b2 c2 d2 =
--       V4 (a1 &lt;&gt; a2) (b1 &lt;&gt; b2) (c1 &lt;&gt; c2) (d1 &lt;&gt; d2)
--   
--   instance Monoid a =&gt; Monoid (V4 a) where
--     mempty :: V4 a
--     mempty = V4 mempty mempty mempty mempty
--   </pre>
--   
--   Historically this required modifying the type class to include generic
--   method definitions (<tt>-XDefaultSignatures</tt>) and deriving it with
--   the <tt>anyclass</tt> strategy (<tt>-XDeriveAnyClass</tt>). Having a
--   /via type/ like <a>Generically</a> decouples the instance from the
--   type class.
newtype Generically a
Generically :: a -> Generically a

-- | A type whose instances are defined generically, using the
--   <a>Generic1</a> representation. <a>Generically1</a> is a higher-kinded
--   version of <a>Generically</a> that uses <a>Generic</a>.
--   
--   Generic instances can be derived for type constructors via
--   <tt><a>Generically1</a> F</tt> using <tt>-XDerivingVia</tt>.
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric      #-}
--   {-# LANGUAGE DerivingStrategies #-}
--   {-# LANGUAGE DerivingVia        #-}
--   
--   import GHC.Generics (Generic)
--   
--   data V4 a = V4 a a a a
--     deriving stock (Functor, Generic1)
--   
--     deriving Applicative
--     via Generically1 V4
--   </pre>
--   
--   This corresponds to <a>Applicative</a> instances defined by pointwise
--   lifting:
--   
--   <pre>
--   instance Applicative V4 where
--     pure :: a -&gt; V4 a
--     pure a = V4 a a a a
--   
--     liftA2 :: (a -&gt; b -&gt; c) -&gt; (V4 a -&gt; V4 b -&gt; V4 c)
--     liftA2 (·) (V4 a1 b1 c1 d1) (V4 a2 b2 c2 d2) =
--       V4 (a1 · a2) (b1 · b2) (c1 · c2) (d1 · d2)
--   </pre>
--   
--   Historically this required modifying the type class to include generic
--   method definitions (<tt>-XDefaultSignatures</tt>) and deriving it with
--   the <tt>anyclass</tt> strategy (<tt>-XDeriveAnyClass</tt>). Having a
--   /via type/ like <a>Generically1</a> decouples the instance from the
--   type class.
newtype Generically1 (f :: k -> Type) (a :: k)
[Generically1] :: forall {k} (f :: k -> Type) (a :: k). f a -> Generically1 f a
instance (GHC.Internal.Base.Alternative f, GHC.Internal.Base.Alternative g) => GHC.Internal.Base.Alternative (f GHC.Internal.Generics.:*: g)
instance (GHC.Internal.Base.Alternative f, GHC.Internal.Base.Applicative g) => GHC.Internal.Base.Alternative (f GHC.Internal.Generics.:.: g)
instance (GHC.Internal.Generics.Generic1 f, GHC.Internal.Base.Alternative (GHC.Internal.Generics.Rep1 f)) => GHC.Internal.Base.Alternative (GHC.Internal.Generics.Generically1 f)
instance GHC.Internal.Base.Alternative f => GHC.Internal.Base.Alternative (GHC.Internal.Generics.M1 i c f)
instance GHC.Internal.Base.Alternative f => GHC.Internal.Base.Alternative (GHC.Internal.Generics.Rec1 f)
instance GHC.Internal.Base.Alternative GHC.Internal.Generics.U1
instance (GHC.Internal.Base.Applicative f, GHC.Internal.Base.Applicative g) => GHC.Internal.Base.Applicative (f GHC.Internal.Generics.:*: g)
instance (GHC.Internal.Base.Applicative f, GHC.Internal.Base.Applicative g) => GHC.Internal.Base.Applicative (f GHC.Internal.Generics.:.: g)
instance (GHC.Internal.Generics.Generic1 f, GHC.Internal.Base.Applicative (GHC.Internal.Generics.Rep1 f)) => GHC.Internal.Base.Applicative (GHC.Internal.Generics.Generically1 f)
instance GHC.Internal.Base.Monoid c => GHC.Internal.Base.Applicative (GHC.Internal.Generics.K1 i c)
instance GHC.Internal.Base.Applicative f => GHC.Internal.Base.Applicative (GHC.Internal.Generics.M1 i c f)
instance GHC.Internal.Base.Applicative GHC.Internal.Generics.Par1
instance GHC.Internal.Base.Applicative f => GHC.Internal.Base.Applicative (GHC.Internal.Generics.Rec1 f)
instance GHC.Internal.Base.Applicative GHC.Internal.Generics.U1
instance GHC.Internal.Enum.Bounded GHC.Internal.Generics.Associativity
instance GHC.Internal.Enum.Bounded GHC.Internal.Generics.DecidedStrictness
instance GHC.Internal.Enum.Bounded GHC.Internal.Generics.SourceStrictness
instance GHC.Internal.Enum.Bounded GHC.Internal.Generics.SourceUnpackedness
instance (GHC.Internal.TypeLits.KnownSymbol n, GHC.Internal.Generics.SingI f, GHC.Internal.Generics.SingI r) => GHC.Internal.Generics.Constructor ('GHC.Internal.Generics.MetaCons n f r)
instance (GHC.Internal.TypeLits.KnownSymbol n, GHC.Internal.TypeLits.KnownSymbol m, GHC.Internal.TypeLits.KnownSymbol p, GHC.Internal.Generics.SingI nt) => GHC.Internal.Generics.Datatype ('GHC.Internal.Generics.MetaData n m p nt)
instance GHC.Internal.Enum.Enum GHC.Internal.Generics.Associativity
instance GHC.Internal.Enum.Enum GHC.Internal.Generics.DecidedStrictness
instance GHC.Internal.Enum.Enum GHC.Internal.Generics.SourceStrictness
instance GHC.Internal.Enum.Enum GHC.Internal.Generics.SourceUnpackedness
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Eq (f p), GHC.Classes.Eq (g p)) => GHC.Classes.Eq ((GHC.Internal.Generics.:*:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Eq (f p), GHC.Classes.Eq (g p)) => GHC.Classes.Eq ((GHC.Internal.Generics.:+:) f g p)
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Classes.Eq (f (g p)) => GHC.Classes.Eq ((GHC.Internal.Generics.:.:) f g p)
instance GHC.Classes.Eq GHC.Internal.Generics.Associativity
instance GHC.Classes.Eq GHC.Internal.Generics.DecidedStrictness
instance GHC.Classes.Eq GHC.Internal.Generics.Fixity
instance forall k (f :: k -> *) (a :: k). (GHC.Internal.Generics.Generic1 f, GHC.Classes.Eq (GHC.Internal.Generics.Rep1 f a)) => GHC.Classes.Eq (GHC.Internal.Generics.Generically1 f a)
instance forall i c k (p :: k). GHC.Classes.Eq c => GHC.Classes.Eq (GHC.Internal.Generics.K1 i c p)
instance forall i (c :: GHC.Internal.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Classes.Eq (f p) => GHC.Classes.Eq (GHC.Internal.Generics.M1 i c f p)
instance GHC.Classes.Eq p => GHC.Classes.Eq (GHC.Internal.Generics.Par1 p)
instance forall k (f :: k -> *) (p :: k). GHC.Classes.Eq (f p) => GHC.Classes.Eq (GHC.Internal.Generics.Rec1 f p)
instance GHC.Classes.Eq GHC.Internal.Generics.SourceStrictness
instance GHC.Classes.Eq GHC.Internal.Generics.SourceUnpackedness
instance forall k (p :: k). GHC.Classes.Eq (GHC.Internal.Generics.U1 p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Internal.Generics.URec (GHC.Internal.Ptr.Ptr ()) p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Internal.Generics.URec GHC.Types.Char p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Internal.Generics.URec GHC.Types.Double p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Internal.Generics.URec GHC.Types.Float p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Internal.Generics.URec GHC.Types.Int p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Internal.Generics.URec GHC.Types.Word p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Internal.Generics.V1 p)
instance (GHC.Internal.Base.Functor f, GHC.Internal.Base.Functor g) => GHC.Internal.Base.Functor (f GHC.Internal.Generics.:*: g)
instance (GHC.Internal.Base.Functor f, GHC.Internal.Base.Functor g) => GHC.Internal.Base.Functor (f GHC.Internal.Generics.:+: g)
instance (GHC.Internal.Base.Functor f, GHC.Internal.Base.Functor g) => GHC.Internal.Base.Functor (f GHC.Internal.Generics.:.: g)
instance (GHC.Internal.Generics.Generic1 f, GHC.Internal.Base.Functor (GHC.Internal.Generics.Rep1 f)) => GHC.Internal.Base.Functor (GHC.Internal.Generics.Generically1 f)
instance GHC.Internal.Base.Functor (GHC.Internal.Generics.K1 i c)
instance GHC.Internal.Base.Functor f => GHC.Internal.Base.Functor (GHC.Internal.Generics.M1 i c f)
instance GHC.Internal.Base.Functor GHC.Internal.Generics.Par1
instance GHC.Internal.Base.Functor f => GHC.Internal.Base.Functor (GHC.Internal.Generics.Rec1 f)
instance GHC.Internal.Base.Functor GHC.Internal.Generics.U1
instance GHC.Internal.Base.Functor (GHC.Internal.Generics.URec (GHC.Internal.Ptr.Ptr ()))
instance GHC.Internal.Base.Functor (GHC.Internal.Generics.URec GHC.Types.Char)
instance GHC.Internal.Base.Functor (GHC.Internal.Generics.URec GHC.Types.Double)
instance GHC.Internal.Base.Functor (GHC.Internal.Generics.URec GHC.Types.Float)
instance GHC.Internal.Base.Functor (GHC.Internal.Generics.URec GHC.Types.Int)
instance GHC.Internal.Base.Functor (GHC.Internal.Generics.URec GHC.Types.Word)
instance GHC.Internal.Base.Functor GHC.Internal.Generics.V1
instance GHC.Internal.Generics.Generic1 GHC.Internal.Data.Ord.Down
instance GHC.Internal.Generics.Generic1 (GHC.Internal.Data.Either.Either a)
instance GHC.Internal.Generics.Generic1 []
instance GHC.Internal.Generics.Generic1 GHC.Internal.Maybe.Maybe
instance GHC.Internal.Generics.Generic1 GHC.Internal.Base.NonEmpty
instance GHC.Internal.Generics.Generic1 GHC.Internal.Generics.Par1
instance GHC.Internal.Generics.Generic1 GHC.Tuple.Solo
instance GHC.Internal.Generics.Generic1 ((,,,,,,,,,) a b c d e f g h i)
instance GHC.Internal.Generics.Generic1 ((,,,,,,,,,,) a b c d e f g h i j)
instance GHC.Internal.Generics.Generic1 ((,,,,,,,,,,,) a b c d e f g h i j k)
instance GHC.Internal.Generics.Generic1 ((,,,,,,,,,,,,) a b c d e f g h i j k l)
instance GHC.Internal.Generics.Generic1 ((,,,,,,,,,,,,,) a b c d e f g h i j k l m)
instance GHC.Internal.Generics.Generic1 ((,,,,,,,,,,,,,,) a b c d e f g h i j k l m n)
instance GHC.Internal.Generics.Generic1 ((,) a)
instance GHC.Internal.Generics.Generic1 ((,,) a b)
instance GHC.Internal.Generics.Generic1 ((,,,) a b c)
instance GHC.Internal.Generics.Generic1 ((,,,,) a b c d)
instance GHC.Internal.Generics.Generic1 ((,,,,,) a b c d e)
instance GHC.Internal.Generics.Generic1 ((,,,,,,) a b c d e f)
instance GHC.Internal.Generics.Generic1 ((,,,,,,,) a b c d e f g)
instance GHC.Internal.Generics.Generic1 ((,,,,,,,,) a b c d e f g h)
instance forall k (f :: k -> *) (g :: k -> *). GHC.Internal.Generics.Generic1 (f GHC.Internal.Generics.:*: g)
instance forall k (f :: k -> *) (g :: k -> *). GHC.Internal.Generics.Generic1 (f GHC.Internal.Generics.:+: g)
instance forall (f :: * -> *) k (g :: k -> *). GHC.Internal.Base.Functor f => GHC.Internal.Generics.Generic1 (f GHC.Internal.Generics.:.: g)
instance GHC.Internal.Generics.Generic1 (GHC.Internal.Generics.K1 i c)
instance forall i (c :: GHC.Internal.Generics.Meta) k (f :: k -> *). GHC.Internal.Generics.Generic1 (GHC.Internal.Generics.M1 i c f)
instance GHC.Internal.Generics.Generic1 GHC.Internal.Data.Proxy.Proxy
instance forall k (f :: k -> *). GHC.Internal.Generics.Generic1 (GHC.Internal.Generics.Rec1 f)
instance GHC.Internal.Generics.Generic1 GHC.Internal.Generics.U1
instance GHC.Internal.Generics.Generic1 (GHC.Internal.Generics.URec (GHC.Internal.Ptr.Ptr ()))
instance GHC.Internal.Generics.Generic1 (GHC.Internal.Generics.URec GHC.Types.Char)
instance GHC.Internal.Generics.Generic1 (GHC.Internal.Generics.URec GHC.Types.Double)
instance GHC.Internal.Generics.Generic1 (GHC.Internal.Generics.URec GHC.Types.Float)
instance GHC.Internal.Generics.Generic1 (GHC.Internal.Generics.URec GHC.Types.Int)
instance GHC.Internal.Generics.Generic1 (GHC.Internal.Generics.URec GHC.Types.Word)
instance GHC.Internal.Generics.Generic1 GHC.Internal.Generics.V1
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). GHC.Internal.Generics.Generic ((GHC.Internal.Generics.:*:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). GHC.Internal.Generics.Generic ((GHC.Internal.Generics.:+:) f g p)
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Internal.Generics.Generic ((GHC.Internal.Generics.:.:) f g p)
instance GHC.Internal.Generics.Generic GHC.Internal.Generics.Associativity
instance GHC.Internal.Generics.Generic GHC.Types.Bool
instance GHC.Internal.Generics.Generic GHC.Internal.Generics.DecidedStrictness
instance GHC.Internal.Generics.Generic (GHC.Internal.Data.Ord.Down a)
instance GHC.Internal.Generics.Generic (GHC.Internal.Data.Either.Either a b)
instance GHC.Internal.Generics.Generic GHC.Internal.Fingerprint.Type.Fingerprint
instance GHC.Internal.Generics.Generic GHC.Internal.Generics.Fixity
instance GHC.Internal.Generics.Generic GHC.Internal.Unicode.GeneralCategory
instance forall i c k (p :: k). GHC.Internal.Generics.Generic (GHC.Internal.Generics.K1 i c p)
instance GHC.Internal.Generics.Generic [a]
instance forall i (c :: GHC.Internal.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Internal.Generics.Generic (GHC.Internal.Generics.M1 i c f p)
instance GHC.Internal.Generics.Generic (GHC.Internal.Maybe.Maybe a)
instance GHC.Internal.Generics.Generic (GHC.Internal.Base.NonEmpty a)
instance GHC.Internal.Generics.Generic GHC.Types.Ordering
instance GHC.Internal.Generics.Generic (GHC.Internal.Generics.Par1 p)
instance forall k (t :: k). GHC.Internal.Generics.Generic (GHC.Internal.Data.Proxy.Proxy t)
instance forall k (f :: k -> *) (p :: k). GHC.Internal.Generics.Generic (GHC.Internal.Generics.Rec1 f p)
instance GHC.Internal.Generics.Generic (GHC.Tuple.Solo a)
instance GHC.Internal.Generics.Generic GHC.Internal.Generics.SourceStrictness
instance GHC.Internal.Generics.Generic GHC.Internal.Generics.SourceUnpackedness
instance GHC.Internal.Generics.Generic GHC.Internal.Stack.Types.SrcLoc
instance GHC.Internal.Generics.Generic (a, b, c, d, e, f, g, h, i, j)
instance GHC.Internal.Generics.Generic (a, b, c, d, e, f, g, h, i, j, k)
instance GHC.Internal.Generics.Generic (a, b, c, d, e, f, g, h, i, j, k, l)
instance GHC.Internal.Generics.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance GHC.Internal.Generics.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance GHC.Internal.Generics.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance GHC.Internal.Generics.Generic (a, b)
instance GHC.Internal.Generics.Generic (a, b, c)
instance GHC.Internal.Generics.Generic (a, b, c, d)
instance GHC.Internal.Generics.Generic (a, b, c, d, e)
instance GHC.Internal.Generics.Generic (a, b, c, d, e, f)
instance GHC.Internal.Generics.Generic (a, b, c, d, e, f, g)
instance GHC.Internal.Generics.Generic (a, b, c, d, e, f, g, h)
instance GHC.Internal.Generics.Generic (a, b, c, d, e, f, g, h, i)
instance forall k (p :: k). GHC.Internal.Generics.Generic (GHC.Internal.Generics.U1 p)
instance forall k (p :: k). GHC.Internal.Generics.Generic (GHC.Internal.Generics.URec (GHC.Internal.Ptr.Ptr ()) p)
instance forall k (p :: k). GHC.Internal.Generics.Generic (GHC.Internal.Generics.URec GHC.Types.Char p)
instance forall k (p :: k). GHC.Internal.Generics.Generic (GHC.Internal.Generics.URec GHC.Types.Double p)
instance forall k (p :: k). GHC.Internal.Generics.Generic (GHC.Internal.Generics.URec GHC.Types.Float p)
instance forall k (p :: k). GHC.Internal.Generics.Generic (GHC.Internal.Generics.URec GHC.Types.Int p)
instance forall k (p :: k). GHC.Internal.Generics.Generic (GHC.Internal.Generics.URec GHC.Types.Word p)
instance GHC.Internal.Generics.Generic ()
instance forall k (p :: k). GHC.Internal.Generics.Generic (GHC.Internal.Generics.V1 p)
instance GHC.Internal.Generics.Generic GHC.Internal.Base.Void
instance GHC.Internal.Ix.Ix GHC.Internal.Generics.Associativity
instance GHC.Internal.Ix.Ix GHC.Internal.Generics.DecidedStrictness
instance GHC.Internal.Ix.Ix GHC.Internal.Generics.SourceStrictness
instance GHC.Internal.Ix.Ix GHC.Internal.Generics.SourceUnpackedness
instance (GHC.Internal.Base.MonadPlus f, GHC.Internal.Base.MonadPlus g) => GHC.Internal.Base.MonadPlus (f GHC.Internal.Generics.:*: g)
instance GHC.Internal.Base.MonadPlus f => GHC.Internal.Base.MonadPlus (GHC.Internal.Generics.M1 i c f)
instance GHC.Internal.Base.MonadPlus f => GHC.Internal.Base.MonadPlus (GHC.Internal.Generics.Rec1 f)
instance GHC.Internal.Base.MonadPlus GHC.Internal.Generics.U1
instance (GHC.Internal.Base.Monad f, GHC.Internal.Base.Monad g) => GHC.Internal.Base.Monad (f GHC.Internal.Generics.:*: g)
instance GHC.Internal.Base.Monad f => GHC.Internal.Base.Monad (GHC.Internal.Generics.M1 i c f)
instance GHC.Internal.Base.Monad GHC.Internal.Generics.Par1
instance GHC.Internal.Base.Monad f => GHC.Internal.Base.Monad (GHC.Internal.Generics.Rec1 f)
instance GHC.Internal.Base.Monad GHC.Internal.Generics.U1
instance forall k (f :: k -> *) (p :: k) (g :: k -> *). (GHC.Internal.Base.Monoid (f p), GHC.Internal.Base.Monoid (g p)) => GHC.Internal.Base.Monoid ((GHC.Internal.Generics.:*:) f g p)
instance forall k2 k1 (f :: k2 -> *) (g :: k1 -> k2) (p :: k1). GHC.Internal.Base.Monoid (f (g p)) => GHC.Internal.Base.Monoid ((GHC.Internal.Generics.:.:) f g p)
instance (GHC.Internal.Generics.Generic a, GHC.Internal.Base.Monoid (GHC.Internal.Generics.Rep a ())) => GHC.Internal.Base.Monoid (GHC.Internal.Generics.Generically a)
instance forall k c i (p :: k). GHC.Internal.Base.Monoid c => GHC.Internal.Base.Monoid (GHC.Internal.Generics.K1 i c p)
instance forall k (f :: k -> *) (p :: k) i (c :: GHC.Internal.Generics.Meta). GHC.Internal.Base.Monoid (f p) => GHC.Internal.Base.Monoid (GHC.Internal.Generics.M1 i c f p)
instance GHC.Internal.Base.Monoid p => GHC.Internal.Base.Monoid (GHC.Internal.Generics.Par1 p)
instance forall k (f :: k -> *) (p :: k). GHC.Internal.Base.Monoid (f p) => GHC.Internal.Base.Monoid (GHC.Internal.Generics.Rec1 f p)
instance forall k (p :: k). GHC.Internal.Base.Monoid (GHC.Internal.Generics.U1 p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Ord (f p), GHC.Classes.Ord (g p)) => GHC.Classes.Ord ((GHC.Internal.Generics.:*:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Ord (f p), GHC.Classes.Ord (g p)) => GHC.Classes.Ord ((GHC.Internal.Generics.:+:) f g p)
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Classes.Ord (f (g p)) => GHC.Classes.Ord ((GHC.Internal.Generics.:.:) f g p)
instance GHC.Classes.Ord GHC.Internal.Generics.Associativity
instance GHC.Classes.Ord GHC.Internal.Generics.DecidedStrictness
instance GHC.Classes.Ord GHC.Internal.Generics.Fixity
instance forall k (f :: k -> *) (a :: k). (GHC.Internal.Generics.Generic1 f, GHC.Classes.Ord (GHC.Internal.Generics.Rep1 f a)) => GHC.Classes.Ord (GHC.Internal.Generics.Generically1 f a)
instance forall i c k (p :: k). GHC.Classes.Ord c => GHC.Classes.Ord (GHC.Internal.Generics.K1 i c p)
instance forall i (c :: GHC.Internal.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Classes.Ord (f p) => GHC.Classes.Ord (GHC.Internal.Generics.M1 i c f p)
instance GHC.Classes.Ord p => GHC.Classes.Ord (GHC.Internal.Generics.Par1 p)
instance forall k (f :: k -> *) (p :: k). GHC.Classes.Ord (f p) => GHC.Classes.Ord (GHC.Internal.Generics.Rec1 f p)
instance GHC.Classes.Ord GHC.Internal.Generics.SourceStrictness
instance GHC.Classes.Ord GHC.Internal.Generics.SourceUnpackedness
instance forall k (p :: k). GHC.Classes.Ord (GHC.Internal.Generics.U1 p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Internal.Generics.URec (GHC.Internal.Ptr.Ptr ()) p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Internal.Generics.URec GHC.Types.Char p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Internal.Generics.URec GHC.Types.Double p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Internal.Generics.URec GHC.Types.Float p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Internal.Generics.URec GHC.Types.Int p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Internal.Generics.URec GHC.Types.Word p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Internal.Generics.V1 p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Internal.Read.Read (f p), GHC.Internal.Read.Read (g p)) => GHC.Internal.Read.Read ((GHC.Internal.Generics.:*:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Internal.Read.Read (f p), GHC.Internal.Read.Read (g p)) => GHC.Internal.Read.Read ((GHC.Internal.Generics.:+:) f g p)
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Internal.Read.Read (f (g p)) => GHC.Internal.Read.Read ((GHC.Internal.Generics.:.:) f g p)
instance GHC.Internal.Read.Read GHC.Internal.Generics.Associativity
instance GHC.Internal.Read.Read GHC.Internal.Generics.DecidedStrictness
instance GHC.Internal.Read.Read GHC.Internal.Generics.Fixity
instance forall i c k (p :: k). GHC.Internal.Read.Read c => GHC.Internal.Read.Read (GHC.Internal.Generics.K1 i c p)
instance forall i (c :: GHC.Internal.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Internal.Read.Read (f p) => GHC.Internal.Read.Read (GHC.Internal.Generics.M1 i c f p)
instance GHC.Internal.Read.Read p => GHC.Internal.Read.Read (GHC.Internal.Generics.Par1 p)
instance forall k (f :: k -> *) (p :: k). GHC.Internal.Read.Read (f p) => GHC.Internal.Read.Read (GHC.Internal.Generics.Rec1 f p)
instance GHC.Internal.Read.Read GHC.Internal.Generics.SourceStrictness
instance GHC.Internal.Read.Read GHC.Internal.Generics.SourceUnpackedness
instance forall k (p :: k). GHC.Internal.Read.Read (GHC.Internal.Generics.U1 p)
instance forall k (p :: k). GHC.Internal.Read.Read (GHC.Internal.Generics.V1 p)
instance (GHC.Internal.Generics.SingI mn, GHC.Internal.Generics.SingI su, GHC.Internal.Generics.SingI ss, GHC.Internal.Generics.SingI ds) => GHC.Internal.Generics.Selector ('GHC.Internal.Generics.MetaSel mn su ss ds)
instance forall k (f :: k -> *) (p :: k) (g :: k -> *). (GHC.Internal.Base.Semigroup (f p), GHC.Internal.Base.Semigroup (g p)) => GHC.Internal.Base.Semigroup ((GHC.Internal.Generics.:*:) f g p)
instance forall k2 k1 (f :: k2 -> *) (g :: k1 -> k2) (p :: k1). GHC.Internal.Base.Semigroup (f (g p)) => GHC.Internal.Base.Semigroup ((GHC.Internal.Generics.:.:) f g p)
instance (GHC.Internal.Generics.Generic a, GHC.Internal.Base.Semigroup (GHC.Internal.Generics.Rep a ())) => GHC.Internal.Base.Semigroup (GHC.Internal.Generics.Generically a)
instance forall k c i (p :: k). GHC.Internal.Base.Semigroup c => GHC.Internal.Base.Semigroup (GHC.Internal.Generics.K1 i c p)
instance forall k (f :: k -> *) (p :: k) i (c :: GHC.Internal.Generics.Meta). GHC.Internal.Base.Semigroup (f p) => GHC.Internal.Base.Semigroup (GHC.Internal.Generics.M1 i c f p)
instance GHC.Internal.Base.Semigroup p => GHC.Internal.Base.Semigroup (GHC.Internal.Generics.Par1 p)
instance forall k (f :: k -> *) (p :: k). GHC.Internal.Base.Semigroup (f p) => GHC.Internal.Base.Semigroup (GHC.Internal.Generics.Rec1 f p)
instance forall k (p :: k). GHC.Internal.Base.Semigroup (GHC.Internal.Generics.U1 p)
instance forall k (p :: k). GHC.Internal.Base.Semigroup (GHC.Internal.Generics.V1 p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Internal.Show.Show (f p), GHC.Internal.Show.Show (g p)) => GHC.Internal.Show.Show ((GHC.Internal.Generics.:*:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Internal.Show.Show (f p), GHC.Internal.Show.Show (g p)) => GHC.Internal.Show.Show ((GHC.Internal.Generics.:+:) f g p)
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Internal.Show.Show (f (g p)) => GHC.Internal.Show.Show ((GHC.Internal.Generics.:.:) f g p)
instance GHC.Internal.Show.Show GHC.Internal.Generics.Associativity
instance GHC.Internal.Show.Show GHC.Internal.Generics.DecidedStrictness
instance GHC.Internal.Show.Show GHC.Internal.Generics.Fixity
instance forall i c k (p :: k). GHC.Internal.Show.Show c => GHC.Internal.Show.Show (GHC.Internal.Generics.K1 i c p)
instance forall i (c :: GHC.Internal.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Internal.Show.Show (f p) => GHC.Internal.Show.Show (GHC.Internal.Generics.M1 i c f p)
instance GHC.Internal.Show.Show p => GHC.Internal.Show.Show (GHC.Internal.Generics.Par1 p)
instance forall k (f :: k -> *) (p :: k). GHC.Internal.Show.Show (f p) => GHC.Internal.Show.Show (GHC.Internal.Generics.Rec1 f p)
instance GHC.Internal.Show.Show GHC.Internal.Generics.SourceStrictness
instance GHC.Internal.Show.Show GHC.Internal.Generics.SourceUnpackedness
instance forall k (p :: k). GHC.Internal.Show.Show (GHC.Internal.Generics.U1 p)
instance forall k (p :: k). GHC.Internal.Show.Show (GHC.Internal.Generics.URec GHC.Types.Char p)
instance forall k (p :: k). GHC.Internal.Show.Show (GHC.Internal.Generics.URec GHC.Types.Double p)
instance forall k (p :: k). GHC.Internal.Show.Show (GHC.Internal.Generics.URec GHC.Types.Float p)
instance forall k (p :: k). GHC.Internal.Show.Show (GHC.Internal.Generics.URec GHC.Types.Int p)
instance forall k (p :: k). GHC.Internal.Show.Show (GHC.Internal.Generics.URec GHC.Types.Word p)
instance forall k (p :: k). GHC.Internal.Show.Show (GHC.Internal.Generics.UAddr p)
instance forall k (p :: k). GHC.Internal.Show.Show (GHC.Internal.Generics.V1 p)
instance GHC.Internal.Generics.SingI 'GHC.Internal.Generics.LeftAssociative
instance GHC.Internal.Generics.SingI 'GHC.Internal.Generics.NotAssociative
instance GHC.Internal.Generics.SingI 'GHC.Internal.Generics.RightAssociative
instance GHC.Internal.Generics.SingI 'GHC.Types.False
instance GHC.Internal.Generics.SingI 'GHC.Types.True
instance GHC.Internal.Generics.SingI 'GHC.Internal.Generics.DecidedLazy
instance GHC.Internal.Generics.SingI 'GHC.Internal.Generics.DecidedStrict
instance GHC.Internal.Generics.SingI 'GHC.Internal.Generics.DecidedUnpack
instance (GHC.Internal.Generics.SingI a, GHC.Internal.TypeNats.KnownNat n) => GHC.Internal.Generics.SingI ('GHC.Internal.Generics.InfixI a n)
instance GHC.Internal.Generics.SingI 'GHC.Internal.Generics.PrefixI
instance forall a1 (a2 :: a1). GHC.Internal.Generics.SingI a2 => GHC.Internal.Generics.SingI ('GHC.Internal.Maybe.Just a2)
instance GHC.Internal.Generics.SingI 'GHC.Internal.Maybe.Nothing
instance GHC.Internal.Generics.SingI 'GHC.Internal.Generics.NoSourceStrictness
instance GHC.Internal.Generics.SingI 'GHC.Internal.Generics.SourceLazy
instance GHC.Internal.Generics.SingI 'GHC.Internal.Generics.SourceStrict
instance GHC.Internal.Generics.SingI 'GHC.Internal.Generics.NoSourceUnpackedness
instance GHC.Internal.Generics.SingI 'GHC.Internal.Generics.SourceNoUnpack
instance GHC.Internal.Generics.SingI 'GHC.Internal.Generics.SourceUnpack
instance GHC.Internal.TypeLits.KnownSymbol a => GHC.Internal.Generics.SingI a
instance GHC.Internal.Generics.SingKind GHC.Internal.Generics.Associativity
instance GHC.Internal.Generics.SingKind GHC.Types.Bool
instance GHC.Internal.Generics.SingKind GHC.Internal.Generics.DecidedStrictness
instance GHC.Internal.Generics.SingKind GHC.Internal.Generics.FixityI
instance GHC.Internal.Generics.SingKind a => GHC.Internal.Generics.SingKind (GHC.Internal.Maybe.Maybe a)
instance GHC.Internal.Generics.SingKind GHC.Internal.Generics.SourceStrictness
instance GHC.Internal.Generics.SingKind GHC.Internal.Generics.SourceUnpackedness
instance GHC.Internal.Generics.SingKind GHC.Types.Symbol


-- | A data type defining the language extensions supported by GHC.
module GHC.Internal.LanguageExtensions

-- | The language extensions known to GHC.
--   
--   Note that there is an orphan <tt>Binary</tt> instance for this type
--   supplied by the <a>GHC.LanguageExtensions</a> module provided by
--   <tt>ghc-boot</tt>. We can't provide here as this would require adding
--   transitive dependencies to the <tt>template-haskell</tt> package,
--   which must have a minimal dependency set.
data Extension
Cpp :: Extension
OverlappingInstances :: Extension
UndecidableInstances :: Extension
IncoherentInstances :: Extension
UndecidableSuperClasses :: Extension
MonomorphismRestriction :: Extension
MonoLocalBinds :: Extension
DeepSubsumption :: Extension
RelaxedPolyRec :: Extension
ExtendedDefaultRules :: Extension
NamedDefaults :: Extension
ForeignFunctionInterface :: Extension
UnliftedFFITypes :: Extension
InterruptibleFFI :: Extension
CApiFFI :: Extension
GHCForeignImportPrim :: Extension
JavaScriptFFI :: Extension
ParallelArrays :: Extension
Arrows :: Extension
TemplateHaskell :: Extension
TemplateHaskellQuotes :: Extension
QualifiedDo :: Extension
QuasiQuotes :: Extension
ImplicitParams :: Extension
ImplicitPrelude :: Extension
ScopedTypeVariables :: Extension
AllowAmbiguousTypes :: Extension
UnboxedTuples :: Extension
UnboxedSums :: Extension
UnliftedNewtypes :: Extension
UnliftedDatatypes :: Extension
BangPatterns :: Extension
TypeFamilies :: Extension
TypeFamilyDependencies :: Extension
TypeInType :: Extension
OverloadedStrings :: Extension
OverloadedLists :: Extension
NumDecimals :: Extension
DisambiguateRecordFields :: Extension
RecordWildCards :: Extension
NamedFieldPuns :: Extension
ViewPatterns :: Extension
OrPatterns :: Extension
GADTs :: Extension
GADTSyntax :: Extension
NPlusKPatterns :: Extension
DoAndIfThenElse :: Extension
BlockArguments :: Extension
RebindableSyntax :: Extension
ConstraintKinds :: Extension
PolyKinds :: Extension
DataKinds :: Extension
TypeData :: Extension
InstanceSigs :: Extension
ApplicativeDo :: Extension
LinearTypes :: Extension
RequiredTypeArguments :: Extension
StandaloneDeriving :: Extension
DeriveDataTypeable :: Extension
AutoDeriveTypeable :: Extension
DeriveFunctor :: Extension
DeriveTraversable :: Extension
DeriveFoldable :: Extension
DeriveGeneric :: Extension
DefaultSignatures :: Extension
DeriveAnyClass :: Extension
DeriveLift :: Extension
DerivingStrategies :: Extension
DerivingVia :: Extension
TypeSynonymInstances :: Extension
FlexibleContexts :: Extension
FlexibleInstances :: Extension
ConstrainedClassMethods :: Extension
MultiParamTypeClasses :: Extension
NullaryTypeClasses :: Extension
FunctionalDependencies :: Extension
UnicodeSyntax :: Extension
ExistentialQuantification :: Extension
MagicHash :: Extension
EmptyDataDecls :: Extension
KindSignatures :: Extension
RoleAnnotations :: Extension
ParallelListComp :: Extension
TransformListComp :: Extension
MonadComprehensions :: Extension
GeneralizedNewtypeDeriving :: Extension
RecursiveDo :: Extension
PostfixOperators :: Extension
TupleSections :: Extension
PatternGuards :: Extension
LiberalTypeSynonyms :: Extension
RankNTypes :: Extension
ImpredicativeTypes :: Extension
TypeOperators :: Extension
ExplicitNamespaces :: Extension
PackageImports :: Extension
ExplicitForAll :: Extension
AlternativeLayoutRule :: Extension
AlternativeLayoutRuleTransitional :: Extension
DatatypeContexts :: Extension
NondecreasingIndentation :: Extension
RelaxedLayout :: Extension
TraditionalRecordSyntax :: Extension
LambdaCase :: Extension
MultiWayIf :: Extension
BinaryLiterals :: Extension
NegativeLiterals :: Extension
HexFloatLiterals :: Extension
DuplicateRecordFields :: Extension
OverloadedLabels :: Extension
EmptyCase :: Extension
PatternSynonyms :: Extension
PartialTypeSignatures :: Extension
NamedWildCards :: Extension
StaticPointers :: Extension
TypeApplications :: Extension
Strict :: Extension
StrictData :: Extension
EmptyDataDeriving :: Extension
NumericUnderscores :: Extension
QuantifiedConstraints :: Extension
StarIsType :: Extension
ImportQualifiedPost :: Extension
CUSKs :: Extension
StandaloneKindSignatures :: Extension
LexicalNegation :: Extension
FieldSelectors :: Extension
OverloadedRecordDot :: Extension
OverloadedRecordUpdate :: Extension
TypeAbstractions :: Extension
ExtendedLiterals :: Extension
ListTuplePuns :: Extension
MultilineStrings :: Extension
instance GHC.Internal.Enum.Bounded GHC.Internal.LanguageExtensions.Extension
instance GHC.Internal.Enum.Enum GHC.Internal.LanguageExtensions.Extension
instance GHC.Classes.Eq GHC.Internal.LanguageExtensions.Extension
instance GHC.Internal.Generics.Generic GHC.Internal.LanguageExtensions.Extension
instance GHC.Classes.Ord GHC.Internal.LanguageExtensions.Extension
instance GHC.Internal.Show.Show GHC.Internal.LanguageExtensions.Extension

module GHC.Internal.ForeignSrcLang

-- | Foreign formats supported by GHC via TH
data ForeignSrcLang

-- | C
LangC :: ForeignSrcLang

-- | C++
LangCxx :: ForeignSrcLang

-- | Objective C
LangObjc :: ForeignSrcLang

-- | Objective C++
LangObjcxx :: ForeignSrcLang

-- | Assembly language (.s)
LangAsm :: ForeignSrcLang

-- | JavaScript
LangJs :: ForeignSrcLang

-- | Object (.o)
RawObject :: ForeignSrcLang
instance GHC.Classes.Eq GHC.Internal.ForeignSrcLang.ForeignSrcLang
instance GHC.Internal.Generics.Generic GHC.Internal.ForeignSrcLang.ForeignSrcLang
instance GHC.Internal.Show.Show GHC.Internal.ForeignSrcLang.ForeignSrcLang


-- | Auxiliary definitions for <a>Semigroup</a>
--   
--   This module provides some <tt>newtype</tt> wrappers and helpers which
--   are reexported from the <a>Data.Semigroup</a> module or imported
--   directly by some other modules.
--   
--   This module also provides internal definitions related to the
--   <a>Semigroup</a> class some.
--   
--   This module exists mostly to simplify or workaround import-graph
--   issues.
module GHC.Internal.Data.Semigroup.Internal

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Semigroup</a>.
--   
--   When <tt>x &lt;&gt; x = x</tt>, this definition should be preferred,
--   because it works in &lt;math&gt; rather than &lt;math&gt;.
stimesIdempotent :: Integral b => b -> a -> a

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Monoid</a>.
--   
--   When <tt>x &lt;&gt; x = x</tt>, this definition should be preferred,
--   because it works in &lt;math&gt; rather than &lt;math&gt;
stimesIdempotentMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | This is a valid definition of <a>stimes</a> for a <a>Monoid</a>.
--   
--   Unlike the default definition of <a>stimes</a>, it is defined for 0
--   and so it should be preferred where possible.
stimesMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | The dual of a <a>Monoid</a>, obtained by swapping the arguments of
--   <a>(&lt;&gt;)</a>.
--   
--   <pre>
--   Dual a &lt;&gt; Dual b == Dual (b &lt;&gt; a)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Dual "Hello" &lt;&gt; Dual "World"
--   Dual {getDual = "WorldHello"}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Dual (Dual "Hello") &lt;&gt; Dual (Dual "World")
--   Dual {getDual = Dual {getDual = "HelloWorld"}}
--   </pre>
newtype Dual a
Dual :: a -> Dual a
[getDual] :: Dual a -> a

-- | The monoid of endomorphisms under composition.
--   
--   <pre>
--   Endo f &lt;&gt; Endo g == Endo (f . g)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo ("Hello, " ++) &lt;&gt; Endo (++ "!")
--   
--   &gt;&gt;&gt; appEndo computation "Haskell"
--   "Hello, Haskell!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo (*3) &lt;&gt; Endo (+1)
--   
--   &gt;&gt;&gt; appEndo computation 1
--   6
--   </pre>
newtype Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a
stimesEndoError :: a

-- | Boolean monoid under conjunction <a>(&amp;&amp;)</a>.
--   
--   <pre>
--   All x &lt;&gt; All y = All (x &amp;&amp; y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; All True &lt;&gt; mempty &lt;&gt; All False)
--   All {getAll = False}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat (map (\x -&gt; All (even x)) [2,4,6,7,8])
--   All {getAll = False}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; All True &lt;&gt; mempty
--   All {getAll = True}
--   </pre>
newtype All
All :: Bool -> All
[getAll] :: All -> Bool

-- | Boolean monoid under disjunction <a>(||)</a>.
--   
--   <pre>
--   Any x &lt;&gt; Any y = Any (x || y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Any True &lt;&gt; mempty &lt;&gt; Any False
--   Any {getAny = True}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat (map (\x -&gt; Any (even x)) [2,4,6,7,8])
--   Any {getAny = True}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Any False &lt;&gt; mempty
--   Any {getAny = False}
--   </pre>
newtype Any
Any :: Bool -> Any
[getAny] :: Any -> Bool

-- | Monoid under addition.
--   
--   <pre>
--   Sum a &lt;&gt; Sum b = Sum (a + b)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Sum 1 &lt;&gt; Sum 2 &lt;&gt; mempty
--   Sum {getSum = 3}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat [ Sum n | n &lt;- [3 .. 9]]
--   Sum {getSum = 42}
--   </pre>
newtype Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Monoid under multiplication.
--   
--   <pre>
--   Product x &lt;&gt; Product y == Product (x * y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Product 3 &lt;&gt; Product 4 &lt;&gt; mempty
--   Product {getProduct = 12}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat [ Product n | n &lt;- [2 .. 10]]
--   Product {getProduct = 3628800}
--   </pre>
newtype Product a
Product :: a -> Product a
[getProduct] :: Product a -> a

-- | Monoid under <a>&lt;|&gt;</a>.
--   
--   <pre>
--   Alt l &lt;&gt; Alt r == Alt (l &lt;|&gt; r)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Alt (Just 12) &lt;&gt; Alt (Just 24)
--   Alt {getAlt = Just 12}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Alt Nothing &lt;&gt; Alt (Just 24)
--   Alt {getAlt = Just 24}
--   </pre>
newtype Alt (f :: k -> Type) (a :: k)
Alt :: f a -> Alt (f :: k -> Type) (a :: k)
[getAlt] :: Alt (f :: k -> Type) (a :: k) -> f a
instance GHC.Internal.Base.Alternative f => GHC.Internal.Base.Alternative (GHC.Internal.Data.Semigroup.Internal.Alt f)
instance GHC.Internal.Base.Applicative f => GHC.Internal.Base.Applicative (GHC.Internal.Data.Semigroup.Internal.Alt f)
instance GHC.Internal.Base.Applicative GHC.Internal.Data.Semigroup.Internal.Dual
instance GHC.Internal.Base.Applicative GHC.Internal.Data.Semigroup.Internal.Product
instance GHC.Internal.Base.Applicative GHC.Internal.Data.Semigroup.Internal.Sum
instance GHC.Internal.Enum.Bounded GHC.Internal.Data.Semigroup.Internal.All
instance GHC.Internal.Enum.Bounded GHC.Internal.Data.Semigroup.Internal.Any
instance GHC.Internal.Enum.Bounded a => GHC.Internal.Enum.Bounded (GHC.Internal.Data.Semigroup.Internal.Dual a)
instance GHC.Internal.Enum.Bounded a => GHC.Internal.Enum.Bounded (GHC.Internal.Data.Semigroup.Internal.Product a)
instance GHC.Internal.Enum.Bounded a => GHC.Internal.Enum.Bounded (GHC.Internal.Data.Semigroup.Internal.Sum a)
instance forall k (f :: k -> *) (a :: k). GHC.Internal.Enum.Enum (f a) => GHC.Internal.Enum.Enum (GHC.Internal.Data.Semigroup.Internal.Alt f a)
instance GHC.Classes.Eq GHC.Internal.Data.Semigroup.Internal.All
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (GHC.Internal.Data.Semigroup.Internal.Alt f a)
instance GHC.Classes.Eq GHC.Internal.Data.Semigroup.Internal.Any
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Internal.Data.Semigroup.Internal.Dual a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Internal.Data.Semigroup.Internal.Product a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Internal.Data.Semigroup.Internal.Sum a)
instance GHC.Internal.Base.Functor f => GHC.Internal.Base.Functor (GHC.Internal.Data.Semigroup.Internal.Alt f)
instance GHC.Internal.Base.Functor GHC.Internal.Data.Semigroup.Internal.Dual
instance GHC.Internal.Base.Functor GHC.Internal.Data.Semigroup.Internal.Product
instance GHC.Internal.Base.Functor GHC.Internal.Data.Semigroup.Internal.Sum
instance GHC.Internal.Generics.Generic1 GHC.Internal.Data.Semigroup.Internal.Dual
instance GHC.Internal.Generics.Generic1 GHC.Internal.Data.Semigroup.Internal.Product
instance GHC.Internal.Generics.Generic1 GHC.Internal.Data.Semigroup.Internal.Sum
instance forall k (f :: k -> *). GHC.Internal.Generics.Generic1 (GHC.Internal.Data.Semigroup.Internal.Alt f)
instance GHC.Internal.Generics.Generic GHC.Internal.Data.Semigroup.Internal.All
instance forall k (f :: k -> *) (a :: k). GHC.Internal.Generics.Generic (GHC.Internal.Data.Semigroup.Internal.Alt f a)
instance GHC.Internal.Generics.Generic GHC.Internal.Data.Semigroup.Internal.Any
instance GHC.Internal.Generics.Generic (GHC.Internal.Data.Semigroup.Internal.Dual a)
instance GHC.Internal.Generics.Generic (GHC.Internal.Data.Semigroup.Internal.Endo a)
instance GHC.Internal.Generics.Generic (GHC.Internal.Data.Semigroup.Internal.Product a)
instance GHC.Internal.Generics.Generic (GHC.Internal.Data.Semigroup.Internal.Sum a)
instance GHC.Internal.Base.MonadPlus f => GHC.Internal.Base.MonadPlus (GHC.Internal.Data.Semigroup.Internal.Alt f)
instance GHC.Internal.Base.Monad f => GHC.Internal.Base.Monad (GHC.Internal.Data.Semigroup.Internal.Alt f)
instance GHC.Internal.Base.Monad GHC.Internal.Data.Semigroup.Internal.Dual
instance GHC.Internal.Base.Monad GHC.Internal.Data.Semigroup.Internal.Product
instance GHC.Internal.Base.Monad GHC.Internal.Data.Semigroup.Internal.Sum
instance GHC.Internal.Base.Monoid GHC.Internal.Data.Semigroup.Internal.All
instance GHC.Internal.Base.Alternative f => GHC.Internal.Base.Monoid (GHC.Internal.Data.Semigroup.Internal.Alt f a)
instance GHC.Internal.Base.Monoid GHC.Internal.Data.Semigroup.Internal.Any
instance GHC.Internal.Base.Monoid a => GHC.Internal.Base.Monoid (GHC.Internal.Data.Semigroup.Internal.Dual a)
instance GHC.Internal.Base.Monoid (GHC.Internal.Data.Semigroup.Internal.Endo a)
instance GHC.Internal.Num.Num a => GHC.Internal.Base.Monoid (GHC.Internal.Data.Semigroup.Internal.Product a)
instance GHC.Internal.Num.Num a => GHC.Internal.Base.Monoid (GHC.Internal.Data.Semigroup.Internal.Sum a)
instance forall k (f :: k -> *) (a :: k). GHC.Internal.Num.Num (f a) => GHC.Internal.Num.Num (GHC.Internal.Data.Semigroup.Internal.Alt f a)
instance GHC.Internal.Num.Num a => GHC.Internal.Num.Num (GHC.Internal.Data.Semigroup.Internal.Product a)
instance GHC.Internal.Num.Num a => GHC.Internal.Num.Num (GHC.Internal.Data.Semigroup.Internal.Sum a)
instance GHC.Classes.Ord GHC.Internal.Data.Semigroup.Internal.All
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (GHC.Internal.Data.Semigroup.Internal.Alt f a)
instance GHC.Classes.Ord GHC.Internal.Data.Semigroup.Internal.Any
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Internal.Data.Semigroup.Internal.Dual a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Internal.Data.Semigroup.Internal.Product a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Internal.Data.Semigroup.Internal.Sum a)
instance GHC.Internal.Read.Read GHC.Internal.Data.Semigroup.Internal.All
instance forall k (f :: k -> *) (a :: k). GHC.Internal.Read.Read (f a) => GHC.Internal.Read.Read (GHC.Internal.Data.Semigroup.Internal.Alt f a)
instance GHC.Internal.Read.Read GHC.Internal.Data.Semigroup.Internal.Any
instance GHC.Internal.Read.Read a => GHC.Internal.Read.Read (GHC.Internal.Data.Semigroup.Internal.Dual a)
instance GHC.Internal.Read.Read a => GHC.Internal.Read.Read (GHC.Internal.Data.Semigroup.Internal.Product a)
instance GHC.Internal.Read.Read a => GHC.Internal.Read.Read (GHC.Internal.Data.Semigroup.Internal.Sum a)
instance GHC.Internal.Base.Semigroup GHC.Internal.Data.Semigroup.Internal.All
instance GHC.Internal.Base.Alternative f => GHC.Internal.Base.Semigroup (GHC.Internal.Data.Semigroup.Internal.Alt f a)
instance GHC.Internal.Base.Semigroup GHC.Internal.Data.Semigroup.Internal.Any
instance GHC.Internal.Base.Semigroup a => GHC.Internal.Base.Semigroup (GHC.Internal.Data.Semigroup.Internal.Dual a)
instance GHC.Internal.Base.Semigroup (GHC.Internal.Data.Semigroup.Internal.Endo a)
instance GHC.Internal.Num.Num a => GHC.Internal.Base.Semigroup (GHC.Internal.Data.Semigroup.Internal.Product a)
instance GHC.Internal.Num.Num a => GHC.Internal.Base.Semigroup (GHC.Internal.Data.Semigroup.Internal.Sum a)
instance GHC.Internal.Show.Show GHC.Internal.Data.Semigroup.Internal.All
instance forall k (f :: k -> *) (a :: k). GHC.Internal.Show.Show (f a) => GHC.Internal.Show.Show (GHC.Internal.Data.Semigroup.Internal.Alt f a)
instance GHC.Internal.Show.Show GHC.Internal.Data.Semigroup.Internal.Any
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Internal.Data.Semigroup.Internal.Dual a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Internal.Data.Semigroup.Internal.Product a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Internal.Data.Semigroup.Internal.Sum a)


-- | A type <tt>a</tt> is a <a>Monoid</a> if it provides an associative
--   function (<a>&lt;&gt;</a>) that lets you combine any two values of
--   type <tt>a</tt> into one, and a neutral element (<a>mempty</a>) such
--   that
--   
--   <pre>
--   a &lt;&gt; mempty == mempty &lt;&gt; a == a
--   </pre>
--   
--   A <a>Monoid</a> is a <a>Semigroup</a> with the added requirement of a
--   neutral element. Thus any <a>Monoid</a> is a <a>Semigroup</a>, but not
--   the other way around.
--   
--   <h4><b>Examples</b></h4>
--   
--   The <a>Sum</a> monoid is defined by the numerical addition operator
--   and `0` as neutral element:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Int (Int)
--   
--   &gt;&gt;&gt; mempty :: Sum Int
--   Sum {getSum = 0}
--   
--   &gt;&gt;&gt; Sum 1 &lt;&gt; Sum 2 &lt;&gt; Sum 3 &lt;&gt; Sum 4 :: Sum Int
--   Sum {getSum = 10}
--   </pre>
--   
--   We can combine multiple values in a list into a single value using the
--   <a>mconcat</a> function. Note that we have to specify the type here
--   since <a>Int</a> is a monoid under several different operations:
--   
--   <pre>
--   &gt;&gt;&gt; mconcat [1,2,3,4] :: Sum Int
--   Sum {getSum = 10}
--   
--   &gt;&gt;&gt; mconcat [] :: Sum Int
--   Sum {getSum = 0}
--   </pre>
--   
--   Another valid monoid instance of <a>Int</a> is <a>Product</a> It is
--   defined by multiplication and `1` as neutral element:
--   
--   <pre>
--   &gt;&gt;&gt; Product 1 &lt;&gt; Product 2 &lt;&gt; Product 3 &lt;&gt; Product 4 :: Product Int
--   Product {getProduct = 24}
--   
--   &gt;&gt;&gt; mconcat [1,2,3,4] :: Product Int
--   Product {getProduct = 24}
--   
--   &gt;&gt;&gt; mconcat [] :: Product Int
--   Product {getProduct = 1}
--   </pre>
module GHC.Internal.Data.Monoid

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   You can alternatively define <a>mconcat</a> instead of <a>mempty</a>,
--   in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>mconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>mconcat</a> (<a>join</a> xss) =
--   <a>mconcat</a> (<a>fmap</a> <a>mconcat</a> xss)</tt></li>
--   <li><i>Subclass</i> <tt><a>mconcat</a> (<tt>toList</tt> xs) =
--   <a>sconcat</a> xs</tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello world" &lt;&gt; mempty
--   "Hello world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mempty &lt;&gt; [1, 2, 3]
--   [1,2,3]
--   </pre>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
--   
--   <pre>
--   &gt;&gt;&gt; mconcat ["Hello", " ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
mconcat :: Monoid a => [a] -> a

-- | An associative operation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [1, 2, 3] &lt;&gt; Just [4, 5, 6]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr "Hello, " &lt;&gt; putStrLn "World!"
--   Hello, World!
--   </pre>
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | The dual of a <a>Monoid</a>, obtained by swapping the arguments of
--   <a>(&lt;&gt;)</a>.
--   
--   <pre>
--   Dual a &lt;&gt; Dual b == Dual (b &lt;&gt; a)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Dual "Hello" &lt;&gt; Dual "World"
--   Dual {getDual = "WorldHello"}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Dual (Dual "Hello") &lt;&gt; Dual (Dual "World")
--   Dual {getDual = Dual {getDual = "HelloWorld"}}
--   </pre>
newtype Dual a
Dual :: a -> Dual a
[getDual] :: Dual a -> a

-- | The monoid of endomorphisms under composition.
--   
--   <pre>
--   Endo f &lt;&gt; Endo g == Endo (f . g)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo ("Hello, " ++) &lt;&gt; Endo (++ "!")
--   
--   &gt;&gt;&gt; appEndo computation "Haskell"
--   "Hello, Haskell!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo (*3) &lt;&gt; Endo (+1)
--   
--   &gt;&gt;&gt; appEndo computation 1
--   6
--   </pre>
newtype Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a

-- | Boolean monoid under conjunction <a>(&amp;&amp;)</a>.
--   
--   <pre>
--   All x &lt;&gt; All y = All (x &amp;&amp; y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; All True &lt;&gt; mempty &lt;&gt; All False)
--   All {getAll = False}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat (map (\x -&gt; All (even x)) [2,4,6,7,8])
--   All {getAll = False}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; All True &lt;&gt; mempty
--   All {getAll = True}
--   </pre>
newtype All
All :: Bool -> All
[getAll] :: All -> Bool

-- | Boolean monoid under disjunction <a>(||)</a>.
--   
--   <pre>
--   Any x &lt;&gt; Any y = Any (x || y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Any True &lt;&gt; mempty &lt;&gt; Any False
--   Any {getAny = True}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat (map (\x -&gt; Any (even x)) [2,4,6,7,8])
--   Any {getAny = True}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Any False &lt;&gt; mempty
--   Any {getAny = False}
--   </pre>
newtype Any
Any :: Bool -> Any
[getAny] :: Any -> Bool

-- | Monoid under addition.
--   
--   <pre>
--   Sum a &lt;&gt; Sum b = Sum (a + b)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Sum 1 &lt;&gt; Sum 2 &lt;&gt; mempty
--   Sum {getSum = 3}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat [ Sum n | n &lt;- [3 .. 9]]
--   Sum {getSum = 42}
--   </pre>
newtype Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Monoid under multiplication.
--   
--   <pre>
--   Product x &lt;&gt; Product y == Product (x * y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Product 3 &lt;&gt; Product 4 &lt;&gt; mempty
--   Product {getProduct = 12}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat [ Product n | n &lt;- [2 .. 10]]
--   Product {getProduct = 3628800}
--   </pre>
newtype Product a
Product :: a -> Product a
[getProduct] :: Product a -> a

-- | Maybe monoid returning the leftmost non-<a>Nothing</a> value.
--   
--   <tt><a>First</a> a</tt> is isomorphic to <tt><a>Alt</a> <a>Maybe</a>
--   a</tt>, but precedes it historically.
--   
--   Beware that <tt>Data.Monoid.</tt><a>First</a> is different from
--   <tt>Data.Semigroup.</tt><a>First</a>. The former returns the first
--   non-<a>Nothing</a>, so <tt>Data.Monoid.First Nothing &lt;&gt; x =
--   x</tt>. The latter simply returns the first value, thus
--   <tt>Data.Semigroup.First Nothing &lt;&gt; x = Data.Semigroup.First
--   Nothing</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; First (Just "hello") &lt;&gt; First Nothing &lt;&gt; First (Just "world")
--   First {getFirst = Just "hello"}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; First Nothing &lt;&gt; mempty
--   First {getFirst = Nothing}
--   </pre>
newtype First a
First :: Maybe a -> First a
[getFirst] :: First a -> Maybe a

-- | Maybe monoid returning the rightmost non-<a>Nothing</a> value.
--   
--   <tt><a>Last</a> a</tt> is isomorphic to <tt><a>Dual</a> (<a>First</a>
--   a)</tt>, and thus to <tt><a>Dual</a> (<a>Alt</a> <a>Maybe</a> a)</tt>
--   
--   <tt>Data.Semigroup.</tt><a>Last</a>. The former returns the last
--   non-<a>Nothing</a>, so <tt>x &lt;&gt; Data.Monoid.Last Nothing =
--   x</tt>. The latter simply returns the last value, thus <tt>x &lt;&gt;
--   Data.Semigroup.Last Nothing = Data.Semigroup.Last Nothing</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Last (Just "hello") &lt;&gt; Last Nothing &lt;&gt; Last (Just "world")
--   Last {getLast = Just "world"}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Last Nothing &lt;&gt; mempty
--   Last {getLast = Nothing}
--   </pre>
newtype Last a
Last :: Maybe a -> Last a
[getLast] :: Last a -> Maybe a

-- | Monoid under <a>&lt;|&gt;</a>.
--   
--   <pre>
--   Alt l &lt;&gt; Alt r == Alt (l &lt;|&gt; r)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Alt (Just 12) &lt;&gt; Alt (Just 24)
--   Alt {getAlt = Just 12}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Alt Nothing &lt;&gt; Alt (Just 24)
--   Alt {getAlt = Just 24}
--   </pre>
newtype Alt (f :: k -> Type) (a :: k)
Alt :: f a -> Alt (f :: k -> Type) (a :: k)
[getAlt] :: Alt (f :: k -> Type) (a :: k) -> f a

-- | This data type witnesses the lifting of a <a>Monoid</a> into an
--   <a>Applicative</a> pointwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Ap (Just [1, 2, 3]) &lt;&gt; Ap Nothing
--   Ap {getAp = Nothing}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Ap [Sum 10, Sum 20] &lt;&gt; Ap [Sum 1, Sum 2]
--   Ap {getAp = [Sum {getSum = 11},Sum {getSum = 12},Sum {getSum = 21},Sum {getSum = 22}]}
--   </pre>
newtype Ap (f :: k -> Type) (a :: k)
Ap :: f a -> Ap (f :: k -> Type) (a :: k)
[getAp] :: Ap (f :: k -> Type) (a :: k) -> f a
instance GHC.Internal.Base.Alternative f => GHC.Internal.Base.Alternative (GHC.Internal.Data.Monoid.Ap f)
instance GHC.Internal.Base.Applicative f => GHC.Internal.Base.Applicative (GHC.Internal.Data.Monoid.Ap f)
instance GHC.Internal.Base.Applicative GHC.Internal.Data.Monoid.First
instance GHC.Internal.Base.Applicative GHC.Internal.Data.Monoid.Last
instance (GHC.Internal.Base.Applicative f, GHC.Internal.Enum.Bounded a) => GHC.Internal.Enum.Bounded (GHC.Internal.Data.Monoid.Ap f a)
instance forall k (f :: k -> *) (a :: k). GHC.Internal.Enum.Enum (f a) => GHC.Internal.Enum.Enum (GHC.Internal.Data.Monoid.Ap f a)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (GHC.Internal.Data.Monoid.Ap f a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Internal.Data.Monoid.First a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Internal.Data.Monoid.Last a)
instance GHC.Internal.Base.Functor f => GHC.Internal.Base.Functor (GHC.Internal.Data.Monoid.Ap f)
instance GHC.Internal.Base.Functor GHC.Internal.Data.Monoid.First
instance GHC.Internal.Base.Functor GHC.Internal.Data.Monoid.Last
instance GHC.Internal.Generics.Generic1 GHC.Internal.Data.Monoid.First
instance GHC.Internal.Generics.Generic1 GHC.Internal.Data.Monoid.Last
instance forall k (f :: k -> *). GHC.Internal.Generics.Generic1 (GHC.Internal.Data.Monoid.Ap f)
instance forall k (f :: k -> *) (a :: k). GHC.Internal.Generics.Generic (GHC.Internal.Data.Monoid.Ap f a)
instance GHC.Internal.Generics.Generic (GHC.Internal.Data.Monoid.First a)
instance GHC.Internal.Generics.Generic (GHC.Internal.Data.Monoid.Last a)
instance GHC.Internal.Control.Monad.Fail.MonadFail f => GHC.Internal.Control.Monad.Fail.MonadFail (GHC.Internal.Data.Monoid.Ap f)
instance GHC.Internal.Base.Monad f => GHC.Internal.Base.Monad (GHC.Internal.Data.Monoid.Ap f)
instance GHC.Internal.Base.Monad GHC.Internal.Data.Monoid.First
instance GHC.Internal.Base.Monad GHC.Internal.Data.Monoid.Last
instance GHC.Internal.Base.MonadPlus f => GHC.Internal.Base.MonadPlus (GHC.Internal.Data.Monoid.Ap f)
instance (GHC.Internal.Base.Applicative f, GHC.Internal.Base.Monoid a) => GHC.Internal.Base.Monoid (GHC.Internal.Data.Monoid.Ap f a)
instance GHC.Internal.Base.Monoid (GHC.Internal.Data.Monoid.First a)
instance GHC.Internal.Base.Monoid (GHC.Internal.Data.Monoid.Last a)
instance (GHC.Internal.Base.Applicative f, GHC.Internal.Num.Num a) => GHC.Internal.Num.Num (GHC.Internal.Data.Monoid.Ap f a)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (GHC.Internal.Data.Monoid.Ap f a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Internal.Data.Monoid.First a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Internal.Data.Monoid.Last a)
instance forall k (f :: k -> *) (a :: k). GHC.Internal.Read.Read (f a) => GHC.Internal.Read.Read (GHC.Internal.Data.Monoid.Ap f a)
instance GHC.Internal.Read.Read a => GHC.Internal.Read.Read (GHC.Internal.Data.Monoid.First a)
instance GHC.Internal.Read.Read a => GHC.Internal.Read.Read (GHC.Internal.Data.Monoid.Last a)
instance (GHC.Internal.Base.Applicative f, GHC.Internal.Base.Semigroup a) => GHC.Internal.Base.Semigroup (GHC.Internal.Data.Monoid.Ap f a)
instance GHC.Internal.Base.Semigroup (GHC.Internal.Data.Monoid.First a)
instance GHC.Internal.Base.Semigroup (GHC.Internal.Data.Monoid.Last a)
instance forall k (f :: k -> *) (a :: k). GHC.Internal.Show.Show (f a) => GHC.Internal.Show.Show (GHC.Internal.Data.Monoid.Ap f a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Internal.Data.Monoid.First a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Internal.Data.Monoid.Last a)


-- | Target byte ordering.
module GHC.Internal.ByteOrder

-- | Byte ordering.
data ByteOrder

-- | most-significant-byte occurs in lowest address.
BigEndian :: ByteOrder

-- | least-significant-byte occurs in lowest address.
LittleEndian :: ByteOrder

-- | The byte ordering of the target machine.
targetByteOrder :: ByteOrder
instance GHC.Internal.Enum.Bounded GHC.Internal.ByteOrder.ByteOrder
instance GHC.Internal.Enum.Enum GHC.Internal.ByteOrder.ByteOrder
instance GHC.Classes.Eq GHC.Internal.ByteOrder.ByteOrder
instance GHC.Internal.Generics.Generic GHC.Internal.ByteOrder.ByteOrder
instance GHC.Classes.Ord GHC.Internal.ByteOrder.ByteOrder
instance GHC.Internal.Read.Read GHC.Internal.ByteOrder.ByteOrder
instance GHC.Internal.Show.Show GHC.Internal.ByteOrder.ByteOrder


-- | Operations on lists.
module GHC.Internal.Data.OldList

-- | <a>(++)</a> appends two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
--   
--   <h4><b>Performance considerations</b></h4>
--   
--   This function takes linear time in the number of elements of the
--   <b>first</b> list. Thus it is better to associate repeated
--   applications of <a>(++)</a> to the right (which is the default
--   behaviour): <tt>xs ++ (ys ++ zs)</tt> or simply <tt>xs ++ ys ++
--   zs</tt>, but not <tt>(xs ++ ys) ++ zs</tt>. For the same reason
--   <a>concat</a> <tt>=</tt> <a>foldr</a> <a>(++)</a> <tt>[]</tt> has
--   linear performance, while <a>foldl</a> <a>(++)</a> <tt>[]</tt> is
--   prone to quadratic slowdown
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1, 2, 3] ++ [4, 5, 6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ++ [1, 2, 3]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [3, 2, 1] ++ []
--   [3,2,1]
--   </pre>
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | &lt;math&gt;. Extract the first element of a list, which must be
--   non-empty.
--   
--   To disable the warning about partiality put <tt>{-# OPTIONS_GHC
--   -Wno-x-partial -Wno-unrecognised-warning-flags #-}</tt> at the top of
--   the file. To disable it throughout a package put the same options into
--   <tt>ghc-options</tt> section of Cabal file. To disable it in GHCi put
--   <tt>:set -Wno-x-partial -Wno-unrecognised-warning-flags</tt> into
--   <tt>~/.ghci</tt> config file. See also the <a>migration guide</a>.
--   
--   <h5><b>Examples</b></h5>
--   
--   <pre>
--   &gt;&gt;&gt; head [1, 2, 3]
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; head [1..]
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; head []
--   *** Exception: Prelude.head: empty list
--   </pre>

-- | <i>Warning: This is a partial function, it throws an error on empty
--   lists. Use pattern matching, <a>uncons</a> or <a>listToMaybe</a>
--   instead. Consider refactoring to use <a>Data.List.NonEmpty</a>.</i>
head :: HasCallStack => [a] -> a

-- | &lt;math&gt;. Extract the last element of a list, which must be finite
--   and non-empty.
--   
--   WARNING: This function is partial. Consider using <a>unsnoc</a>
--   instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; last [1, 2, 3]
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; last [1..]
--   * Hangs forever *
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; last []
--   *** Exception: Prelude.last: empty list
--   </pre>
last :: HasCallStack => [a] -> a

-- | &lt;math&gt;. Extract the elements after the head of a list, which
--   must be non-empty.
--   
--   To disable the warning about partiality put <tt>{-# OPTIONS_GHC
--   -Wno-x-partial -Wno-unrecognised-warning-flags #-}</tt> at the top of
--   the file. To disable it throughout a package put the same options into
--   <tt>ghc-options</tt> section of Cabal file. To disable it in GHCi put
--   <tt>:set -Wno-x-partial -Wno-unrecognised-warning-flags</tt> into
--   <tt>~/.ghci</tt> config file. See also the <a>migration guide</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; tail [1, 2, 3]
--   [2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tail [1]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tail []
--   *** Exception: Prelude.tail: empty list
--   </pre>

-- | <i>Warning: This is a partial function, it throws an error on empty
--   lists. Replace it with <a>drop</a> 1, or use pattern matching or
--   <a>uncons</a> instead. Consider refactoring to use
--   <a>Data.List.NonEmpty</a>.</i>
tail :: HasCallStack => [a] -> [a]

-- | &lt;math&gt;. Return all the elements of a list except the last one.
--   The list must be non-empty.
--   
--   WARNING: This function is partial. Consider using <a>unsnoc</a>
--   instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; init [1, 2, 3]
--   [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; init [1]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; init []
--   *** Exception: Prelude.init: empty list
--   </pre>
init :: HasCallStack => [a] -> [a]

-- | &lt;math&gt;. Decompose a list into its <a>head</a> and <a>tail</a>.
--   
--   <ul>
--   <li>If the list is empty, returns <a>Nothing</a>.</li>
--   <li>If the list is non-empty, returns <tt><a>Just</a> (x, xs)</tt>,
--   where <tt>x</tt> is the <a>head</a> of the list and <tt>xs</tt> its
--   <a>tail</a>.</li>
--   </ul>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncons []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncons [1]
--   Just (1,[])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncons [1, 2, 3]
--   Just (1,[2,3])
--   </pre>
uncons :: [a] -> Maybe (a, [a])

-- | &lt;math&gt;. Decompose a list into <a>init</a> and <a>last</a>.
--   
--   <ul>
--   <li>If the list is empty, returns <a>Nothing</a>.</li>
--   <li>If the list is non-empty, returns <tt><a>Just</a> (xs, x)</tt>,
--   where <tt>xs</tt> is the <a>init</a>ial part of the list and
--   <tt>x</tt> is its <a>last</a> element.</li>
--   </ul>
--   
--   <a>unsnoc</a> is dual to <a>uncons</a>: for a finite list <tt>xs</tt>
--   
--   <pre>
--   unsnoc xs = (\(hd, tl) -&gt; (reverse tl, hd)) &lt;$&gt; uncons (reverse xs)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc [1]
--   Just ([],1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc [1, 2, 3]
--   Just ([1,2],3)
--   </pre>
--   
--   <h4><b>Laziness</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; fst &lt;$&gt; unsnoc [undefined]
--   Just []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; head . fst &lt;$&gt; unsnoc (1 : undefined)
--   Just *** Exception: Prelude.undefined
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; head . fst &lt;$&gt; unsnoc (1 : 2 : undefined)
--   Just 1
--   </pre>
unsnoc :: [a] -> Maybe ([a], a)

-- | Construct a list from a single element.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; singleton True
--   [True]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; singleton [1, 2, 3]
--   [[1,2,3]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; singleton 'c'
--   "c"
--   </pre>
singleton :: a -> [a]

-- | &lt;math&gt;. Test whether a list is empty.
--   
--   <pre>
--   &gt;&gt;&gt; null []
--   True
--   
--   &gt;&gt;&gt; null [1]
--   False
--   
--   &gt;&gt;&gt; null [1..]
--   False
--   </pre>
null :: [a] -> Bool

-- | &lt;math&gt;. <a>length</a> returns the length of a finite list as an
--   <a>Int</a>. It is an instance of the more general
--   <a>genericLength</a>, the result type of which may be any kind of
--   number.
--   
--   <pre>
--   &gt;&gt;&gt; length []
--   0
--   
--   &gt;&gt;&gt; length ['a', 'b', 'c']
--   3
--   
--   &gt;&gt;&gt; length [1..]
--   * Hangs forever *
--   </pre>
length :: [a] -> Int

-- | &lt;math&gt;. <a>map</a> <tt>f xs</tt> is the list obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   this means that <tt>map id == id</tt>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map id [1, 2, 3]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (\n -&gt; 3 * n + 1) [1, 2, 3]
--   [4,7,10]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | &lt;math&gt;. <a>reverse</a> <tt>xs</tt> returns the elements of
--   <tt>xs</tt> in reverse order. <tt>xs</tt> must be finite.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <a>reverse</a> is lazy in its elements.
--   
--   <pre>
--   &gt;&gt;&gt; head (reverse [undefined, 1])
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reverse (1 : 2 : undefined)
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; reverse []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reverse [42]
--   [42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reverse [2,5,7]
--   [7,5,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reverse [1..]
--   * Hangs forever *
--   </pre>
reverse :: [a] -> [a]

-- | &lt;math&gt;. The <a>intersperse</a> function takes an element and a
--   list and `intersperses' that element between the elements of the list.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <a>intersperse</a> has the following properties
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (intersperse undefined ('a' : undefined))
--   "a"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 2 (intersperse ',' ('a' : undefined))
--   "a*** Exception: Prelude.undefined
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; intersperse ',' "abcde"
--   "a,b,c,d,e"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intersperse 1 [3, 4, 5]
--   [3,1,4,1,5]
--   </pre>
intersperse :: a -> [a] -> [a]

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <a>intercalate</a> has the following properties:
--   
--   <pre>
--   &gt;&gt;&gt; take 5 (intercalate undefined ("Lorem" : undefined))
--   "Lorem"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 6 (intercalate ", " ("Lorem" : undefined))
--   "Lorem*** Exception: Prelude.undefined
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate ", " ["Lorem", "ipsum", "dolor"]
--   "Lorem, ipsum, dolor"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate [0, 1] [[2, 3], [4, 5, 6], []]
--   [2,3,0,1,4,5,6,0,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate [1, 2, 3] [[], []]
--   [1,2,3]
--   </pre>
intercalate :: [a] -> [[a]] -> [a]

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <a>transpose</a> is lazy in its elements
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (transpose ['a' : undefined, 'b' : undefined])
--   ["ab"]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[1,2,3],[4,5,6]]
--   [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   If some of the rows are shorter than the following rows, their
--   elements are skipped:
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[10,11],[20],[],[30,31,32]]
--   [[10,20,30],[11,31],[32]]
--   </pre>
--   
--   For this reason the outer list must be finite; otherwise
--   <a>transpose</a> hangs:
--   
--   <pre>
--   &gt;&gt;&gt; transpose (repeat [])
--   * Hangs forever *
--   </pre>
transpose :: [[a]] -> [[a]]

-- | The <a>subsequences</a> function returns the list of all subsequences
--   of the argument.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <a>subsequences</a> does not look ahead unless it must:
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (subsequences undefined)
--   [[]]
--   
--   &gt;&gt;&gt; take 2 (subsequences ('a' : undefined))
--   ["","a"]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; subsequences "abc"
--   ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
--   
--   This function is productive on infinite inputs:
--   
--   <pre>
--   &gt;&gt;&gt; take 8 $ subsequences ['a'..]
--   ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
subsequences :: [a] -> [[a]]

-- | The <a>permutations</a> function returns the list of all permutations
--   of the argument.
--   
--   Note that the order of permutations is not lexicographic. It satisfies
--   the following property:
--   
--   <pre>
--   map (take n) (take (product [1..n]) (permutations ([1..n] ++ undefined))) == permutations [1..n]
--   </pre>
--   
--   <h4><b>Laziness</b></h4>
--   
--   The <a>permutations</a> function is maximally lazy: for each
--   <tt>n</tt>, the value of <tt><a>permutations</a> xs</tt> starts with
--   those permutations that permute <tt><a>take</a> n xs</tt> and keep
--   <tt><a>drop</a> n xs</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; permutations "abc"
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; permutations [1, 2]
--   [[1,2],[2,1]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; permutations []
--   [[]]
--   </pre>
--   
--   This function is productive on infinite inputs:
--   
--   <pre>
--   &gt;&gt;&gt; take 6 $ map (take 3) $ permutations ['a'..]
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
permutations :: [a] -> [[a]]

-- | <a>foldl</a>, applied to a binary operator, a starting value
--   (typically the left-identity of the operator), and a list, reduces the
--   list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   The list must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (+) 0 [1..4]
--   10
--   
--   &gt;&gt;&gt; foldl (+) 42 []
--   42
--   
--   &gt;&gt;&gt; foldl (-) 100 [1..4]
--   90
--   
--   &gt;&gt;&gt; foldl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   "dcbafoo"
--   
--   &gt;&gt;&gt; foldl (+) 0 [1..]
--   * Hangs forever *
--   </pre>
foldl :: forall a b. (b -> a -> b) -> b -> [a] -> b

-- | A strict version of <a>foldl</a>.
foldl' :: forall a b. (b -> a -> b) -> b -> [a] -> b

-- | <a>foldl1</a> is a variant of <a>foldl</a> that has no starting value
--   argument, and thus must be applied to non-empty lists. Note that
--   unlike <a>foldl</a>, the accumulated value must be of the same type as
--   the list elements.
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..4]
--   10
--   
--   &gt;&gt;&gt; foldl1 (+) []
--   *** Exception: Prelude.foldl1: empty list
--   
--   &gt;&gt;&gt; foldl1 (-) [1..4]
--   -8
--   
--   &gt;&gt;&gt; foldl1 (&amp;&amp;) [True, False, True, True]
--   False
--   
--   &gt;&gt;&gt; foldl1 (||) [False, False, True, True]
--   True
--   
--   &gt;&gt;&gt; foldl1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldl1 :: HasCallStack => (a -> a -> a) -> [a] -> a

-- | A strict version of <a>foldl1</a>.
foldl1' :: HasCallStack => (a -> a -> a) -> [a] -> a

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a list, reduces
--   the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
foldr :: (a -> b -> b) -> b -> [a] -> b

-- | <a>foldr1</a> is a variant of <a>foldr</a> that has no starting value
--   argument, and thus must be applied to non-empty lists. Note that
--   unlike <a>foldr</a>, the accumulated value must be of the same type as
--   the list elements.
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..4]
--   10
--   
--   &gt;&gt;&gt; foldr1 (+) []
--   *** Exception: Prelude.foldr1: empty list
--   
--   &gt;&gt;&gt; foldr1 (-) [1..4]
--   -2
--   
--   &gt;&gt;&gt; foldr1 (&amp;&amp;) [True, False, True, True]
--   False
--   
--   &gt;&gt;&gt; foldr1 (||) [False, False, True, True]
--   True
--   
--   &gt;&gt;&gt; force $ foldr1 (+) [1..]
--   *** Exception: stack overflow
--   </pre>
foldr1 :: HasCallStack => (a -> a -> a) -> [a] -> a

-- | Concatenate a list of lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; concat [[1,2,3], [4,5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat [[42]]
--   [42]
--   </pre>
concat :: [[a]] -> [a]

-- | Map a function returning a list over a list and concatenate the
--   results. <a>concatMap</a> can be seen as the composition of
--   <a>concat</a> and <a>map</a>.
--   
--   <pre>
--   concatMap f xs == (concat . map f) xs
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (\i -&gt; [-i,i]) []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (\i -&gt; [-i, i]) [1, 2, 3]
--   [-1,1,-2,2,-3,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap ('replicate' 3) [0, 2, 4]
--   [0,0,0,2,2,2,4,4,4]
--   </pre>
concatMap :: (a -> [b]) -> [a] -> [b]

-- | <a>and</a> returns the conjunction of a Boolean list. For the result
--   to be <a>True</a>, the list must be finite; <a>False</a>, however,
--   results from a <a>False</a> value at a finite index of a finite or
--   infinite list.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; and []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True, True, False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,True,True,True...
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (repeat True)
--   * Hangs forever *
--   </pre>
and :: [Bool] -> Bool

-- | <a>or</a> returns the disjunction of a Boolean list. For the result to
--   be <a>False</a>, the list must be finite; <a>True</a>, however,
--   results from a <a>True</a> value at a finite index of a finite or
--   infinite list.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; or []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (True : repeat False) -- Infinite list [True,False,False,False,False,False,False...
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (repeat False)
--   * Hangs forever *
--   </pre>
or :: [Bool] -> Bool

-- | Applied to a predicate and a list, <a>any</a> determines if any
--   element of the list satisfies the predicate. For the result to be
--   <a>False</a>, the list must be finite; <a>True</a>, however, results
--   from a <a>True</a> value for the predicate applied to an element at a
--   finite index of a finite or infinite list.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2,3,4,5]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [0, -1..]
--   * Hangs forever *
--   </pre>
any :: (a -> Bool) -> [a] -> Bool

-- | Applied to a predicate and a list, <a>all</a> determines if all
--   elements of the list satisfy the predicate. For the result to be
--   <a>True</a>, the list must be finite; <a>False</a>, however, results
--   from a <a>False</a> value for the predicate applied to an element at a
--   finite index of a finite or infinite list.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2,3,4,5]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [4..]
--   * Hangs forever *
--   </pre>
all :: (a -> Bool) -> [a] -> Bool

-- | The <a>sum</a> function computes the sum of a finite list of numbers.
--   
--   <pre>
--   &gt;&gt;&gt; sum []
--   0
--   
--   &gt;&gt;&gt; sum [42]
--   42
--   
--   &gt;&gt;&gt; sum [1..10]
--   55
--   
--   &gt;&gt;&gt; sum [4.1, 2.0, 1.7]
--   7.8
--   
--   &gt;&gt;&gt; sum [1..]
--   * Hangs forever *
--   </pre>
sum :: Num a => [a] -> a

-- | The <a>product</a> function computes the product of a finite list of
--   numbers.
--   
--   <pre>
--   &gt;&gt;&gt; product []
--   1
--   
--   &gt;&gt;&gt; product [42]
--   42
--   
--   &gt;&gt;&gt; product [1..10]
--   3628800
--   
--   &gt;&gt;&gt; product [4.1, 2.0, 1.7]
--   13.939999999999998
--   
--   &gt;&gt;&gt; product [1..]
--   * Hangs forever *
--   </pre>
product :: Num a => [a] -> a

-- | <a>maximum</a> returns the maximum value from a list, which must be
--   non-empty, finite, and of an ordered type. This function is equivalent
--   to <tt><a>foldr1</a> <a>max</a></tt>, and its behavior on lists with
--   multiple maxima depends on the relevant implementation of <a>max</a>.
--   For the default implementation of <a>max</a>, list order is used as a
--   tie-breaker: if there are multiple maxima, the rightmost of them is
--   chosen (this is equivalent to <tt><a>maximumBy</a>
--   <a>compare</a></tt>).
--   
--   <pre>
--   &gt;&gt;&gt; maximum []
--   *** Exception: Prelude.maximum: empty list
--   
--   &gt;&gt;&gt; maximum [42]
--   42
--   
--   &gt;&gt;&gt; maximum [55, -12, 7, 0, -89]
--   55
--   
--   &gt;&gt;&gt; maximum [1..]
--   * Hangs forever *
--   </pre>
maximum :: (Ord a, HasCallStack) => [a] -> a

-- | <a>minimum</a> returns the minimum value from a list, which must be
--   non-empty, finite, and of an ordered type. This function is equivalent
--   to <tt><a>foldr1</a> <a>min</a></tt>, and its behavior on lists with
--   multiple minima depends on the relevant implementation of <a>min</a>.
--   For the default implementation of <a>min</a>, list order is used as a
--   tie-breaker: if there are multiple minima, the leftmost of them is
--   chosen (this is equivalent to <tt><a>minimumBy</a>
--   <a>compare</a></tt>).
--   
--   <pre>
--   &gt;&gt;&gt; minimum []
--   *** Exception: Prelude.minimum: empty list
--   
--   &gt;&gt;&gt; minimum [42]
--   42
--   
--   &gt;&gt;&gt; minimum [55, -12, 7, 0, -89]
--   -89
--   
--   &gt;&gt;&gt; minimum [1..]
--   * Hangs forever *
--   </pre>
minimum :: (Ord a, HasCallStack) => [a] -> a

-- | &lt;math&gt;. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (+) 0 [1..4]
--   [0,1,3,6,10]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (+) 42 []
--   [42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (-) 100 [1..4]
--   [100,99,97,94,90]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["foo","afoo","bafoo","cbafoo","dcbafoo"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 (scanl (+) 0 [1..])
--   [0,1,3,6,10,15,21,28,36,45]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (scanl undefined 'a' undefined)
--   "a"
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. A strict version of <a>scanl</a>.
scanl' :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (+) [1..4]
--   [1,3,6,10]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (+) []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (-) [1..4]
--   [1,-1,-4,-8]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (&amp;&amp;) [True, False, True, True]
--   [True,False,False,False]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (||) [False, False, True, True]
--   [False,False,True,True]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 (scanl1 (+) [1..])
--   [1,3,6,10,15,21,28,36,45,55]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (scanl1 undefined ('a' : undefined))
--   "a"
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that the order of parameters on the accumulating function are
--   reversed compared to <a>scanl</a>. Also note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (+) 0 [1..4]
--   [10,9,7,4,0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (+) 42 []
--   [42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (-) 100 [1..4]
--   [98,-97,99,-96,100]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (\nextChar reversedString -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["abcdfoo","bcdfoo","cdfoo","dfoo","foo"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; force $ scanr (+) 0 [1..]
--   *** Exception: stack overflow
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (+) [1..4]
--   [10,9,7,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (+) []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (-) [1..4]
--   [-2,3,-1,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (&amp;&amp;) [True, False, True, True]
--   [False,False,True,True]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (||) [True, True, False, False]
--   [True,True,False,False]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; force $ scanr1 (+) [1..]
--   *** Exception: stack overflow
--   </pre>
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | The <a>mapAccumL</a> function behaves like a combination of <a>map</a>
--   and <a>foldl</a>; it applies a function to each element of a list,
--   passing an accumulating parameter from left to right, and returning a
--   final value of this accumulator together with the new list.
--   
--   <a>mapAccumL</a> does not force accumulator if it is unused:
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (snd (mapAccumL (\_ x -&gt; (undefined, x)) undefined ('a' : undefined)))
--   "a"
--   </pre>
mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])

-- | The <a>mapAccumR</a> function behaves like a combination of <a>map</a>
--   and <a>foldr</a>; it applies a function to each element of a list,
--   passing an accumulating parameter from right to left, and returning a
--   final value of this accumulator together with the new list.
mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   <h4><b>Laziness</b></h4>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
--   
--   <pre>
--   &gt;&gt;&gt; take 1 $ iterate undefined 42
--   [42]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ iterate not True
--   [True,False,True,False,True,False,True,False,True,False]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ iterate (+3) 42
--   [42,45,48,51,54,57,60,63,66,69]
--   </pre>
--   
--   <tt>iterate id == <a>repeat</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ iterate id 1
--   [1,1,1,1,1,1,1,1,1,1]
--   </pre>
iterate :: (a -> a) -> a -> [a]

-- | <a>iterate'</a> is the strict version of <a>iterate</a>.
--   
--   It forces the result of each application of the function to weak head
--   normal form (WHNF) before proceeding.
--   
--   <pre>
--   &gt;&gt;&gt; take 1 $ iterate' undefined 42
--   *** Exception: Prelude.undefined
--   </pre>
iterate' :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ repeat 17
--   [17,17,17,17,17,17,17,17,17, 17]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; repeat undefined
--   [*** Exception: Prelude.undefined
--   </pre>
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; replicate 0 True
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate (-1) True
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate 4 True
--   [True,True,True,True]
--   </pre>
replicate :: Int -> a -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; cycle []
--   *** Exception: Prelude.cycle: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 (cycle [42])
--   [42,42,42,42,42,42,42,42,42,42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 (cycle [2, 5, 7])
--   [2,5,7,2,5,7,2,5,7,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (cycle (42 : undefined))
--   [42]
--   </pre>
cycle :: HasCallStack => [a] -> [a]

-- | The <a>unfoldr</a> function is a `dual' to <a>foldr</a>: while
--   <a>foldr</a> reduces a list to a summary value, <a>unfoldr</a> builds
--   a list from a seed value. The function takes the element and returns
--   <a>Nothing</a> if it is done producing the list or returns <a>Just</a>
--   <tt>(a,b)</tt>, in which case, <tt>a</tt> is a prepended to the list
--   and <tt>b</tt> is used as the next element in a recursive call. For
--   example,
--   
--   <pre>
--   iterate f == unfoldr (\x -&gt; Just (x, f x))
--   </pre>
--   
--   In some cases, <a>unfoldr</a> can undo a <a>foldr</a> operation:
--   
--   <pre>
--   unfoldr f' (foldr f z xs) == xs
--   </pre>
--   
--   if the following holds:
--   
--   <pre>
--   f' (f x y) = Just (x,y)
--   f' z       = Nothing
--   </pre>
--   
--   <h4><b>Laziness</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (unfoldr (\x -&gt; Just (x, undefined)) 'a')
--   "a"
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ unfoldr (\(x, y) -&gt; Just (x, (y, x + y))) (0, 1)
--   [0,1,1,2,3,5,8,13,21,54]
--   </pre>
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt;= <a>length</a> xs</tt>.
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; take 0 undefined
--   []
--   
--   &gt;&gt;&gt; take 2 (1 : 2 : undefined)
--   [1,2]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; take 5 "Hello World!"
--   "Hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 3 [1,2,3,4,5]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 3 [1,2]
--   [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 3 []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take (-1) [1,2]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 0 [1,2]
--   []
--   </pre>
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt;= <a>length</a>
--   xs</tt>.
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; drop 6 "Hello World!"
--   "World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; drop 3 [1,2,3,4,5]
--   [4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; drop 3 [1,2]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; drop 3 []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; drop (-1) [1,2]
--   [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; drop 0 [1,2]
--   [1,2]
--   </pre>
drop :: Int -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
--   
--   <h4><b>Laziness</b></h4>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt>
--   unless <tt>n</tt> is <tt>_|_</tt>: <tt>splitAt _|_ xs = _|_</tt>, not
--   <tt>(_|_, _|_)</tt>).
--   
--   The first component of the tuple is produced lazily:
--   
--   <pre>
--   &gt;&gt;&gt; fst (splitAt 0 undefined)
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (fst (splitAt 10 (1 : undefined)))
--   [1]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 6 "Hello World!"
--   ("Hello ","World!")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 3 [1,2,3,4,5]
--   ([1,2,3],[4,5])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 1 [1,2,3]
--   ([1],[2,3])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 3 [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 4 [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 0 [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitAt (-1) [1,2,3]
--   ([],[1,2,3])
--   </pre>
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (const False) undefined
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (const False) (undefined : undefined)
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (takeWhile (const True) (1 : undefined))
--   [1]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 3) [1,2,3,4,1,2,3,4]
--   [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 9) [1,2,3]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 0) [1,2,3]
--   []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 3) [1,2,3,4,5,1,2,3]
--   [3,4,5,1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 9) [1,2,3]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 0) [1,2,3]
--   [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | The <a>dropWhileEnd</a> function drops the largest suffix of a list in
--   which the given predicate holds for all elements.
--   
--   <h4><b>Laziness</b></h4>
--   
--   This function is lazy in spine, but strict in elements, which makes it
--   different from <a>reverse</a> <a>.</a> <a>dropWhile</a> <tt>p</tt>
--   <a>.</a> <a>reverse</a>, which is strict in spine, but lazy in
--   elements. For instance:
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (dropWhileEnd (&lt; 0) (1 : undefined))
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (reverse $ dropWhile (&lt; 0) $ reverse (1 : undefined))
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   but on the other hand
--   
--   <pre>
--   &gt;&gt;&gt; last (dropWhileEnd (&lt; 0) [undefined, 1])
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; last (reverse $ dropWhile (&lt; 0) $ reverse [undefined, 1])
--   1
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo\n"
--   "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo bar"
--   "foo bar"
--   
--   &gt;&gt;&gt; dropWhileEnd (&gt; 10) [1..20]
--   [1,2,3,4,5,6,7,8,9,10]
--   </pre>
dropWhileEnd :: (a -> Bool) -> [a] -> [a]

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is the longest prefix (possibly
--   empty) of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second
--   element is the remainder of the list:
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>, even if <tt>p</tt> is <tt>_|_</tt>.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; span undefined []
--   ([],[])
--   
--   &gt;&gt;&gt; fst (span (const False) undefined)
--   *** Exception: Prelude.undefined
--   
--   &gt;&gt;&gt; fst (span (const False) (undefined : undefined))
--   []
--   
--   &gt;&gt;&gt; take 1 (fst (span (const True) (1 : undefined)))
--   [1]
--   </pre>
--   
--   <a>span</a> produces the first component of the tuple lazily:
--   
--   <pre>
--   &gt;&gt;&gt; take 10 (fst (span (const True) [1..]))
--   [1,2,3,4,5,6,7,8,9,10]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2],[3,4,1,2,3,4])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 9) [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 0) [1,2,3]
--   ([],[1,2,3])
--   </pre>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt> and consequently to <tt>(<a>takeWhile</a> (<a>not</a> . p) xs,
--   <a>dropWhile</a> (<a>not</a> . p) xs)</tt>, even if <tt>p</tt> is
--   <tt>_|_</tt>.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; break undefined []
--   ([],[])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fst (break (const True) undefined)
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fst (break (const True) (undefined : undefined))
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (fst (break (const False) (1 : undefined)))
--   [1]
--   </pre>
--   
--   <a>break</a> produces the first component of the tuple lazily:
--   
--   <pre>
--   &gt;&gt;&gt; take 10 (fst (break (const False) [1..]))
--   [1,2,3,4,5,6,7,8,9,10]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; break (&gt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2,3],[4,1,2,3,4])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; break (&lt; 9) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; break (&gt; 9) [1,2,3]
--   ([1,2,3],[])
--   </pre>
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | &lt;math&gt;. The <a>stripPrefix</a> function drops the given prefix
--   from a list. It returns <a>Nothing</a> if the list did not start with
--   the prefix given, or <a>Just</a> the list after the prefix, if it
--   does.
--   
--   <h5><b>Examples</b></h5>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foobar"
--   Just "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foo"
--   Just ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoo"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoobaz"
--   Nothing
--   </pre>
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]

-- | The <a>group</a> function takes a list and returns a list of lists
--   such that the concatenation of the result is equal to the argument.
--   Moreover, each sublist in the result is non-empty, all elements are
--   equal to the first one, and consecutive equal elements of the input
--   end up in the same element of the output list.
--   
--   <a>group</a> is a special case of <a>groupBy</a>, which allows the
--   programmer to supply their own equality test.
--   
--   It's often preferable to use <tt>Data.List.NonEmpty.</tt><a>group</a>,
--   which provides type-level guarantees of non-emptiness of inner lists.
--   A common idiom to squash repeating elements <a>map</a> <a>head</a>
--   <a>.</a> <a>group</a> is better served by <a>map</a>
--   <tt>Data.List.NonEmpty.</tt><a>head</a> <a>.</a>
--   <tt>Data.List.NonEmpty.</tt><a>group</a> because it avoids partial
--   functions.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; group "Mississippi"
--   ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; group [1, 1, 1, 2, 2, 3, 4, 5, 5]
--   [[1,1,1],[2,2],[3],[4],[5,5]]
--   </pre>
group :: Eq a => [a] -> [[a]]

-- | The <a>inits</a> function returns all initial segments of the
--   argument, shortest first.
--   
--   <a>inits</a> is semantically equivalent to <tt><a>map</a>
--   <a>reverse</a> . <a>scanl</a> (<a>flip</a> (:)) []</tt>, but under the
--   hood uses a queue to amortize costs of <a>reverse</a>.
--   
--   <h4><b>Laziness</b></h4>
--   
--   Note that <a>inits</a> has the following strictness property:
--   <tt>inits (xs ++ _|_) = inits xs ++ _|_</tt>
--   
--   In particular, <tt>inits _|_ = [] : _|_</tt>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; inits "abc"
--   ["","a","ab","abc"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; inits []
--   [[]]
--   </pre>
--   
--   inits is productive on infinite lists:
--   
--   <pre>
--   &gt;&gt;&gt; take 5 $ inits [1..]
--   [[],[1],[1,2],[1,2,3],[1,2,3,4]]
--   </pre>
inits :: [a] -> [[a]]

-- | &lt;math&gt;. The <a>tails</a> function returns all final segments of
--   the argument, longest first.
--   
--   <h4><b>Laziness</b></h4>
--   
--   Note that <a>tails</a> has the following strictness property:
--   <tt>tails _|_ = _|_ : _|_</tt>
--   
--   <pre>
--   &gt;&gt;&gt; tails undefined
--   [*** Exception: Prelude.undefined
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; drop 1 (tails [undefined, 1, 2])
--   [[1, 2], [2], []]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; tails "abc"
--   ["abc","bc","c",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tails [1, 2, 3]
--   [[1,2,3],[2,3],[3],[]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tails []
--   [[]]
--   </pre>
tails :: [a] -> [[a]]

-- | &lt;math&gt;. The <a>isPrefixOf</a> function takes two lists and
--   returns <a>True</a> iff the first list is a prefix of the second.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Hello World!"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Wello Horld!"
--   False
--   </pre>
--   
--   For the result to be <a>True</a>, the first list must be finite;
--   <a>False</a>, however, results from any mismatch:
--   
--   <pre>
--   &gt;&gt;&gt; [0..] `isPrefixOf` [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..] `isPrefixOf` [0..99]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..99] `isPrefixOf` [0..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..] `isPrefixOf` [0..]
--   * Hangs forever *
--   </pre>
--   
--   <a>isPrefixOf</a> shortcuts when the first argument is empty:
--   
--   <pre>
--   &gt;&gt;&gt; isPrefixOf [] undefined
--   True
--   </pre>
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "ld!" `isSuffixOf` "Hello World!"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "World" `isSuffixOf` "Hello World!"
--   False
--   </pre>
--   
--   The second list must be finite; however the first list may be
--   infinite:
--   
--   <pre>
--   &gt;&gt;&gt; [0..] `isSuffixOf` [0..99]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..99] `isSuffixOf` [0..]
--   * Hangs forever *
--   </pre>
isSuffixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isInfixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is contained, wholly and intact, anywhere within
--   the second.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; isInfixOf "Haskell" "I really like Haskell."
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isInfixOf "Ial" "I really like Haskell."
--   False
--   </pre>
--   
--   For the result to be <a>True</a>, the first list must be finite; for
--   the result to be <a>False</a>, the second list must be finite:
--   
--   <pre>
--   &gt;&gt;&gt; [20..50] `isInfixOf` [0..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..] `isInfixOf` [20..50]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..] `isInfixOf` [0..]
--   * Hangs forever *
--   </pre>
isInfixOf :: Eq a => [a] -> [a] -> Bool

-- | <a>elem</a> is the list membership predicate, usually written in infix
--   form, e.g., <tt>x `elem` xs</tt>. For the result to be <a>False</a>,
--   the list must be finite; <a>True</a>, however, results from an element
--   equal to <tt>x</tt> found at a finite index of a finite or infinite
--   list.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2,3,4,5]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [4..]
--   * Hangs forever *
--   </pre>
elem :: Eq a => a -> [a] -> Bool
infix 4 `elem`

-- | <a>notElem</a> is the negation of <a>elem</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2,3,4,5]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [4..]
--   * Hangs forever *
--   </pre>
notElem :: Eq a => a -> [a] -> Bool
infix 4 `notElem`

-- | &lt;math&gt;. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list. For the result to be <a>Nothing</a>, the list must
--   be finite.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 [(1, "first")]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | The <a>find</a> function takes a predicate and a list and returns the
--   first element in the list matching the predicate, or <a>Nothing</a> if
--   there is no such element. For the result to be <a>Nothing</a>, the
--   list must be finite.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; find (&gt; 4) [1..]
--   Just 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; find (&lt; 0) [1..10]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; find ('a' `elem`) ["john", "marcus", "paul"]
--   Just "marcus"
--   </pre>
find :: (a -> Bool) -> [a] -> Maybe a

-- | &lt;math&gt;. <a>filter</a>, applied to a predicate and a list,
--   returns the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter (\l -&gt; length l &gt; 3) ["Hello", ", ", "World", "!"]
--   ["Hello","World"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter (/= 3) [1, 2, 3, 4, 3, 2, 1]
--   [1,2,4,2,1]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | The <a>partition</a> function takes a predicate and a list, and
--   returns the pair of lists of elements which do and do not satisfy the
--   predicate, respectively; i.e.,
--   
--   <pre>
--   partition p xs == (filter p xs, filter (not . p) xs)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; partition (`elem` "aeiou") "Hello World!"
--   ("eoo","Hll Wrld!")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; partition even [1..10]
--   ([2,4,6,8,10],[1,3,5,7,9])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; partition (&lt; 5) [1..10]
--   ([1,2,3,4],[5,6,7,8,9,10])
--   </pre>
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | List index (subscript) operator, starting from 0. Returns
--   <a>Nothing</a> if the index is out of bounds
--   
--   This is the total variant of the partial <a>!!</a> operator.
--   
--   WARNING: This function takes linear time in the index.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !? 0
--   Just 'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !? 2
--   Just 'c'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !? 3
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !? (-1)
--   Nothing
--   </pre>
(!?) :: [a] -> Int -> Maybe a
infixl 9 !?

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
--   
--   WARNING: This function is partial, and should only be used if you are
--   sure that the indexing will not fail. Otherwise, use <a>!?</a>.
--   
--   WARNING: This function takes linear time in the index.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 0
--   'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 2
--   'c'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 3
--   *** Exception: Prelude.!!: index too large
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! (-1)
--   *** Exception: Prelude.!!: negative index
--   </pre>
(!!) :: HasCallStack => [a] -> Int -> a
infixl 9 !!

-- | The <a>elemIndex</a> function returns the index of the first element
--   in the given list which is equal (by <a>==</a>) to the query element,
--   or <a>Nothing</a> if there is no such element. For the result to be
--   <a>Nothing</a>, the list must be finite.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 4 [0..]
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 'o' "haskell"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 0 [1..]
--   * hangs forever *
--   </pre>
elemIndex :: Eq a => a -> [a] -> Maybe Int

-- | The <a>elemIndices</a> function extends <a>elemIndex</a>, by returning
--   the indices of all elements equal to the query element, in ascending
--   order.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; elemIndices 'o' "Hello World"
--   [4,7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elemIndices 1 [1, 2, 3, 1, 2, 3]
--   [0,3]
--   </pre>
elemIndices :: Eq a => a -> [a] -> [Int]

-- | The <a>findIndex</a> function takes a predicate and a list and returns
--   the index of the first element in the list satisfying the predicate,
--   or <a>Nothing</a> if there is no such element. For the result to be
--   <a>Nothing</a>, the list must be finite.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; findIndex isSpace "Hello World!"
--   Just 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findIndex odd [0, 2, 4, 6]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findIndex even [1..]
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findIndex odd [0, 2 ..]
--   * hangs forever *
--   </pre>
findIndex :: (a -> Bool) -> [a] -> Maybe Int

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; findIndices (`elem` "aeiou") "Hello World!"
--   [1,4,7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findIndices (\l -&gt; length l &gt; 3) ["a", "bcde", "fgh", "ijklmnop"]
--   [1,3]
--   </pre>
findIndices :: (a -> Bool) -> [a] -> [Int]

-- | &lt;math&gt;. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; zip [] undefined
--   []
--   
--   &gt;&gt;&gt; zip undefined []
--   *** Exception: Prelude.undefined
--   ...
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; zip [1, 2, 3] ['a', 'b', 'c']
--   [(1,'a'),(2,'b'),(3,'c')]
--   </pre>
--   
--   If one input list is shorter than the other, excess elements of the
--   longer list are discarded, even if one of the lists is infinite:
--   
--   <pre>
--   &gt;&gt;&gt; zip [1] ['a', 'b']
--   [(1,'a')]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zip [1, 2] ['a']
--   [(1,'a')]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zip [] [1..]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zip [1..] []
--   []
--   </pre>
zip :: [a] -> [b] -> [(a, b)]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | The <a>zip4</a> function takes four lists and returns a list of
--   quadruples, analogous to <a>zip</a>. It is capable of list fusion, but
--   it is restricted to its first list argument and its resulting list.
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]

-- | The <a>zip5</a> function takes five lists and returns a list of
--   five-tuples, analogous to <a>zip</a>. It is capable of list fusion,
--   but it is restricted to its first list argument and its resulting
--   list.
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]

-- | The <a>zip6</a> function takes six lists and returns a list of
--   six-tuples, analogous to <a>zip</a>. It is capable of list fusion, but
--   it is restricted to its first list argument and its resulting list.
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]

-- | The <a>zip7</a> function takes seven lists and returns a list of
--   seven-tuples, analogous to <a>zip</a>. It is capable of list fusion,
--   but it is restricted to its first list argument and its resulting
--   list.
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]

-- | &lt;math&gt;. <a>zipWith</a> generalises <a>zip</a> by zipping with
--   the function given as the first argument, instead of a tupling
--   function.
--   
--   <pre>
--   zipWith (,) xs ys == zip xs ys
--   zipWith f [x1,x2,x3..] [y1,y2,y3..] == [f x1 y1, f x2 y2, f x3 y3..]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; let f = undefined
--   
--   &gt;&gt;&gt; zipWith f [] undefined
--   []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
--   
--   <h4><b>Examples</b></h4>
--   
--   <tt><a>zipWith</a> <a>(+)</a></tt> can be applied to two lists to
--   produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (++) ["hello ", "foo"] ["world!", "bar"]
--   ["hello world!","foobar"]
--   </pre>
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | &lt;math&gt;. The <a>zipWith3</a> function takes a function which
--   combines three elements, as well as three lists and returns a list of
--   the function applied to corresponding elements, analogous to
--   <a>zipWith</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
--   
--   <pre>
--   zipWith3 (,,) xs ys zs == zip3 xs ys zs
--   zipWith3 f [x1,x2,x3..] [y1,y2,y3..] [z1,z2,z3..] == [f x1 y1 z1, f x2 y2 z2, f x3 y3 z3..]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; zipWith3 (\x y z -&gt; [x, y, z]) "123" "abc" "xyz"
--   ["1ax","2by","3cz"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zipWith3 (\x y z -&gt; (x * y) + z) [1, 2, 3] [4, 5, 6] [7, 8, 9]
--   [11,18,27]
--   </pre>
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | The <a>zipWith4</a> function takes a function which combines four
--   elements, as well as four lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]

-- | The <a>zipWith5</a> function takes a function which combines five
--   elements, as well as five lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]

-- | The <a>zipWith6</a> function takes a function which combines six
--   elements, as well as six lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]

-- | The <a>zipWith7</a> function takes a function which combines seven
--   elements, as well as seven lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>. It is capable of
--   list fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unzip []
--   ([],[])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unzip [(1, 'a'), (2, 'b')]
--   ([1,2],"ab")
--   </pre>
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists of the respective components, analogous to <a>unzip</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unzip3 []
--   ([],[],[])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unzip3 [(1, 'a', True), (2, 'b', False)]
--   ([1,2],"ab",[True,False])
--   </pre>
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | The <a>unzip4</a> function takes a list of quadruples and returns four
--   lists, analogous to <a>unzip</a>.
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])

-- | The <a>unzip5</a> function takes a list of five-tuples and returns
--   five lists, analogous to <a>unzip</a>.
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])

-- | The <a>unzip6</a> function takes a list of six-tuples and returns six
--   lists, analogous to <a>unzip</a>.
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])

-- | The <a>unzip7</a> function takes a list of seven-tuples and returns
--   seven lists, analogous to <a>unzip</a>.
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])

-- | Splits the argument into a list of <i>lines</i> stripped of their
--   terminating <tt>\n</tt> characters. The <tt>\n</tt> terminator is
--   optional in a final non-empty line of the argument string.
--   
--   When the argument string is empty, or ends in a <tt>\n</tt> character,
--   it can be recovered by passing the result of <a>lines</a> to the
--   <a>unlines</a> function. Otherwise, <a>unlines</a> appends the missing
--   terminating <tt>\n</tt>. This makes <tt>unlines . lines</tt>
--   <i>idempotent</i>:
--   
--   <pre>
--   (unlines . lines) . (unlines . lines) = (unlines . lines)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; lines ""           -- empty input contains no lines
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"         -- single empty line
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"        -- single unterminated line
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"      -- single non-empty line
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"    -- second line is empty
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"   -- second line is unterminated
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n" -- two non-empty lines
--   ["one","two"]
--   </pre>
lines :: String -> [String]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space (as defined by <a>isSpace</a>). This function
--   trims any white spaces at the beginning and at the end.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; words " foo bar "
--   ["foo","bar"]
--   </pre>
words :: String -> [String]

-- | Appends a <tt>\n</tt> character to each input string, then
--   concatenates the results. Equivalent to <tt><tt>foldMap</tt> (s -&gt;
--   s <a>++</a> "\n")</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
--   
--   Note that <tt><a>unlines</a> <a>.</a> <a>lines</a> <a>/=</a>
--   <a>id</a></tt> when the input is not <tt>\n</tt>-terminated:
--   
--   <pre>
--   &gt;&gt;&gt; unlines . lines $ "foo\nbar"
--   "foo\nbar\n"
--   </pre>
unlines :: [String] -> String

-- | <a>unwords</a> joins words with separating spaces (U+0020 SPACE).
--   
--   <a>unwords</a> is neither left nor right inverse of <a>words</a>:
--   
--   <pre>
--   &gt;&gt;&gt; words (unwords [" "])
--   []
--   
--   &gt;&gt;&gt; unwords (words "foo\nbar")
--   "foo bar"
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["foo", "bar", "", "baz"]
--   "foo bar  baz"
--   </pre>
unwords :: [String] -> String

-- | &lt;math&gt;. The <a>nub</a> function removes duplicate elements from
--   a list. In particular, it keeps only the first occurrence of each
--   element. (The name <a>nub</a> means `essence'.) It is a special case
--   of <a>nubBy</a>, which allows the programmer to supply their own
--   equality test.
--   
--   If there exists <tt>instance Ord a</tt>, it's faster to use
--   <tt>nubOrd</tt> from the <tt>containers</tt> package (<a>link to the
--   latest online documentation</a>), which takes only &lt;math&gt; time
--   where <tt>d</tt> is the number of distinct elements in the list.
--   
--   Another approach to speed up <a>nub</a> is to use <a>map</a>
--   <tt>Data.List.NonEmpty.</tt><a>head</a> .
--   <tt>Data.List.NonEmpty.</tt><a>group</a> . <a>sort</a>, which takes
--   &lt;math&gt; time, requires <tt>instance Ord a</tt> and doesn't
--   preserve the order.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nub [1,2,3,4,3,2,1,2,4,3,5]
--   [1,2,3,4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nub "hello, world!"
--   "helo, wrd!"
--   </pre>
nub :: Eq a => [a] -> [a]

-- | &lt;math&gt;. <a>delete</a> <tt>x</tt> removes the first occurrence of
--   <tt>x</tt> from its list argument.
--   
--   It is a special case of <a>deleteBy</a>, which allows the programmer
--   to supply their own equality test.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; delete 'a' "banana"
--   "bnana"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; delete "not" ["haskell", "is", "not", "awesome"]
--   ["haskell","is","awesome"]
--   </pre>
delete :: Eq a => a -> [a] -> [a]

-- | The <a>\\</a> function is list difference (non-associative). In the
--   result of <tt>xs</tt> <a>\\</a> <tt>ys</tt>, the first occurrence of
--   each element of <tt>ys</tt> in turn (if any) has been removed from
--   <tt>xs</tt>. Thus <tt>(xs ++ ys) \\ xs == ys</tt>.
--   
--   It is a special case of <a>deleteFirstsBy</a>, which allows the
--   programmer to supply their own equality test.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello World!" \\ "ell W"
--   "Hoorld!"
--   </pre>
--   
--   The second list must be finite, but the first may be infinite.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 ([0..] \\ [2..4])
--   [0,1,5,6,7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 5 ([0..] \\ [2..])
--   * Hangs forever *
--   </pre>
(\\) :: Eq a => [a] -> [a] -> [a]
infix 5 \\

-- | The <a>union</a> function returns the list union of the two lists. It
--   is a special case of <a>unionBy</a>, which allows the programmer to
--   supply their own equality test.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "dog" `union` "cow"
--   "dogcw"
--   </pre>
--   
--   If equal elements are present in both lists, an element from the first
--   list will be used. If the second list contains equal elements, only
--   the first one will be retained:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Semigroup(Arg(..))
--   
--   &gt;&gt;&gt; union [Arg () "dog"] [Arg () "cow"]
--   [Arg () "dog"]
--   
--   &gt;&gt;&gt; union [] [Arg () "dog", Arg () "cow"]
--   [Arg () "dog"]
--   </pre>
--   
--   However if the first list contains duplicates, so will the result:
--   
--   <pre>
--   &gt;&gt;&gt; "coot" `union` "duck"
--   "cootduk"
--   
--   &gt;&gt;&gt; "duck" `union` "coot"
--   "duckot"
--   </pre>
--   
--   <a>union</a> is productive even if both arguments are infinite.
--   
--   <pre>
--   &gt;&gt;&gt; [0, 2 ..] `union` [1, 3 ..]
--   [0,2,4,6,8,10,12..
--   </pre>
union :: Eq a => [a] -> [a] -> [a]

-- | The <a>intersect</a> function takes the list intersection of two
--   lists. It is a special case of <a>intersectBy</a>, which allows the
--   programmer to supply their own equality test.
--   
--   <h5><b>Examples</b></h5>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] `intersect` [2,4,6,8]
--   [2,4]
--   </pre>
--   
--   If equal elements are present in both lists, an element from the first
--   list will be used, and all duplicates from the second list quashed:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Semigroup
--   
--   &gt;&gt;&gt; intersect [Arg () "dog"] [Arg () "cow", Arg () "cat"]
--   [Arg () "dog"]
--   </pre>
--   
--   However if the first list contains duplicates, so will the result.
--   
--   <pre>
--   &gt;&gt;&gt; "coot" `intersect` "heron"
--   "oo"
--   
--   &gt;&gt;&gt; "heron" `intersect` "coot"
--   "o"
--   </pre>
--   
--   If the second list is infinite, <a>intersect</a> either hangs or
--   returns its first argument in full. Otherwise if the first list is
--   infinite, <a>intersect</a> might be productive:
--   
--   <pre>
--   &gt;&gt;&gt; intersect [100..] [0..]
--   [100,101,102,103...
--   
--   &gt;&gt;&gt; intersect [0] [1..]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; intersect [1..] [0]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; intersect (cycle [1..3]) [2]
--   [2,2,2,2...
--   </pre>
intersect :: Eq a => [a] -> [a] -> [a]

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   Elements are arranged from lowest to highest, keeping duplicates in
--   the order they appeared in the input.
--   
--   The argument must be finite.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sort [1,6,4,3,2,5]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sort "haskell"
--   "aehklls"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Semigroup(Arg(..))
--   
--   &gt;&gt;&gt; sort [Arg ":)" 0, Arg ":D" 0, Arg ":)" 1, Arg ":3" 0, Arg ":D" 1]
--   [Arg ":)" 0,Arg ":)" 1,Arg ":3" 0,Arg ":D" 0,Arg ":D" 1]
--   </pre>
sort :: Ord a => [a] -> [a]

-- | Sort a list by comparing the results of a key function applied to each
--   element. <tt><a>sortOn</a> f</tt> is equivalent to <tt><a>sortBy</a>
--   (<a>comparing</a> f)</tt>, but has the performance advantage of only
--   evaluating <tt>f</tt> once for each element in the input list. This is
--   called the decorate-sort-undecorate paradigm, or <a>Schwartzian
--   transform</a>.
--   
--   Elements are arranged from lowest to highest, keeping duplicates in
--   the order they appeared in the input.
--   
--   The argument must be finite.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sortOn fst [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sortOn length ["jim", "creed", "pam", "michael", "dwight", "kevin"]
--   ["jim","pam","creed","kevin","dwight","michael"]
--   </pre>
--   
--   <h4><b>Performance notes</b></h4>
--   
--   This function minimises the projections performed, by materialising
--   the projections in an intermediate list.
--   
--   For trivial projections, you should prefer using <a>sortBy</a> with
--   <a>comparing</a>, for example:
--   
--   <pre>
--   &gt;&gt;&gt; sortBy (comparing fst) [(3, 1), (2, 2), (1, 3)]
--   [(1,3),(2,2),(3,1)]
--   </pre>
--   
--   Or, for the exact same API as <a>sortOn</a>, you can use `sortBy .
--   comparing`:
--   
--   <pre>
--   &gt;&gt;&gt; (sortBy . comparing) fst [(3, 1), (2, 2), (1, 3)]
--   [(1,3),(2,2),(3,1)]
--   </pre>
sortOn :: Ord b => (a -> b) -> [a] -> [a]

-- | &lt;math&gt;. The <a>insert</a> function takes an element and a list
--   and inserts the element into the list at the first position where it
--   is less than or equal to the next element. In particular, if the list
--   is sorted before the call, the result will also be sorted. It is a
--   special case of <a>insertBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; insert (-1) [1, 2, 3]
--   [-1,1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; insert 'd' "abcefg"
--   "abcdefg"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; insert 4 [1, 2, 3, 5, 6, 7]
--   [1,2,3,4,5,6,7]
--   </pre>
insert :: Ord a => a -> [a] -> [a]

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded
--   <a>(==)</a> function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nubBy (\x y -&gt; mod x 3 == mod y 3) [1,2,4,5,6]
--   [1,2,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nubBy (/=) [2, 7, 1, 8, 2, 8, 1, 8, 2, 8]
--   [2,2,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nubBy (&gt;) [1, 2, 3, 2, 1, 5, 4, 5, 3, 2]
--   [1,2,3,5,5]
--   </pre>
nubBy :: (a -> a -> Bool) -> [a] -> [a]

-- | &lt;math&gt;. The <a>deleteBy</a> function behaves like <a>delete</a>,
--   but takes a user-supplied equality predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; deleteBy (&lt;=) 4 [1..10]
--   [1,2,3,5,6,7,8,9,10]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; deleteBy (/=) 5 [5, 5, 4, 3, 5, 2]
--   [5,5,3,5,2]
--   </pre>
deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]

-- | The <a>deleteFirstsBy</a> function takes a predicate and two lists and
--   returns the first list with the first occurrence of each element of
--   the second list removed. This is the non-overloaded version of
--   <a>(\\)</a>.
--   
--   <pre>
--   (\\) == deleteFirstsBy (==)
--   </pre>
--   
--   The second list must be finite, but the first may be infinite.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; deleteFirstsBy (&gt;) [1..10] [3, 4, 5]
--   [4,5,6,7,8,9,10]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; deleteFirstsBy (/=) [1..10] [1, 3, 5]
--   [4,5,6,7,8,9,10]
--   </pre>
deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>unionBy</a> function is the non-overloaded version of
--   <a>union</a>. Both arguments may be infinite.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unionBy (&gt;) [3, 4, 5] [1, 2, 3, 4, 5, 6]
--   [3,4,5,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Semigroup (Arg(..))
--   
--   &gt;&gt;&gt; unionBy (/=) [Arg () "Saul"] [Arg () "Kim"]
--   [Arg () "Saul", Arg () "Kim"]
--   </pre>
unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>intersectBy</a> function is the non-overloaded version of
--   <a>intersect</a>. It is productive for infinite arguments only if the
--   first one is a subset of the second.
intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
--   
--   When a supplied relation is not transitive, it is important to
--   remember that equality is checked against the first element in the
--   group, not against the nearest neighbour:
--   
--   <pre>
--   &gt;&gt;&gt; groupBy (\a b -&gt; b - a &lt; 5) [0..19]
--   [[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19]]
--   </pre>
--   
--   It's often preferable to use
--   <tt>Data.List.NonEmpty.</tt><a>groupBy</a>, which provides type-level
--   guarantees of non-emptiness of inner lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; groupBy (/=) [1, 1, 1, 2, 3, 1, 4, 4, 5]
--   [[1],[1],[1,2,3],[1,4,4,5]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; groupBy (&gt;) [1, 3, 5, 1, 4, 2, 6, 5, 4]
--   [[1],[3],[5,1,4,2],[6,5,4]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; groupBy (const not) [True, False, True, False, False, False, True]
--   [[True,False],[True,False,False,False],[True]]
--   </pre>
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]

-- | The <a>sortBy</a> function is the non-overloaded version of
--   <a>sort</a>. The argument must be finite.
--   
--   The supplied comparison relation is supposed to be reflexive and
--   antisymmetric, otherwise, e. g., for <tt>_ _ -&gt; GT</tt>, the
--   ordered list simply does not exist. The relation is also expected to
--   be transitive: if it is not then <a>sortBy</a> might fail to find an
--   ordered permutation, even if it exists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sortBy (\(a,_) (b,_) -&gt; compare a b) [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | &lt;math&gt;. The non-overloaded version of <a>insert</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; insertBy (\x y -&gt; compare (length x) (length y)) [1, 2] [[1], [1, 2, 3], [1, 2, 3, 4]]
--   [[1],[1,2],[1,2,3],[1,2,3,4]]
--   </pre>
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]

-- | The <a>maximumBy</a> function takes a comparison function and a list
--   and returns the greatest element of the list by the comparison
--   function. The list must be finite and non-empty. List order is used as
--   a tie-breaker: if there are multiple greatest elements, the last of
--   them is chosen.
--   
--   <h4><b>Examples</b></h4>
--   
--   We can use this to find the longest entry of a list:
--   
--   <pre>
--   &gt;&gt;&gt; maximumBy (\x y -&gt; compare (length x) (length y)) ["Hello", "World", "!", "Longest", "bar"]
--   "Longest"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimumBy (\(a, b) (c, d) -&gt; compare (abs (a - b)) (abs (c - d))) [(10, 15), (1, 2), (3, 5)]
--   (10, 15)
--   </pre>
maximumBy :: (a -> a -> Ordering) -> [a] -> a

-- | The <a>minimumBy</a> function takes a comparison function and a list
--   and returns the least element of the list by the comparison function.
--   The list must be finite and non-empty. List order is used as a
--   tie-breaker: if there are multiple least elements, the first of them
--   is chosen.
--   
--   <h4><b>Examples</b></h4>
--   
--   We can use this to find the shortest entry of a list:
--   
--   <pre>
--   &gt;&gt;&gt; minimumBy (\x y -&gt; compare (length x) (length y)) ["Hello", "World", "!", "Longest", "bar"]
--   "!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimumBy (\(a, b) (c, d) -&gt; compare (abs (a - b)) (abs (c - d))) [(10, 15), (1, 2), (3, 5)]
--   (1, 2)
--   </pre>
minimumBy :: (a -> a -> Ordering) -> [a] -> a

-- | &lt;math&gt;. The <a>genericLength</a> function is an overloaded
--   version of <a>length</a>. In particular, instead of returning an
--   <a>Int</a>, it returns any type which is an instance of <a>Num</a>. It
--   is, however, less efficient than <a>length</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; genericLength [1, 2, 3] :: Int
--   3
--   
--   &gt;&gt;&gt; genericLength [1, 2, 3] :: Float
--   3.0
--   </pre>
--   
--   Users should take care to pick a return type that is wide enough to
--   contain the full length of the list. If the width is insufficient, the
--   overflow behaviour will depend on the <tt>(+)</tt> implementation in
--   the selected <a>Num</a> instance. The following example overflows
--   because the actual list length of 200 lies outside of the
--   <tt>Int8</tt> range of <tt>-128..127</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; genericLength [1..200] :: Int8
--   -56
--   </pre>
genericLength :: Num i => [a] -> i

-- | The <a>genericTake</a> function is an overloaded version of
--   <a>take</a>, which accepts any <a>Integral</a> value as the number of
--   elements to take.
genericTake :: Integral i => i -> [a] -> [a]

-- | The <a>genericDrop</a> function is an overloaded version of
--   <a>drop</a>, which accepts any <a>Integral</a> value as the number of
--   elements to drop.
genericDrop :: Integral i => i -> [a] -> [a]

-- | The <a>genericSplitAt</a> function is an overloaded version of
--   <a>splitAt</a>, which accepts any <a>Integral</a> value as the
--   position at which to split.
genericSplitAt :: Integral i => i -> [a] -> ([a], [a])

-- | The <a>genericIndex</a> function is an overloaded version of
--   <a>!!</a>, which accepts any <a>Integral</a> value as the index.
genericIndex :: Integral i => [a] -> i -> a

-- | The <a>genericReplicate</a> function is an overloaded version of
--   <a>replicate</a>, which accepts any <a>Integral</a> value as the
--   number of repetitions to make.
genericReplicate :: Integral i => i -> a -> [a]


-- | Class of data structures that can be folded to a summary value.
module GHC.Internal.Data.Foldable

-- | The Foldable class represents data structures that can be reduced to a
--   summary value one element at a time. Strict left-associative folds are
--   a good fit for space-efficient reduction, while lazy right-associative
--   folds are a good fit for corecursive iteration, or for folds that
--   short-circuit after processing an initial subsequence of the
--   structure's elements.
--   
--   Instances can be derived automatically by enabling the
--   <tt>DeriveFoldable</tt> extension. For example, a derived instance for
--   a binary tree might be:
--   
--   <pre>
--   {-# LANGUAGE DeriveFoldable #-}
--   data Tree a = Empty
--               | Leaf a
--               | Node (Tree a) a (Tree a)
--       deriving Foldable
--   </pre>
--   
--   A more detailed description can be found in the <b>Overview</b>
--   section of <a>Data.Foldable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Foldable#laws</a>.
class Foldable (t :: Type -> Type)

-- | Given a structure with elements whose type is a <a>Monoid</a>, combine
--   them via the monoid's <tt>(<a>&lt;&gt;</a>)</tt> operator. This fold
--   is right-associative and lazy in the accumulator. When you need a
--   strict left-associative fold, use <a>foldMap'</a> instead, with
--   <a>id</a> as the map.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fold [[1, 2, 3], [4, 5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fold $ Node (Leaf (Sum 1)) (Sum 3) (Leaf (Sum 5))
--   Sum {getSum = 9}
--   </pre>
--   
--   Folds of unbounded structures do not terminate when the monoid's
--   <tt>(<a>&lt;&gt;</a>)</tt> operator is strict:
--   
--   <pre>
--   &gt;&gt;&gt; fold (repeat Nothing)
--   * Hangs forever *
--   </pre>
--   
--   Lazy corecursive folds of unbounded structures are fine:
--   
--   <pre>
--   &gt;&gt;&gt; take 12 $ fold $ map (\i -&gt; [i..i+2]) [0..]
--   [0,1,2,1,2,3,2,3,4,3,4,5]
--   
--   &gt;&gt;&gt; sum $ take 4000000 $ fold $ map (\i -&gt; [i..i+2]) [0..]
--   2666668666666
--   </pre>
fold :: (Foldable t, Monoid m) => t m -> m

-- | Map each element of the structure into a monoid, and combine the
--   results with <tt>(<a>&lt;&gt;</a>)</tt>. This fold is
--   right-associative and lazy in the accumulator. For strict
--   left-associative folds consider <a>foldMap'</a> instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Sum [1, 3, 5]
--   Sum {getSum = 9}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Product [1, 3, 5]
--   Product {getProduct = 15}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap (replicate 3) [1, 2, 3]
--   [1,1,1,2,2,2,3,3,3]
--   </pre>
--   
--   When a Monoid's <tt>(<a>&lt;&gt;</a>)</tt> is lazy in its second
--   argument, <a>foldMap</a> can return a result even from an unbounded
--   structure. For example, lazy accumulation enables
--   <a>Data.ByteString.Builder</a> to efficiently serialise large data
--   structures and produce the output incrementally:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.ByteString.Lazy as L
--   
--   &gt;&gt;&gt; import qualified Data.ByteString.Builder as B
--   
--   &gt;&gt;&gt; let bld :: Int -&gt; B.Builder; bld i = B.intDec i &lt;&gt; B.word8 0x20
--   
--   &gt;&gt;&gt; let lbs = B.toLazyByteString $ foldMap bld [0..]
--   
--   &gt;&gt;&gt; L.take 64 lbs
--   "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24"
--   </pre>
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | A left-associative variant of <a>foldMap</a> that is strict in the
--   accumulator. Use this method for strict reduction when partial results
--   are merged via <tt>(<a>&lt;&gt;</a>)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Define a <a>Monoid</a> over finite bit strings under <tt>xor</tt>. Use
--   it to strictly compute the <tt>xor</tt> of a list of <a>Int</a>
--   values.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XGeneralizedNewtypeDeriving
--   
--   &gt;&gt;&gt; import Data.Bits (Bits, FiniteBits, xor, zeroBits)
--   
--   &gt;&gt;&gt; import Data.Foldable (foldMap')
--   
--   &gt;&gt;&gt; import Numeric (showHex)
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; newtype X a = X a deriving (Eq, Bounded, Enum, Bits, FiniteBits)
--   
--   &gt;&gt;&gt; instance Bits a =&gt; Semigroup (X a) where X a &lt;&gt; X b = X (a `xor` b)
--   
--   &gt;&gt;&gt; instance Bits a =&gt; Monoid    (X a) where mempty     = X zeroBits
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; let bits :: [Int]; bits = [0xcafe, 0xfeed, 0xdeaf, 0xbeef, 0x5411]
--   
--   &gt;&gt;&gt; (\ (X a) -&gt; showString "0x" . showHex a $ "") $ foldMap' X bits
--   "0x42"
--   </pre>
foldMap' :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure, lazy in the accumulator.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that since the head of the resulting expression is produced by an
--   application of the operator to the first element of the list, given an
--   operator lazy in its right argument, <a>foldr</a> can produce a
--   terminating expression from an unbounded list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False [False, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (\c acc -&gt; acc ++ [c]) "foo" ['a', 'b', 'c', 'd']
--   "foodcba"
--   </pre>
--   
--   <h5>Infinite structures</h5>
--   
--   ⚠️ Applying <a>foldr</a> to infinite structures usually doesn't
--   terminate.
--   
--   It may still terminate under one of the following conditions:
--   
--   <ul>
--   <li>the folding function is short-circuiting</li>
--   <li>the folding function is lazy on its second argument</li>
--   </ul>
--   
--   <h6>Short-circuiting</h6>
--   
--   <tt>(<a>||</a>)</tt> short-circuits on <a>True</a> values, so the
--   following terminates because there is a <a>True</a> value finitely far
--   from the left side:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (True : repeat False)
--   True
--   </pre>
--   
--   But the following doesn't terminate:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (repeat False ++ [True])
--   * Hangs forever *
--   </pre>
--   
--   <h6>Laziness in the second argument</h6>
--   
--   Applying <a>foldr</a> to infinite structures terminates when the
--   operator is lazy in its second argument (the initial accumulator is
--   never used in this case, and so could be left <a>undefined</a>, but
--   <tt>[]</tt> is more clear):
--   
--   <pre>
--   &gt;&gt;&gt; take 5 $ foldr (\i acc -&gt; i : fmap (+3) acc) [] (repeat 1)
--   [1,4,7,10,13]
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | <a>foldr'</a> is a variant of <a>foldr</a> that performs strict
--   reduction from right to left, i.e. starting with the right-most
--   element. The input structure <i>must</i> be finite, otherwise
--   <a>foldr'</a> runs out of space (<i>diverges</i>).
--   
--   If you want a strict right fold in constant space, you need a
--   structure that supports faster than <i>O(n)</i> access to the
--   right-most element, such as <tt>Seq</tt> from the <tt>containers</tt>
--   package.
--   
--   This method does not run in constant space for structures such as
--   lists that don't support efficient right-to-left iteration and so
--   require <i>O(n)</i> space to perform right-to-left reduction. Use of
--   this method with such a structure is a hint that the chosen structure
--   may be a poor fit for the task at hand. If the order in which the
--   elements are combined is not important, use <a>foldl'</a> instead.
foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure, lazy in the accumulator. This is
--   rarely what you want, but can work well for structures with efficient
--   right-to-left sequencing and an operator that is lazy in its left
--   argument.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. Like all left-associative folds,
--   <a>foldl</a> will diverge if given an infinite list.
--   
--   If you want an efficient strict left-fold, you probably want to use
--   <a>foldl'</a> instead of <a>foldl</a>. The reason for this is that the
--   latter does not force the <i>inner</i> results (e.g. <tt>z `f` x1</tt>
--   in the above example) before applying them to the operator (e.g. to
--   <tt>(`f` x2)</tt>). This results in a thunk chain <i>O(n)</i> elements
--   long, which then must be evaluated from the outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to:
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   The first example is a strict fold, which in practice is best
--   performed with <a>foldl'</a>.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (+) 42 [1,2,3,4]
--   52
--   </pre>
--   
--   Though the result below is lazy, the input is reversed before
--   prepending it to the initial accumulator, so corecursion begins only
--   after traversing the entire input string.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\acc c -&gt; c : acc) "abcd" "efgh"
--   "hgfeabcd"
--   </pre>
--   
--   A left fold of a structure that is infinite on the right cannot
--   terminate, even when for any finite input the fold just returns the
--   initial accumulator:
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\a _ -&gt; a) 0 $ repeat 1
--   * Hangs forever *
--   </pre>
--   
--   WARNING: When it comes to lists, you always want to use either
--   <a>foldl'</a> or <a>foldr</a> instead.
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to Weak Head Normal
--   Form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite structure to a single strict result (e.g. <a>sum</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl' f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) []
--   Exception: Prelude.foldr1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) Nothing
--   *** Exception: foldr1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (-) [1..4]
--   -2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) []
--   *** Exception: Prelude.foldl1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) Nothing
--   *** Exception: foldl1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (-) [1..4]
--   -8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | List of elements of a structure, from left to right. If the entire
--   list is intended to be reduced via a fold, just fold the structure
--   directly bypassing the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; toList Nothing
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList (Just 42)
--   [42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList (Left "foo")
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList (Node (Leaf 5) 17 (Node Empty 12 (Leaf 8)))
--   [5,17,12,8]
--   </pre>
--   
--   For lists, <a>toList</a> is the identity:
--   
--   <pre>
--   &gt;&gt;&gt; toList [1, 2, 3]
--   [1,2,3]
--   </pre>
toList :: Foldable t => t a -> [a]

-- | Test whether the structure is empty. The default implementation is
--   Left-associative and lazy in both the initial element and the
--   accumulator. Thus optimised for structures where the first element can
--   be accessed in constant time. Structures where this is not the case
--   should have a non-default implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; null []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null [1]
--   False
--   </pre>
--   
--   <a>null</a> is expected to terminate even for infinite structures. The
--   default implementation terminates provided the structure is bounded on
--   the left (there is a leftmost element).
--   
--   <pre>
--   &gt;&gt;&gt; null [1..]
--   False
--   </pre>
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation just counts elements starting with the
--   leftmost. Instances for structures that can compute the element count
--   faster than via element-by-element counting, should provide a
--   specialised implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; length []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length ['a', 'b', 'c']
--   3
--   
--   &gt;&gt;&gt; length [1..]
--   * Hangs forever *
--   </pre>
length :: Foldable t => t a -> Int

-- | Does the element occur in the structure?
--   
--   Note: <a>elem</a> is often used in infix form.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2,3,4,5]
--   True
--   </pre>
--   
--   For infinite structures, the default implementation of <a>elem</a>
--   terminates if the sought-after value exists at a finite distance from
--   the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The largest element of a non-empty structure. This function is
--   equivalent to <tt><a>foldr1</a> <a>max</a></tt>, and its behavior on
--   structures with multiple largest elements depends on the relevant
--   implementation of <a>max</a>. For the default implementation of
--   <a>max</a> (<tt>max x y = if x &lt;= y then y else x</tt>), structure
--   order is used as a tie-breaker: if there are multiple largest
--   elements, the rightmost of them is chosen (this is equivalent to
--   <tt><a>maximumBy</a> <a>compare</a></tt>).
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the maximum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximum [1..10]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum []
--   *** Exception: Prelude.maximum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum Nothing
--   *** Exception: maximum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximum :: (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure. This function is
--   equivalent to <tt><a>foldr1</a> <a>min</a></tt>, and its behavior on
--   structures with multiple largest elements depends on the relevant
--   implementation of <a>min</a>. For the default implementation of
--   <a>min</a> (<tt>min x y = if x &lt;= y then x else y</tt>), structure
--   order is used as a tie-breaker: if there are multiple least elements,
--   the leftmost of them is chosen (this is equivalent to
--   <tt><a>minimumBy</a> <a>compare</a></tt>).
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the minimum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimum [1..10]
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum []
--   *** Exception: Prelude.minimum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum Nothing
--   *** Exception: minimum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimum :: (Foldable t, Ord a) => t a -> a

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; sum []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..10]
--   55
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [4.1, 2.0, 1.7]
--   7.8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..]
--   * Hangs forever *
--   </pre>
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; product []
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..10]
--   3628800
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [4.1, 2.0, 1.7]
--   13.939999999999998
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..]
--   * Hangs forever *
--   </pre>
product :: (Foldable t, Num a) => t a -> a
infix 4 `elem`

-- | Right-to-left monadic fold over the elements of a structure.
--   
--   Given a structure <tt>t</tt> with elements <tt>(a, b, c, ..., x,
--   y)</tt>, the result of a fold with an operator function <tt>f</tt> is
--   equivalent to:
--   
--   <pre>
--   foldrM f z t = do
--       yy &lt;- f y z
--       xx &lt;- f x yy
--       ...
--       bb &lt;- f b cc
--       aa &lt;- f a bb
--       return aa -- Just @return z@ when the structure is empty
--   </pre>
--   
--   For a Monad <tt>m</tt>, given two functions <tt>f1 :: a -&gt; m b</tt>
--   and <tt>f2 :: b -&gt; m c</tt>, their Kleisli composition <tt>(f1
--   &gt;=&gt; f2) :: a -&gt; m c</tt> is defined by:
--   
--   <pre>
--   (f1 &gt;=&gt; f2) a = f1 a &gt;&gt;= f2
--   </pre>
--   
--   Another way of thinking about <tt>foldrM</tt> is that it amounts to an
--   application to <tt>z</tt> of a Kleisli composition:
--   
--   <pre>
--   foldrM f z t = f y &gt;=&gt; f x &gt;=&gt; ... &gt;=&gt; f b &gt;=&gt; f a $ z
--   </pre>
--   
--   The monadic effects of <tt>foldrM</tt> are sequenced from right to
--   left, and e.g. folds of infinite lists will diverge.
--   
--   If at some step the bind operator <tt>(<a>&gt;&gt;=</a>)</tt>
--   short-circuits (as with, e.g., <a>mzero</a> in a <a>MonadPlus</a>),
--   the evaluated effects will be from a tail of the element sequence. If
--   you want to evaluate the monadic effects in left-to-right order, or
--   perhaps be able to short-circuit after an initial sequence of
--   elements, you'll need to use <a>foldlM</a> instead.
--   
--   If the monadic effects don't short-circuit, the outermost application
--   of <tt>f</tt> is to the leftmost element <tt>a</tt>, so that, ignoring
--   effects, the result looks like a right fold:
--   
--   <pre>
--   a `f` (b `f` (c `f` (... (x `f` (y `f` z))))).
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let f i acc = do { print i ; return $ i : acc }
--   
--   &gt;&gt;&gt; foldrM f [] [0..3]
--   3
--   2
--   1
--   0
--   [0,1,2,3]
--   </pre>
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b

-- | Left-to-right monadic fold over the elements of a structure.
--   
--   Given a structure <tt>t</tt> with elements <tt>(a, b, ..., w, x,
--   y)</tt>, the result of a fold with an operator function <tt>f</tt> is
--   equivalent to:
--   
--   <pre>
--   foldlM f z t = do
--       aa &lt;- f z a
--       bb &lt;- f aa b
--       ...
--       xx &lt;- f ww x
--       yy &lt;- f xx y
--       return yy -- Just @return z@ when the structure is empty
--   </pre>
--   
--   For a Monad <tt>m</tt>, given two functions <tt>f1 :: a -&gt; m b</tt>
--   and <tt>f2 :: b -&gt; m c</tt>, their Kleisli composition <tt>(f1
--   &gt;=&gt; f2) :: a -&gt; m c</tt> is defined by:
--   
--   <pre>
--   (f1 &gt;=&gt; f2) a = f1 a &gt;&gt;= f2
--   </pre>
--   
--   Another way of thinking about <tt>foldlM</tt> is that it amounts to an
--   application to <tt>z</tt> of a Kleisli composition:
--   
--   <pre>
--   foldlM f z t =
--       flip f a &gt;=&gt; flip f b &gt;=&gt; ... &gt;=&gt; flip f x &gt;=&gt; flip f y $ z
--   </pre>
--   
--   The monadic effects of <tt>foldlM</tt> are sequenced from left to
--   right.
--   
--   If at some step the bind operator <tt>(<a>&gt;&gt;=</a>)</tt>
--   short-circuits (as with, e.g., <a>mzero</a> in a <a>MonadPlus</a>),
--   the evaluated effects will be from an initial segment of the element
--   sequence. If you want to evaluate the monadic effects in right-to-left
--   order, or perhaps be able to short-circuit after processing a tail of
--   the sequence of elements, you'll need to use <a>foldrM</a> instead.
--   
--   If the monadic effects don't short-circuit, the outermost application
--   of <tt>f</tt> is to the rightmost element <tt>y</tt>, so that,
--   ignoring effects, the result looks like a left fold:
--   
--   <pre>
--   ((((z `f` a) `f` b) ... `f` w) `f` x) `f` y
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let f a e = do { print e ; return $ e : a }
--   
--   &gt;&gt;&gt; foldlM f [] [0..3]
--   0
--   1
--   2
--   3
--   [3,2,1,0]
--   </pre>
foldlM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Map each element of a structure to an <a>Applicative</a> action,
--   evaluate these actions from left to right, and ignore the results. For
--   a version that doesn't ignore the results see <a>traverse</a>.
--   
--   <a>traverse_</a> is just like <a>mapM_</a>, but generalised to
--   <a>Applicative</a> actions.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; traverse_ print ["Hello", "world", "!"]
--   "Hello"
--   "world"
--   "!"
--   </pre>
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()

-- | <a>for_</a> is <a>traverse_</a> with its arguments flipped. For a
--   version that doesn't ignore the results see <a>for</a>. This is
--   <a>forM_</a> generalised to <a>Applicative</a> actions.
--   
--   <a>for_</a> is just like <a>forM_</a>, but generalised to
--   <a>Applicative</a> actions.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; for_ [1..4] print
--   1
--   2
--   3
--   4
--   </pre>
for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()

-- | Evaluate each action in the structure from left to right, and ignore
--   the results. For a version that doesn't ignore the results see
--   <a>sequenceA</a>.
--   
--   <a>sequenceA_</a> is just like <a>sequence_</a>, but generalised to
--   <a>Applicative</a> actions.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA_ [print "Hello", print "world", print "!"]
--   "Hello"
--   "world"
--   "!"
--   </pre>
sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()

-- | The sum of a collection of actions using <a>(&lt;|&gt;)</a>,
--   generalizing <a>concat</a>.
--   
--   <a>asum</a> is just like <a>msum</a>, but generalised to
--   <a>Alternative</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; asum [Just "Hello", Nothing, Just "World"]
--   Just "Hello"
--   </pre>
asum :: (Foldable t, Alternative f) => t (f a) -> f a

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   <a>mapM_</a> is just like <a>traverse_</a>, but specialised to monadic
--   actions.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   <a>forM_</a> is just like <a>for_</a>, but specialised to monadic
--   actions.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   <a>sequence_</a> is just like <a>sequenceA_</a>, but specialised to
--   monadic actions.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | The sum of a collection of actions using <a>(&lt;|&gt;)</a>,
--   generalizing <a>concat</a>.
--   
--   <a>msum</a> is just like <a>asum</a>, but specialised to
--   <a>MonadPlus</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage, using the <a>MonadPlus</a> instance for <a>Maybe</a>:
--   
--   <pre>
--   &gt;&gt;&gt; msum [Just "Hello", Nothing, Just "World"]
--   Just "Hello"
--   </pre>
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a

-- | The concatenation of all the elements of a container of lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concat (Just [1, 2, 3])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat (Left 42)
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat [[1, 2, 3], [4, 5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
concat :: Foldable t => t [a] -> [a]

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) [[1..], [10..], [100..], [1000..]]
--   [1,2,3,10,11,12,100,101,102,1000,1001,1002]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) (Just [1..])
--   [1,2,3]
--   </pre>
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; and []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True, True, False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,...
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (repeat True)
--   * Hangs forever *
--   </pre>
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; or []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (True : repeat False) -- Infinite list [True,False,False,False,...
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (repeat False)
--   * Hangs forever *
--   </pre>
or :: Foldable t => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2,3,4,5]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [0, -1..]
--   * Hangs forever *
--   </pre>
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2,3,4,5]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [4..]
--   * Hangs forever *
--   </pre>
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | The largest element of a non-empty structure with respect to the given
--   comparison function. Structure order is used as a tie-breaker: if
--   there are multiple largest elements, the rightmost of them is chosen.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximumBy (compare `on` length) ["Hello", "World", "!", "Longest", "bar"]
--   "Longest"
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The least element of a non-empty structure with respect to the given
--   comparison function. Structure order is used as a tie-breaker: if
--   there are multiple least elements, the leftmost of them is chosen.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimumBy (compare `on` length) ["Hello", "World", "!", "Longest", "bar"]
--   "!"
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | <a>notElem</a> is the negation of <a>elem</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2,3,4,5]
--   False
--   </pre>
--   
--   For infinite structures, <a>notElem</a> terminates if the value exists
--   at a finite distance from the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | The <a>find</a> function takes a predicate and a structure and returns
--   the leftmost element of the structure matching the predicate, or
--   <a>Nothing</a> if there is no such element.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; find (&gt; 42) [0, 5..]
--   Just 45
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; find (&gt; 12) [1..7]
--   Nothing
--   </pre>
find :: Foldable t => (a -> Bool) -> t a -> Maybe a
instance (GHC.Internal.Data.Foldable.Foldable f, GHC.Internal.Data.Foldable.Foldable g) => GHC.Internal.Data.Foldable.Foldable (f GHC.Internal.Generics.:*: g)
instance (GHC.Internal.Data.Foldable.Foldable f, GHC.Internal.Data.Foldable.Foldable g) => GHC.Internal.Data.Foldable.Foldable (f GHC.Internal.Generics.:+: g)
instance (GHC.Internal.Data.Foldable.Foldable f, GHC.Internal.Data.Foldable.Foldable g) => GHC.Internal.Data.Foldable.Foldable (f GHC.Internal.Generics.:.: g)
instance GHC.Internal.Data.Foldable.Foldable f => GHC.Internal.Data.Foldable.Foldable (GHC.Internal.Data.Semigroup.Internal.Alt f)
instance GHC.Internal.Data.Foldable.Foldable f => GHC.Internal.Data.Foldable.Foldable (GHC.Internal.Data.Monoid.Ap f)
instance GHC.Internal.Data.Foldable.Foldable (GHC.Internal.Arr.Array i)
instance GHC.Internal.Data.Foldable.Foldable GHC.Internal.Data.Ord.Down
instance GHC.Internal.Data.Foldable.Foldable GHC.Internal.Data.Semigroup.Internal.Dual
instance GHC.Internal.Data.Foldable.Foldable (GHC.Internal.Data.Either.Either a)
instance GHC.Internal.Data.Foldable.Foldable GHC.Internal.Data.Monoid.First
instance GHC.Internal.Data.Foldable.Foldable (GHC.Internal.Generics.K1 i c)
instance GHC.Internal.Data.Foldable.Foldable GHC.Internal.Data.Monoid.Last
instance GHC.Internal.Data.Foldable.Foldable []
instance GHC.Internal.Data.Foldable.Foldable f => GHC.Internal.Data.Foldable.Foldable (GHC.Internal.Generics.M1 i c f)
instance GHC.Internal.Data.Foldable.Foldable GHC.Internal.Maybe.Maybe
instance GHC.Internal.Data.Foldable.Foldable GHC.Internal.Base.NonEmpty
instance GHC.Internal.Data.Foldable.Foldable GHC.Internal.Generics.Par1
instance GHC.Internal.Data.Foldable.Foldable GHC.Internal.Data.Semigroup.Internal.Product
instance GHC.Internal.Data.Foldable.Foldable GHC.Internal.Data.Proxy.Proxy
instance GHC.Internal.Data.Foldable.Foldable f => GHC.Internal.Data.Foldable.Foldable (GHC.Internal.Generics.Rec1 f)
instance GHC.Internal.Data.Foldable.Foldable GHC.Tuple.Solo
instance GHC.Internal.Data.Foldable.Foldable GHC.Internal.Data.Semigroup.Internal.Sum
instance GHC.Internal.Data.Foldable.Foldable ((,) a)
instance GHC.Internal.Data.Foldable.Foldable GHC.Internal.Generics.U1
instance GHC.Internal.Data.Foldable.Foldable GHC.Internal.Generics.UAddr
instance GHC.Internal.Data.Foldable.Foldable GHC.Internal.Generics.UChar
instance GHC.Internal.Data.Foldable.Foldable GHC.Internal.Generics.UDouble
instance GHC.Internal.Data.Foldable.Foldable GHC.Internal.Generics.UFloat
instance GHC.Internal.Data.Foldable.Foldable GHC.Internal.Generics.UInt
instance GHC.Internal.Data.Foldable.Foldable GHC.Internal.Generics.UWord
instance GHC.Internal.Data.Foldable.Foldable GHC.Internal.Generics.V1

module GHC.Internal.ClosureTypes

-- | Enum representing closure types This is a mirror of:
--   <tt>rts<i>include</i>rts<i>storage</i>ClosureTypes.h</tt>
data ClosureType
INVALID_OBJECT :: ClosureType
CONSTR :: ClosureType
CONSTR_1_0 :: ClosureType
CONSTR_0_1 :: ClosureType
CONSTR_2_0 :: ClosureType
CONSTR_1_1 :: ClosureType
CONSTR_0_2 :: ClosureType
CONSTR_NOCAF :: ClosureType
FUN :: ClosureType
FUN_1_0 :: ClosureType
FUN_0_1 :: ClosureType
FUN_2_0 :: ClosureType
FUN_1_1 :: ClosureType
FUN_0_2 :: ClosureType
FUN_STATIC :: ClosureType
THUNK :: ClosureType
THUNK_1_0 :: ClosureType
THUNK_0_1 :: ClosureType
THUNK_2_0 :: ClosureType
THUNK_1_1 :: ClosureType
THUNK_0_2 :: ClosureType
THUNK_STATIC :: ClosureType
THUNK_SELECTOR :: ClosureType
BCO :: ClosureType
AP :: ClosureType
PAP :: ClosureType
AP_STACK :: ClosureType
IND :: ClosureType
IND_STATIC :: ClosureType
RET_BCO :: ClosureType
RET_SMALL :: ClosureType
RET_BIG :: ClosureType
RET_FUN :: ClosureType
UPDATE_FRAME :: ClosureType
CATCH_FRAME :: ClosureType
UNDERFLOW_FRAME :: ClosureType
STOP_FRAME :: ClosureType
BLOCKING_QUEUE :: ClosureType
BLACKHOLE :: ClosureType
MVAR_CLEAN :: ClosureType
MVAR_DIRTY :: ClosureType
TVAR :: ClosureType
ARR_WORDS :: ClosureType
MUT_ARR_PTRS_CLEAN :: ClosureType
MUT_ARR_PTRS_DIRTY :: ClosureType
MUT_ARR_PTRS_FROZEN_DIRTY :: ClosureType
MUT_ARR_PTRS_FROZEN_CLEAN :: ClosureType
MUT_VAR_CLEAN :: ClosureType
MUT_VAR_DIRTY :: ClosureType
WEAK :: ClosureType
PRIM :: ClosureType
MUT_PRIM :: ClosureType
TSO :: ClosureType
STACK :: ClosureType
TREC_CHUNK :: ClosureType
ATOMICALLY_FRAME :: ClosureType
CATCH_RETRY_FRAME :: ClosureType
CATCH_STM_FRAME :: ClosureType
WHITEHOLE :: ClosureType
SMALL_MUT_ARR_PTRS_CLEAN :: ClosureType
SMALL_MUT_ARR_PTRS_DIRTY :: ClosureType
SMALL_MUT_ARR_PTRS_FROZEN_DIRTY :: ClosureType
SMALL_MUT_ARR_PTRS_FROZEN_CLEAN :: ClosureType
COMPACT_NFDATA :: ClosureType
CONTINUATION :: ClosureType
N_CLOSURE_TYPES :: ClosureType
instance GHC.Internal.Enum.Enum GHC.Internal.ClosureTypes.ClosureType
instance GHC.Classes.Eq GHC.Internal.ClosureTypes.ClosureType
instance GHC.Internal.Generics.Generic GHC.Internal.ClosureTypes.ClosureType
instance GHC.Classes.Ord GHC.Internal.ClosureTypes.ClosureType
instance GHC.Internal.Show.Show GHC.Internal.ClosureTypes.ClosureType


module GHC.Internal.Data.Functor.Const

-- | The <a>Const</a> functor.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; fmap (++ "World") (Const "Hello")
--   Const "Hello"
--   </pre>
--   
--   Because we ignore the second type parameter to <a>Const</a>, the
--   Applicative instance, which has <tt><a>(&lt;*&gt;)</a> :: Monoid m
--   =&gt; Const m (a -&gt; b) -&gt; Const m a -&gt; Const m b</tt>
--   essentially turns into <tt>Monoid m =&gt; m -&gt; m -&gt; m</tt>,
--   which is <a>(&lt;&gt;)</a>
--   
--   <pre>
--   &gt;&gt;&gt; Const [1, 2, 3] &lt;*&gt; Const [4, 5, 6]
--   Const [1,2,3,4,5,6]
--   </pre>
newtype Const a (b :: k)
Const :: a -> Const a (b :: k)
[getConst] :: Const a (b :: k) -> a
instance GHC.Internal.Base.Monoid m => GHC.Internal.Base.Applicative (GHC.Internal.Data.Functor.Const.Const m)
instance forall a k (b :: k). GHC.Internal.Bits.Bits a => GHC.Internal.Bits.Bits (GHC.Internal.Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Internal.Enum.Bounded a => GHC.Internal.Enum.Bounded (GHC.Internal.Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Internal.Enum.Enum a => GHC.Internal.Enum.Enum (GHC.Internal.Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Internal.Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Internal.Bits.FiniteBits a => GHC.Internal.Bits.FiniteBits (GHC.Internal.Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Internal.Float.Floating a => GHC.Internal.Float.Floating (GHC.Internal.Data.Functor.Const.Const a b)
instance GHC.Internal.Data.Foldable.Foldable (GHC.Internal.Data.Functor.Const.Const m)
instance forall a k (b :: k). GHC.Internal.Real.Fractional a => GHC.Internal.Real.Fractional (GHC.Internal.Data.Functor.Const.Const a b)
instance GHC.Internal.Base.Functor (GHC.Internal.Data.Functor.Const.Const m)
instance GHC.Internal.Generics.Generic1 (GHC.Internal.Data.Functor.Const.Const a)
instance forall a k (b :: k). GHC.Internal.Generics.Generic (GHC.Internal.Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Internal.Real.Integral a => GHC.Internal.Real.Integral (GHC.Internal.Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Internal.Ix.Ix a => GHC.Internal.Ix.Ix (GHC.Internal.Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Internal.Base.Monoid a => GHC.Internal.Base.Monoid (GHC.Internal.Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Internal.Num.Num a => GHC.Internal.Num.Num (GHC.Internal.Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Internal.Data.Functor.Const.Const a b)
instance forall k a (b :: k). GHC.Internal.Read.Read a => GHC.Internal.Read.Read (GHC.Internal.Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Internal.Real.Real a => GHC.Internal.Real.Real (GHC.Internal.Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Internal.Float.RealFloat a => GHC.Internal.Float.RealFloat (GHC.Internal.Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Internal.Real.RealFrac a => GHC.Internal.Real.RealFrac (GHC.Internal.Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Internal.Base.Semigroup a => GHC.Internal.Base.Semigroup (GHC.Internal.Data.Functor.Const.Const a b)
instance forall k a (b :: k). GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Internal.Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Internal.Foreign.Storable.Storable a => GHC.Internal.Foreign.Storable.Storable (GHC.Internal.Data.Functor.Const.Const a b)


-- | The representations of the types <a>TyCon</a> and <a>TypeRep</a>, and
--   the function <a>mkTyCon</a> which is used by derived instances of
--   <a>Typeable</a> to construct <a>TyCon</a>s.
--   
--   Be warned, these functions can be used to construct ill-kinded type
--   representations.
module GHC.Internal.Type.Reflection.Unsafe

-- | TypeRep is a concrete representation of a (monomorphic) type.
--   <a>TypeRep</a> supports reasonably efficient equality. See Note [Grand
--   plan for Typeable] in GHC.Tc.Instance.Typeable
data TypeRep (a :: k)

-- | Construct a representation for a type application.
mkTrApp :: forall k1 k2 (a :: k1 -> k2) (b :: k1). TypeRep a -> TypeRep b -> TypeRep (a b)

-- | Exquisitely unsafe.
mkTyCon :: String -> String -> String -> Int -> KindRep -> TyCon

-- | Observe the <a>Fingerprint</a> of a type representation
typeRepFingerprint :: forall {k} (a :: k). TypeRep a -> Fingerprint
someTypeRepFingerprint :: SomeTypeRep -> Fingerprint

-- | The representation produced by GHC for conjuring up the kind of a
--   <a>TypeRep</a>.
data KindRep
KindRepTyConApp :: TyCon -> [KindRep] -> KindRep
KindRepVar :: !KindBndr -> KindRep
KindRepApp :: KindRep -> KindRep -> KindRep
KindRepFun :: KindRep -> KindRep -> KindRep
KindRepTYPE :: !RuntimeRep -> KindRep
KindRepTypeLitS :: TypeLitSort -> Addr# -> KindRep
KindRepTypeLitD :: TypeLitSort -> [Char] -> KindRep
pattern KindRepTypeLit :: TypeLitSort -> String -> KindRep
data TypeLitSort
TypeLitSymbol :: TypeLitSort
TypeLitNat :: TypeLitSort
TypeLitChar :: TypeLitSort
data TyCon

-- | Construct a representation for a type constructor applied at a
--   monomorphic kind.
--   
--   Note that this is unsafe as it allows you to construct ill-kinded
--   types.
mkTrCon :: forall k (a :: k). TyCon -> [SomeTypeRep] -> TypeRep a
tyConKindRep :: TyCon -> KindRep
tyConKindArgs :: TyCon -> Int
tyConFingerprint :: TyCon -> Fingerprint


-- | This provides a type-indexed type representation mechanism, similar to
--   that described by,
--   
--   <ul>
--   <li>Simon Peyton-Jones, Stephanie Weirich, Richard Eisenberg,
--   Dimitrios Vytiniotis. "<a>A reflection on types</a>". <i>Proc. Philip
--   Wadler's 60th birthday Festschrift</i>, Edinburgh (April 2016).</li>
--   </ul>
--   
--   The interface provides <a>TypeRep</a>, a type representation which can
--   be safely decomposed and composed. See <a>Data.Dynamic</a> for an
--   example of this.
module GHC.Internal.Type.Reflection

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)
typeRep :: forall {k} (a :: k). Typeable a => TypeRep a

-- | Use a <a>TypeRep</a> as <a>Typeable</a> evidence.
--   
--   The <a>TypeRep</a> pattern synonym brings a <a>Typeable</a> constraint
--   into scope and can be used in place of <a>withTypeable</a>.
--   
--   <pre>
--   f :: TypeRep a -&gt; ..
--   f rep = withTypeable {- Typeable a in scope -}
--   
--   f :: TypeRep a -&gt; ..
--   f TypeRep = {- Typeable a in scope -}
--   </pre>
withTypeable :: forall k (a :: k) r. TypeRep a -> (Typeable a => r) -> r

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data (a :: k) :~: (b :: k)
[Refl] :: forall {k} (a :: k). a :~: a
infix 4 :~:

-- | Kind heterogeneous propositional equality. Like <a>:~:</a>, <tt>a :~~:
--   b</tt> is inhabited by a terminating value if and only if <tt>a</tt>
--   is the same type as <tt>b</tt>.
data (a :: k1) :~~: (b :: k2)
[HRefl] :: forall {k1} (a :: k1). a :~~: a
infix 4 :~~:

-- | TypeRep is a concrete representation of a (monomorphic) type.
--   <a>TypeRep</a> supports reasonably efficient equality. See Note [Grand
--   plan for Typeable] in GHC.Tc.Instance.Typeable
data TypeRep (a :: k)

-- | A explicitly bidirectional pattern synonym to construct a concrete
--   representation of a type.
--   
--   As an <b>expression</b>: Constructs a singleton <tt>TypeRep a</tt>
--   given a implicit 'Typeable a' constraint:
--   
--   <pre>
--   TypeRep @a :: Typeable a =&gt; TypeRep a
--   </pre>
--   
--   As a <b>pattern</b>: Matches on an explicit <tt>TypeRep a</tt> witness
--   bringing an implicit <tt>Typeable a</tt> constraint into scope.
--   
--   <pre>
--   f :: TypeRep a -&gt; ..
--   f TypeRep = {- Typeable a in scope -}
--   </pre>
pattern TypeRep :: () => Typeable a => TypeRep a
typeOf :: Typeable a => a -> TypeRep a

-- | A type application.
--   
--   For instance,
--   
--   <pre>
--   typeRep @(Maybe Int) === App (typeRep @Maybe) (typeRep @Int)
--   </pre>
--   
--   Note that this will also match a function type,
--   
--   <pre>
--   typeRep @(Int# -&gt; Char)
--     ===
--   App (App arrow (typeRep @Int#)) (typeRep @Char)
--   </pre>
--   
--   where <tt>arrow :: TypeRep ((-&gt;) :: TYPE IntRep -&gt; Type -&gt;
--   Type)</tt>.
pattern App :: forall k2 t k1 a b. () => t ~ a b => TypeRep a -> TypeRep b -> TypeRep t

-- | Pattern match on a type constructor
pattern Con :: () => NotApplication a => TyCon -> TypeRep a

-- | Pattern match on a type constructor including its instantiated kind
--   variables.
--   
--   For instance,
--   
--   <pre>
--   App (Con' proxyTyCon ks) intRep = typeRep @(Proxy @Int)
--   </pre>
--   
--   will bring into scope,
--   
--   <pre>
--   proxyTyCon :: TyCon
--   ks         == [someTypeRep <tt>Type] :: [SomeTypeRep]
--   intRep     == typeRep </tt>Int
--   </pre>
pattern Con' :: () => NotApplication a => TyCon -> [SomeTypeRep] -> TypeRep a

-- | The function type constructor.
--   
--   For instance,
--   
--   <pre>
--   typeRep @(Int -&gt; Char) === Fun (typeRep @Int) (typeRep @Char)
--   </pre>
pattern Fun :: forall k fun (r1 :: RuntimeRep) (r2 :: RuntimeRep) arg res. () => (k ~ Type, fun ~~ (arg -> res)) => TypeRep arg -> TypeRep res -> TypeRep fun

-- | Observe the type constructor of a type representation
typeRepTyCon :: forall {k} (a :: k). TypeRep a -> TyCon

-- | Helper to fully evaluate <a>TypeRep</a> for use as
--   <tt>NFData(rnf)</tt> implementation
rnfTypeRep :: forall {k} (a :: k). TypeRep a -> ()

-- | Type equality
eqTypeRep :: forall k1 k2 (a :: k1) (b :: k2). TypeRep a -> TypeRep b -> Maybe (a :~~: b)

-- | Type equality decision
decTypeRep :: forall k1 k2 (a :: k1) (b :: k2). TypeRep a -> TypeRep b -> Either ((a :~~: b) -> Void) (a :~~: b)

-- | Observe the kind of a type.
typeRepKind :: forall k (a :: k). TypeRep a -> TypeRep k
splitApps :: forall {k} (a :: k). TypeRep a -> (TyCon, [SomeTypeRep])

-- | A non-indexed type representation.
data SomeTypeRep
[SomeTypeRep] :: forall k (a :: k). !TypeRep a -> SomeTypeRep

-- | Takes a value of type <tt>a</tt> and returns a concrete representation
--   of that type.
someTypeRep :: forall {k} proxy (a :: k). Typeable a => proxy a -> SomeTypeRep

-- | Observe the type constructor of a quantified type representation.
someTypeRepTyCon :: SomeTypeRep -> TyCon

-- | Helper to fully evaluate <a>SomeTypeRep</a> for use as
--   <tt>NFData(rnf)</tt> implementation
rnfSomeTypeRep :: SomeTypeRep -> ()
data TyCon
tyConPackage :: TyCon -> String
tyConModule :: TyCon -> String
tyConName :: TyCon -> String
rnfTyCon :: TyCon -> ()
data Module
moduleName :: Module -> String
modulePackage :: Module -> String

-- | Helper to fully evaluate <a>TyCon</a> for use as <tt>NFData(rnf)</tt>
--   implementation
rnfModule :: Module -> ()


-- | Exception context type.
module GHC.Internal.Exception.Context

-- | Exception context represents a list of <a>ExceptionAnnotation</a>s.
--   These are attached to <tt>SomeException</tt>s via
--   <a>addExceptionContext</a> and can be used to capture various ad-hoc
--   metadata about the exception including backtraces and
--   application-specific context.
--   
--   <a>ExceptionContext</a>s can be merged via concatenation using the
--   <a>Semigroup</a> instance or <a>mergeExceptionContext</a>.
--   
--   Note that GHC will automatically solve implicit constraints of type
--   <a>ExceptionContext</a> with <a>emptyExceptionContext</a>.
data ExceptionContext
ExceptionContext :: [SomeExceptionAnnotation] -> ExceptionContext

-- | An <a>ExceptionContext</a> containing no annotations.
emptyExceptionContext :: ExceptionContext

-- | Construct a singleton <a>ExceptionContext</a> from an
--   <a>ExceptionAnnotation</a>.
addExceptionAnnotation :: ExceptionAnnotation a => a -> ExceptionContext -> ExceptionContext

-- | Retrieve all <a>ExceptionAnnotation</a>s of the given type from an
--   <a>ExceptionContext</a>.
getExceptionAnnotations :: ExceptionAnnotation a => ExceptionContext -> [a]
getAllExceptionAnnotations :: ExceptionContext -> [SomeExceptionAnnotation]

-- | Merge two <a>ExceptionContext</a>s via concatenation
mergeExceptionContext :: ExceptionContext -> ExceptionContext -> ExceptionContext

-- | Render <a>ExceptionContext</a> to a human-readable <a>String</a>.
displayExceptionContext :: ExceptionContext -> String
data SomeExceptionAnnotation
SomeExceptionAnnotation :: a -> SomeExceptionAnnotation

-- | <a>ExceptionAnnotation</a>s are types which can decorate exceptions as
--   <a>ExceptionContext</a>.
class Typeable a => ExceptionAnnotation a

-- | Render the annotation for display to the user.
displayExceptionAnnotation :: ExceptionAnnotation a => a -> String
($dmdisplayExceptionAnnotation) :: (ExceptionAnnotation a, Show a) => a -> String
instance GHC.Internal.Base.Monoid GHC.Internal.Exception.Context.ExceptionContext
instance GHC.Internal.Base.Semigroup GHC.Internal.Exception.Context.ExceptionContext


-- | The <a>Typeable</a> class reifies types to some extent by associating
--   type representations to types. These type representations can be
--   compared, and one can in turn define a type-safe cast operation. To
--   this end, an unsafe cast is guarded by a test for type
--   (representation) equivalence. The module <a>Data.Dynamic</a> uses
--   Typeable for an implementation of dynamics. The module
--   <a>Data.Data</a> uses Typeable and type-safe cast (but not dynamics)
--   to support the "Scrap your boilerplate" style of generic programming.
--   
--   <h2>Compatibility Notes</h2>
--   
--   Since GHC 8.2, GHC has supported type-indexed type representations.
--   <a>Data.Typeable</a> provides type representations which are qualified
--   over this index, providing an interface very similar to the
--   <a>Typeable</a> notion seen in previous releases. For the type-indexed
--   interface, see <a>Type.Reflection</a>.
--   
--   Since GHC 7.10, all types automatically have <a>Typeable</a> instances
--   derived. This is in contrast to previous releases where
--   <a>Typeable</a> had to be explicitly derived using the
--   <tt>DeriveDataTypeable</tt> language extension.
--   
--   Since GHC 7.8, <a>Typeable</a> is poly-kinded. The changes required
--   for this might break some old programs involving <a>Typeable</a>. More
--   details on this, including how to fix your code, can be found on the
--   <a>PolyTypeable wiki page</a>
module GHC.Internal.Data.Typeable

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)

-- | Observe a type representation for the type of a value.
typeOf :: Typeable a => a -> TypeRep

-- | Takes a value of type <tt>a</tt> and returns a concrete representation
--   of that type.
typeRep :: forall {k} proxy (a :: k). Typeable a => proxy a -> TypeRep

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data (a :: k) :~: (b :: k)
[Refl] :: forall {k} (a :: k). a :~: a
infix 4 :~:

-- | Kind heterogeneous propositional equality. Like <a>:~:</a>, <tt>a :~~:
--   b</tt> is inhabited by a terminating value if and only if <tt>a</tt>
--   is the same type as <tt>b</tt>.
data (a :: k1) :~~: (b :: k2)
[HRefl] :: forall {k1} (a :: k1). a :~~: a
infix 4 :~~:

-- | The type-safe cast operation
cast :: (Typeable a, Typeable b) => a -> Maybe b

-- | Extract a witness of equality of two types
eqT :: forall {k} (a :: k) (b :: k). (Typeable a, Typeable b) => Maybe (a :~: b)

-- | Extract a witness of heterogeneous equality of two types
heqT :: forall {k1} {k2} (a :: k1) (b :: k2). (Typeable a, Typeable b) => Maybe (a :~~: b)

-- | Decide an equality of two types
decT :: forall {k} (a :: k) (b :: k). (Typeable a, Typeable b) => Either ((a :~: b) -> Void) (a :~: b)

-- | Decide heterogeneous equality of two types.
hdecT :: forall {k1} {k2} (a :: k1) (b :: k2). (Typeable a, Typeable b) => Either ((a :~~: b) -> Void) (a :~~: b)

-- | A flexible variation parameterised in a type constructor
gcast :: forall {k} (a :: k) (b :: k) c. (Typeable a, Typeable b) => c a -> Maybe (c b)

-- | Cast over <tt>k1 -&gt; k2</tt>
gcast1 :: forall {k1} {k2} c (t :: k2 -> k1) (t' :: k2 -> k1) (a :: k2). (Typeable t, Typeable t') => c (t a) -> Maybe (c (t' a))

-- | Cast over <tt>k1 -&gt; k2 -&gt; k3</tt>
gcast2 :: forall {k1} {k2} {k3} c (t :: k2 -> k3 -> k1) (t' :: k2 -> k3 -> k1) (a :: k2) (b :: k3). (Typeable t, Typeable t') => c (t a b) -> Maybe (c (t' a b))

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt><a>undefined</a> :: a</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data Proxy (t :: k)
Proxy :: Proxy (t :: k)

-- | A quantified type representation.
type TypeRep = SomeTypeRep

-- | Force a <a>TypeRep</a> to normal form.
rnfTypeRep :: TypeRep -> ()

-- | Show a type representation
showsTypeRep :: TypeRep -> ShowS

-- | Build a function type.
mkFunTy :: TypeRep -> TypeRep -> TypeRep

-- | Applies a type to a function type. Returns: <tt>Just u</tt> if the
--   first argument represents a function of type <tt>t -&gt; u</tt> and
--   the second argument represents a function of type <tt>t</tt>.
--   Otherwise, returns <tt>Nothing</tt>.
funResultTy :: TypeRep -> TypeRep -> Maybe TypeRep

-- | Splits a type constructor application. Note that if the type
--   constructor is polymorphic, this will not return the kinds that were
--   used.
splitTyConApp :: TypeRep -> (TyCon, [TypeRep])

-- | Observe the argument types of a type representation
typeRepArgs :: TypeRep -> [TypeRep]

-- | Observe the type constructor of a quantified type representation.
typeRepTyCon :: TypeRep -> TyCon

-- | Takes a value of type <tt>a</tt> and returns a concrete representation
--   of that type.
typeRepFingerprint :: TypeRep -> Fingerprint
data TyCon
tyConPackage :: TyCon -> String
tyConModule :: TyCon -> String
tyConName :: TyCon -> String
rnfTyCon :: TyCon -> ()
tyConFingerprint :: TyCon -> Fingerprint
typeOf1 :: Typeable t => t a -> TypeRep
typeOf2 :: Typeable t => t a b -> TypeRep
typeOf3 :: Typeable t => t a b c -> TypeRep
typeOf4 :: Typeable t => t a b c d -> TypeRep
typeOf5 :: Typeable t => t a b c d e -> TypeRep
typeOf6 :: Typeable t => t a b c d e f -> TypeRep
typeOf7 :: Typeable t => t a b c d e f g -> TypeRep
trLiftedRep :: TypeRep LiftedRep


-- | Exceptions and exception-handling functions.
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.Exception.Type

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e

-- | <tt>toException</tt> should produce a <a>SomeException</a> with no
--   attached <a>ExceptionContext</a>.
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

backtraceDesired :: Exception e => e -> Bool

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException
SomeException :: e -> SomeException

-- | Displays a <a>SomeException</a> with additional information:
--   
--   <ul>
--   <li>The type of the underlying exception</li>
--   <li>The exception context</li>
--   </ul>
--   
--   By default, <tt>uncaughtExceptionHandler</tt> uses
--   <a>displayExceptionWithInfo</a> to print uncaught exceptions. This
--   default can be overriden with <tt>setUncaughtExceptionHandler</tt>,
--   for instance, to present custom error messages on exceptions to the
--   user.
displayExceptionWithInfo :: SomeException -> String

-- | View the <a>ExceptionContext</a> of a <a>SomeException</a>.
someExceptionContext :: SomeException -> ExceptionContext

-- | Add more <a>ExceptionContext</a> to a <a>SomeException</a>.
addExceptionContext :: ExceptionAnnotation a => a -> SomeException -> SomeException
mapExceptionContext :: (ExceptionContext -> ExceptionContext) -> SomeException -> SomeException
newtype NoBacktrace e
NoBacktrace :: e -> NoBacktrace e

-- | A constraint used to propagate <a>ExceptionContext</a>s.
--   
--   GHC will automatically default any unsolved <a>HasExceptionContext</a>
--   constraints to an empty exception context, similarly to
--   <tt>HasCallStack</tt>.
--   
--   NOTE: The fact that <tt>HasExceptionContext</tt> is defined as an
--   implicit parameter is an implementation detail and <b>should not</b>
--   be considered a part of the API. It does however mean that any
--   implicit parameter `?exceptionContext :: ExceptionContext` will be
--   subject to defaulting, as described above.
type HasExceptionContext = ?exceptionContext :: ExceptionContext

-- | Exception context represents a list of <a>ExceptionAnnotation</a>s.
--   These are attached to <tt>SomeException</tt>s via
--   <a>addExceptionContext</a> and can be used to capture various ad-hoc
--   metadata about the exception including backtraces and
--   application-specific context.
--   
--   <a>ExceptionContext</a>s can be merged via concatenation using the
--   <a>Semigroup</a> instance or <a>mergeExceptionContext</a>.
--   
--   Note that GHC will automatically solve implicit constraints of type
--   <a>ExceptionContext</a> with <a>emptyExceptionContext</a>.
data ExceptionContext
ExceptionContext :: [SomeExceptionAnnotation] -> ExceptionContext

-- | An <a>ExceptionContext</a> containing no annotations.
emptyExceptionContext :: ExceptionContext

-- | Merge two <a>ExceptionContext</a>s via concatenation
mergeExceptionContext :: ExceptionContext -> ExceptionContext -> ExceptionContext

-- | Wraps a particular exception exposing its <a>ExceptionContext</a>.
--   Intended to be used when <tt>catch</tt>ing exceptions in cases where
--   access to the context is desired.
data ExceptionWithContext a
ExceptionWithContext :: ExceptionContext -> a -> ExceptionWithContext a

-- | <tt>WhileHandling</tt> is used to annotate rethrow exceptions. By
--   inspecting the <tt>WhileHandling</tt> annotation, all the places the
--   exception has been rethrow can be recovered.
data WhileHandling
WhileHandling :: SomeException -> WhileHandling

-- | Create <a>SomeException</a> from an explicit context and exception.
whileHandling :: Exception e => ExceptionWithContext e -> WhileHandling

-- | Arithmetic exceptions.
data ArithException
Overflow :: ArithException
Underflow :: ArithException
LossOfPrecision :: ArithException
DivideByZero :: ArithException
Denormal :: ArithException

RatioZeroDenominator :: ArithException
divZeroException :: SomeException
overflowException :: SomeException
ratioZeroDenomException :: SomeException
underflowException :: SomeException
instance GHC.Classes.Eq GHC.Internal.Exception.Type.ArithException
instance GHC.Internal.Exception.Context.ExceptionAnnotation GHC.Internal.Exception.Type.WhileHandling
instance GHC.Internal.Exception.Type.Exception GHC.Internal.Exception.Type.ArithException
instance GHC.Internal.Exception.Type.Exception a => GHC.Internal.Exception.Type.Exception (GHC.Internal.Exception.Type.ExceptionWithContext a)
instance GHC.Internal.Exception.Type.Exception e => GHC.Internal.Exception.Type.Exception (GHC.Internal.Exception.Type.NoBacktrace e)
instance GHC.Internal.Exception.Type.Exception GHC.Internal.Exception.Type.SomeException
instance GHC.Internal.Exception.Type.Exception GHC.Internal.Base.Void
instance GHC.Classes.Ord GHC.Internal.Exception.Type.ArithException
instance GHC.Internal.Show.Show GHC.Internal.Exception.Type.ArithException
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Internal.Exception.Type.ExceptionWithContext a)
instance GHC.Internal.Show.Show e => GHC.Internal.Show.Show (GHC.Internal.Exception.Type.NoBacktrace e)
instance GHC.Internal.Show.Show GHC.Internal.Exception.Type.SomeException
instance GHC.Internal.Show.Show GHC.Internal.Exception.Type.WhileHandling


-- | Exceptions and exception-handling functions.
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.Exception

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e

-- | <tt>toException</tt> should produce a <a>SomeException</a> with no
--   attached <a>ExceptionContext</a>.
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

backtraceDesired :: Exception e => e -> Bool

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException
SomeException :: e -> SomeException

-- | Displays a <a>SomeException</a> with additional information:
--   
--   <ul>
--   <li>The type of the underlying exception</li>
--   <li>The exception context</li>
--   </ul>
--   
--   By default, <tt>uncaughtExceptionHandler</tt> uses
--   <a>displayExceptionWithInfo</a> to print uncaught exceptions. This
--   default can be overriden with <tt>setUncaughtExceptionHandler</tt>,
--   for instance, to present custom error messages on exceptions to the
--   user.
displayExceptionWithInfo :: SomeException -> String

-- | View the <a>ExceptionContext</a> of a <a>SomeException</a>.
someExceptionContext :: SomeException -> ExceptionContext

-- | Add more <a>ExceptionContext</a> to a <a>SomeException</a>.
addExceptionContext :: ExceptionAnnotation a => a -> SomeException -> SomeException

-- | Throw an exception. Exceptions may be thrown from purely functional
--   code, but may only be caught within the <a>IO</a> monad.
--   
--   WARNING: You may want to use <tt>throwIO</tt> instead so that your
--   pure code stays exception-free.
throw :: forall a e. (HasCallStack, Exception e) => e -> a

-- | Arithmetic exceptions.
data ArithException
Overflow :: ArithException
Underflow :: ArithException
LossOfPrecision :: ArithException
DivideByZero :: ArithException
Denormal :: ArithException

RatioZeroDenominator :: ArithException
divZeroException :: SomeException
overflowException :: SomeException
ratioZeroDenomException :: SomeException
underflowException :: SomeException

-- | This is thrown when the user calls <a>error</a>. The <tt>String</tt>
--   is the argument given to <a>error</a>.
--   
--   Historically, there was a second <tt>String</tt> for the location, but
--   it was subsumed by the backtrace mechanisms (since base-4.22).
data ErrorCall
ErrorCall :: String -> ErrorCall

-- | <i>Deprecated: ErrorCallWithLocation has been deprecated in favour of
--   ErrorCall (which does not have a location). Backtraces are now handled
--   by the backtrace exception mechanisms exclusively.</i>
pattern ErrorCallWithLocation :: String -> String -> ErrorCall
errorCallException :: String -> SomeException
errorCallWithCallStackException :: String -> CallStack -> SomeException

toExceptionWithBacktrace :: (HasCallStack, Exception e) => e -> IO SomeException

-- | <a>CallStack</a>s are a lightweight method of obtaining a partial
--   call-stack at any point in the program.
--   
--   A function can request its call-site with the <a>HasCallStack</a>
--   constraint. For example, we can define
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   </pre>
--   
--   as a variant of <tt>putStrLn</tt> that will get its call-site and
--   print it, along with the string given as argument. We can access the
--   call-stack inside <tt>putStrLnWithCallStack</tt> with
--   <a>callStack</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   putStrLnWithCallStack msg = do
--     putStrLn msg
--     putStrLn (prettyCallStack callStack)
--   :}
--   </pre>
--   
--   Thus, if we call <tt>putStrLnWithCallStack</tt> we will get a
--   formatted call-stack alongside our string.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLnWithCallStack "hello"
--   hello
--   CallStack (from HasCallStack):
--     putStrLnWithCallStack, called at &lt;interactive&gt;:... in interactive:Ghci...
--   </pre>
--   
--   GHC solves <a>HasCallStack</a> constraints in three steps:
--   
--   <ol>
--   <li>If there is a <a>CallStack</a> in scope -- i.e. the enclosing
--   function has a <a>HasCallStack</a> constraint -- GHC will append the
--   new call-site to the existing <a>CallStack</a>.</li>
--   <li>If there is no <a>CallStack</a> in scope -- e.g. in the GHCi
--   session above -- and the enclosing definition does not have an
--   explicit type signature, GHC will infer a <a>HasCallStack</a>
--   constraint for the enclosing definition (subject to the monomorphism
--   restriction).</li>
--   <li>If there is no <a>CallStack</a> in scope and the enclosing
--   definition has an explicit type signature, GHC will solve the
--   <a>HasCallStack</a> constraint for the singleton <a>CallStack</a>
--   containing just the current call-site.</li>
--   </ol>
--   
--   <a>CallStack</a>s do not interact with the RTS and do not require
--   compilation with <tt>-prof</tt>. On the other hand, as they are built
--   up explicitly via the <a>HasCallStack</a> constraints, they will
--   generally not contain as much information as the simulated call-stacks
--   maintained by the RTS.
--   
--   A <a>CallStack</a> is a <tt>[(String, SrcLoc)]</tt>. The
--   <tt>String</tt> is the name of function that was called, the
--   <a>SrcLoc</a> is the call-site. The list is ordered with the most
--   recently called function at the head.
--   
--   NOTE: The intrepid user may notice that <a>HasCallStack</a> is just an
--   alias for an implicit parameter <tt>?callStack :: CallStack</tt>. This
--   is an implementation detail and <b>should not</b> be considered part
--   of the <a>CallStack</a> API, we may decide to change the
--   implementation in the future.
data CallStack

-- | Convert a list of call-sites to a <a>CallStack</a>.
fromCallSiteList :: [([Char], SrcLoc)] -> CallStack

-- | Extract a list of call-sites from the <a>CallStack</a>.
--   
--   The list is ordered by most recent call.
getCallStack :: CallStack -> [([Char], SrcLoc)]
prettyCallStack :: CallStack -> String
prettyCallStackLines :: CallStack -> [String]

-- | A single location in the source code.
data SrcLoc
SrcLoc :: [Char] -> [Char] -> [Char] -> Int -> Int -> Int -> Int -> SrcLoc
[srcLocPackage] :: SrcLoc -> [Char]
[srcLocModule] :: SrcLoc -> [Char]
[srcLocFile] :: SrcLoc -> [Char]
[srcLocStartLine] :: SrcLoc -> Int
[srcLocStartCol] :: SrcLoc -> Int
[srcLocEndLine] :: SrcLoc -> Int
[srcLocEndCol] :: SrcLoc -> Int
prettySrcLoc :: SrcLoc -> String
instance GHC.Classes.Eq GHC.Internal.Exception.ErrorCall
instance GHC.Internal.Exception.Type.Exception GHC.Internal.Exception.ErrorCall
instance GHC.Classes.Ord GHC.Internal.Exception.ErrorCall
instance GHC.Internal.Show.Show GHC.Internal.Exception.ErrorCall


-- | Definitions for the <a>IO</a> monad and its friends.
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.IO

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
newtype IO a
IO :: (State# RealWorld -> (# State# RealWorld, a #)) -> IO a
unIO :: IO a -> State# RealWorld -> (# State# RealWorld, a #)
liftIO :: IO a -> State# RealWorld -> STret RealWorld a
mplusIO :: IO a -> IO a -> IO a

-- | This is the "back door" into the <a>IO</a> monad, allowing <a>IO</a>
--   computation to be performed at any time. For this to be safe, the
--   <a>IO</a> computation should be free of side effects and independent
--   of its environment.
--   
--   If the I/O computation wrapped in <a>unsafePerformIO</a> performs side
--   effects, then the relative order in which those side effects take
--   place (relative to the main I/O trunk, or other calls to
--   <a>unsafePerformIO</a>) is indeterminate. Furthermore, when using
--   <a>unsafePerformIO</a> to cause side-effects, you should take the
--   following precautions to ensure the side effects are performed as many
--   times as you expect them to be. Note that these precautions are
--   necessary for GHC, but may not be sufficient, and other compilers may
--   require different precautions:
--   
--   <ul>
--   <li>Use <tt>{-# NOINLINE foo #-}</tt> as a pragma on any function
--   <tt>foo</tt> that calls <a>unsafePerformIO</a>. If the call is
--   inlined, the I/O may be performed more than once.</li>
--   <li>Use the compiler flag <tt>-fno-cse</tt> to prevent common
--   sub-expression elimination being performed on the module, which might
--   combine two side effects that were meant to be separate. A good
--   example is using multiple global variables (like <tt>test</tt> in the
--   example below).</li>
--   <li>Make sure that the either you switch off let-floating
--   (<tt>-fno-full-laziness</tt>), or that the call to
--   <a>unsafePerformIO</a> cannot float outside a lambda. For example, if
--   you say: <tt> f x = unsafePerformIO (newIORef []) </tt> you may get
--   only one reference cell shared between all calls to <tt>f</tt>. Better
--   would be <tt> f x = unsafePerformIO (newIORef [x]) </tt> because now
--   it can't float outside the lambda.</li>
--   </ul>
--   
--   It is less well known that <a>unsafePerformIO</a> is not type safe.
--   For example:
--   
--   <pre>
--   test :: IORef [a]
--   test = unsafePerformIO $ newIORef []
--   
--   main = do
--           writeIORef test [42]
--           bang &lt;- readIORef test
--           print (bang :: [Char])
--   </pre>
--   
--   This program will core dump. This problem with polymorphic references
--   is well known in the ML community, and does not arise with normal
--   monadic use of references. There is no easy way to make it impossible
--   once you use <a>unsafePerformIO</a>. Indeed, it is possible to write
--   <tt>coerce :: a -&gt; b</tt> with the help of <a>unsafePerformIO</a>.
--   So be careful!
--   
--   WARNING: If you're looking for "a way to get a <a>String</a> from an
--   'IO String'", then <a>unsafePerformIO</a> is not the way to go. Learn
--   about do-notation and the <tt>&lt;-</tt> syntax element before you
--   proceed.
unsafePerformIO :: IO a -> a

-- | <a>unsafeInterleaveIO</a> allows an <a>IO</a> computation to be
--   deferred lazily. When passed a value of type <tt>IO a</tt>, the
--   <a>IO</a> will only be performed when the value of the <tt>a</tt> is
--   demanded. This is used to implement lazy file reading, see
--   <a>hGetContents</a>.
unsafeInterleaveIO :: IO a -> IO a

-- | This version of <a>unsafePerformIO</a> is more efficient because it
--   omits the check that the IO is only being performed by a single
--   thread. Hence, when you use <a>unsafeDupablePerformIO</a>, there is a
--   possibility that the IO action may be performed multiple times (on a
--   multiprocessor), and you should therefore ensure that it gives the
--   same results each time. It may even happen that one of the duplicated
--   IO actions is only run partially, and then interrupted in the middle
--   without an exception being raised. Therefore, functions like
--   <a>bracket</a> cannot be used safely within
--   <a>unsafeDupablePerformIO</a>.
unsafeDupablePerformIO :: IO a -> a

-- | <a>unsafeDupableInterleaveIO</a> allows an <a>IO</a> computation to be
--   deferred lazily. When passed a value of type <tt>IO a</tt>, the
--   <a>IO</a> will only be performed when the value of the <tt>a</tt> is
--   demanded.
--   
--   The computation may be performed multiple times by different threads,
--   possibly at the same time. To ensure that the computation is performed
--   only once, use <a>unsafeInterleaveIO</a> instead.
unsafeDupableInterleaveIO :: IO a -> IO a

-- | Ensures that the suspensions under evaluation by the current thread
--   are unique; that is, the current thread is not evaluating anything
--   that is also under evaluation by another thread that has also executed
--   <a>noDuplicate</a>.
--   
--   This operation is used in the definition of <a>unsafePerformIO</a> to
--   prevent the IO action from being executed multiple times, which is
--   usually undesirable.
noDuplicate :: IO ()

-- | Execute an <a>IO</a> action, adding the given
--   <tt>ExceptionContext</tt> to any thrown synchronous exceptions.
annotateIO :: ExceptionAnnotation e => e -> IO a -> IO a

-- | Embed a strict state thread in an <a>IO</a> action. The
--   <a>RealWorld</a> parameter indicates that the internal state used by
--   the <a>ST</a> computation is a special one supplied by the <a>IO</a>
--   monad, and thus distinct from those used by invocations of
--   <a>runST</a>.
stToIO :: ST RealWorld a -> IO a

-- | Convert an <a>IO</a> action into an <a>ST</a> action. The type of the
--   result is constrained to use a <a>RealWorld</a> state thread, and
--   therefore the result cannot be passed to <a>runST</a>.
ioToST :: IO a -> ST RealWorld a

-- | Convert an <a>IO</a> action to an <a>ST</a> action. This relies on
--   <a>IO</a> and <a>ST</a> having the same representation modulo the
--   constraint on the state thread type parameter.
unsafeIOToST :: IO a -> ST s a

-- | Convert an <a>ST</a> action to an <a>IO</a> action. This relies on
--   <a>IO</a> and <a>ST</a> having the same representation modulo the
--   constraint on the state thread type parameter.
--   
--   For an example demonstrating why this is unsafe, see
--   <a>https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html</a>
unsafeSTToIO :: ST s a -> IO a

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | This is the simplest of the exception-catching functions. It takes a
--   single argument, runs it, and if an exception is raised the "handler"
--   is executed, with the value of the exception passed as an argument.
--   Otherwise, the result is returned as normal. For example:
--   
--   <pre>
--   catch (readFile f)
--         (\e -&gt; do let err = show (e :: IOException)
--                   hPutStr stderr ("Warning: Couldn't open " ++ f ++ ": " ++ err)
--                   return "")
--   </pre>
--   
--   Note that we have to give a type signature to <tt>e</tt>, or the
--   program will not typecheck as the type is ambiguous. While it is
--   possible to catch exceptions of any type, see the section "Catching
--   all exceptions" (in <a>Control.Exception</a>) for an explanation of
--   the problems with doing so.
--   
--   For catching exceptions in pure (non-<a>IO</a>) expressions, see the
--   function <a>evaluate</a>.
--   
--   Note that due to Haskell's unspecified evaluation order, an expression
--   may throw one of several possible exceptions: consider the expression
--   <tt>(error "urk") + (1 `div` 0)</tt>. Does the expression throw
--   <tt>ErrorCall "urk"</tt>, or <tt>DivideByZero</tt>?
--   
--   The answer is "it might throw either"; the choice is
--   non-deterministic. If you are catching any type of exception then you
--   might catch either. If you are calling <tt>catch</tt> with type <tt>IO
--   Int -&gt; (ArithException -&gt; IO Int) -&gt; IO Int</tt> then the
--   handler may get run with <tt>DivideByZero</tt> as an argument, or an
--   <tt>ErrorCall "urk"</tt> exception may be propagated further up. If
--   you call it again, you might get the opposite behaviour. This is ok,
--   because <a>catch</a> is an <a>IO</a> computation.
catch :: Exception e => IO a -> (e -> IO a) -> IO a

-- | A variant of <a>catch</a> which doesn't annotate the handler with the
--   exception which was caught. This function should be used when you are
--   implementing your own error handling functions which may rethrow the
--   exceptions.
--   
--   In the case where you rethrow an exception without modifying it, you
--   should rethrow the exception with the old exception context.
catchNoPropagate :: Exception e => IO a -> (ExceptionWithContext e -> IO a) -> IO a

-- | Catch an exception in the <a>IO</a> monad.
--   
--   Note that this function is <i>strict</i> in the action. That is,
--   <tt>catchException undefined b == _|_</tt>. See for details.
catchException :: Exception e => IO a -> (e -> IO a) -> IO a

-- | A variant of <a>catchException</a> which does not annotate the handler
--   with <a>WhileHandling</a>
catchExceptionNoPropagate :: Exception e => IO a -> (ExceptionWithContext e -> IO a) -> IO a

-- | Catch any <a>Exception</a> type in the <a>IO</a> monad.
--   
--   Note that this function is <i>strict</i> in the action. That is,
--   <tt>catchAny undefined b == _|_</tt>. See for details.
--   
--   If you rethrow an exception, you should reuse the supplied
--   ExceptionContext.
catchAny :: IO a -> (forall e. (HasExceptionContext, Exception e) => e -> IO a) -> IO a

-- | A variant of <a>throw</a> that can only be used within the <a>IO</a>
--   monad.
--   
--   Although <a>throwIO</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e   `seq` ()  ===&gt; throw e
--   throwIO e `seq` ()  ===&gt; ()
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwIO</a> will only cause
--   an exception to be raised when it is used within the <a>IO</a> monad.
--   
--   The <a>throwIO</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>IO</a> monad because
--   it guarantees ordering with respect to other operations, whereas
--   <a>throw</a> does not. We say that <a>throwIO</a> throws *precise*
--   exceptions and <a>throw</a>, <a>error</a>, etc. all throw *imprecise*
--   exceptions. For example
--   
--   <pre>
--   throw e + error "boom" ===&gt; error "boom"
--   throw e + error "boom" ===&gt; throw e
--   </pre>
--   
--   are both valid reductions and the compiler may pick any (loop, even),
--   whereas
--   
--   <pre>
--   throwIO e &gt;&gt; error "boom" ===&gt; throwIO e
--   </pre>
--   
--   will always throw <tt>e</tt> when executed.
--   
--   See also the <a>GHC wiki page on precise exceptions</a> for a more
--   technical introduction to how GHC optimises around precise vs.
--   imprecise exceptions.
throwIO :: (HasCallStack, Exception e) => e -> IO a

-- | A utility to use when rethrowing exceptions, no new backtrace will be
--   attached when rethrowing an exception but you must supply the existing
--   context.
rethrowIO :: Exception e => ExceptionWithContext e -> IO a

-- | Executes an IO computation with asynchronous exceptions <i>masked</i>.
--   That is, any thread which attempts to raise an exception in the
--   current thread with <a>throwTo</a> will be blocked until asynchronous
--   exceptions are unmasked again.
--   
--   The argument passed to <a>mask</a> is a function that takes as its
--   argument another function, which can be used to restore the prevailing
--   masking state within the context of the masked computation. For
--   example, a common way to use <a>mask</a> is to protect the acquisition
--   of a resource:
--   
--   <pre>
--   mask $ \restore -&gt; do
--       x &lt;- acquire
--       restore (do_something_with x) `onException` release
--       release
--   </pre>
--   
--   This code guarantees that <tt>acquire</tt> is paired with
--   <tt>release</tt>, by masking asynchronous exceptions for the critical
--   parts. (Rather than write this code yourself, it would be better to
--   use <a>bracket</a> which abstracts the general pattern).
--   
--   Note that the <tt>restore</tt> action passed to the argument to
--   <a>mask</a> does not necessarily unmask asynchronous exceptions, it
--   just restores the masking state to that of the enclosing context. Thus
--   if asynchronous exceptions are already masked, <a>mask</a> cannot be
--   used to unmask exceptions again. This is so that if you call a library
--   function with exceptions masked, you can be sure that the library call
--   will not be able to unmask exceptions again. If you are writing
--   library code and need to use asynchronous exceptions, the only way is
--   to create a new thread; see <a>forkIOWithUnmask</a>.
--   
--   Asynchronous exceptions may still be received while in the masked
--   state if the masked thread <i>blocks</i> in certain ways; see
--   <a>Control.Exception#interruptible</a>.
--   
--   Threads created by <a>forkIO</a> inherit the <a>MaskingState</a> from
--   the parent; that is, to start a thread in the
--   <a>MaskedInterruptible</a> state, use <tt>mask_ $ forkIO ...</tt>.
--   This is particularly useful if you need to establish an exception
--   handler in the forked thread before any asynchronous exceptions are
--   received. To create a new thread in an unmasked state use
--   <a>forkIOWithUnmask</a>.
mask :: ((forall a. () => IO a -> IO a) -> IO b) -> IO b

-- | Like <a>mask</a>, but does not pass a <tt>restore</tt> action to the
--   argument.
mask_ :: IO a -> IO a

-- | Like <a>mask</a>, but the masked computation is not interruptible (see
--   <a>Control.Exception#interruptible</a>). THIS SHOULD BE USED WITH
--   GREAT CARE, because if a thread executing in
--   <a>uninterruptibleMask</a> blocks for any reason, then the thread (and
--   possibly the program, if this is the main thread) will be unresponsive
--   and unkillable. This function should only be necessary if you need to
--   mask exceptions around an interruptible operation, and you can
--   guarantee that the interruptible operation will only block for a short
--   period of time.
uninterruptibleMask :: ((forall a. () => IO a -> IO a) -> IO b) -> IO b

-- | Like <a>uninterruptibleMask</a>, but does not pass a <tt>restore</tt>
--   action to the argument.
uninterruptibleMask_ :: IO a -> IO a

-- | Describes the behaviour of a thread when an asynchronous exception is
--   received.
data MaskingState

-- | asynchronous exceptions are unmasked (the normal state)
Unmasked :: MaskingState

-- | the state during <a>mask</a>: asynchronous exceptions are masked, but
--   blocking operations may still be interrupted
MaskedInterruptible :: MaskingState

-- | the state during <a>uninterruptibleMask</a>: asynchronous exceptions
--   are masked, and blocking operations may not be interrupted
MaskedUninterruptible :: MaskingState

-- | Returns the <a>MaskingState</a> for the current thread.
getMaskingState :: IO MaskingState
unsafeUnmask :: IO a -> IO a

-- | Allow asynchronous exceptions to be raised even inside <a>mask</a>,
--   making the operation interruptible (see the discussion of
--   "Interruptible operations" in <a>Exception</a>).
--   
--   When called outside <a>mask</a>, or inside <a>uninterruptibleMask</a>,
--   this function has no effect.
interruptible :: IO a -> IO a
onException :: IO a -> IO b -> IO a
bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
finally :: IO a -> IO b -> IO a

-- | Evaluate the argument to weak head normal form.
--   
--   <a>evaluate</a> is typically used to uncover any exceptions that a
--   lazy value may contain, and possibly handle them.
--   
--   <a>evaluate</a> only evaluates to <i>weak head normal form</i>. If
--   deeper evaluation is needed, the <tt>force</tt> function from
--   <tt>Control.DeepSeq</tt> may be handy:
--   
--   <pre>
--   evaluate $ force x
--   </pre>
--   
--   There is a subtle difference between <tt><a>evaluate</a> x</tt> and
--   <tt><a>return</a> <a>$!</a> x</tt>, analogous to the difference
--   between <a>throwIO</a> and <a>throw</a>. If the lazy value <tt>x</tt>
--   throws an exception, <tt><a>return</a> <a>$!</a> x</tt> will fail to
--   return an <a>IO</a> action and will throw an exception instead.
--   <tt><a>evaluate</a> x</tt>, on the other hand, always produces an
--   <a>IO</a> action; that action will throw an exception upon
--   <i>execution</i> iff <tt>x</tt> throws an exception upon
--   <i>evaluation</i>.
--   
--   The practical implication of this difference is that due to the
--   <i>imprecise exceptions</i> semantics,
--   
--   <pre>
--   (return $! error "foo") &gt;&gt; error "bar"
--   </pre>
--   
--   may throw either <tt>"foo"</tt> or <tt>"bar"</tt>, depending on the
--   optimizations performed by the compiler. On the other hand,
--   
--   <pre>
--   evaluate (error "foo") &gt;&gt; error "bar"
--   </pre>
--   
--   is guaranteed to throw <tt>"foo"</tt>.
--   
--   The rule of thumb is to use <a>evaluate</a> to force or handle
--   exceptions in lazy values. If, on the other hand, you are forcing a
--   lazy value for efficiency reasons only and do not care about
--   exceptions, you may use <tt><a>return</a> <a>$!</a> x</tt>.
evaluate :: a -> IO a

-- | The primitive used to implement <a>evaluate</a>. Prefer to use
--   <a>evaluate</a> whenever possible!
seq# :: a -> State# s -> (# State# s, a #)
mkUserError :: [Char] -> SomeException
instance GHC.Classes.Eq GHC.Internal.IO.MaskingState
instance GHC.Internal.Show.Show GHC.Internal.IO.MaskingState


-- | Stable names are a way of performing fast ( &lt;math&gt; ),
--   not-quite-exact comparison between objects.
--   
--   Stable names solve the following problem: suppose you want to build a
--   hash table with Haskell objects as keys, but you want to use pointer
--   equality for comparison; maybe because the keys are large and hashing
--   would be slow, or perhaps because the keys are infinite in size. We
--   can't build a hash table using the address of the object as the key,
--   because objects get moved around by the garbage collector, meaning a
--   re-hash would be necessary after every garbage collection.
module GHC.Internal.StableName

-- | An abstract name for an object, that supports equality and hashing.
--   
--   Stable names have the following property:
--   
--   <ul>
--   <li>If <tt>sn1 :: StableName</tt> and <tt>sn2 :: StableName</tt> and
--   <tt>sn1 == sn2</tt> then <tt>sn1</tt> and <tt>sn2</tt> were created by
--   calls to <tt>makeStableName</tt> on the same object.</li>
--   </ul>
--   
--   The reverse is not necessarily true: if two stable names are not
--   equal, then the objects they name may still be equal. Note in
--   particular that <a>makeStableName</a> may return a different
--   <a>StableName</a> after an object is evaluated.
--   
--   Stable Names are similar to Stable Pointers
--   (<a>Foreign.StablePtr</a>), but differ in the following ways:
--   
--   <ul>
--   <li>There is no <tt>freeStableName</tt> operation, unlike
--   <a>Foreign.StablePtr</a>s. Stable names are reclaimed by the runtime
--   system when they are no longer needed.</li>
--   <li>There is no <tt>deRefStableName</tt> operation. You can't get back
--   from a stable name to the original Haskell object. The reason for this
--   is that the existence of a stable name for an object does not
--   guarantee the existence of the object itself; it can still be garbage
--   collected.</li>
--   </ul>
data StableName a
StableName :: StableName# a -> StableName a

-- | Makes a <a>StableName</a> for an arbitrary object. The object passed
--   as the first argument is not evaluated by <a>makeStableName</a>.
makeStableName :: a -> IO (StableName a)

-- | Convert a <a>StableName</a> to an <a>Int</a>. The <a>Int</a> returned
--   is not necessarily unique; several <a>StableName</a>s may map to the
--   same <a>Int</a> (in practice however, the chances of this are small,
--   so the result of <a>hashStableName</a> makes a good hash key).
hashStableName :: StableName a -> Int

-- | Equality on <a>StableName</a> that does not require that the types of
--   the arguments match.
eqStableName :: StableName a -> StableName b -> Bool
instance GHC.Classes.Eq (GHC.Internal.StableName.StableName a)


-- | Stable names are a way of performing fast ( &lt;math&gt; ),
--   not-quite-exact comparison between objects.
--   
--   Stable names solve the following problem: suppose you want to build a
--   hash table with Haskell objects as keys, but you want to use pointer
--   equality for comparison; maybe because the keys are large and hashing
--   would be slow, or perhaps because the keys are infinite in size. We
--   can't build a hash table using the address of the object as the key,
--   because objects get moved around by the garbage collector, meaning a
--   re-hash would be necessary after every garbage collection.
--   
--   See <a>Stretching the storage manager: weak pointers and stable names
--   in Haskell</a> by Simon Peyton Jones, Simon Marlow and Conal Elliott
--   for detailed discussion of stable names. An implementation of a memo
--   table with stable names can be found in <a><tt>stable-memo</tt></a>
--   package.
module GHC.Internal.System.Mem.StableName

-- | An abstract name for an object, that supports equality and hashing.
--   
--   Stable names have the following property:
--   
--   <ul>
--   <li>If <tt>sn1 :: StableName</tt> and <tt>sn2 :: StableName</tt> and
--   <tt>sn1 == sn2</tt> then <tt>sn1</tt> and <tt>sn2</tt> were created by
--   calls to <tt>makeStableName</tt> on the same object.</li>
--   </ul>
--   
--   The reverse is not necessarily true: if two stable names are not
--   equal, then the objects they name may still be equal. Note in
--   particular that <a>makeStableName</a> may return a different
--   <a>StableName</a> after an object is evaluated.
--   
--   Stable Names are similar to Stable Pointers
--   (<a>Foreign.StablePtr</a>), but differ in the following ways:
--   
--   <ul>
--   <li>There is no <tt>freeStableName</tt> operation, unlike
--   <a>Foreign.StablePtr</a>s. Stable names are reclaimed by the runtime
--   system when they are no longer needed.</li>
--   <li>There is no <tt>deRefStableName</tt> operation. You can't get back
--   from a stable name to the original Haskell object. The reason for this
--   is that the existence of a stable name for an object does not
--   guarantee the existence of the object itself; it can still be garbage
--   collected.</li>
--   </ul>
data StableName a

-- | Makes a <a>StableName</a> for an arbitrary object. The object passed
--   as the first argument is not evaluated by <a>makeStableName</a>.
makeStableName :: a -> IO (StableName a)

-- | Convert a <a>StableName</a> to an <a>Int</a>. The <a>Int</a> returned
--   is not necessarily unique; several <a>StableName</a>s may map to the
--   same <a>Int</a> (in practice however, the chances of this are small,
--   so the result of <a>hashStableName</a> makes a good hash key).
hashStableName :: StableName a -> Int

-- | Equality on <a>StableName</a> that does not require that the types of
--   the arguments match.
eqStableName :: StableName a -> StableName b -> Bool


-- | The IORef type
module GHC.Internal.IORef

-- | A mutable variable in the <a>IO</a> monad.
--   
--   <pre>
--   &gt;&gt;&gt; import GHC.Internal.Data.IORef
--   
--   &gt;&gt;&gt; r &lt;- newIORef 0
--   
--   &gt;&gt;&gt; readIORef r
--   0
--   
--   &gt;&gt;&gt; writeIORef r 1
--   
--   &gt;&gt;&gt; readIORef r
--   1
--   
--   &gt;&gt;&gt; atomicWriteIORef r 2
--   
--   &gt;&gt;&gt; readIORef r
--   2
--   
--   &gt;&gt;&gt; modifyIORef' r (+ 1)
--   
--   &gt;&gt;&gt; readIORef r
--   3
--   
--   &gt;&gt;&gt; atomicModifyIORef' r (\a -&gt; (a + 1, ()))
--   
--   &gt;&gt;&gt; readIORef r
--   4
--   </pre>
--   
--   See also <a>STRef</a> and <a>MVar</a>.
newtype IORef a
IORef :: STRef RealWorld a -> IORef a

-- | Build a new <a>IORef</a>
newIORef :: a -> IO (IORef a)

-- | Read the value of an <a>IORef</a>.
--   
--   Beware that the CPU executing a thread can reorder reads or writes to
--   independent locations. See <a>Data.IORef#memmodel</a> for more
--   details.
readIORef :: IORef a -> IO a

-- | Write a new value into an <a>IORef</a>.
--   
--   This function does not create a memory barrier and can be reordered
--   with other independent reads and writes within a thread, which may
--   cause issues for multithreaded execution. In these cases, consider
--   using <a>atomicWriteIORef</a> instead. See <a>Data.IORef#memmodel</a>
--   for more details.
writeIORef :: IORef a -> a -> IO ()

-- | Atomically apply a function to the contents of an <a>IORef</a>,
--   installing its first component in the <a>IORef</a> and returning the
--   old contents and the result of applying the function. The result of
--   the function application (the pair) is not forced. As a result, this
--   can lead to memory leaks. It is generally better to use
--   <a>atomicModifyIORef2</a>.
atomicModifyIORef2Lazy :: IORef a -> (a -> (a, b)) -> IO (a, (a, b))

-- | Atomically apply a function to the contents of an <a>IORef</a>,
--   installing its first component in the <a>IORef</a> and returning the
--   old contents and the result of applying the function. The result of
--   the function application (the pair) is forced, but neither of its
--   components is.
atomicModifyIORef2 :: IORef a -> (a -> (a, b)) -> IO (a, (a, b))

-- | Atomically apply a function to the contents of an <a>IORef</a> and
--   return the old and new values. The result of the function is not
--   forced. As this can lead to a memory leak, it is usually better to use
--   <a>atomicModifyIORef'_</a>.
atomicModifyIORefLazy_ :: IORef a -> (a -> a) -> IO (a, a)

-- | Atomically apply a function to the contents of an <a>IORef</a> and
--   return the old and new values. The result of the function is forced.
atomicModifyIORef'_ :: IORef a -> (a -> a) -> IO (a, a)

-- | A version of <a>atomicModifyIORef</a> that forces the (pair) result of
--   the function.
atomicModifyIORefP :: IORef a -> (a -> (a, b)) -> IO b

-- | Atomically replace the contents of an <a>IORef</a>, returning the old
--   contents.
atomicSwapIORef :: IORef a -> a -> IO a

-- | A strict version of <a>atomicModifyIORef</a>. This forces both the
--   value stored in the <a>IORef</a> and the value returned.
--   
--   Conceptually,
--   
--   <pre>
--   atomicModifyIORef' ref f = do
--     -- Begin atomic block
--     old &lt;- <a>readIORef</a> ref
--     let r = f old
--         new = fst r
--     <a>writeIORef</a> ref new
--     -- End atomic block
--     case r of
--       (!_new, !res) -&gt; pure res
--   </pre>
--   
--   The actions in the "atomic block" are not subject to interference by
--   other threads. In particular, the value in the <a>IORef</a> cannot
--   change between the <a>readIORef</a> and <a>writeIORef</a> invocations.
--   
--   The new value is installed in the <a>IORef</a> before either value is
--   forced. So
--   
--   <pre>
--   atomicModifyIORef' ref (x -&gt; (x+1, undefined))
--   </pre>
--   
--   will increment the <a>IORef</a> and then throw an exception in the
--   calling thread.
--   
--   <pre>
--   atomicModifyIORef' ref (x -&gt; (undefined, x))
--   </pre>
--   
--   and
--   
--   <pre>
--   atomicModifyIORef' ref (_ -&gt; undefined)
--   </pre>
--   
--   will each raise an exception in the calling thread, but will
--   <i>also</i> install the bottoming value in the <a>IORef</a>, where it
--   may be read by other threads.
--   
--   This function imposes a memory barrier, preventing reordering around
--   the "atomic block"; see <a>Data.IORef#memmodel</a> for details.
atomicModifyIORef' :: IORef a -> (a -> (a, b)) -> IO b
instance GHC.Classes.Eq (GHC.Internal.IORef.IORef a)


-- | GHC's implementation of the <a>ForeignPtr</a> data type.
module GHC.Internal.ForeignPtr

-- | The type <a>ForeignPtr</a> represents references to objects that are
--   maintained in a foreign language, i.e., that are not part of the data
--   structures usually managed by the Haskell storage manager. The
--   essential difference between <a>ForeignPtr</a>s and vanilla memory
--   references of type <tt>Ptr a</tt> is that the former may be associated
--   with <i>finalizers</i>. A finalizer is a routine that is invoked when
--   the Haskell storage manager detects that - within the Haskell heap and
--   stack - there are no more references left that are pointing to the
--   <a>ForeignPtr</a>. Typically, the finalizer will, then, invoke
--   routines in the foreign language that free the resources bound by the
--   foreign object.
--   
--   The <a>ForeignPtr</a> is parameterised in the same way as <a>Ptr</a>.
--   The type argument of <a>ForeignPtr</a> should normally be an instance
--   of class <a>Storable</a>.
data ForeignPtr a
ForeignPtr :: Addr# -> ForeignPtrContents -> ForeignPtr a

-- | Controls finalization of a <a>ForeignPtr</a>, that is, what should
--   happen if the <a>ForeignPtr</a> becomes unreachable. Visually, these
--   data constructors are appropriate in these scenarios:
--   
--   <pre>
--                             Memory backing pointer is
--                              GC-Managed   Unmanaged
--   Finalizer functions are: +------------+-----------------+
--                   Allowed  | MallocPtr  | PlainForeignPtr |
--                            +------------+-----------------+
--                Prohibited  | PlainPtr   | FinalPtr        |
--                            +------------+-----------------+
--   </pre>
data ForeignPtrContents

-- | The pointer refers to unmanaged memory that was allocated by a foreign
--   function (typically using <tt>malloc</tt>). The finalizer frequently
--   calls the C function <tt>free</tt> or some variant of it.
PlainForeignPtr :: !IORef Finalizers -> ForeignPtrContents

-- | The pointer refers to unmanaged memory that should not be freed when
--   the <a>ForeignPtr</a> becomes unreachable. Functions that add
--   finalizers to a <a>ForeignPtr</a> throw exceptions when the
--   <a>ForeignPtr</a> is backed by <a>PlainPtr</a>Most commonly, this is
--   used with <tt>Addr#</tt> literals. See Note [Why FinalPtr].
FinalPtr :: ForeignPtrContents

-- | The pointer refers to a byte array. The <a>MutableByteArray#</a> field
--   means that the <a>MutableByteArray#</a> is reachable (by GC) whenever
--   the <a>ForeignPtr</a> is reachable. When the <a>ForeignPtr</a> becomes
--   unreachable, the runtime's normal GC recovers the memory backing it.
--   Here, the finalizer function intended to be used to <tt>free()</tt>
--   any ancillary *unmanaged* memory pointed to by the
--   <a>MutableByteArray#</a>. See the <tt>zlib</tt> library for an example
--   of this use.
--   
--   <ol>
--   <li>Invariant: The <a>Addr#</a> in the parent <a>ForeignPtr</a> is an
--   interior pointer into this <a>MutableByteArray#</a>.</li>
--   <li>Invariant: The <a>MutableByteArray#</a> is pinned, so the
--   <a>Addr#</a> does not get invalidated by the GC moving the byte
--   array.</li>
--   <li>Invariant: A <a>MutableByteArray#</a> must not be associated with
--   more than one set of finalizers. For example, this is sound:</li>
--   </ol>
--   
--   <pre>
--   incrGood :: ForeignPtr Word8 -&gt; ForeignPtr Word8
--   incrGood (ForeignPtr p (MallocPtr m f)) = ForeignPtr (plusPtr p 1) (MallocPtr m f)
--   </pre>
--   
--   But this is unsound:
--   
--   <pre>
--   incrBad :: ForeignPtr Word8 -&gt; IO (ForeignPtr Word8)
--   incrBad (ForeignPtr p (MallocPtr m _)) = do
--     f &lt;- newIORef NoFinalizers
--     pure (ForeignPtr p (MallocPtr m f))
--   </pre>
MallocPtr :: MutableByteArray# RealWorld -> !IORef Finalizers -> ForeignPtrContents

-- | The pointer refers to a byte array. Finalization is not supported.
--   This optimizes <tt>MallocPtr</tt> by avoiding the allocation of a
--   <tt>MutVar#</tt> when it is known that no one will add finalizers to
--   the <tt>ForeignPtr</tt>. Functions that add finalizers to a
--   <a>ForeignPtr</a> throw exceptions when the <a>ForeignPtr</a> is
--   backed by <a>PlainPtr</a>. The invariants that apply to
--   <a>MallocPtr</a> apply to <a>PlainPtr</a> as well.
PlainPtr :: MutableByteArray# RealWorld -> ForeignPtrContents

-- | Functions called when a <a>ForeignPtr</a> is finalized. Note that C
--   finalizers and Haskell finalizers cannot be mixed.
data Finalizers

-- | No finalizer. If there is no intent to add a finalizer at any point in
--   the future, consider <a>FinalPtr</a> or <a>PlainPtr</a> instead since
--   these perform fewer allocations.
NoFinalizers :: Finalizers

-- | Finalizers are all C functions.
CFinalizers :: Weak# () -> Finalizers

-- | Finalizers are all Haskell functions.
HaskellFinalizers :: [IO ()] -> Finalizers

-- | A finalizer is represented as a pointer to a foreign function that, at
--   finalisation time, gets as an argument a plain pointer variant of the
--   foreign pointer that the finalizer is associated with.
--   
--   Note that the foreign function <i>must</i> either use the
--   <tt>ccall</tt> or the <tt>capi</tt> calling convention.
type FinalizerPtr a = FunPtr Ptr a -> IO ()
type FinalizerEnvPtr env a = FunPtr Ptr env -> Ptr a -> IO ()

-- | Turns a plain memory reference into a foreign pointer that may be
--   associated with finalizers by using <a>addForeignPtrFinalizer</a>.
newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)

-- | Allocate some memory and return a <a>ForeignPtr</a> to it. The memory
--   will be released automatically when the <a>ForeignPtr</a> is
--   discarded.
--   
--   <a>mallocForeignPtr</a> is equivalent to
--   
--   <pre>
--   do { p &lt;- malloc; newForeignPtr finalizerFree p }
--   </pre>
--   
--   although it may be implemented differently internally: you may not
--   assume that the memory returned by <a>mallocForeignPtr</a> has been
--   allocated with <a>malloc</a>.
--   
--   GHC notes: <a>mallocForeignPtr</a> has a heavily optimised
--   implementation in GHC. It uses pinned memory in the garbage collected
--   heap, so the <a>ForeignPtr</a> does not require a finalizer to free
--   the memory. Use of <a>mallocForeignPtr</a> and associated functions is
--   strongly recommended in preference to <a>newForeignPtr</a> with a
--   finalizer.
mallocForeignPtr :: Storable a => IO (ForeignPtr a)

-- | Allocate some memory and return a <a>ForeignPtr</a> to it. The memory
--   will be released automatically when the <a>ForeignPtr</a> is
--   discarded.
--   
--   GHC notes: <a>mallocPlainForeignPtr</a> has a heavily optimised
--   implementation in GHC. It uses pinned memory in the garbage collected
--   heap, as for mallocForeignPtr. Unlike mallocForeignPtr, a ForeignPtr
--   created with mallocPlainForeignPtr carries no finalizers. It is not
--   possible to add a finalizer to a ForeignPtr created with
--   mallocPlainForeignPtr. This is useful for ForeignPtrs that will live
--   only inside Haskell (such as those created for packed strings).
--   Attempts to add a finalizer to a ForeignPtr created this way, or to
--   finalize such a pointer, will throw an exception.
mallocPlainForeignPtr :: Storable a => IO (ForeignPtr a)

-- | This function is similar to <a>mallocForeignPtr</a>, except that the
--   size of the memory required is given explicitly as a number of bytes.
mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocForeignPtrBytes</a>, except that
--   the internally an optimised ForeignPtr representation with no
--   finalizer is used. Attempts to add a finalizer will cause an exception
--   to be thrown.
mallocPlainForeignPtrBytes :: Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocForeignPtrBytes</a>, except that
--   the size and alignment of the memory required is given explicitly as
--   numbers of bytes.
mallocForeignPtrAlignedBytes :: Int -> Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocForeignPtrAlignedBytes</a>,
--   except that the internally an optimised ForeignPtr representation with
--   no finalizer is used. Attempts to add a finalizer will cause an
--   exception to be thrown.
mallocPlainForeignPtrAlignedBytes :: Int -> Int -> IO (ForeignPtr a)

-- | Turns a plain memory reference into a foreign object by associating a
--   finalizer - given by the monadic operation - with the reference.
--   
--   When finalization is triggered by GC, the storage manager will start
--   the finalizer, in a separate thread, some time after the last
--   reference to the <tt>ForeignPtr</tt> is dropped. There is <b>no
--   guarantee of promptness</b>, and in fact there is no guarantee that
--   the finalizer will eventually run at all for GC-triggered
--   finalization.
--   
--   When finalization is triggered by explicitly calling
--   <tt>finalizeForeignPtr</tt>, the finalizer will run immediately on the
--   current Haskell thread.
--   
--   Note that references from a finalizer do not necessarily prevent
--   another object from being finalized. If A's finalizer refers to B
--   (perhaps using <a>touchForeignPtr</a>, then the only guarantee is that
--   B's finalizer will never be started before A's. If both A and B are
--   unreachable, then both finalizers will start together. See
--   <a>touchForeignPtr</a> for more on finalizer ordering.
newConcForeignPtr :: Ptr a -> IO () -> IO (ForeignPtr a)

-- | This function adds a finalizer to the given foreign object. The
--   finalizer will run <i>before</i> all other finalizers for the same
--   object which have already been registered.
addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()

-- | Like <a>addForeignPtrFinalizer</a> but the finalizer is passed an
--   additional environment parameter.
addForeignPtrFinalizerEnv :: FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO ()

-- | This function adds a finalizer to the given <tt>ForeignPtr</tt>. The
--   finalizer will run <i>before</i> all other finalizers for the same
--   object which have already been registered.
--   
--   This is a variant of <tt>addForeignPtrFinalizer</tt>, where the
--   finalizer is an arbitrary <tt>IO</tt> action. When finalization is
--   triggered by GC, the finalizer will run in a new thread. When
--   finalization is triggered by explicitly calling
--   <tt>finalizeForeignPtr</tt>, the finalizer will run immediately on the
--   current Haskell thread.
--   
--   NB. Be very careful with these finalizers. One common trap is that if
--   a finalizer references another finalized value, it does not prevent
--   that value from being finalized. In particular, <a>Handle</a>s are
--   finalized objects, so a finalizer should not refer to a <a>Handle</a>
--   (including <a>stdout</a>, <a>stdin</a>, or <a>stderr</a>).
addForeignPtrConcFinalizer :: ForeignPtr a -> IO () -> IO ()

-- | This function extracts the pointer component of a foreign pointer.
--   This is a potentially dangerous operations, as if the argument to
--   <a>unsafeForeignPtrToPtr</a> is the last usage occurrence of the given
--   foreign pointer, then its finalizer(s) will be run, which potentially
--   invalidates the plain pointer just obtained. Hence,
--   <a>touchForeignPtr</a> must be used wherever it has to be guaranteed
--   that the pointer lives on - i.e., has another usage occurrence.
--   
--   To avoid subtle coding errors, hand written marshalling code should
--   preferably use <a>withForeignPtr</a> rather than combinations of
--   <a>unsafeForeignPtrToPtr</a> and <a>touchForeignPtr</a>. However, the
--   latter routines are occasionally preferred in tool generated
--   marshalling code.
unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a

-- | This function casts a <a>ForeignPtr</a> parameterised by one type into
--   another type.
castForeignPtr :: ForeignPtr a -> ForeignPtr b

-- | Advances the given address by the given offset in bytes.
--   
--   The new <a>ForeignPtr</a> shares the finalizer of the original,
--   equivalent from a finalization standpoint to just creating another
--   reference to the original. That is, the finalizer will not be called
--   before the new <a>ForeignPtr</a> is unreachable, nor will it be called
--   an additional time due to this call, and the finalizer will be called
--   with the same address that it would have had this call not happened,
--   *not* the new address.
plusForeignPtr :: ForeignPtr a -> Int -> ForeignPtr b

-- | This is a way to look at the pointer living inside a foreign object.
--   This function takes a function which is applied to that pointer. The
--   resulting <a>IO</a> action is then executed. The foreign object is
--   kept alive at least during the whole action, even if it is not used
--   directly inside. Note that it is not safe to return the pointer from
--   the action and use it after the action completes. All uses of the
--   pointer should be inside the <a>withForeignPtr</a> bracket. The reason
--   for this unsafeness is the same as for <a>unsafeForeignPtrToPtr</a>
--   below: the finalizer may run earlier than expected, because the
--   compiler can only track usage of the <a>ForeignPtr</a> object, not a
--   <a>Ptr</a> object made from it.
--   
--   This function is normally used for marshalling data to or from the
--   object pointed to by the <a>ForeignPtr</a>, using the operations from
--   the <a>Storable</a> class.
withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b

-- | This is similar to <a>withForeignPtr</a> but comes with an important
--   caveat: the user must guarantee that the continuation does not diverge
--   (e.g. loop or throw an exception). In exchange for this loss of
--   generality, this function offers the ability of GHC to optimise more
--   aggressively.
--   
--   Specifically, applications of the form: <tt> unsafeWithForeignPtr fptr
--   (<a>forever</a> something) </tt>
--   
--   See GHC issue #17760 for more information about the unsoundness
--   behavior that this function can result in.
unsafeWithForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b

-- | This function ensures that the foreign object in question is alive at
--   the given place in the sequence of IO actions. However, this comes
--   with a significant caveat: the contract above does not hold if GHC can
--   demonstrate that the code preceding <tt>touchForeignPtr</tt> diverges
--   (e.g. by looping infinitely or throwing an exception). For this
--   reason, you are strongly advised to use instead <a>withForeignPtr</a>
--   where possible.
--   
--   Also, note that this function should not be used to express
--   dependencies between finalizers on <a>ForeignPtr</a>s. For example, if
--   the finalizer for a <a>ForeignPtr</a> <tt>F1</tt> calls
--   <a>touchForeignPtr</a> on a second <a>ForeignPtr</a> <tt>F2</tt>, then
--   the only guarantee is that the finalizer for <tt>F2</tt> is never
--   started before the finalizer for <tt>F1</tt>. They might be started
--   together if for example both <tt>F1</tt> and <tt>F2</tt> are otherwise
--   unreachable, and in that case the scheduler might end up running the
--   finalizer for <tt>F2</tt> first.
--   
--   In general, it is not recommended to use finalizers on separate
--   objects with ordering constraints between them. To express the
--   ordering robustly requires explicit synchronisation using
--   <tt>MVar</tt>s between the finalizers, but even then the runtime
--   sometimes runs multiple finalizers sequentially in a single thread
--   (for performance reasons), so synchronisation between finalizers could
--   result in artificial deadlock. Another alternative is to use explicit
--   reference counting.
touchForeignPtr :: ForeignPtr a -> IO ()

-- | Causes the finalizers associated with a foreign pointer to be run
--   immediately. The foreign pointer must not be used again after this
--   function is called. If the foreign pointer does not support
--   finalizers, this is a no-op.
finalizeForeignPtr :: ForeignPtr a -> IO ()
instance GHC.Classes.Eq (GHC.Internal.ForeignPtr.ForeignPtr a)
instance GHC.Classes.Ord (GHC.Internal.ForeignPtr.ForeignPtr a)
instance GHC.Internal.Show.Show (GHC.Internal.ForeignPtr.ForeignPtr a)


-- | The <a>ForeignPtr</a> type and operations. This module is part of the
--   Foreign Function Interface (FFI) and will usually be imported via the
--   <a>Foreign</a> module.
module GHC.Internal.Foreign.ForeignPtr.Imp

-- | The type <a>ForeignPtr</a> represents references to objects that are
--   maintained in a foreign language, i.e., that are not part of the data
--   structures usually managed by the Haskell storage manager. The
--   essential difference between <a>ForeignPtr</a>s and vanilla memory
--   references of type <tt>Ptr a</tt> is that the former may be associated
--   with <i>finalizers</i>. A finalizer is a routine that is invoked when
--   the Haskell storage manager detects that - within the Haskell heap and
--   stack - there are no more references left that are pointing to the
--   <a>ForeignPtr</a>. Typically, the finalizer will, then, invoke
--   routines in the foreign language that free the resources bound by the
--   foreign object.
--   
--   The <a>ForeignPtr</a> is parameterised in the same way as <a>Ptr</a>.
--   The type argument of <a>ForeignPtr</a> should normally be an instance
--   of class <a>Storable</a>.
data ForeignPtr a

-- | A finalizer is represented as a pointer to a foreign function that, at
--   finalisation time, gets as an argument a plain pointer variant of the
--   foreign pointer that the finalizer is associated with.
--   
--   Note that the foreign function <i>must</i> either use the
--   <tt>ccall</tt> or the <tt>capi</tt> calling convention.
type FinalizerPtr a = FunPtr Ptr a -> IO ()
type FinalizerEnvPtr env a = FunPtr Ptr env -> Ptr a -> IO ()

-- | Turns a plain memory reference into a foreign pointer, and associates
--   a finalizer with the reference. The finalizer will be executed after
--   the last reference to the foreign object is dropped. There is no
--   guarantee of promptness, however the finalizer will be executed before
--   the program exits.
newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)

-- | Turns a plain memory reference into a foreign pointer that may be
--   associated with finalizers by using <a>addForeignPtrFinalizer</a>.
newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)

-- | This function adds a finalizer to the given foreign object. The
--   finalizer will run <i>before</i> all other finalizers for the same
--   object which have already been registered.
addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()

-- | This variant of <a>newForeignPtr</a> adds a finalizer that expects an
--   environment in addition to the finalized pointer. The environment that
--   will be passed to the finalizer is fixed by the second argument to
--   <a>newForeignPtrEnv</a>.
newForeignPtrEnv :: FinalizerEnvPtr env a -> Ptr env -> Ptr a -> IO (ForeignPtr a)

-- | Like <a>addForeignPtrFinalizer</a> but the finalizer is passed an
--   additional environment parameter.
addForeignPtrFinalizerEnv :: FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO ()

-- | This is a way to look at the pointer living inside a foreign object.
--   This function takes a function which is applied to that pointer. The
--   resulting <a>IO</a> action is then executed. The foreign object is
--   kept alive at least during the whole action, even if it is not used
--   directly inside. Note that it is not safe to return the pointer from
--   the action and use it after the action completes. All uses of the
--   pointer should be inside the <a>withForeignPtr</a> bracket. The reason
--   for this unsafeness is the same as for <a>unsafeForeignPtrToPtr</a>
--   below: the finalizer may run earlier than expected, because the
--   compiler can only track usage of the <a>ForeignPtr</a> object, not a
--   <a>Ptr</a> object made from it.
--   
--   This function is normally used for marshalling data to or from the
--   object pointed to by the <a>ForeignPtr</a>, using the operations from
--   the <a>Storable</a> class.
withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b

-- | Causes the finalizers associated with a foreign pointer to be run
--   immediately. The foreign pointer must not be used again after this
--   function is called. If the foreign pointer does not support
--   finalizers, this is a no-op.
finalizeForeignPtr :: ForeignPtr a -> IO ()

-- | This function extracts the pointer component of a foreign pointer.
--   This is a potentially dangerous operations, as if the argument to
--   <a>unsafeForeignPtrToPtr</a> is the last usage occurrence of the given
--   foreign pointer, then its finalizer(s) will be run, which potentially
--   invalidates the plain pointer just obtained. Hence,
--   <a>touchForeignPtr</a> must be used wherever it has to be guaranteed
--   that the pointer lives on - i.e., has another usage occurrence.
--   
--   To avoid subtle coding errors, hand written marshalling code should
--   preferably use <a>withForeignPtr</a> rather than combinations of
--   <a>unsafeForeignPtrToPtr</a> and <a>touchForeignPtr</a>. However, the
--   latter routines are occasionally preferred in tool generated
--   marshalling code.
unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a

-- | This function ensures that the foreign object in question is alive at
--   the given place in the sequence of IO actions. However, this comes
--   with a significant caveat: the contract above does not hold if GHC can
--   demonstrate that the code preceding <tt>touchForeignPtr</tt> diverges
--   (e.g. by looping infinitely or throwing an exception). For this
--   reason, you are strongly advised to use instead <a>withForeignPtr</a>
--   where possible.
--   
--   Also, note that this function should not be used to express
--   dependencies between finalizers on <a>ForeignPtr</a>s. For example, if
--   the finalizer for a <a>ForeignPtr</a> <tt>F1</tt> calls
--   <a>touchForeignPtr</a> on a second <a>ForeignPtr</a> <tt>F2</tt>, then
--   the only guarantee is that the finalizer for <tt>F2</tt> is never
--   started before the finalizer for <tt>F1</tt>. They might be started
--   together if for example both <tt>F1</tt> and <tt>F2</tt> are otherwise
--   unreachable, and in that case the scheduler might end up running the
--   finalizer for <tt>F2</tt> first.
--   
--   In general, it is not recommended to use finalizers on separate
--   objects with ordering constraints between them. To express the
--   ordering robustly requires explicit synchronisation using
--   <tt>MVar</tt>s between the finalizers, but even then the runtime
--   sometimes runs multiple finalizers sequentially in a single thread
--   (for performance reasons), so synchronisation between finalizers could
--   result in artificial deadlock. Another alternative is to use explicit
--   reference counting.
touchForeignPtr :: ForeignPtr a -> IO ()

-- | This function casts a <a>ForeignPtr</a> parameterised by one type into
--   another type.
castForeignPtr :: ForeignPtr a -> ForeignPtr b

-- | Advances the given address by the given offset in bytes.
--   
--   The new <a>ForeignPtr</a> shares the finalizer of the original,
--   equivalent from a finalization standpoint to just creating another
--   reference to the original. That is, the finalizer will not be called
--   before the new <a>ForeignPtr</a> is unreachable, nor will it be called
--   an additional time due to this call, and the finalizer will be called
--   with the same address that it would have had this call not happened,
--   *not* the new address.
plusForeignPtr :: ForeignPtr a -> Int -> ForeignPtr b

-- | Allocate some memory and return a <a>ForeignPtr</a> to it. The memory
--   will be released automatically when the <a>ForeignPtr</a> is
--   discarded.
--   
--   <a>mallocForeignPtr</a> is equivalent to
--   
--   <pre>
--   do { p &lt;- malloc; newForeignPtr finalizerFree p }
--   </pre>
--   
--   although it may be implemented differently internally: you may not
--   assume that the memory returned by <a>mallocForeignPtr</a> has been
--   allocated with <a>malloc</a>.
--   
--   GHC notes: <a>mallocForeignPtr</a> has a heavily optimised
--   implementation in GHC. It uses pinned memory in the garbage collected
--   heap, so the <a>ForeignPtr</a> does not require a finalizer to free
--   the memory. Use of <a>mallocForeignPtr</a> and associated functions is
--   strongly recommended in preference to <a>newForeignPtr</a> with a
--   finalizer.
mallocForeignPtr :: Storable a => IO (ForeignPtr a)

-- | This function is similar to <a>mallocForeignPtr</a>, except that the
--   size of the memory required is given explicitly as a number of bytes.
mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocArray</a>, but yields a memory
--   area that has a finalizer attached that releases the memory area. As
--   with <a>mallocForeignPtr</a>, it is not guaranteed that the block of
--   memory was allocated by <a>malloc</a>.
mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocArray0</a>, but yields a memory
--   area that has a finalizer attached that releases the memory area. As
--   with <a>mallocForeignPtr</a>, it is not guaranteed that the block of
--   memory was allocated by <a>malloc</a>.
mallocForeignPtrArray0 :: Storable a => Int -> IO (ForeignPtr a)


-- | The <a>ForeignPtr</a> type and operations. This module is part of the
--   Foreign Function Interface (FFI) and will usually be imported via the
--   <a>Foreign</a> module.
--   
--   Unsafe API Only.
module GHC.Internal.Foreign.ForeignPtr.Unsafe

-- | This function extracts the pointer component of a foreign pointer.
--   This is a potentially dangerous operations, as if the argument to
--   <a>unsafeForeignPtrToPtr</a> is the last usage occurrence of the given
--   foreign pointer, then its finalizer(s) will be run, which potentially
--   invalidates the plain pointer just obtained. Hence,
--   <a>touchForeignPtr</a> must be used wherever it has to be guaranteed
--   that the pointer lives on - i.e., has another usage occurrence.
--   
--   To avoid subtle coding errors, hand written marshalling code should
--   preferably use <a>withForeignPtr</a> rather than combinations of
--   <a>unsafeForeignPtrToPtr</a> and <a>touchForeignPtr</a>. However, the
--   latter routines are occasionally preferred in tool generated
--   marshalling code.
unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a


-- | The <a>ForeignPtr</a> type and operations. This module is part of the
--   Foreign Function Interface (FFI) and will usually be imported via the
--   <a>Foreign</a> module.
--   
--   For non-portable support of Haskell finalizers, see the
--   <a>Foreign.Concurrent</a> module.
module GHC.Internal.Foreign.ForeignPtr

-- | The type <a>ForeignPtr</a> represents references to objects that are
--   maintained in a foreign language, i.e., that are not part of the data
--   structures usually managed by the Haskell storage manager. The
--   essential difference between <a>ForeignPtr</a>s and vanilla memory
--   references of type <tt>Ptr a</tt> is that the former may be associated
--   with <i>finalizers</i>. A finalizer is a routine that is invoked when
--   the Haskell storage manager detects that - within the Haskell heap and
--   stack - there are no more references left that are pointing to the
--   <a>ForeignPtr</a>. Typically, the finalizer will, then, invoke
--   routines in the foreign language that free the resources bound by the
--   foreign object.
--   
--   The <a>ForeignPtr</a> is parameterised in the same way as <a>Ptr</a>.
--   The type argument of <a>ForeignPtr</a> should normally be an instance
--   of class <a>Storable</a>.
data ForeignPtr a

-- | A finalizer is represented as a pointer to a foreign function that, at
--   finalisation time, gets as an argument a plain pointer variant of the
--   foreign pointer that the finalizer is associated with.
--   
--   Note that the foreign function <i>must</i> either use the
--   <tt>ccall</tt> or the <tt>capi</tt> calling convention.
type FinalizerPtr a = FunPtr Ptr a -> IO ()
type FinalizerEnvPtr env a = FunPtr Ptr env -> Ptr a -> IO ()

-- | Turns a plain memory reference into a foreign pointer, and associates
--   a finalizer with the reference. The finalizer will be executed after
--   the last reference to the foreign object is dropped. There is no
--   guarantee of promptness, however the finalizer will be executed before
--   the program exits.
newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)

-- | Turns a plain memory reference into a foreign pointer that may be
--   associated with finalizers by using <a>addForeignPtrFinalizer</a>.
newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)

-- | This function adds a finalizer to the given foreign object. The
--   finalizer will run <i>before</i> all other finalizers for the same
--   object which have already been registered.
addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()

-- | This variant of <a>newForeignPtr</a> adds a finalizer that expects an
--   environment in addition to the finalized pointer. The environment that
--   will be passed to the finalizer is fixed by the second argument to
--   <a>newForeignPtrEnv</a>.
newForeignPtrEnv :: FinalizerEnvPtr env a -> Ptr env -> Ptr a -> IO (ForeignPtr a)

-- | Like <a>addForeignPtrFinalizer</a> but the finalizer is passed an
--   additional environment parameter.
addForeignPtrFinalizerEnv :: FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO ()

-- | This is a way to look at the pointer living inside a foreign object.
--   This function takes a function which is applied to that pointer. The
--   resulting <a>IO</a> action is then executed. The foreign object is
--   kept alive at least during the whole action, even if it is not used
--   directly inside. Note that it is not safe to return the pointer from
--   the action and use it after the action completes. All uses of the
--   pointer should be inside the <a>withForeignPtr</a> bracket. The reason
--   for this unsafeness is the same as for <a>unsafeForeignPtrToPtr</a>
--   below: the finalizer may run earlier than expected, because the
--   compiler can only track usage of the <a>ForeignPtr</a> object, not a
--   <a>Ptr</a> object made from it.
--   
--   This function is normally used for marshalling data to or from the
--   object pointed to by the <a>ForeignPtr</a>, using the operations from
--   the <a>Storable</a> class.
withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b

-- | Causes the finalizers associated with a foreign pointer to be run
--   immediately. The foreign pointer must not be used again after this
--   function is called. If the foreign pointer does not support
--   finalizers, this is a no-op.
finalizeForeignPtr :: ForeignPtr a -> IO ()

-- | This function ensures that the foreign object in question is alive at
--   the given place in the sequence of IO actions. However, this comes
--   with a significant caveat: the contract above does not hold if GHC can
--   demonstrate that the code preceding <tt>touchForeignPtr</tt> diverges
--   (e.g. by looping infinitely or throwing an exception). For this
--   reason, you are strongly advised to use instead <a>withForeignPtr</a>
--   where possible.
--   
--   Also, note that this function should not be used to express
--   dependencies between finalizers on <a>ForeignPtr</a>s. For example, if
--   the finalizer for a <a>ForeignPtr</a> <tt>F1</tt> calls
--   <a>touchForeignPtr</a> on a second <a>ForeignPtr</a> <tt>F2</tt>, then
--   the only guarantee is that the finalizer for <tt>F2</tt> is never
--   started before the finalizer for <tt>F1</tt>. They might be started
--   together if for example both <tt>F1</tt> and <tt>F2</tt> are otherwise
--   unreachable, and in that case the scheduler might end up running the
--   finalizer for <tt>F2</tt> first.
--   
--   In general, it is not recommended to use finalizers on separate
--   objects with ordering constraints between them. To express the
--   ordering robustly requires explicit synchronisation using
--   <tt>MVar</tt>s between the finalizers, but even then the runtime
--   sometimes runs multiple finalizers sequentially in a single thread
--   (for performance reasons), so synchronisation between finalizers could
--   result in artificial deadlock. Another alternative is to use explicit
--   reference counting.
touchForeignPtr :: ForeignPtr a -> IO ()

-- | This function casts a <a>ForeignPtr</a> parameterised by one type into
--   another type.
castForeignPtr :: ForeignPtr a -> ForeignPtr b

-- | Advances the given address by the given offset in bytes.
--   
--   The new <a>ForeignPtr</a> shares the finalizer of the original,
--   equivalent from a finalization standpoint to just creating another
--   reference to the original. That is, the finalizer will not be called
--   before the new <a>ForeignPtr</a> is unreachable, nor will it be called
--   an additional time due to this call, and the finalizer will be called
--   with the same address that it would have had this call not happened,
--   *not* the new address.
plusForeignPtr :: ForeignPtr a -> Int -> ForeignPtr b

-- | Allocate some memory and return a <a>ForeignPtr</a> to it. The memory
--   will be released automatically when the <a>ForeignPtr</a> is
--   discarded.
--   
--   <a>mallocForeignPtr</a> is equivalent to
--   
--   <pre>
--   do { p &lt;- malloc; newForeignPtr finalizerFree p }
--   </pre>
--   
--   although it may be implemented differently internally: you may not
--   assume that the memory returned by <a>mallocForeignPtr</a> has been
--   allocated with <a>malloc</a>.
--   
--   GHC notes: <a>mallocForeignPtr</a> has a heavily optimised
--   implementation in GHC. It uses pinned memory in the garbage collected
--   heap, so the <a>ForeignPtr</a> does not require a finalizer to free
--   the memory. Use of <a>mallocForeignPtr</a> and associated functions is
--   strongly recommended in preference to <a>newForeignPtr</a> with a
--   finalizer.
mallocForeignPtr :: Storable a => IO (ForeignPtr a)

-- | This function is similar to <a>mallocForeignPtr</a>, except that the
--   size of the memory required is given explicitly as a number of bytes.
mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocArray</a>, but yields a memory
--   area that has a finalizer attached that releases the memory area. As
--   with <a>mallocForeignPtr</a>, it is not guaranteed that the block of
--   memory was allocated by <a>malloc</a>.
mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocArray0</a>, but yields a memory
--   area that has a finalizer attached that releases the memory area. As
--   with <a>mallocForeignPtr</a>, it is not guaranteed that the block of
--   memory was allocated by <a>malloc</a>.
mallocForeignPtrArray0 :: Storable a => Int -> IO (ForeignPtr a)


-- | Buffers used in the IO system
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.IO.Buffer

-- | A mutable array of bytes that can be passed to foreign functions.
--   
--   The buffer is represented by a record, where the record contains the
--   raw buffer and the start/end points of the filled portion. The buffer
--   contents itself is mutable, but the rest of the record is immutable.
--   This is a slightly odd mix, but it turns out to be quite practical: by
--   making all the buffer metadata immutable, we can have operations on
--   buffer metadata outside of the IO monad.
--   
--   The "live" elements of the buffer are those between the <a>bufL</a>
--   and <a>bufR</a> offsets. In an empty buffer, <a>bufL</a> is equal to
--   <a>bufR</a>, but they might not be zero: for example, the buffer might
--   correspond to a memory-mapped file and in which case <a>bufL</a> will
--   point to the next location to be written, which is not necessarily the
--   beginning of the file.
--   
--   On Posix systems the I/O manager has an implicit reliance on doing a
--   file read moving the file pointer. However on Windows async operations
--   the kernel object representing a file does not use the file pointer
--   offset. Logically this makes sense since operations can be performed
--   in any arbitrary order. OVERLAPPED operations don't respect the file
--   pointer offset as their intention is to support arbitrary async reads
--   to anywhere at a much lower level. As such we should explicitly keep
--   track of the file offsets of the target in the buffer. Any operation
--   to seek should also update this entry.
--   
--   In order to keep us sane we try to uphold the invariant that any
--   function being passed a Handle is responsible for updating the handles
--   offset unless other behaviour is documented.
data Buffer e
Buffer :: !RawBuffer e -> BufferState -> !Int -> !Word64 -> !Int -> !Int -> Buffer e
[bufRaw] :: Buffer e -> !RawBuffer e
[bufState] :: Buffer e -> BufferState
[bufSize] :: Buffer e -> !Int
[bufOffset] :: Buffer e -> !Word64
[bufL] :: Buffer e -> !Int
[bufR] :: Buffer e -> !Int
data BufferState
ReadBuffer :: BufferState
WriteBuffer :: BufferState
type CharBuffer = Buffer Char
type CharBufElem = Char
newByteBuffer :: Int -> BufferState -> IO (Buffer Word8)
newCharBuffer :: Int -> BufferState -> IO CharBuffer
newBuffer :: Int -> Int -> BufferState -> IO (Buffer e)
emptyBuffer :: RawBuffer e -> Int -> BufferState -> Buffer e
bufferRemove :: Int -> Buffer e -> Buffer e
bufferAdd :: Int -> Buffer e -> Buffer e

-- | slides the contents of the buffer to the beginning
slideContents :: Buffer Word8 -> IO (Buffer Word8)
bufferAdjustL :: Int -> Buffer e -> Buffer e
bufferAddOffset :: Int -> Buffer e -> Buffer e
bufferAdjustOffset :: Word64 -> Buffer e -> Buffer e
isEmptyBuffer :: Buffer e -> Bool
isFullBuffer :: Buffer e -> Bool
isFullCharBuffer :: Buffer e -> Bool
isWriteBuffer :: Buffer e -> Bool
bufferElems :: Buffer e -> Int
bufferAvailable :: Buffer e -> Int
bufferOffset :: Buffer e -> Word64
summaryBuffer :: Buffer a -> String
withBuffer :: Buffer e -> (Ptr e -> IO a) -> IO a
withRawBuffer :: RawBuffer e -> (Ptr e -> IO a) -> IO a
checkBuffer :: Buffer a -> IO ()
type RawBuffer e = ForeignPtr e
readWord8Buf :: RawBuffer Word8 -> Int -> IO Word8
writeWord8Buf :: RawBuffer Word8 -> Int -> Word8 -> IO ()
type RawCharBuffer = RawBuffer CharBufElem
peekCharBuf :: RawCharBuffer -> Int -> IO Char
readCharBuf :: RawCharBuffer -> Int -> IO (Char, Int)
writeCharBuf :: RawCharBuffer -> Int -> Char -> IO Int
readCharBufPtr :: Ptr CharBufElem -> Int -> IO (Char, Int)
writeCharBufPtr :: Ptr CharBufElem -> Int -> Char -> IO Int
charSize :: Int
instance GHC.Classes.Eq GHC.Internal.IO.Buffer.BufferState


-- | Types for text encoding/decoding
module GHC.Internal.IO.Encoding.Types
data BufferCodec from to state
BufferCodec# :: CodeBuffer# from to -> (Buffer from -> Buffer to -> State# RealWorld -> (# State# RealWorld, Buffer from, Buffer to #)) -> IO () -> IO state -> (state -> IO ()) -> BufferCodec from to state

-- | The <tt>encode</tt> function translates elements of the buffer
--   <tt>from</tt> to the buffer <tt>to</tt>. It should translate as many
--   elements as possible given the sizes of the buffers, including
--   translating zero elements if there is either not enough room in
--   <tt>to</tt>, or <tt>from</tt> does not contain a complete multibyte
--   sequence.
--   
--   If multiple CodingProgress returns are possible, OutputUnderflow must
--   be preferred to InvalidSequence. This allows GHC's IO library to
--   assume that if we observe InvalidSequence there is at least a single
--   element available in the output buffer.
--   
--   The fact that as many elements as possible are translated is used by
--   the IO library in order to report translation errors at the point they
--   actually occur, rather than when the buffer is translated.
[encode#] :: BufferCodec from to state -> CodeBuffer# from to

-- | The <tt>recover</tt> function is used to continue decoding in the
--   presence of invalid or unrepresentable sequences. This includes both
--   those detected by <tt>encode</tt> returning <tt>InvalidSequence</tt>
--   and those that occur because the input byte sequence appears to be
--   truncated.
--   
--   Progress will usually be made by skipping the first element of the
--   <tt>from</tt> buffer. This function should only be called if you are
--   certain that you wish to do this skipping and if the <tt>to</tt>
--   buffer has at least one element of free space. Because this function
--   deals with decoding failure, it assumes that the from buffer has at
--   least one element.
--   
--   <tt>recover</tt> may raise an exception rather than skipping anything.
--   
--   Currently, some implementations of <tt>recover</tt> may mutate the
--   input buffer. In particular, this feature is used to implement
--   transliteration.
[recover#] :: BufferCodec from to state -> Buffer from -> Buffer to -> State# RealWorld -> (# State# RealWorld, Buffer from, Buffer to #)

-- | Resources associated with the encoding may now be released. The
--   <tt>encode</tt> function may not be called again after calling
--   <tt>close</tt>.
[close#] :: BufferCodec from to state -> IO ()

-- | Return the current state of the codec.
--   
--   Many codecs are not stateful, and in these case the state can be
--   represented as <tt>()</tt>. Other codecs maintain a state. For
--   example, UTF-16 recognises a BOM (byte-order-mark) character at the
--   beginning of the input, and remembers thereafter whether to use
--   big-endian or little-endian mode. In this case, the state of the codec
--   would include two pieces of information: whether we are at the
--   beginning of the stream (the BOM only occurs at the beginning), and if
--   not, whether to use the big or little-endian encoding.
[getState#] :: BufferCodec from to state -> IO state
[setState#] :: BufferCodec from to state -> state -> IO ()
pattern BufferCodec :: CodeBuffer from to -> (Buffer from -> Buffer to -> IO (Buffer from, Buffer to)) -> IO () -> IO state -> (state -> IO ()) -> BufferCodec from to state

-- | A <a>TextEncoding</a> is a specification of a conversion scheme
--   between sequences of bytes and sequences of Unicode characters.
--   
--   For example, UTF-8 is an encoding of Unicode characters into a
--   sequence of bytes. The <a>TextEncoding</a> for UTF-8 is <a>utf8</a>.
data TextEncoding
TextEncoding :: String -> IO (TextDecoder dstate) -> IO (TextEncoder estate) -> TextEncoding

-- | a string that can be passed to <a>mkTextEncoding</a> to create an
--   equivalent <a>TextEncoding</a>.
[textEncodingName] :: TextEncoding -> String

-- | Creates a means of decoding bytes into characters: the result must not
--   be shared between several byte sequences or simultaneously across
--   threads
[mkTextDecoder] :: TextEncoding -> IO (TextDecoder dstate)

-- | Creates a means of encode characters into bytes: the result must not
--   be shared between several character sequences or simultaneously across
--   threads
[mkTextEncoder] :: TextEncoding -> IO (TextEncoder estate)
type TextEncoder state = BufferCodec CharBufElem Word8 state
type TextDecoder state = BufferCodec Word8 CharBufElem state
type CodeBuffer from to = Buffer from -> Buffer to -> IO (CodingProgress, Buffer from, Buffer to)
type EncodeBuffer = CodeBuffer Char Word8
type DecodeBuffer = CodeBuffer Word8 Char

data CodingProgress

-- | Stopped because the input contains insufficient available elements, or
--   all of the input sequence has been successfully translated.
InputUnderflow :: CodingProgress

-- | Stopped because the output contains insufficient free elements
OutputUnderflow :: CodingProgress

-- | Stopped because there are sufficient free elements in the output to
--   output at least one encoded ASCII character, but the input contains an
--   invalid or unrepresentable sequence
InvalidSequence :: CodingProgress
type DecodeBuffer# = CodeBuffer# Word8 Char
type EncodeBuffer# = CodeBuffer# Char Word8
type DecodingBuffer# = CodingBuffer# Word8 Char
type EncodingBuffer# = CodingBuffer# Char Word8
instance GHC.Classes.Eq GHC.Internal.IO.Encoding.Types.CodingProgress
instance GHC.Internal.Show.Show GHC.Internal.IO.Encoding.Types.CodingProgress
instance GHC.Internal.Show.Show GHC.Internal.IO.Encoding.Types.TextEncoding


-- | The IOArray type
module GHC.Internal.IOArray

-- | An <a>IOArray</a> is a mutable, boxed, non-strict array in the
--   <a>IO</a> monad. The type arguments are as follows:
--   
--   <ul>
--   <li><tt>i</tt>: the index type of the array (should be an instance of
--   <a>Ix</a>)</li>
--   <li><tt>e</tt>: the element type of the array.</li>
--   </ul>
newtype IOArray i e
IOArray :: STArray RealWorld i e -> IOArray i e

-- | Build a new <a>IOArray</a>
newIOArray :: Ix i => (i, i) -> e -> IO (IOArray i e)

-- | Read a value from an <a>IOArray</a>
unsafeReadIOArray :: IOArray i e -> Int -> IO e

-- | Write a new value into an <a>IOArray</a>
unsafeWriteIOArray :: IOArray i e -> Int -> e -> IO ()

-- | Read a value from an <a>IOArray</a>
readIOArray :: Ix i => IOArray i e -> i -> IO e

-- | Write a new value into an <a>IOArray</a>
writeIOArray :: Ix i => IOArray i e -> i -> e -> IO ()
boundsIOArray :: IOArray i e -> (i, i)
instance GHC.Classes.Eq (GHC.Internal.IOArray.IOArray i e)


-- | Type classes for I/O providers.
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.IO.Device

-- | A low-level I/O provider where the data is bytes in memory. The Word64
--   offsets currently have no effect on POSIX system or consoles where the
--   implicit behaviour of the C runtime is assumed to move the file
--   pointer on every read/write without needing an explicit seek.
class RawIO a

-- | Read up to the specified number of bytes starting from a specified
--   offset, returning the number of bytes actually read. This function
--   should only block if there is no data available. If there is not
--   enough data available, then the function should just return the
--   available data. A return value of zero indicates that the end of the
--   data stream (e.g. end of file) has been reached.
read :: RawIO a => a -> Ptr Word8 -> Word64 -> Int -> IO Int

-- | Read up to the specified number of bytes starting from a specified
--   offset, returning the number of bytes actually read, or <a>Nothing</a>
--   if the end of the stream has been reached.
readNonBlocking :: RawIO a => a -> Ptr Word8 -> Word64 -> Int -> IO (Maybe Int)

-- | Write the specified number of bytes starting at a given offset.
write :: RawIO a => a -> Ptr Word8 -> Word64 -> Int -> IO ()

-- | Write up to the specified number of bytes without blocking starting at
--   a given offset. Returns the actual number of bytes written.
writeNonBlocking :: RawIO a => a -> Ptr Word8 -> Word64 -> Int -> IO Int

-- | I/O operations required for implementing a <a>Handle</a>.
class IODevice a

-- | <tt>ready dev write msecs</tt> returns <a>True</a> if the device has
--   data to read (if <tt>write</tt> is <a>False</a>) or space to write new
--   data (if <tt>write</tt> is <a>True</a>). <tt>msecs</tt> specifies how
--   long to wait, in milliseconds.
ready :: IODevice a => a -> Bool -> Int -> IO Bool

-- | closes the device. Further operations on the device should produce
--   exceptions.
close :: IODevice a => a -> IO ()

-- | returns <a>True</a> if the device is a terminal or console.
isTerminal :: IODevice a => a -> IO Bool

-- | returns <a>True</a> if the device supports <a>seek</a> operations.
isSeekable :: IODevice a => a -> IO Bool

-- | seek to the specified position in the data.
seek :: IODevice a => a -> SeekMode -> Integer -> IO Integer

-- | return the current position in the data.
tell :: IODevice a => a -> IO Integer

-- | return the size of the data.
getSize :: IODevice a => a -> IO Integer

-- | change the size of the data.
setSize :: IODevice a => a -> Integer -> IO ()

-- | for terminal devices, changes whether characters are echoed on the
--   device.
setEcho :: IODevice a => a -> Bool -> IO ()

-- | returns the current echoing status.
getEcho :: IODevice a => a -> IO Bool

-- | some devices (e.g. terminals) support a "raw" mode where characters
--   entered are immediately made available to the program. If available,
--   this operation enables raw mode.
setRaw :: IODevice a => a -> Bool -> IO ()

-- | returns the <a>IODeviceType</a> corresponding to this device.
devType :: IODevice a => a -> IO IODeviceType

-- | duplicates the device, if possible. The new device is expected to
--   share a file pointer with the original device (like Unix
--   <tt>dup</tt>).
dup :: IODevice a => a -> IO a

-- | <tt>dup2 source target</tt> replaces the target device with the source
--   device. The target device is closed first, if necessary, and then it
--   is made into a duplicate of the first device (like Unix
--   <tt>dup2</tt>).
dup2 :: IODevice a => a -> a -> IO a

-- | Type of a device that can be used to back a <a>Handle</a> (see also
--   <a>mkFileHandle</a>). The standard libraries provide creation of
--   <a>Handle</a>s via Posix file operations with file descriptors (see
--   <a>mkHandleFromFD</a>) with FD being the underlying <a>IODevice</a>
--   instance.
--   
--   Users may provide custom instances of <a>IODevice</a> which are
--   expected to conform the following rules:
data IODeviceType

-- | The standard libraries do not have direct support for this device
--   type, but a user implementation is expected to provide a list of file
--   names in the directory, in any order, separated by <tt>'\0'</tt>
--   characters, excluding the <tt>"."</tt> and <tt>".."</tt> names. See
--   also <a>getDirectoryContents</a>. Seek operations are not supported on
--   directories (other than to the zero position).
Directory :: IODeviceType

-- | A duplex communications channel (results in creation of a duplex
--   <a>Handle</a>). The standard libraries use this device type when
--   creating <a>Handle</a>s for open sockets.
Stream :: IODeviceType

-- | A file that may be read or written, and also may be seekable.
RegularFile :: IODeviceType

-- | A "raw" (disk) device which supports block binary read and write
--   operations and may be seekable only to positions of certain
--   granularity (block- aligned).
RawDevice :: IODeviceType

-- | A mode that determines the effect of <a>hSeek</a> <tt>hdl mode i</tt>.
data SeekMode

-- | the position of <tt>hdl</tt> is set to <tt>i</tt>.
AbsoluteSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the
--   current position.
RelativeSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the end
--   of the file.
SeekFromEnd :: SeekMode
instance GHC.Internal.Enum.Enum GHC.Internal.IO.Device.SeekMode
instance GHC.Classes.Eq GHC.Internal.IO.Device.IODeviceType
instance GHC.Classes.Eq GHC.Internal.IO.Device.SeekMode
instance GHC.Internal.Ix.Ix GHC.Internal.IO.Device.SeekMode
instance GHC.Classes.Ord GHC.Internal.IO.Device.SeekMode
instance GHC.Internal.Read.Read GHC.Internal.IO.Device.SeekMode
instance GHC.Internal.Show.Show GHC.Internal.IO.Device.SeekMode


-- | Class of buffered IO devices
module GHC.Internal.IO.BufferedIO

-- | The purpose of <a>BufferedIO</a> is to provide a common interface for
--   I/O devices that can read and write data through a buffer. Devices
--   that implement <a>BufferedIO</a> include ordinary files, memory-mapped
--   files, and bytestrings. The underlying device implementing a
--   <a>Handle</a> must provide <a>BufferedIO</a>.
class BufferedIO dev

-- | allocate a new buffer. The size of the buffer is at the discretion of
--   the device; e.g. for a memory-mapped file the buffer will probably
--   cover the entire file.
newBuffer :: BufferedIO dev => dev -> BufferState -> IO (Buffer Word8)

-- | reads bytes into the buffer, blocking if there are no bytes available.
--   Returns the number of bytes read (zero indicates end-of-file), and the
--   new buffer.
fillReadBuffer :: BufferedIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)

-- | reads bytes into the buffer without blocking. Returns the number of
--   bytes read (Nothing indicates end-of-file), and the new buffer.
fillReadBuffer0 :: BufferedIO dev => dev -> Buffer Word8 -> IO (Maybe Int, Buffer Word8)

-- | Prepares an empty write buffer. This lets the device decide how to set
--   up a write buffer: the buffer may need to point to a specific location
--   in memory, for example. This is typically used by the client when
--   switching from reading to writing on a buffered read/write device.
--   
--   There is no corresponding operation for read buffers, because before
--   reading the client will always call <a>fillReadBuffer</a>.
emptyWriteBuffer :: BufferedIO dev => dev -> Buffer Word8 -> IO (Buffer Word8)

-- | Flush all the data from the supplied write buffer out to the device.
--   The returned buffer should be empty, and ready for writing.
flushWriteBuffer :: BufferedIO dev => dev -> Buffer Word8 -> IO (Buffer Word8)

-- | Flush data from the supplied write buffer out to the device without
--   blocking. Returns the number of bytes written and the remaining
--   buffer.
flushWriteBuffer0 :: BufferedIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)
readBuf :: RawIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)
readBufNonBlocking :: RawIO dev => dev -> Buffer Word8 -> IO (Maybe Int, Buffer Word8)
writeBuf :: RawIO dev => dev -> Buffer Word8 -> IO (Buffer Word8)
writeBufNonBlocking :: RawIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)


-- | Basic types for the implementation of IO Handles.
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.IO.Handle.Types

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
data Handle
FileHandle :: FilePath -> !MVar Handle__ -> Handle
DuplexHandle :: FilePath -> !MVar Handle__ -> !MVar Handle__ -> Handle
data Handle__
Handle__ :: !dev -> HandleType -> !IORef (Buffer Word8) -> BufferMode -> !IORef (dec_state, Buffer Word8) -> !IORef (Buffer CharBufElem) -> !IORef (BufferList CharBufElem) -> Maybe (TextEncoder enc_state) -> Maybe (TextDecoder dec_state) -> Maybe TextEncoding -> Newline -> Newline -> Maybe (MVar Handle__) -> Handle__
[haDevice] :: Handle__ -> !dev
[haType] :: Handle__ -> HandleType
[haByteBuffer] :: Handle__ -> !IORef (Buffer Word8)
[haBufferMode] :: Handle__ -> BufferMode

-- | The byte buffer just before we did our last batch of decoding.
[haLastDecode] :: Handle__ -> !IORef (dec_state, Buffer Word8)
[haCharBuffer] :: Handle__ -> !IORef (Buffer CharBufElem)
[haBuffers] :: Handle__ -> !IORef (BufferList CharBufElem)
[haEncoder] :: Handle__ -> Maybe (TextEncoder enc_state)
[haDecoder] :: Handle__ -> Maybe (TextDecoder dec_state)
[haCodec] :: Handle__ -> Maybe TextEncoding
[haInputNL] :: Handle__ -> Newline
[haOutputNL] :: Handle__ -> Newline
[haOtherSide] :: Handle__ -> Maybe (MVar Handle__)
showHandle :: FilePath -> String -> String
checkHandleInvariants :: Handle__ -> IO ()
data BufferList e
BufferListNil :: BufferList e
BufferListCons :: RawBuffer e -> BufferList e -> BufferList e
data HandleType
ClosedHandle :: HandleType
SemiClosedHandle :: HandleType
ReadHandle :: HandleType
WriteHandle :: HandleType
AppendHandle :: HandleType
ReadWriteHandle :: HandleType

-- | <tt><a>isReadableHandleType</a> hdlType</tt> returns <a>True</a> if
--   <tt>hdlType</tt> is one of <a>ReadHandle</a> and
--   <a>ReadWriteHandle</a>.
isReadableHandleType :: HandleType -> Bool

-- | <tt><a>isWritableHandleType</a> hdlType</tt> returns <a>True</a> if
--   <tt>hdlType</tt> is one of <a>AppendHandle</a>, <a>WriteHandle</a> and
--   <a>ReadWriteHandle</a>.
isWritableHandleType :: HandleType -> Bool

-- | <tt><a>isReadWriteHandleType</a> hdlType</tt> returns <a>True</a> if
--   <tt>hdlType</tt> is <a>ReadWriteHandle</a>.
isReadWriteHandleType :: HandleType -> Bool

-- | <tt><a>isAppendHandleType</a> hdlType</tt> returns <a>True</a> if
--   <tt>hdlType</tt> is <a>AppendHandle</a>.
isAppendHandleType :: HandleType -> Bool

-- | Three kinds of buffering are supported: line-buffering,
--   block-buffering or no-buffering. These modes have the following
--   effects. For output, items are written out, or <i>flushed</i>, from
--   the internal buffer according to the buffer mode:
--   
--   <ul>
--   <li><i>line-buffering</i>: the entire output buffer is flushed
--   whenever a newline is output, the buffer overflows, a <a>hFlush</a> is
--   issued, or the handle is closed.</li>
--   <li><i>block-buffering</i>: the entire buffer is written out whenever
--   it overflows, a <a>hFlush</a> is issued, or the handle is closed.</li>
--   <li><i>no-buffering</i>: output is written immediately, and never
--   stored in the buffer.</li>
--   </ul>
--   
--   An implementation is free to flush the buffer more frequently, but not
--   less frequently, than specified above. The output buffer is emptied as
--   soon as it has been written out.
--   
--   Similarly, input occurs according to the buffer mode for the handle:
--   
--   <ul>
--   <li><i>line-buffering</i>: when the buffer for the handle is not
--   empty, the next item is obtained from the buffer; otherwise, when the
--   buffer is empty, characters up to and including the next newline
--   character are read into the buffer. No characters are available until
--   the newline character is available or the buffer is full.</li>
--   <li><i>block-buffering</i>: when the buffer for the handle becomes
--   empty, the next block of data is read into the buffer.</li>
--   <li><i>no-buffering</i>: the next input item is read and returned. The
--   <a>hLookAhead</a> operation implies that even a no-buffered handle may
--   require a one-character buffer.</li>
--   </ul>
--   
--   The default buffering mode when a handle is opened is
--   implementation-dependent and may depend on the file system object
--   which is attached to that handle. For most implementations, physical
--   files will normally be block-buffered and terminals will normally be
--   line-buffered.
data BufferMode

-- | buffering is disabled if possible.
NoBuffering :: BufferMode

-- | line-buffering should be enabled if possible.
LineBuffering :: BufferMode

-- | block-buffering should be enabled if possible. The size of the buffer
--   is <tt>n</tt> items if the argument is <a>Just</a> <tt>n</tt> and is
--   otherwise implementation-dependent.
BlockBuffering :: Maybe Int -> BufferMode
data BufferCodec from to state
BufferCodec# :: CodeBuffer# from to -> (Buffer from -> Buffer to -> State# RealWorld -> (# State# RealWorld, Buffer from, Buffer to #)) -> IO () -> IO state -> (state -> IO ()) -> BufferCodec from to state

-- | The <tt>encode</tt> function translates elements of the buffer
--   <tt>from</tt> to the buffer <tt>to</tt>. It should translate as many
--   elements as possible given the sizes of the buffers, including
--   translating zero elements if there is either not enough room in
--   <tt>to</tt>, or <tt>from</tt> does not contain a complete multibyte
--   sequence.
--   
--   If multiple CodingProgress returns are possible, OutputUnderflow must
--   be preferred to InvalidSequence. This allows GHC's IO library to
--   assume that if we observe InvalidSequence there is at least a single
--   element available in the output buffer.
--   
--   The fact that as many elements as possible are translated is used by
--   the IO library in order to report translation errors at the point they
--   actually occur, rather than when the buffer is translated.
[encode#] :: BufferCodec from to state -> CodeBuffer# from to

-- | The <tt>recover</tt> function is used to continue decoding in the
--   presence of invalid or unrepresentable sequences. This includes both
--   those detected by <tt>encode</tt> returning <tt>InvalidSequence</tt>
--   and those that occur because the input byte sequence appears to be
--   truncated.
--   
--   Progress will usually be made by skipping the first element of the
--   <tt>from</tt> buffer. This function should only be called if you are
--   certain that you wish to do this skipping and if the <tt>to</tt>
--   buffer has at least one element of free space. Because this function
--   deals with decoding failure, it assumes that the from buffer has at
--   least one element.
--   
--   <tt>recover</tt> may raise an exception rather than skipping anything.
--   
--   Currently, some implementations of <tt>recover</tt> may mutate the
--   input buffer. In particular, this feature is used to implement
--   transliteration.
[recover#] :: BufferCodec from to state -> Buffer from -> Buffer to -> State# RealWorld -> (# State# RealWorld, Buffer from, Buffer to #)

-- | Resources associated with the encoding may now be released. The
--   <tt>encode</tt> function may not be called again after calling
--   <tt>close</tt>.
[close#] :: BufferCodec from to state -> IO ()

-- | Return the current state of the codec.
--   
--   Many codecs are not stateful, and in these case the state can be
--   represented as <tt>()</tt>. Other codecs maintain a state. For
--   example, UTF-16 recognises a BOM (byte-order-mark) character at the
--   beginning of the input, and remembers thereafter whether to use
--   big-endian or little-endian mode. In this case, the state of the codec
--   would include two pieces of information: whether we are at the
--   beginning of the stream (the BOM only occurs at the beginning), and if
--   not, whether to use the big or little-endian encoding.
[getState#] :: BufferCodec from to state -> IO state
[setState#] :: BufferCodec from to state -> state -> IO ()
pattern BufferCodec :: CodeBuffer from to -> (Buffer from -> Buffer to -> IO (Buffer from, Buffer to)) -> IO () -> IO state -> (state -> IO ()) -> BufferCodec from to state

-- | Specifies the translation, if any, of newline characters between
--   internal Strings and the external file or stream. Haskell Strings are
--   assumed to represent newlines with the <tt>'\n'</tt> character; the
--   newline mode specifies how to translate <tt>'\n'</tt> on output, and
--   what to translate into <tt>'\n'</tt> on input.
data NewlineMode
NewlineMode :: Newline -> Newline -> NewlineMode

-- | the representation of newlines on input
[inputNL] :: NewlineMode -> Newline

-- | the representation of newlines on output
[outputNL] :: NewlineMode -> Newline

-- | The representation of a newline in the external file or stream.
data Newline

-- | <pre>
--   '\n'
--   </pre>
LF :: Newline

-- | <pre>
--   '\r\n'
--   </pre>
CRLF :: Newline

-- | The native newline representation for the current platform: <a>LF</a>
--   on Unix systems, <a>CRLF</a> on Windows.
nativeNewline :: Newline

-- | Map <tt>'\r\n'</tt> into <tt>'\n'</tt> on input, and <tt>'\n'</tt> to
--   the native newline representation on output. This mode can be used on
--   any platform, and works with text files using any newline convention.
--   The downside is that <tt>readFile &gt;&gt;= writeFile</tt> might yield
--   a different file.
--   
--   <pre>
--   universalNewlineMode  = NewlineMode { inputNL  = CRLF,
--                                         outputNL = nativeNewline }
--   </pre>
universalNewlineMode :: NewlineMode

-- | Do no newline translation at all.
--   
--   <pre>
--   noNewlineTranslation  = NewlineMode { inputNL  = LF, outputNL = LF }
--   </pre>
noNewlineTranslation :: NewlineMode

-- | Use the native newline representation on both input and output
--   
--   <pre>
--   nativeNewlineMode  = NewlineMode { inputNL  = nativeNewline
--                                      outputNL = nativeNewline }
--   </pre>
nativeNewlineMode :: NewlineMode
instance GHC.Classes.Eq GHC.Internal.IO.Handle.Types.BufferMode
instance GHC.Classes.Eq GHC.Internal.IO.Handle.Types.Handle
instance GHC.Classes.Eq GHC.Internal.IO.Handle.Types.Newline
instance GHC.Classes.Eq GHC.Internal.IO.Handle.Types.NewlineMode
instance GHC.Classes.Ord GHC.Internal.IO.Handle.Types.BufferMode
instance GHC.Classes.Ord GHC.Internal.IO.Handle.Types.Newline
instance GHC.Classes.Ord GHC.Internal.IO.Handle.Types.NewlineMode
instance GHC.Internal.Read.Read GHC.Internal.IO.Handle.Types.BufferMode
instance GHC.Internal.Read.Read GHC.Internal.IO.Handle.Types.Newline
instance GHC.Internal.Read.Read GHC.Internal.IO.Handle.Types.NewlineMode
instance GHC.Internal.Show.Show GHC.Internal.IO.Handle.Types.BufferMode
instance GHC.Internal.Show.Show GHC.Internal.IO.Handle.Types.Handle
instance GHC.Internal.Show.Show GHC.Internal.IO.Handle.Types.HandleType
instance GHC.Internal.Show.Show GHC.Internal.IO.Handle.Types.Newline
instance GHC.Internal.Show.Show GHC.Internal.IO.Handle.Types.NewlineMode


-- | IO-related Exception types and functions
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.IO.Exception

-- | The thread is blocked on an <tt>MVar</tt>, but there are no other
--   references to the <tt>MVar</tt> so it can't ever continue.
data BlockedIndefinitelyOnMVar
BlockedIndefinitelyOnMVar :: BlockedIndefinitelyOnMVar
blockedIndefinitelyOnMVar :: SomeException

-- | The thread is waiting to retry an STM transaction, but there are no
--   other references to any <tt>TVar</tt>s involved, so it can't ever
--   continue.
data BlockedIndefinitelyOnSTM
BlockedIndefinitelyOnSTM :: BlockedIndefinitelyOnSTM
blockedIndefinitelyOnSTM :: SomeException

-- | There are no runnable threads, so the program is deadlocked. The
--   <tt>Deadlock</tt> exception is raised in the main thread only.
data Deadlock
Deadlock :: Deadlock

-- | This thread has exceeded its allocation limit. See
--   <a>setAllocationCounter</a> and <a>enableAllocationLimit</a>.
data AllocationLimitExceeded
AllocationLimitExceeded :: AllocationLimitExceeded
allocationLimitExceeded :: SomeException

-- | <a>assert</a> was applied to <a>False</a>.
newtype AssertionFailed
AssertionFailed :: String -> AssertionFailed

-- | Compaction found an object that cannot be compacted. Functions cannot
--   be compacted, nor can mutable objects or pinned objects. See
--   <a>compact</a>.
newtype CompactionFailed
CompactionFailed :: String -> CompactionFailed
cannotCompactFunction :: SomeException
cannotCompactPinned :: SomeException
cannotCompactMutable :: SomeException

-- | Superclass for asynchronous exceptions.
data SomeAsyncException
SomeAsyncException :: e -> SomeAsyncException

asyncExceptionToException :: Exception e => e -> SomeException

asyncExceptionFromException :: Exception e => SomeException -> Maybe e

-- | Asynchronous exceptions.
data AsyncException

-- | The current thread's stack exceeded its limit. Since an exception has
--   been raised, the thread's stack will certainly be below its limit
--   again, but the programmer should take remedial action immediately.
StackOverflow :: AsyncException

-- | The program's heap is reaching its limit, and the program should take
--   action to reduce the amount of live data it has. Notes:
--   
--   <ul>
--   <li>It is undefined which thread receives this exception. GHC
--   currently throws this to the same thread that receives
--   <a>UserInterrupt</a>, but this may change in the future.</li>
--   <li>The GHC RTS currently can only recover from heap overflow if it
--   detects that an explicit memory limit (set via RTS flags). has been
--   exceeded. Currently, failure to allocate memory from the operating
--   system results in immediate termination of the program.</li>
--   </ul>
HeapOverflow :: AsyncException

-- | This exception is raised by another thread calling <a>killThread</a>,
--   or by the system if it needs to terminate the thread for some reason.
ThreadKilled :: AsyncException

-- | This exception is raised by default in the main thread of the program
--   when the user requests to terminate the program via the usual
--   mechanism(s) (e.g. Control-C in the console).
UserInterrupt :: AsyncException
stackOverflow :: SomeException
heapOverflow :: SomeException

-- | Exceptions generated by array operations
data ArrayException

-- | An attempt was made to index an array outside its declared bounds.
IndexOutOfBounds :: String -> ArrayException

-- | An attempt was made to evaluate an element of an array that had not
--   been initialized.
UndefinedElement :: String -> ArrayException

-- | Defines the exit codes that a program can return.
data ExitCode

-- | indicates successful termination;
ExitSuccess :: ExitCode

-- | indicates program failure with an exit code. The exact interpretation
--   of the code is operating-system dependent. In particular, some values
--   may be prohibited (e.g. 0 on a POSIX-compliant system).
ExitFailure :: Int -> ExitCode

-- | The exception thrown when an infinite cycle is detected in
--   <a>fixIO</a>.
data FixIOException
FixIOException :: FixIOException
ioException :: HasCallStack => IOException -> IO a

-- | Raise an <a>IOError</a> in the <a>IO</a> monad.
ioError :: HasCallStack => IOError -> IO a

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOError</a> instead of returning a result.
--   For a more general type of exception, including also those that arise
--   in pure code, see <a>Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | Exceptions that occur in the <tt>IO</tt> monad. An
--   <tt>IOException</tt> records a more specific error type, a descriptive
--   string and maybe the handle that was used when the error was flagged.
data IOException
IOError :: Maybe Handle -> IOErrorType -> String -> String -> Maybe CInt -> Maybe FilePath -> IOException

-- | the handle used by the action flagging the error.
[ioe_handle] :: IOException -> Maybe Handle

-- | what it was.
[ioe_type] :: IOException -> IOErrorType

-- | location.
[ioe_location] :: IOException -> String

-- | error type specific information.
[ioe_description] :: IOException -> String

-- | errno leading to this error, if any.
[ioe_errno] :: IOException -> Maybe CInt

-- | filename the error is related to (some libraries may assume different
--   encodings when constructing this field from e.g. <tt>ByteString</tt>
--   or other types)
[ioe_filename] :: IOException -> Maybe FilePath

-- | An abstract type that contains a value for each variant of
--   <a>IOError</a>.
data IOErrorType
AlreadyExists :: IOErrorType
NoSuchThing :: IOErrorType
ResourceBusy :: IOErrorType
ResourceExhausted :: IOErrorType
EOF :: IOErrorType
IllegalOperation :: IOErrorType
PermissionDenied :: IOErrorType
UserError :: IOErrorType
UnsatisfiedConstraints :: IOErrorType
SystemError :: IOErrorType
ProtocolError :: IOErrorType
OtherError :: IOErrorType
InvalidArgument :: IOErrorType
InappropriateType :: IOErrorType
HardwareFault :: IOErrorType
UnsupportedOperation :: IOErrorType
TimeExpired :: IOErrorType
ResourceVanished :: IOErrorType
Interrupted :: IOErrorType

-- | Construct an <a>IOError</a> value with a string describing the error.
--   The <tt>fail</tt> method of the <a>IO</a> instance of the <a>Monad</a>
--   class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError
assertError :: (?callStack :: CallStack) => Bool -> a -> a
unsupportedOperation :: IOError
untangle :: Addr# -> String -> String
instance GHC.Classes.Eq GHC.Internal.IO.Exception.ArrayException
instance GHC.Classes.Eq GHC.Internal.IO.Exception.AsyncException
instance GHC.Classes.Eq GHC.Internal.IO.Exception.ExitCode
instance GHC.Classes.Eq GHC.Internal.IO.Exception.IOErrorType
instance GHC.Classes.Eq GHC.Internal.IO.Exception.IOException
instance GHC.Internal.Exception.Type.Exception GHC.Internal.IO.Exception.AllocationLimitExceeded
instance GHC.Internal.Exception.Type.Exception GHC.Internal.IO.Exception.ArrayException
instance GHC.Internal.Exception.Type.Exception GHC.Internal.IO.Exception.AssertionFailed
instance GHC.Internal.Exception.Type.Exception GHC.Internal.IO.Exception.AsyncException
instance GHC.Internal.Exception.Type.Exception GHC.Internal.IO.Exception.BlockedIndefinitelyOnMVar
instance GHC.Internal.Exception.Type.Exception GHC.Internal.IO.Exception.BlockedIndefinitelyOnSTM
instance GHC.Internal.Exception.Type.Exception GHC.Internal.IO.Exception.CompactionFailed
instance GHC.Internal.Exception.Type.Exception GHC.Internal.IO.Exception.Deadlock
instance GHC.Internal.Exception.Type.Exception GHC.Internal.IO.Exception.ExitCode
instance GHC.Internal.Exception.Type.Exception GHC.Internal.IO.Exception.FixIOException
instance GHC.Internal.Exception.Type.Exception GHC.Internal.IO.Exception.IOException
instance GHC.Internal.Exception.Type.Exception GHC.Internal.IO.Exception.SomeAsyncException
instance GHC.Internal.Generics.Generic GHC.Internal.IO.Exception.ExitCode
instance GHC.Classes.Ord GHC.Internal.IO.Exception.ArrayException
instance GHC.Classes.Ord GHC.Internal.IO.Exception.AsyncException
instance GHC.Classes.Ord GHC.Internal.IO.Exception.ExitCode
instance GHC.Internal.Read.Read GHC.Internal.IO.Exception.ExitCode
instance GHC.Internal.Show.Show GHC.Internal.IO.Exception.AllocationLimitExceeded
instance GHC.Internal.Show.Show GHC.Internal.IO.Exception.ArrayException
instance GHC.Internal.Show.Show GHC.Internal.IO.Exception.AssertionFailed
instance GHC.Internal.Show.Show GHC.Internal.IO.Exception.AsyncException
instance GHC.Internal.Show.Show GHC.Internal.IO.Exception.BlockedIndefinitelyOnMVar
instance GHC.Internal.Show.Show GHC.Internal.IO.Exception.BlockedIndefinitelyOnSTM
instance GHC.Internal.Show.Show GHC.Internal.IO.Exception.CompactionFailed
instance GHC.Internal.Show.Show GHC.Internal.IO.Exception.Deadlock
instance GHC.Internal.Show.Show GHC.Internal.IO.Exception.ExitCode
instance GHC.Internal.Show.Show GHC.Internal.IO.Exception.FixIOException
instance GHC.Internal.Show.Show GHC.Internal.IO.Exception.IOErrorType
instance GHC.Internal.Show.Show GHC.Internal.IO.Exception.IOException
instance GHC.Internal.Show.Show GHC.Internal.IO.Exception.SomeAsyncException


-- | Types for specifying how text encoding/decoding fails
module GHC.Internal.IO.Encoding.Failure

-- | The <a>CodingFailureMode</a> is used to construct
--   <a>TextEncoding</a>s, and specifies how they handle illegal sequences.
data CodingFailureMode

-- | Throw an error when an illegal sequence is encountered
ErrorOnCodingFailure :: CodingFailureMode

-- | Attempt to ignore and recover if an illegal sequence is encountered
IgnoreCodingFailure :: CodingFailureMode

-- | Replace with the closest visual match upon an illegal sequence
TransliterateCodingFailure :: CodingFailureMode

-- | Use the private-use escape mechanism to attempt to allow illegal
--   sequences to be roundtripped.
RoundtripFailure :: CodingFailureMode
codingFailureModeSuffix :: CodingFailureMode -> String

-- | Some characters are actually "surrogate" codepoints defined for use in
--   UTF-16. We need to signal an invalid character if we detect them when
--   encoding a sequence of <a>Char</a>s into <a>Word8</a>s because they
--   won't give valid Unicode.
--   
--   We may also need to signal an invalid character if we detect them when
--   encoding a sequence of <a>Char</a>s into <a>Word8</a>s because the
--   <a>RoundtripFailure</a> mode creates these to round-trip bytes through
--   our internal UTF-16 encoding.
isSurrogate :: Char -> Bool
recoverDecode :: CodingFailureMode -> Buffer Word8 -> Buffer Char -> IO (Buffer Word8, Buffer Char)
recoverEncode :: CodingFailureMode -> Buffer Char -> Buffer Word8 -> IO (Buffer Char, Buffer Word8)
recoverDecode# :: CodingFailureMode -> Buffer Word8 -> Buffer Char -> State# RealWorld -> (# State# RealWorld, Buffer Word8, Buffer Char #)
recoverEncode# :: CodingFailureMode -> Buffer Char -> Buffer Word8 -> State# RealWorld -> (# State# RealWorld, Buffer Char, Buffer Word8 #)
instance GHC.Internal.Show.Show GHC.Internal.IO.Encoding.Failure.CodingFailureMode


-- | UTF-8 Codec for the IO library
--   
--   This is one of several UTF-8 implementations provided by GHC; see Note
--   [GHC's many UTF-8 implementations] in <a>GHC.Encoding.UTF8</a> for an
--   overview.
--   
--   Portions Copyright : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan
--   2009, (c) Duncan Coutts 2009
module GHC.Internal.IO.Encoding.UTF8
utf8 :: TextEncoding

mkUTF8 :: CodingFailureMode -> TextEncoding
utf8_bom :: TextEncoding
mkUTF8_bom :: CodingFailureMode -> TextEncoding


-- | UTF-32 Codecs for the IO library
--   
--   Portions Copyright : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan
--   2009, (c) Duncan Coutts 2009
module GHC.Internal.IO.Encoding.UTF32
utf32 :: TextEncoding

mkUTF32 :: CodingFailureMode -> TextEncoding
utf32_decode :: IORef (Maybe DecodeBuffer#) -> DecodeBuffer#
utf32_encode :: IORef Bool -> EncodeBuffer#
utf32be :: TextEncoding

mkUTF32be :: CodingFailureMode -> TextEncoding
utf32be_decode :: DecodeBuffer#
utf32be_encode :: EncodeBuffer#
utf32le :: TextEncoding

mkUTF32le :: CodingFailureMode -> TextEncoding
utf32le_decode :: DecodeBuffer#
utf32le_encode :: EncodeBuffer#


-- | UTF-16 Codecs for the IO library
--   
--   Portions Copyright : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan
--   2009, (c) Duncan Coutts 2009
module GHC.Internal.IO.Encoding.UTF16
utf16 :: TextEncoding

mkUTF16 :: CodingFailureMode -> TextEncoding
utf16_decode :: IORef (Maybe DecodeBuffer#) -> DecodeBuffer#
utf16_encode :: IORef Bool -> EncodeBuffer#
utf16be :: TextEncoding

mkUTF16be :: CodingFailureMode -> TextEncoding
utf16be_decode :: DecodeBuffer#
utf16be_encode :: EncodeBuffer#
utf16le :: TextEncoding

mkUTF16le :: CodingFailureMode -> TextEncoding
utf16le_decode :: DecodeBuffer#
utf16le_encode :: EncodeBuffer#


-- | Single-byte encodings that map directly to Unicode code points.
--   
--   Portions Copyright : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan
--   2009, (c) Duncan Coutts 2009
module GHC.Internal.IO.Encoding.Latin1
latin1 :: TextEncoding

mkLatin1 :: CodingFailureMode -> TextEncoding
latin1_checked :: TextEncoding

mkLatin1_checked :: CodingFailureMode -> TextEncoding

ascii :: TextEncoding

mkAscii :: CodingFailureMode -> TextEncoding
latin1_decode :: DecodeBuffer#
ascii_decode :: DecodeBuffer#
latin1_encode :: EncodeBuffer#
latin1_checked_encode :: EncodeBuffer#
ascii_encode :: EncodeBuffer#


-- | Routines for testing return values and raising a <a>userError</a>
--   exception in case of values indicating an error state.
module GHC.Internal.Foreign.Marshal.Error

-- | Execute an <a>IO</a> action, throwing a <a>userError</a> if the
--   predicate yields <a>True</a> when applied to the result returned by
--   the <a>IO</a> action. If no exception is raised, return the result of
--   the computation.
throwIf :: (a -> Bool) -> (a -> String) -> IO a -> IO a

-- | Like <a>throwIf</a>, but discarding the result
throwIf_ :: (a -> Bool) -> (a -> String) -> IO a -> IO ()

-- | Guards against negative result values
throwIfNeg :: (Ord a, Num a) => (a -> String) -> IO a -> IO a

-- | Like <a>throwIfNeg</a>, but discarding the result
throwIfNeg_ :: (Ord a, Num a) => (a -> String) -> IO a -> IO ()

-- | Guards against null pointers
throwIfNull :: String -> IO (Ptr a) -> IO (Ptr a)

-- | Discard the return value of an <a>IO</a> action

-- | <i>Deprecated: use <a>void</a> instead</i>
void :: IO a -> IO ()


-- | The module <a>Foreign.Marshal.Alloc</a> provides operations to
--   allocate and deallocate blocks of raw memory (i.e., unstructured
--   chunks of memory outside of the area maintained by the Haskell storage
--   manager). These memory blocks are commonly used to pass compound data
--   structures to foreign functions or to provide space in which compound
--   result values are obtained from foreign functions.
--   
--   If any of the allocation functions fails, an exception is thrown. In
--   some cases, memory exhaustion may mean the process is terminated. If
--   <a>free</a> or <a>reallocBytes</a> is applied to a memory area that
--   has been allocated with <a>alloca</a> or <a>allocaBytes</a>, the
--   behaviour is undefined. Any further access to memory areas allocated
--   with <a>alloca</a> or <a>allocaBytes</a>, after the computation that
--   was passed to the allocation function has terminated, leads to
--   undefined behaviour. Any further access to the memory area referenced
--   by a pointer passed to <a>realloc</a>, <a>reallocBytes</a>, or
--   <a>free</a> entails undefined behaviour.
--   
--   All storage allocated by functions that allocate based on a <i>size in
--   bytes</i> must be sufficiently aligned for any of the basic foreign
--   types that fits into the newly allocated storage. All storage
--   allocated by functions that allocate based on a specific type must be
--   sufficiently aligned for that type. Array allocation routines need to
--   obey the same alignment constraints for each array element.
--   
--   The underlying implementation is wrapping the <tt><a>stdlib.h</a></tt>
--   <tt>malloc</tt>, <tt>realloc</tt>, and <tt>free</tt>. In other words
--   it should be safe to allocate using C-<tt>malloc</tt>, and free memory
--   with <a>free</a> from this module.
module GHC.Internal.Foreign.Marshal.Alloc

-- | <tt><a>alloca</a> f</tt> executes the computation <tt>f</tt>, passing
--   as argument a pointer to a temporarily allocated block of memory
--   sufficient to hold values of type <tt>a</tt>.
--   
--   The memory is freed when <tt>f</tt> terminates (either normally or via
--   an exception), so the pointer passed to <tt>f</tt> must <i>not</i> be
--   used after this.
alloca :: Storable a => (Ptr a -> IO b) -> IO b

-- | <tt><a>allocaBytes</a> n f</tt> executes the computation <tt>f</tt>,
--   passing as argument a pointer to a temporarily allocated block of
--   memory of <tt>n</tt> bytes. The block of memory is sufficiently
--   aligned for any of the basic foreign types that fits into a memory
--   block of the allocated size.
--   
--   The memory is freed when <tt>f</tt> terminates (either normally or via
--   an exception), so the pointer passed to <tt>f</tt> must <i>not</i> be
--   used after this.
allocaBytes :: Int -> (Ptr a -> IO b) -> IO b

-- | <tt><a>allocaBytesAligned</a> size align f</tt> executes the
--   computation <tt>f</tt>, passing as argument a pointer to a temporarily
--   allocated block of memory of <tt>size</tt> bytes and aligned to
--   <tt>align</tt> bytes. The value of <tt>align</tt> must be a power of
--   two.
--   
--   The memory is freed when <tt>f</tt> terminates (either normally or via
--   an exception), so the pointer passed to <tt>f</tt> must <i>not</i> be
--   used after this.
allocaBytesAligned :: Int -> Int -> (Ptr a -> IO b) -> IO b

-- | Allocate a block of memory that is sufficient to hold values of type
--   <tt>a</tt>. The size of the area allocated is determined by the
--   <a>sizeOf</a> method from the instance of <a>Storable</a> for the
--   appropriate type.
--   
--   The memory may be deallocated using <a>free</a> or
--   <a>finalizerFree</a> when no longer required.
malloc :: Storable a => IO (Ptr a)

-- | Allocate a block of memory of the given number of bytes. The block of
--   memory is sufficiently aligned for any of the basic foreign types that
--   fits into a memory block of the allocated size.
--   
--   The memory may be deallocated using <a>free</a> or
--   <a>finalizerFree</a> when no longer required.
mallocBytes :: Int -> IO (Ptr a)

-- | Like <a>malloc</a> but memory is filled with bytes of value zero.
calloc :: Storable a => IO (Ptr a)

-- | Like <a>mallocBytes</a>, but memory is filled with bytes of value
--   zero.
callocBytes :: Int -> IO (Ptr a)

-- | Resize a memory area that was allocated with <a>malloc</a> or
--   <a>mallocBytes</a> to the size needed to store values of type
--   <tt>b</tt>. The returned pointer may refer to an entirely different
--   memory area, but will be suitably aligned to hold values of type
--   <tt>b</tt>. The contents of the referenced memory area will be the
--   same as of the original pointer up to the minimum of the original size
--   and the size of values of type <tt>b</tt>.
--   
--   If the argument to <a>realloc</a> is <a>nullPtr</a>, <a>realloc</a>
--   behaves like <a>malloc</a>.
realloc :: forall a b. Storable b => Ptr a -> IO (Ptr b)

-- | Resize a memory area that was allocated with <a>malloc</a> or
--   <a>mallocBytes</a> to the given size. The returned pointer may refer
--   to an entirely different memory area, but will be sufficiently aligned
--   for any of the basic foreign types that fits into a memory block of
--   the given size. The contents of the referenced memory area will be the
--   same as of the original pointer up to the minimum of the original size
--   and the given size.
--   
--   If the pointer argument to <a>reallocBytes</a> is <a>nullPtr</a>,
--   <a>reallocBytes</a> behaves like <a>malloc</a>. If the requested size
--   is 0, <a>reallocBytes</a> behaves like <a>free</a>.
reallocBytes :: Ptr a -> Int -> IO (Ptr a)

-- | Free a block of memory that was allocated with <a>malloc</a>,
--   <a>mallocBytes</a>, <a>realloc</a>, <a>reallocBytes</a>, <a>new</a> or
--   any of the <tt>new</tt><i>X</i> functions in
--   <a>Foreign.Marshal.Array</a> or <a>Foreign.C.String</a>.
free :: Ptr a -> IO ()

-- | A pointer to a foreign function equivalent to <a>free</a>, which may
--   be used as a finalizer (cf <a>ForeignPtr</a>) for storage allocated
--   with <a>malloc</a>, <a>mallocBytes</a>, <a>realloc</a> or
--   <a>reallocBytes</a>.
finalizerFree :: FinalizerPtr a


-- | Utilities for primitive marshaling
module GHC.Internal.Foreign.Marshal.Utils

-- | <tt><a>with</a> val f</tt> executes the computation <tt>f</tt>,
--   passing as argument a pointer to a temporarily allocated block of
--   memory into which <tt>val</tt> has been marshalled (the combination of
--   <a>alloca</a> and <a>poke</a>).
--   
--   The memory is freed when <tt>f</tt> terminates (either normally or via
--   an exception), so the pointer passed to <tt>f</tt> must <i>not</i> be
--   used after this.
with :: Storable a => a -> (Ptr a -> IO b) -> IO b

-- | Allocate a block of memory and marshal a value into it (the
--   combination of <a>malloc</a> and <a>poke</a>). The size of the area
--   allocated is determined by the <a>sizeOf</a> method from the instance
--   of <a>Storable</a> for the appropriate type.
--   
--   The memory may be deallocated using <a>free</a> or
--   <a>finalizerFree</a> when no longer required.
new :: Storable a => a -> IO (Ptr a)

-- | Convert a Haskell <a>Bool</a> to its numeric representation
fromBool :: Num a => Bool -> a

-- | Convert a Boolean in numeric representation to a Haskell value
toBool :: (Eq a, Num a) => a -> Bool

-- | Allocate storage and marshal a storable value wrapped into a
--   <a>Maybe</a>
--   
--   <ul>
--   <li>the <a>nullPtr</a> is used to represent <a>Nothing</a></li>
--   </ul>
maybeNew :: (a -> IO (Ptr b)) -> Maybe a -> IO (Ptr b)

-- | Converts a <tt>withXXX</tt> combinator into one marshalling a value
--   wrapped into a <a>Maybe</a>, using <a>nullPtr</a> to represent
--   <a>Nothing</a>.
maybeWith :: (a -> (Ptr b -> IO c) -> IO c) -> Maybe a -> (Ptr b -> IO c) -> IO c

-- | Convert a peek combinator into a one returning <a>Nothing</a> if
--   applied to a <a>nullPtr</a>
maybePeek :: (Ptr a -> IO b) -> Ptr a -> IO (Maybe b)

-- | Replicates a <tt>withXXX</tt> combinator over a list of objects,
--   yielding a list of marshalled objects
withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res

-- | Copies the given number of bytes from the second area (source) into
--   the first (destination); the copied areas may <i>not</i> overlap
copyBytes :: Ptr a -> Ptr a -> Int -> IO ()

-- | Copies the given number of bytes from the second area (source) into
--   the first (destination); the copied areas <i>may</i> overlap
moveBytes :: Ptr a -> Ptr a -> Int -> IO ()

-- | Fill a given number of bytes in memory area with a byte value.
fillBytes :: Ptr a -> Word8 -> Int -> IO ()


-- | Module with fewer dependencies than GHC.Internal.RTS.Flags that allows
--   to quickly test if some flag is set.
module GHC.Internal.RTS.Flags.Test

-- | Specialized version of <tt>getTraceFlags</tt> for just checking if
--   user event tracing is enabled.
getUserEventTracingEnabled :: IO Bool


-- | Marshalling support: routines allocating, storing, and retrieving
--   Haskell lists that are represented as arrays in the foreign language
module GHC.Internal.Foreign.Marshal.Array

-- | Allocate storage for the given number of elements of a storable type
--   (like <a>malloc</a>, but for multiple elements).
mallocArray :: Storable a => Int -> IO (Ptr a)

-- | Like <a>mallocArray</a>, but add an extra position to hold a special
--   termination element.
mallocArray0 :: Storable a => Int -> IO (Ptr a)

-- | Temporarily allocate space for the given number of elements (like
--   <a>alloca</a>, but for multiple elements).
allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b

-- | Like <a>allocaArray</a>, but add an extra position to hold a special
--   termination element.
allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b

-- | Adjust the size of an array
reallocArray :: Storable a => Ptr a -> Int -> IO (Ptr a)

-- | Adjust the size of an array including an extra position for the end
--   marker.
reallocArray0 :: Storable a => Ptr a -> Int -> IO (Ptr a)

-- | Like <a>mallocArray</a>, but allocated memory is filled with bytes of
--   value zero.
callocArray :: Storable a => Int -> IO (Ptr a)

-- | Like <a>callocArray0</a>, but allocated memory is filled with bytes of
--   value zero.
callocArray0 :: Storable a => Int -> IO (Ptr a)

-- | Convert an array of given length into a Haskell list. The
--   implementation is tail-recursive and so uses constant stack space.
peekArray :: Storable a => Int -> Ptr a -> IO [a]

-- | Convert an array terminated by the given end marker into a Haskell
--   list
peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]

-- | Write the list elements consecutive into memory
pokeArray :: Storable a => Ptr a -> [a] -> IO ()

-- | Write the list elements consecutive into memory and terminate them
--   with the given marker element
pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()

-- | Write a list of storable elements into a newly allocated, consecutive
--   sequence of storable values (like <a>new</a>, but for multiple
--   elements).
newArray :: Storable a => [a] -> IO (Ptr a)

-- | Write a list of storable elements into a newly allocated, consecutive
--   sequence of storable values, where the end is fixed by the given end
--   marker
newArray0 :: Storable a => a -> [a] -> IO (Ptr a)

-- | Temporarily store a list of storable values in memory (like
--   <a>with</a>, but for multiple elements).
withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b

-- | Like <a>withArray</a>, but a terminator indicates where the array ends
withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b

-- | Like <a>withArray</a>, but the action gets the number of values as an
--   additional parameter
withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b

-- | Like <a>withArrayLen</a>, but a terminator indicates where the array
--   ends
withArrayLen0 :: Storable a => a -> [a] -> (Int -> Ptr a -> IO b) -> IO b

-- | Copy the given number of elements from the second array (source) into
--   the first array (destination); the copied areas may <i>not</i> overlap
copyArray :: Storable a => Ptr a -> Ptr a -> Int -> IO ()

-- | Copy the given number of elements from the second array (source) into
--   the first array (destination); the copied areas <i>may</i> overlap
moveArray :: Storable a => Ptr a -> Ptr a -> Int -> IO ()

-- | Return the number of elements in an array, excluding the terminator
lengthArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO Int

-- | Advance a pointer into an array by the given number of elements
advancePtr :: Storable a => Ptr a -> Int -> Ptr a


-- | Marshalling support. Unsafe API.
module GHC.Internal.Foreign.Marshal.Unsafe

-- | Sometimes an external entity is a pure function, except that it passes
--   arguments and/or results via pointers. The function
--   <tt>unsafeLocalState</tt> permits the packaging of such entities as
--   pure functions.
--   
--   The only IO operations allowed in the IO action passed to
--   <tt>unsafeLocalState</tt> are (a) local allocation (<tt>alloca</tt>,
--   <tt>allocaBytes</tt> and derived operations such as <tt>withArray</tt>
--   and <tt>withCString</tt>), and (b) pointer operations
--   (<tt>Foreign.Storable</tt> and <tt>Foreign.Ptr</tt>) on the pointers
--   to local storage, and (c) foreign functions whose only observable
--   effect is to read and/or write the locally allocated memory. Passing
--   an IO operation that does not obey these rules results in undefined
--   behaviour.
--   
--   It is expected that this operation will be replaced in a future
--   revision of Haskell.
unsafeLocalState :: IO a -> a


-- | FFI datatypes and operations that use or require concurrency (GHC
--   only).
module GHC.Internal.Foreign.Concurrent

-- | Turns a plain memory reference into a foreign object by associating a
--   finalizer - given by the monadic operation - with the reference.
--   
--   When finalization is triggered by GC, the storage manager will start
--   the finalizer, in a separate thread, some time after the last
--   reference to the <tt>ForeignPtr</tt> is dropped. There is <b>no
--   guarantee of promptness</b>, and in fact there is no guarantee that
--   the finalizer will eventually run at all for GC-triggered
--   finalization.
--   
--   When finalization is triggered by explicitly calling
--   <tt>finalizeForeignPtr</tt>, the finalizer will run immediately on the
--   current Haskell thread.
--   
--   Note that references from a finalizer do not necessarily prevent
--   another object from being finalized. If A's finalizer refers to B
--   (perhaps using <a>touchForeignPtr</a>, then the only guarantee is that
--   B's finalizer will never be started before A's. If both A and B are
--   unreachable, then both finalizers will start together. See
--   <a>touchForeignPtr</a> for more on finalizer ordering.
newForeignPtr :: Ptr a -> IO () -> IO (ForeignPtr a)

-- | This function adds a finalizer to the given <a>ForeignPtr</a>. The
--   finalizer will run <i>before</i> all other finalizers for the same
--   object which have already been registered.
--   
--   This is a variant of <a>addForeignPtrFinalizer</a>, where the
--   finalizer is an arbitrary <a>IO</a> action. When it is invoked, the
--   finalizer will run in a new thread.
--   
--   NB. Be very careful with these finalizers. One common trap is that if
--   a finalizer references another finalized value, it does not prevent
--   that value from being finalized. In particular, <a>Handle</a>s are
--   finalized objects, so a finalizer should not refer to a <a>Handle</a>
--   (including <a>stdout</a>, <a>stdin</a>, or <a>stderr</a>).
addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()


-- | Foreign marshalling support for CStrings with configurable encodings
module GHC.Internal.Foreign.C.String.Encoding

-- | A C string is a reference to an array of C characters terminated by
--   NUL.
type CString = Ptr CChar

-- | A string with explicit length information in bytes instead of a
--   terminating NUL (allowing NUL characters in the middle of the string).
type CStringLen = (Ptr CChar, Int)

-- | Marshal a NUL terminated C string into a Haskell string.
peekCString :: TextEncoding -> CString -> IO String

-- | Marshal a C string with explicit length into a Haskell string.
peekCStringLen :: TextEncoding -> CStringLen -> IO String

-- | Marshal a Haskell string into a NUL terminated C string.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCString :: TextEncoding -> String -> IO CString

-- | Marshal a Haskell string into a C string (ie, character array) with
--   explicit length information.
--   
--   Note that this does not NUL terminate the resulting string.
--   
--   <ul>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCStringLen :: TextEncoding -> String -> IO CStringLen

-- | Marshal a Haskell string into a NUL-terminated C string (ie, character
--   array) with explicit length information.
--   
--   <ul>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCStringLen0 :: TextEncoding -> String -> IO CStringLen

-- | Marshal a Haskell string into a NUL terminated C string using
--   temporary storage.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCString :: TextEncoding -> String -> (CString -> IO a) -> IO a

-- | Marshal a Haskell string into a C string (ie, character array) in
--   temporary storage, with explicit length information.
--   
--   Note that this does not NUL terminate the resulting string.
--   
--   <ul>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCStringLen :: TextEncoding -> String -> (CStringLen -> IO a) -> IO a

-- | Marshal a Haskell string into a NUL-terminated C string (ie, character
--   array) in temporary storage, with explicit length information.
--   
--   <ul>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCStringLen0 :: TextEncoding -> String -> (CStringLen -> IO a) -> IO a

-- | Marshal a list of Haskell strings into an array of NUL terminated C
--   strings using temporary storage.
--   
--   <ul>
--   <li>the Haskell strings may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCStringsLen :: TextEncoding -> [String] -> (Int -> Ptr CString -> IO a) -> IO a

-- | Determines whether a character can be accurately encoded in a
--   <a>CString</a>.
--   
--   Pretty much anyone who uses this function is in a state of sin because
--   whether or not a character is encodable will, in general, depend on
--   the context in which it occurs.
charIsRepresentable :: TextEncoding -> Char -> IO Bool


-- | Utilities for primitive marshalling of C strings.
--   
--   The marshalling converts each Haskell character, representing a
--   Unicode code point, to one or more bytes in a manner that, by default,
--   is determined by the current locale. As a consequence, no guarantees
--   can be made about the relative length of a Haskell string and its
--   corresponding C string, and therefore all the marshalling routines
--   include memory allocation. The translation between Unicode and the
--   encoding of the current locale may be lossy.
module GHC.Internal.Foreign.C.String

-- | A C string is a reference to an array of C characters terminated by
--   NUL.
type CString = Ptr CChar

-- | A string with explicit length information in bytes instead of a
--   terminating NUL (allowing NUL characters in the middle of the string).
type CStringLen = (Ptr CChar, Int)

-- | Marshal a NUL terminated C string into a Haskell string.
peekCString :: CString -> IO String

-- | Marshal a C string with explicit length into a Haskell string.
peekCStringLen :: CStringLen -> IO String

-- | Marshal a Haskell string into a NUL terminated C string.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCString :: String -> IO CString

-- | Marshal a Haskell string into a C string (ie, character array) with
--   explicit length information.
--   
--   <ul>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCStringLen :: String -> IO CStringLen

-- | Marshal a Haskell string into a NUL terminated C string using
--   temporary storage.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCString :: String -> (CString -> IO a) -> IO a

-- | Marshal a Haskell string into a C string (ie, character array) in
--   temporary storage, with explicit length information.
--   
--   <ul>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCStringLen :: String -> (CStringLen -> IO a) -> IO a
charIsRepresentable :: Char -> IO Bool

-- | Convert a Haskell character to a C character. This function is only
--   safe on the first 256 characters.
castCharToCChar :: Char -> CChar

-- | Convert a C byte, representing a Latin-1 character, to the
--   corresponding Haskell character.
castCCharToChar :: CChar -> Char

-- | Convert a Haskell character to a C <tt>unsigned char</tt>. This
--   function is only safe on the first 256 characters.
castCharToCUChar :: Char -> CUChar

-- | Convert a C <tt>unsigned char</tt>, representing a Latin-1 character,
--   to the corresponding Haskell character.
castCUCharToChar :: CUChar -> Char

-- | Convert a Haskell character to a C <tt>signed char</tt>. This function
--   is only safe on the first 256 characters.
castCharToCSChar :: Char -> CSChar

-- | Convert a C <tt>signed char</tt>, representing a Latin-1 character, to
--   the corresponding Haskell character.
castCSCharToChar :: CSChar -> Char

-- | Marshal a NUL terminated C string into a Haskell string.
peekCAString :: CString -> IO String

-- | Marshal a C string with explicit length into a Haskell string.
peekCAStringLen :: CStringLen -> IO String

-- | Marshal a Haskell string into a NUL terminated C string.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCAString :: String -> IO CString

-- | Marshal a Haskell string into a C string (ie, character array) with
--   explicit length information.
--   
--   <ul>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCAStringLen :: String -> IO CStringLen

-- | Marshal a Haskell string into a NUL terminated C string using
--   temporary storage.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCAString :: String -> (CString -> IO a) -> IO a

-- | Marshal a Haskell string into a C string (ie, character array) in
--   temporary storage, with explicit length information.
--   
--   <ul>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCAStringLen :: String -> (CStringLen -> IO a) -> IO a

-- | A C wide string is a reference to an array of C wide characters
--   terminated by NUL.
type CWString = Ptr CWchar

-- | A wide character string with explicit length information in
--   <a>CWchar</a>s instead of a terminating NUL (allowing NUL characters
--   in the middle of the string).
type CWStringLen = (Ptr CWchar, Int)

-- | Marshal a NUL terminated C wide string into a Haskell string.
peekCWString :: CWString -> IO String

-- | Marshal a C wide string with explicit length into a Haskell string.
peekCWStringLen :: CWStringLen -> IO String

-- | Marshal a Haskell string into a NUL terminated C wide string.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>new storage is allocated for the C wide string and must be
--   explicitly freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCWString :: String -> IO CWString

-- | Marshal a Haskell string into a C wide string (ie, wide character
--   array) with explicit length information.
--   
--   <ul>
--   <li>new storage is allocated for the C wide string and must be
--   explicitly freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCWStringLen :: String -> IO CWStringLen

-- | Marshal a Haskell string into a NUL terminated C wide string using
--   temporary storage.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCWString :: String -> (CWString -> IO a) -> IO a

-- | Marshal a Haskell string into a C wide string (i.e. wide character
--   array) in temporary storage, with explicit length information.
--   
--   <ul>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCWStringLen :: String -> (CWStringLen -> IO a) -> IO a


-- | <i>The API of this module is unstable and is tightly coupled to GHC's
--   internals.</i> If depend on it, make sure to use a tight upper bound,
--   e.g., <tt>base &lt; 4.X</tt> rather than <tt>base &lt; 5</tt>, because
--   the interface can change rapidly without much warning.
--   
--   Descriptions of flags can be seen in <a>GHC User's Guide</a>, or by
--   running RTS help message using <tt>+RTS --help</tt>.
module GHC.Internal.RTS.Flags

-- | <a>RtsTime</a> is defined as a <tt>StgWord64</tt> in
--   <tt>stg/Types.h</tt>
type RtsTime = Word64

-- | Parameters of the runtime system
data RTSFlags
RTSFlags :: GCFlags -> ConcFlags -> MiscFlags -> DebugFlags -> CCFlags -> ProfFlags -> TraceFlags -> TickyFlags -> ParFlags -> HpcFlags -> RTSFlags
[gcFlags] :: RTSFlags -> GCFlags
[concurrentFlags] :: RTSFlags -> ConcFlags
[miscFlags] :: RTSFlags -> MiscFlags
[debugFlags] :: RTSFlags -> DebugFlags
[costCentreFlags] :: RTSFlags -> CCFlags
[profilingFlags] :: RTSFlags -> ProfFlags
[traceFlags] :: RTSFlags -> TraceFlags
[tickyFlags] :: RTSFlags -> TickyFlags
[parFlags] :: RTSFlags -> ParFlags
[hpcFlags] :: RTSFlags -> HpcFlags

-- | Should we produce a summary of the garbage collector statistics after
--   the program has exited?
data GiveGCStats
NoGCStats :: GiveGCStats
CollectGCStats :: GiveGCStats
OneLineGCStats :: GiveGCStats
SummaryGCStats :: GiveGCStats
VerboseGCStats :: GiveGCStats

-- | Parameters of the garbage collector.
data GCFlags
GCFlags :: Maybe FilePath -> GiveGCStats -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Bool -> Double -> Double -> Double -> Word32 -> Bool -> Bool -> Double -> Bool -> Bool -> RtsTime -> Bool -> Word -> Word -> Bool -> Word -> GCFlags
[statsFile] :: GCFlags -> Maybe FilePath
[giveStats] :: GCFlags -> GiveGCStats
[maxStkSize] :: GCFlags -> Word32
[initialStkSize] :: GCFlags -> Word32
[stkChunkSize] :: GCFlags -> Word32
[stkChunkBufferSize] :: GCFlags -> Word32
[maxHeapSize] :: GCFlags -> Word32
[minAllocAreaSize] :: GCFlags -> Word32
[largeAllocLim] :: GCFlags -> Word32
[nurseryChunkSize] :: GCFlags -> Word32
[minOldGenSize] :: GCFlags -> Word32
[heapSizeSuggestion] :: GCFlags -> Word32
[heapSizeSuggestionAuto] :: GCFlags -> Bool
[oldGenFactor] :: GCFlags -> Double
[returnDecayFactor] :: GCFlags -> Double
[pcFreeHeap] :: GCFlags -> Double
[generations] :: GCFlags -> Word32
[squeezeUpdFrames] :: GCFlags -> Bool

-- | True <a>=</a> "compact all the time"
[compact] :: GCFlags -> Bool
[compactThreshold] :: GCFlags -> Double

-- | use "mostly mark-sweep" instead of copying for the oldest generation
[sweep] :: GCFlags -> Bool
[ringBell] :: GCFlags -> Bool
[idleGCDelayTime] :: GCFlags -> RtsTime
[doIdleGC] :: GCFlags -> Bool

-- | address to ask the OS for memory
[heapBase] :: GCFlags -> Word
[allocLimitGrace] :: GCFlags -> Word
[numa] :: GCFlags -> Bool
[numaMask] :: GCFlags -> Word

-- | Parameters concerning context switching
data ConcFlags
ConcFlags :: RtsTime -> Int -> ConcFlags
[ctxtSwitchTime] :: ConcFlags -> RtsTime
[ctxtSwitchTicks] :: ConcFlags -> Int

-- | Miscellaneous parameters
data MiscFlags
MiscFlags :: RtsTime -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Word -> IoManagerFlag -> Word32 -> MiscFlags
[tickInterval] :: MiscFlags -> RtsTime
[installSignalHandlers] :: MiscFlags -> Bool
[installSEHHandlers] :: MiscFlags -> Bool
[generateCrashDumpFile] :: MiscFlags -> Bool
[generateStackTrace] :: MiscFlags -> Bool
[machineReadable] :: MiscFlags -> Bool
[disableDelayedOsMemoryReturn] :: MiscFlags -> Bool
[internalCounters] :: MiscFlags -> Bool
[linkerAlwaysPic] :: MiscFlags -> Bool

-- | address to ask the OS for memory for the linker, 0 ==&gt; off
[linkerMemBase] :: MiscFlags -> Word
[ioManager] :: MiscFlags -> IoManagerFlag
[numIoWorkerThreads] :: MiscFlags -> Word32

data IoManagerFlag
IoManagerFlagAuto :: IoManagerFlag

-- | Unix only, non-threaded RTS only
IoManagerFlagSelect :: IoManagerFlag

-- | cross-platform, threaded RTS only
IoManagerFlagMIO :: IoManagerFlag

-- | Windows only
IoManagerFlagWinIO :: IoManagerFlag

-- | Windows only, non-threaded RTS only
IoManagerFlagWin32Legacy :: IoManagerFlag

-- | Flags to control debugging output &amp; extra checking in various
--   subsystems.
data DebugFlags
DebugFlags :: Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> DebugFlags

-- | <pre>
--   s
--   </pre>
[scheduler] :: DebugFlags -> Bool

-- | <pre>
--   i
--   </pre>
[interpreter] :: DebugFlags -> Bool

-- | <pre>
--   w
--   </pre>
[weak] :: DebugFlags -> Bool

-- | <pre>
--   G
--   </pre>
[gccafs] :: DebugFlags -> Bool

-- | <pre>
--   g
--   </pre>
[gc] :: DebugFlags -> Bool

-- | <pre>
--   n
--   </pre>
[nonmoving_gc] :: DebugFlags -> Bool

-- | <pre>
--   b
--   </pre>
[block_alloc] :: DebugFlags -> Bool

-- | <pre>
--   S
--   </pre>
[sanity] :: DebugFlags -> Bool

-- | <pre>
--   t
--   </pre>
[stable] :: DebugFlags -> Bool

-- | <pre>
--   p
--   </pre>
[prof] :: DebugFlags -> Bool

-- | <tt>l</tt> the object linker
[linker] :: DebugFlags -> Bool

-- | <pre>
--   a
--   </pre>
[apply] :: DebugFlags -> Bool

-- | <pre>
--   m
--   </pre>
[stm] :: DebugFlags -> Bool

-- | <tt>z</tt> stack squeezing &amp; lazy blackholing
[squeeze] :: DebugFlags -> Bool

-- | <tt>c</tt> coverage
[hpc] :: DebugFlags -> Bool

-- | <pre>
--   r
--   </pre>
[sparks] :: DebugFlags -> Bool

-- | Should the RTS produce a cost-center summary?
data DoCostCentres
CostCentresNone :: DoCostCentres
CostCentresSummary :: DoCostCentres
CostCentresVerbose :: DoCostCentres
CostCentresAll :: DoCostCentres
CostCentresJSON :: DoCostCentres

-- | Parameters pertaining to the cost-center profiler.
data CCFlags
CCFlags :: DoCostCentres -> Int -> Int -> CCFlags
[doCostCentres] :: CCFlags -> DoCostCentres
[profilerTicks] :: CCFlags -> Int
[msecsPerTick] :: CCFlags -> Int

-- | What sort of heap profile are we collecting?
data DoHeapProfile
NoHeapProfiling :: DoHeapProfile
HeapByCCS :: DoHeapProfile
HeapByMod :: DoHeapProfile
HeapByDescr :: DoHeapProfile
HeapByType :: DoHeapProfile
HeapByRetainer :: DoHeapProfile
HeapByLDV :: DoHeapProfile
HeapByClosureType :: DoHeapProfile
HeapByInfoTable :: DoHeapProfile

HeapByEra :: DoHeapProfile

-- | Parameters of the cost-center profiler
data ProfFlags
ProfFlags :: DoHeapProfile -> RtsTime -> Word -> Bool -> Bool -> Bool -> Bool -> Word -> Word -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Word -> ProfFlags
[doHeapProfile] :: ProfFlags -> DoHeapProfile

-- | time between samples
[heapProfileInterval] :: ProfFlags -> RtsTime

-- | ticks between samples (derived)
[heapProfileIntervalTicks] :: ProfFlags -> Word
[startHeapProfileAtStartup] :: ProfFlags -> Bool

[startTimeProfileAtStartup] :: ProfFlags -> Bool
[showCCSOnException] :: ProfFlags -> Bool

[automaticEraIncrement] :: ProfFlags -> Bool
[maxRetainerSetSize] :: ProfFlags -> Word
[ccsLength] :: ProfFlags -> Word
[modSelector] :: ProfFlags -> Maybe String
[descrSelector] :: ProfFlags -> Maybe String
[typeSelector] :: ProfFlags -> Maybe String
[ccSelector] :: ProfFlags -> Maybe String
[ccsSelector] :: ProfFlags -> Maybe String
[retainerSelector] :: ProfFlags -> Maybe String
[bioSelector] :: ProfFlags -> Maybe String

[eraSelector] :: ProfFlags -> Word

-- | Is event tracing enabled?
data DoTrace

-- | no tracing
TraceNone :: DoTrace

-- | send tracing events to the event log
TraceEventLog :: DoTrace

-- | send tracing events to <tt>stderr</tt>
TraceStderr :: DoTrace

-- | Parameters pertaining to event tracing
data TraceFlags
TraceFlags :: DoTrace -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> TraceFlags
[tracing] :: TraceFlags -> DoTrace

-- | show timestamp in stderr output
[timestamp] :: TraceFlags -> Bool

-- | trace scheduler events
[traceScheduler] :: TraceFlags -> Bool

-- | trace GC events
[traceGc] :: TraceFlags -> Bool

-- | trace nonmoving GC heap census samples
[traceNonmovingGc] :: TraceFlags -> Bool

-- | trace spark events by a sampled method
[sparksSampled] :: TraceFlags -> Bool

-- | trace spark events 100% accurately
[sparksFull] :: TraceFlags -> Bool

-- | trace user events (emitted from Haskell code)
[user] :: TraceFlags -> Bool

-- | Parameters pertaining to ticky-ticky profiler
data TickyFlags
TickyFlags :: Bool -> Maybe FilePath -> TickyFlags
[showTickyStats] :: TickyFlags -> Bool
[tickyFile] :: TickyFlags -> Maybe FilePath

-- | Parameters pertaining to parallelism
data ParFlags
ParFlags :: Word32 -> Bool -> Word32 -> Bool -> Word32 -> Bool -> Word32 -> Word32 -> Word32 -> Bool -> ParFlags
[nCapabilities] :: ParFlags -> Word32
[migrate] :: ParFlags -> Bool
[maxLocalSparks] :: ParFlags -> Word32
[parGcEnabled] :: ParFlags -> Bool
[parGcGen] :: ParFlags -> Word32
[parGcLoadBalancingEnabled] :: ParFlags -> Bool
[parGcLoadBalancingGen] :: ParFlags -> Word32
[parGcNoSyncWithIdle] :: ParFlags -> Word32
[parGcThreads] :: ParFlags -> Word32
[setAffinity] :: ParFlags -> Bool

-- | Parameters pertaining to Haskell program coverage (HPC)
data HpcFlags
HpcFlags :: Bool -> Bool -> HpcFlags

-- | Controls whether a <tt><a>program</a>.tix</tt> file is read at the
--   start of execution to initialize the RTS internal HPC datastructures.
[readTixFile] :: HpcFlags -> Bool

-- | Controls whether the <tt><a>program</a>.tix</tt> file should be
--   written after the execution of the program.
[writeTixFile] :: HpcFlags -> Bool
getRTSFlags :: IO RTSFlags
getGCFlags :: IO GCFlags
getConcFlags :: IO ConcFlags
getMiscFlags :: IO MiscFlags
getDebugFlags :: IO DebugFlags
getCCFlags :: IO CCFlags
getProfFlags :: IO ProfFlags
getTraceFlags :: IO TraceFlags
getTickyFlags :: IO TickyFlags
getParFlags :: IO ParFlags
getHpcFlags :: IO HpcFlags
instance GHC.Internal.Enum.Enum GHC.Internal.RTS.Flags.DoCostCentres
instance GHC.Internal.Enum.Enum GHC.Internal.RTS.Flags.DoHeapProfile
instance GHC.Internal.Enum.Enum GHC.Internal.RTS.Flags.DoTrace
instance GHC.Internal.Enum.Enum GHC.Internal.RTS.Flags.GiveGCStats
instance GHC.Internal.Enum.Enum GHC.Internal.RTS.Flags.IoManagerFlag
instance GHC.Classes.Eq GHC.Internal.RTS.Flags.IoManagerFlag
instance GHC.Internal.Generics.Generic GHC.Internal.RTS.Flags.CCFlags
instance GHC.Internal.Generics.Generic GHC.Internal.RTS.Flags.ConcFlags
instance GHC.Internal.Generics.Generic GHC.Internal.RTS.Flags.DebugFlags
instance GHC.Internal.Generics.Generic GHC.Internal.RTS.Flags.DoCostCentres
instance GHC.Internal.Generics.Generic GHC.Internal.RTS.Flags.DoHeapProfile
instance GHC.Internal.Generics.Generic GHC.Internal.RTS.Flags.DoTrace
instance GHC.Internal.Generics.Generic GHC.Internal.RTS.Flags.GCFlags
instance GHC.Internal.Generics.Generic GHC.Internal.RTS.Flags.GiveGCStats
instance GHC.Internal.Generics.Generic GHC.Internal.RTS.Flags.HpcFlags
instance GHC.Internal.Generics.Generic GHC.Internal.RTS.Flags.MiscFlags
instance GHC.Internal.Generics.Generic GHC.Internal.RTS.Flags.ParFlags
instance GHC.Internal.Generics.Generic GHC.Internal.RTS.Flags.ProfFlags
instance GHC.Internal.Generics.Generic GHC.Internal.RTS.Flags.RTSFlags
instance GHC.Internal.Generics.Generic GHC.Internal.RTS.Flags.TickyFlags
instance GHC.Internal.Generics.Generic GHC.Internal.RTS.Flags.TraceFlags
instance GHC.Internal.Show.Show GHC.Internal.RTS.Flags.CCFlags
instance GHC.Internal.Show.Show GHC.Internal.RTS.Flags.ConcFlags
instance GHC.Internal.Show.Show GHC.Internal.RTS.Flags.DebugFlags
instance GHC.Internal.Show.Show GHC.Internal.RTS.Flags.DoCostCentres
instance GHC.Internal.Show.Show GHC.Internal.RTS.Flags.DoHeapProfile
instance GHC.Internal.Show.Show GHC.Internal.RTS.Flags.DoTrace
instance GHC.Internal.Show.Show GHC.Internal.RTS.Flags.GCFlags
instance GHC.Internal.Show.Show GHC.Internal.RTS.Flags.GiveGCStats
instance GHC.Internal.Show.Show GHC.Internal.RTS.Flags.HpcFlags
instance GHC.Internal.Show.Show GHC.Internal.RTS.Flags.IoManagerFlag
instance GHC.Internal.Show.Show GHC.Internal.RTS.Flags.MiscFlags
instance GHC.Internal.Show.Show GHC.Internal.RTS.Flags.ParFlags
instance GHC.Internal.Show.Show GHC.Internal.RTS.Flags.ProfFlags
instance GHC.Internal.Show.Show GHC.Internal.RTS.Flags.RTSFlags
instance GHC.Internal.Show.Show GHC.Internal.RTS.Flags.TickyFlags
instance GHC.Internal.Show.Show GHC.Internal.RTS.Flags.TraceFlags


-- | C-specific Marshalling support: Handling of C "errno" error codes.
module GHC.Internal.Foreign.C.Error

-- | Haskell representation for <tt>errno</tt> values. The implementation
--   is deliberately exposed, to allow users to add their own definitions
--   of <a>Errno</a> values.
newtype Errno
Errno :: CInt -> Errno
eOK :: Errno
e2BIG :: Errno
eACCES :: Errno
eADDRINUSE :: Errno
eADDRNOTAVAIL :: Errno
eADV :: Errno
eAFNOSUPPORT :: Errno
eAGAIN :: Errno
eALREADY :: Errno
eBADF :: Errno
eBADMSG :: Errno
eBADRPC :: Errno
eBUSY :: Errno
eCHILD :: Errno
eCOMM :: Errno
eCONNABORTED :: Errno
eCONNREFUSED :: Errno
eCONNRESET :: Errno
eDEADLK :: Errno
eDESTADDRREQ :: Errno
eDIRTY :: Errno
eDOM :: Errno
eDQUOT :: Errno
eEXIST :: Errno
eFAULT :: Errno
eFBIG :: Errno
eFTYPE :: Errno
eHOSTDOWN :: Errno
eHOSTUNREACH :: Errno
eIDRM :: Errno
eILSEQ :: Errno
eINPROGRESS :: Errno
eINTR :: Errno
eINVAL :: Errno
eIO :: Errno
eISCONN :: Errno
eISDIR :: Errno
eLOOP :: Errno
eMFILE :: Errno
eMLINK :: Errno
eMSGSIZE :: Errno
eMULTIHOP :: Errno
eNAMETOOLONG :: Errno
eNETDOWN :: Errno
eNETRESET :: Errno
eNETUNREACH :: Errno
eNFILE :: Errno
eNOBUFS :: Errno
eNODATA :: Errno
eNODEV :: Errno
eNOENT :: Errno
eNOEXEC :: Errno
eNOLCK :: Errno
eNOLINK :: Errno
eNOMEM :: Errno
eNOMSG :: Errno
eNONET :: Errno
eNOPROTOOPT :: Errno
eNOSPC :: Errno
eNOSR :: Errno
eNOSTR :: Errno
eNOSYS :: Errno
eNOTBLK :: Errno
eNOTCONN :: Errno
eNOTDIR :: Errno
eNOTEMPTY :: Errno
eNOTSOCK :: Errno

eNOTSUP :: Errno
eNOTTY :: Errno
eNXIO :: Errno
eOPNOTSUPP :: Errno
ePERM :: Errno
ePFNOSUPPORT :: Errno
ePIPE :: Errno
ePROCLIM :: Errno
ePROCUNAVAIL :: Errno
ePROGMISMATCH :: Errno
ePROGUNAVAIL :: Errno
ePROTO :: Errno
ePROTONOSUPPORT :: Errno
ePROTOTYPE :: Errno
eRANGE :: Errno
eREMCHG :: Errno
eREMOTE :: Errno
eROFS :: Errno
eRPCMISMATCH :: Errno
eRREMOTE :: Errno
eSHUTDOWN :: Errno
eSOCKTNOSUPPORT :: Errno
eSPIPE :: Errno
eSRCH :: Errno
eSRMNT :: Errno
eSTALE :: Errno
eTIME :: Errno
eTIMEDOUT :: Errno
eTOOMANYREFS :: Errno
eTXTBSY :: Errno
eUSERS :: Errno
eWOULDBLOCK :: Errno
eXDEV :: Errno

-- | Yield <a>True</a> if the given <a>Errno</a> value is valid on the
--   system. This implies that the <a>Eq</a> instance of <a>Errno</a> is
--   also system dependent as it is only defined for valid values of
--   <a>Errno</a>.
isValidErrno :: Errno -> Bool

-- | Get the current value of <tt>errno</tt> in the current thread.
--   
--   On GHC, the runtime will ensure that any Haskell thread will only see
--   "its own" <tt>errno</tt>, by saving and restoring the value when
--   Haskell threads are scheduled across OS threads.
getErrno :: IO Errno

-- | Reset the current thread's <tt>errno</tt> value to <a>eOK</a>.
resetErrno :: IO ()

-- | Construct an <a>IOError</a> based on the given <a>Errno</a> value. The
--   optional information can be used to improve the accuracy of error
--   messages.
errnoToIOError :: String -> Errno -> Maybe Handle -> Maybe String -> IOError

-- | Throw an <a>IOError</a> corresponding to the current value of
--   <a>getErrno</a>.
throwErrno :: String -> IO a

-- | Throw an <a>IOError</a> corresponding to the current value of
--   <a>getErrno</a> if the result value of the <a>IO</a> action meets the
--   given predicate.
throwErrnoIf :: (a -> Bool) -> String -> IO a -> IO a

-- | as <a>throwErrnoIf</a>, but discards the result of the <a>IO</a>
--   action after error handling.
throwErrnoIf_ :: (a -> Bool) -> String -> IO a -> IO ()

-- | as <a>throwErrnoIf</a>, but retry the <a>IO</a> action when it yields
--   the error code <a>eINTR</a> - this amounts to the standard retry loop
--   for interrupted POSIX system calls.
throwErrnoIfRetry :: (a -> Bool) -> String -> IO a -> IO a

-- | as <a>throwErrnoIfRetry</a>, but discards the result.
throwErrnoIfRetry_ :: (a -> Bool) -> String -> IO a -> IO ()

-- | Throw an <a>IOError</a> corresponding to the current value of
--   <a>getErrno</a> if the <a>IO</a> action returns a result of
--   <tt>-1</tt>.
throwErrnoIfMinus1 :: (Eq a, Num a) => String -> IO a -> IO a

-- | as <a>throwErrnoIfMinus1</a>, but discards the result.
throwErrnoIfMinus1_ :: (Eq a, Num a) => String -> IO a -> IO ()

-- | Throw an <a>IOError</a> corresponding to the current value of
--   <a>getErrno</a> if the <a>IO</a> action returns a result of
--   <tt>-1</tt>, but retries in case of an interrupted operation.
throwErrnoIfMinus1Retry :: (Eq a, Num a) => String -> IO a -> IO a

-- | as <a>throwErrnoIfMinus1</a>, but discards the result.
throwErrnoIfMinus1Retry_ :: (Eq a, Num a) => String -> IO a -> IO ()

-- | Throw an <a>IOError</a> corresponding to the current value of
--   <a>getErrno</a> if the <a>IO</a> action returns <a>nullPtr</a>.
throwErrnoIfNull :: String -> IO (Ptr a) -> IO (Ptr a)

-- | Throw an <a>IOError</a> corresponding to the current value of
--   <a>getErrno</a> if the <a>IO</a> action returns <a>nullPtr</a>, but
--   retry in case of an interrupted operation.
throwErrnoIfNullRetry :: String -> IO (Ptr a) -> IO (Ptr a)

-- | as <a>throwErrnoIfRetry</a>, but additionally if the operation yields
--   the error code <a>eAGAIN</a> or <a>eWOULDBLOCK</a>, an alternative
--   action is executed before retrying.
throwErrnoIfRetryMayBlock :: (a -> Bool) -> String -> IO a -> IO b -> IO a

-- | as <a>throwErrnoIfRetryMayBlock</a>, but discards the result.
throwErrnoIfRetryMayBlock_ :: (a -> Bool) -> String -> IO a -> IO b -> IO ()

-- | as <a>throwErrnoIfMinus1Retry</a>, but checks for operations that
--   would block.
throwErrnoIfMinus1RetryMayBlock :: (Eq a, Num a) => String -> IO a -> IO b -> IO a

-- | as <a>throwErrnoIfMinus1RetryMayBlock</a>, but discards the result.
throwErrnoIfMinus1RetryMayBlock_ :: (Eq a, Num a) => String -> IO a -> IO b -> IO ()

-- | as <a>throwErrnoIfNullRetry</a>, but checks for operations that would
--   block.
throwErrnoIfNullRetryMayBlock :: String -> IO (Ptr a) -> IO b -> IO (Ptr a)

-- | as <a>throwErrno</a>, but exceptions include the given path when
--   appropriate.
throwErrnoPath :: String -> FilePath -> IO a

-- | as <a>throwErrnoIf</a>, but exceptions include the given path when
--   appropriate.
throwErrnoPathIf :: (a -> Bool) -> String -> FilePath -> IO a -> IO a

-- | as <a>throwErrnoIf_</a>, but exceptions include the given path when
--   appropriate.
throwErrnoPathIf_ :: (a -> Bool) -> String -> FilePath -> IO a -> IO ()

-- | as <a>throwErrnoIfNull</a>, but exceptions include the given path when
--   appropriate.
throwErrnoPathIfNull :: String -> FilePath -> IO (Ptr a) -> IO (Ptr a)

-- | as <a>throwErrnoIfMinus1</a>, but exceptions include the given path
--   when appropriate.
throwErrnoPathIfMinus1 :: (Eq a, Num a) => String -> FilePath -> IO a -> IO a

-- | as <a>throwErrnoIfMinus1_</a>, but exceptions include the given path
--   when appropriate.
throwErrnoPathIfMinus1_ :: (Eq a, Num a) => String -> FilePath -> IO a -> IO ()
instance GHC.Classes.Eq GHC.Internal.Foreign.C.Error.Errno


-- | POSIX support layer for the standard libraries.
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
--   
--   This library is built on *every* platform, including Win32.
--   
--   Non-POSIX compliant in order to support the following features: *
--   S_ISSOCK (no sockets in POSIX)
module GHC.Internal.System.Posix.Internals
puts :: String -> IO ()
data CFLock
data CGroup
data CLconv
data CPasswd
data CSigaction
data CSigset
data CStat
data CTermios
data CTm
data CTms
data CUtimbuf
data CUtsname
type FD = CInt
fdFileSize :: FD -> IO Integer
fileType :: FilePath -> IO IODeviceType
fdStat :: FD -> IO (IODeviceType, CDev, CIno)
fdType :: FD -> IO IODeviceType

-- | Return a known device type or throw an exception if the device type is
--   unknown.
statGetType :: Ptr CStat -> IO IODeviceType

-- | Unlike <tt>statGetType</tt>, <tt>statGetType_maybe</tt> will not throw
--   an exception if the CStat refers to a unknown device type.
statGetType_maybe :: Ptr CStat -> IO (Maybe IODeviceType)
ioe_unknownfiletype :: IOException
fdGetMode :: FD -> IO IOMode
withFilePath :: FilePath -> (CString -> IO a) -> IO a
newFilePath :: FilePath -> IO CString
peekFilePath :: CString -> IO FilePath
peekFilePathLen :: CStringLen -> IO FilePath

-- | Check an encoded <a>FilePath</a> for internal NUL octets as these are
--   disallowed in POSIX filepaths. See #13660.
checkForInteriorNuls :: FilePath -> CStringLen -> IO ()
throwInternalNulError :: FilePath -> IO a
setEcho :: FD -> Bool -> IO ()
getEcho :: FD -> IO Bool
setCooked :: FD -> Bool -> IO ()
tcSetAttr :: FD -> (Ptr CTermios -> IO a) -> IO a
get_saved_termios :: CInt -> IO (Ptr CTermios)
set_saved_termios :: CInt -> Ptr CTermios -> IO ()
setNonBlockingFD :: FD -> Bool -> IO ()
setCloseOnExec :: FD -> IO ()
type CFilePath = CString

-- | The same as <a>c_safe_open</a>, but an <i>interruptible operation</i>
--   as described in <a>Control.Exception</a>—it respects
--   <a>uninterruptibleMask</a> but not <a>mask</a>.
--   
--   We want to be able to interrupt an openFile call if it's expensive
--   (NFS, FUSE, etc.), and we especially need to be able to interrupt a
--   blocking open call. See #17912.
c_interruptible_open :: CFilePath -> CInt -> CMode -> IO CInt
c_safe_open :: CFilePath -> CInt -> CMode -> IO CInt

-- | Consult the RTS to find whether it is threaded.
hostIsThreaded :: Bool
c_open :: CFilePath -> CInt -> CMode -> IO CInt

c_interruptible_open_ :: CFilePath -> CInt -> CMode -> IO CInt

rtsIsThreaded_ :: Int
c_safe_open_ :: CFilePath -> CInt -> CMode -> IO CInt
c_fstat :: CInt -> Ptr CStat -> IO CInt
lstat :: CFilePath -> Ptr CStat -> IO CInt
c_read :: CInt -> Ptr Word8 -> CSize -> IO CSsize
c_safe_read :: CInt -> Ptr Word8 -> CSize -> IO CSsize
c_umask :: CMode -> IO CMode
c_write :: CInt -> Ptr Word8 -> CSize -> IO CSsize
c_safe_write :: CInt -> Ptr Word8 -> CSize -> IO CSsize
c_pipe :: Ptr CInt -> IO CInt
c_lseek :: CInt -> COff -> CInt -> IO COff
c_access :: CString -> CInt -> IO CInt
c_chmod :: CString -> CMode -> IO CInt
c_close :: CInt -> IO CInt
c_creat :: CString -> CMode -> IO CInt
c_dup :: CInt -> IO CInt
c_dup2 :: CInt -> CInt -> IO CInt
c_isatty :: CInt -> IO CInt
c_unlink :: CString -> IO CInt
c_utime :: CString -> Ptr CUtimbuf -> IO CInt
c_getpid :: IO CPid
c_stat :: CFilePath -> Ptr CStat -> IO CInt
c_ftruncate :: CInt -> COff -> IO CInt
c_fcntl_read :: CInt -> CInt -> IO CInt
c_fcntl_write :: CInt -> CInt -> CLong -> IO CInt
c_fcntl_lock :: CInt -> CInt -> Ptr CFLock -> IO CInt
c_fork :: IO CPid
c_link :: CString -> CString -> IO CInt
c_mkfifo :: CString -> CMode -> IO CInt
c_sigemptyset :: Ptr CSigset -> IO CInt
c_sigaddset :: Ptr CSigset -> CInt -> IO CInt
c_sigprocmask :: CInt -> Ptr CSigset -> Ptr CSigset -> IO CInt
c_tcgetattr :: CInt -> Ptr CTermios -> IO CInt
c_tcsetattr :: CInt -> CInt -> Ptr CTermios -> IO CInt
c_waitpid :: CPid -> Ptr CInt -> CInt -> IO CPid
o_RDONLY :: CInt
o_WRONLY :: CInt
o_RDWR :: CInt
o_APPEND :: CInt
o_CREAT :: CInt
o_EXCL :: CInt
o_TRUNC :: CInt
o_NOCTTY :: CInt
o_NONBLOCK :: CInt
o_BINARY :: CInt
c_s_isreg :: CMode -> CInt
c_s_ischr :: CMode -> CInt
c_s_isblk :: CMode -> CInt
c_s_isdir :: CMode -> CInt
c_s_isfifo :: CMode -> CInt
s_isreg :: CMode -> Bool
s_ischr :: CMode -> Bool
s_isblk :: CMode -> Bool
s_isdir :: CMode -> Bool
s_isfifo :: CMode -> Bool
sizeof_stat :: Int
st_mtime :: Ptr CStat -> IO CTime
st_size :: Ptr CStat -> IO COff
st_mode :: Ptr CStat -> IO CMode
st_dev :: Ptr CStat -> IO CDev
st_ino :: Ptr CStat -> IO CIno
const_echo :: CInt
const_tcsanow :: CInt
const_icanon :: CInt
const_vmin :: CInt
const_vtime :: CInt
const_sigttou :: CInt
const_sig_block :: CInt
const_sig_setmask :: CInt
const_f_getfl :: CInt
const_f_setfl :: CInt
const_f_setfd :: CInt
const_fd_cloexec :: CLong
sizeof_termios :: Int
sizeof_sigset_t :: Int
c_lflag :: Ptr CTermios -> IO CTcflag
poke_c_lflag :: Ptr CTermios -> CTcflag -> IO ()
ptr_c_cc :: Ptr CTermios -> IO (Ptr Word8)
s_issock :: CMode -> Bool
c_s_issock :: CMode -> CInt
dEFAULT_BUFFER_SIZE :: Int
sEEK_CUR :: CInt
sEEK_SET :: CInt
sEEK_END :: CInt


-- | This module provides text encoding/decoding using iconv
module GHC.Internal.IO.Encoding.Iconv
iconvEncoding :: String -> IO (Maybe TextEncoding)

-- | Construct an iconv-based <a>TextEncoding</a> for the given character
--   set and <a>CodingFailureMode</a>.
--   
--   As iconv is missing in some minimal environments (e.g. #10298), this
--   checks to ensure that iconv is working properly before returning the
--   encoding, returning <a>Nothing</a> if not.
mkIconvEncoding :: CodingFailureMode -> String -> IO (Maybe TextEncoding)
localeEncodingName :: String


-- | Common Timer definitions shared between WinIO and RIO.
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.Event.TimeOut

-- | A priority search queue, with timeouts as priorities.
type TimeoutQueue = PSQ TimeoutCallback

-- | Warning: since the <a>TimeoutCallback</a> is called from the I/O
--   manager, it must not throw an exception or block for a long period of
--   time. In particular, be wary of <a>throwTo</a> and <a>killThread</a>:
--   if the target thread is making a foreign call, these functions will
--   block until the call completes.
type TimeoutCallback = IO ()

-- | An edit to apply to a <a>TimeoutQueue</a>.
type TimeoutEdit = TimeoutQueue -> TimeoutQueue

-- | A timeout registration cookie.
newtype TimeoutKey
TK :: Unique -> TimeoutKey
instance GHC.Classes.Eq GHC.Internal.Event.TimeOut.TimeoutKey
instance GHC.Classes.Ord GHC.Internal.Event.TimeOut.TimeoutKey


-- | <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
--   
--   Simple UTF-8 codecs supporting non-streaming encoding/decoding. For
--   encoding where codepoints may be broken across buffers, see
--   <a>GHC.IO.Encoding.UTF8</a>.
--   
--   This is one of several UTF-8 implementations provided by GHC; see Note
--   [GHC's many UTF-8 implementations] in <a>GHC.Encoding.UTF8</a> for an
--   overview.
module GHC.Internal.Encoding.UTF8

-- | Decode a single character at the given <a>Addr#</a>.
utf8DecodeCharAddr# :: Addr# -> Int# -> (# Char#, Int# #)

-- | Decode a single codepoint starting at the given <a>Ptr</a>.
utf8DecodeCharPtr :: Ptr Word8 -> (Char, Int)

-- | Decode a single codepoint starting at the given byte offset into a
--   <a>ByteArray#</a>.
utf8DecodeCharByteArray# :: ByteArray# -> Int# -> (# Char#, Int# #)
utf8DecodeByteArray# :: ByteArray# -> [Char]
utf8DecodeForeignPtr :: ForeignPtr Word8 -> Int -> Int -> [Char]
utf8CountCharsByteArray# :: ByteArray# -> Int
utf8CompareByteArray# :: ByteArray# -> ByteArray# -> Ordering
utf8EncodePtr :: Ptr Word8 -> String -> IO ()
utf8EncodeByteArray# :: String -> ByteArray#
utf8EncodedLength :: String -> Int

module GHC.Internal.Weak.Finalize

-- | Set the global action called to report exceptions thrown by weak
--   pointer finalizers to the user.
setFinalizerExceptionHandler :: (SomeException -> IO ()) -> IO ()

-- | Get the global action called to report exceptions thrown by weak
--   pointer finalizers to the user.
getFinalizerExceptionHandler :: IO (SomeException -> IO ())

-- | An exception handler for <a>Handle</a> finalization that prints the
--   error to the given <a>Handle</a>, but doesn't rethrow it.
printToHandleFinalizerExceptionHandler :: Handle -> SomeException -> IO ()

-- | Run a batch of finalizers from the garbage collector. We're given an
--   array of finalizers and the length of the array, and we just call each
--   one in turn.
runFinalizerBatch :: Int -> Array# (State# RealWorld -> State# RealWorld) -> IO ()


-- | Weak pointers.
module GHC.Internal.Weak

-- | A weak pointer object with a key and a value. The value has type
--   <tt>v</tt>.
--   
--   A weak pointer expresses a relationship between two objects, the
--   <i>key</i> and the <i>value</i>: if the key is considered to be alive
--   by the garbage collector, then the value is also alive. A reference
--   from the value to the key does <i>not</i> keep the key alive.
--   
--   A weak pointer may also have a finalizer of type <tt>IO ()</tt>; if it
--   does, then the finalizer will be run at most once, at a time after the
--   key has become unreachable by the program ("dead"). The storage
--   manager attempts to run the finalizer(s) for an object soon after the
--   object dies, but promptness is not guaranteed.
--   
--   It is not guaranteed that a finalizer will eventually run, and no
--   attempt is made to run outstanding finalizers when the program exits.
--   Therefore finalizers should not be relied on to clean up resources -
--   other methods (eg. exception handlers) should be employed, possibly in
--   addition to finalizers.
--   
--   References from the finalizer to the key are treated in the same way
--   as references from the value to the key: they do not keep the key
--   alive. A finalizer may therefore resurrect the key, perhaps by storing
--   it in the same data structure.
--   
--   The finalizer, and the relationship between the key and the value,
--   exist regardless of whether the program keeps a reference to the
--   <a>Weak</a> object or not.
--   
--   There may be multiple weak pointers with the same key. In this case,
--   the finalizers for each of these weak pointers will all be run in some
--   arbitrary order, or perhaps concurrently, when the key dies. If the
--   programmer specifies a finalizer that assumes it has the only
--   reference to an object (for example, a file that it wishes to close),
--   then the programmer must ensure that there is only one such finalizer.
--   
--   If there are no other threads to run, the runtime system will check
--   for runnable finalizers before declaring the system to be deadlocked.
--   
--   WARNING: weak pointers to ordinary non-primitive Haskell types are
--   particularly fragile, because the compiler is free to optimise away or
--   duplicate the underlying data structure. Therefore attempting to place
--   a finalizer on an ordinary Haskell type may well result in the
--   finalizer running earlier than you expected. This is not a problem for
--   caches and memo tables where early finalization is benign.
--   
--   Finalizers <i>can</i> be used reliably for types that are created
--   explicitly and have identity, such as <tt>IORef</tt>, <tt>MVar</tt>,
--   and <tt>TVar</tt>. However, to place a finalizer on one of these
--   types, you should use the specific operation provided for that type,
--   e.g. <tt>mkWeakIORef</tt>, <tt>mkWeakMVar</tt> and <tt>mkWeakTVar</tt>
--   respectively. These operations attach the finalizer to the primitive
--   object inside the box (e.g. <tt>MutVar#</tt> in the case of
--   <tt>IORef</tt>), because attaching the finalizer to the box itself
--   fails when the outer box is optimised away by the compiler.
data Weak v
Weak :: Weak# v -> Weak v

-- | Establishes a weak pointer to <tt>k</tt>, with value <tt>v</tt> and a
--   finalizer.
--   
--   This is the most general interface for building a weak pointer.
mkWeak :: k -> v -> Maybe (IO ()) -> IO (Weak v)

-- | Dereferences a weak pointer. If the key is still alive, then
--   <tt><a>Just</a> v</tt> is returned (where <tt>v</tt> is the
--   <i>value</i> in the weak pointer), otherwise <a>Nothing</a> is
--   returned.
--   
--   The return value of <a>deRefWeak</a> depends on when the garbage
--   collector runs, hence it is in the <a>IO</a> monad.
deRefWeak :: Weak v -> IO (Maybe v)

-- | Causes a the finalizer associated with a weak pointer to be run
--   immediately.
finalize :: Weak v -> IO ()

-- | Set the global action called to report exceptions thrown by weak
--   pointer finalizers to the user.
setFinalizerExceptionHandler :: (SomeException -> IO ()) -> IO ()

-- | Get the global action called to report exceptions thrown by weak
--   pointer finalizers to the user.
getFinalizerExceptionHandler :: IO (SomeException -> IO ())

-- | An exception handler for <a>Handle</a> finalization that prints the
--   error to the given <a>Handle</a>, but doesn't rethrow it.
printToHandleFinalizerExceptionHandler :: Handle -> SomeException -> IO ()


-- | Mutable references in the IO monad.
module GHC.Internal.Data.IORef

-- | A mutable variable in the <a>IO</a> monad.
--   
--   <pre>
--   &gt;&gt;&gt; import GHC.Internal.Data.IORef
--   
--   &gt;&gt;&gt; r &lt;- newIORef 0
--   
--   &gt;&gt;&gt; readIORef r
--   0
--   
--   &gt;&gt;&gt; writeIORef r 1
--   
--   &gt;&gt;&gt; readIORef r
--   1
--   
--   &gt;&gt;&gt; atomicWriteIORef r 2
--   
--   &gt;&gt;&gt; readIORef r
--   2
--   
--   &gt;&gt;&gt; modifyIORef' r (+ 1)
--   
--   &gt;&gt;&gt; readIORef r
--   3
--   
--   &gt;&gt;&gt; atomicModifyIORef' r (\a -&gt; (a + 1, ()))
--   
--   &gt;&gt;&gt; readIORef r
--   4
--   </pre>
--   
--   See also <a>STRef</a> and <a>MVar</a>.
data IORef a

-- | Build a new <a>IORef</a>
newIORef :: a -> IO (IORef a)

-- | Read the value of an <a>IORef</a>.
--   
--   Beware that the CPU executing a thread can reorder reads or writes to
--   independent locations. See <a>Data.IORef#memmodel</a> for more
--   details.
readIORef :: IORef a -> IO a

-- | Write a new value into an <a>IORef</a>.
--   
--   This function does not create a memory barrier and can be reordered
--   with other independent reads and writes within a thread, which may
--   cause issues for multithreaded execution. In these cases, consider
--   using <a>atomicWriteIORef</a> instead. See <a>Data.IORef#memmodel</a>
--   for more details.
writeIORef :: IORef a -> a -> IO ()

-- | Mutate the contents of an <a>IORef</a>, combining <a>readIORef</a> and
--   <a>writeIORef</a>. This is not an atomic update, consider using
--   <a>atomicModifyIORef</a> when operating in a multithreaded
--   environment.
--   
--   Be warned that <a>modifyIORef</a> does not apply the function
--   strictly. This means if the program calls <a>modifyIORef</a> many
--   times, but seldom uses the value, thunks will pile up in memory
--   resulting in a space leak. This is a common mistake made when using an
--   IORef as a counter. For example, the following will likely produce a
--   stack overflow:
--   
--   <pre>
--   ref &lt;- newIORef 0
--   replicateM_ 1000000 $ modifyIORef ref (+1)
--   readIORef ref &gt;&gt;= print
--   </pre>
--   
--   To avoid this problem, use <a>modifyIORef'</a> instead.
modifyIORef :: IORef a -> (a -> a) -> IO ()

-- | Strict version of <a>modifyIORef</a>. This is not an atomic update,
--   consider using <a>atomicModifyIORef'</a> when operating in a
--   multithreaded environment.
modifyIORef' :: IORef a -> (a -> a) -> IO ()

-- | Atomically modifies the contents of an <a>IORef</a>.
--   
--   This function is useful for using <a>IORef</a> in a safe way in a
--   multithreaded program. If you only have one <a>IORef</a>, then using
--   <a>atomicModifyIORef</a> to access and modify it will prevent race
--   conditions.
--   
--   Extending the atomicity to multiple <a>IORef</a>s is problematic, so
--   it is recommended that if you need to do anything more complicated
--   then using <a>MVar</a> instead is a good idea.
--   
--   Conceptually,
--   
--   <pre>
--   atomicModifyIORef ref f = do
--     -- Begin atomic block
--     old &lt;- <a>readIORef</a> ref
--     let r = f old
--         new = fst r
--     <a>writeIORef</a> ref new
--     -- End atomic block
--     case r of
--       (_new, res) -&gt; pure res
--   </pre>
--   
--   The actions in the section labeled "atomic block" are not subject to
--   interference from other threads. In particular, it is impossible for
--   the value in the <a>IORef</a> to change between the <a>readIORef</a>
--   and <a>writeIORef</a> invocations.
--   
--   The user-supplied function is applied to the value stored in the
--   <a>IORef</a>, yielding a new value to store in the <a>IORef</a> and a
--   value to return. After the new value is (lazily) stored in the
--   <a>IORef</a>, <tt>atomicModifyIORef</tt> forces the result pair, but
--   does not force either component of the result. To force <i>both</i>
--   components, use <a>atomicModifyIORef'</a>.
--   
--   Note that
--   
--   <pre>
--   atomicModifyIORef ref (_ -&gt; undefined)
--   </pre>
--   
--   will raise an exception in the calling thread, but will <i>also</i>
--   install the bottoming value in the <a>IORef</a>, where it may be read
--   by other threads.
--   
--   This function imposes a memory barrier, preventing reordering around
--   the "atomic block"; see <a>Data.IORef#memmodel</a> for details.
atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b

-- | A strict version of <a>atomicModifyIORef</a>. This forces both the
--   value stored in the <a>IORef</a> and the value returned.
--   
--   Conceptually,
--   
--   <pre>
--   atomicModifyIORef' ref f = do
--     -- Begin atomic block
--     old &lt;- <a>readIORef</a> ref
--     let r = f old
--         new = fst r
--     <a>writeIORef</a> ref new
--     -- End atomic block
--     case r of
--       (!_new, !res) -&gt; pure res
--   </pre>
--   
--   The actions in the "atomic block" are not subject to interference by
--   other threads. In particular, the value in the <a>IORef</a> cannot
--   change between the <a>readIORef</a> and <a>writeIORef</a> invocations.
--   
--   The new value is installed in the <a>IORef</a> before either value is
--   forced. So
--   
--   <pre>
--   atomicModifyIORef' ref (x -&gt; (x+1, undefined))
--   </pre>
--   
--   will increment the <a>IORef</a> and then throw an exception in the
--   calling thread.
--   
--   <pre>
--   atomicModifyIORef' ref (x -&gt; (undefined, x))
--   </pre>
--   
--   and
--   
--   <pre>
--   atomicModifyIORef' ref (_ -&gt; undefined)
--   </pre>
--   
--   will each raise an exception in the calling thread, but will
--   <i>also</i> install the bottoming value in the <a>IORef</a>, where it
--   may be read by other threads.
--   
--   This function imposes a memory barrier, preventing reordering around
--   the "atomic block"; see <a>Data.IORef#memmodel</a> for details.
atomicModifyIORef' :: IORef a -> (a -> (a, b)) -> IO b

-- | Variant of <a>writeIORef</a>. The prefix "atomic" relates to a fact
--   that it imposes a reordering barrier, similar to
--   <a>atomicModifyIORef</a>. Such a write will not be reordered with
--   other reads or writes even on CPUs with weak memory model.
atomicWriteIORef :: IORef a -> a -> IO ()

-- | Make a <a>Weak</a> pointer to an <a>IORef</a>, using the second
--   argument as a finalizer to run when <a>IORef</a> is garbage-collected
mkWeakIORef :: IORef a -> IO () -> IO (Weak (IORef a))


-- | Text codecs for I/O
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.IO.Encoding
data BufferCodec from to state
BufferCodec# :: CodeBuffer# from to -> (Buffer from -> Buffer to -> State# RealWorld -> (# State# RealWorld, Buffer from, Buffer to #)) -> IO () -> IO state -> (state -> IO ()) -> BufferCodec from to state

-- | The <tt>encode</tt> function translates elements of the buffer
--   <tt>from</tt> to the buffer <tt>to</tt>. It should translate as many
--   elements as possible given the sizes of the buffers, including
--   translating zero elements if there is either not enough room in
--   <tt>to</tt>, or <tt>from</tt> does not contain a complete multibyte
--   sequence.
--   
--   If multiple CodingProgress returns are possible, OutputUnderflow must
--   be preferred to InvalidSequence. This allows GHC's IO library to
--   assume that if we observe InvalidSequence there is at least a single
--   element available in the output buffer.
--   
--   The fact that as many elements as possible are translated is used by
--   the IO library in order to report translation errors at the point they
--   actually occur, rather than when the buffer is translated.
[encode#] :: BufferCodec from to state -> CodeBuffer# from to

-- | The <tt>recover</tt> function is used to continue decoding in the
--   presence of invalid or unrepresentable sequences. This includes both
--   those detected by <tt>encode</tt> returning <tt>InvalidSequence</tt>
--   and those that occur because the input byte sequence appears to be
--   truncated.
--   
--   Progress will usually be made by skipping the first element of the
--   <tt>from</tt> buffer. This function should only be called if you are
--   certain that you wish to do this skipping and if the <tt>to</tt>
--   buffer has at least one element of free space. Because this function
--   deals with decoding failure, it assumes that the from buffer has at
--   least one element.
--   
--   <tt>recover</tt> may raise an exception rather than skipping anything.
--   
--   Currently, some implementations of <tt>recover</tt> may mutate the
--   input buffer. In particular, this feature is used to implement
--   transliteration.
[recover#] :: BufferCodec from to state -> Buffer from -> Buffer to -> State# RealWorld -> (# State# RealWorld, Buffer from, Buffer to #)

-- | Resources associated with the encoding may now be released. The
--   <tt>encode</tt> function may not be called again after calling
--   <tt>close</tt>.
[close#] :: BufferCodec from to state -> IO ()

-- | Return the current state of the codec.
--   
--   Many codecs are not stateful, and in these case the state can be
--   represented as <tt>()</tt>. Other codecs maintain a state. For
--   example, UTF-16 recognises a BOM (byte-order-mark) character at the
--   beginning of the input, and remembers thereafter whether to use
--   big-endian or little-endian mode. In this case, the state of the codec
--   would include two pieces of information: whether we are at the
--   beginning of the stream (the BOM only occurs at the beginning), and if
--   not, whether to use the big or little-endian encoding.
[getState#] :: BufferCodec from to state -> IO state
[setState#] :: BufferCodec from to state -> state -> IO ()
pattern BufferCodec :: CodeBuffer from to -> (Buffer from -> Buffer to -> IO (Buffer from, Buffer to)) -> IO () -> IO state -> (state -> IO ()) -> BufferCodec from to state

-- | A <a>TextEncoding</a> is a specification of a conversion scheme
--   between sequences of bytes and sequences of Unicode characters.
--   
--   For example, UTF-8 is an encoding of Unicode characters into a
--   sequence of bytes. The <a>TextEncoding</a> for UTF-8 is <a>utf8</a>.
data TextEncoding
TextEncoding :: String -> IO (TextDecoder dstate) -> IO (TextEncoder estate) -> TextEncoding

-- | a string that can be passed to <a>mkTextEncoding</a> to create an
--   equivalent <a>TextEncoding</a>.
[textEncodingName] :: TextEncoding -> String

-- | Creates a means of decoding bytes into characters: the result must not
--   be shared between several byte sequences or simultaneously across
--   threads
[mkTextDecoder] :: TextEncoding -> IO (TextDecoder dstate)

-- | Creates a means of encode characters into bytes: the result must not
--   be shared between several character sequences or simultaneously across
--   threads
[mkTextEncoder] :: TextEncoding -> IO (TextEncoder estate)
type TextEncoder state = BufferCodec CharBufElem Word8 state
type TextDecoder state = BufferCodec Word8 CharBufElem state

data CodingProgress

-- | Stopped because the input contains insufficient available elements, or
--   all of the input sequence has been successfully translated.
InputUnderflow :: CodingProgress

-- | Stopped because the output contains insufficient free elements
OutputUnderflow :: CodingProgress

-- | Stopped because there are sufficient free elements in the output to
--   output at least one encoded ASCII character, but the input contains an
--   invalid or unrepresentable sequence
InvalidSequence :: CodingProgress

-- | The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to
--   the first 256 Unicode code points, and is thus not a complete Unicode
--   encoding. An attempt to write a character greater than <tt>'\255'</tt>
--   to a <a>Handle</a> using the <a>latin1</a> encoding will result in an
--   error.
latin1 :: TextEncoding
latin1_encode :: CharBuffer -> Buffer Word8 -> IO (CharBuffer, Buffer Word8)
latin1_decode :: Buffer Word8 -> CharBuffer -> IO (Buffer Word8, CharBuffer)

-- | The UTF-8 Unicode encoding
utf8 :: TextEncoding

-- | The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte
--   sequence 0xEF 0xBB 0xBF). This encoding behaves like <a>utf8</a>,
--   except that on input, the BOM sequence is ignored at the beginning of
--   the stream, and on output, the BOM sequence is prepended.
--   
--   The byte-order-mark is strictly unnecessary in UTF-8, but is sometimes
--   used to identify the encoding of a file.
utf8_bom :: TextEncoding

-- | The UTF-16 Unicode encoding (a byte-order-mark should be used to
--   indicate endianness).
utf16 :: TextEncoding

-- | The UTF-16 Unicode encoding (little-endian)
utf16le :: TextEncoding

-- | The UTF-16 Unicode encoding (big-endian)
utf16be :: TextEncoding

-- | The UTF-32 Unicode encoding (a byte-order-mark should be used to
--   indicate endianness).
utf32 :: TextEncoding

-- | The UTF-32 Unicode encoding (little-endian)
utf32le :: TextEncoding

-- | The UTF-32 Unicode encoding (big-endian)
utf32be :: TextEncoding

initLocaleEncoding :: TextEncoding

-- | The Unicode encoding of the current locale
getLocaleEncoding :: IO TextEncoding

-- | The encoding of the current locale, but allowing arbitrary undecodable
--   bytes to be round-tripped through it.
--   
--   Do not expect the encoding to be Unicode-compatible: it could appear
--   to be ASCII or anything else.
--   
--   This <a>TextEncoding</a> is used to decode and encode command line
--   arguments and environment variables on non-Windows platforms.
--   
--   On Windows, this encoding *should not* be used if possible because the
--   use of code pages is deprecated: Strings should be retrieved via the
--   "wide" W-family of UTF-16 APIs instead
getFileSystemEncoding :: IO TextEncoding

-- | The Unicode encoding of the current locale, but where undecodable
--   bytes are replaced with their closest visual match. Used for the
--   <a>CString</a> marshalling functions in <a>Foreign.C.String</a>
getForeignEncoding :: IO TextEncoding

-- | Set locale encoding for your program. The locale affects how
--   <a>Char</a>s are encoded and decoded when serialized to bytes: e. g.,
--   when you read or write files (<a>readFile'</a>, <a>writeFile</a>) or
--   use standard input/output (<a>getLine</a>, <a>putStrLn</a>). For
--   instance, if your program prints non-ASCII characters, it is prudent
--   to execute
--   
--   <pre>
--   setLocaleEncoding utf8
--   </pre>
--   
--   This is necessary, but not enough on Windows, where console is a
--   stateful device, which needs to be configured using
--   <tt>System.Win32.Console.setConsoleOutputCP</tt> and restored back
--   afterwards. These intricacies are covered by <a>code-page</a> package,
--   which offers a crossplatform <tt>System.IO.CodePage.withCodePage</tt>
--   bracket.
--   
--   Wrong locale encoding typically causes error messages like "invalid
--   argument (cannot decode byte sequence starting from ...)" or "invalid
--   argument (cannot encode character ...)".
setLocaleEncoding :: TextEncoding -> IO ()

setFileSystemEncoding :: TextEncoding -> IO ()

setForeignEncoding :: TextEncoding -> IO ()

-- | An encoding in which Unicode code points are translated to bytes by
--   taking the code point modulo 256. When decoding, bytes are translated
--   directly into the equivalent code point.
--   
--   This encoding never fails in either direction. However, encoding
--   discards information, so encode followed by decode is not the
--   identity.
char8 :: TextEncoding

-- | Look up the named Unicode encoding. May fail with
--   
--   <ul>
--   <li><a>isDoesNotExistError</a> if the encoding is unknown</li>
--   </ul>
--   
--   The set of known encodings is system-dependent, but includes at least:
--   
--   <ul>
--   <li><pre>UTF-8</pre></li>
--   <li><tt>UTF-16</tt>, <tt>UTF-16BE</tt>, <tt>UTF-16LE</tt></li>
--   <li><tt>UTF-32</tt>, <tt>UTF-32BE</tt>, <tt>UTF-32LE</tt></li>
--   </ul>
--   
--   There is additional notation (borrowed from GNU iconv) for specifying
--   how illegal characters are handled:
--   
--   <ul>
--   <li>a suffix of <tt>//IGNORE</tt>, e.g. <tt>UTF-8//IGNORE</tt>, will
--   cause all illegal sequences on input to be ignored, and on output will
--   drop all code points that have no representation in the target
--   encoding.</li>
--   <li>a suffix of <tt>//TRANSLIT</tt> will choose a replacement
--   character for illegal sequences or code points.</li>
--   <li>a suffix of <tt>//ROUNDTRIP</tt> will use a PEP383-style escape
--   mechanism to represent any invalid bytes in the input as Unicode
--   codepoints (specifically, as lone surrogates, which are normally
--   invalid in UTF-32). Upon output, these special codepoints are detected
--   and turned back into the corresponding original byte.</li>
--   </ul>
--   
--   In theory, this mechanism allows arbitrary data to be roundtripped via
--   a <a>String</a> with no loss of data. In practice, there are two
--   limitations to be aware of:
--   
--   <ol>
--   <li>This only stands a chance of working for an encoding which is an
--   ASCII superset, as for security reasons we refuse to escape any bytes
--   smaller than 128. Many encodings of interest are ASCII supersets (in
--   particular, you can assume that the locale encoding is an ASCII
--   superset) but many (such as UTF-16) are not.</li>
--   <li>If the underlying encoding is not itself roundtrippable, this
--   mechanism can fail. Roundtrippable encodings are those which have an
--   injective mapping into Unicode. Almost all encodings meet this
--   criterion, but some do not. Notably, Shift-JIS (CP932) and Big5
--   contain several different encodings of the same Unicode
--   codepoint.</li>
--   </ol>
--   
--   On Windows, you can access supported code pages with the prefix
--   <tt>CP</tt>; for example, <tt>"CP1250"</tt>.
mkTextEncoding :: String -> IO TextEncoding

-- | Internal encoding of argv
argvEncoding :: IO TextEncoding


-- | Access to GHC's call-stack simulation
module GHC.Internal.Stack.CCS

-- | Returns a <tt>[String]</tt> representing the current call stack. This
--   can be useful for debugging.
--   
--   The implementation uses the call-stack simulation maintained by the
--   profiler, so it only works if the program was compiled with
--   <tt>-prof</tt> and contains suitable SCC annotations (e.g. by using
--   <tt>-fprof-auto</tt>). Otherwise, the list returned is likely to be
--   empty or uninformative.
currentCallStack :: IO [String]

-- | Get the stack trace attached to an object.
whoCreated :: a -> IO [String]

-- | A cost-centre stack from GHC's cost-center profiler.
data CostCentreStack

-- | A cost-centre from GHC's cost-center profiler.
data CostCentre

-- | Returns the current <a>CostCentreStack</a> (value is <tt>nullPtr</tt>
--   if the current program was not compiled with profiling support). Takes
--   a dummy argument which can be used to avoid the call to
--   <tt>getCurrentCCS</tt> being floated out by the simplifier, which
--   would result in an uninformative stack (<a>CAF</a>).
getCurrentCCS :: dummy -> IO (Ptr CostCentreStack)

-- | Get the <a>CostCentreStack</a> associated with the given value.
getCCSOf :: a -> IO (Ptr CostCentreStack)

-- | Run a computation with an empty cost-center stack. For example, this
--   is used by the interpreter to run an interpreted computation without
--   the call stack showing that it was invoked from GHC.
clearCCS :: IO a -> IO a

-- | Get the <a>CostCentre</a> at the head of a <a>CostCentreStack</a>.
ccsCC :: Ptr CostCentreStack -> IO (Ptr CostCentre)

-- | Get the tail of a <a>CostCentreStack</a>.
ccsParent :: Ptr CostCentreStack -> IO (Ptr CostCentreStack)

-- | Get the label of a <a>CostCentre</a>.
ccLabel :: Ptr CostCentre -> IO CString

-- | Get the module of a <a>CostCentre</a>.
ccModule :: Ptr CostCentre -> IO CString

-- | Get the source span of a <a>CostCentre</a>.
ccSrcSpan :: Ptr CostCentre -> IO CString

-- | Format a <a>CostCentreStack</a> as a list of lines.
ccsToStrings :: Ptr CostCentreStack -> IO [String]
renderStack :: [String] -> String


-- | Access to GHC's call-stack simulation
module GHC.Internal.Stack

-- | Like the function <a>error</a>, but appends a stack trace to the error
--   message if one is available.

-- | <i>Deprecated: <a>error</a> appends the call stack now</i>
errorWithStackTrace :: String -> a

-- | Returns a <tt>[String]</tt> representing the current call stack. This
--   can be useful for debugging.
--   
--   The implementation uses the call-stack simulation maintained by the
--   profiler, so it only works if the program was compiled with
--   <tt>-prof</tt> and contains suitable SCC annotations (e.g. by using
--   <tt>-fprof-auto</tt>). Otherwise, the list returned is likely to be
--   empty or uninformative.
currentCallStack :: IO [String]

-- | Get the stack trace attached to an object.
whoCreated :: a -> IO [String]

-- | <a>CallStack</a>s are a lightweight method of obtaining a partial
--   call-stack at any point in the program.
--   
--   A function can request its call-site with the <a>HasCallStack</a>
--   constraint. For example, we can define
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   </pre>
--   
--   as a variant of <tt>putStrLn</tt> that will get its call-site and
--   print it, along with the string given as argument. We can access the
--   call-stack inside <tt>putStrLnWithCallStack</tt> with
--   <a>callStack</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   putStrLnWithCallStack msg = do
--     putStrLn msg
--     putStrLn (prettyCallStack callStack)
--   :}
--   </pre>
--   
--   Thus, if we call <tt>putStrLnWithCallStack</tt> we will get a
--   formatted call-stack alongside our string.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLnWithCallStack "hello"
--   hello
--   CallStack (from HasCallStack):
--     putStrLnWithCallStack, called at &lt;interactive&gt;:... in interactive:Ghci...
--   </pre>
--   
--   GHC solves <a>HasCallStack</a> constraints in three steps:
--   
--   <ol>
--   <li>If there is a <a>CallStack</a> in scope -- i.e. the enclosing
--   function has a <a>HasCallStack</a> constraint -- GHC will append the
--   new call-site to the existing <a>CallStack</a>.</li>
--   <li>If there is no <a>CallStack</a> in scope -- e.g. in the GHCi
--   session above -- and the enclosing definition does not have an
--   explicit type signature, GHC will infer a <a>HasCallStack</a>
--   constraint for the enclosing definition (subject to the monomorphism
--   restriction).</li>
--   <li>If there is no <a>CallStack</a> in scope and the enclosing
--   definition has an explicit type signature, GHC will solve the
--   <a>HasCallStack</a> constraint for the singleton <a>CallStack</a>
--   containing just the current call-site.</li>
--   </ol>
--   
--   <a>CallStack</a>s do not interact with the RTS and do not require
--   compilation with <tt>-prof</tt>. On the other hand, as they are built
--   up explicitly via the <a>HasCallStack</a> constraints, they will
--   generally not contain as much information as the simulated call-stacks
--   maintained by the RTS.
--   
--   A <a>CallStack</a> is a <tt>[(String, SrcLoc)]</tt>. The
--   <tt>String</tt> is the name of function that was called, the
--   <a>SrcLoc</a> is the call-site. The list is ordered with the most
--   recently called function at the head.
--   
--   NOTE: The intrepid user may notice that <a>HasCallStack</a> is just an
--   alias for an implicit parameter <tt>?callStack :: CallStack</tt>. This
--   is an implementation detail and <b>should not</b> be considered part
--   of the <a>CallStack</a> API, we may decide to change the
--   implementation in the future.
data CallStack

-- | Request a CallStack.
--   
--   NOTE: The implicit parameter <tt>?callStack :: CallStack</tt> is an
--   implementation detail and <b>should not</b> be considered part of the
--   <a>CallStack</a> API, we may decide to change the implementation in
--   the future.
type HasCallStack = ?callStack :: CallStack

-- | Return the current <a>CallStack</a>.
--   
--   Does *not* include the call-site of <a>callStack</a>.
callStack :: HasCallStack => CallStack

-- | The empty <a>CallStack</a>.
emptyCallStack :: CallStack

-- | Freeze a call-stack, preventing any further call-sites from being
--   appended.
--   
--   <pre>
--   pushCallStack callSite (freezeCallStack callStack) = freezeCallStack callStack
--   </pre>
freezeCallStack :: CallStack -> CallStack

-- | Convert a list of call-sites to a <a>CallStack</a>.
fromCallSiteList :: [([Char], SrcLoc)] -> CallStack

-- | Extract a list of call-sites from the <a>CallStack</a>.
--   
--   The list is ordered by most recent call.
getCallStack :: CallStack -> [([Char], SrcLoc)]

-- | Pop the most recent call-site off the <a>CallStack</a>.
--   
--   This function, like <a>pushCallStack</a>, has no effect on a frozen
--   <a>CallStack</a>.
popCallStack :: CallStack -> CallStack

-- | Push a call-site onto the stack.
--   
--   This function has no effect on a frozen <a>CallStack</a>.
pushCallStack :: ([Char], SrcLoc) -> CallStack -> CallStack

-- | Perform some computation without adding new entries to the
--   <a>CallStack</a>.
withFrozenCallStack :: HasCallStack => (HasCallStack => a) -> a
prettyCallStackLines :: CallStack -> [String]

-- | Pretty print a <a>CallStack</a>.
prettyCallStack :: CallStack -> String

-- | A single location in the source code.
data SrcLoc
SrcLoc :: [Char] -> [Char] -> [Char] -> Int -> Int -> Int -> Int -> SrcLoc
[srcLocPackage] :: SrcLoc -> [Char]
[srcLocModule] :: SrcLoc -> [Char]
[srcLocFile] :: SrcLoc -> [Char]
[srcLocStartLine] :: SrcLoc -> Int
[srcLocStartCol] :: SrcLoc -> Int
[srcLocEndLine] :: SrcLoc -> Int
[srcLocEndCol] :: SrcLoc -> Int

-- | Pretty print a <a>SrcLoc</a>.
prettySrcLoc :: SrcLoc -> String

-- | A cost-centre stack from GHC's cost-center profiler.
data CostCentreStack

-- | A cost-centre from GHC's cost-center profiler.
data CostCentre

-- | Returns the current <a>CostCentreStack</a> (value is <tt>nullPtr</tt>
--   if the current program was not compiled with profiling support). Takes
--   a dummy argument which can be used to avoid the call to
--   <tt>getCurrentCCS</tt> being floated out by the simplifier, which
--   would result in an uninformative stack (<a>CAF</a>).
getCurrentCCS :: dummy -> IO (Ptr CostCentreStack)

-- | Get the <a>CostCentreStack</a> associated with the given value.
getCCSOf :: a -> IO (Ptr CostCentreStack)

-- | Run a computation with an empty cost-center stack. For example, this
--   is used by the interpreter to run an interpreted computation without
--   the call stack showing that it was invoked from GHC.
clearCCS :: IO a -> IO a

-- | Get the <a>CostCentre</a> at the head of a <a>CostCentreStack</a>.
ccsCC :: Ptr CostCentreStack -> IO (Ptr CostCentre)

-- | Get the tail of a <a>CostCentreStack</a>.
ccsParent :: Ptr CostCentreStack -> IO (Ptr CostCentreStack)

-- | Get the label of a <a>CostCentre</a>.
ccLabel :: Ptr CostCentre -> IO CString

-- | Get the module of a <a>CostCentre</a>.
ccModule :: Ptr CostCentre -> IO CString

-- | Get the source span of a <a>CostCentre</a>.
ccSrcSpan :: Ptr CostCentre -> IO CString

-- | Format a <a>CostCentreStack</a> as a list of lines.
ccsToStrings :: Ptr CostCentreStack -> IO [String]
renderStack :: [String] -> String

module GHC.Internal.InfoProv.Types
data InfoProv
InfoProv :: String -> ClosureType -> String -> String -> String -> String -> String -> String -> InfoProv
[ipName] :: InfoProv -> String
[ipDesc] :: InfoProv -> ClosureType
[ipTyDesc] :: InfoProv -> String
[ipLabel] :: InfoProv -> String

[ipUnitId] :: InfoProv -> String
[ipMod] :: InfoProv -> String
[ipSrcFile] :: InfoProv -> String
[ipSrcSpan] :: InfoProv -> String
ipLoc :: InfoProv -> String
ipeProv :: Ptr InfoProvEnt -> Ptr InfoProv
data InfoProvEnt
peekInfoProv :: Ptr InfoProv -> IO InfoProv
getIPE :: a -> r -> (Ptr InfoProvEnt -> IO r) -> IO r
data StgInfoTable
lookupIPE :: Ptr StgInfoTable -> IO (Maybe InfoProv)
instance GHC.Classes.Eq GHC.Internal.InfoProv.Types.InfoProv
instance GHC.Internal.Show.Show GHC.Internal.InfoProv.Types.InfoProv


-- | Access to GHC's info-table provenance metadata.
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.InfoProv
data InfoProv
InfoProv :: String -> ClosureType -> String -> String -> String -> String -> String -> String -> InfoProv
[ipName] :: InfoProv -> String
[ipDesc] :: InfoProv -> ClosureType
[ipTyDesc] :: InfoProv -> String
[ipLabel] :: InfoProv -> String

[ipUnitId] :: InfoProv -> String
[ipMod] :: InfoProv -> String
[ipSrcFile] :: InfoProv -> String
[ipSrcSpan] :: InfoProv -> String
ipLoc :: InfoProv -> String

-- | Get information about where a value originated from. This information
--   is stored statically in a binary when <tt>-finfo-table-map</tt> is
--   enabled. The source positions will be greatly improved by also enabled
--   debug information with <tt>-g3</tt>. Finally you can enable
--   <tt>-fdistinct-constructor-tables</tt> to get more precise information
--   about data constructor allocations.
--   
--   The information is collect by looking at the info table address of a
--   specific closure and then consulting a specially generated map (by
--   <tt>-finfo-table-map</tt>) to find out where we think the best source
--   position to describe that info table arose from.
whereFrom :: a -> IO (Maybe InfoProv)
data InfoProvEnt
ipeProv :: Ptr InfoProvEnt -> Ptr InfoProv
peekInfoProv :: Ptr InfoProv -> IO InfoProv

module GHC.Internal.Environment

-- | Computation <a>getFullArgs</a> is the "raw" version of <a>getArgs</a>,
--   similar to <tt>argv</tt> in other languages. It returns a list of the
--   program's command line arguments, starting with the program name, and
--   including those normally eaten by the RTS (+RTS ... -RTS).
getFullArgs :: IO [String]


-- | An abstract interface to a unique symbol generator.
module GHC.Internal.Data.Unique

-- | An abstract unique object. Objects of type <a>Unique</a> may be
--   compared for equality and ordering and hashed into <a>Int</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   do x &lt;- newUnique
--      print (x == x)
--      y &lt;- newUnique
--      print (x == y)
--   :}
--   True
--   False
--   </pre>
data Unique

-- | Creates a new object of type <a>Unique</a>. The value returned will
--   not compare equal to any other value of type <a>Unique</a> returned by
--   previous calls to <a>newUnique</a>. There is no limit on the number of
--   times <a>newUnique</a> may be called.
newUnique :: IO Unique

-- | Hashes a <a>Unique</a> into an <a>Int</a>. Two <a>Unique</a>s may hash
--   to the same value, although in practice this is unlikely. The
--   <a>Int</a> returned makes a good hash key.
hashUnique :: Unique -> Int
instance GHC.Classes.Eq GHC.Internal.Data.Unique.Unique
instance GHC.Classes.Ord GHC.Internal.Data.Unique.Unique


-- | This module contains support for pooled memory management. Under this
--   scheme, (re-)allocations belong to a given pool, and everything in a
--   pool is deallocated when the pool itself is deallocated. This is
--   useful when <a>alloca</a> with its implicit allocation and
--   deallocation is not flexible enough, but explicit uses of
--   <a>malloc</a> and <tt>free</tt> are too awkward.
module GHC.Internal.Foreign.Marshal.Pool

-- | A memory pool.
data Pool

-- | Allocate a fresh memory pool.
newPool :: IO Pool

-- | Deallocate a memory pool and everything which has been allocated in
--   the pool itself.
freePool :: Pool -> IO ()

-- | Execute an action with a fresh memory pool, which gets automatically
--   deallocated (including its contents) after the action has finished.
withPool :: (Pool -> IO b) -> IO b

-- | Allocate space for storable type in the given pool. The size of the
--   area allocated is determined by the <a>sizeOf</a> method from the
--   instance of <a>Storable</a> for the appropriate type.
pooledMalloc :: Storable a => Pool -> IO (Ptr a)

-- | Allocate the given number of bytes of storage in the pool.
pooledMallocBytes :: Pool -> Int -> IO (Ptr a)

-- | Adjust the storage area for an element in the pool to the given size
--   of the required type.
pooledRealloc :: Storable a => Pool -> Ptr a -> IO (Ptr a)

-- | Adjust the storage area for an element in the pool to the given size.
--   Note that the previously allocated space is still retained in the same
--   <a>Pool</a> and will only be freed when the entire <a>Pool</a> is
--   freed.
pooledReallocBytes :: Pool -> Ptr a -> Int -> IO (Ptr a)

-- | Allocate storage for the given number of elements of a storable type
--   in the pool.
pooledMallocArray :: Storable a => Pool -> Int -> IO (Ptr a)

-- | Allocate storage for the given number of elements of a storable type
--   in the pool, but leave room for an extra element to signal the end of
--   the array.
pooledMallocArray0 :: Storable a => Pool -> Int -> IO (Ptr a)

-- | Adjust the size of an array in the given pool.
pooledReallocArray :: Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)

-- | Adjust the size of an array with an end marker in the given pool.
pooledReallocArray0 :: Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)

-- | Allocate storage for a value in the given pool and marshal the value
--   into this storage.
pooledNew :: Storable a => Pool -> a -> IO (Ptr a)

-- | Allocate consecutive storage for a list of values in the given pool
--   and marshal these values into it.
pooledNewArray :: Storable a => Pool -> [a] -> IO (Ptr a)

-- | Allocate consecutive storage for a list of values in the given pool
--   and marshal these values into it, terminating the end with the given
--   marker.
pooledNewArray0 :: Storable a => Pool -> a -> [a] -> IO (Ptr a)


-- | Marshalling support
--   
--   Safe API Only.

-- | <i>Deprecated: Safe is now the default, please use
--   GHC.Internal.Foreign.Marshal instead</i>
module GHC.Internal.Foreign.Marshal.Safe


-- | The Dynamic interface provides basic support for dynamic types.
--   
--   Operations for injecting values of arbitrary type into a dynamically
--   typed value, Dynamic, are provided, together with operations for
--   converting dynamic values into a concrete (monomorphic) type.
module GHC.Internal.Data.Dynamic

-- | A value of type <a>Dynamic</a> is an object encapsulated together with
--   its type.
--   
--   A <a>Dynamic</a> may only represent a monomorphic value; an attempt to
--   create a value of type <a>Dynamic</a> from a polymorphically-typed
--   expression will result in an ambiguity error (see <a>toDyn</a>).
--   
--   <a>Show</a>ing a value of type <a>Dynamic</a> returns a pretty-printed
--   representation of the object's type; useful for debugging.
data Dynamic
[Dynamic] :: forall a. TypeRep a -> a -> Dynamic

-- | Converts an arbitrary value into an object of type <a>Dynamic</a>.
--   
--   The type of the object must be an instance of <a>Typeable</a>, which
--   ensures that only monomorphically-typed objects may be converted to
--   <a>Dynamic</a>. To convert a polymorphic object into <a>Dynamic</a>,
--   give it a monomorphic type signature. For example:
--   
--   <pre>
--   toDyn (id :: Int -&gt; Int)
--   </pre>
toDyn :: Typeable a => a -> Dynamic

-- | Converts a <a>Dynamic</a> object back into an ordinary Haskell value
--   of the correct type. See also <a>fromDynamic</a>.
fromDyn :: Typeable a => Dynamic -> a -> a

-- | Converts a <a>Dynamic</a> object back into an ordinary Haskell value
--   of the correct type. See also <a>fromDyn</a>.
fromDynamic :: Typeable a => Dynamic -> Maybe a
dynApply :: Dynamic -> Dynamic -> Maybe Dynamic
dynApp :: Dynamic -> Dynamic -> Dynamic
dynTypeRep :: Dynamic -> SomeTypeRep

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)
instance GHC.Internal.Exception.Type.Exception GHC.Internal.Data.Dynamic.Dynamic
instance GHC.Internal.Show.Show GHC.Internal.Data.Dynamic.Dynamic


-- | Basic concurrency stuff.
module GHC.Internal.Conc.Sync

-- | A <a>ThreadId</a> is an abstract type representing a handle to a
--   thread. <a>ThreadId</a> is an instance of <a>Eq</a>, <a>Ord</a> and
--   <a>Show</a>, where the <a>Ord</a> instance implements an arbitrary
--   total ordering over <a>ThreadId</a>s. The <a>Show</a> instance lets
--   you convert an arbitrary-valued <a>ThreadId</a> to string form;
--   showing a <a>ThreadId</a> value is occasionally useful when debugging
--   or diagnosing the behaviour of a concurrent program.
--   
--   <i>Note</i>: in GHC, if you have a <a>ThreadId</a>, you essentially
--   have a pointer to the thread itself. This means the thread itself
--   can't be garbage collected until you drop the <a>ThreadId</a>. This
--   misfeature would be difficult to correct while continuing to support
--   <a>threadStatus</a>.
data ThreadId
ThreadId :: ThreadId# -> ThreadId

-- | Map a thread to an integer identifier which is unique within the
--   current process.
fromThreadId :: ThreadId -> Word64
showThreadId :: ThreadId -> String

-- | Returns the <a>ThreadId</a> of the calling thread (GHC only).
myThreadId :: IO ThreadId

-- | <a>killThread</a> raises the <a>ThreadKilled</a> exception in the
--   given thread (GHC only).
--   
--   <pre>
--   killThread tid = throwTo tid ThreadKilled
--   </pre>
killThread :: ThreadId -> IO ()

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()

-- | The <a>yield</a> action allows (forces, in a co-operative multitasking
--   implementation) a context-switch to any other currently runnable
--   threads (if any), and is occasionally useful when implementing
--   concurrency abstractions.
yield :: IO ()

-- | <a>labelThread</a> stores a string as identifier for this thread. This
--   identifier will be used in the debugging output to make distinction of
--   different threads easier (otherwise you only have the thread state
--   object's address in the heap). It also emits an event to the RTS
--   eventlog.
labelThread :: ThreadId -> String -> IO ()

-- | <a>labelThreadByteArray#</a> sets the label of a thread to the given
--   UTF-8 encoded string contained in a <a>ByteArray#</a>.
labelThreadByteArray# :: ThreadId -> ByteArray# -> IO ()

-- | Make a weak pointer to a <a>ThreadId</a>. It can be important to do
--   this if you want to hold a reference to a <a>ThreadId</a> while still
--   allowing the thread to receive the <tt>BlockedIndefinitely</tt> family
--   of exceptions (e.g. <a>BlockedIndefinitelyOnMVar</a>). Holding a
--   normal <a>ThreadId</a> reference will prevent the delivery of
--   <tt>BlockedIndefinitely</tt> exceptions because the reference could be
--   used as the target of <a>throwTo</a> at any time, which would unblock
--   the thread.
--   
--   Holding a <tt>Weak ThreadId</tt>, on the other hand, will not prevent
--   the thread from receiving <tt>BlockedIndefinitely</tt> exceptions. It
--   is still possible to throw an exception to a <tt>Weak ThreadId</tt>,
--   but the caller must use <tt>deRefWeak</tt> first to determine whether
--   the thread still exists.
mkWeakThreadId :: ThreadId -> IO (Weak ThreadId)

-- | List the Haskell threads of the current process.
listThreads :: IO [ThreadId]

-- | Query the label of thread, returning <a>Nothing</a> if the thread's
--   label has not been set.
threadLabel :: ThreadId -> IO (Maybe String)

-- | The current status of a thread
data ThreadStatus

-- | the thread is currently runnable or running
ThreadRunning :: ThreadStatus

-- | the thread has finished
ThreadFinished :: ThreadStatus

-- | the thread is blocked on some resource
ThreadBlocked :: BlockReason -> ThreadStatus

-- | the thread received an uncaught exception
ThreadDied :: ThreadStatus
data BlockReason

-- | blocked on <a>MVar</a>
BlockedOnMVar :: BlockReason

-- | blocked on a computation in progress by another thread
BlockedOnBlackHole :: BlockReason

-- | blocked in <a>throwTo</a>
BlockedOnException :: BlockReason

-- | blocked in <a>retry</a> in an STM transaction
BlockedOnSTM :: BlockReason

-- | currently in a foreign call
BlockedOnForeignCall :: BlockReason

-- | blocked on some other resource. Without <tt>-threaded</tt>, I/O and
--   <a>threadDelay</a> show up as <a>BlockedOnOther</a>, with
--   <tt>-threaded</tt> they show up as <a>BlockedOnMVar</a>.
BlockedOnOther :: BlockReason

-- | Query the current execution status of a thread.
threadStatus :: ThreadId -> IO ThreadStatus

-- | Returns the number of the capability on which the thread is currently
--   running, and a boolean indicating whether the thread is locked to that
--   capability or not. A thread is locked to a capability if it was
--   created with <tt>forkOn</tt>.
threadCapability :: ThreadId -> IO (Int, Bool)

-- | Creates a new thread to run the <a>IO</a> computation passed as the
--   first argument, and returns the <a>ThreadId</a> of the newly created
--   thread.
--   
--   The new thread will be a lightweight, <i>unbound</i> thread. Foreign
--   calls made by this thread are not guaranteed to be made by any
--   particular OS thread; if you need foreign calls to be made by a
--   particular OS thread, then use <a>forkOS</a> instead.
--   
--   The new thread inherits the <i>masked</i> state of the parent (see
--   <a>mask</a>).
--   
--   The newly created thread has an exception handler that discards the
--   exceptions <a>BlockedIndefinitelyOnMVar</a>,
--   <a>BlockedIndefinitelyOnSTM</a>, and <a>ThreadKilled</a>, and passes
--   all other exceptions to the uncaught exception handler.
--   
--   WARNING: Exceptions in the new thread will not be rethrown in the
--   thread that created it. This means that you might be completely
--   unaware of the problem if/when this happens. You may want to use the
--   <a>async</a> library instead.
forkIO :: IO () -> IO ThreadId

-- | Like <a>forkIO</a>, but the child thread is passed a function that can
--   be used to unmask asynchronous exceptions. This function is typically
--   used in the following way
--   
--   <pre>
--   ... mask_ $ forkIOWithUnmask $ \unmask -&gt;
--                  catch (unmask ...) handler
--   </pre>
--   
--   so that the exception handler in the child thread is established with
--   asynchronous exceptions masked, meanwhile the main body of the child
--   thread is executed in the unmasked state.
--   
--   Note that the unmask function passed to the child thread should only
--   be used in that thread; the behaviour is undefined if it is invoked in
--   a different thread.
forkIOWithUnmask :: ((forall a. () => IO a -> IO a) -> IO ()) -> IO ThreadId

-- | Like <a>forkIO</a>, but lets you specify on which capability the
--   thread should run. Unlike a <a>forkIO</a> thread, a thread created by
--   <a>forkOn</a> will stay on the same capability for its entire lifetime
--   (<a>forkIO</a> threads can migrate between capabilities according to
--   the scheduling policy). <a>forkOn</a> is useful for overriding the
--   scheduling policy when you know in advance how best to distribute the
--   threads.
--   
--   The <a>Int</a> argument specifies a <i>capability number</i> (see
--   <a>getNumCapabilities</a>). Typically capabilities correspond to
--   physical processors, but the exact behaviour is
--   implementation-dependent. The value passed to <a>forkOn</a> is
--   interpreted modulo the total number of capabilities as returned by
--   <a>getNumCapabilities</a>.
--   
--   GHC note: the number of capabilities is specified by the <tt>+RTS
--   -N</tt> option when the program is started. Capabilities can be fixed
--   to actual processor cores with <tt>+RTS -qa</tt> if the underlying
--   operating system supports that, although in practice this is usually
--   unnecessary (and may actually degrade performance in some cases -
--   experimentation is recommended).
forkOn :: Int -> IO () -> IO ThreadId

-- | Like <a>forkIOWithUnmask</a>, but the child thread is pinned to the
--   given CPU, as with <a>forkOn</a>.
forkOnWithUnmask :: Int -> ((forall a. () => IO a -> IO a) -> IO ()) -> IO ThreadId

-- | the value passed to the <tt>+RTS -N</tt> flag. This is the number of
--   Haskell threads that can run truly simultaneously at any given time,
--   and is typically set to the number of physical processor cores on the
--   machine.
--   
--   Strictly speaking it is better to use <a>getNumCapabilities</a>,
--   because the number of capabilities might vary at runtime.
numCapabilities :: Int

-- | Returns the number of Haskell threads that can run truly
--   simultaneously (on separate physical processors) at any given time. To
--   change this value, use <a>setNumCapabilities</a>.
getNumCapabilities :: IO Int

-- | Set the number of Haskell threads that can run truly simultaneously
--   (on separate physical processors) at any given time. The number passed
--   to <a>forkOn</a> is interpreted modulo this value. The initial value
--   is given by the <tt>+RTS -N</tt> runtime flag.
--   
--   This is also the number of threads that will participate in parallel
--   garbage collection. It is strongly recommended that the number of
--   capabilities is not set larger than the number of physical processor
--   cores, and it may often be beneficial to leave one or more cores free
--   to avoid contention with other processes in the machine.
setNumCapabilities :: Int -> IO ()

-- | Returns the number of CPUs that the machine has
getNumProcessors :: IO Int

-- | Returns the number of sparks currently in the local spark pool
numSparks :: IO Int
childHandler :: SomeException -> IO ()
par :: a -> b -> b
infixr 0 `par`
pseq :: a -> b -> b
infixr 0 `pseq`

-- | Internal function used by the RTS to run sparks.
runSparks :: IO ()

-- | Make a <a>StablePtr</a> that can be passed to the C function
--   <tt>hs_try_putmvar()</tt>. The RTS wants a <a>StablePtr</a> to the
--   underlying <a>MVar#</a>, but a <a>StablePtr#</a> can only refer to
--   lifted types, so we have to cheat by coercing.
newStablePtrPrimMVar :: MVar a -> IO (StablePtr PrimMVar)
data PrimMVar

-- | Every thread has an allocation counter that tracks how much memory has
--   been allocated by the thread. The counter is initialized to zero, and
--   <a>setAllocationCounter</a> sets the current value. The allocation
--   counter counts *down*, so in the absence of a call to
--   <a>setAllocationCounter</a> its value is the negation of the number of
--   bytes of memory allocated by the thread.
--   
--   There are two things that you can do with this counter:
--   
--   <ul>
--   <li>Use it as a simple profiling mechanism, with
--   <a>getAllocationCounter</a>.</li>
--   <li>Use it as a resource limit. See <a>enableAllocationLimit</a>.</li>
--   </ul>
--   
--   Allocation accounting is accurate only to about 4Kbytes.
setAllocationCounter :: Int64 -> IO ()

-- | Return the current value of the allocation counter for the current
--   thread.
getAllocationCounter :: IO Int64

-- | Enables the allocation counter to be treated as a limit for the
--   current thread. When the allocation limit is enabled, if the
--   allocation counter counts down below zero, the thread will be sent the
--   <a>AllocationLimitExceeded</a> asynchronous exception. When this
--   happens, the counter is reinitialised (by default to 100K, but tunable
--   with the <tt>+RTS -xq</tt> option) so that it can handle the exception
--   and perform any necessary clean up. If it exhausts this additional
--   allowance, another <a>AllocationLimitExceeded</a> exception is sent,
--   and so forth. Like other asynchronous exceptions, the
--   <a>AllocationLimitExceeded</a> exception is deferred while the thread
--   is inside <a>mask</a> or an exception handler in <a>catch</a>.
--   
--   Note that memory allocation is unrelated to <i>live memory</i>, also
--   known as <i>heap residency</i>. A thread can allocate a large amount
--   of memory and retain anything between none and all of it. It is better
--   to think of the allocation limit as a limit on <i>CPU time</i>, rather
--   than a limit on memory.
--   
--   Compared to using timeouts, allocation limits don't count time spent
--   blocked or in foreign calls.
enableAllocationLimit :: IO ()

-- | Disable allocation limit processing for the current thread.
disableAllocationLimit :: IO ()

-- | A monad supporting atomic memory transactions.
newtype STM a
STM :: (State# RealWorld -> (# State# RealWorld, a #)) -> STM a

-- | Perform a series of STM actions atomically.
--   
--   Using <a>atomically</a> inside an <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a> subverts some of guarantees that STM
--   provides. It makes it possible to run a transaction inside of another
--   transaction, depending on when the thunk is evaluated. If a nested
--   transaction is attempted, an exception is thrown by the runtime. It is
--   possible to safely use <a>atomically</a> inside <a>unsafePerformIO</a>
--   or <a>unsafeInterleaveIO</a>, but the typechecker does not rule out
--   programs that may attempt nested transactions, meaning that the
--   programmer must take special care to prevent these.
--   
--   However, there are functions for creating transactional variables that
--   can always be safely called in <a>unsafePerformIO</a>. See:
--   <a>newTVarIO</a>, <a>newTChanIO</a>, <a>newBroadcastTChanIO</a>,
--   <a>newTQueueIO</a>, <a>newTBQueueIO</a>, and <a>newTMVarIO</a>.
--   
--   Using <a>unsafePerformIO</a> inside of <a>atomically</a> is also
--   dangerous but for different reasons. See <a>unsafeIOToSTM</a> for more
--   on this.
atomically :: STM a -> IO a

-- | Retry execution of the current memory transaction because it has seen
--   values in <a>TVar</a>s which mean that it should not continue (e.g.
--   the <a>TVar</a>s represent a shared buffer that is now empty). The
--   implementation may block the thread until one of the <a>TVar</a>s that
--   it has read from has been updated. (GHC only)
retry :: STM a

-- | Compose two alternative STM actions (GHC only).
--   
--   If the first action completes without retrying then it forms the
--   result of the <a>orElse</a>. Otherwise, if the first action retries,
--   then the second action is tried in its place. If both actions retry
--   then the <a>orElse</a> as a whole retries.
orElse :: STM a -> STM a -> STM a

-- | A variant of <a>throw</a> that can only be used within the <a>STM</a>
--   monad.
--   
--   Throwing an exception in <tt>STM</tt> aborts the transaction and
--   propagates the exception. If the exception is caught via
--   <a>catchSTM</a>, only the changes enclosed by the catch are rolled
--   back; changes made outside of <a>catchSTM</a> persist.
--   
--   If the exception is not caught inside of the <a>STM</a>, it is
--   re-thrown by <a>atomically</a>, and the entire <a>STM</a> is rolled
--   back.
--   
--   Although <a>throwSTM</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e    `seq` x  ===&gt; throw e
--   throwSTM e `seq` x  ===&gt; x
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwSTM</a> will only cause
--   an exception to be raised when it is used within the <a>STM</a> monad.
--   The <a>throwSTM</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>STM</a> monad because
--   it guarantees ordering with respect to other <a>STM</a> operations,
--   whereas <a>throw</a> does not.
throwSTM :: Exception e => e -> STM a

-- | Exception handling within STM actions.
--   
--   <tt><a>catchSTM</a> m f</tt> catches any exception thrown by
--   <tt>m</tt> using <a>throwSTM</a>, using the function <tt>f</tt> to
--   handle the exception. If an exception is thrown, any changes made by
--   <tt>m</tt> are rolled back, but changes prior to <tt>m</tt> persist.
catchSTM :: Exception e => STM a -> (e -> STM a) -> STM a

-- | Shared memory locations that support atomic memory transactions.
data TVar a
TVar :: TVar# RealWorld a -> TVar a

-- | Create a new <a>TVar</a> holding a value supplied
newTVar :: a -> STM (TVar a)

-- | <tt>IO</tt> version of <a>newTVar</a>. This is useful for creating
--   top-level <a>TVar</a>s using <a>unsafePerformIO</a>, because using
--   <a>atomically</a> inside <a>unsafePerformIO</a> isn't possible.
newTVarIO :: a -> IO (TVar a)

-- | Return the current value stored in a <a>TVar</a>.
readTVar :: TVar a -> STM a

-- | Return the current value stored in a <a>TVar</a>. This is equivalent
--   to
--   
--   <pre>
--   readTVarIO = atomically . readTVar
--   </pre>
--   
--   but works much faster, because it doesn't perform a complete
--   transaction, it just reads the current value of the <a>TVar</a>.
readTVarIO :: TVar a -> IO a

-- | Write the supplied value into a <a>TVar</a>.
writeTVar :: TVar a -> a -> STM ()

-- | Unsafely performs IO in the STM monad. Beware: this is a highly
--   dangerous thing to do.
--   
--   <ul>
--   <li>The STM implementation will often run transactions multiple times,
--   so you need to be prepared for this if your IO has any side
--   effects.</li>
--   <li>The STM implementation will abort transactions that are known to
--   be invalid and need to be restarted. This may happen in the middle of
--   <a>unsafeIOToSTM</a>, so make sure you don't acquire any resources
--   that need releasing (exception handlers are ignored when aborting the
--   transaction). That includes doing any IO using Handles, for example.
--   Getting this wrong will probably lead to random deadlocks.</li>
--   <li>The transaction may have seen an inconsistent view of memory when
--   the IO runs. Invariants that you expect to be true throughout your
--   program may not be true inside a transaction, due to the way
--   transactions are implemented. Normally this wouldn't be visible to the
--   programmer, but using <a>unsafeIOToSTM</a> can expose it.</li>
--   </ul>
unsafeIOToSTM :: IO a -> STM a

-- | Provide an <a>IO</a> action with the current value of an <a>MVar</a>.
--   The <a>MVar</a> will be empty for the duration that the action is
--   running.
withMVar :: MVar a -> (a -> IO b) -> IO b

-- | Modify the value of an <a>MVar</a>.
modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
setUncaughtExceptionHandler :: (SomeException -> IO ()) -> IO ()
getUncaughtExceptionHandler :: IO (SomeException -> IO ())
reportError :: SomeException -> IO ()
reportStackOverflow :: IO ()
reportHeapOverflow :: IO ()
sharedCAF :: a -> (Ptr a -> IO (Ptr a)) -> IO a
instance GHC.Internal.Base.Alternative GHC.Internal.Conc.Sync.STM
instance GHC.Internal.Base.Applicative GHC.Internal.Conc.Sync.STM
instance GHC.Classes.Eq GHC.Internal.Conc.Sync.BlockReason
instance GHC.Classes.Eq (GHC.Internal.Conc.Sync.TVar a)
instance GHC.Classes.Eq GHC.Internal.Conc.Sync.ThreadId
instance GHC.Classes.Eq GHC.Internal.Conc.Sync.ThreadStatus
instance GHC.Internal.Base.Functor GHC.Internal.Conc.Sync.STM
instance GHC.Internal.Base.MonadPlus GHC.Internal.Conc.Sync.STM
instance GHC.Internal.Base.Monad GHC.Internal.Conc.Sync.STM
instance GHC.Internal.Base.Monoid a => GHC.Internal.Base.Monoid (GHC.Internal.Conc.Sync.STM a)
instance GHC.Classes.Ord GHC.Internal.Conc.Sync.BlockReason
instance GHC.Classes.Ord GHC.Internal.Conc.Sync.ThreadId
instance GHC.Classes.Ord GHC.Internal.Conc.Sync.ThreadStatus
instance GHC.Internal.Base.Semigroup a => GHC.Internal.Base.Semigroup (GHC.Internal.Conc.Sync.STM a)
instance GHC.Internal.Show.Show GHC.Internal.Conc.Sync.BlockReason
instance GHC.Internal.Show.Show GHC.Internal.Conc.Sync.ThreadId
instance GHC.Internal.Show.Show GHC.Internal.Conc.Sync.ThreadStatus


-- | Memory-related system things.
module GHC.Internal.System.Mem

-- | Triggers an immediate major garbage collection.
performGC :: IO ()

-- | Triggers an immediate major garbage collection.
performMajorGC :: IO ()

-- | Triggers an immediate major garbage collection, ensuring that
--   collection finishes before returning.
performBlockingMajorGC :: IO ()

-- | Triggers an immediate minor garbage collection.
performMinorGC :: IO ()

-- | Every thread has an allocation counter that tracks how much memory has
--   been allocated by the thread. The counter is initialized to zero, and
--   <a>setAllocationCounter</a> sets the current value. The allocation
--   counter counts *down*, so in the absence of a call to
--   <a>setAllocationCounter</a> its value is the negation of the number of
--   bytes of memory allocated by the thread.
--   
--   There are two things that you can do with this counter:
--   
--   <ul>
--   <li>Use it as a simple profiling mechanism, with
--   <a>getAllocationCounter</a>.</li>
--   <li>Use it as a resource limit. See <a>enableAllocationLimit</a>.</li>
--   </ul>
--   
--   Allocation accounting is accurate only to about 4Kbytes.
setAllocationCounter :: Int64 -> IO ()

-- | Return the current value of the allocation counter for the current
--   thread.
getAllocationCounter :: IO Int64

-- | Enables the allocation counter to be treated as a limit for the
--   current thread. When the allocation limit is enabled, if the
--   allocation counter counts down below zero, the thread will be sent the
--   <a>AllocationLimitExceeded</a> asynchronous exception. When this
--   happens, the counter is reinitialised (by default to 100K, but tunable
--   with the <tt>+RTS -xq</tt> option) so that it can handle the exception
--   and perform any necessary clean up. If it exhausts this additional
--   allowance, another <a>AllocationLimitExceeded</a> exception is sent,
--   and so forth. Like other asynchronous exceptions, the
--   <a>AllocationLimitExceeded</a> exception is deferred while the thread
--   is inside <a>mask</a> or an exception handler in <a>catch</a>.
--   
--   Note that memory allocation is unrelated to <i>live memory</i>, also
--   known as <i>heap residency</i>. A thread can allocate a large amount
--   of memory and retain anything between none and all of it. It is better
--   to think of the allocation limit as a limit on <i>CPU time</i>, rather
--   than a limit on memory.
--   
--   Compared to using timeouts, allocation limits don't count time spent
--   blocked or in foreign calls.
enableAllocationLimit :: IO ()

-- | Disable allocation limit processing for the current thread.
disableAllocationLimit :: IO ()


-- | This module exposes an interface for capturing the state of a thread's
--   execution stack for diagnostics purposes: <a>cloneMyStack</a>,
--   <a>cloneThreadStack</a>.
--   
--   Such a "cloned" stack can be decoded with <a>decode</a> to a stack
--   trace, given that the <tt>-finfo-table-map</tt> is enabled.
module GHC.Internal.Stack.CloneStack

-- | A frozen snapshot of the state of an execution stack.
data StackSnapshot
StackSnapshot :: !StackSnapshot# -> StackSnapshot

-- | Representation for the source location where a return frame was pushed
--   on the stack. This happens every time when a <tt>case ... of</tt>
--   scrutinee is evaluated.
data StackEntry
StackEntry :: String -> String -> String -> ClosureType -> StackEntry
[functionName] :: StackEntry -> String
[moduleName] :: StackEntry -> String
[srcLoc] :: StackEntry -> String
[closureType] :: StackEntry -> ClosureType

-- | Clone the stack of the executing thread
cloneMyStack :: IO StackSnapshot

-- | Clone the stack of a thread identified by its <a>ThreadId</a>
cloneThreadStack :: ThreadId -> IO StackSnapshot

-- | Decode a <a>StackSnapshot</a> to a stacktrace (a list of
--   <a>StackEntry</a>). The stack trace is created from return frames with
--   according <tt>InfoProvEnt</tt> entries. To generate them, use the GHC
--   flag <tt>-finfo-table-map</tt>. If there are no <tt>InfoProvEnt</tt>
--   entries, an empty list is returned.
--   
--   Please note:
--   
--   <ul>
--   <li>To gather <a>StackEntry</a> from libraries, these have to be
--   compiled with <tt>-finfo-table-map</tt>, too.</li>
--   <li>Due to optimizations by GHC (e.g. inlining) the stacktrace may
--   change with different GHC parameters and versions.</li>
--   <li>The stack trace is empty (by design) if there are no return frames
--   on the stack. (These are pushed every time when a <tt>case ... of</tt>
--   scrutinee is evaluated.)</li>
--   </ul>
decode :: StackSnapshot -> IO [StackEntry]
prettyStackEntry :: StackEntry -> String
instance GHC.Classes.Eq GHC.Internal.Stack.CloneStack.StackEntry
instance GHC.Internal.Show.Show GHC.Internal.Stack.CloneStack.StackEntry


-- | This module defines the basic operations on I/O "handles". All of the
--   operations defined here are independent of the underlying device.
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.IO.Handle.Internals
withHandle :: String -> Handle -> (Handle__ -> IO (Handle__, a)) -> IO a
withHandle' :: String -> Handle -> MVar Handle__ -> (Handle__ -> IO (Handle__, a)) -> IO a
withHandle_ :: String -> Handle -> (Handle__ -> IO a) -> IO a
withHandle__' :: String -> Handle -> MVar Handle__ -> (Handle__ -> IO Handle__) -> IO ()
withHandle_' :: String -> Handle -> MVar Handle__ -> (Handle__ -> IO a) -> IO a
withAllHandles__ :: String -> Handle -> (Handle__ -> IO Handle__) -> IO ()
wantWritableHandle :: String -> Handle -> (Handle__ -> IO a) -> IO a
wantReadableHandle :: String -> Handle -> (Handle__ -> IO (Handle__, a)) -> IO a
wantReadableHandle_ :: String -> Handle -> (Handle__ -> IO a) -> IO a
wantSeekableHandle :: String -> Handle -> (Handle__ -> IO a) -> IO a
mkHandle :: (RawIO dev, IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> HandleType -> Bool -> Maybe TextEncoding -> NewlineMode -> Maybe HandleFinalizer -> Maybe (MVar Handle__) -> IO Handle

-- | makes a new <a>Handle</a>
mkFileHandle :: (RawIO dev, IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> IOMode -> Maybe TextEncoding -> NewlineMode -> IO Handle

-- | makes a new <a>Handle</a> without a finalizer.
mkFileHandleNoFinalizer :: (RawIO dev, IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> IOMode -> Maybe TextEncoding -> NewlineMode -> IO Handle

-- | like <a>mkFileHandle</a>, except that a <a>Handle</a> is created with
--   two independent buffers, one for reading and one for writing. Used for
--   full-duplex streams, such as network sockets.
mkDuplexHandle :: (RawIO dev, IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> Maybe TextEncoding -> NewlineMode -> IO Handle

-- | like <a>mkFileHandle</a>, except that a <a>Handle</a> is created with
--   two independent buffers, one for reading and one for writing. Used for
--   full-duplex streams, such as network sockets.
mkDuplexHandleNoFinalizer :: (RawIO dev, IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> Maybe TextEncoding -> NewlineMode -> IO Handle

-- | Add a finalizer to a <a>Handle</a>. Specifically, the finalizer will
--   be added to the <a>MVar</a> of a file handle or the write-side
--   <a>MVar</a> of a duplex handle. See Handle Finalizers for details.
addHandleFinalizer :: Handle -> HandleFinalizer -> IO ()
openTextEncoding :: Maybe TextEncoding -> HandleType -> (forall es ds. () => Maybe (TextEncoder es) -> Maybe (TextDecoder ds) -> IO a) -> IO a
closeTextCodecs :: Handle__ -> IO ()
initBufferState :: HandleType -> BufferState
dEFAULT_CHAR_BUFFER_SIZE :: Int

-- | syncs the file with the buffer, including moving the file pointer
--   backwards in the case of a read buffer. This can fail on a
--   non-seekable read Handle.
flushBuffer :: Handle__ -> IO ()
flushWriteBuffer :: Handle__ -> IO ()
flushCharReadBuffer :: Handle__ -> IO ()

-- | flushes the Char buffer only. Works on all Handles.
flushCharBuffer :: Handle__ -> IO ()
flushByteReadBuffer :: Handle__ -> IO ()
flushByteWriteBuffer :: Handle__ -> IO ()
readTextDevice :: Handle__ -> CharBuffer -> IO CharBuffer
writeCharBuffer :: Handle__ -> CharBuffer -> IO ()
readTextDeviceNonBlocking :: Handle__ -> CharBuffer -> IO CharBuffer
decodeByteBuf :: Handle__ -> CharBuffer -> IO CharBuffer
augmentIOError :: IOException -> String -> Handle -> IOException
ioe_closedHandle :: IO a
ioe_semiclosedHandle :: IO a
ioe_EOF :: IO a
ioe_notReadable :: IO a
ioe_notWritable :: IO a
ioe_finalizedHandle :: FilePath -> Handle__
ioe_bufsiz :: Int -> IO a

-- | This function exists temporarily to avoid an unused import warning in
--   <tt>bytestring</tt>.
hClose_impl :: Handle -> IO ()
hClose_help :: Handle__ -> IO (Handle__, Maybe SomeException)
hLookAhead_ :: Handle__ -> IO Char
type HandleFinalizer = FilePath -> MVar Handle__ -> IO ()
handleFinalizer :: FilePath -> MVar Handle__ -> IO ()
debugIO :: String -> IO ()
traceIO :: String -> IO ()


-- | Extensible exceptions, except for multiple handlers.
module GHC.Internal.Control.Exception.Base

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException
SomeException :: e -> SomeException

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e

-- | <tt>toException</tt> should produce a <a>SomeException</a> with no
--   attached <a>ExceptionContext</a>.
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

backtraceDesired :: Exception e => e -> Bool

-- | Exceptions that occur in the <tt>IO</tt> monad. An
--   <tt>IOException</tt> records a more specific error type, a descriptive
--   string and maybe the handle that was used when the error was flagged.
data IOException

-- | Arithmetic exceptions.
data ArithException
Overflow :: ArithException
Underflow :: ArithException
LossOfPrecision :: ArithException
DivideByZero :: ArithException
Denormal :: ArithException

RatioZeroDenominator :: ArithException

-- | Exceptions generated by array operations
data ArrayException

-- | An attempt was made to index an array outside its declared bounds.
IndexOutOfBounds :: String -> ArrayException

-- | An attempt was made to evaluate an element of an array that had not
--   been initialized.
UndefinedElement :: String -> ArrayException

-- | <a>assert</a> was applied to <a>False</a>.
newtype AssertionFailed
AssertionFailed :: String -> AssertionFailed

-- | Superclass for asynchronous exceptions.
data SomeAsyncException
SomeAsyncException :: e -> SomeAsyncException

-- | Asynchronous exceptions.
data AsyncException

-- | The current thread's stack exceeded its limit. Since an exception has
--   been raised, the thread's stack will certainly be below its limit
--   again, but the programmer should take remedial action immediately.
StackOverflow :: AsyncException

-- | The program's heap is reaching its limit, and the program should take
--   action to reduce the amount of live data it has. Notes:
--   
--   <ul>
--   <li>It is undefined which thread receives this exception. GHC
--   currently throws this to the same thread that receives
--   <a>UserInterrupt</a>, but this may change in the future.</li>
--   <li>The GHC RTS currently can only recover from heap overflow if it
--   detects that an explicit memory limit (set via RTS flags). has been
--   exceeded. Currently, failure to allocate memory from the operating
--   system results in immediate termination of the program.</li>
--   </ul>
HeapOverflow :: AsyncException

-- | This exception is raised by another thread calling <a>killThread</a>,
--   or by the system if it needs to terminate the thread for some reason.
ThreadKilled :: AsyncException

-- | This exception is raised by default in the main thread of the program
--   when the user requests to terminate the program via the usual
--   mechanism(s) (e.g. Control-C in the console).
UserInterrupt :: AsyncException

asyncExceptionToException :: Exception e => e -> SomeException

asyncExceptionFromException :: Exception e => SomeException -> Maybe e

-- | Thrown when the runtime system detects that the computation is
--   guaranteed not to terminate. Note that there is no guarantee that the
--   runtime system will notice whether any given computation is guaranteed
--   to terminate or not.
data NonTermination
NonTermination :: NonTermination

-- | Thrown when the program attempts to call <tt>atomically</tt>, from the
--   <tt>stm</tt> package, inside another call to <tt>atomically</tt>.
data NestedAtomically
NestedAtomically :: NestedAtomically

-- | The thread is blocked on an <tt>MVar</tt>, but there are no other
--   references to the <tt>MVar</tt> so it can't ever continue.
data BlockedIndefinitelyOnMVar
BlockedIndefinitelyOnMVar :: BlockedIndefinitelyOnMVar

-- | The exception thrown when an infinite cycle is detected in
--   <a>fixIO</a>.
data FixIOException
FixIOException :: FixIOException

-- | The thread is waiting to retry an STM transaction, but there are no
--   other references to any <tt>TVar</tt>s involved, so it can't ever
--   continue.
data BlockedIndefinitelyOnSTM
BlockedIndefinitelyOnSTM :: BlockedIndefinitelyOnSTM

-- | This thread has exceeded its allocation limit. See
--   <a>setAllocationCounter</a> and <a>enableAllocationLimit</a>.
data AllocationLimitExceeded
AllocationLimitExceeded :: AllocationLimitExceeded

-- | Compaction found an object that cannot be compacted. Functions cannot
--   be compacted, nor can mutable objects or pinned objects. See
--   <a>compact</a>.
newtype CompactionFailed
CompactionFailed :: String -> CompactionFailed

-- | There are no runnable threads, so the program is deadlocked. The
--   <tt>Deadlock</tt> exception is raised in the main thread only.
data Deadlock
Deadlock :: Deadlock

-- | A class method without a definition (neither a default definition, nor
--   a definition in the appropriate instance) was called. The
--   <tt>String</tt> gives information about which method it was.
newtype NoMethodError
NoMethodError :: String -> NoMethodError

-- | A pattern match failed. The <tt>String</tt> gives information about
--   the source location of the pattern.
newtype PatternMatchFail
PatternMatchFail :: String -> PatternMatchFail

-- | An uninitialised record field was used. The <tt>String</tt> gives
--   information about the source location where the record was
--   constructed.
newtype RecConError
RecConError :: String -> RecConError

-- | A record selector was applied to a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another. The <tt>String</tt> gives information about the source
--   location of the record selector.
newtype RecSelError
RecSelError :: String -> RecSelError

-- | A record update was performed on a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another. The <tt>String</tt> gives information about the source
--   location of the record update.
newtype RecUpdError
RecUpdError :: String -> RecUpdError

-- | This is thrown when the user calls <a>error</a>. The <tt>String</tt>
--   is the argument given to <a>error</a>.
--   
--   Historically, there was a second <tt>String</tt> for the location, but
--   it was subsumed by the backtrace mechanisms (since base-4.22).
data ErrorCall
ErrorCall :: String -> ErrorCall

-- | <i>Deprecated: ErrorCallWithLocation has been deprecated in favour of
--   ErrorCall (which does not have a location). Backtraces are now handled
--   by the backtrace exception mechanisms exclusively.</i>
pattern ErrorCallWithLocation :: String -> String -> ErrorCall

-- | An expression that didn't typecheck during compile time was called.
--   This is only possible with -fdefer-type-errors. The <tt>String</tt>
--   gives details about the failed type check.
newtype TypeError
TypeError :: String -> TypeError

-- | Thrown when the program attempts a continuation capture, but no prompt
--   with the given prompt tag exists in the current continuation.
data NoMatchingContinuationPrompt
NoMatchingContinuationPrompt :: NoMatchingContinuationPrompt

-- | A variant of <a>throw</a> that can only be used within the <a>IO</a>
--   monad.
--   
--   Although <a>throwIO</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e   `seq` ()  ===&gt; throw e
--   throwIO e `seq` ()  ===&gt; ()
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwIO</a> will only cause
--   an exception to be raised when it is used within the <a>IO</a> monad.
--   
--   The <a>throwIO</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>IO</a> monad because
--   it guarantees ordering with respect to other operations, whereas
--   <a>throw</a> does not. We say that <a>throwIO</a> throws *precise*
--   exceptions and <a>throw</a>, <a>error</a>, etc. all throw *imprecise*
--   exceptions. For example
--   
--   <pre>
--   throw e + error "boom" ===&gt; error "boom"
--   throw e + error "boom" ===&gt; throw e
--   </pre>
--   
--   are both valid reductions and the compiler may pick any (loop, even),
--   whereas
--   
--   <pre>
--   throwIO e &gt;&gt; error "boom" ===&gt; throwIO e
--   </pre>
--   
--   will always throw <tt>e</tt> when executed.
--   
--   See also the <a>GHC wiki page on precise exceptions</a> for a more
--   technical introduction to how GHC optimises around precise vs.
--   imprecise exceptions.
throwIO :: (HasCallStack, Exception e) => e -> IO a

-- | A utility to use when rethrowing exceptions, no new backtrace will be
--   attached when rethrowing an exception but you must supply the existing
--   context.
rethrowIO :: Exception e => ExceptionWithContext e -> IO a

-- | Throw an exception. Exceptions may be thrown from purely functional
--   code, but may only be caught within the <a>IO</a> monad.
--   
--   WARNING: You may want to use <tt>throwIO</tt> instead so that your
--   pure code stays exception-free.
throw :: forall a e. (HasCallStack, Exception e) => e -> a

-- | Raise an <a>IOError</a> in the <a>IO</a> monad.
ioError :: HasCallStack => IOError -> IO a

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()

-- | This is the simplest of the exception-catching functions. It takes a
--   single argument, runs it, and if an exception is raised the "handler"
--   is executed, with the value of the exception passed as an argument.
--   Otherwise, the result is returned as normal. For example:
--   
--   <pre>
--   catch (readFile f)
--         (\e -&gt; do let err = show (e :: IOException)
--                   hPutStr stderr ("Warning: Couldn't open " ++ f ++ ": " ++ err)
--                   return "")
--   </pre>
--   
--   Note that we have to give a type signature to <tt>e</tt>, or the
--   program will not typecheck as the type is ambiguous. While it is
--   possible to catch exceptions of any type, see the section "Catching
--   all exceptions" (in <a>Control.Exception</a>) for an explanation of
--   the problems with doing so.
--   
--   For catching exceptions in pure (non-<a>IO</a>) expressions, see the
--   function <a>evaluate</a>.
--   
--   Note that due to Haskell's unspecified evaluation order, an expression
--   may throw one of several possible exceptions: consider the expression
--   <tt>(error "urk") + (1 `div` 0)</tt>. Does the expression throw
--   <tt>ErrorCall "urk"</tt>, or <tt>DivideByZero</tt>?
--   
--   The answer is "it might throw either"; the choice is
--   non-deterministic. If you are catching any type of exception then you
--   might catch either. If you are calling <tt>catch</tt> with type <tt>IO
--   Int -&gt; (ArithException -&gt; IO Int) -&gt; IO Int</tt> then the
--   handler may get run with <tt>DivideByZero</tt> as an argument, or an
--   <tt>ErrorCall "urk"</tt> exception may be propagated further up. If
--   you call it again, you might get the opposite behaviour. This is ok,
--   because <a>catch</a> is an <a>IO</a> computation.
catch :: Exception e => IO a -> (e -> IO a) -> IO a

-- | A variant of <a>catch</a> which doesn't annotate the handler with the
--   exception which was caught. This function should be used when you are
--   implementing your own error handling functions which may rethrow the
--   exceptions.
--   
--   In the case where you rethrow an exception without modifying it, you
--   should rethrow the exception with the old exception context.
catchNoPropagate :: Exception e => IO a -> (ExceptionWithContext e -> IO a) -> IO a

-- | The function <a>catchJust</a> is like <a>catch</a>, but it takes an
--   extra argument which is an <i>exception predicate</i>, a function
--   which selects which type of exceptions we're interested in.
--   
--   <pre>
--   catchJust (\e -&gt; if isDoesNotExistErrorType (ioeGetErrorType e) then Just () else Nothing)
--             (readFile f)
--             (\_ -&gt; do hPutStrLn stderr ("No such file: " ++ show f)
--                       return "")
--   </pre>
--   
--   Any other exceptions which are not matched by the predicate are
--   re-raised, and may be caught by an enclosing <a>catch</a>,
--   <a>catchJust</a>, etc.
catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a

-- | A version of <a>catch</a> with the arguments swapped around; useful in
--   situations where the code for the handler is shorter. For example:
--   
--   <pre>
--   do handle (\NonTermination -&gt; exitWith (ExitFailure 1)) $
--      ...
--   </pre>
handle :: Exception e => (e -> IO a) -> IO a -> IO a

-- | A version of <a>catchJust</a> with the arguments swapped around (see
--   <a>handle</a>).
handleJust :: Exception e => (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a

-- | Similar to <a>catch</a>, but returns an <a>Either</a> result which is
--   <tt>(<a>Right</a> a)</tt> if no exception of type <tt>e</tt> was
--   raised, or <tt>(<a>Left</a> ex)</tt> if an exception of type
--   <tt>e</tt> was raised and its value is <tt>ex</tt>. If any other type
--   of exception is raised then it will be propagated up to the next
--   enclosing exception handler.
--   
--   <pre>
--   try a = catch (Right `liftM` a) (return . Left)
--   </pre>
try :: Exception e => IO a -> IO (Either e a)

-- | Like <a>try</a> but also returns the exception context, which is
--   useful if you intend to rethrow the exception later.
tryWithContext :: Exception e => IO a -> IO (Either (ExceptionWithContext e) a)

-- | A variant of <a>try</a> that takes an exception predicate to select
--   which exceptions are caught (c.f. <a>catchJust</a>). If the exception
--   does not match the predicate, it is re-thrown.
tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)

-- | Like <a>finally</a>, but only performs the final action if there was
--   an exception raised by the computation.
onException :: IO a -> IO b -> IO a

-- | Evaluate the argument to weak head normal form.
--   
--   <a>evaluate</a> is typically used to uncover any exceptions that a
--   lazy value may contain, and possibly handle them.
--   
--   <a>evaluate</a> only evaluates to <i>weak head normal form</i>. If
--   deeper evaluation is needed, the <tt>force</tt> function from
--   <tt>Control.DeepSeq</tt> may be handy:
--   
--   <pre>
--   evaluate $ force x
--   </pre>
--   
--   There is a subtle difference between <tt><a>evaluate</a> x</tt> and
--   <tt><a>return</a> <a>$!</a> x</tt>, analogous to the difference
--   between <a>throwIO</a> and <a>throw</a>. If the lazy value <tt>x</tt>
--   throws an exception, <tt><a>return</a> <a>$!</a> x</tt> will fail to
--   return an <a>IO</a> action and will throw an exception instead.
--   <tt><a>evaluate</a> x</tt>, on the other hand, always produces an
--   <a>IO</a> action; that action will throw an exception upon
--   <i>execution</i> iff <tt>x</tt> throws an exception upon
--   <i>evaluation</i>.
--   
--   The practical implication of this difference is that due to the
--   <i>imprecise exceptions</i> semantics,
--   
--   <pre>
--   (return $! error "foo") &gt;&gt; error "bar"
--   </pre>
--   
--   may throw either <tt>"foo"</tt> or <tt>"bar"</tt>, depending on the
--   optimizations performed by the compiler. On the other hand,
--   
--   <pre>
--   evaluate (error "foo") &gt;&gt; error "bar"
--   </pre>
--   
--   is guaranteed to throw <tt>"foo"</tt>.
--   
--   The rule of thumb is to use <a>evaluate</a> to force or handle
--   exceptions in lazy values. If, on the other hand, you are forcing a
--   lazy value for efficiency reasons only and do not care about
--   exceptions, you may use <tt><a>return</a> <a>$!</a> x</tt>.
evaluate :: a -> IO a

-- | This function maps one exception into another as proposed in the paper
--   "A semantics for imprecise exceptions".
mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a

-- | Executes an IO computation with asynchronous exceptions <i>masked</i>.
--   That is, any thread which attempts to raise an exception in the
--   current thread with <a>throwTo</a> will be blocked until asynchronous
--   exceptions are unmasked again.
--   
--   The argument passed to <a>mask</a> is a function that takes as its
--   argument another function, which can be used to restore the prevailing
--   masking state within the context of the masked computation. For
--   example, a common way to use <a>mask</a> is to protect the acquisition
--   of a resource:
--   
--   <pre>
--   mask $ \restore -&gt; do
--       x &lt;- acquire
--       restore (do_something_with x) `onException` release
--       release
--   </pre>
--   
--   This code guarantees that <tt>acquire</tt> is paired with
--   <tt>release</tt>, by masking asynchronous exceptions for the critical
--   parts. (Rather than write this code yourself, it would be better to
--   use <a>bracket</a> which abstracts the general pattern).
--   
--   Note that the <tt>restore</tt> action passed to the argument to
--   <a>mask</a> does not necessarily unmask asynchronous exceptions, it
--   just restores the masking state to that of the enclosing context. Thus
--   if asynchronous exceptions are already masked, <a>mask</a> cannot be
--   used to unmask exceptions again. This is so that if you call a library
--   function with exceptions masked, you can be sure that the library call
--   will not be able to unmask exceptions again. If you are writing
--   library code and need to use asynchronous exceptions, the only way is
--   to create a new thread; see <a>forkIOWithUnmask</a>.
--   
--   Asynchronous exceptions may still be received while in the masked
--   state if the masked thread <i>blocks</i> in certain ways; see
--   <a>Control.Exception#interruptible</a>.
--   
--   Threads created by <a>forkIO</a> inherit the <a>MaskingState</a> from
--   the parent; that is, to start a thread in the
--   <a>MaskedInterruptible</a> state, use <tt>mask_ $ forkIO ...</tt>.
--   This is particularly useful if you need to establish an exception
--   handler in the forked thread before any asynchronous exceptions are
--   received. To create a new thread in an unmasked state use
--   <a>forkIOWithUnmask</a>.
mask :: ((forall a. () => IO a -> IO a) -> IO b) -> IO b

-- | Like <a>mask</a>, but does not pass a <tt>restore</tt> action to the
--   argument.
mask_ :: IO a -> IO a

-- | Like <a>mask</a>, but the masked computation is not interruptible (see
--   <a>Control.Exception#interruptible</a>). THIS SHOULD BE USED WITH
--   GREAT CARE, because if a thread executing in
--   <a>uninterruptibleMask</a> blocks for any reason, then the thread (and
--   possibly the program, if this is the main thread) will be unresponsive
--   and unkillable. This function should only be necessary if you need to
--   mask exceptions around an interruptible operation, and you can
--   guarantee that the interruptible operation will only block for a short
--   period of time.
uninterruptibleMask :: ((forall a. () => IO a -> IO a) -> IO b) -> IO b

-- | Like <a>uninterruptibleMask</a>, but does not pass a <tt>restore</tt>
--   action to the argument.
uninterruptibleMask_ :: IO a -> IO a

-- | Describes the behaviour of a thread when an asynchronous exception is
--   received.
data MaskingState

-- | asynchronous exceptions are unmasked (the normal state)
Unmasked :: MaskingState

-- | the state during <a>mask</a>: asynchronous exceptions are masked, but
--   blocking operations may still be interrupted
MaskedInterruptible :: MaskingState

-- | the state during <a>uninterruptibleMask</a>: asynchronous exceptions
--   are masked, and blocking operations may not be interrupted
MaskedUninterruptible :: MaskingState

-- | Returns the <a>MaskingState</a> for the current thread.
getMaskingState :: IO MaskingState

-- | If the first argument evaluates to <a>True</a>, then the result is the
--   second argument. Otherwise an <a>AssertionFailed</a> exception is
--   raised, containing a <a>String</a> with the source file and line
--   number of the call to <a>assert</a>.
--   
--   Assertions can normally be turned on or off with a compiler flag (for
--   GHC, assertions are normally on unless optimisation is turned on with
--   <tt>-O</tt> or the <tt>-fignore-asserts</tt> option is given). When
--   assertions are turned off, the first argument to <a>assert</a> is
--   ignored, and the second argument is returned as the result.
assert :: Bool -> a -> a

-- | Exception context represents a list of <a>ExceptionAnnotation</a>s.
--   These are attached to <tt>SomeException</tt>s via
--   <a>addExceptionContext</a> and can be used to capture various ad-hoc
--   metadata about the exception including backtraces and
--   application-specific context.
--   
--   <a>ExceptionContext</a>s can be merged via concatenation using the
--   <a>Semigroup</a> instance or <a>mergeExceptionContext</a>.
--   
--   Note that GHC will automatically solve implicit constraints of type
--   <a>ExceptionContext</a> with <a>emptyExceptionContext</a>.
data ExceptionContext
ExceptionContext :: [SomeExceptionAnnotation] -> ExceptionContext

-- | Execute an <a>IO</a> action, adding the given
--   <tt>ExceptionContext</tt> to any thrown synchronous exceptions.
annotateIO :: ExceptionAnnotation e => e -> IO a -> IO a

-- | <tt>WhileHandling</tt> is used to annotate rethrow exceptions. By
--   inspecting the <tt>WhileHandling</tt> annotation, all the places the
--   exception has been rethrow can be recovered.
data WhileHandling
WhileHandling :: SomeException -> WhileHandling

-- | When you want to acquire a resource, do some work with it, and then
--   release the resource, it is a good idea to use <a>bracket</a>, because
--   <a>bracket</a> will install the necessary exception handler to release
--   the resource in the event that an exception is raised during the
--   computation. If an exception is raised, then <a>bracket</a> will
--   re-raise the exception (after performing the release).
--   
--   A common example is opening a file:
--   
--   <pre>
--   bracket
--     (openFile "filename" ReadMode)
--     (hClose)
--     (\fileHandle -&gt; do { ... })
--   </pre>
--   
--   The arguments to <a>bracket</a> are in this order so that we can
--   partially apply it, e.g.:
--   
--   <pre>
--   withFile name mode = bracket (openFile name mode) hClose
--   </pre>
--   
--   Bracket wraps the release action with <a>mask</a>, which is sufficient
--   to ensure that the release action executes to completion when it does
--   not invoke any interruptible actions, even in the presence of
--   asynchronous exceptions. For example, <tt>hClose</tt> is
--   uninterruptible when it is not racing other uses of the handle.
--   Similarly, closing a socket (from "network" package) is also
--   uninterruptible under similar conditions. An example of an
--   interruptible action is <a>killThread</a>. Completion of interruptible
--   release actions can be ensured by wrapping them in
--   <a>uninterruptibleMask_</a>, but this risks making the program
--   non-responsive to <tt>Control-C</tt>, or timeouts. Another option is
--   to run the release action asynchronously in its own thread:
--   
--   <pre>
--   void $ uninterruptibleMask_ $ forkIO $ do { ... }
--   </pre>
--   
--   The resource will be released as soon as possible, but the thread that
--   invoked bracket will not block in an uninterruptible state.
bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c

-- | A variant of <a>bracket</a> where the return value from the first
--   computation is not required.
bracket_ :: IO a -> IO b -> IO c -> IO c

-- | Like <a>bracket</a>, but only performs the final action if there was
--   an exception raised by the in-between computation.
bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c

-- | A specialised variant of <a>bracket</a> with just a computation to run
--   afterward.
finally :: IO a -> IO b -> IO a
recSelError :: Addr# -> a
recConError :: Addr# -> a
impossibleError :: Addr# -> a
impossibleConstraintError :: Addr# -> a
nonExhaustiveGuardsError :: Addr# -> a
patError :: Addr# -> a
noMethodBindingError :: Addr# -> a
typeError :: Addr# -> a
nonTermination :: SomeException
nestedAtomically :: SomeException
noMatchingContinuationPrompt :: SomeException
instance GHC.Internal.Exception.Type.Exception GHC.Internal.Control.Exception.Base.NestedAtomically
instance GHC.Internal.Exception.Type.Exception GHC.Internal.Control.Exception.Base.NoMatchingContinuationPrompt
instance GHC.Internal.Exception.Type.Exception GHC.Internal.Control.Exception.Base.NoMethodError
instance GHC.Internal.Exception.Type.Exception GHC.Internal.Control.Exception.Base.NonTermination
instance GHC.Internal.Exception.Type.Exception GHC.Internal.Control.Exception.Base.PatternMatchFail
instance GHC.Internal.Exception.Type.Exception GHC.Internal.Control.Exception.Base.RecConError
instance GHC.Internal.Exception.Type.Exception GHC.Internal.Control.Exception.Base.RecSelError
instance GHC.Internal.Exception.Type.Exception GHC.Internal.Control.Exception.Base.RecUpdError
instance GHC.Internal.Exception.Type.Exception GHC.Internal.Control.Exception.Base.TypeError
instance GHC.Internal.Show.Show GHC.Internal.Control.Exception.Base.NestedAtomically
instance GHC.Internal.Show.Show GHC.Internal.Control.Exception.Base.NoMatchingContinuationPrompt
instance GHC.Internal.Show.Show GHC.Internal.Control.Exception.Base.NoMethodError
instance GHC.Internal.Show.Show GHC.Internal.Control.Exception.Base.NonTermination
instance GHC.Internal.Show.Show GHC.Internal.Control.Exception.Base.PatternMatchFail
instance GHC.Internal.Show.Show GHC.Internal.Control.Exception.Base.RecConError
instance GHC.Internal.Show.Show GHC.Internal.Control.Exception.Base.RecSelError
instance GHC.Internal.Show.Show GHC.Internal.Control.Exception.Base.RecUpdError
instance GHC.Internal.Show.Show GHC.Internal.Control.Exception.Base.TypeError


-- | Standard IO Errors.
module GHC.Internal.System.IO.Error

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOError</a> instead of returning a result.
--   For a more general type of exception, including also those that arise
--   in pure code, see <a>Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | Construct an <a>IOError</a> value with a string describing the error.
--   The <tt>fail</tt> method of the <a>IO</a> instance of the <a>Monad</a>
--   class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError

-- | Construct an <a>IOError</a> of the given type where the second
--   argument describes the error location and the third and fourth
--   argument contain the file handle and file path of the file involved in
--   the error if applicable.
mkIOError :: IOErrorType -> String -> Maybe Handle -> Maybe FilePath -> IOError

-- | Adds a location description and maybe a file path and file handle to
--   an <a>IOError</a>. If any of the file handle or file path is not given
--   the corresponding value in the <a>IOError</a> remains unaltered.
annotateIOError :: IOError -> String -> Maybe Handle -> Maybe FilePath -> IOError

-- | An error indicating that an <a>IO</a> operation failed because one of
--   its arguments already exists.
isAlreadyExistsError :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because one of
--   its arguments does not exist.
isDoesNotExistError :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because one of
--   its arguments is a single-use resource, which is already being used
--   (for example, opening the same file twice for writing might give this
--   error).
isAlreadyInUseError :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because the
--   device is full.
isFullError :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because the end
--   of file has been reached.
isEOFError :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because the
--   operation was not possible. Any computation which returns an <a>IO</a>
--   result may fail with <a>isIllegalOperation</a>. In some cases, an
--   implementation will not be able to distinguish between the possible
--   error causes. In this case it should fail with
--   <a>isIllegalOperation</a>.
isIllegalOperation :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because the
--   user does not have sufficient operating system privilege to perform
--   that operation.
isPermissionError :: IOError -> Bool

-- | A programmer-defined error value constructed using <a>userError</a>.
isUserError :: IOError -> Bool

-- | An error indicating that the operation failed because the resource
--   vanished. See <a>resourceVanishedErrorType</a>.
isResourceVanishedError :: IOError -> Bool
ioeGetErrorType :: IOError -> IOErrorType
ioeGetLocation :: IOError -> String
ioeGetErrorString :: IOError -> String
ioeGetHandle :: IOError -> Maybe Handle
ioeGetFileName :: IOError -> Maybe FilePath
ioeSetErrorType :: IOError -> IOErrorType -> IOError
ioeSetErrorString :: IOError -> String -> IOError
ioeSetLocation :: IOError -> String -> IOError
ioeSetHandle :: IOError -> Handle -> IOError
ioeSetFileName :: IOError -> FilePath -> IOError

-- | An abstract type that contains a value for each variant of
--   <a>IOError</a>.
data IOErrorType

-- | I/O error where the operation failed because one of its arguments
--   already exists.
alreadyExistsErrorType :: IOErrorType

-- | I/O error where the operation failed because one of its arguments does
--   not exist.
doesNotExistErrorType :: IOErrorType

-- | I/O error where the operation failed because one of its arguments is a
--   single-use resource, which is already being used.
alreadyInUseErrorType :: IOErrorType

-- | I/O error where the operation failed because the device is full.
fullErrorType :: IOErrorType

-- | I/O error where the operation failed because the end of file has been
--   reached.
eofErrorType :: IOErrorType

-- | I/O error where the operation is not possible.
illegalOperationErrorType :: IOErrorType

-- | I/O error where the operation failed because the user does not have
--   sufficient operating system privilege to perform that operation.
permissionErrorType :: IOErrorType

-- | I/O error that is programmer-defined.
userErrorType :: IOErrorType

-- | I/O error where the operation failed because the resource vanished.
--   This happens when, for example, attempting to write to a closed socket
--   or attempting to write to a named pipe that was deleted.
resourceVanishedErrorType :: IOErrorType

-- | I/O error where the operation failed because one of its arguments
--   already exists.
isAlreadyExistsErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because one of its arguments does
--   not exist.
isDoesNotExistErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because one of its arguments is a
--   single-use resource, which is already being used.
isAlreadyInUseErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because the device is full.
isFullErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because the end of file has been
--   reached.
isEOFErrorType :: IOErrorType -> Bool

-- | I/O error where the operation is not possible.
isIllegalOperationErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because the user does not have
--   sufficient operating system privilege to perform that operation.
isPermissionErrorType :: IOErrorType -> Bool

-- | I/O error that is programmer-defined.
isUserErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because the resource vanished.
--   See <a>resourceVanishedErrorType</a>.
isResourceVanishedErrorType :: IOErrorType -> Bool

-- | Raise an <a>IOError</a> in the <a>IO</a> monad.
ioError :: HasCallStack => IOError -> IO a

-- | The <a>catchIOError</a> function establishes a handler that receives
--   any <a>IOError</a> raised in the action protected by
--   <a>catchIOError</a>. An <a>IOError</a> is caught by the most recent
--   handler established by one of the exception handling functions. These
--   handlers are not selective: all <a>IOError</a>s are caught. Exception
--   propagation must be explicitly provided in a handler by re-raising any
--   unwanted exceptions. For example, in
--   
--   <pre>
--   f = catchIOError g (\e -&gt; if IO.isEOFError e then return [] else ioError e)
--   </pre>
--   
--   the function <tt>f</tt> returns <tt>[]</tt> when an end-of-file
--   exception (cf. <a>isEOFError</a>) occurs in <tt>g</tt>; otherwise, the
--   exception is propagated to the next outer handler.
--   
--   When an exception propagates outside the main program, the Haskell
--   system prints the associated <a>IOError</a> value and exits the
--   program.
--   
--   Non-I/O exceptions are not caught by this variant; to catch all
--   exceptions, use <a>catch</a> from <a>Control.Exception</a>.
catchIOError :: IO a -> (IOError -> IO a) -> IO a

-- | The construct <a>tryIOError</a> <tt>comp</tt> exposes IO errors which
--   occur within a computation, and which are not fully handled.
--   
--   Non-I/O exceptions are not caught by this variant; to catch all
--   exceptions, use <a>try</a> from <a>Control.Exception</a>.
tryIOError :: IO a -> IO (Either IOError a)

-- | Catch any <a>IOError</a> that occurs in the computation and throw a
--   modified version.
modifyIOError :: (IOError -> IOError) -> IO a -> IO a


-- | This library provides support for <i>strict</i> state threads, as
--   described in the PLDI '94 paper by John Launchbury and Simon Peyton
--   Jones <i>Lazy Functional State Threads</i>.
module GHC.Internal.Control.Monad.ST.Imp

-- | The strict <a>ST</a> monad. The <a>ST</a> monad allows for destructive
--   updates, but is escapable (unlike IO). A computation of type
--   <tt><a>ST</a> s a</tt> returns a value of type <tt>a</tt>, and execute
--   in "thread" <tt>s</tt>. The <tt>s</tt> parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are strict in the
--   state (though not in values stored in the state). For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= f) = _|_
--   </pre>
data ST s a

-- | Return the value computed by a state thread. The <tt>forall</tt>
--   ensures that the internal state used by the <a>ST</a> computation is
--   inaccessible to the rest of the program.
runST :: (forall s. () => ST s a) -> a

-- | Allow the result of an <a>ST</a> computation to be used (lazily)
--   inside the computation.
--   
--   Note that if <tt>f</tt> is strict, <tt><a>fixST</a> f = _|_</tt>.
fixST :: (a -> ST s a) -> ST s a

-- | <a>RealWorld</a> is deeply magical. It is <i>primitive</i>, but it is
--   not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <a>RealWorld</a>; it's only used in the type system, to
--   parameterise <a>State#</a>.
data RealWorld

-- | Embed a strict state thread in an <a>IO</a> action. The
--   <a>RealWorld</a> parameter indicates that the internal state used by
--   the <a>ST</a> computation is a special one supplied by the <a>IO</a>
--   monad, and thus distinct from those used by invocations of
--   <a>runST</a>.
stToIO :: ST RealWorld a -> IO a

-- | <a>unsafeInterleaveST</a> allows an <a>ST</a> computation to be
--   deferred lazily. When passed a value of type <tt>ST a</tt>, the
--   <a>ST</a> computation will only be performed when the value of the
--   <tt>a</tt> is demanded.
unsafeInterleaveST :: ST s a -> ST s a

-- | <a>unsafeDupableInterleaveST</a> allows an <a>ST</a> computation to be
--   deferred lazily. When passed a value of type <tt>ST a</tt>, the
--   <a>ST</a> computation will only be performed when the value of the
--   <tt>a</tt> is demanded.
--   
--   The computation may be performed multiple times by different threads,
--   possibly at the same time. To prevent this, use
--   <a>unsafeInterleaveST</a> instead.
unsafeDupableInterleaveST :: ST s a -> ST s a

-- | Convert an <a>IO</a> action to an <a>ST</a> action. This relies on
--   <a>IO</a> and <a>ST</a> having the same representation modulo the
--   constraint on the state thread type parameter.
unsafeIOToST :: IO a -> ST s a

-- | Convert an <a>ST</a> action to an <a>IO</a> action. This relies on
--   <a>IO</a> and <a>ST</a> having the same representation modulo the
--   constraint on the state thread type parameter.
--   
--   For an example demonstrating why this is unsafe, see
--   <a>https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html</a>
unsafeSTToIO :: ST s a -> IO a


-- | This library provides support for <i>strict</i> state threads, as
--   described in the PLDI '94 paper by John Launchbury and Simon Peyton
--   Jones <i>Lazy Functional State Threads</i>.
--   
--   References (variables) that can be used within the <tt>ST</tt> monad
--   are provided by <a>Data.STRef</a>, and arrays are provided by
--   <a>Data.Array.ST</a>.
module GHC.Internal.Control.Monad.ST

-- | The strict <a>ST</a> monad. The <a>ST</a> monad allows for destructive
--   updates, but is escapable (unlike IO). A computation of type
--   <tt><a>ST</a> s a</tt> returns a value of type <tt>a</tt>, and execute
--   in "thread" <tt>s</tt>. The <tt>s</tt> parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are strict in the
--   state (though not in values stored in the state). For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= f) = _|_
--   </pre>
data ST s a

-- | Return the value computed by a state thread. The <tt>forall</tt>
--   ensures that the internal state used by the <a>ST</a> computation is
--   inaccessible to the rest of the program.
runST :: (forall s. () => ST s a) -> a

-- | Allow the result of an <a>ST</a> computation to be used (lazily)
--   inside the computation.
--   
--   Note that if <tt>f</tt> is strict, <tt><a>fixST</a> f = _|_</tt>.
fixST :: (a -> ST s a) -> ST s a

-- | <a>RealWorld</a> is deeply magical. It is <i>primitive</i>, but it is
--   not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <a>RealWorld</a>; it's only used in the type system, to
--   parameterise <a>State#</a>.
data RealWorld

-- | Embed a strict state thread in an <a>IO</a> action. The
--   <a>RealWorld</a> parameter indicates that the internal state used by
--   the <a>ST</a> computation is a special one supplied by the <a>IO</a>
--   monad, and thus distinct from those used by invocations of
--   <a>runST</a>.
stToIO :: ST RealWorld a -> IO a


-- | This module provides support for raising and catching both built-in
--   and user-defined exceptions.
--   
--   In addition to exceptions thrown by <a>IO</a> operations, exceptions
--   may be thrown by pure code (imprecise exceptions) or by external
--   events (asynchronous exceptions), but may only be caught in the
--   <a>IO</a> monad. For more details, see:
--   
--   <ul>
--   <li><i>A semantics for imprecise exceptions</i>, by Simon Peyton
--   Jones, Alastair Reid, Tony Hoare, Simon Marlow, Fergus Henderson, in
--   <i>PLDI'99</i>.</li>
--   <li><i>Asynchronous exceptions in Haskell</i>, by Simon Marlow, Simon
--   Peyton Jones, Andy Moran and John Reppy, in <i>PLDI'01</i>.</li>
--   <li><i>An Extensible Dynamically-Typed Hierarchy of Exceptions</i>, by
--   Simon Marlow, in <i>Haskell '06</i>.</li>
--   </ul>
module GHC.Internal.Control.Exception

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException
SomeException :: e -> SomeException

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e

-- | <tt>toException</tt> should produce a <a>SomeException</a> with no
--   attached <a>ExceptionContext</a>.
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

backtraceDesired :: Exception e => e -> Bool

-- | Exceptions that occur in the <tt>IO</tt> monad. An
--   <tt>IOException</tt> records a more specific error type, a descriptive
--   string and maybe the handle that was used when the error was flagged.
data IOException

-- | Arithmetic exceptions.
data ArithException
Overflow :: ArithException
Underflow :: ArithException
LossOfPrecision :: ArithException
DivideByZero :: ArithException
Denormal :: ArithException

RatioZeroDenominator :: ArithException

-- | Exceptions generated by array operations
data ArrayException

-- | An attempt was made to index an array outside its declared bounds.
IndexOutOfBounds :: String -> ArrayException

-- | An attempt was made to evaluate an element of an array that had not
--   been initialized.
UndefinedElement :: String -> ArrayException

-- | <a>assert</a> was applied to <a>False</a>.
newtype AssertionFailed
AssertionFailed :: String -> AssertionFailed

-- | Superclass for asynchronous exceptions.
data SomeAsyncException
SomeAsyncException :: e -> SomeAsyncException

-- | Asynchronous exceptions.
data AsyncException

-- | The current thread's stack exceeded its limit. Since an exception has
--   been raised, the thread's stack will certainly be below its limit
--   again, but the programmer should take remedial action immediately.
StackOverflow :: AsyncException

-- | The program's heap is reaching its limit, and the program should take
--   action to reduce the amount of live data it has. Notes:
--   
--   <ul>
--   <li>It is undefined which thread receives this exception. GHC
--   currently throws this to the same thread that receives
--   <a>UserInterrupt</a>, but this may change in the future.</li>
--   <li>The GHC RTS currently can only recover from heap overflow if it
--   detects that an explicit memory limit (set via RTS flags). has been
--   exceeded. Currently, failure to allocate memory from the operating
--   system results in immediate termination of the program.</li>
--   </ul>
HeapOverflow :: AsyncException

-- | This exception is raised by another thread calling <a>killThread</a>,
--   or by the system if it needs to terminate the thread for some reason.
ThreadKilled :: AsyncException

-- | This exception is raised by default in the main thread of the program
--   when the user requests to terminate the program via the usual
--   mechanism(s) (e.g. Control-C in the console).
UserInterrupt :: AsyncException

asyncExceptionToException :: Exception e => e -> SomeException

asyncExceptionFromException :: Exception e => SomeException -> Maybe e

-- | Thrown when the runtime system detects that the computation is
--   guaranteed not to terminate. Note that there is no guarantee that the
--   runtime system will notice whether any given computation is guaranteed
--   to terminate or not.
data NonTermination
NonTermination :: NonTermination

-- | Thrown when the program attempts to call <tt>atomically</tt>, from the
--   <tt>stm</tt> package, inside another call to <tt>atomically</tt>.
data NestedAtomically
NestedAtomically :: NestedAtomically

-- | The thread is blocked on an <tt>MVar</tt>, but there are no other
--   references to the <tt>MVar</tt> so it can't ever continue.
data BlockedIndefinitelyOnMVar
BlockedIndefinitelyOnMVar :: BlockedIndefinitelyOnMVar

-- | The thread is waiting to retry an STM transaction, but there are no
--   other references to any <tt>TVar</tt>s involved, so it can't ever
--   continue.
data BlockedIndefinitelyOnSTM
BlockedIndefinitelyOnSTM :: BlockedIndefinitelyOnSTM

-- | This thread has exceeded its allocation limit. See
--   <a>setAllocationCounter</a> and <a>enableAllocationLimit</a>.
data AllocationLimitExceeded
AllocationLimitExceeded :: AllocationLimitExceeded

-- | Compaction found an object that cannot be compacted. Functions cannot
--   be compacted, nor can mutable objects or pinned objects. See
--   <a>compact</a>.
newtype CompactionFailed
CompactionFailed :: String -> CompactionFailed

-- | There are no runnable threads, so the program is deadlocked. The
--   <tt>Deadlock</tt> exception is raised in the main thread only.
data Deadlock
Deadlock :: Deadlock

-- | A class method without a definition (neither a default definition, nor
--   a definition in the appropriate instance) was called. The
--   <tt>String</tt> gives information about which method it was.
newtype NoMethodError
NoMethodError :: String -> NoMethodError

-- | A pattern match failed. The <tt>String</tt> gives information about
--   the source location of the pattern.
newtype PatternMatchFail
PatternMatchFail :: String -> PatternMatchFail

-- | An uninitialised record field was used. The <tt>String</tt> gives
--   information about the source location where the record was
--   constructed.
newtype RecConError
RecConError :: String -> RecConError

-- | A record selector was applied to a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another. The <tt>String</tt> gives information about the source
--   location of the record selector.
newtype RecSelError
RecSelError :: String -> RecSelError

-- | A record update was performed on a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another. The <tt>String</tt> gives information about the source
--   location of the record update.
newtype RecUpdError
RecUpdError :: String -> RecUpdError

-- | This is thrown when the user calls <a>error</a>. The <tt>String</tt>
--   is the argument given to <a>error</a>.
--   
--   Historically, there was a second <tt>String</tt> for the location, but
--   it was subsumed by the backtrace mechanisms (since base-4.22).
data ErrorCall
ErrorCall :: String -> ErrorCall

-- | <i>Deprecated: ErrorCallWithLocation has been deprecated in favour of
--   ErrorCall (which does not have a location). Backtraces are now handled
--   by the backtrace exception mechanisms exclusively.</i>
pattern ErrorCallWithLocation :: String -> String -> ErrorCall

-- | An expression that didn't typecheck during compile time was called.
--   This is only possible with -fdefer-type-errors. The <tt>String</tt>
--   gives details about the failed type check.
newtype TypeError
TypeError :: String -> TypeError

-- | Throw an exception. Exceptions may be thrown from purely functional
--   code, but may only be caught within the <a>IO</a> monad.
--   
--   WARNING: You may want to use <tt>throwIO</tt> instead so that your
--   pure code stays exception-free.
throw :: forall a e. (HasCallStack, Exception e) => e -> a

-- | A variant of <a>throw</a> that can only be used within the <a>IO</a>
--   monad.
--   
--   Although <a>throwIO</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e   `seq` ()  ===&gt; throw e
--   throwIO e `seq` ()  ===&gt; ()
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwIO</a> will only cause
--   an exception to be raised when it is used within the <a>IO</a> monad.
--   
--   The <a>throwIO</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>IO</a> monad because
--   it guarantees ordering with respect to other operations, whereas
--   <a>throw</a> does not. We say that <a>throwIO</a> throws *precise*
--   exceptions and <a>throw</a>, <a>error</a>, etc. all throw *imprecise*
--   exceptions. For example
--   
--   <pre>
--   throw e + error "boom" ===&gt; error "boom"
--   throw e + error "boom" ===&gt; throw e
--   </pre>
--   
--   are both valid reductions and the compiler may pick any (loop, even),
--   whereas
--   
--   <pre>
--   throwIO e &gt;&gt; error "boom" ===&gt; throwIO e
--   </pre>
--   
--   will always throw <tt>e</tt> when executed.
--   
--   See also the <a>GHC wiki page on precise exceptions</a> for a more
--   technical introduction to how GHC optimises around precise vs.
--   imprecise exceptions.
throwIO :: (HasCallStack, Exception e) => e -> IO a

-- | A utility to use when rethrowing exceptions, no new backtrace will be
--   attached when rethrowing an exception but you must supply the existing
--   context.
rethrowIO :: Exception e => ExceptionWithContext e -> IO a

-- | Raise an <a>IOError</a> in the <a>IO</a> monad.
ioError :: HasCallStack => IOError -> IO a

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()

-- | This is the simplest of the exception-catching functions. It takes a
--   single argument, runs it, and if an exception is raised the "handler"
--   is executed, with the value of the exception passed as an argument.
--   Otherwise, the result is returned as normal. For example:
--   
--   <pre>
--   catch (readFile f)
--         (\e -&gt; do let err = show (e :: IOException)
--                   hPutStr stderr ("Warning: Couldn't open " ++ f ++ ": " ++ err)
--                   return "")
--   </pre>
--   
--   Note that we have to give a type signature to <tt>e</tt>, or the
--   program will not typecheck as the type is ambiguous. While it is
--   possible to catch exceptions of any type, see the section "Catching
--   all exceptions" (in <a>Control.Exception</a>) for an explanation of
--   the problems with doing so.
--   
--   For catching exceptions in pure (non-<a>IO</a>) expressions, see the
--   function <a>evaluate</a>.
--   
--   Note that due to Haskell's unspecified evaluation order, an expression
--   may throw one of several possible exceptions: consider the expression
--   <tt>(error "urk") + (1 `div` 0)</tt>. Does the expression throw
--   <tt>ErrorCall "urk"</tt>, or <tt>DivideByZero</tt>?
--   
--   The answer is "it might throw either"; the choice is
--   non-deterministic. If you are catching any type of exception then you
--   might catch either. If you are calling <tt>catch</tt> with type <tt>IO
--   Int -&gt; (ArithException -&gt; IO Int) -&gt; IO Int</tt> then the
--   handler may get run with <tt>DivideByZero</tt> as an argument, or an
--   <tt>ErrorCall "urk"</tt> exception may be propagated further up. If
--   you call it again, you might get the opposite behaviour. This is ok,
--   because <a>catch</a> is an <a>IO</a> computation.
catch :: Exception e => IO a -> (e -> IO a) -> IO a

-- | A variant of <a>catch</a> which doesn't annotate the handler with the
--   exception which was caught. This function should be used when you are
--   implementing your own error handling functions which may rethrow the
--   exceptions.
--   
--   In the case where you rethrow an exception without modifying it, you
--   should rethrow the exception with the old exception context.
catchNoPropagate :: Exception e => IO a -> (ExceptionWithContext e -> IO a) -> IO a

-- | Sometimes you want to catch two different sorts of exception. You
--   could do something like
--   
--   <pre>
--   f = expr `catch` \ (ex :: ArithException) -&gt; handleArith ex
--            `catch` \ (ex :: IOException)    -&gt; handleIO    ex
--   </pre>
--   
--   However, there are a couple of problems with this approach. The first
--   is that having two exception handlers is inefficient. However, the
--   more serious issue is that the second exception handler will catch
--   exceptions in the first, e.g. in the example above, if
--   <tt>handleArith</tt> throws an <tt>IOException</tt> then the second
--   exception handler will catch it.
--   
--   Instead, we provide a function <a>catches</a>, which would be used
--   thus:
--   
--   <pre>
--   f = expr `catches` [Handler (\ (ex :: ArithException) -&gt; handleArith ex),
--                       Handler (\ (ex :: IOException)    -&gt; handleIO    ex)]
--   </pre>
catches :: IO a -> [Handler a] -> IO a

-- | You need this when using <a>catches</a>.
data Handler a
Handler :: (e -> IO a) -> Handler a

-- | The function <a>catchJust</a> is like <a>catch</a>, but it takes an
--   extra argument which is an <i>exception predicate</i>, a function
--   which selects which type of exceptions we're interested in.
--   
--   <pre>
--   catchJust (\e -&gt; if isDoesNotExistErrorType (ioeGetErrorType e) then Just () else Nothing)
--             (readFile f)
--             (\_ -&gt; do hPutStrLn stderr ("No such file: " ++ show f)
--                       return "")
--   </pre>
--   
--   Any other exceptions which are not matched by the predicate are
--   re-raised, and may be caught by an enclosing <a>catch</a>,
--   <a>catchJust</a>, etc.
catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a

-- | A version of <a>catch</a> with the arguments swapped around; useful in
--   situations where the code for the handler is shorter. For example:
--   
--   <pre>
--   do handle (\NonTermination -&gt; exitWith (ExitFailure 1)) $
--      ...
--   </pre>
handle :: Exception e => (e -> IO a) -> IO a -> IO a

-- | A version of <a>catchJust</a> with the arguments swapped around (see
--   <a>handle</a>).
handleJust :: Exception e => (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a

-- | Similar to <a>catch</a>, but returns an <a>Either</a> result which is
--   <tt>(<a>Right</a> a)</tt> if no exception of type <tt>e</tt> was
--   raised, or <tt>(<a>Left</a> ex)</tt> if an exception of type
--   <tt>e</tt> was raised and its value is <tt>ex</tt>. If any other type
--   of exception is raised then it will be propagated up to the next
--   enclosing exception handler.
--   
--   <pre>
--   try a = catch (Right `liftM` a) (return . Left)
--   </pre>
try :: Exception e => IO a -> IO (Either e a)

-- | Like <a>try</a> but also returns the exception context, which is
--   useful if you intend to rethrow the exception later.
tryWithContext :: Exception e => IO a -> IO (Either (ExceptionWithContext e) a)

-- | A variant of <a>try</a> that takes an exception predicate to select
--   which exceptions are caught (c.f. <a>catchJust</a>). If the exception
--   does not match the predicate, it is re-thrown.
tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)

-- | Evaluate the argument to weak head normal form.
--   
--   <a>evaluate</a> is typically used to uncover any exceptions that a
--   lazy value may contain, and possibly handle them.
--   
--   <a>evaluate</a> only evaluates to <i>weak head normal form</i>. If
--   deeper evaluation is needed, the <tt>force</tt> function from
--   <tt>Control.DeepSeq</tt> may be handy:
--   
--   <pre>
--   evaluate $ force x
--   </pre>
--   
--   There is a subtle difference between <tt><a>evaluate</a> x</tt> and
--   <tt><a>return</a> <a>$!</a> x</tt>, analogous to the difference
--   between <a>throwIO</a> and <a>throw</a>. If the lazy value <tt>x</tt>
--   throws an exception, <tt><a>return</a> <a>$!</a> x</tt> will fail to
--   return an <a>IO</a> action and will throw an exception instead.
--   <tt><a>evaluate</a> x</tt>, on the other hand, always produces an
--   <a>IO</a> action; that action will throw an exception upon
--   <i>execution</i> iff <tt>x</tt> throws an exception upon
--   <i>evaluation</i>.
--   
--   The practical implication of this difference is that due to the
--   <i>imprecise exceptions</i> semantics,
--   
--   <pre>
--   (return $! error "foo") &gt;&gt; error "bar"
--   </pre>
--   
--   may throw either <tt>"foo"</tt> or <tt>"bar"</tt>, depending on the
--   optimizations performed by the compiler. On the other hand,
--   
--   <pre>
--   evaluate (error "foo") &gt;&gt; error "bar"
--   </pre>
--   
--   is guaranteed to throw <tt>"foo"</tt>.
--   
--   The rule of thumb is to use <a>evaluate</a> to force or handle
--   exceptions in lazy values. If, on the other hand, you are forcing a
--   lazy value for efficiency reasons only and do not care about
--   exceptions, you may use <tt><a>return</a> <a>$!</a> x</tt>.
evaluate :: a -> IO a

-- | This function maps one exception into another as proposed in the paper
--   "A semantics for imprecise exceptions".
mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a

-- | Executes an IO computation with asynchronous exceptions <i>masked</i>.
--   That is, any thread which attempts to raise an exception in the
--   current thread with <a>throwTo</a> will be blocked until asynchronous
--   exceptions are unmasked again.
--   
--   The argument passed to <a>mask</a> is a function that takes as its
--   argument another function, which can be used to restore the prevailing
--   masking state within the context of the masked computation. For
--   example, a common way to use <a>mask</a> is to protect the acquisition
--   of a resource:
--   
--   <pre>
--   mask $ \restore -&gt; do
--       x &lt;- acquire
--       restore (do_something_with x) `onException` release
--       release
--   </pre>
--   
--   This code guarantees that <tt>acquire</tt> is paired with
--   <tt>release</tt>, by masking asynchronous exceptions for the critical
--   parts. (Rather than write this code yourself, it would be better to
--   use <a>bracket</a> which abstracts the general pattern).
--   
--   Note that the <tt>restore</tt> action passed to the argument to
--   <a>mask</a> does not necessarily unmask asynchronous exceptions, it
--   just restores the masking state to that of the enclosing context. Thus
--   if asynchronous exceptions are already masked, <a>mask</a> cannot be
--   used to unmask exceptions again. This is so that if you call a library
--   function with exceptions masked, you can be sure that the library call
--   will not be able to unmask exceptions again. If you are writing
--   library code and need to use asynchronous exceptions, the only way is
--   to create a new thread; see <a>forkIOWithUnmask</a>.
--   
--   Asynchronous exceptions may still be received while in the masked
--   state if the masked thread <i>blocks</i> in certain ways; see
--   <a>Control.Exception#interruptible</a>.
--   
--   Threads created by <a>forkIO</a> inherit the <a>MaskingState</a> from
--   the parent; that is, to start a thread in the
--   <a>MaskedInterruptible</a> state, use <tt>mask_ $ forkIO ...</tt>.
--   This is particularly useful if you need to establish an exception
--   handler in the forked thread before any asynchronous exceptions are
--   received. To create a new thread in an unmasked state use
--   <a>forkIOWithUnmask</a>.
mask :: ((forall a. () => IO a -> IO a) -> IO b) -> IO b

-- | Like <a>mask</a>, but does not pass a <tt>restore</tt> action to the
--   argument.
mask_ :: IO a -> IO a

-- | Like <a>mask</a>, but the masked computation is not interruptible (see
--   <a>Control.Exception#interruptible</a>). THIS SHOULD BE USED WITH
--   GREAT CARE, because if a thread executing in
--   <a>uninterruptibleMask</a> blocks for any reason, then the thread (and
--   possibly the program, if this is the main thread) will be unresponsive
--   and unkillable. This function should only be necessary if you need to
--   mask exceptions around an interruptible operation, and you can
--   guarantee that the interruptible operation will only block for a short
--   period of time.
uninterruptibleMask :: ((forall a. () => IO a -> IO a) -> IO b) -> IO b

-- | Like <a>uninterruptibleMask</a>, but does not pass a <tt>restore</tt>
--   action to the argument.
uninterruptibleMask_ :: IO a -> IO a

-- | Describes the behaviour of a thread when an asynchronous exception is
--   received.
data MaskingState

-- | asynchronous exceptions are unmasked (the normal state)
Unmasked :: MaskingState

-- | the state during <a>mask</a>: asynchronous exceptions are masked, but
--   blocking operations may still be interrupted
MaskedInterruptible :: MaskingState

-- | the state during <a>uninterruptibleMask</a>: asynchronous exceptions
--   are masked, and blocking operations may not be interrupted
MaskedUninterruptible :: MaskingState

-- | Returns the <a>MaskingState</a> for the current thread.
getMaskingState :: IO MaskingState

-- | Allow asynchronous exceptions to be raised even inside <a>mask</a>,
--   making the operation interruptible (see the discussion of
--   "Interruptible operations" in <a>Exception</a>).
--   
--   When called outside <a>mask</a>, or inside <a>uninterruptibleMask</a>,
--   this function has no effect.
interruptible :: IO a -> IO a

-- | When invoked inside <a>mask</a>, this function allows a masked
--   asynchronous exception to be raised, if one exists. It is equivalent
--   to performing an interruptible operation (see #interruptible), but
--   does not involve any actual blocking.
--   
--   When called outside <a>mask</a>, or inside <a>uninterruptibleMask</a>,
--   this function has no effect.
allowInterrupt :: IO ()

-- | If the first argument evaluates to <a>True</a>, then the result is the
--   second argument. Otherwise an <a>AssertionFailed</a> exception is
--   raised, containing a <a>String</a> with the source file and line
--   number of the call to <a>assert</a>.
--   
--   Assertions can normally be turned on or off with a compiler flag (for
--   GHC, assertions are normally on unless optimisation is turned on with
--   <tt>-O</tt> or the <tt>-fignore-asserts</tt> option is given). When
--   assertions are turned off, the first argument to <a>assert</a> is
--   ignored, and the second argument is returned as the result.
assert :: Bool -> a -> a

-- | When you want to acquire a resource, do some work with it, and then
--   release the resource, it is a good idea to use <a>bracket</a>, because
--   <a>bracket</a> will install the necessary exception handler to release
--   the resource in the event that an exception is raised during the
--   computation. If an exception is raised, then <a>bracket</a> will
--   re-raise the exception (after performing the release).
--   
--   A common example is opening a file:
--   
--   <pre>
--   bracket
--     (openFile "filename" ReadMode)
--     (hClose)
--     (\fileHandle -&gt; do { ... })
--   </pre>
--   
--   The arguments to <a>bracket</a> are in this order so that we can
--   partially apply it, e.g.:
--   
--   <pre>
--   withFile name mode = bracket (openFile name mode) hClose
--   </pre>
--   
--   Bracket wraps the release action with <a>mask</a>, which is sufficient
--   to ensure that the release action executes to completion when it does
--   not invoke any interruptible actions, even in the presence of
--   asynchronous exceptions. For example, <tt>hClose</tt> is
--   uninterruptible when it is not racing other uses of the handle.
--   Similarly, closing a socket (from "network" package) is also
--   uninterruptible under similar conditions. An example of an
--   interruptible action is <a>killThread</a>. Completion of interruptible
--   release actions can be ensured by wrapping them in
--   <a>uninterruptibleMask_</a>, but this risks making the program
--   non-responsive to <tt>Control-C</tt>, or timeouts. Another option is
--   to run the release action asynchronously in its own thread:
--   
--   <pre>
--   void $ uninterruptibleMask_ $ forkIO $ do { ... }
--   </pre>
--   
--   The resource will be released as soon as possible, but the thread that
--   invoked bracket will not block in an uninterruptible state.
bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c

-- | A variant of <a>bracket</a> where the return value from the first
--   computation is not required.
bracket_ :: IO a -> IO b -> IO c -> IO c

-- | Like <a>bracket</a>, but only performs the final action if there was
--   an exception raised by the in-between computation.
bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c

-- | A specialised variant of <a>bracket</a> with just a computation to run
--   afterward.
finally :: IO a -> IO b -> IO a

-- | Like <a>finally</a>, but only performs the final action if there was
--   an exception raised by the computation.
onException :: IO a -> IO b -> IO a

-- | Exception context represents a list of <a>ExceptionAnnotation</a>s.
--   These are attached to <tt>SomeException</tt>s via
--   <a>addExceptionContext</a> and can be used to capture various ad-hoc
--   metadata about the exception including backtraces and
--   application-specific context.
--   
--   <a>ExceptionContext</a>s can be merged via concatenation using the
--   <a>Semigroup</a> instance or <a>mergeExceptionContext</a>.
--   
--   Note that GHC will automatically solve implicit constraints of type
--   <a>ExceptionContext</a> with <a>emptyExceptionContext</a>.
data ExceptionContext
ExceptionContext :: [SomeExceptionAnnotation] -> ExceptionContext

-- | Execute an <a>IO</a> action, adding the given
--   <tt>ExceptionContext</tt> to any thrown synchronous exceptions.
annotateIO :: ExceptionAnnotation e => e -> IO a -> IO a

-- | <tt>WhileHandling</tt> is used to annotate rethrow exceptions. By
--   inspecting the <tt>WhileHandling</tt> annotation, all the places the
--   exception has been rethrow can be recovered.
data WhileHandling
WhileHandling :: SomeException -> WhileHandling
instance GHC.Internal.Base.Functor GHC.Internal.Control.Exception.Handler


-- | String I/O functions
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.IO.Handle.Text

-- | Computation <a>hWaitForInput</a> <tt>hdl t</tt> waits until input is
--   available on handle <tt>hdl</tt>. It returns <a>True</a> as soon as
--   input is available on <tt>hdl</tt>, or <a>False</a> if no input is
--   available within <tt>t</tt> milliseconds. Note that
--   <a>hWaitForInput</a> waits until one or more full <i>characters</i>
--   are available, which means that it needs to do decoding, and hence may
--   fail with a decoding error.
--   
--   If <tt>t</tt> is less than zero, then <tt>hWaitForInput</tt> waits
--   indefinitely.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   <li>a decoding error, if the input begins with an invalid byte
--   sequence in this Handle's encoding.</li>
--   </ul>
--   
--   NOTE for GHC users: unless you use the <tt>-threaded</tt> flag,
--   <tt>hWaitForInput hdl t</tt> where <tt>t &gt;= 0</tt> will block all
--   other Haskell threads for the duration of the call. It behaves like a
--   <tt>safe</tt> foreign call in this respect.
hWaitForInput :: Handle -> Int -> IO Bool

-- | Computation <a>hGetChar</a> <tt>hdl</tt> reads a character from the
--   file or channel managed by <tt>hdl</tt>, blocking until a character is
--   available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetChar :: Handle -> IO Char

-- | Computation <a>hGetLine</a> <tt>hdl</tt> reads a line from the file or
--   channel managed by <tt>hdl</tt>. <a>hGetLine</a> does not return the
--   newline as part of the result.
--   
--   A line is separated by the newline set with <a>hSetNewlineMode</a> or
--   <a>nativeNewline</a> by default. The read newline character(s) are not
--   returned as part of the result.
--   
--   If <a>hGetLine</a> encounters end-of-file at any point while reading
--   in the middle of a line, it is treated as a line terminator and the
--   (partial) line is returned.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file is encountered when reading
--   the <i>first</i> character of the line.</li>
--   </ul>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; withFile "/home/user/foo" ReadMode hGetLine &gt;&gt;= putStrLn
--   this is the first line of the file :O
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; withFile "/home/user/bar" ReadMode (replicateM 3 . hGetLine)
--   ["this is the first line","this is the second line","this is the third line"]
--   </pre>
hGetLine :: Handle -> IO String

-- | Computation <a>hGetContents</a> <tt>hdl</tt> returns the list of
--   characters corresponding to the unread portion of the channel or file
--   managed by <tt>hdl</tt>, which is put into an intermediate state,
--   <i>semi-closed</i>. In this state, <tt>hdl</tt> is effectively closed,
--   but items are read from <tt>hdl</tt> on demand and accumulated in a
--   special list returned by <a>hGetContents</a> <tt>hdl</tt>.
--   
--   Any operation that fails because a handle is closed, also fails if a
--   handle is semi-closed. The only exception is <a>hClose</a>. A
--   semi-closed handle becomes closed:
--   
--   <ul>
--   <li>if <a>hClose</a> is applied to it;</li>
--   <li>if an I/O error occurs when reading an item from the handle;</li>
--   <li>or once the entire contents of the handle has been read.</li>
--   </ul>
--   
--   Once a semi-closed handle becomes closed, the contents of the
--   associated list becomes fixed. The contents of this final list is only
--   partially specified: it will contain at least all the items of the
--   stream that were evaluated prior to the handle becoming closed.
--   
--   Any I/O errors encountered while a handle is semi-closed are simply
--   discarded.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetContents :: Handle -> IO String

-- | Computation <a>hPutChar</a> <tt>hdl ch</tt> writes the character
--   <tt>ch</tt> to the file or channel managed by <tt>hdl</tt>. Characters
--   may be buffered if buffering is enabled for <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full.</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutChar :: Handle -> Char -> IO ()

-- | Computation <a>hPutStr</a> <tt>hdl s</tt> writes the string <tt>s</tt>
--   to the file or channel managed by <tt>hdl</tt>.
--   
--   Note that <a>hPutStr</a> is not concurrency safe unless the
--   <a>BufferMode</a> of <tt>hdl</tt> is set to <a>LineBuffering</a> or
--   <a>BlockBuffering</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let f = forkIO . hPutStr stdout
--   
--   &gt;&gt;&gt; in do hSetBuffering stdout NoBuffering; f "This is a longer string"; f ":D"; f "Hello Haskell"; pure ()
--   This: HDiesl lao  lHoansgkeerl lstring
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let f = forkIO . hPutStr stdout
--   
--   &gt;&gt;&gt; in do hSetBuffering stdout LineBuffering; f "This is a longer string"; f ":D"; f "Hello Haskell"; pure ()
--   This is a longer string:DHello Haskell
--   </pre>
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full.</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutStr :: Handle -> String -> IO ()
commitBuffer' :: RawCharBuffer -> Int -> Int -> Bool -> Bool -> Handle__ -> IO CharBuffer

-- | <a>hGetBuf</a> <tt>hdl buf count</tt> reads data from the handle
--   <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is reached
--   or <tt>count</tt> 8-bit bytes have been read. It returns the number of
--   bytes actually read. This may be zero if EOF was reached before any
--   data was read (or if <tt>count</tt> is zero).
--   
--   <a>hGetBuf</a> never raises an EOF exception, instead it returns a
--   value smaller than <tt>count</tt>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBuf</a> will behave as if EOF was reached.
--   
--   <a>hGetBuf</a> ignores the prevailing <a>TextEncoding</a> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
hGetBuf :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hGetBufSome</a> <tt>hdl buf count</tt> reads data from the handle
--   <tt>hdl</tt> into the buffer <tt>buf</tt>. If there is any data
--   available to read, then <a>hGetBufSome</a> returns it immediately; it
--   only blocks if there is no data to be read.
--   
--   It returns the number of bytes actually read. This may be zero if EOF
--   was reached before any data was read (or if <tt>count</tt> is zero).
--   
--   <a>hGetBufSome</a> never raises an EOF exception, instead it returns a
--   value smaller than <tt>count</tt>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBufSome</a> will behave as if EOF was reached.
--   
--   <a>hGetBufSome</a> ignores the prevailing <a>TextEncoding</a> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
hGetBufSome :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hGetBufNonBlocking</a> <tt>hdl buf count</tt> reads data from the
--   handle <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is
--   reached, or <tt>count</tt> 8-bit bytes have been read, or there is no
--   more data available to read immediately.
--   
--   <a>hGetBufNonBlocking</a> is identical to <a>hGetBuf</a>, except that
--   it will never block waiting for data to become available, instead it
--   returns only whatever data is available. To wait for data to arrive
--   before calling <a>hGetBufNonBlocking</a>, use <a>hWaitForInput</a>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBufNonBlocking</a> will behave as if EOF was reached.
--   
--   <a>hGetBufNonBlocking</a> ignores the prevailing <a>TextEncoding</a>
--   and <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
--   
--   NOTE: on Windows, this function does not work correctly; it behaves
--   identically to <a>hGetBuf</a>.
hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hPutBuf</a> <tt>hdl buf count</tt> writes <tt>count</tt> 8-bit
--   bytes from the buffer <tt>buf</tt> to the handle <tt>hdl</tt>. It
--   returns ().
--   
--   <a>hPutBuf</a> ignores any text encoding that applies to the
--   <a>Handle</a>, writing the bytes directly to the underlying file or
--   device.
--   
--   <a>hPutBuf</a> ignores the prevailing <a>TextEncoding</a> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and writes bytes directly.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>ResourceVanished</a> if the handle is a pipe or socket, and the
--   reading end is closed. (If this is a POSIX system, and the program has
--   not asked to ignore SIGPIPE, then a SIGPIPE may be delivered instead,
--   whose default action is to terminate the program).</li>
--   </ul>
hPutBuf :: Handle -> Ptr a -> Int -> IO ()
hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
memcpy :: Ptr a -> Ptr a -> CSize -> IO (Ptr ())

-- | The same as <a>hPutStr</a>, but adds a newline character.
--   
--   This operation may fail with the same errors, and has the same issues
--   with concurrency, as <a>hPutStr</a>!
hPutStrLn :: Handle -> String -> IO ()

-- | The <a>hGetContents'</a> operation reads all input on the given handle
--   before returning it as a <a>String</a> and closing the handle.
--   
--   This is a strict version of <a>hGetContents</a>
hGetContents' :: Handle -> IO String


-- | An <tt><a>MVar</a> t</tt> is a mutable location that is either empty
--   or contains a value of type <tt>t</tt>. It has two fundamental
--   operations: <a>putMVar</a> which fills an <a>MVar</a> if it is empty
--   and blocks otherwise, and <a>takeMVar</a> which empties an <a>MVar</a>
--   if it is full and blocks otherwise. They can be used in multiple
--   different ways:
--   
--   <ol>
--   <li>As synchronized mutable variables,</li>
--   <li>As channels, with <a>takeMVar</a> and <a>putMVar</a> as receive
--   and send, and</li>
--   <li>As a binary semaphore <tt><a>MVar</a> ()</tt>, with
--   <a>takeMVar</a> and <a>putMVar</a> as wait and signal.</li>
--   </ol>
--   
--   They were introduced in the paper <a>"Concurrent Haskell"</a> by Simon
--   Peyton Jones, Andrew Gordon and Sigbjorn Finne, though some details of
--   their implementation have since then changed (in particular, a put on
--   a full <a>MVar</a> used to error, but now merely blocks.)
--   
--   <h3>Applicability</h3>
--   
--   <a>MVar</a>s offer more flexibility than <a>IORef</a>s, but less
--   flexibility than <a>STM</a>. They are appropriate for building
--   synchronization primitives and performing simple inter-thread
--   communication; however they are very simple and susceptible to race
--   conditions, deadlocks or uncaught exceptions. Do not use them if you
--   need to perform larger atomic operations such as reading from multiple
--   variables: use <a>STM</a> instead.
--   
--   In particular, the "bigger" functions in this module (<a>swapMVar</a>,
--   <a>withMVar</a>, <a>modifyMVar_</a> and <a>modifyMVar</a>) are simply
--   the composition of a <a>takeMVar</a> followed by a <a>putMVar</a> with
--   exception safety. These have atomicity guarantees only if all other
--   threads perform a <a>takeMVar</a> before a <a>putMVar</a> as well;
--   otherwise, they may block.
--   
--   <h3>Fairness</h3>
--   
--   No thread can be blocked indefinitely on an <a>MVar</a> unless another
--   thread holds that <a>MVar</a> indefinitely. One usual implementation
--   of this fairness guarantee is that threads blocked on an <a>MVar</a>
--   are served in a first-in-first-out fashion (this is what GHC does),
--   but this is not guaranteed in the semantics.
--   
--   <h3>Gotchas</h3>
--   
--   Like many other Haskell data structures, <a>MVar</a>s are lazy. This
--   means that if you place an expensive unevaluated thunk inside an
--   <a>MVar</a>, it will be evaluated by the thread that consumes it, not
--   the thread that produced it. Be sure to <a>evaluate</a> values to be
--   placed in an <a>MVar</a> to the appropriate normal form, or utilize a
--   strict <tt>MVar</tt> provided by the <a>strict-concurrency</a>
--   package.
--   
--   <h3>Ordering</h3>
--   
--   <a>MVar</a> operations are always observed to take place in the order
--   they are written in the program, regardless of the memory model of the
--   underlying machine. This is in contrast to <a>IORef</a> operations
--   which may appear out-of-order to another thread in some cases.
--   
--   <h3>Example</h3>
--   
--   Consider the following concurrent data structure, a skip channel. This
--   is a channel for an intermittent source of high bandwidth information
--   (for example, mouse movement events.) Writing to the channel never
--   blocks, and reading from the channel only returns the most recent
--   value, or blocks if there are no new values. Multiple readers are
--   supported with a <tt>dupSkipChan</tt> operation.
--   
--   A skip channel is a pair of <a>MVar</a>s. The first <a>MVar</a>
--   contains the current value, and a list of semaphores that need to be
--   notified when it changes. The second <a>MVar</a> is a semaphore for
--   this particular reader: it is full if there is a value in the channel
--   that this reader has not read yet, and empty otherwise.
--   
--   <pre>
--   data SkipChan a = SkipChan (MVar (a, [MVar ()])) (MVar ())
--   
--   newSkipChan :: IO (SkipChan a)
--   newSkipChan = do
--       sem &lt;- newEmptyMVar
--       main &lt;- newMVar (undefined, [sem])
--       return (SkipChan main sem)
--   
--   putSkipChan :: SkipChan a -&gt; a -&gt; IO ()
--   putSkipChan (SkipChan main _) v = do
--       (_, sems) &lt;- takeMVar main
--       putMVar main (v, [])
--       mapM_ (\sem -&gt; putMVar sem ()) sems
--   
--   getSkipChan :: SkipChan a -&gt; IO a
--   getSkipChan (SkipChan main sem) = do
--       takeMVar sem
--       (v, sems) &lt;- takeMVar main
--       putMVar main (v, sem : sems)
--       return v
--   
--   dupSkipChan :: SkipChan a -&gt; IO (SkipChan a)
--   dupSkipChan (SkipChan main _) = do
--       sem &lt;- newEmptyMVar
--       (v, sems) &lt;- takeMVar main
--       putMVar main (v, sem : sems)
--       return (SkipChan main sem)
--   </pre>
--   
--   This example was adapted from the original Concurrent Haskell paper.
--   For more examples of <a>MVar</a>s being used to build higher-level
--   synchronization primitives, see <a>Chan</a> and <a>QSem</a>.
module GHC.Internal.Control.Concurrent.MVar

-- | An <a>MVar</a> (pronounced "em-var") is a synchronising variable, used
--   for communication between concurrent threads. It can be thought of as
--   a box, which may be empty or full.
data MVar a

-- | Create an <a>MVar</a> which is initially empty.
newEmptyMVar :: IO (MVar a)

-- | Create an <a>MVar</a> which contains the supplied value.
newMVar :: a -> IO (MVar a)

-- | Return the contents of the <a>MVar</a>. If the <a>MVar</a> is
--   currently empty, <a>takeMVar</a> will wait until it is full. After a
--   <a>takeMVar</a>, the <a>MVar</a> is left empty.
--   
--   There are two further important properties of <a>takeMVar</a>:
--   
--   <ul>
--   <li><a>takeMVar</a> is single-wakeup. That is, if there are multiple
--   threads blocked in <a>takeMVar</a>, and the <a>MVar</a> becomes full,
--   only one thread will be woken up. The runtime guarantees that the
--   woken thread completes its <a>takeMVar</a> operation.</li>
--   <li>When multiple threads are blocked on an <a>MVar</a>, they are
--   woken up in FIFO order. This is useful for providing fairness
--   properties of abstractions built using <a>MVar</a>s.</li>
--   </ul>
takeMVar :: MVar a -> IO a

-- | Put a value into an <a>MVar</a>. If the <a>MVar</a> is currently full,
--   <a>putMVar</a> will wait until it becomes empty.
--   
--   There are two further important properties of <a>putMVar</a>:
--   
--   <ul>
--   <li><a>putMVar</a> is single-wakeup. That is, if there are multiple
--   threads blocked in <a>putMVar</a>, and the <a>MVar</a> becomes empty,
--   only one thread will be woken up. The runtime guarantees that the
--   woken thread completes its <a>putMVar</a> operation.</li>
--   <li>When multiple threads are blocked on an <a>MVar</a>, they are
--   woken up in FIFO order. This is useful for providing fairness
--   properties of abstractions built using <a>MVar</a>s.</li>
--   </ul>
putMVar :: MVar a -> a -> IO ()

-- | Atomically read the contents of an <a>MVar</a>. If the <a>MVar</a> is
--   currently empty, <a>readMVar</a> will wait until it is full.
--   <a>readMVar</a> is guaranteed to receive the next <a>putMVar</a>.
--   
--   <a>readMVar</a> is multiple-wakeup, so when multiple readers are
--   blocked on an <a>MVar</a>, all of them are woken up at the same time.
--   The runtime guarantees that all woken threads complete their
--   <a>readMVar</a> operation.
--   
--   <i>Compatibility note:</i> Prior to base 4.7, <a>readMVar</a> was a
--   combination of <a>takeMVar</a> and <a>putMVar</a>. This mean that in
--   the presence of other threads attempting to <a>putMVar</a>,
--   <a>readMVar</a> could block. Furthermore, <a>readMVar</a> would not
--   receive the next <a>putMVar</a> if there was already a pending thread
--   blocked on <a>takeMVar</a>. The old behavior can be recovered by
--   implementing 'readMVar as follows:
--   
--   <pre>
--   readMVar :: MVar a -&gt; IO a
--   readMVar m =
--     mask_ $ do
--       a &lt;- takeMVar m
--       putMVar m a
--       return a
--   </pre>
readMVar :: MVar a -> IO a

-- | Take a value from an <a>MVar</a>, put a new value into the <a>MVar</a>
--   and return the value taken. This function is atomic only if there are
--   no other producers for this <a>MVar</a>. In other words, it cannot
--   guarantee that, by the time <a>swapMVar</a> gets the chance to write
--   to the MVar, the value of the MVar has not been altered by a write
--   operation from another thread.
swapMVar :: MVar a -> a -> IO a

-- | A non-blocking version of <a>takeMVar</a>. The <a>tryTakeMVar</a>
--   function returns immediately, with <a>Nothing</a> if the <a>MVar</a>
--   was empty, or <tt><a>Just</a> a</tt> if the <a>MVar</a> was full with
--   contents <tt>a</tt>. After <a>tryTakeMVar</a>, the <a>MVar</a> is left
--   empty.
tryTakeMVar :: MVar a -> IO (Maybe a)

-- | A non-blocking version of <a>putMVar</a>. The <a>tryPutMVar</a>
--   function attempts to put the value <tt>a</tt> into the <a>MVar</a>,
--   returning <a>True</a> if it was successful, or <a>False</a> otherwise.
tryPutMVar :: MVar a -> a -> IO Bool

-- | Check whether a given <a>MVar</a> is empty.
--   
--   Notice that the boolean value returned is just a snapshot of the state
--   of the MVar. By the time you get to react on its result, the MVar may
--   have been filled (or emptied) - so be extremely careful when using
--   this operation. Use <a>tryTakeMVar</a> instead if possible.
isEmptyMVar :: MVar a -> IO Bool

-- | <a>withMVar</a> is an exception-safe wrapper for operating on the
--   contents of an <a>MVar</a>. This operation is exception-safe: it will
--   replace the original contents of the <a>MVar</a> if an exception is
--   raised (see <a>Control.Exception</a>). However, it is only atomic if
--   there are no other producers for this <a>MVar</a>. In other words, it
--   cannot guarantee that, by the time <a>withMVar</a> gets the chance to
--   write to the MVar, the value of the MVar has not been altered by a
--   write operation from another thread.
withMVar :: MVar a -> (a -> IO b) -> IO b

-- | Like <a>withMVar</a>, but the <tt>IO</tt> action in the second
--   argument is executed with asynchronous exceptions masked.
withMVarMasked :: MVar a -> (a -> IO b) -> IO b

-- | An exception-safe wrapper for modifying the contents of an
--   <a>MVar</a>. Like <a>withMVar</a>, <a>modifyMVar</a> will replace the
--   original contents of the <a>MVar</a> if an exception is raised during
--   the operation. This function is only atomic if there are no other
--   producers for this <a>MVar</a>. In other words, it cannot guarantee
--   that, by the time <a>modifyMVar_</a> gets the chance to write to the
--   MVar, the value of the MVar has not been altered by a write operation
--   from another thread.
modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()

-- | A slight variation on <a>modifyMVar_</a> that allows a value to be
--   returned (<tt>b</tt>) in addition to the modified value of the
--   <a>MVar</a>.
modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b

-- | Like <a>modifyMVar_</a>, but the <tt>IO</tt> action in the second
--   argument is executed with asynchronous exceptions masked.
modifyMVarMasked_ :: MVar a -> (a -> IO a) -> IO ()

-- | Like <a>modifyMVar</a>, but the <tt>IO</tt> action in the second
--   argument is executed with asynchronous exceptions masked.
modifyMVarMasked :: MVar a -> (a -> IO (a, b)) -> IO b

-- | A non-blocking version of <a>readMVar</a>. The <a>tryReadMVar</a>
--   function returns immediately, with <a>Nothing</a> if the <a>MVar</a>
--   was empty, or <tt><a>Just</a> a</tt> if the <a>MVar</a> was full with
--   contents <tt>a</tt>.
tryReadMVar :: MVar a -> IO (Maybe a)

-- | Make a <a>Weak</a> pointer to an <a>MVar</a>, using the second
--   argument as a finalizer to run when the <a>MVar</a> is
--   garbage-collected
mkWeakMVar :: MVar a -> IO () -> IO (Weak (MVar a))

-- | <i>Deprecated: use <a>mkWeakMVar</a> instead</i>
addMVarFinalizer :: MVar a -> IO () -> IO ()


-- | Bound thread support.
module GHC.Internal.Conc.Bound

-- | Like <a>forkIO</a>, this sparks off a new thread to run the <a>IO</a>
--   computation passed as the first argument, and returns the
--   <a>ThreadId</a> of the newly created thread.
--   
--   However, <a>forkOS</a> creates a <i>bound</i> thread, which is
--   necessary if you need to call foreign (non-Haskell) libraries that
--   make use of thread-local state, such as OpenGL (see
--   <a>Control.Concurrent#boundthreads</a>).
--   
--   Using <a>forkOS</a> instead of <a>forkIO</a> makes no difference at
--   all to the scheduling behaviour of the Haskell runtime system. It is a
--   common misconception that you need to use <a>forkOS</a> instead of
--   <a>forkIO</a> to avoid blocking all the Haskell threads when making a
--   foreign call; this isn't the case. To allow foreign calls to be made
--   without blocking all the Haskell threads (with GHC), it is only
--   necessary to use the <tt>-threaded</tt> option when linking your
--   program, and to make sure the foreign import is not marked
--   <tt>unsafe</tt>.
forkOS :: IO () -> IO ThreadId

-- | Like <a>forkIOWithUnmask</a>, but the child thread is a bound thread,
--   as with <a>forkOS</a>.
forkOSWithUnmask :: ((forall a. () => IO a -> IO a) -> IO ()) -> IO ThreadId

-- | Returns <a>True</a> if the calling thread is <i>bound</i>, that is, if
--   it is safe to use foreign libraries that rely on thread-local state
--   from the calling thread.
isCurrentThreadBound :: IO Bool

-- | Run the <a>IO</a> computation passed as the first argument. If the
--   calling thread is not <i>bound</i>, a bound thread is created
--   temporarily. <tt>runInBoundThread</tt> doesn't finish until the
--   <a>IO</a> computation finishes.
--   
--   You can wrap a series of foreign function calls that rely on
--   thread-local state with <tt>runInBoundThread</tt> so that you can use
--   them without knowing whether the current thread is <i>bound</i>.
runInBoundThread :: IO a -> IO a

-- | Run the <a>IO</a> computation passed as the first argument. If the
--   calling thread is <i>bound</i>, an unbound thread is created
--   temporarily using <a>forkIO</a>. <tt>runInBoundThread</tt> doesn't
--   finish until the <a>IO</a> computation finishes.
--   
--   Use this function <i>only</i> in the rare case that you have actually
--   observed a performance loss due to the use of bound threads. A program
--   that doesn't need its main thread to be bound and makes <i>heavy</i>
--   use of concurrency (e.g. a web server), might want to wrap its
--   <tt>main</tt> action in <tt>runInUnboundThread</tt>.
--   
--   Note that exceptions which are thrown to the current thread are thrown
--   in turn to the thread that is executing the given computation. This
--   ensures there's always a way of killing the forked thread.
runInUnboundThread :: IO a -> IO a

-- | <a>True</a> if bound threads are supported. If
--   <tt>rtsSupportsBoundThreads</tt> is <a>False</a>,
--   <a>isCurrentThreadBound</a> will always return <a>False</a> and both
--   <a>forkOS</a> and <a>runInBoundThread</a> will fail.
rtsSupportsBoundThreads :: Bool

module GHC.Internal.Conc.Signal
type Signal = CInt
type HandlerFun = ForeignPtr Word8 -> IO ()
setHandler :: Signal -> Maybe (HandlerFun, Dynamic) -> IO (Maybe (HandlerFun, Dynamic))
runHandlers :: ForeignPtr Word8 -> Signal -> IO ()
runHandlersPtr :: Ptr Word8 -> Signal -> IO ()

module GHC.Internal.Clock

-- | Return monotonic time in seconds, since some unspecified starting
--   point
getMonotonicTime :: IO Double

-- | Return monotonic time in nanoseconds, since some unspecified starting
--   point
getMonotonicTimeNSec :: IO Word64


-- | Basic concurrency stuff.
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.Conc.IO
ensureIOManagerIsRunning :: IO ()
ioManagerCapabilitiesChanged :: IO ()

-- | Interrupts the current wait of the I/O manager if it is currently
--   blocked. This instructs it to re-read how much it should wait and to
--   process any pending events.
interruptIOManager :: IO ()

-- | Suspends the current thread for a given number of microseconds (GHC
--   only).
--   
--   There is no guarantee that the thread will be rescheduled promptly
--   when the delay has expired, but the thread will never continue to run
--   <i>earlier</i> than specified.
--   
--   Be careful not to exceed <tt>maxBound :: Int</tt>, which on 32-bit
--   machines is only 2147483647 μs, less than 36 minutes. Consider using
--   <tt>Control.Concurrent.Thread.Delay.delay</tt> from
--   <tt>unbounded-delays</tt> package.
threadDelay :: Int -> IO ()

-- | Switch the value of returned <a>TVar</a> from initial value
--   <a>False</a> to <a>True</a> after a given number of microseconds. The
--   caveats associated with <a>threadDelay</a> also apply.
--   
--   Be careful not to exceed <tt>maxBound :: Int</tt>, which on 32-bit
--   machines is only 2147483647 μs, less than 36 minutes.
registerDelay :: Int -> IO (TVar Bool)

-- | Block the current thread until data is available to read on the given
--   file descriptor (GHC only).
--   
--   This will throw an <a>IOError</a> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitRead</a>, use <a>closeFdWith</a>.
threadWaitRead :: Fd -> IO ()

-- | Block the current thread until data can be written to the given file
--   descriptor (GHC only).
--   
--   This will throw an <a>IOError</a> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitWrite</a>, use <a>closeFdWith</a>.
threadWaitWrite :: Fd -> IO ()

-- | Returns an STM action that can be used to wait for data to read from a
--   file descriptor. The second returned value is an IO action that can be
--   used to deregister interest in the file descriptor.
threadWaitReadSTM :: Fd -> IO (STM (), IO ())

-- | Returns an STM action that can be used to wait until data can be
--   written to a file descriptor. The second returned value is an IO
--   action that can be used to deregister interest in the file descriptor.
threadWaitWriteSTM :: Fd -> IO (STM (), IO ())

-- | Close a file descriptor in a concurrency-safe way (GHC only). If you
--   are using <a>threadWaitRead</a> or <a>threadWaitWrite</a> to perform
--   blocking I/O, you <i>must</i> use this function to close file
--   descriptors, or blocked threads may not be woken.
--   
--   Any threads that are blocked on the file descriptor via
--   <a>threadWaitRead</a> or <a>threadWaitWrite</a> will be unblocked by
--   having IO exceptions thrown.
closeFdWith :: (Fd -> IO ()) -> Fd -> IO ()


-- | Raw read/write operations on file descriptors
module GHC.Internal.IO.FD
data FD
FD :: {-# UNPACK #-} !CInt -> {-# UNPACK #-} !Int -> FD
[fdFD] :: FD -> {-# UNPACK #-} !CInt

-- | On Unix we need to know whether this <a>FD</a> has <tt>O_NONBLOCK</tt>
--   set. If it has, then we can use more efficient routines (namely,
--   unsafe FFI) to read/write to it. Otherwise safe FFI is used.
--   
--   <tt>O_NONBLOCK</tt> has no effect on regular files and block devices
--   at the moment, thus this flag should be off for them. While reading
--   from a file cannot block indefinitely (as opposed to reading from a
--   socket or a pipe), it can block the entire runtime for a "brief"
--   moment of time: you cannot read a file from a floppy drive or network
--   share without delay.
[fdIsNonBlocking] :: FD -> {-# UNPACK #-} !Int

-- | Open a file and make an <a>FD</a> for it. Truncates the file to zero
--   size when the <a>IOMode</a> is <a>WriteMode</a>.
--   
--   <a>openFileWith</a> takes two actions, <tt>act1</tt> and
--   <tt>act2</tt>, to perform after opening the file.
--   
--   <tt>act1</tt> is passed a file descriptor and I/O device type for the
--   newly opened file. If an exception occurs in <tt>act1</tt>, then the
--   file will be closed. <tt>act1</tt> <i>must not</i> close the file
--   itself. If it does so and then receives an exception, then the
--   exception handler will attempt to close it again, which is
--   impermissible.
--   
--   <tt>act2</tt> is performed with asynchronous exceptions masked. It is
--   passed a function to restore the masking state and the result of
--   <tt>act1</tt>. It /must not/ throw an exception (or deliver one via an
--   interruptible operation) without first closing the file or arranging
--   for it to be closed. <tt>act2</tt> <i>may</i> close the file, but is
--   not required to do so. If <tt>act2</tt> leaves the file open, then the
--   file will remain open on return from <a>openFileWith</a>.
--   
--   Code calling <a>openFileWith</a> that wishes to install a finalizer to
--   close the file should do so in <tt>act2</tt>. Doing so in
--   <tt>act1</tt> could potentially close the file in the finalizer first
--   and then in the exception handler. See <a>openFile'</a> for an example
--   of this use. Regardless, the caller is responsible for ensuring that
--   the file is eventually closed, perhaps using <a>bracket</a>.
openFileWith :: FilePath -> IOMode -> Bool -> (FD -> IODeviceType -> IO r) -> ((forall x. () => IO x -> IO x) -> r -> IO s) -> IO s

-- | Open a file and make an <a>FD</a> for it. Truncates the file to zero
--   size when the <a>IOMode</a> is <a>WriteMode</a>. This function is
--   difficult to use without potentially leaking the file descriptor on
--   exception. In particular, it must be used with exceptions masked,
--   which is a bit rude because the thread will be uninterruptible while
--   the file path is being encoded. Use <a>openFileWith</a> instead.
openFile :: FilePath -> IOMode -> Bool -> IO (FD, IODeviceType)

-- | Make a <a>FD</a> from an existing file descriptor. Fails if the FD
--   refers to a directory. If the FD refers to a file, <a>mkFD</a> locks
--   the file according to the Haskell 2010 single writer/multiple reader
--   locking semantics (this is why we need the <a>IOMode</a> argument
--   too).
mkFD :: CInt -> IOMode -> Maybe (IODeviceType, CDev, CIno) -> Bool -> Bool -> IO (FD, IODeviceType)
release :: FD -> IO ()
setNonBlockingMode :: FD -> Bool -> IO FD
readRawBufferPtr :: String -> FD -> Ptr Word8 -> Int -> CSize -> IO Int
readRawBufferPtrNoBlock :: String -> FD -> Ptr Word8 -> Int -> CSize -> IO Int
writeRawBufferPtr :: String -> FD -> Ptr Word8 -> Int -> CSize -> IO CInt
stdin :: FD
stdout :: FD
stderr :: FD
instance GHC.Internal.IO.BufferedIO.BufferedIO GHC.Internal.IO.FD.FD
instance GHC.Internal.IO.Device.IODevice GHC.Internal.IO.FD.FD
instance GHC.Internal.IO.Device.RawIO GHC.Internal.IO.FD.FD
instance GHC.Internal.Show.Show GHC.Internal.IO.FD.FD


-- | Handle operations implemented by file descriptors (FDs)
module GHC.Internal.IO.Handle.FD

-- | A handle managing input from the Haskell program's standard input
--   channel.
stdin :: Handle

-- | A handle managing output to the Haskell program's standard output
--   channel.
stdout :: Handle

-- | A handle managing output to the Haskell program's standard error
--   channel.
stderr :: Handle

-- | Computation <a>openFile</a> <tt>file mode</tt> allocates and returns a
--   new, open handle to manage the file <tt>file</tt>. It manages input if
--   <tt>mode</tt> is <a>ReadMode</a>, output if <tt>mode</tt> is
--   <a>WriteMode</a> or <a>AppendMode</a>, and both input and output if
--   mode is <a>ReadWriteMode</a>.
--   
--   If the file does not exist and it is opened for output, it should be
--   created as a new file. If <tt>mode</tt> is <a>WriteMode</a> and the
--   file already exists, then it should be truncated to zero length. Some
--   operating systems delete empty files, so there is no guarantee that
--   the file will exist following an <a>openFile</a> with <tt>mode</tt>
--   <a>WriteMode</a> unless it is subsequently written to successfully.
--   The handle is positioned at the end of the file if <tt>mode</tt> is
--   <a>AppendMode</a>, and otherwise at the beginning (in which case its
--   internal position is 0). The initial buffer mode is
--   implementation-dependent.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isAlreadyInUseError</a> if the file is already open and cannot
--   be reopened;</li>
--   <li><a>isDoesNotExistError</a> if the file does not exist or (on POSIX
--   systems) is a FIFO without a reader and <a>WriteMode</a> was
--   requested; or</li>
--   <li><a>isPermissionError</a> if the user does not have permission to
--   open the file.</li>
--   </ul>
--   
--   On POSIX systems, <a>openFile</a> is an <i>interruptible operation</i>
--   as described in <a>Control.Exception</a>.
--   
--   Note: if you will be working with files containing binary data, you'll
--   want to be using <a>openBinaryFile</a>.
openFile :: FilePath -> IOMode -> IO Handle

-- | <tt><a>withFile</a> name mode act</tt> opens a file like
--   <a>openFile</a> and passes the resulting handle to the computation
--   <tt>act</tt>. The handle will be closed on exit from <a>withFile</a>,
--   whether by normal termination or by raising an exception. If closing
--   the handle raises an exception, then this exception will be raised by
--   <a>withFile</a> rather than any exception raised by <tt>act</tt>.
withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r

-- | Like <a>openFile</a>, but open the file in binary mode. On Windows,
--   reading a file in text mode (which is the default) will translate CRLF
--   to LF, and writing will translate LF to CRLF. This is usually what you
--   want with text files. With binary files this is undesirable; also, as
--   usual under Microsoft operating systems, text mode treats control-Z as
--   EOF. Binary mode turns off all special treatment of end-of-line and
--   end-of-file characters. (See also <a>hSetBinaryMode</a>.)
openBinaryFile :: FilePath -> IOMode -> IO Handle

-- | A version of <a>openBinaryFile</a> that takes an action to perform
--   with the handle. If an exception occurs in the action, then the file
--   will be closed automatically. The action <i>should</i> close the file
--   when finished with it so the file does not remain open until the
--   garbage collector collects the handle.
withBinaryFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r

-- | Like <a>openFile</a>, but opens the file in ordinary blocking mode.
--   This can be useful for opening a FIFO for writing: if we open in
--   non-blocking mode then the open will fail if there are no readers,
--   whereas a blocking open will block until a reader appear.
--   
--   Note: when blocking happens, an OS thread becomes tied up with the
--   processing, so the program must have at least another OS thread if it
--   wants to unblock itself. By corollary, a non-threaded runtime will
--   need a process-external trigger in order to become unblocked.
--   
--   On POSIX systems, <a>openFileBlocking</a> is an <i>interruptible
--   operation</i> as described in <a>Control.Exception</a>.
openFileBlocking :: FilePath -> IOMode -> IO Handle

-- | <tt><a>withFileBlocking</a> name mode act</tt> opens a file like
--   <a>openFileBlocking</a> and passes the resulting handle to the
--   computation <tt>act</tt>. The handle will be closed on exit from
--   <a>withFileBlocking</a>, whether by normal termination or by raising
--   an exception. If closing the handle raises an exception, then this
--   exception will be raised by <a>withFile</a> rather than any exception
--   raised by <tt>act</tt>.
withFileBlocking :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
mkHandleFromFD :: FD -> IODeviceType -> FilePath -> IOMode -> Bool -> Maybe TextEncoding -> IO Handle

-- | Turn an existing file descriptor into a Handle. This is used by
--   various external libraries to make Handles.
--   
--   Makes a binary Handle. This is for historical reasons; it should
--   probably be a text Handle with the default encoding and newline
--   translation instead.
fdToHandle :: FD -> IO Handle

-- | Old API kept to avoid breaking clients
fdToHandle' :: CInt -> Maybe IODeviceType -> Bool -> FilePath -> IOMode -> Bool -> IO Handle

-- | Turn an existing Handle into a file descriptor. This function throws
--   an IOError if the Handle does not reference a file descriptor.
handleToFd :: Handle -> IO FD


-- | This model abstracts away the platform specific handles that can be
--   toggled through the RTS.
module GHC.Internal.IO.StdHandles

-- | <a>stdin</a> is a handle managing the programs standard input.
stdin :: Handle

-- | <a>stdout</a> is a handle managing the programs standard output.
stdout :: Handle

-- | <a>stderr</a> is a handle managing the programs standard error.
stderr :: Handle

-- | The computation <tt><a>openFile</a> path mode</tt> returns a file
--   handle that can be used to interact with the file.
--   
--   The handle is open in text mode with <a>localeEncoding</a>. You can
--   change the encoding with <a>hSetEncoding</a>.
openFile :: FilePath -> IOMode -> IO Handle

-- | The computation <tt><a>openBinaryFile</a> path mode</tt> returns a
--   file handle that can be used to interact with the binary file.
--   
--   This is different from <a>openFile</a> as in that it does not use any
--   file encoding.
openBinaryFile :: FilePath -> IOMode -> IO Handle
openFileBlocking :: FilePath -> IOMode -> IO Handle

-- | The computation <tt><a>withFile</a> path mode action</tt> opens the
--   file and runs <tt>action</tt> with the obtained handle before closing
--   the file.
--   
--   Even when an exception is raised within the <tt>action</tt>, the file
--   will still be closed. This is why <tt><a>withFile</a> path mode
--   act</tt> is preferable to
--   
--   <pre>
--   <a>openFile</a> path mode &gt;&gt;= (\hdl -&gt; act hdl &gt;&gt;= <a>hClose</a> hdl)
--   </pre>
--   
--   See also: <a>bracket</a>
withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r

-- | The computation <tt><a>withBinaryFile</a> path mode action</tt> opens
--   the binary file and runs <tt>action</tt> with the obtained handle
--   before closing the binary file.
--   
--   This is different from <a>withFile</a> as in that it does not use any
--   file encoding.
--   
--   Even when an exception is raised within the <tt>action</tt>, the file
--   will still be closed. This is why <tt><a>withBinaryFile</a> path mode
--   act</tt> is preferable to
--   
--   <pre>
--   <a>openBinaryFile</a> path mode &gt;&gt;= (\hdl -&gt; act hdl &gt;&gt;= <a>hClose</a> hdl)
--   </pre>
--   
--   See also: <a>bracket</a>
withBinaryFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
withFileBlocking :: FilePath -> IOMode -> (Handle -> IO r) -> IO r

module GHC.Internal.IO.Handle.Lock

-- | Exception thrown by <tt>hLock</tt> on non-Windows platforms that don't
--   support <tt>flock</tt>.
data FileLockingNotSupported
FileLockingNotSupported :: FileLockingNotSupported

-- | Indicates a mode in which a file should be locked.
data LockMode
SharedLock :: LockMode
ExclusiveLock :: LockMode

-- | If a <a>Handle</a> references a file descriptor, attempt to lock
--   contents of the underlying file in appropriate mode. If the file is
--   already locked in incompatible mode, this function blocks until the
--   lock is established. The lock is automatically released upon closing a
--   <a>Handle</a>.
--   
--   Things to be aware of:
--   
--   1) This function may block inside a C call. If it does, in order to be
--   able to interrupt it with asynchronous exceptions and/or for other
--   threads to continue working, you MUST use threaded version of the
--   runtime system.
--   
--   2) The implementation uses <tt>LockFileEx</tt> on Windows and
--   <tt>flock</tt> otherwise, hence all of their caveats also apply here.
--   
--   3) On non-Windows platforms that don't support <tt>flock</tt> (e.g.
--   Solaris) this function throws <tt>FileLockingNotImplemented</tt>. We
--   deliberately choose to not provide fcntl based locking instead because
--   of its broken semantics.
hLock :: Handle -> LockMode -> IO ()

-- | Non-blocking version of <a>hLock</a>.
--   
--   Returns <a>True</a> if taking the lock was successful and <a>False</a>
--   otherwise.
hTryLock :: Handle -> LockMode -> IO Bool

-- | Release a lock taken with <a>hLock</a> or <a>hTryLock</a>.
hUnlock :: Handle -> IO ()


-- | External API for GHC's Handle implementation
module GHC.Internal.IO.Handle

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
data Handle

-- | Three kinds of buffering are supported: line-buffering,
--   block-buffering or no-buffering. These modes have the following
--   effects. For output, items are written out, or <i>flushed</i>, from
--   the internal buffer according to the buffer mode:
--   
--   <ul>
--   <li><i>line-buffering</i>: the entire output buffer is flushed
--   whenever a newline is output, the buffer overflows, a <a>hFlush</a> is
--   issued, or the handle is closed.</li>
--   <li><i>block-buffering</i>: the entire buffer is written out whenever
--   it overflows, a <a>hFlush</a> is issued, or the handle is closed.</li>
--   <li><i>no-buffering</i>: output is written immediately, and never
--   stored in the buffer.</li>
--   </ul>
--   
--   An implementation is free to flush the buffer more frequently, but not
--   less frequently, than specified above. The output buffer is emptied as
--   soon as it has been written out.
--   
--   Similarly, input occurs according to the buffer mode for the handle:
--   
--   <ul>
--   <li><i>line-buffering</i>: when the buffer for the handle is not
--   empty, the next item is obtained from the buffer; otherwise, when the
--   buffer is empty, characters up to and including the next newline
--   character are read into the buffer. No characters are available until
--   the newline character is available or the buffer is full.</li>
--   <li><i>block-buffering</i>: when the buffer for the handle becomes
--   empty, the next block of data is read into the buffer.</li>
--   <li><i>no-buffering</i>: the next input item is read and returned. The
--   <a>hLookAhead</a> operation implies that even a no-buffered handle may
--   require a one-character buffer.</li>
--   </ul>
--   
--   The default buffering mode when a handle is opened is
--   implementation-dependent and may depend on the file system object
--   which is attached to that handle. For most implementations, physical
--   files will normally be block-buffered and terminals will normally be
--   line-buffered.
data BufferMode

-- | buffering is disabled if possible.
NoBuffering :: BufferMode

-- | line-buffering should be enabled if possible.
LineBuffering :: BufferMode

-- | block-buffering should be enabled if possible. The size of the buffer
--   is <tt>n</tt> items if the argument is <a>Just</a> <tt>n</tt> and is
--   otherwise implementation-dependent.
BlockBuffering :: Maybe Int -> BufferMode

-- | makes a new <a>Handle</a>
mkFileHandle :: (RawIO dev, IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> IOMode -> Maybe TextEncoding -> NewlineMode -> IO Handle

-- | like <a>mkFileHandle</a>, except that a <a>Handle</a> is created with
--   two independent buffers, one for reading and one for writing. Used for
--   full-duplex streams, such as network sockets.
mkDuplexHandle :: (RawIO dev, IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> Maybe TextEncoding -> NewlineMode -> IO Handle

-- | For a handle <tt>hdl</tt> which attached to a physical file,
--   <a>hFileSize</a> <tt>hdl</tt> returns the size of that file in 8-bit
--   bytes.
hFileSize :: Handle -> IO Integer

-- | <a>hSetFileSize</a> <tt>hdl</tt> <tt>size</tt> truncates the physical
--   file with handle <tt>hdl</tt> to <tt>size</tt> bytes.
hSetFileSize :: Handle -> Integer -> IO ()

-- | For a readable handle <tt>hdl</tt>, <a>hIsEOF</a> <tt>hdl</tt> returns
--   <a>True</a> if no further input can be taken from <tt>hdl</tt> or for
--   a physical file, if the current I/O position is equal to the length of
--   the file. Otherwise, it returns <a>False</a>.
--   
--   NOTE: <a>hIsEOF</a> may block, because it has to attempt to read from
--   the stream to determine whether there is any more data to be read.
hIsEOF :: Handle -> IO Bool

-- | The computation <a>isEOF</a> is identical to <a>hIsEOF</a>, except
--   that it works only on <a>stdin</a>.
isEOF :: IO Bool

-- | Computation <a>hLookAhead</a> returns the next character from the
--   handle without removing it from the input buffer, blocking until a
--   character is available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hLookAhead :: Handle -> IO Char

-- | Computation <a>hSetBuffering</a> <tt>hdl mode</tt> sets the mode of
--   buffering for handle <tt>hdl</tt> on subsequent reads and writes.
--   
--   If the buffer mode is changed from <a>BlockBuffering</a> or
--   <a>LineBuffering</a> to <a>NoBuffering</a>, then
--   
--   <ul>
--   <li>if <tt>hdl</tt> is writable, the buffer is flushed as for
--   <a>hFlush</a>;</li>
--   <li>if <tt>hdl</tt> is not writable, the contents of the buffer are
--   discarded.</li>
--   </ul>
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isPermissionError</a> if the handle has already been used for
--   reading or writing and the implementation does not allow the buffering
--   mode to be changed.</li>
--   </ul>
hSetBuffering :: Handle -> BufferMode -> IO ()

-- | Select binary mode (<a>True</a>) or text mode (<a>False</a>) on a open
--   handle. (See also <a>openBinaryFile</a>.)
--   
--   This has the same effect as calling <a>hSetEncoding</a> with
--   <a>char8</a>, together with <a>hSetNewlineMode</a> with
--   <a>noNewlineTranslation</a>.
hSetBinaryMode :: Handle -> Bool -> IO ()

-- | The action <a>hSetEncoding</a> <tt>hdl</tt> <tt>encoding</tt> changes
--   the text encoding for the handle <tt>hdl</tt> to <tt>encoding</tt>.
--   The default encoding when a <a>Handle</a> is created is
--   <a>localeEncoding</a>, namely the default encoding for the current
--   locale.
--   
--   To create a <a>Handle</a> with no encoding at all, use
--   <a>openBinaryFile</a>. To stop further encoding or decoding on an
--   existing <a>Handle</a>, use <a>hSetBinaryMode</a>.
--   
--   <a>hSetEncoding</a> may need to flush buffered data in order to change
--   the encoding.
hSetEncoding :: Handle -> TextEncoding -> IO ()

-- | Return the current <a>TextEncoding</a> for the specified
--   <a>Handle</a>, or <a>Nothing</a> if the <a>Handle</a> is in binary
--   mode.
--   
--   Note that the <a>TextEncoding</a> remembers nothing about the state of
--   the encoder/decoder in use on this <a>Handle</a>. For example, if the
--   encoding in use is UTF-16, then using <a>hGetEncoding</a> and
--   <a>hSetEncoding</a> to save and restore the encoding may result in an
--   extra byte-order-mark being written to the file.
hGetEncoding :: Handle -> IO (Maybe TextEncoding)

-- | The action <a>hFlush</a> <tt>hdl</tt> causes any items buffered for
--   output in handle <tt>hdl</tt> to be sent immediately to the operating
--   system.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full;</li>
--   <li><a>isPermissionError</a> if a system resource limit would be
--   exceeded. It is unspecified whether the characters in the buffer are
--   discarded or retained under these circumstances.</li>
--   </ul>
hFlush :: Handle -> IO ()

-- | The action <a>hFlushAll</a> <tt>hdl</tt> flushes all buffered data in
--   <tt>hdl</tt>, including any buffered read data. Buffered read data is
--   flushed by seeking the file position back to the point before the
--   buffered data was read, and hence only works if <tt>hdl</tt> is
--   seekable (see <a>hIsSeekable</a>).
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full;</li>
--   <li><a>isPermissionError</a> if a system resource limit would be
--   exceeded. It is unspecified whether the characters in the buffer are
--   discarded or retained under these circumstances;</li>
--   <li><a>isIllegalOperation</a> if <tt>hdl</tt> has buffered read data,
--   and is not seekable.</li>
--   </ul>
hFlushAll :: Handle -> IO ()

-- | Returns a duplicate of the original handle, with its own buffer. The
--   two Handles will share a file pointer, however. The original handle's
--   buffer is flushed, including discarding any input data, before the
--   handle is duplicated.
hDuplicate :: Handle -> IO Handle

-- | Makes the second handle a duplicate of the first handle. The second
--   handle will be closed first, if it is not already.
--   
--   This can be used to retarget the standard Handles, for example:
--   
--   <pre>
--   do h &lt;- openFile "mystdout" WriteMode
--      hDuplicateTo h stdout
--   </pre>
hDuplicateTo :: Handle -> Handle -> IO ()

-- | Computation <a>hClose</a> <tt>hdl</tt> makes handle <tt>hdl</tt>
--   closed. Before the computation finishes, if <tt>hdl</tt> is writable
--   its buffer is flushed as for <a>hFlush</a>. Performing <a>hClose</a>
--   on a handle that has already been closed has no effect; doing so is
--   not an error. All other operations on a closed handle will fail. If
--   <a>hClose</a> fails for any reason, any further operations (apart from
--   <a>hClose</a>) on the handle will still fail as if <tt>hdl</tt> had
--   been successfully closed.
--   
--   <a>hClose</a> is an <i>interruptible operation</i> in the sense
--   described in <a>Control.Exception</a>. If <a>hClose</a> is interrupted
--   by an asynchronous exception in the process of flushing its buffers,
--   then the I/O device (e.g., file) will be closed anyway.
hClose :: Handle -> IO ()
hClose_help :: Handle__ -> IO (Handle__, Maybe SomeException)

-- | Indicates a mode in which a file should be locked.
data LockMode
SharedLock :: LockMode
ExclusiveLock :: LockMode

-- | If a <a>Handle</a> references a file descriptor, attempt to lock
--   contents of the underlying file in appropriate mode. If the file is
--   already locked in incompatible mode, this function blocks until the
--   lock is established. The lock is automatically released upon closing a
--   <a>Handle</a>.
--   
--   Things to be aware of:
--   
--   1) This function may block inside a C call. If it does, in order to be
--   able to interrupt it with asynchronous exceptions and/or for other
--   threads to continue working, you MUST use threaded version of the
--   runtime system.
--   
--   2) The implementation uses <tt>LockFileEx</tt> on Windows and
--   <tt>flock</tt> otherwise, hence all of their caveats also apply here.
--   
--   3) On non-Windows platforms that don't support <tt>flock</tt> (e.g.
--   Solaris) this function throws <tt>FileLockingNotImplemented</tt>. We
--   deliberately choose to not provide fcntl based locking instead because
--   of its broken semantics.
hLock :: Handle -> LockMode -> IO ()

-- | Non-blocking version of <a>hLock</a>.
--   
--   Returns <a>True</a> if taking the lock was successful and <a>False</a>
--   otherwise.
hTryLock :: Handle -> LockMode -> IO Bool
type HandlePosition = Integer
data HandlePosn
HandlePosn :: Handle -> HandlePosition -> HandlePosn

-- | Computation <a>hGetPosn</a> <tt>hdl</tt> returns the current I/O
--   position of <tt>hdl</tt> as a value of the abstract type
--   <a>HandlePosn</a>.
hGetPosn :: Handle -> IO HandlePosn

-- | If a call to <a>hGetPosn</a> <tt>hdl</tt> returns a position
--   <tt>p</tt>, then computation <a>hSetPosn</a> <tt>p</tt> sets the
--   position of <tt>hdl</tt> to the position it held at the time of the
--   call to <a>hGetPosn</a>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isPermissionError</a> if a system resource limit would be
--   exceeded.</li>
--   </ul>
hSetPosn :: HandlePosn -> IO ()

-- | A mode that determines the effect of <a>hSeek</a> <tt>hdl mode i</tt>.
data SeekMode

-- | the position of <tt>hdl</tt> is set to <tt>i</tt>.
AbsoluteSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the
--   current position.
RelativeSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the end
--   of the file.
SeekFromEnd :: SeekMode

-- | Computation <a>hSeek</a> <tt>hdl mode i</tt> sets the position of
--   handle <tt>hdl</tt> depending on <tt>mode</tt>. The offset <tt>i</tt>
--   is given in terms of 8-bit bytes.
--   
--   If <tt>hdl</tt> is block- or line-buffered, then seeking to a position
--   which is not in the current buffer will first cause any items in the
--   output buffer to be written to the device, and then cause the input
--   buffer to be discarded. Some handles may not be seekable (see
--   <a>hIsSeekable</a>), or only support a subset of the possible
--   positioning operations (for instance, it may only be possible to seek
--   to the end of a tape, or to a positive offset from the beginning or
--   current position). It is not possible to set a negative I/O position,
--   or for a physical file, an I/O position beyond the current
--   end-of-file.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isIllegalOperationError</a> if the Handle is not seekable, or
--   does not support the requested seek mode.</li>
--   <li><a>isPermissionError</a> if a system resource limit would be
--   exceeded.</li>
--   </ul>
hSeek :: Handle -> SeekMode -> Integer -> IO ()

-- | Computation <a>hTell</a> <tt>hdl</tt> returns the current position of
--   the handle <tt>hdl</tt>, as the number of bytes from the beginning of
--   the file. The value returned may be subsequently passed to
--   <a>hSeek</a> to reposition the handle to the current position.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isIllegalOperationError</a> if the Handle is not seekable.</li>
--   </ul>
hTell :: Handle -> IO Integer

-- | <tt><a>hIsOpen</a> hdl</tt> returns whether the handle is open. If the
--   <a>haType</a> of <tt>hdl</tt> is <a>ClosedHandle</a> or
--   <a>SemiClosedHandle</a> this returns <a>False</a> and <a>True</a>
--   otherwise.
hIsOpen :: Handle -> IO Bool

-- | <tt><a>hIsOpen</a> hdl</tt> returns whether the handle is closed. If
--   the <a>haType</a> of <tt>hdl</tt> is <a>ClosedHandle</a> this returns
--   <a>True</a> and <a>False</a> otherwise.
hIsClosed :: Handle -> IO Bool

-- | <tt><a>hIsReadable</a> hdl</tt> returns whether it is possible to read
--   from the handle.
hIsReadable :: Handle -> IO Bool

-- | <tt><a>hIsWritable</a> hdl</tt> returns whether it is possible to
--   write to the handle.
hIsWritable :: Handle -> IO Bool

-- | Computation <a>hGetBuffering</a> <tt>hdl</tt> returns the current
--   buffering mode for <tt>hdl</tt>.
hGetBuffering :: Handle -> IO BufferMode

-- | <tt><a>hIsSeekable</a> hdl</tt> returns whether it is possible to
--   <a>hSeek</a> with the given handle.
hIsSeekable :: Handle -> IO Bool

-- | Set the echoing status of a handle connected to a terminal.
hSetEcho :: Handle -> Bool -> IO ()

-- | Get the echoing status of a handle connected to a terminal.
hGetEcho :: Handle -> IO Bool

-- | Is the handle connected to a terminal?
--   
--   On Windows the result of <tt>hIsTerminalDevide</tt> might be
--   misleading, because non-native terminals, such as MinTTY used in MSYS
--   and Cygwin environments, are implemented via redirection. Use
--   <tt>System.Win32.Types.withHandleToHANDLE
--   System.Win32.MinTTY.isMinTTYHandle</tt> to recognise it. Also consider
--   <tt>ansi-terminal</tt> package for crossplatform terminal support.
hIsTerminalDevice :: Handle -> IO Bool

-- | Set the <a>NewlineMode</a> on the specified <a>Handle</a>. All
--   buffered data is flushed first.
hSetNewlineMode :: Handle -> NewlineMode -> IO ()

-- | The representation of a newline in the external file or stream.
data Newline

-- | <pre>
--   '\n'
--   </pre>
LF :: Newline

-- | <pre>
--   '\r\n'
--   </pre>
CRLF :: Newline

-- | Specifies the translation, if any, of newline characters between
--   internal Strings and the external file or stream. Haskell Strings are
--   assumed to represent newlines with the <tt>'\n'</tt> character; the
--   newline mode specifies how to translate <tt>'\n'</tt> on output, and
--   what to translate into <tt>'\n'</tt> on input.
data NewlineMode
NewlineMode :: Newline -> Newline -> NewlineMode

-- | the representation of newlines on input
[inputNL] :: NewlineMode -> Newline

-- | the representation of newlines on output
[outputNL] :: NewlineMode -> Newline

-- | The native newline representation for the current platform: <a>LF</a>
--   on Unix systems, <a>CRLF</a> on Windows.
nativeNewline :: Newline

-- | Do no newline translation at all.
--   
--   <pre>
--   noNewlineTranslation  = NewlineMode { inputNL  = LF, outputNL = LF }
--   </pre>
noNewlineTranslation :: NewlineMode

-- | Map <tt>'\r\n'</tt> into <tt>'\n'</tt> on input, and <tt>'\n'</tt> to
--   the native newline representation on output. This mode can be used on
--   any platform, and works with text files using any newline convention.
--   The downside is that <tt>readFile &gt;&gt;= writeFile</tt> might yield
--   a different file.
--   
--   <pre>
--   universalNewlineMode  = NewlineMode { inputNL  = CRLF,
--                                         outputNL = nativeNewline }
--   </pre>
universalNewlineMode :: NewlineMode

-- | Use the native newline representation on both input and output
--   
--   <pre>
--   nativeNewlineMode  = NewlineMode { inputNL  = nativeNewline
--                                      outputNL = nativeNewline }
--   </pre>
nativeNewlineMode :: NewlineMode

-- | <a>hShow</a> is in the <a>IO</a> monad, and gives more comprehensive
--   output than the (pure) instance of <a>Show</a> for <a>Handle</a>.
hShow :: Handle -> IO String

-- | Computation <a>hWaitForInput</a> <tt>hdl t</tt> waits until input is
--   available on handle <tt>hdl</tt>. It returns <a>True</a> as soon as
--   input is available on <tt>hdl</tt>, or <a>False</a> if no input is
--   available within <tt>t</tt> milliseconds. Note that
--   <a>hWaitForInput</a> waits until one or more full <i>characters</i>
--   are available, which means that it needs to do decoding, and hence may
--   fail with a decoding error.
--   
--   If <tt>t</tt> is less than zero, then <tt>hWaitForInput</tt> waits
--   indefinitely.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   <li>a decoding error, if the input begins with an invalid byte
--   sequence in this Handle's encoding.</li>
--   </ul>
--   
--   NOTE for GHC users: unless you use the <tt>-threaded</tt> flag,
--   <tt>hWaitForInput hdl t</tt> where <tt>t &gt;= 0</tt> will block all
--   other Haskell threads for the duration of the call. It behaves like a
--   <tt>safe</tt> foreign call in this respect.
hWaitForInput :: Handle -> Int -> IO Bool

-- | Computation <a>hGetChar</a> <tt>hdl</tt> reads a character from the
--   file or channel managed by <tt>hdl</tt>, blocking until a character is
--   available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetChar :: Handle -> IO Char

-- | Computation <a>hGetLine</a> <tt>hdl</tt> reads a line from the file or
--   channel managed by <tt>hdl</tt>. <a>hGetLine</a> does not return the
--   newline as part of the result.
--   
--   A line is separated by the newline set with <a>hSetNewlineMode</a> or
--   <a>nativeNewline</a> by default. The read newline character(s) are not
--   returned as part of the result.
--   
--   If <a>hGetLine</a> encounters end-of-file at any point while reading
--   in the middle of a line, it is treated as a line terminator and the
--   (partial) line is returned.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file is encountered when reading
--   the <i>first</i> character of the line.</li>
--   </ul>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; withFile "/home/user/foo" ReadMode hGetLine &gt;&gt;= putStrLn
--   this is the first line of the file :O
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; withFile "/home/user/bar" ReadMode (replicateM 3 . hGetLine)
--   ["this is the first line","this is the second line","this is the third line"]
--   </pre>
hGetLine :: Handle -> IO String

-- | Computation <a>hGetContents</a> <tt>hdl</tt> returns the list of
--   characters corresponding to the unread portion of the channel or file
--   managed by <tt>hdl</tt>, which is put into an intermediate state,
--   <i>semi-closed</i>. In this state, <tt>hdl</tt> is effectively closed,
--   but items are read from <tt>hdl</tt> on demand and accumulated in a
--   special list returned by <a>hGetContents</a> <tt>hdl</tt>.
--   
--   Any operation that fails because a handle is closed, also fails if a
--   handle is semi-closed. The only exception is <a>hClose</a>. A
--   semi-closed handle becomes closed:
--   
--   <ul>
--   <li>if <a>hClose</a> is applied to it;</li>
--   <li>if an I/O error occurs when reading an item from the handle;</li>
--   <li>or once the entire contents of the handle has been read.</li>
--   </ul>
--   
--   Once a semi-closed handle becomes closed, the contents of the
--   associated list becomes fixed. The contents of this final list is only
--   partially specified: it will contain at least all the items of the
--   stream that were evaluated prior to the handle becoming closed.
--   
--   Any I/O errors encountered while a handle is semi-closed are simply
--   discarded.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetContents :: Handle -> IO String

-- | The <a>hGetContents'</a> operation reads all input on the given handle
--   before returning it as a <a>String</a> and closing the handle.
--   
--   This is a strict version of <a>hGetContents</a>
hGetContents' :: Handle -> IO String

-- | Computation <a>hPutChar</a> <tt>hdl ch</tt> writes the character
--   <tt>ch</tt> to the file or channel managed by <tt>hdl</tt>. Characters
--   may be buffered if buffering is enabled for <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full.</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutChar :: Handle -> Char -> IO ()

-- | Computation <a>hPutStr</a> <tt>hdl s</tt> writes the string <tt>s</tt>
--   to the file or channel managed by <tt>hdl</tt>.
--   
--   Note that <a>hPutStr</a> is not concurrency safe unless the
--   <a>BufferMode</a> of <tt>hdl</tt> is set to <a>LineBuffering</a> or
--   <a>BlockBuffering</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let f = forkIO . hPutStr stdout
--   
--   &gt;&gt;&gt; in do hSetBuffering stdout NoBuffering; f "This is a longer string"; f ":D"; f "Hello Haskell"; pure ()
--   This: HDiesl lao  lHoansgkeerl lstring
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let f = forkIO . hPutStr stdout
--   
--   &gt;&gt;&gt; in do hSetBuffering stdout LineBuffering; f "This is a longer string"; f ":D"; f "Hello Haskell"; pure ()
--   This is a longer string:DHello Haskell
--   </pre>
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full.</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutStr :: Handle -> String -> IO ()

-- | <a>hGetBuf</a> <tt>hdl buf count</tt> reads data from the handle
--   <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is reached
--   or <tt>count</tt> 8-bit bytes have been read. It returns the number of
--   bytes actually read. This may be zero if EOF was reached before any
--   data was read (or if <tt>count</tt> is zero).
--   
--   <a>hGetBuf</a> never raises an EOF exception, instead it returns a
--   value smaller than <tt>count</tt>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBuf</a> will behave as if EOF was reached.
--   
--   <a>hGetBuf</a> ignores the prevailing <a>TextEncoding</a> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
hGetBuf :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hGetBufNonBlocking</a> <tt>hdl buf count</tt> reads data from the
--   handle <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is
--   reached, or <tt>count</tt> 8-bit bytes have been read, or there is no
--   more data available to read immediately.
--   
--   <a>hGetBufNonBlocking</a> is identical to <a>hGetBuf</a>, except that
--   it will never block waiting for data to become available, instead it
--   returns only whatever data is available. To wait for data to arrive
--   before calling <a>hGetBufNonBlocking</a>, use <a>hWaitForInput</a>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBufNonBlocking</a> will behave as if EOF was reached.
--   
--   <a>hGetBufNonBlocking</a> ignores the prevailing <a>TextEncoding</a>
--   and <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
--   
--   NOTE: on Windows, this function does not work correctly; it behaves
--   identically to <a>hGetBuf</a>.
hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hPutBuf</a> <tt>hdl buf count</tt> writes <tt>count</tt> 8-bit
--   bytes from the buffer <tt>buf</tt> to the handle <tt>hdl</tt>. It
--   returns ().
--   
--   <a>hPutBuf</a> ignores any text encoding that applies to the
--   <a>Handle</a>, writing the bytes directly to the underlying file or
--   device.
--   
--   <a>hPutBuf</a> ignores the prevailing <a>TextEncoding</a> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and writes bytes directly.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>ResourceVanished</a> if the handle is a pipe or socket, and the
--   reading end is closed. (If this is a POSIX system, and the program has
--   not asked to ignore SIGPIPE, then a SIGPIPE may be delivered instead,
--   whose default action is to terminate the program).</li>
--   </ul>
hPutBuf :: Handle -> Ptr a -> Int -> IO ()
hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
instance GHC.Classes.Eq GHC.Internal.IO.Handle.HandlePosn
instance GHC.Internal.Show.Show GHC.Internal.IO.Handle.HandlePosn


-- | Support for catching exceptions raised during top-level computations
--   (e.g. <tt>Main.main</tt>, <a>forkIO</a>, and foreign exports)
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.TopHandler

-- | <a>runMainIO</a> is wrapped around <a>main</a> (or whatever main is
--   called in the program). It catches otherwise uncaught exceptions, and
--   also flushes stdout/stderr before exiting.
runMainIO :: IO a -> IO a

-- | <a>runIO</a> is wrapped around every <tt>foreign export</tt> and
--   <tt>foreign import "wrapper"</tt> to mop up any uncaught exceptions.
--   Thus, the result of running <a>exitWith</a> in a foreign-exported
--   function is the same as in the main thread: it terminates the program.
runIO :: IO a -> IO a

-- | Like <a>runIO</a>, but in the event of an exception that causes an
--   exit, we don't shut down the system cleanly, we just exit. This is
--   useful in some cases, because the safe exit version will give other
--   threads a chance to clean up first, which might shut down the system
--   in a different way. For example, try
--   
--   main = forkIO (runIO (exitWith (ExitFailure 1))) &gt;&gt; threadDelay
--   10000
--   
--   This will sometimes exit with "interrupted" and code 0, because the
--   main thread is given a chance to shut down when the child thread calls
--   safeExit. There is a race to shut down between the main and child
--   threads.
runIOFastExit :: IO a -> IO a

-- | The same as <a>runIO</a>, but for non-IO computations. Used for
--   wrapping <tt>foreign export</tt> and <tt>foreign import "wrapper"</tt>
--   when these are used to export Haskell functions with non-IO types.
runNonIO :: a -> IO a
topHandler :: SomeException -> IO a
topHandlerFastExit :: SomeException -> IO a
reportStackOverflow :: IO ()
reportError :: SomeException -> IO ()
flushStdHandles :: IO ()


-- | The standard IO library.
module GHC.Internal.System.IO

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
data IO a

-- | The implementation of <a>mfix</a> for <a>IO</a>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>FixIOException</a> if the function passed to <a>fixIO</a>
--   inspects its argument.</li>
--   </ul>
--   
--   <h4><b>Examples</b></h4>
--   
--   the IO-action is only executed once. The recursion is only on the
--   values.
--   
--   <pre>
--   &gt;&gt;&gt; take 3 &lt;$&gt; fixIO (\x -&gt; putStr ":D" &gt;&gt; (:x) &lt;$&gt; readLn @Int)
--   :D
--   2
--   [2,2,2]
--   </pre>
--   
--   If we are strict in the value, just as with <a>fix</a>, we do not get
--   termination:
--   
--   <pre>
--   &gt;&gt;&gt; fixIO (\x -&gt; putStr x &gt;&gt; pure ('x' : x))
--   * hangs forever *
--   </pre>
--   
--   We can tie the knot of a structure within <a>IO</a> using
--   <a>fixIO</a>:
--   
--   <pre>
--   data Node = MkNode Int (IORef Node)
--   
--   foo :: IO ()
--   foo = do
--     p &lt;- fixIO (p -&gt; newIORef (MkNode 0 p))
--     q &lt;- output p
--     r &lt;- output q
--     _ &lt;- output r
--     pure ()
--   
--   output :: IORef Node -&gt; IO (IORef Node)
--   output ref = do
--     MkNode x p &lt;- readIORef ref
--     print x
--     pure p
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foo
--   0
--   0
--   0
--   </pre>
fixIO :: (a -> IO a) -> IO a

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
data Handle

-- | <a>stdin</a> is a handle managing the programs standard input.
stdin :: Handle

-- | <a>stdout</a> is a handle managing the programs standard output.
stdout :: Handle

-- | <a>stderr</a> is a handle managing the programs standard error.
stderr :: Handle

-- | The computation <tt><a>withFile</a> path mode action</tt> opens the
--   file and runs <tt>action</tt> with the obtained handle before closing
--   the file.
--   
--   Even when an exception is raised within the <tt>action</tt>, the file
--   will still be closed. This is why <tt><a>withFile</a> path mode
--   act</tt> is preferable to
--   
--   <pre>
--   <a>openFile</a> path mode &gt;&gt;= (\hdl -&gt; act hdl &gt;&gt;= <a>hClose</a> hdl)
--   </pre>
--   
--   See also: <a>bracket</a>
withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r

-- | The computation <tt><a>openFile</a> path mode</tt> returns a file
--   handle that can be used to interact with the file.
--   
--   The handle is open in text mode with <a>localeEncoding</a>. You can
--   change the encoding with <a>hSetEncoding</a>.
openFile :: FilePath -> IOMode -> IO Handle

-- | See <a>openFile</a>
data IOMode
ReadMode :: IOMode
WriteMode :: IOMode
AppendMode :: IOMode
ReadWriteMode :: IOMode

-- | Computation <a>hClose</a> <tt>hdl</tt> makes handle <tt>hdl</tt>
--   closed. Before the computation finishes, if <tt>hdl</tt> is writable
--   its buffer is flushed as for <a>hFlush</a>. Performing <a>hClose</a>
--   on a handle that has already been closed has no effect; doing so is
--   not an error. All other operations on a closed handle will fail. If
--   <a>hClose</a> fails for any reason, any further operations (apart from
--   <a>hClose</a>) on the handle will still fail as if <tt>hdl</tt> had
--   been successfully closed.
--   
--   <a>hClose</a> is an <i>interruptible operation</i> in the sense
--   described in <a>Control.Exception</a>. If <a>hClose</a> is interrupted
--   by an asynchronous exception in the process of flushing its buffers,
--   then the I/O device (e.g., file) will be closed anyway.
hClose :: Handle -> IO ()

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string.
--   
--   The file is read lazily, on demand, as with <a>getContents</a>.
--   
--   This operation may fail with the same errors as <a>hGetContents</a>
--   and <a>openFile</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; readFile "~/hello_world"
--   "Greetings!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 5 &lt;$&gt; readFile "/dev/zero"
--   "\NUL\NUL\NUL\NUL\NUL"
--   </pre>
readFile :: FilePath -> IO String

-- | The <a>readFile'</a> function reads a file and returns the contents of
--   the file as a string.
--   
--   This is identical to <a>readFile</a>, but the file is fully read
--   before being returned, as with <a>getContents'</a>.
readFile' :: FilePath -> IO String

-- | The computation <tt><a>writeFile</a> file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   This operation may fail with the same errors as <a>hPutStr</a> and
--   <a>withFile</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; writeFile "hello" "world" &gt;&gt; readFile "hello"
--   "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; writeFile "~/" "D:"
--   *** Exception: ~/: withFile: inappropriate type (Is a directory)
--   </pre>
writeFile :: FilePath -> String -> IO ()

-- | The computation <tt><a>appendFile</a> file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   This operation may fail with the same errors as <a>hPutStr</a> and
--   <a>withFile</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   The following example could be more efficently written by acquiring a
--   handle instead with <a>openFile</a> and using the computations capable
--   of writing to handles such as <a>hPutStr</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let fn = "hello_world"
--   
--   &gt;&gt;&gt; in writeFile fn "hello" &gt;&gt; appendFile fn " world!" &gt;&gt; (readFile fn &gt;&gt;= putStrLn)
--   "hello world!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let fn = "foo"; output = readFile' fn &gt;&gt;= putStrLn
--   
--   &gt;&gt;&gt; in output &gt;&gt; appendFile fn (show [1,2,3]) &gt;&gt; output
--   this is what's in the file
--   this is what's in the file[1,2,3]
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | For a handle <tt>hdl</tt> which attached to a physical file,
--   <a>hFileSize</a> <tt>hdl</tt> returns the size of that file in 8-bit
--   bytes.
hFileSize :: Handle -> IO Integer

-- | <a>hSetFileSize</a> <tt>hdl</tt> <tt>size</tt> truncates the physical
--   file with handle <tt>hdl</tt> to <tt>size</tt> bytes.
hSetFileSize :: Handle -> Integer -> IO ()

-- | For a readable handle <tt>hdl</tt>, <a>hIsEOF</a> <tt>hdl</tt> returns
--   <a>True</a> if no further input can be taken from <tt>hdl</tt> or for
--   a physical file, if the current I/O position is equal to the length of
--   the file. Otherwise, it returns <a>False</a>.
--   
--   NOTE: <a>hIsEOF</a> may block, because it has to attempt to read from
--   the stream to determine whether there is any more data to be read.
hIsEOF :: Handle -> IO Bool

-- | The computation <a>isEOF</a> is identical to <a>hIsEOF</a>, except
--   that it works only on <a>stdin</a>.
isEOF :: IO Bool

-- | Three kinds of buffering are supported: line-buffering,
--   block-buffering or no-buffering. These modes have the following
--   effects. For output, items are written out, or <i>flushed</i>, from
--   the internal buffer according to the buffer mode:
--   
--   <ul>
--   <li><i>line-buffering</i>: the entire output buffer is flushed
--   whenever a newline is output, the buffer overflows, a <a>hFlush</a> is
--   issued, or the handle is closed.</li>
--   <li><i>block-buffering</i>: the entire buffer is written out whenever
--   it overflows, a <a>hFlush</a> is issued, or the handle is closed.</li>
--   <li><i>no-buffering</i>: output is written immediately, and never
--   stored in the buffer.</li>
--   </ul>
--   
--   An implementation is free to flush the buffer more frequently, but not
--   less frequently, than specified above. The output buffer is emptied as
--   soon as it has been written out.
--   
--   Similarly, input occurs according to the buffer mode for the handle:
--   
--   <ul>
--   <li><i>line-buffering</i>: when the buffer for the handle is not
--   empty, the next item is obtained from the buffer; otherwise, when the
--   buffer is empty, characters up to and including the next newline
--   character are read into the buffer. No characters are available until
--   the newline character is available or the buffer is full.</li>
--   <li><i>block-buffering</i>: when the buffer for the handle becomes
--   empty, the next block of data is read into the buffer.</li>
--   <li><i>no-buffering</i>: the next input item is read and returned. The
--   <a>hLookAhead</a> operation implies that even a no-buffered handle may
--   require a one-character buffer.</li>
--   </ul>
--   
--   The default buffering mode when a handle is opened is
--   implementation-dependent and may depend on the file system object
--   which is attached to that handle. For most implementations, physical
--   files will normally be block-buffered and terminals will normally be
--   line-buffered.
data BufferMode

-- | buffering is disabled if possible.
NoBuffering :: BufferMode

-- | line-buffering should be enabled if possible.
LineBuffering :: BufferMode

-- | block-buffering should be enabled if possible. The size of the buffer
--   is <tt>n</tt> items if the argument is <a>Just</a> <tt>n</tt> and is
--   otherwise implementation-dependent.
BlockBuffering :: Maybe Int -> BufferMode

-- | Computation <a>hSetBuffering</a> <tt>hdl mode</tt> sets the mode of
--   buffering for handle <tt>hdl</tt> on subsequent reads and writes.
--   
--   If the buffer mode is changed from <a>BlockBuffering</a> or
--   <a>LineBuffering</a> to <a>NoBuffering</a>, then
--   
--   <ul>
--   <li>if <tt>hdl</tt> is writable, the buffer is flushed as for
--   <a>hFlush</a>;</li>
--   <li>if <tt>hdl</tt> is not writable, the contents of the buffer are
--   discarded.</li>
--   </ul>
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isPermissionError</a> if the handle has already been used for
--   reading or writing and the implementation does not allow the buffering
--   mode to be changed.</li>
--   </ul>
hSetBuffering :: Handle -> BufferMode -> IO ()

-- | Computation <a>hGetBuffering</a> <tt>hdl</tt> returns the current
--   buffering mode for <tt>hdl</tt>.
hGetBuffering :: Handle -> IO BufferMode

-- | The action <a>hFlush</a> <tt>hdl</tt> causes any items buffered for
--   output in handle <tt>hdl</tt> to be sent immediately to the operating
--   system.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full;</li>
--   <li><a>isPermissionError</a> if a system resource limit would be
--   exceeded. It is unspecified whether the characters in the buffer are
--   discarded or retained under these circumstances.</li>
--   </ul>
hFlush :: Handle -> IO ()

-- | Computation <a>hGetPosn</a> <tt>hdl</tt> returns the current I/O
--   position of <tt>hdl</tt> as a value of the abstract type
--   <a>HandlePosn</a>.
hGetPosn :: Handle -> IO HandlePosn

-- | If a call to <a>hGetPosn</a> <tt>hdl</tt> returns a position
--   <tt>p</tt>, then computation <a>hSetPosn</a> <tt>p</tt> sets the
--   position of <tt>hdl</tt> to the position it held at the time of the
--   call to <a>hGetPosn</a>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isPermissionError</a> if a system resource limit would be
--   exceeded.</li>
--   </ul>
hSetPosn :: HandlePosn -> IO ()
data HandlePosn

-- | Computation <a>hSeek</a> <tt>hdl mode i</tt> sets the position of
--   handle <tt>hdl</tt> depending on <tt>mode</tt>. The offset <tt>i</tt>
--   is given in terms of 8-bit bytes.
--   
--   If <tt>hdl</tt> is block- or line-buffered, then seeking to a position
--   which is not in the current buffer will first cause any items in the
--   output buffer to be written to the device, and then cause the input
--   buffer to be discarded. Some handles may not be seekable (see
--   <a>hIsSeekable</a>), or only support a subset of the possible
--   positioning operations (for instance, it may only be possible to seek
--   to the end of a tape, or to a positive offset from the beginning or
--   current position). It is not possible to set a negative I/O position,
--   or for a physical file, an I/O position beyond the current
--   end-of-file.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isIllegalOperationError</a> if the Handle is not seekable, or
--   does not support the requested seek mode.</li>
--   <li><a>isPermissionError</a> if a system resource limit would be
--   exceeded.</li>
--   </ul>
hSeek :: Handle -> SeekMode -> Integer -> IO ()

-- | A mode that determines the effect of <a>hSeek</a> <tt>hdl mode i</tt>.
data SeekMode

-- | the position of <tt>hdl</tt> is set to <tt>i</tt>.
AbsoluteSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the
--   current position.
RelativeSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the end
--   of the file.
SeekFromEnd :: SeekMode

-- | Computation <a>hTell</a> <tt>hdl</tt> returns the current position of
--   the handle <tt>hdl</tt>, as the number of bytes from the beginning of
--   the file. The value returned may be subsequently passed to
--   <a>hSeek</a> to reposition the handle to the current position.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isIllegalOperationError</a> if the Handle is not seekable.</li>
--   </ul>
hTell :: Handle -> IO Integer

-- | <tt><a>hIsOpen</a> hdl</tt> returns whether the handle is open. If the
--   <a>haType</a> of <tt>hdl</tt> is <a>ClosedHandle</a> or
--   <a>SemiClosedHandle</a> this returns <a>False</a> and <a>True</a>
--   otherwise.
hIsOpen :: Handle -> IO Bool

-- | <tt><a>hIsOpen</a> hdl</tt> returns whether the handle is closed. If
--   the <a>haType</a> of <tt>hdl</tt> is <a>ClosedHandle</a> this returns
--   <a>True</a> and <a>False</a> otherwise.
hIsClosed :: Handle -> IO Bool

-- | <tt><a>hIsReadable</a> hdl</tt> returns whether it is possible to read
--   from the handle.
hIsReadable :: Handle -> IO Bool

-- | <tt><a>hIsWritable</a> hdl</tt> returns whether it is possible to
--   write to the handle.
hIsWritable :: Handle -> IO Bool

-- | <tt><a>hIsSeekable</a> hdl</tt> returns whether it is possible to
--   <a>hSeek</a> with the given handle.
hIsSeekable :: Handle -> IO Bool

-- | Is the handle connected to a terminal?
--   
--   On Windows the result of <tt>hIsTerminalDevide</tt> might be
--   misleading, because non-native terminals, such as MinTTY used in MSYS
--   and Cygwin environments, are implemented via redirection. Use
--   <tt>System.Win32.Types.withHandleToHANDLE
--   System.Win32.MinTTY.isMinTTYHandle</tt> to recognise it. Also consider
--   <tt>ansi-terminal</tt> package for crossplatform terminal support.
hIsTerminalDevice :: Handle -> IO Bool

-- | Set the echoing status of a handle connected to a terminal.
hSetEcho :: Handle -> Bool -> IO ()

-- | Get the echoing status of a handle connected to a terminal.
hGetEcho :: Handle -> IO Bool

-- | <a>hShow</a> is in the <a>IO</a> monad, and gives more comprehensive
--   output than the (pure) instance of <a>Show</a> for <a>Handle</a>.
hShow :: Handle -> IO String

-- | Computation <a>hWaitForInput</a> <tt>hdl t</tt> waits until input is
--   available on handle <tt>hdl</tt>. It returns <a>True</a> as soon as
--   input is available on <tt>hdl</tt>, or <a>False</a> if no input is
--   available within <tt>t</tt> milliseconds. Note that
--   <a>hWaitForInput</a> waits until one or more full <i>characters</i>
--   are available, which means that it needs to do decoding, and hence may
--   fail with a decoding error.
--   
--   If <tt>t</tt> is less than zero, then <tt>hWaitForInput</tt> waits
--   indefinitely.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   <li>a decoding error, if the input begins with an invalid byte
--   sequence in this Handle's encoding.</li>
--   </ul>
--   
--   NOTE for GHC users: unless you use the <tt>-threaded</tt> flag,
--   <tt>hWaitForInput hdl t</tt> where <tt>t &gt;= 0</tt> will block all
--   other Haskell threads for the duration of the call. It behaves like a
--   <tt>safe</tt> foreign call in this respect.
hWaitForInput :: Handle -> Int -> IO Bool

-- | Computation <a>hReady</a> <tt>hdl</tt> indicates whether at least one
--   item is available for input from handle <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hReady :: Handle -> IO Bool

-- | Computation <a>hGetChar</a> <tt>hdl</tt> reads a character from the
--   file or channel managed by <tt>hdl</tt>, blocking until a character is
--   available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetChar :: Handle -> IO Char

-- | Computation <a>hGetLine</a> <tt>hdl</tt> reads a line from the file or
--   channel managed by <tt>hdl</tt>. <a>hGetLine</a> does not return the
--   newline as part of the result.
--   
--   A line is separated by the newline set with <a>hSetNewlineMode</a> or
--   <a>nativeNewline</a> by default. The read newline character(s) are not
--   returned as part of the result.
--   
--   If <a>hGetLine</a> encounters end-of-file at any point while reading
--   in the middle of a line, it is treated as a line terminator and the
--   (partial) line is returned.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file is encountered when reading
--   the <i>first</i> character of the line.</li>
--   </ul>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; withFile "/home/user/foo" ReadMode hGetLine &gt;&gt;= putStrLn
--   this is the first line of the file :O
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; withFile "/home/user/bar" ReadMode (replicateM 3 . hGetLine)
--   ["this is the first line","this is the second line","this is the third line"]
--   </pre>
hGetLine :: Handle -> IO String

-- | Computation <a>hLookAhead</a> returns the next character from the
--   handle without removing it from the input buffer, blocking until a
--   character is available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hLookAhead :: Handle -> IO Char

-- | Computation <a>hGetContents</a> <tt>hdl</tt> returns the list of
--   characters corresponding to the unread portion of the channel or file
--   managed by <tt>hdl</tt>, which is put into an intermediate state,
--   <i>semi-closed</i>. In this state, <tt>hdl</tt> is effectively closed,
--   but items are read from <tt>hdl</tt> on demand and accumulated in a
--   special list returned by <a>hGetContents</a> <tt>hdl</tt>.
--   
--   Any operation that fails because a handle is closed, also fails if a
--   handle is semi-closed. The only exception is <a>hClose</a>. A
--   semi-closed handle becomes closed:
--   
--   <ul>
--   <li>if <a>hClose</a> is applied to it;</li>
--   <li>if an I/O error occurs when reading an item from the handle;</li>
--   <li>or once the entire contents of the handle has been read.</li>
--   </ul>
--   
--   Once a semi-closed handle becomes closed, the contents of the
--   associated list becomes fixed. The contents of this final list is only
--   partially specified: it will contain at least all the items of the
--   stream that were evaluated prior to the handle becoming closed.
--   
--   Any I/O errors encountered while a handle is semi-closed are simply
--   discarded.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetContents :: Handle -> IO String

-- | The <a>hGetContents'</a> operation reads all input on the given handle
--   before returning it as a <a>String</a> and closing the handle.
--   
--   This is a strict version of <a>hGetContents</a>
hGetContents' :: Handle -> IO String

-- | Computation <a>hPutChar</a> <tt>hdl ch</tt> writes the character
--   <tt>ch</tt> to the file or channel managed by <tt>hdl</tt>. Characters
--   may be buffered if buffering is enabled for <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full.</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutChar :: Handle -> Char -> IO ()

-- | Computation <a>hPutStr</a> <tt>hdl s</tt> writes the string <tt>s</tt>
--   to the file or channel managed by <tt>hdl</tt>.
--   
--   Note that <a>hPutStr</a> is not concurrency safe unless the
--   <a>BufferMode</a> of <tt>hdl</tt> is set to <a>LineBuffering</a> or
--   <a>BlockBuffering</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let f = forkIO . hPutStr stdout
--   
--   &gt;&gt;&gt; in do hSetBuffering stdout NoBuffering; f "This is a longer string"; f ":D"; f "Hello Haskell"; pure ()
--   This: HDiesl lao  lHoansgkeerl lstring
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let f = forkIO . hPutStr stdout
--   
--   &gt;&gt;&gt; in do hSetBuffering stdout LineBuffering; f "This is a longer string"; f ":D"; f "Hello Haskell"; pure ()
--   This is a longer string:DHello Haskell
--   </pre>
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full.</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutStr :: Handle -> String -> IO ()

-- | The same as <a>hPutStr</a>, but adds a newline character.
--   
--   This operation may fail with the same errors, and has the same issues
--   with concurrency, as <a>hPutStr</a>!
hPutStrLn :: Handle -> String -> IO ()

-- | Computation <a>hPrint</a> <tt>hdl t</tt> writes the string
--   representation of <tt>t</tt> given by the <a>show</a> function to the
--   file or channel managed by <tt>hdl</tt> and appends a newline.
--   
--   This operation may fail with the same errors as <a>hPutStrLn</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; hPrint stdout [1,2,3]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hPrint stdin [4,5,6]
--   *** Exception: &lt;stdin&gt;: hPutStr: illegal operation (handle is not open for writing)
--   </pre>
hPrint :: Show a => Handle -> a -> IO ()

-- | <tt><a>interact</a> f</tt> takes the entire input from <a>stdin</a>
--   and applies <tt>f</tt> to it. The resulting string is written to the
--   <a>stdout</a> device.
--   
--   Note that this operation is lazy, which allows to produce output even
--   before all input has been consumed.
--   
--   This operation may fail with the same errors as <a>getContents</a> and
--   <a>putStr</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; interact (\str -&gt; str ++ str)
--   &gt; hi :)
--   hi :)
--   &gt; ^D
--   hi :)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; interact (const ":D")
--   :D
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; interact (show . words)
--   &gt; hello world!
--   &gt; I hope you have a great day
--   &gt; ^D
--   ["hello","world!","I","hope","you","have","a","great","day"]
--   </pre>
interact :: (String -> String) -> IO ()

-- | Write a character to the standard output device
--   
--   <a>putChar</a> is implemented as <tt><a>hPutChar</a>
--   <a>stdout</a></tt>.
--   
--   This operation may fail with the same errors as <a>hPutChar</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Note that the following do not put a newline.
--   
--   <pre>
--   &gt;&gt;&gt; putChar 'x'
--   x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putChar '\0042'
--   *
--   </pre>
putChar :: Char -> IO ()

-- | Write a string to the standard output device
--   
--   <a>putStr</a> is implemented as <tt><a>hPutStr</a> <a>stdout</a></tt>.
--   
--   This operation may fail with the same errors, and has the same issues
--   with concurrency, as <a>hPutStr</a>!
--   
--   <h4><b>Examples</b></h4>
--   
--   Note that the following do not put a newline.
--   
--   <pre>
--   &gt;&gt;&gt; putStr "Hello, World!"
--   Hello, World!
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr "\0052\0042\0050"
--   4*2
--   </pre>
putStr :: String -> IO ()

-- | The same as <a>putStr</a>, but adds a newline character.
--   
--   This operation may fail with the same errors, and has the same issues
--   with concurrency, as <a>hPutStr</a>!
putStrLn :: String -> IO ()

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   <a>print</a> is implemented as <tt><a>putStrLn</a> <a>.</a>
--   <a>show</a></tt>
--   
--   This operation may fail with the same errors, and has the same issues
--   with concurrency, as <a>hPutStr</a>!
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; print [1, 2, 3]
--   [1,2,3]
--   </pre>
--   
--   Be careful when using <a>print</a> for outputting strings, as this
--   will invoke <a>show</a> and cause strings to be printed with quotation
--   marks and non-ascii symbols escaped.
--   
--   <pre>
--   &gt;&gt;&gt; print "λ :D"
--   "\995 :D"
--   </pre>
--   
--   A program to print the first 8 integers and their powers of 2 could be
--   written as:
--   
--   <pre>
--   &gt;&gt;&gt; print [(n, 2^n) | n &lt;- [0..8]]
--   [(0,1),(1,2),(2,4),(3,8),(4,16),(5,32),(6,64),(7,128),(8,256)]
--   </pre>
print :: Show a => a -> IO ()

-- | Read a single character from the standard input device.
--   
--   <a>getChar</a> is implemented as <tt><a>hGetChar</a>
--   <a>stdin</a></tt>.
--   
--   This operation may fail with the same errors as <a>hGetChar</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; getChar
--   a'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getChar
--   &gt;
--   '\n'
--   </pre>
getChar :: IO Char

-- | Read a line from the standard input device.
--   
--   <a>getLine</a> is implemented as <tt><a>hGetLine</a>
--   <a>stdin</a></tt>.
--   
--   This operation may fail with the same errors as <a>hGetLine</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; getLine
--   &gt; Hello World!
--   "Hello World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getLine
--   &gt;
--   ""
--   </pre>
getLine :: IO String

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed.
--   
--   <a>getContents</a> is implemented as <tt><a>hGetContents</a>
--   <a>stdin</a></tt>.
--   
--   This operation may fail with the same errors as <a>hGetContents</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; getContents &gt;&gt;= putStr
--   &gt; aaabbbccc :D
--   aaabbbccc :D
--   &gt; I hope you have a great day
--   I hope you have a great day
--   &gt; ^D
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getContents &gt;&gt;= print . length
--   &gt; abc
--   &gt; &lt;3
--   &gt; def ^D
--   11
--   </pre>
getContents :: IO String

-- | The <a>getContents'</a> operation returns all user input as a single
--   string, which is fully read before being returned
--   
--   <a>getContents'</a> is implemented as <tt><a>hGetContents'</a>
--   <a>stdin</a></tt>.
--   
--   This operation may fail with the same errors as <a>hGetContents'</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; getContents' &gt;&gt;= putStr
--   &gt; aaabbbccc :D
--   &gt; I hope you have a great day
--   aaabbbccc :D
--   I hope you have a great day
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getContents' &gt;&gt;= print . length
--   &gt; abc
--   &gt; &lt;3
--   &gt; def ^D
--   11
--   </pre>
getContents' :: IO String

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isUserError</a> if there is no unambiguous parse.</li>
--   </ul>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; fmap (+ 1) (readIO "1")
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; readIO "not quite ()" :: IO ()
--   *** Exception: user error (Prelude.readIO: no parse)
--   </pre>
readIO :: Read a => String -> IO a

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
--   
--   This operation may fail with the same errors as <a>getLine</a> and
--   <a>readIO</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; fmap (+ 5) readLn
--   &gt; 25
--   30
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; readLn :: IO String
--   &gt; this is not a string literal
--   *** Exception: user error (Prelude.readIO: no parse)
--   </pre>
readLn :: Read a => IO a

-- | The computation <tt><a>withBinaryFile</a> path mode action</tt> opens
--   the binary file and runs <tt>action</tt> with the obtained handle
--   before closing the binary file.
--   
--   This is different from <a>withFile</a> as in that it does not use any
--   file encoding.
--   
--   Even when an exception is raised within the <tt>action</tt>, the file
--   will still be closed. This is why <tt><a>withBinaryFile</a> path mode
--   act</tt> is preferable to
--   
--   <pre>
--   <a>openBinaryFile</a> path mode &gt;&gt;= (\hdl -&gt; act hdl &gt;&gt;= <a>hClose</a> hdl)
--   </pre>
--   
--   See also: <a>bracket</a>
withBinaryFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r

-- | The computation <tt><a>openBinaryFile</a> path mode</tt> returns a
--   file handle that can be used to interact with the binary file.
--   
--   This is different from <a>openFile</a> as in that it does not use any
--   file encoding.
openBinaryFile :: FilePath -> IOMode -> IO Handle

-- | Select binary mode (<a>True</a>) or text mode (<a>False</a>) on a open
--   handle. (See also <a>openBinaryFile</a>.)
--   
--   This has the same effect as calling <a>hSetEncoding</a> with
--   <a>char8</a>, together with <a>hSetNewlineMode</a> with
--   <a>noNewlineTranslation</a>.
hSetBinaryMode :: Handle -> Bool -> IO ()

-- | <a>hPutBuf</a> <tt>hdl buf count</tt> writes <tt>count</tt> 8-bit
--   bytes from the buffer <tt>buf</tt> to the handle <tt>hdl</tt>. It
--   returns ().
--   
--   <a>hPutBuf</a> ignores any text encoding that applies to the
--   <a>Handle</a>, writing the bytes directly to the underlying file or
--   device.
--   
--   <a>hPutBuf</a> ignores the prevailing <a>TextEncoding</a> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and writes bytes directly.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>ResourceVanished</a> if the handle is a pipe or socket, and the
--   reading end is closed. (If this is a POSIX system, and the program has
--   not asked to ignore SIGPIPE, then a SIGPIPE may be delivered instead,
--   whose default action is to terminate the program).</li>
--   </ul>
hPutBuf :: Handle -> Ptr a -> Int -> IO ()

-- | <a>hGetBuf</a> <tt>hdl buf count</tt> reads data from the handle
--   <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is reached
--   or <tt>count</tt> 8-bit bytes have been read. It returns the number of
--   bytes actually read. This may be zero if EOF was reached before any
--   data was read (or if <tt>count</tt> is zero).
--   
--   <a>hGetBuf</a> never raises an EOF exception, instead it returns a
--   value smaller than <tt>count</tt>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBuf</a> will behave as if EOF was reached.
--   
--   <a>hGetBuf</a> ignores the prevailing <a>TextEncoding</a> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
hGetBuf :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hGetBufSome</a> <tt>hdl buf count</tt> reads data from the handle
--   <tt>hdl</tt> into the buffer <tt>buf</tt>. If there is any data
--   available to read, then <a>hGetBufSome</a> returns it immediately; it
--   only blocks if there is no data to be read.
--   
--   It returns the number of bytes actually read. This may be zero if EOF
--   was reached before any data was read (or if <tt>count</tt> is zero).
--   
--   <a>hGetBufSome</a> never raises an EOF exception, instead it returns a
--   value smaller than <tt>count</tt>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBufSome</a> will behave as if EOF was reached.
--   
--   <a>hGetBufSome</a> ignores the prevailing <a>TextEncoding</a> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
hGetBufSome :: Handle -> Ptr a -> Int -> IO Int
hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hGetBufNonBlocking</a> <tt>hdl buf count</tt> reads data from the
--   handle <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is
--   reached, or <tt>count</tt> 8-bit bytes have been read, or there is no
--   more data available to read immediately.
--   
--   <a>hGetBufNonBlocking</a> is identical to <a>hGetBuf</a>, except that
--   it will never block waiting for data to become available, instead it
--   returns only whatever data is available. To wait for data to arrive
--   before calling <a>hGetBufNonBlocking</a>, use <a>hWaitForInput</a>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBufNonBlocking</a> will behave as if EOF was reached.
--   
--   <a>hGetBufNonBlocking</a> ignores the prevailing <a>TextEncoding</a>
--   and <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
--   
--   NOTE: on Windows, this function does not work correctly; it behaves
--   identically to <a>hGetBuf</a>.
hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int

-- | The function creates a temporary file in ReadWrite mode. The created
--   file isn't deleted automatically, so you need to delete it manually.
--   
--   The file is created with permissions such that only the current user
--   can read/write it.
--   
--   With some exceptions (see below), the file will be created securely in
--   the sense that an attacker should not be able to cause openTempFile to
--   overwrite another file on the filesystem using your credentials, by
--   putting symbolic links (on Unix) in the place where the temporary file
--   is to be created. On Unix the <tt>O_CREAT</tt> and <tt>O_EXCL</tt>
--   flags are used to prevent this attack, but note that <tt>O_EXCL</tt>
--   is sometimes not supported on NFS filesystems, so if you rely on this
--   behaviour it is best to use local filesystems only.
openTempFile :: FilePath -> String -> IO (FilePath, Handle)

-- | Like <a>openTempFile</a>, but opens the file in binary mode. See
--   <a>openBinaryFile</a> for more comments.
openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)

-- | Like <a>openTempFile</a>, but uses the default file permissions
openTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)

-- | Like <a>openBinaryTempFile</a>, but uses the default file permissions
openBinaryTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)

-- | The action <a>hSetEncoding</a> <tt>hdl</tt> <tt>encoding</tt> changes
--   the text encoding for the handle <tt>hdl</tt> to <tt>encoding</tt>.
--   The default encoding when a <a>Handle</a> is created is
--   <a>localeEncoding</a>, namely the default encoding for the current
--   locale.
--   
--   To create a <a>Handle</a> with no encoding at all, use
--   <a>openBinaryFile</a>. To stop further encoding or decoding on an
--   existing <a>Handle</a>, use <a>hSetBinaryMode</a>.
--   
--   <a>hSetEncoding</a> may need to flush buffered data in order to change
--   the encoding.
hSetEncoding :: Handle -> TextEncoding -> IO ()

-- | Return the current <a>TextEncoding</a> for the specified
--   <a>Handle</a>, or <a>Nothing</a> if the <a>Handle</a> is in binary
--   mode.
--   
--   Note that the <a>TextEncoding</a> remembers nothing about the state of
--   the encoder/decoder in use on this <a>Handle</a>. For example, if the
--   encoding in use is UTF-16, then using <a>hGetEncoding</a> and
--   <a>hSetEncoding</a> to save and restore the encoding may result in an
--   extra byte-order-mark being written to the file.
hGetEncoding :: Handle -> IO (Maybe TextEncoding)

-- | A <a>TextEncoding</a> is a specification of a conversion scheme
--   between sequences of bytes and sequences of Unicode characters.
--   
--   For example, UTF-8 is an encoding of Unicode characters into a
--   sequence of bytes. The <a>TextEncoding</a> for UTF-8 is <a>utf8</a>.
data TextEncoding

-- | The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to
--   the first 256 Unicode code points, and is thus not a complete Unicode
--   encoding. An attempt to write a character greater than <tt>'\255'</tt>
--   to a <a>Handle</a> using the <a>latin1</a> encoding will result in an
--   error.
latin1 :: TextEncoding

-- | The UTF-8 Unicode encoding
utf8 :: TextEncoding

-- | The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte
--   sequence 0xEF 0xBB 0xBF). This encoding behaves like <a>utf8</a>,
--   except that on input, the BOM sequence is ignored at the beginning of
--   the stream, and on output, the BOM sequence is prepended.
--   
--   The byte-order-mark is strictly unnecessary in UTF-8, but is sometimes
--   used to identify the encoding of a file.
utf8_bom :: TextEncoding

-- | The UTF-16 Unicode encoding (a byte-order-mark should be used to
--   indicate endianness).
utf16 :: TextEncoding

-- | The UTF-16 Unicode encoding (little-endian)
utf16le :: TextEncoding

-- | The UTF-16 Unicode encoding (big-endian)
utf16be :: TextEncoding

-- | The UTF-32 Unicode encoding (a byte-order-mark should be used to
--   indicate endianness).
utf32 :: TextEncoding

-- | The UTF-32 Unicode encoding (little-endian)
utf32le :: TextEncoding

-- | The UTF-32 Unicode encoding (big-endian)
utf32be :: TextEncoding

-- | The encoding of the current locale.
--   
--   This is the initial locale encoding: if it has been subsequently
--   changed by <a>setLocaleEncoding</a> this value will not reflect that
--   change.
localeEncoding :: TextEncoding

-- | An encoding in which Unicode code points are translated to bytes by
--   taking the code point modulo 256. When decoding, bytes are translated
--   directly into the equivalent code point.
--   
--   This encoding never fails in either direction. However, encoding
--   discards information, so encode followed by decode is not the
--   identity.
char8 :: TextEncoding

-- | Look up the named Unicode encoding. May fail with
--   
--   <ul>
--   <li><a>isDoesNotExistError</a> if the encoding is unknown</li>
--   </ul>
--   
--   The set of known encodings is system-dependent, but includes at least:
--   
--   <ul>
--   <li><pre>UTF-8</pre></li>
--   <li><tt>UTF-16</tt>, <tt>UTF-16BE</tt>, <tt>UTF-16LE</tt></li>
--   <li><tt>UTF-32</tt>, <tt>UTF-32BE</tt>, <tt>UTF-32LE</tt></li>
--   </ul>
--   
--   There is additional notation (borrowed from GNU iconv) for specifying
--   how illegal characters are handled:
--   
--   <ul>
--   <li>a suffix of <tt>//IGNORE</tt>, e.g. <tt>UTF-8//IGNORE</tt>, will
--   cause all illegal sequences on input to be ignored, and on output will
--   drop all code points that have no representation in the target
--   encoding.</li>
--   <li>a suffix of <tt>//TRANSLIT</tt> will choose a replacement
--   character for illegal sequences or code points.</li>
--   <li>a suffix of <tt>//ROUNDTRIP</tt> will use a PEP383-style escape
--   mechanism to represent any invalid bytes in the input as Unicode
--   codepoints (specifically, as lone surrogates, which are normally
--   invalid in UTF-32). Upon output, these special codepoints are detected
--   and turned back into the corresponding original byte.</li>
--   </ul>
--   
--   In theory, this mechanism allows arbitrary data to be roundtripped via
--   a <a>String</a> with no loss of data. In practice, there are two
--   limitations to be aware of:
--   
--   <ol>
--   <li>This only stands a chance of working for an encoding which is an
--   ASCII superset, as for security reasons we refuse to escape any bytes
--   smaller than 128. Many encodings of interest are ASCII supersets (in
--   particular, you can assume that the locale encoding is an ASCII
--   superset) but many (such as UTF-16) are not.</li>
--   <li>If the underlying encoding is not itself roundtrippable, this
--   mechanism can fail. Roundtrippable encodings are those which have an
--   injective mapping into Unicode. Almost all encodings meet this
--   criterion, but some do not. Notably, Shift-JIS (CP932) and Big5
--   contain several different encodings of the same Unicode
--   codepoint.</li>
--   </ol>
--   
--   On Windows, you can access supported code pages with the prefix
--   <tt>CP</tt>; for example, <tt>"CP1250"</tt>.
mkTextEncoding :: String -> IO TextEncoding

-- | Set the <a>NewlineMode</a> on the specified <a>Handle</a>. All
--   buffered data is flushed first.
hSetNewlineMode :: Handle -> NewlineMode -> IO ()

-- | The representation of a newline in the external file or stream.
data Newline

-- | <pre>
--   '\n'
--   </pre>
LF :: Newline

-- | <pre>
--   '\r\n'
--   </pre>
CRLF :: Newline

-- | The native newline representation for the current platform: <a>LF</a>
--   on Unix systems, <a>CRLF</a> on Windows.
nativeNewline :: Newline

-- | Specifies the translation, if any, of newline characters between
--   internal Strings and the external file or stream. Haskell Strings are
--   assumed to represent newlines with the <tt>'\n'</tt> character; the
--   newline mode specifies how to translate <tt>'\n'</tt> on output, and
--   what to translate into <tt>'\n'</tt> on input.
data NewlineMode
NewlineMode :: Newline -> Newline -> NewlineMode

-- | the representation of newlines on input
[inputNL] :: NewlineMode -> Newline

-- | the representation of newlines on output
[outputNL] :: NewlineMode -> Newline

-- | Do no newline translation at all.
--   
--   <pre>
--   noNewlineTranslation  = NewlineMode { inputNL  = LF, outputNL = LF }
--   </pre>
noNewlineTranslation :: NewlineMode

-- | Map <tt>'\r\n'</tt> into <tt>'\n'</tt> on input, and <tt>'\n'</tt> to
--   the native newline representation on output. This mode can be used on
--   any platform, and works with text files using any newline convention.
--   The downside is that <tt>readFile &gt;&gt;= writeFile</tt> might yield
--   a different file.
--   
--   <pre>
--   universalNewlineMode  = NewlineMode { inputNL  = CRLF,
--                                         outputNL = nativeNewline }
--   </pre>
universalNewlineMode :: NewlineMode

-- | Use the native newline representation on both input and output
--   
--   <pre>
--   nativeNewlineMode  = NewlineMode { inputNL  = nativeNewline
--                                      outputNL = nativeNewline }
--   </pre>
nativeNewlineMode :: NewlineMode


-- | Exiting the program.
module GHC.Internal.System.Exit

-- | Defines the exit codes that a program can return.
data ExitCode

-- | indicates successful termination;
ExitSuccess :: ExitCode

-- | indicates program failure with an exit code. The exact interpretation
--   of the code is operating-system dependent. In particular, some values
--   may be prohibited (e.g. 0 on a POSIX-compliant system).
ExitFailure :: Int -> ExitCode

-- | Computation <a>exitWith</a> <tt>code</tt> throws <a>ExitCode</a>
--   <tt>code</tt>. Normally this terminates the program, returning
--   <tt>code</tt> to the program's caller.
--   
--   On program termination, the standard <a>Handle</a>s <a>stdout</a> and
--   <a>stderr</a> are flushed automatically; any other buffered
--   <a>Handle</a>s need to be flushed manually, otherwise the buffered
--   data will be discarded.
--   
--   A program that fails in any other way is treated as if it had called
--   <a>exitFailure</a>. A program that terminates successfully without
--   calling <a>exitWith</a> explicitly is treated as if it had called
--   <a>exitWith</a> <a>ExitSuccess</a>.
--   
--   As an <a>ExitCode</a> is an <a>Exception</a>, it can be caught using
--   the functions of <a>Control.Exception</a>. This means that cleanup
--   computations added with <a>bracket</a> (from <a>Control.Exception</a>)
--   are also executed properly on <a>exitWith</a>.
--   
--   Note: in GHC, <a>exitWith</a> should be called from the main program
--   thread in order to exit the process. When called from another thread,
--   <a>exitWith</a> will throw an <a>ExitCode</a> as normal, but the
--   exception will not cause the process itself to exit.
exitWith :: ExitCode -> IO a

-- | The computation <a>exitFailure</a> is equivalent to <a>exitWith</a>
--   <tt>(</tt><a>ExitFailure</a> <i>exitfail</i><tt>)</tt>, where
--   <i>exitfail</i> is implementation-dependent.
exitFailure :: IO a

-- | The computation <a>exitSuccess</a> is equivalent to <a>exitWith</a>
--   <a>ExitSuccess</a>, It terminates the program successfully.
exitSuccess :: IO a

-- | Write given error message to <a>stderr</a> and terminate with
--   <a>exitFailure</a>.
die :: String -> IO a

module GHC.Internal.Fingerprint
data Fingerprint
Fingerprint :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> Fingerprint
fingerprint0 :: Fingerprint
fingerprintData :: Ptr Word8 -> Int -> IO Fingerprint
fingerprintString :: String -> Fingerprint
fingerprintFingerprints :: [Fingerprint] -> Fingerprint

-- | Computes the hash of a given file. This function loops over the
--   handle, running in constant memory.
getFileHash :: FilePath -> IO Fingerprint


-- | Symbolic references to values.
--   
--   References to values are usually implemented with memory addresses,
--   and this is practical when communicating values between the different
--   pieces of a single process.
--   
--   When values are communicated across different processes running in
--   possibly different machines, though, addresses are no longer useful
--   since each process may use different addresses to store a given value.
--   
--   To solve such concern, the references provided by this module offer a
--   key that can be used to locate the values on each process. Each
--   process maintains a global table of references which can be looked up
--   with a given key. This table is known as the Static Pointer Table. The
--   reference can then be dereferenced to obtain the value.
--   
--   The various communicating processes need to agree on the keys used to
--   refer to the values in the Static Pointer Table, or lookups will fail.
--   Only processes launched from the same program binary are guaranteed to
--   use the same set of keys.
module GHC.Internal.StaticPtr

-- | A reference to a value of type <tt>a</tt>.
data StaticPtr a

-- | Dereferences a static pointer.
deRefStaticPtr :: StaticPtr a -> a

-- | A key for <a>StaticPtr</a>s that can be serialized and used with
--   <a>unsafeLookupStaticPtr</a>.
type StaticKey = Fingerprint

-- | The <a>StaticKey</a> that can be used to look up the given
--   <a>StaticPtr</a>.
staticKey :: StaticPtr a -> StaticKey

-- | Looks up a <a>StaticPtr</a> by its <a>StaticKey</a>.
--   
--   If the <a>StaticPtr</a> is not found returns <tt>Nothing</tt>.
--   
--   This function is unsafe because the program behavior is undefined if
--   the type of the returned <a>StaticPtr</a> does not match the expected
--   one.
unsafeLookupStaticPtr :: StaticKey -> IO (Maybe (StaticPtr a))

-- | Miscellaneous information available for debugging purposes.
data StaticPtrInfo
StaticPtrInfo :: String -> String -> (Int, Int) -> StaticPtrInfo

-- | Package key of the package where the static pointer is defined
[spInfoUnitId] :: StaticPtrInfo -> String

-- | Name of the module where the static pointer is defined
[spInfoModuleName] :: StaticPtrInfo -> String

-- | Source location of the definition of the static pointer as a
--   <tt>(Line, Column)</tt> pair.
[spInfoSrcLoc] :: StaticPtrInfo -> (Int, Int)

-- | <a>StaticPtrInfo</a> of the given <a>StaticPtr</a>.
staticPtrInfo :: StaticPtr a -> StaticPtrInfo

-- | A list of all known keys.
staticPtrKeys :: IO [StaticKey]

-- | A class for things buildable from static pointers.
--   
--   GHC wraps each use of the <tt>static</tt> keyword with
--   <a>fromStaticPtr</a>. Because the <tt>static</tt> keyword requires its
--   argument to be an instance of <a>Typeable</a>, <a>fromStaticPtr</a>
--   carries a <a>Typeable</a> constraint as well.
class IsStatic (p :: Type -> Type)
fromStaticPtr :: (IsStatic p, Typeable a) => StaticPtr a -> p a
instance GHC.Internal.StaticPtr.IsStatic GHC.Internal.StaticPtr.StaticPtr
instance GHC.Internal.Show.Show GHC.Internal.StaticPtr.StaticPtrInfo


-- | Monadic fixpoints.
--   
--   For a detailed discussion, see Levent Erkok's thesis, <i>Value
--   Recursion in Monadic Computations</i>, Oregon Graduate Institute,
--   2002.
module GHC.Internal.Control.Monad.Fix

-- | Monads having fixed points with a 'knot-tying' semantics. Instances of
--   <a>MonadFix</a> should satisfy the following laws:
--   
--   <ul>
--   <li><i>Purity</i> <tt><a>mfix</a> (<a>return</a> . h) = <a>return</a>
--   (<a>fix</a> h)</tt></li>
--   <li><i>Left shrinking (or Tightening)</i> <tt><a>mfix</a> (\x -&gt; a
--   &gt;&gt;= \y -&gt; f x y) = a &gt;&gt;= \y -&gt; <a>mfix</a> (\x -&gt;
--   f x y)</tt></li>
--   <li><i>Sliding</i> <tt><a>mfix</a> (<a>liftM</a> h . f) = <a>liftM</a>
--   h (<a>mfix</a> (f . h))</tt>, for strict <tt>h</tt>.</li>
--   <li><i>Nesting</i> <tt><a>mfix</a> (\x -&gt; <a>mfix</a> (\y -&gt; f x
--   y)) = <a>mfix</a> (\x -&gt; f x x)</tt></li>
--   </ul>
--   
--   This class is used in the translation of the recursive <tt>do</tt>
--   notation supported by GHC and Hugs.
class Monad m => MonadFix (m :: Type -> Type)

-- | The fixed point of a monadic computation. <tt><a>mfix</a> f</tt>
--   executes the action <tt>f</tt> only once, with the eventual output fed
--   back as the input. Hence <tt>f</tt> should not be strict, for then
--   <tt><a>mfix</a> f</tt> would diverge.
mfix :: MonadFix m => (a -> m a) -> m a

-- | <tt><a>fix</a> f</tt> is the least fixed point of the function
--   <tt>f</tt>, i.e. the least defined <tt>x</tt> such that <tt>f x =
--   x</tt>.
--   
--   When <tt>f</tt> is strict, this means that because, by the definition
--   of strictness, <tt>f ⊥ = ⊥</tt> and such the least defined fixed point
--   of any strict function is <tt>⊥</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We can write the factorial function using direct recursion as
--   
--   <pre>
--   &gt;&gt;&gt; let fac n = if n &lt;= 1 then 1 else n * fac (n-1) in fac 5
--   120
--   </pre>
--   
--   This uses the fact that Haskell’s <tt>let</tt> introduces recursive
--   bindings. We can rewrite this definition using <a>fix</a>,
--   
--   Instead of making a recursive call, we introduce a dummy parameter
--   <tt>rec</tt>; when used within <a>fix</a>, this parameter then refers
--   to <a>fix</a>’s argument, hence the recursion is reintroduced.
--   
--   <pre>
--   &gt;&gt;&gt; fix (\rec n -&gt; if n &lt;= 1 then 1 else n * rec (n-1)) 5
--   120
--   </pre>
--   
--   Using <a>fix</a>, we can implement versions of <a>repeat</a> as
--   <tt><a>fix</a> <a>.</a> <tt>(:)</tt></tt> and <a>cycle</a> as
--   <tt><a>fix</a> <a>.</a> <tt>(++)</tt></tt>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ fix (0:)
--   [0,0,0,0,0,0,0,0,0,0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (fix (\rec n -&gt; if n &lt; 2 then n else rec (n - 1) + rec (n - 2))) [1..10]
--   [1,1,2,3,5,8,13,21,34,55]
--   </pre>
--   
--   <h4><b>Implementation Details</b></h4>
--   
--   The current implementation of <a>fix</a> uses structural sharing
--   
--   <pre>
--   <a>fix</a> f = let x = f x in x
--   </pre>
--   
--   A more straightforward but non-sharing version would look like
--   
--   <pre>
--   <a>fix</a> f = f (<a>fix</a> f)
--   </pre>
fix :: (a -> a) -> a
instance (GHC.Internal.Control.Monad.Fix.MonadFix f, GHC.Internal.Control.Monad.Fix.MonadFix g) => GHC.Internal.Control.Monad.Fix.MonadFix (f GHC.Internal.Generics.:*: g)
instance GHC.Internal.Control.Monad.Fix.MonadFix f => GHC.Internal.Control.Monad.Fix.MonadFix (GHC.Internal.Data.Semigroup.Internal.Alt f)
instance GHC.Internal.Control.Monad.Fix.MonadFix f => GHC.Internal.Control.Monad.Fix.MonadFix (GHC.Internal.Data.Monoid.Ap f)
instance GHC.Internal.Control.Monad.Fix.MonadFix GHC.Internal.Data.Ord.Down
instance GHC.Internal.Control.Monad.Fix.MonadFix GHC.Internal.Data.Semigroup.Internal.Dual
instance GHC.Internal.Control.Monad.Fix.MonadFix (GHC.Internal.Data.Either.Either e)
instance GHC.Internal.Control.Monad.Fix.MonadFix ((->) r)
instance GHC.Internal.Control.Monad.Fix.MonadFix GHC.Internal.Data.Monoid.First
instance GHC.Internal.Control.Monad.Fix.MonadFix GHC.Types.IO
instance GHC.Internal.Control.Monad.Fix.MonadFix GHC.Internal.Data.Monoid.Last
instance GHC.Internal.Control.Monad.Fix.MonadFix []
instance GHC.Internal.Control.Monad.Fix.MonadFix f => GHC.Internal.Control.Monad.Fix.MonadFix (GHC.Internal.Generics.M1 i c f)
instance GHC.Internal.Control.Monad.Fix.MonadFix GHC.Internal.Maybe.Maybe
instance GHC.Internal.Control.Monad.Fix.MonadFix GHC.Internal.Base.NonEmpty
instance GHC.Internal.Control.Monad.Fix.MonadFix GHC.Internal.Generics.Par1
instance GHC.Internal.Control.Monad.Fix.MonadFix GHC.Internal.Data.Semigroup.Internal.Product
instance GHC.Internal.Control.Monad.Fix.MonadFix f => GHC.Internal.Control.Monad.Fix.MonadFix (GHC.Internal.Generics.Rec1 f)
instance GHC.Internal.Control.Monad.Fix.MonadFix (GHC.Internal.ST.ST s)
instance GHC.Internal.Control.Monad.Fix.MonadFix GHC.Tuple.Solo
instance GHC.Internal.Control.Monad.Fix.MonadFix GHC.Internal.Data.Semigroup.Internal.Sum
instance GHC.Internal.Base.Monoid a => GHC.Internal.Control.Monad.Fix.MonadFix ((,) a)


-- | The identity functor and monad.
--   
--   This trivial type constructor serves two purposes:
--   
--   <ul>
--   <li>It can be used with functions parameterized by functor or monad
--   classes.</li>
--   <li>It can be used as a base monad to which a series of monad
--   transformers may be applied to construct a composite monad. Most monad
--   transformer modules include the special case of applying the
--   transformer to <a>Identity</a>. For example, <tt>State s</tt> is an
--   abbreviation for <tt>StateT s <a>Identity</a></tt>.</li>
--   </ul>
module GHC.Internal.Data.Functor.Identity

-- | Identity functor and monad. (a non-strict monad)
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; fmap (+1) (Identity 0)
--   Identity 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Identity [1, 2, 3] &lt;&gt; Identity [4, 5, 6]
--   Identity [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; do
--         x &lt;- Identity 10
--         y &lt;- Identity (x + 5)
--         pure (x + y)
--   Identity 25
--   </pre>
newtype Identity a
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a
instance GHC.Internal.Base.Applicative GHC.Internal.Data.Functor.Identity.Identity
instance GHC.Internal.Bits.Bits a => GHC.Internal.Bits.Bits (GHC.Internal.Data.Functor.Identity.Identity a)
instance GHC.Internal.Enum.Bounded a => GHC.Internal.Enum.Bounded (GHC.Internal.Data.Functor.Identity.Identity a)
instance GHC.Internal.Enum.Enum a => GHC.Internal.Enum.Enum (GHC.Internal.Data.Functor.Identity.Identity a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Internal.Data.Functor.Identity.Identity a)
instance GHC.Internal.Bits.FiniteBits a => GHC.Internal.Bits.FiniteBits (GHC.Internal.Data.Functor.Identity.Identity a)
instance GHC.Internal.Float.Floating a => GHC.Internal.Float.Floating (GHC.Internal.Data.Functor.Identity.Identity a)
instance GHC.Internal.Data.Foldable.Foldable GHC.Internal.Data.Functor.Identity.Identity
instance GHC.Internal.Real.Fractional a => GHC.Internal.Real.Fractional (GHC.Internal.Data.Functor.Identity.Identity a)
instance GHC.Internal.Base.Functor GHC.Internal.Data.Functor.Identity.Identity
instance GHC.Internal.Generics.Generic1 GHC.Internal.Data.Functor.Identity.Identity
instance GHC.Internal.Generics.Generic (GHC.Internal.Data.Functor.Identity.Identity a)
instance GHC.Internal.Real.Integral a => GHC.Internal.Real.Integral (GHC.Internal.Data.Functor.Identity.Identity a)
instance GHC.Internal.Ix.Ix a => GHC.Internal.Ix.Ix (GHC.Internal.Data.Functor.Identity.Identity a)
instance GHC.Internal.Control.Monad.Fix.MonadFix GHC.Internal.Data.Functor.Identity.Identity
instance GHC.Internal.Base.Monad GHC.Internal.Data.Functor.Identity.Identity
instance GHC.Internal.Base.Monoid a => GHC.Internal.Base.Monoid (GHC.Internal.Data.Functor.Identity.Identity a)
instance GHC.Internal.Num.Num a => GHC.Internal.Num.Num (GHC.Internal.Data.Functor.Identity.Identity a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Internal.Data.Functor.Identity.Identity a)
instance GHC.Internal.Read.Read a => GHC.Internal.Read.Read (GHC.Internal.Data.Functor.Identity.Identity a)
instance GHC.Internal.Float.RealFloat a => GHC.Internal.Float.RealFloat (GHC.Internal.Data.Functor.Identity.Identity a)
instance GHC.Internal.Real.RealFrac a => GHC.Internal.Real.RealFrac (GHC.Internal.Data.Functor.Identity.Identity a)
instance GHC.Internal.Real.Real a => GHC.Internal.Real.Real (GHC.Internal.Data.Functor.Identity.Identity a)
instance GHC.Internal.Base.Semigroup a => GHC.Internal.Base.Semigroup (GHC.Internal.Data.Functor.Identity.Identity a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Internal.Data.Functor.Identity.Identity a)
instance GHC.Internal.Foreign.Storable.Storable a => GHC.Internal.Foreign.Storable.Storable (GHC.Internal.Data.Functor.Identity.Identity a)


-- | Class of data structures that can be traversed from left to right,
--   performing an action on each element. Instances are expected to
--   satisfy the listed <a>laws</a>.
module GHC.Internal.Data.Traversable

-- | Functors representing data structures that can be transformed to
--   structures of the <i>same shape</i> by performing an
--   <a>Applicative</a> (or, therefore, <a>Monad</a>) action on each
--   element from left to right.
--   
--   A more detailed description of what <i>same shape</i> means, the
--   various methods, how traversals are constructed, and example advanced
--   use-cases can be found in the <b>Overview</b> section of
--   <a>Data.Traversable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Traversable#laws</a>.
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   In the first two examples we show each evaluated action mapping to the
--   output structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse Just [1,2,3,4]
--   Just [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   In the next examples, we show that <a>Nothing</a> and <a>Left</a>
--   values short circuit the created structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse (const Nothing) [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse (\x -&gt; if odd x then Just x else Nothing)  [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4, Left 0]
--   Left 0
--   </pre>
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   For the first two examples we show sequenceA fully evaluating a a
--   structure and collecting the results.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3]
--   Just [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3]
--   Right [1,2,3]
--   </pre>
--   
--   The next two example show <a>Nothing</a> and <a>Just</a> will short
--   circuit the resulting structure if present in the input. For more
--   context, check the <a>Traversable</a> instances for <a>Either</a> and
--   <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3, Nothing]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3, Left 4]
--   Left 4
--   </pre>
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <a>mapM</a> is literally a <a>traverse</a> with a type signature
--   restricted to <a>Monad</a>. Its implementation may be more efficient
--   due to additional power of <a>Monad</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   The first two examples are instances where the input and and output of
--   <a>sequence</a> are isomorphic.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Right [1,2,3,4]
--   [Right 1,Right 2,Right 3,Right 4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Right 1,Right 2,Right 3,Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   The following examples demonstrate short circuit behavior for
--   <a>sequence</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Left [1,2,3,4]
--   Left [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Left 0, Right 1,Right 2,Right 3,Right 4]
--   Left 0
--   </pre>
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | <a>for</a> is <a>traverse</a> with its arguments flipped. For a
--   version that ignores the results see <a>for_</a>.
for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | <a>forAccumM</a> is <a>mapAccumM</a> with the arguments rearranged.
forAccumM :: (Monad m, Traversable t) => s -> t a -> (s -> a -> m (s, b)) -> m (s, t b)

-- | The <a>mapAccumL</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldl</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from left to right, and
--   returning a final value of this accumulator together with the new
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumL (\a b -&gt; (a + b, a)) 0 [1..10]
--   (55,[0,1,3,6,10,15,21,28,36,45])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumL (\a b -&gt; (a &lt;&gt; show b, a)) "0" [1..5]
--   ("012345",["0","01","012","0123","01234"])
--   </pre>
mapAccumL :: Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | The <a>mapAccumR</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldr</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from right to left, and
--   returning a final value of this accumulator together with the new
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumR (\a b -&gt; (a + b, a)) 0 [1..10]
--   (55,[54,52,49,45,40,34,27,19,10,0])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumR (\a b -&gt; (a &lt;&gt; show b, a)) "0" [1..5]
--   ("054321",["05432","0543","054","05","0"])
--   </pre>
mapAccumR :: Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | The <a>mapAccumM</a> function behaves like a combination of
--   <a>mapM</a> and <a>mapAccumL</a> that traverses the structure while
--   evaluating the actions and passing an accumulating parameter from left
--   to right. It returns a final value of this accumulator together with
--   the new structure. The accumulator is often used for caching the
--   intermediate results of a computation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let expensiveDouble a = putStrLn ("Doubling " &lt;&gt; show a) &gt;&gt; pure (2 * a)
--   
--   &gt;&gt;&gt; :{
--   mapAccumM (\cache a -&gt; case lookup a cache of
--       Nothing -&gt; expensiveDouble a &gt;&gt;= \double -&gt; pure ((a, double):cache, double)
--       Just double -&gt; pure (cache, double)
--       ) [] [1, 2, 3, 1, 2, 3]
--   :}
--   Doubling 1
--   Doubling 2
--   Doubling 3
--   ([(3,6),(2,4),(1,2)],[2,4,6,2,4,6])
--   </pre>
mapAccumM :: (Monad m, Traversable t) => (s -> a -> m (s, b)) -> s -> t a -> m (s, t b)

-- | This function may be used as a value for <a>fmap</a> in a
--   <a>Functor</a> instance, provided that <a>traverse</a> is defined.
--   (Using <a>fmapDefault</a> with a <a>Traversable</a> instance defined
--   only by <a>sequenceA</a> will result in infinite recursion.)
--   
--   <pre>
--   <a>fmapDefault</a> f ≡ <a>runIdentity</a> . <a>traverse</a> (<a>Identity</a> . f)
--   </pre>
fmapDefault :: Traversable t => (a -> b) -> t a -> t b

-- | This function may be used as a value for <a>foldMap</a> in a
--   <a>Foldable</a> instance.
--   
--   <pre>
--   <a>foldMapDefault</a> f ≡ <a>getConst</a> . <a>traverse</a> (<a>Const</a> . f)
--   </pre>
foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
instance (GHC.Internal.Data.Traversable.Traversable f, GHC.Internal.Data.Traversable.Traversable g) => GHC.Internal.Data.Traversable.Traversable (f GHC.Internal.Generics.:*: g)
instance (GHC.Internal.Data.Traversable.Traversable f, GHC.Internal.Data.Traversable.Traversable g) => GHC.Internal.Data.Traversable.Traversable (f GHC.Internal.Generics.:+: g)
instance (GHC.Internal.Data.Traversable.Traversable f, GHC.Internal.Data.Traversable.Traversable g) => GHC.Internal.Data.Traversable.Traversable (f GHC.Internal.Generics.:.: g)
instance GHC.Internal.Data.Traversable.Traversable f => GHC.Internal.Data.Traversable.Traversable (GHC.Internal.Data.Semigroup.Internal.Alt f)
instance GHC.Internal.Data.Traversable.Traversable f => GHC.Internal.Data.Traversable.Traversable (GHC.Internal.Data.Monoid.Ap f)
instance GHC.Internal.Ix.Ix i => GHC.Internal.Data.Traversable.Traversable (GHC.Internal.Arr.Array i)
instance GHC.Internal.Data.Traversable.Traversable (GHC.Internal.Data.Functor.Const.Const m)
instance GHC.Internal.Data.Traversable.Traversable GHC.Internal.Data.Ord.Down
instance GHC.Internal.Data.Traversable.Traversable GHC.Internal.Data.Semigroup.Internal.Dual
instance GHC.Internal.Data.Traversable.Traversable (GHC.Internal.Data.Either.Either a)
instance GHC.Internal.Data.Traversable.Traversable GHC.Internal.Data.Monoid.First
instance GHC.Internal.Data.Traversable.Traversable GHC.Internal.Data.Functor.Identity.Identity
instance GHC.Internal.Data.Traversable.Traversable (GHC.Internal.Generics.K1 i c)
instance GHC.Internal.Data.Traversable.Traversable GHC.Internal.Data.Monoid.Last
instance GHC.Internal.Data.Traversable.Traversable []
instance GHC.Internal.Data.Traversable.Traversable f => GHC.Internal.Data.Traversable.Traversable (GHC.Internal.Generics.M1 i c f)
instance GHC.Internal.Data.Traversable.Traversable GHC.Internal.Maybe.Maybe
instance GHC.Internal.Data.Traversable.Traversable GHC.Internal.Base.NonEmpty
instance GHC.Internal.Data.Traversable.Traversable GHC.Internal.Generics.Par1
instance GHC.Internal.Data.Traversable.Traversable GHC.Internal.Data.Semigroup.Internal.Product
instance GHC.Internal.Data.Traversable.Traversable GHC.Internal.Data.Proxy.Proxy
instance GHC.Internal.Data.Traversable.Traversable f => GHC.Internal.Data.Traversable.Traversable (GHC.Internal.Generics.Rec1 f)
instance GHC.Internal.Data.Traversable.Traversable GHC.Tuple.Solo
instance GHC.Internal.Data.Traversable.Traversable GHC.Internal.Data.Semigroup.Internal.Sum
instance GHC.Internal.Data.Traversable.Traversable ((,) a)
instance GHC.Internal.Data.Traversable.Traversable GHC.Internal.Generics.U1
instance GHC.Internal.Data.Traversable.Traversable GHC.Internal.Generics.UAddr
instance GHC.Internal.Data.Traversable.Traversable GHC.Internal.Generics.UChar
instance GHC.Internal.Data.Traversable.Traversable GHC.Internal.Generics.UDouble
instance GHC.Internal.Data.Traversable.Traversable GHC.Internal.Generics.UFloat
instance GHC.Internal.Data.Traversable.Traversable GHC.Internal.Generics.UInt
instance GHC.Internal.Data.Traversable.Traversable GHC.Internal.Generics.UWord
instance GHC.Internal.Data.Traversable.Traversable GHC.Internal.Generics.V1


-- | Operations on lists.
module GHC.Internal.Data.List

-- | The builtin linked list type.
--   
--   In Haskell, lists are one of the most important data types as they are
--   often used analogous to loops in imperative programming languages.
--   These lists are singly linked, which makes them unsuited for
--   operations that require &lt;math&gt; access. Instead, they are
--   intended to be traversed.
--   
--   You can use <tt>List a</tt> or <tt>[a]</tt> in type signatures:
--   
--   <pre>
--   length :: [a] -&gt; Int
--   </pre>
--   
--   or
--   
--   <pre>
--   length :: List a -&gt; Int
--   </pre>
--   
--   They are fully equivalent, and <tt>List a</tt> will be normalised to
--   <tt>[a]</tt>.
--   
--   <h4>Usage</h4>
--   
--   Lists are constructed recursively using the right-associative
--   constructor operator (or <i>cons</i>) <tt>(:) :: a -&gt; [a] -&gt;
--   [a]</tt>, which prepends an element to a list, and the empty list
--   <tt>[]</tt>.
--   
--   <pre>
--   (1 : 2 : 3 : []) == (1 : (2 : (3 : []))) == [1, 2, 3]
--   </pre>
--   
--   Lists can also be constructed using list literals of the form
--   <tt>[x_1, x_2, ..., x_n]</tt> which are syntactic sugar and, unless
--   <tt>-XOverloadedLists</tt> is enabled, are translated into uses of
--   <tt>(:)</tt> and <tt>[]</tt>
--   
--   <a>String</a> literals, like <tt>"I 💜 hs"</tt>, are translated into
--   Lists of characters, <tt>['I', ' ', '💜', ' ', 'h', 's']</tt>.
--   
--   <h4><b>Implementation</b></h4>
--   
--   Internally and in memory, all the above are represented like this,
--   with arrows being pointers to locations in memory.
--   
--   <pre>
--   ╭───┬───┬──╮   ╭───┬───┬──╮   ╭───┬───┬──╮   ╭────╮
--   │(:)│   │ ─┼──&gt;│(:)│   │ ─┼──&gt;│(:)│   │ ─┼──&gt;│ [] │
--   ╰───┴─┼─┴──╯   ╰───┴─┼─┴──╯   ╰───┴─┼─┴──╯   ╰────╯
--         v              v              v
--         1              2              3
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; ['H', 'a', 's', 'k', 'e', 'l', 'l']
--   "Haskell"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 : [4, 1, 5, 9]
--   [1,4,1,5,9]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] : [] : []
--   [[],[]]
--   </pre>
data [] a

-- | <a>(++)</a> appends two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
--   
--   <h4><b>Performance considerations</b></h4>
--   
--   This function takes linear time in the number of elements of the
--   <b>first</b> list. Thus it is better to associate repeated
--   applications of <a>(++)</a> to the right (which is the default
--   behaviour): <tt>xs ++ (ys ++ zs)</tt> or simply <tt>xs ++ ys ++
--   zs</tt>, but not <tt>(xs ++ ys) ++ zs</tt>. For the same reason
--   <a>concat</a> <tt>=</tt> <a>foldr</a> <a>(++)</a> <tt>[]</tt> has
--   linear performance, while <a>foldl</a> <a>(++)</a> <tt>[]</tt> is
--   prone to quadratic slowdown
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1, 2, 3] ++ [4, 5, 6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ++ [1, 2, 3]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [3, 2, 1] ++ []
--   [3,2,1]
--   </pre>
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | &lt;math&gt;. Extract the first element of a list, which must be
--   non-empty.
--   
--   To disable the warning about partiality put <tt>{-# OPTIONS_GHC
--   -Wno-x-partial -Wno-unrecognised-warning-flags #-}</tt> at the top of
--   the file. To disable it throughout a package put the same options into
--   <tt>ghc-options</tt> section of Cabal file. To disable it in GHCi put
--   <tt>:set -Wno-x-partial -Wno-unrecognised-warning-flags</tt> into
--   <tt>~/.ghci</tt> config file. See also the <a>migration guide</a>.
--   
--   <h5><b>Examples</b></h5>
--   
--   <pre>
--   &gt;&gt;&gt; head [1, 2, 3]
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; head [1..]
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; head []
--   *** Exception: Prelude.head: empty list
--   </pre>

-- | <i>Warning: This is a partial function, it throws an error on empty
--   lists. Use pattern matching, <a>uncons</a> or <a>listToMaybe</a>
--   instead. Consider refactoring to use <a>Data.List.NonEmpty</a>.</i>
head :: HasCallStack => [a] -> a

-- | &lt;math&gt;. Extract the last element of a list, which must be finite
--   and non-empty.
--   
--   WARNING: This function is partial. Consider using <a>unsnoc</a>
--   instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; last [1, 2, 3]
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; last [1..]
--   * Hangs forever *
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; last []
--   *** Exception: Prelude.last: empty list
--   </pre>
last :: HasCallStack => [a] -> a

-- | &lt;math&gt;. Extract the elements after the head of a list, which
--   must be non-empty.
--   
--   To disable the warning about partiality put <tt>{-# OPTIONS_GHC
--   -Wno-x-partial -Wno-unrecognised-warning-flags #-}</tt> at the top of
--   the file. To disable it throughout a package put the same options into
--   <tt>ghc-options</tt> section of Cabal file. To disable it in GHCi put
--   <tt>:set -Wno-x-partial -Wno-unrecognised-warning-flags</tt> into
--   <tt>~/.ghci</tt> config file. See also the <a>migration guide</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; tail [1, 2, 3]
--   [2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tail [1]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tail []
--   *** Exception: Prelude.tail: empty list
--   </pre>

-- | <i>Warning: This is a partial function, it throws an error on empty
--   lists. Replace it with <a>drop</a> 1, or use pattern matching or
--   <a>uncons</a> instead. Consider refactoring to use
--   <a>Data.List.NonEmpty</a>.</i>
tail :: HasCallStack => [a] -> [a]

-- | &lt;math&gt;. Return all the elements of a list except the last one.
--   The list must be non-empty.
--   
--   WARNING: This function is partial. Consider using <a>unsnoc</a>
--   instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; init [1, 2, 3]
--   [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; init [1]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; init []
--   *** Exception: Prelude.init: empty list
--   </pre>
init :: HasCallStack => [a] -> [a]

-- | &lt;math&gt;. Decompose a list into its <a>head</a> and <a>tail</a>.
--   
--   <ul>
--   <li>If the list is empty, returns <a>Nothing</a>.</li>
--   <li>If the list is non-empty, returns <tt><a>Just</a> (x, xs)</tt>,
--   where <tt>x</tt> is the <a>head</a> of the list and <tt>xs</tt> its
--   <a>tail</a>.</li>
--   </ul>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncons []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncons [1]
--   Just (1,[])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncons [1, 2, 3]
--   Just (1,[2,3])
--   </pre>
uncons :: [a] -> Maybe (a, [a])

-- | &lt;math&gt;. Decompose a list into <a>init</a> and <a>last</a>.
--   
--   <ul>
--   <li>If the list is empty, returns <a>Nothing</a>.</li>
--   <li>If the list is non-empty, returns <tt><a>Just</a> (xs, x)</tt>,
--   where <tt>xs</tt> is the <a>init</a>ial part of the list and
--   <tt>x</tt> is its <a>last</a> element.</li>
--   </ul>
--   
--   <a>unsnoc</a> is dual to <a>uncons</a>: for a finite list <tt>xs</tt>
--   
--   <pre>
--   unsnoc xs = (\(hd, tl) -&gt; (reverse tl, hd)) &lt;$&gt; uncons (reverse xs)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc [1]
--   Just ([],1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc [1, 2, 3]
--   Just ([1,2],3)
--   </pre>
--   
--   <h4><b>Laziness</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; fst &lt;$&gt; unsnoc [undefined]
--   Just []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; head . fst &lt;$&gt; unsnoc (1 : undefined)
--   Just *** Exception: Prelude.undefined
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; head . fst &lt;$&gt; unsnoc (1 : 2 : undefined)
--   Just 1
--   </pre>
unsnoc :: [a] -> Maybe ([a], a)

-- | Construct a list from a single element.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; singleton True
--   [True]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; singleton [1, 2, 3]
--   [[1,2,3]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; singleton 'c'
--   "c"
--   </pre>
singleton :: a -> [a]

-- | Test whether the structure is empty. The default implementation is
--   Left-associative and lazy in both the initial element and the
--   accumulator. Thus optimised for structures where the first element can
--   be accessed in constant time. Structures where this is not the case
--   should have a non-default implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; null []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null [1]
--   False
--   </pre>
--   
--   <a>null</a> is expected to terminate even for infinite structures. The
--   default implementation terminates provided the structure is bounded on
--   the left (there is a leftmost element).
--   
--   <pre>
--   &gt;&gt;&gt; null [1..]
--   False
--   </pre>
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation just counts elements starting with the
--   leftmost. Instances for structures that can compute the element count
--   faster than via element-by-element counting, should provide a
--   specialised implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; length []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length ['a', 'b', 'c']
--   3
--   
--   &gt;&gt;&gt; length [1..]
--   * Hangs forever *
--   </pre>
length :: Foldable t => t a -> Int

-- | &lt;math&gt;. <a>map</a> <tt>f xs</tt> is the list obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   this means that <tt>map id == id</tt>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map id [1, 2, 3]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (\n -&gt; 3 * n + 1) [1, 2, 3]
--   [4,7,10]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | &lt;math&gt;. <a>reverse</a> <tt>xs</tt> returns the elements of
--   <tt>xs</tt> in reverse order. <tt>xs</tt> must be finite.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <a>reverse</a> is lazy in its elements.
--   
--   <pre>
--   &gt;&gt;&gt; head (reverse [undefined, 1])
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reverse (1 : 2 : undefined)
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; reverse []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reverse [42]
--   [42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reverse [2,5,7]
--   [7,5,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reverse [1..]
--   * Hangs forever *
--   </pre>
reverse :: [a] -> [a]

-- | &lt;math&gt;. The <a>intersperse</a> function takes an element and a
--   list and `intersperses' that element between the elements of the list.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <a>intersperse</a> has the following properties
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (intersperse undefined ('a' : undefined))
--   "a"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 2 (intersperse ',' ('a' : undefined))
--   "a*** Exception: Prelude.undefined
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; intersperse ',' "abcde"
--   "a,b,c,d,e"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intersperse 1 [3, 4, 5]
--   [3,1,4,1,5]
--   </pre>
intersperse :: a -> [a] -> [a]

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <a>intercalate</a> has the following properties:
--   
--   <pre>
--   &gt;&gt;&gt; take 5 (intercalate undefined ("Lorem" : undefined))
--   "Lorem"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 6 (intercalate ", " ("Lorem" : undefined))
--   "Lorem*** Exception: Prelude.undefined
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate ", " ["Lorem", "ipsum", "dolor"]
--   "Lorem, ipsum, dolor"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate [0, 1] [[2, 3], [4, 5, 6], []]
--   [2,3,0,1,4,5,6,0,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate [1, 2, 3] [[], []]
--   [1,2,3]
--   </pre>
intercalate :: [a] -> [[a]] -> [a]

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <a>transpose</a> is lazy in its elements
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (transpose ['a' : undefined, 'b' : undefined])
--   ["ab"]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[1,2,3],[4,5,6]]
--   [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   If some of the rows are shorter than the following rows, their
--   elements are skipped:
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[10,11],[20],[],[30,31,32]]
--   [[10,20,30],[11,31],[32]]
--   </pre>
--   
--   For this reason the outer list must be finite; otherwise
--   <a>transpose</a> hangs:
--   
--   <pre>
--   &gt;&gt;&gt; transpose (repeat [])
--   * Hangs forever *
--   </pre>
transpose :: [[a]] -> [[a]]

-- | The <a>subsequences</a> function returns the list of all subsequences
--   of the argument.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <a>subsequences</a> does not look ahead unless it must:
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (subsequences undefined)
--   [[]]
--   
--   &gt;&gt;&gt; take 2 (subsequences ('a' : undefined))
--   ["","a"]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; subsequences "abc"
--   ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
--   
--   This function is productive on infinite inputs:
--   
--   <pre>
--   &gt;&gt;&gt; take 8 $ subsequences ['a'..]
--   ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
subsequences :: [a] -> [[a]]

-- | The <a>permutations</a> function returns the list of all permutations
--   of the argument.
--   
--   Note that the order of permutations is not lexicographic. It satisfies
--   the following property:
--   
--   <pre>
--   map (take n) (take (product [1..n]) (permutations ([1..n] ++ undefined))) == permutations [1..n]
--   </pre>
--   
--   <h4><b>Laziness</b></h4>
--   
--   The <a>permutations</a> function is maximally lazy: for each
--   <tt>n</tt>, the value of <tt><a>permutations</a> xs</tt> starts with
--   those permutations that permute <tt><a>take</a> n xs</tt> and keep
--   <tt><a>drop</a> n xs</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; permutations "abc"
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; permutations [1, 2]
--   [[1,2],[2,1]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; permutations []
--   [[]]
--   </pre>
--   
--   This function is productive on infinite inputs:
--   
--   <pre>
--   &gt;&gt;&gt; take 6 $ map (take 3) $ permutations ['a'..]
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
permutations :: [a] -> [[a]]

-- | Left-associative fold of a structure, lazy in the accumulator. This is
--   rarely what you want, but can work well for structures with efficient
--   right-to-left sequencing and an operator that is lazy in its left
--   argument.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. Like all left-associative folds,
--   <a>foldl</a> will diverge if given an infinite list.
--   
--   If you want an efficient strict left-fold, you probably want to use
--   <a>foldl'</a> instead of <a>foldl</a>. The reason for this is that the
--   latter does not force the <i>inner</i> results (e.g. <tt>z `f` x1</tt>
--   in the above example) before applying them to the operator (e.g. to
--   <tt>(`f` x2)</tt>). This results in a thunk chain <i>O(n)</i> elements
--   long, which then must be evaluated from the outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to:
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   The first example is a strict fold, which in practice is best
--   performed with <a>foldl'</a>.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (+) 42 [1,2,3,4]
--   52
--   </pre>
--   
--   Though the result below is lazy, the input is reversed before
--   prepending it to the initial accumulator, so corecursion begins only
--   after traversing the entire input string.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\acc c -&gt; c : acc) "abcd" "efgh"
--   "hgfeabcd"
--   </pre>
--   
--   A left fold of a structure that is infinite on the right cannot
--   terminate, even when for any finite input the fold just returns the
--   initial accumulator:
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\a _ -&gt; a) 0 $ repeat 1
--   * Hangs forever *
--   </pre>
--   
--   WARNING: When it comes to lists, you always want to use either
--   <a>foldl'</a> or <a>foldr</a> instead.
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to Weak Head Normal
--   Form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite structure to a single strict result (e.g. <a>sum</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl' f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) []
--   *** Exception: Prelude.foldl1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) Nothing
--   *** Exception: foldl1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (-) [1..4]
--   -8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A strict version of <a>foldl1</a>.
foldl1' :: HasCallStack => (a -> a -> a) -> [a] -> a

-- | Right-associative fold of a structure, lazy in the accumulator.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that since the head of the resulting expression is produced by an
--   application of the operator to the first element of the list, given an
--   operator lazy in its right argument, <a>foldr</a> can produce a
--   terminating expression from an unbounded list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False [False, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (\c acc -&gt; acc ++ [c]) "foo" ['a', 'b', 'c', 'd']
--   "foodcba"
--   </pre>
--   
--   <h5>Infinite structures</h5>
--   
--   ⚠️ Applying <a>foldr</a> to infinite structures usually doesn't
--   terminate.
--   
--   It may still terminate under one of the following conditions:
--   
--   <ul>
--   <li>the folding function is short-circuiting</li>
--   <li>the folding function is lazy on its second argument</li>
--   </ul>
--   
--   <h6>Short-circuiting</h6>
--   
--   <tt>(<a>||</a>)</tt> short-circuits on <a>True</a> values, so the
--   following terminates because there is a <a>True</a> value finitely far
--   from the left side:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (True : repeat False)
--   True
--   </pre>
--   
--   But the following doesn't terminate:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (repeat False ++ [True])
--   * Hangs forever *
--   </pre>
--   
--   <h6>Laziness in the second argument</h6>
--   
--   Applying <a>foldr</a> to infinite structures terminates when the
--   operator is lazy in its second argument (the initial accumulator is
--   never used in this case, and so could be left <a>undefined</a>, but
--   <tt>[]</tt> is more clear):
--   
--   <pre>
--   &gt;&gt;&gt; take 5 $ foldr (\i acc -&gt; i : fmap (+3) acc) [] (repeat 1)
--   [1,4,7,10,13]
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) []
--   Exception: Prelude.foldr1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) Nothing
--   *** Exception: foldr1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (-) [1..4]
--   -2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | The concatenation of all the elements of a container of lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concat (Just [1, 2, 3])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat (Left 42)
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat [[1, 2, 3], [4, 5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
concat :: Foldable t => t [a] -> [a]

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) [[1..], [10..], [100..], [1000..]]
--   [1,2,3,10,11,12,100,101,102,1000,1001,1002]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) (Just [1..])
--   [1,2,3]
--   </pre>
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; and []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True, True, False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,...
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (repeat True)
--   * Hangs forever *
--   </pre>
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; or []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (True : repeat False) -- Infinite list [True,False,False,False,...
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (repeat False)
--   * Hangs forever *
--   </pre>
or :: Foldable t => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2,3,4,5]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [0, -1..]
--   * Hangs forever *
--   </pre>
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2,3,4,5]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [4..]
--   * Hangs forever *
--   </pre>
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; sum []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..10]
--   55
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [4.1, 2.0, 1.7]
--   7.8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..]
--   * Hangs forever *
--   </pre>
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; product []
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..10]
--   3628800
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [4.1, 2.0, 1.7]
--   13.939999999999998
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..]
--   * Hangs forever *
--   </pre>
product :: (Foldable t, Num a) => t a -> a

-- | The largest element of a non-empty structure. This function is
--   equivalent to <tt><a>foldr1</a> <a>max</a></tt>, and its behavior on
--   structures with multiple largest elements depends on the relevant
--   implementation of <a>max</a>. For the default implementation of
--   <a>max</a> (<tt>max x y = if x &lt;= y then y else x</tt>), structure
--   order is used as a tie-breaker: if there are multiple largest
--   elements, the rightmost of them is chosen (this is equivalent to
--   <tt><a>maximumBy</a> <a>compare</a></tt>).
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the maximum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximum [1..10]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum []
--   *** Exception: Prelude.maximum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum Nothing
--   *** Exception: maximum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximum :: (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure. This function is
--   equivalent to <tt><a>foldr1</a> <a>min</a></tt>, and its behavior on
--   structures with multiple largest elements depends on the relevant
--   implementation of <a>min</a>. For the default implementation of
--   <a>min</a> (<tt>min x y = if x &lt;= y then x else y</tt>), structure
--   order is used as a tie-breaker: if there are multiple least elements,
--   the leftmost of them is chosen (this is equivalent to
--   <tt><a>minimumBy</a> <a>compare</a></tt>).
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the minimum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimum [1..10]
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum []
--   *** Exception: Prelude.minimum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum Nothing
--   *** Exception: minimum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimum :: (Foldable t, Ord a) => t a -> a

-- | &lt;math&gt;. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (+) 0 [1..4]
--   [0,1,3,6,10]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (+) 42 []
--   [42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (-) 100 [1..4]
--   [100,99,97,94,90]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["foo","afoo","bafoo","cbafoo","dcbafoo"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 (scanl (+) 0 [1..])
--   [0,1,3,6,10,15,21,28,36,45]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (scanl undefined 'a' undefined)
--   "a"
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. A strict version of <a>scanl</a>.
scanl' :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (+) [1..4]
--   [1,3,6,10]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (+) []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (-) [1..4]
--   [1,-1,-4,-8]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (&amp;&amp;) [True, False, True, True]
--   [True,False,False,False]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (||) [False, False, True, True]
--   [False,False,True,True]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 (scanl1 (+) [1..])
--   [1,3,6,10,15,21,28,36,45,55]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (scanl1 undefined ('a' : undefined))
--   "a"
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that the order of parameters on the accumulating function are
--   reversed compared to <a>scanl</a>. Also note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (+) 0 [1..4]
--   [10,9,7,4,0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (+) 42 []
--   [42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (-) 100 [1..4]
--   [98,-97,99,-96,100]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (\nextChar reversedString -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["abcdfoo","bcdfoo","cdfoo","dfoo","foo"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; force $ scanr (+) 0 [1..]
--   *** Exception: stack overflow
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (+) [1..4]
--   [10,9,7,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (+) []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (-) [1..4]
--   [-2,3,-1,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (&amp;&amp;) [True, False, True, True]
--   [False,False,True,True]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (||) [True, True, False, False]
--   [True,True,False,False]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; force $ scanr1 (+) [1..]
--   *** Exception: stack overflow
--   </pre>
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | The <a>mapAccumL</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldl</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from left to right, and
--   returning a final value of this accumulator together with the new
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumL (\a b -&gt; (a + b, a)) 0 [1..10]
--   (55,[0,1,3,6,10,15,21,28,36,45])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumL (\a b -&gt; (a &lt;&gt; show b, a)) "0" [1..5]
--   ("012345",["0","01","012","0123","01234"])
--   </pre>
mapAccumL :: Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | The <a>mapAccumR</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldr</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from right to left, and
--   returning a final value of this accumulator together with the new
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumR (\a b -&gt; (a + b, a)) 0 [1..10]
--   (55,[54,52,49,45,40,34,27,19,10,0])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumR (\a b -&gt; (a &lt;&gt; show b, a)) "0" [1..5]
--   ("054321",["05432","0543","054","05","0"])
--   </pre>
mapAccumR :: Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   <h4><b>Laziness</b></h4>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
--   
--   <pre>
--   &gt;&gt;&gt; take 1 $ iterate undefined 42
--   [42]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ iterate not True
--   [True,False,True,False,True,False,True,False,True,False]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ iterate (+3) 42
--   [42,45,48,51,54,57,60,63,66,69]
--   </pre>
--   
--   <tt>iterate id == <a>repeat</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ iterate id 1
--   [1,1,1,1,1,1,1,1,1,1]
--   </pre>
iterate :: (a -> a) -> a -> [a]

-- | <a>iterate'</a> is the strict version of <a>iterate</a>.
--   
--   It forces the result of each application of the function to weak head
--   normal form (WHNF) before proceeding.
--   
--   <pre>
--   &gt;&gt;&gt; take 1 $ iterate' undefined 42
--   *** Exception: Prelude.undefined
--   </pre>
iterate' :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ repeat 17
--   [17,17,17,17,17,17,17,17,17, 17]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; repeat undefined
--   [*** Exception: Prelude.undefined
--   </pre>
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; replicate 0 True
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate (-1) True
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate 4 True
--   [True,True,True,True]
--   </pre>
replicate :: Int -> a -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; cycle []
--   *** Exception: Prelude.cycle: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 (cycle [42])
--   [42,42,42,42,42,42,42,42,42,42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 (cycle [2, 5, 7])
--   [2,5,7,2,5,7,2,5,7,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (cycle (42 : undefined))
--   [42]
--   </pre>
cycle :: HasCallStack => [a] -> [a]

-- | The <a>unfoldr</a> function is a `dual' to <a>foldr</a>: while
--   <a>foldr</a> reduces a list to a summary value, <a>unfoldr</a> builds
--   a list from a seed value. The function takes the element and returns
--   <a>Nothing</a> if it is done producing the list or returns <a>Just</a>
--   <tt>(a,b)</tt>, in which case, <tt>a</tt> is a prepended to the list
--   and <tt>b</tt> is used as the next element in a recursive call. For
--   example,
--   
--   <pre>
--   iterate f == unfoldr (\x -&gt; Just (x, f x))
--   </pre>
--   
--   In some cases, <a>unfoldr</a> can undo a <a>foldr</a> operation:
--   
--   <pre>
--   unfoldr f' (foldr f z xs) == xs
--   </pre>
--   
--   if the following holds:
--   
--   <pre>
--   f' (f x y) = Just (x,y)
--   f' z       = Nothing
--   </pre>
--   
--   <h4><b>Laziness</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (unfoldr (\x -&gt; Just (x, undefined)) 'a')
--   "a"
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ unfoldr (\(x, y) -&gt; Just (x, (y, x + y))) (0, 1)
--   [0,1,1,2,3,5,8,13,21,54]
--   </pre>
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt;= <a>length</a> xs</tt>.
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; take 0 undefined
--   []
--   
--   &gt;&gt;&gt; take 2 (1 : 2 : undefined)
--   [1,2]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; take 5 "Hello World!"
--   "Hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 3 [1,2,3,4,5]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 3 [1,2]
--   [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 3 []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take (-1) [1,2]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 0 [1,2]
--   []
--   </pre>
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt;= <a>length</a>
--   xs</tt>.
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; drop 6 "Hello World!"
--   "World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; drop 3 [1,2,3,4,5]
--   [4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; drop 3 [1,2]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; drop 3 []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; drop (-1) [1,2]
--   [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; drop 0 [1,2]
--   [1,2]
--   </pre>
drop :: Int -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
--   
--   <h4><b>Laziness</b></h4>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt>
--   unless <tt>n</tt> is <tt>_|_</tt>: <tt>splitAt _|_ xs = _|_</tt>, not
--   <tt>(_|_, _|_)</tt>).
--   
--   The first component of the tuple is produced lazily:
--   
--   <pre>
--   &gt;&gt;&gt; fst (splitAt 0 undefined)
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (fst (splitAt 10 (1 : undefined)))
--   [1]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 6 "Hello World!"
--   ("Hello ","World!")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 3 [1,2,3,4,5]
--   ([1,2,3],[4,5])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 1 [1,2,3]
--   ([1],[2,3])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 3 [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 4 [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 0 [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitAt (-1) [1,2,3]
--   ([],[1,2,3])
--   </pre>
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (const False) undefined
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (const False) (undefined : undefined)
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (takeWhile (const True) (1 : undefined))
--   [1]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 3) [1,2,3,4,1,2,3,4]
--   [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 9) [1,2,3]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 0) [1,2,3]
--   []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 3) [1,2,3,4,5,1,2,3]
--   [3,4,5,1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 9) [1,2,3]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 0) [1,2,3]
--   [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | The <a>dropWhileEnd</a> function drops the largest suffix of a list in
--   which the given predicate holds for all elements.
--   
--   <h4><b>Laziness</b></h4>
--   
--   This function is lazy in spine, but strict in elements, which makes it
--   different from <a>reverse</a> <a>.</a> <a>dropWhile</a> <tt>p</tt>
--   <a>.</a> <a>reverse</a>, which is strict in spine, but lazy in
--   elements. For instance:
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (dropWhileEnd (&lt; 0) (1 : undefined))
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (reverse $ dropWhile (&lt; 0) $ reverse (1 : undefined))
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   but on the other hand
--   
--   <pre>
--   &gt;&gt;&gt; last (dropWhileEnd (&lt; 0) [undefined, 1])
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; last (reverse $ dropWhile (&lt; 0) $ reverse [undefined, 1])
--   1
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo\n"
--   "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo bar"
--   "foo bar"
--   
--   &gt;&gt;&gt; dropWhileEnd (&gt; 10) [1..20]
--   [1,2,3,4,5,6,7,8,9,10]
--   </pre>
dropWhileEnd :: (a -> Bool) -> [a] -> [a]

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is the longest prefix (possibly
--   empty) of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second
--   element is the remainder of the list:
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>, even if <tt>p</tt> is <tt>_|_</tt>.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; span undefined []
--   ([],[])
--   
--   &gt;&gt;&gt; fst (span (const False) undefined)
--   *** Exception: Prelude.undefined
--   
--   &gt;&gt;&gt; fst (span (const False) (undefined : undefined))
--   []
--   
--   &gt;&gt;&gt; take 1 (fst (span (const True) (1 : undefined)))
--   [1]
--   </pre>
--   
--   <a>span</a> produces the first component of the tuple lazily:
--   
--   <pre>
--   &gt;&gt;&gt; take 10 (fst (span (const True) [1..]))
--   [1,2,3,4,5,6,7,8,9,10]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2],[3,4,1,2,3,4])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 9) [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 0) [1,2,3]
--   ([],[1,2,3])
--   </pre>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt> and consequently to <tt>(<a>takeWhile</a> (<a>not</a> . p) xs,
--   <a>dropWhile</a> (<a>not</a> . p) xs)</tt>, even if <tt>p</tt> is
--   <tt>_|_</tt>.
--   
--   <h4><b>Laziness</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; break undefined []
--   ([],[])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fst (break (const True) undefined)
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fst (break (const True) (undefined : undefined))
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (fst (break (const False) (1 : undefined)))
--   [1]
--   </pre>
--   
--   <a>break</a> produces the first component of the tuple lazily:
--   
--   <pre>
--   &gt;&gt;&gt; take 10 (fst (break (const False) [1..]))
--   [1,2,3,4,5,6,7,8,9,10]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; break (&gt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2,3],[4,1,2,3,4])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; break (&lt; 9) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; break (&gt; 9) [1,2,3]
--   ([1,2,3],[])
--   </pre>
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | &lt;math&gt;. The <a>stripPrefix</a> function drops the given prefix
--   from a list. It returns <a>Nothing</a> if the list did not start with
--   the prefix given, or <a>Just</a> the list after the prefix, if it
--   does.
--   
--   <h5><b>Examples</b></h5>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foobar"
--   Just "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foo"
--   Just ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoo"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoobaz"
--   Nothing
--   </pre>
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]

-- | The <a>group</a> function takes a list and returns a list of lists
--   such that the concatenation of the result is equal to the argument.
--   Moreover, each sublist in the result is non-empty, all elements are
--   equal to the first one, and consecutive equal elements of the input
--   end up in the same element of the output list.
--   
--   <a>group</a> is a special case of <a>groupBy</a>, which allows the
--   programmer to supply their own equality test.
--   
--   It's often preferable to use <tt>Data.List.NonEmpty.</tt><a>group</a>,
--   which provides type-level guarantees of non-emptiness of inner lists.
--   A common idiom to squash repeating elements <a>map</a> <a>head</a>
--   <a>.</a> <a>group</a> is better served by <a>map</a>
--   <tt>Data.List.NonEmpty.</tt><a>head</a> <a>.</a>
--   <tt>Data.List.NonEmpty.</tt><a>group</a> because it avoids partial
--   functions.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; group "Mississippi"
--   ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; group [1, 1, 1, 2, 2, 3, 4, 5, 5]
--   [[1,1,1],[2,2],[3],[4],[5,5]]
--   </pre>
group :: Eq a => [a] -> [[a]]

-- | The <a>inits</a> function returns all initial segments of the
--   argument, shortest first.
--   
--   <a>inits</a> is semantically equivalent to <tt><a>map</a>
--   <a>reverse</a> . <a>scanl</a> (<a>flip</a> (:)) []</tt>, but under the
--   hood uses a queue to amortize costs of <a>reverse</a>.
--   
--   <h4><b>Laziness</b></h4>
--   
--   Note that <a>inits</a> has the following strictness property:
--   <tt>inits (xs ++ _|_) = inits xs ++ _|_</tt>
--   
--   In particular, <tt>inits _|_ = [] : _|_</tt>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; inits "abc"
--   ["","a","ab","abc"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; inits []
--   [[]]
--   </pre>
--   
--   inits is productive on infinite lists:
--   
--   <pre>
--   &gt;&gt;&gt; take 5 $ inits [1..]
--   [[],[1],[1,2],[1,2,3],[1,2,3,4]]
--   </pre>
inits :: [a] -> [[a]]

-- | &lt;math&gt;. The <a>tails</a> function returns all final segments of
--   the argument, longest first.
--   
--   <h4><b>Laziness</b></h4>
--   
--   Note that <a>tails</a> has the following strictness property:
--   <tt>tails _|_ = _|_ : _|_</tt>
--   
--   <pre>
--   &gt;&gt;&gt; tails undefined
--   [*** Exception: Prelude.undefined
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; drop 1 (tails [undefined, 1, 2])
--   [[1, 2], [2], []]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; tails "abc"
--   ["abc","bc","c",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tails [1, 2, 3]
--   [[1,2,3],[2,3],[3],[]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tails []
--   [[]]
--   </pre>
tails :: [a] -> [[a]]

-- | &lt;math&gt;. The <a>isPrefixOf</a> function takes two lists and
--   returns <a>True</a> iff the first list is a prefix of the second.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Hello World!"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Wello Horld!"
--   False
--   </pre>
--   
--   For the result to be <a>True</a>, the first list must be finite;
--   <a>False</a>, however, results from any mismatch:
--   
--   <pre>
--   &gt;&gt;&gt; [0..] `isPrefixOf` [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..] `isPrefixOf` [0..99]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..99] `isPrefixOf` [0..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..] `isPrefixOf` [0..]
--   * Hangs forever *
--   </pre>
--   
--   <a>isPrefixOf</a> shortcuts when the first argument is empty:
--   
--   <pre>
--   &gt;&gt;&gt; isPrefixOf [] undefined
--   True
--   </pre>
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "ld!" `isSuffixOf` "Hello World!"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "World" `isSuffixOf` "Hello World!"
--   False
--   </pre>
--   
--   The second list must be finite; however the first list may be
--   infinite:
--   
--   <pre>
--   &gt;&gt;&gt; [0..] `isSuffixOf` [0..99]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..99] `isSuffixOf` [0..]
--   * Hangs forever *
--   </pre>
isSuffixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isInfixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is contained, wholly and intact, anywhere within
--   the second.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; isInfixOf "Haskell" "I really like Haskell."
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isInfixOf "Ial" "I really like Haskell."
--   False
--   </pre>
--   
--   For the result to be <a>True</a>, the first list must be finite; for
--   the result to be <a>False</a>, the second list must be finite:
--   
--   <pre>
--   &gt;&gt;&gt; [20..50] `isInfixOf` [0..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..] `isInfixOf` [20..50]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..] `isInfixOf` [0..]
--   * Hangs forever *
--   </pre>
isInfixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSubsequenceOf</a> function takes two lists and returns
--   <a>True</a> if all the elements of the first list occur, in order, in
--   the second. The elements do not have to occur consecutively.
--   
--   <tt><a>isSubsequenceOf</a> x y</tt> is equivalent to <tt>x
--   `<a>elem</a>` (<a>subsequences</a> y)</tt>.
--   
--   Note: <a>isSubsequenceOf</a> is often used in infix form.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "GHC" `isSubsequenceOf` "The Glorious Haskell Compiler"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ['a','d'..'z'] `isSubsequenceOf` ['a'..'z']
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1..10] `isSubsequenceOf` [10,9..0]
--   False
--   </pre>
--   
--   For the result to be <a>True</a>, the first list must be finite; for
--   the result to be <a>False</a>, the second list must be finite:
--   
--   <pre>
--   &gt;&gt;&gt; [0,2..10] `isSubsequenceOf` [0..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..] `isSubsequenceOf` [0,2..10]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0,2..] `isSubsequenceOf` [0..]
--   * Hangs forever*
--   </pre>
isSubsequenceOf :: Eq a => [a] -> [a] -> Bool

-- | Does the element occur in the structure?
--   
--   Note: <a>elem</a> is often used in infix form.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2,3,4,5]
--   True
--   </pre>
--   
--   For infinite structures, the default implementation of <a>elem</a>
--   terminates if the sought-after value exists at a finite distance from
--   the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
elem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `elem`

-- | <a>notElem</a> is the negation of <a>elem</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2,3,4,5]
--   False
--   </pre>
--   
--   For infinite structures, <a>notElem</a> terminates if the value exists
--   at a finite distance from the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | &lt;math&gt;. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list. For the result to be <a>Nothing</a>, the list must
--   be finite.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 [(1, "first")]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | The <a>find</a> function takes a predicate and a structure and returns
--   the leftmost element of the structure matching the predicate, or
--   <a>Nothing</a> if there is no such element.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; find (&gt; 42) [0, 5..]
--   Just 45
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; find (&gt; 12) [1..7]
--   Nothing
--   </pre>
find :: Foldable t => (a -> Bool) -> t a -> Maybe a

-- | &lt;math&gt;. <a>filter</a>, applied to a predicate and a list,
--   returns the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter (\l -&gt; length l &gt; 3) ["Hello", ", ", "World", "!"]
--   ["Hello","World"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter (/= 3) [1, 2, 3, 4, 3, 2, 1]
--   [1,2,4,2,1]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | The <a>partition</a> function takes a predicate and a list, and
--   returns the pair of lists of elements which do and do not satisfy the
--   predicate, respectively; i.e.,
--   
--   <pre>
--   partition p xs == (filter p xs, filter (not . p) xs)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; partition (`elem` "aeiou") "Hello World!"
--   ("eoo","Hll Wrld!")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; partition even [1..10]
--   ([2,4,6,8,10],[1,3,5,7,9])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; partition (&lt; 5) [1..10]
--   ([1,2,3,4],[5,6,7,8,9,10])
--   </pre>
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | List index (subscript) operator, starting from 0. Returns
--   <a>Nothing</a> if the index is out of bounds
--   
--   This is the total variant of the partial <a>!!</a> operator.
--   
--   WARNING: This function takes linear time in the index.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !? 0
--   Just 'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !? 2
--   Just 'c'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !? 3
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !? (-1)
--   Nothing
--   </pre>
(!?) :: [a] -> Int -> Maybe a
infixl 9 !?

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
--   
--   WARNING: This function is partial, and should only be used if you are
--   sure that the indexing will not fail. Otherwise, use <a>!?</a>.
--   
--   WARNING: This function takes linear time in the index.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 0
--   'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 2
--   'c'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 3
--   *** Exception: Prelude.!!: index too large
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! (-1)
--   *** Exception: Prelude.!!: negative index
--   </pre>
(!!) :: HasCallStack => [a] -> Int -> a
infixl 9 !!

-- | The <a>elemIndex</a> function returns the index of the first element
--   in the given list which is equal (by <a>==</a>) to the query element,
--   or <a>Nothing</a> if there is no such element. For the result to be
--   <a>Nothing</a>, the list must be finite.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 4 [0..]
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 'o' "haskell"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 0 [1..]
--   * hangs forever *
--   </pre>
elemIndex :: Eq a => a -> [a] -> Maybe Int

-- | The <a>elemIndices</a> function extends <a>elemIndex</a>, by returning
--   the indices of all elements equal to the query element, in ascending
--   order.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; elemIndices 'o' "Hello World"
--   [4,7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elemIndices 1 [1, 2, 3, 1, 2, 3]
--   [0,3]
--   </pre>
elemIndices :: Eq a => a -> [a] -> [Int]

-- | The <a>findIndex</a> function takes a predicate and a list and returns
--   the index of the first element in the list satisfying the predicate,
--   or <a>Nothing</a> if there is no such element. For the result to be
--   <a>Nothing</a>, the list must be finite.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; findIndex isSpace "Hello World!"
--   Just 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findIndex odd [0, 2, 4, 6]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findIndex even [1..]
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findIndex odd [0, 2 ..]
--   * hangs forever *
--   </pre>
findIndex :: (a -> Bool) -> [a] -> Maybe Int

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; findIndices (`elem` "aeiou") "Hello World!"
--   [1,4,7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findIndices (\l -&gt; length l &gt; 3) ["a", "bcde", "fgh", "ijklmnop"]
--   [1,3]
--   </pre>
findIndices :: (a -> Bool) -> [a] -> [Int]

-- | &lt;math&gt;. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; zip [] undefined
--   []
--   
--   &gt;&gt;&gt; zip undefined []
--   *** Exception: Prelude.undefined
--   ...
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; zip [1, 2, 3] ['a', 'b', 'c']
--   [(1,'a'),(2,'b'),(3,'c')]
--   </pre>
--   
--   If one input list is shorter than the other, excess elements of the
--   longer list are discarded, even if one of the lists is infinite:
--   
--   <pre>
--   &gt;&gt;&gt; zip [1] ['a', 'b']
--   [(1,'a')]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zip [1, 2] ['a']
--   [(1,'a')]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zip [] [1..]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zip [1..] []
--   []
--   </pre>
zip :: [a] -> [b] -> [(a, b)]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | The <a>zip4</a> function takes four lists and returns a list of
--   quadruples, analogous to <a>zip</a>. It is capable of list fusion, but
--   it is restricted to its first list argument and its resulting list.
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]

-- | The <a>zip5</a> function takes five lists and returns a list of
--   five-tuples, analogous to <a>zip</a>. It is capable of list fusion,
--   but it is restricted to its first list argument and its resulting
--   list.
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]

-- | The <a>zip6</a> function takes six lists and returns a list of
--   six-tuples, analogous to <a>zip</a>. It is capable of list fusion, but
--   it is restricted to its first list argument and its resulting list.
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]

-- | The <a>zip7</a> function takes seven lists and returns a list of
--   seven-tuples, analogous to <a>zip</a>. It is capable of list fusion,
--   but it is restricted to its first list argument and its resulting
--   list.
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]

-- | &lt;math&gt;. <a>zipWith</a> generalises <a>zip</a> by zipping with
--   the function given as the first argument, instead of a tupling
--   function.
--   
--   <pre>
--   zipWith (,) xs ys == zip xs ys
--   zipWith f [x1,x2,x3..] [y1,y2,y3..] == [f x1 y1, f x2 y2, f x3 y3..]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; let f = undefined
--   
--   &gt;&gt;&gt; zipWith f [] undefined
--   []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
--   
--   <h4><b>Examples</b></h4>
--   
--   <tt><a>zipWith</a> <a>(+)</a></tt> can be applied to two lists to
--   produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (++) ["hello ", "foo"] ["world!", "bar"]
--   ["hello world!","foobar"]
--   </pre>
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | &lt;math&gt;. The <a>zipWith3</a> function takes a function which
--   combines three elements, as well as three lists and returns a list of
--   the function applied to corresponding elements, analogous to
--   <a>zipWith</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
--   
--   <pre>
--   zipWith3 (,,) xs ys zs == zip3 xs ys zs
--   zipWith3 f [x1,x2,x3..] [y1,y2,y3..] [z1,z2,z3..] == [f x1 y1 z1, f x2 y2 z2, f x3 y3 z3..]
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; zipWith3 (\x y z -&gt; [x, y, z]) "123" "abc" "xyz"
--   ["1ax","2by","3cz"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zipWith3 (\x y z -&gt; (x * y) + z) [1, 2, 3] [4, 5, 6] [7, 8, 9]
--   [11,18,27]
--   </pre>
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | The <a>zipWith4</a> function takes a function which combines four
--   elements, as well as four lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]

-- | The <a>zipWith5</a> function takes a function which combines five
--   elements, as well as five lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]

-- | The <a>zipWith6</a> function takes a function which combines six
--   elements, as well as six lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]

-- | The <a>zipWith7</a> function takes a function which combines seven
--   elements, as well as seven lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>. It is capable of
--   list fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unzip []
--   ([],[])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unzip [(1, 'a'), (2, 'b')]
--   ([1,2],"ab")
--   </pre>
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists of the respective components, analogous to <a>unzip</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unzip3 []
--   ([],[],[])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unzip3 [(1, 'a', True), (2, 'b', False)]
--   ([1,2],"ab",[True,False])
--   </pre>
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | The <a>unzip4</a> function takes a list of quadruples and returns four
--   lists, analogous to <a>unzip</a>.
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])

-- | The <a>unzip5</a> function takes a list of five-tuples and returns
--   five lists, analogous to <a>unzip</a>.
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])

-- | The <a>unzip6</a> function takes a list of six-tuples and returns six
--   lists, analogous to <a>unzip</a>.
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])

-- | The <a>unzip7</a> function takes a list of seven-tuples and returns
--   seven lists, analogous to <a>unzip</a>.
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])

-- | Splits the argument into a list of <i>lines</i> stripped of their
--   terminating <tt>\n</tt> characters. The <tt>\n</tt> terminator is
--   optional in a final non-empty line of the argument string.
--   
--   When the argument string is empty, or ends in a <tt>\n</tt> character,
--   it can be recovered by passing the result of <a>lines</a> to the
--   <a>unlines</a> function. Otherwise, <a>unlines</a> appends the missing
--   terminating <tt>\n</tt>. This makes <tt>unlines . lines</tt>
--   <i>idempotent</i>:
--   
--   <pre>
--   (unlines . lines) . (unlines . lines) = (unlines . lines)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; lines ""           -- empty input contains no lines
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"         -- single empty line
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"        -- single unterminated line
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"      -- single non-empty line
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"    -- second line is empty
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"   -- second line is unterminated
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n" -- two non-empty lines
--   ["one","two"]
--   </pre>
lines :: String -> [String]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space (as defined by <a>isSpace</a>). This function
--   trims any white spaces at the beginning and at the end.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; words " foo bar "
--   ["foo","bar"]
--   </pre>
words :: String -> [String]

-- | Appends a <tt>\n</tt> character to each input string, then
--   concatenates the results. Equivalent to <tt><tt>foldMap</tt> (s -&gt;
--   s <a>++</a> "\n")</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
--   
--   Note that <tt><a>unlines</a> <a>.</a> <a>lines</a> <a>/=</a>
--   <a>id</a></tt> when the input is not <tt>\n</tt>-terminated:
--   
--   <pre>
--   &gt;&gt;&gt; unlines . lines $ "foo\nbar"
--   "foo\nbar\n"
--   </pre>
unlines :: [String] -> String

-- | <a>unwords</a> joins words with separating spaces (U+0020 SPACE).
--   
--   <a>unwords</a> is neither left nor right inverse of <a>words</a>:
--   
--   <pre>
--   &gt;&gt;&gt; words (unwords [" "])
--   []
--   
--   &gt;&gt;&gt; unwords (words "foo\nbar")
--   "foo bar"
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["foo", "bar", "", "baz"]
--   "foo bar  baz"
--   </pre>
unwords :: [String] -> String

-- | &lt;math&gt;. The <a>nub</a> function removes duplicate elements from
--   a list. In particular, it keeps only the first occurrence of each
--   element. (The name <a>nub</a> means `essence'.) It is a special case
--   of <a>nubBy</a>, which allows the programmer to supply their own
--   equality test.
--   
--   If there exists <tt>instance Ord a</tt>, it's faster to use
--   <tt>nubOrd</tt> from the <tt>containers</tt> package (<a>link to the
--   latest online documentation</a>), which takes only &lt;math&gt; time
--   where <tt>d</tt> is the number of distinct elements in the list.
--   
--   Another approach to speed up <a>nub</a> is to use <a>map</a>
--   <tt>Data.List.NonEmpty.</tt><a>head</a> .
--   <tt>Data.List.NonEmpty.</tt><a>group</a> . <a>sort</a>, which takes
--   &lt;math&gt; time, requires <tt>instance Ord a</tt> and doesn't
--   preserve the order.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nub [1,2,3,4,3,2,1,2,4,3,5]
--   [1,2,3,4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nub "hello, world!"
--   "helo, wrd!"
--   </pre>
nub :: Eq a => [a] -> [a]

-- | &lt;math&gt;. <a>delete</a> <tt>x</tt> removes the first occurrence of
--   <tt>x</tt> from its list argument.
--   
--   It is a special case of <a>deleteBy</a>, which allows the programmer
--   to supply their own equality test.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; delete 'a' "banana"
--   "bnana"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; delete "not" ["haskell", "is", "not", "awesome"]
--   ["haskell","is","awesome"]
--   </pre>
delete :: Eq a => a -> [a] -> [a]

-- | The <a>\\</a> function is list difference (non-associative). In the
--   result of <tt>xs</tt> <a>\\</a> <tt>ys</tt>, the first occurrence of
--   each element of <tt>ys</tt> in turn (if any) has been removed from
--   <tt>xs</tt>. Thus <tt>(xs ++ ys) \\ xs == ys</tt>.
--   
--   It is a special case of <a>deleteFirstsBy</a>, which allows the
--   programmer to supply their own equality test.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello World!" \\ "ell W"
--   "Hoorld!"
--   </pre>
--   
--   The second list must be finite, but the first may be infinite.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 ([0..] \\ [2..4])
--   [0,1,5,6,7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 5 ([0..] \\ [2..])
--   * Hangs forever *
--   </pre>
(\\) :: Eq a => [a] -> [a] -> [a]
infix 5 \\

-- | The <a>union</a> function returns the list union of the two lists. It
--   is a special case of <a>unionBy</a>, which allows the programmer to
--   supply their own equality test.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "dog" `union` "cow"
--   "dogcw"
--   </pre>
--   
--   If equal elements are present in both lists, an element from the first
--   list will be used. If the second list contains equal elements, only
--   the first one will be retained:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Semigroup(Arg(..))
--   
--   &gt;&gt;&gt; union [Arg () "dog"] [Arg () "cow"]
--   [Arg () "dog"]
--   
--   &gt;&gt;&gt; union [] [Arg () "dog", Arg () "cow"]
--   [Arg () "dog"]
--   </pre>
--   
--   However if the first list contains duplicates, so will the result:
--   
--   <pre>
--   &gt;&gt;&gt; "coot" `union` "duck"
--   "cootduk"
--   
--   &gt;&gt;&gt; "duck" `union` "coot"
--   "duckot"
--   </pre>
--   
--   <a>union</a> is productive even if both arguments are infinite.
--   
--   <pre>
--   &gt;&gt;&gt; [0, 2 ..] `union` [1, 3 ..]
--   [0,2,4,6,8,10,12..
--   </pre>
union :: Eq a => [a] -> [a] -> [a]

-- | The <a>intersect</a> function takes the list intersection of two
--   lists. It is a special case of <a>intersectBy</a>, which allows the
--   programmer to supply their own equality test.
--   
--   <h5><b>Examples</b></h5>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] `intersect` [2,4,6,8]
--   [2,4]
--   </pre>
--   
--   If equal elements are present in both lists, an element from the first
--   list will be used, and all duplicates from the second list quashed:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Semigroup
--   
--   &gt;&gt;&gt; intersect [Arg () "dog"] [Arg () "cow", Arg () "cat"]
--   [Arg () "dog"]
--   </pre>
--   
--   However if the first list contains duplicates, so will the result.
--   
--   <pre>
--   &gt;&gt;&gt; "coot" `intersect` "heron"
--   "oo"
--   
--   &gt;&gt;&gt; "heron" `intersect` "coot"
--   "o"
--   </pre>
--   
--   If the second list is infinite, <a>intersect</a> either hangs or
--   returns its first argument in full. Otherwise if the first list is
--   infinite, <a>intersect</a> might be productive:
--   
--   <pre>
--   &gt;&gt;&gt; intersect [100..] [0..]
--   [100,101,102,103...
--   
--   &gt;&gt;&gt; intersect [0] [1..]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; intersect [1..] [0]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; intersect (cycle [1..3]) [2]
--   [2,2,2,2...
--   </pre>
intersect :: Eq a => [a] -> [a] -> [a]

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   Elements are arranged from lowest to highest, keeping duplicates in
--   the order they appeared in the input.
--   
--   The argument must be finite.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sort [1,6,4,3,2,5]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sort "haskell"
--   "aehklls"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Semigroup(Arg(..))
--   
--   &gt;&gt;&gt; sort [Arg ":)" 0, Arg ":D" 0, Arg ":)" 1, Arg ":3" 0, Arg ":D" 1]
--   [Arg ":)" 0,Arg ":)" 1,Arg ":3" 0,Arg ":D" 0,Arg ":D" 1]
--   </pre>
sort :: Ord a => [a] -> [a]

-- | Sort a list by comparing the results of a key function applied to each
--   element. <tt><a>sortOn</a> f</tt> is equivalent to <tt><a>sortBy</a>
--   (<a>comparing</a> f)</tt>, but has the performance advantage of only
--   evaluating <tt>f</tt> once for each element in the input list. This is
--   called the decorate-sort-undecorate paradigm, or <a>Schwartzian
--   transform</a>.
--   
--   Elements are arranged from lowest to highest, keeping duplicates in
--   the order they appeared in the input.
--   
--   The argument must be finite.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sortOn fst [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sortOn length ["jim", "creed", "pam", "michael", "dwight", "kevin"]
--   ["jim","pam","creed","kevin","dwight","michael"]
--   </pre>
--   
--   <h4><b>Performance notes</b></h4>
--   
--   This function minimises the projections performed, by materialising
--   the projections in an intermediate list.
--   
--   For trivial projections, you should prefer using <a>sortBy</a> with
--   <a>comparing</a>, for example:
--   
--   <pre>
--   &gt;&gt;&gt; sortBy (comparing fst) [(3, 1), (2, 2), (1, 3)]
--   [(1,3),(2,2),(3,1)]
--   </pre>
--   
--   Or, for the exact same API as <a>sortOn</a>, you can use `sortBy .
--   comparing`:
--   
--   <pre>
--   &gt;&gt;&gt; (sortBy . comparing) fst [(3, 1), (2, 2), (1, 3)]
--   [(1,3),(2,2),(3,1)]
--   </pre>
sortOn :: Ord b => (a -> b) -> [a] -> [a]

-- | &lt;math&gt;. The <a>insert</a> function takes an element and a list
--   and inserts the element into the list at the first position where it
--   is less than or equal to the next element. In particular, if the list
--   is sorted before the call, the result will also be sorted. It is a
--   special case of <a>insertBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; insert (-1) [1, 2, 3]
--   [-1,1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; insert 'd' "abcefg"
--   "abcdefg"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; insert 4 [1, 2, 3, 5, 6, 7]
--   [1,2,3,4,5,6,7]
--   </pre>
insert :: Ord a => a -> [a] -> [a]

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded
--   <a>(==)</a> function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nubBy (\x y -&gt; mod x 3 == mod y 3) [1,2,4,5,6]
--   [1,2,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nubBy (/=) [2, 7, 1, 8, 2, 8, 1, 8, 2, 8]
--   [2,2,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nubBy (&gt;) [1, 2, 3, 2, 1, 5, 4, 5, 3, 2]
--   [1,2,3,5,5]
--   </pre>
nubBy :: (a -> a -> Bool) -> [a] -> [a]

-- | &lt;math&gt;. The <a>deleteBy</a> function behaves like <a>delete</a>,
--   but takes a user-supplied equality predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; deleteBy (&lt;=) 4 [1..10]
--   [1,2,3,5,6,7,8,9,10]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; deleteBy (/=) 5 [5, 5, 4, 3, 5, 2]
--   [5,5,3,5,2]
--   </pre>
deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]

-- | The <a>deleteFirstsBy</a> function takes a predicate and two lists and
--   returns the first list with the first occurrence of each element of
--   the second list removed. This is the non-overloaded version of
--   <a>(\\)</a>.
--   
--   <pre>
--   (\\) == deleteFirstsBy (==)
--   </pre>
--   
--   The second list must be finite, but the first may be infinite.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; deleteFirstsBy (&gt;) [1..10] [3, 4, 5]
--   [4,5,6,7,8,9,10]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; deleteFirstsBy (/=) [1..10] [1, 3, 5]
--   [4,5,6,7,8,9,10]
--   </pre>
deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>unionBy</a> function is the non-overloaded version of
--   <a>union</a>. Both arguments may be infinite.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unionBy (&gt;) [3, 4, 5] [1, 2, 3, 4, 5, 6]
--   [3,4,5,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Semigroup (Arg(..))
--   
--   &gt;&gt;&gt; unionBy (/=) [Arg () "Saul"] [Arg () "Kim"]
--   [Arg () "Saul", Arg () "Kim"]
--   </pre>
unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>intersectBy</a> function is the non-overloaded version of
--   <a>intersect</a>. It is productive for infinite arguments only if the
--   first one is a subset of the second.
intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
--   
--   When a supplied relation is not transitive, it is important to
--   remember that equality is checked against the first element in the
--   group, not against the nearest neighbour:
--   
--   <pre>
--   &gt;&gt;&gt; groupBy (\a b -&gt; b - a &lt; 5) [0..19]
--   [[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19]]
--   </pre>
--   
--   It's often preferable to use
--   <tt>Data.List.NonEmpty.</tt><a>groupBy</a>, which provides type-level
--   guarantees of non-emptiness of inner lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; groupBy (/=) [1, 1, 1, 2, 3, 1, 4, 4, 5]
--   [[1],[1],[1,2,3],[1,4,4,5]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; groupBy (&gt;) [1, 3, 5, 1, 4, 2, 6, 5, 4]
--   [[1],[3],[5,1,4,2],[6,5,4]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; groupBy (const not) [True, False, True, False, False, False, True]
--   [[True,False],[True,False,False,False],[True]]
--   </pre>
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]

-- | The <a>sortBy</a> function is the non-overloaded version of
--   <a>sort</a>. The argument must be finite.
--   
--   The supplied comparison relation is supposed to be reflexive and
--   antisymmetric, otherwise, e. g., for <tt>_ _ -&gt; GT</tt>, the
--   ordered list simply does not exist. The relation is also expected to
--   be transitive: if it is not then <a>sortBy</a> might fail to find an
--   ordered permutation, even if it exists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sortBy (\(a,_) (b,_) -&gt; compare a b) [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | &lt;math&gt;. The non-overloaded version of <a>insert</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; insertBy (\x y -&gt; compare (length x) (length y)) [1, 2] [[1], [1, 2, 3], [1, 2, 3, 4]]
--   [[1],[1,2],[1,2,3],[1,2,3,4]]
--   </pre>
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]

-- | The largest element of a non-empty structure with respect to the given
--   comparison function. Structure order is used as a tie-breaker: if
--   there are multiple largest elements, the rightmost of them is chosen.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximumBy (compare `on` length) ["Hello", "World", "!", "Longest", "bar"]
--   "Longest"
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The least element of a non-empty structure with respect to the given
--   comparison function. Structure order is used as a tie-breaker: if
--   there are multiple least elements, the leftmost of them is chosen.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimumBy (compare `on` length) ["Hello", "World", "!", "Longest", "bar"]
--   "!"
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | &lt;math&gt;. The <a>genericLength</a> function is an overloaded
--   version of <a>length</a>. In particular, instead of returning an
--   <a>Int</a>, it returns any type which is an instance of <a>Num</a>. It
--   is, however, less efficient than <a>length</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; genericLength [1, 2, 3] :: Int
--   3
--   
--   &gt;&gt;&gt; genericLength [1, 2, 3] :: Float
--   3.0
--   </pre>
--   
--   Users should take care to pick a return type that is wide enough to
--   contain the full length of the list. If the width is insufficient, the
--   overflow behaviour will depend on the <tt>(+)</tt> implementation in
--   the selected <a>Num</a> instance. The following example overflows
--   because the actual list length of 200 lies outside of the
--   <tt>Int8</tt> range of <tt>-128..127</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; genericLength [1..200] :: Int8
--   -56
--   </pre>
genericLength :: Num i => [a] -> i

-- | The <a>genericTake</a> function is an overloaded version of
--   <a>take</a>, which accepts any <a>Integral</a> value as the number of
--   elements to take.
genericTake :: Integral i => i -> [a] -> [a]

-- | The <a>genericDrop</a> function is an overloaded version of
--   <a>drop</a>, which accepts any <a>Integral</a> value as the number of
--   elements to drop.
genericDrop :: Integral i => i -> [a] -> [a]

-- | The <a>genericSplitAt</a> function is an overloaded version of
--   <a>splitAt</a>, which accepts any <a>Integral</a> value as the
--   position at which to split.
genericSplitAt :: Integral i => i -> [a] -> ([a], [a])

-- | The <a>genericIndex</a> function is an overloaded version of
--   <a>!!</a>, which accepts any <a>Integral</a> value as the index.
genericIndex :: Integral i => [a] -> i -> a

-- | The <a>genericReplicate</a> function is an overloaded version of
--   <a>replicate</a>, which accepts any <a>Integral</a> value as the
--   number of repetitions to make.
genericReplicate :: Integral i => i -> a -> [a]


-- | Miscellaneous information about the system environment.
module GHC.Internal.System.Environment

-- | Computation <a>getArgs</a> returns a list of the program's command
--   line arguments (not including the program name).
getArgs :: IO [String]

-- | Computation <a>getProgName</a> returns the name of the program as it
--   was invoked.
--   
--   However, this is hard-to-impossible to implement on some non-Unix
--   OSes, so instead, for maximum portability, we just return the leafname
--   of the program as invoked. Even then there are some differences
--   between platforms: on Windows, for example, a program invoked as foo
--   is probably really <tt>FOO.EXE</tt>, and that is what
--   <a>getProgName</a> will return.
getProgName :: IO String

-- | Get an action to query the absolute pathname of the current
--   executable.
--   
--   If the operating system provides a reliable way to determine the
--   current executable, return the query action, otherwise return
--   <tt>Nothing</tt>. The action is defined on FreeBSD, Linux, MacOS,
--   NetBSD, Solaris, and Windows.
--   
--   Even where the query action is defined, there may be situations where
--   no result is available, e.g. if the executable file was deleted while
--   the program is running. Therefore the result of the query action is a
--   <tt>Maybe FilePath</tt>.
--   
--   Note that for scripts and interactive sessions, the result is the path
--   to the interpreter (e.g. ghci.)
--   
--   Note also that while most operating systems return <tt>Nothing</tt> if
--   the executable file was deleted/unlinked, some (including NetBSD)
--   return the original path.
executablePath :: Maybe (IO (Maybe FilePath))

-- | Returns the absolute pathname of the current executable, or
--   <tt>argv[0]</tt> if the operating system does not provide a reliable
--   way query the current executable.
--   
--   Note that for scripts and interactive sessions, this is the path to
--   the interpreter (e.g. ghci.)
--   
--   Since base 4.11.0.0, <a>getExecutablePath</a> resolves symlinks on
--   Windows. If an executable is launched through a symlink,
--   <a>getExecutablePath</a> returns the absolute path of the original
--   executable.
--   
--   If the executable has been deleted, behaviour is ill-defined and
--   varies by operating system. See <a>executablePath</a> for a more
--   reliable way to query the current executable.
getExecutablePath :: IO FilePath

-- | Computation <a>getEnv</a> <tt>var</tt> returns the value of the
--   environment variable <tt>var</tt>. For the inverse, the <a>setEnv</a>
--   function can be used.
--   
--   This computation may fail with:
--   
--   <ul>
--   <li><a>isDoesNotExistError</a> if the environment variable does not
--   exist.</li>
--   </ul>
getEnv :: String -> IO String

-- | Return the value of the environment variable <tt>var</tt>, or
--   <tt>Nothing</tt> if there is no such value.
--   
--   For POSIX users, this is equivalent to <a>getEnv</a>.
lookupEnv :: String -> IO (Maybe String)

-- | <tt>setEnv name value</tt> sets the specified environment variable to
--   <tt>value</tt>.
--   
--   Early versions of this function operated under the mistaken belief
--   that setting an environment variable to the <i>empty string</i> on
--   Windows removes that environment variable from the environment. For
--   the sake of compatibility, it adopted that behavior on POSIX. In
--   particular
--   
--   <pre>
--   setEnv name ""
--   </pre>
--   
--   has the same effect as
--   
--   <pre>
--   <a>unsetEnv</a> name
--   </pre>
--   
--   If you'd like to be able to set environment variables to blank
--   strings, use <a>setEnv</a>.
--   
--   Throws <a>IOException</a> if <tt>name</tt> is the empty string or
--   contains an equals sign.
--   
--   Beware that this function must not be executed concurrently with
--   <a>getEnv</a>, <a>lookupEnv</a>, <a>getEnvironment</a> and such. One
--   thread reading environment variables at the same time with another one
--   modifying them can result in a segfault, see <a>Setenv is not Thread
--   Safe</a> for discussion.
setEnv :: String -> String -> IO ()

-- | <tt>unsetEnv name</tt> removes the specified environment variable from
--   the environment of the current process.
--   
--   Throws <a>IOException</a> if <tt>name</tt> is the empty string or
--   contains an equals sign.
--   
--   Beware that this function must not be executed concurrently with
--   <a>getEnv</a>, <a>lookupEnv</a>, <a>getEnvironment</a> and such. One
--   thread reading environment variables at the same time with another one
--   modifying them can result in a segfault, see <a>Setenv is not Thread
--   Safe</a> for discussion.
unsetEnv :: String -> IO ()

-- | <a>withArgs</a> <tt>args act</tt> - while executing action
--   <tt>act</tt>, have <a>getArgs</a> return <tt>args</tt>.
withArgs :: [String] -> IO a -> IO a

-- | <a>withProgName</a> <tt>name act</tt> - while executing action
--   <tt>act</tt>, have <a>getProgName</a> return <tt>name</tt>.
withProgName :: String -> IO a -> IO a

-- | <a>getEnvironment</a> retrieves the entire environment as a list of
--   <tt>(key,value)</tt> pairs.
--   
--   If an environment entry does not contain an <tt>'='</tt> character,
--   the <tt>key</tt> is the whole entry and the <tt>value</tt> is the
--   empty string.
getEnvironment :: IO [(String, String)]


-- | Various helpers used by the GHCi shell.
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.GHCi.Helpers
disableBuffering :: IO ()
flushAll :: IO ()
evalWrapper :: String -> [String] -> IO a -> IO a


-- | A setEnv implementation that allows blank environment variables.
--   Mimics the <a>Env</a> module from the <tt>unix</tt> package, but with
--   support for Windows too.
--   
--   The matrix of platforms that:
--   
--   <ul>
--   <li>support <tt>putenv(<a>FOO</a>)</tt> to unset environment
--   variables,</li>
--   <li>support <tt>putenv("FOO=")</tt> to unset environment variables or
--   set them to blank values,</li>
--   <li>support <tt>unsetenv</tt> to unset environment variables,</li>
--   <li>support <tt>setenv</tt> to set environment variables,</li>
--   <li>etc.</li>
--   </ul>
--   
--   is very complicated. Some platforms don't support unsetting of
--   environment variables at all.
module GHC.Internal.System.Environment.Blank

-- | Computation <a>getArgs</a> returns a list of the program's command
--   line arguments (not including the program name).
getArgs :: IO [String]

-- | <a>getEnvironment</a> retrieves the entire environment as a list of
--   <tt>(key,value)</tt> pairs.
--   
--   If an environment entry does not contain an <tt>'='</tt> character,
--   the <tt>key</tt> is the whole entry and the <tt>value</tt> is the
--   empty string.
getEnvironment :: IO [(String, String)]

-- | Computation <a>getProgName</a> returns the name of the program as it
--   was invoked.
--   
--   However, this is hard-to-impossible to implement on some non-Unix
--   OSes, so instead, for maximum portability, we just return the leafname
--   of the program as invoked. Even then there are some differences
--   between platforms: on Windows, for example, a program invoked as foo
--   is probably really <tt>FOO.EXE</tt>, and that is what
--   <a>getProgName</a> will return.
getProgName :: IO String

-- | <a>withArgs</a> <tt>args act</tt> - while executing action
--   <tt>act</tt>, have <a>getArgs</a> return <tt>args</tt>.
withArgs :: [String] -> IO a -> IO a

-- | <a>withProgName</a> <tt>name act</tt> - while executing action
--   <tt>act</tt>, have <a>getProgName</a> return <tt>name</tt>.
withProgName :: String -> IO a -> IO a

-- | Returns the absolute pathname of the current executable, or
--   <tt>argv[0]</tt> if the operating system does not provide a reliable
--   way query the current executable.
--   
--   Note that for scripts and interactive sessions, this is the path to
--   the interpreter (e.g. ghci.)
--   
--   Since base 4.11.0.0, <a>getExecutablePath</a> resolves symlinks on
--   Windows. If an executable is launched through a symlink,
--   <a>getExecutablePath</a> returns the absolute path of the original
--   executable.
--   
--   If the executable has been deleted, behaviour is ill-defined and
--   varies by operating system. See <a>executablePath</a> for a more
--   reliable way to query the current executable.
getExecutablePath :: IO FilePath

-- | Similar to <a>lookupEnv</a>.
getEnv :: String -> IO (Maybe String)

-- | Get an environment value or a default value.
getEnvDefault :: String -> String -> IO String

-- | Like <a>setEnv</a>, but allows blank environment values and mimics the
--   function signature of <a>setEnv</a> from the <tt>unix</tt> package.
--   
--   Beware that this function must not be executed concurrently with
--   <a>getEnv</a>, <tt>lookupEnv</tt>, <a>getEnvironment</a> and such. One
--   thread reading environment variables at the same time with another one
--   modifying them can result in a segfault, see <a>Setenv is not Thread
--   Safe</a> for discussion.
setEnv :: String -> String -> Bool -> IO ()

-- | Like <a>unsetEnv</a>, but allows for the removal of blank environment
--   variables. May throw an exception if the underlying platform doesn't
--   support unsetting of environment variables.
--   
--   Beware that this function must not be executed concurrently with
--   <a>getEnv</a>, <tt>lookupEnv</tt>, <a>getEnvironment</a> and such. One
--   thread reading environment variables at the same time with another one
--   modifying them can result in a segfault, see <a>Setenv is not Thread
--   Safe</a> for discussion.
unsetEnv :: String -> IO ()


-- | GCC style response files.
module GHC.Internal.ResponseFile

-- | Like <a>getArgs</a>, but can also read arguments supplied via response
--   files.
--   
--   For example, consider a program <tt>foo</tt>:
--   
--   <pre>
--   main :: IO ()
--   main = do
--     args &lt;- getArgsWithResponseFiles
--     putStrLn (show args)
--   </pre>
--   
--   And a response file <tt>args.txt</tt>:
--   
--   <pre>
--   --one 1
--   --'two' 2
--   --"three" 3
--   </pre>
--   
--   Then the result of invoking <tt>foo</tt> with <tt>args.txt</tt> is:
--   
--   <pre>
--   &gt; ./foo @args.txt
--   ["--one","1","--two","2","--three","3"]
--   </pre>
getArgsWithResponseFiles :: IO [String]

-- | Given a string of concatenated strings, separate each by removing a
--   layer of <i>quoting</i> and/or <i>escaping</i> of certain characters.
--   
--   These characters are: any whitespace, single quote, double quote, and
--   the backslash character. The backslash character always escapes (i.e.,
--   passes through without further consideration) the character which
--   follows. Characters can also be escaped in blocks by quoting (i.e.,
--   surrounding the blocks with matching pairs of either single- or
--   double-quotes which are not themselves escaped).
--   
--   Any whitespace which appears outside of either of the quoting and
--   escaping mechanisms, is interpreted as having been added by this
--   special concatenation process to designate where the boundaries are
--   between the original, un-concatenated list of strings. These added
--   whitespace characters are removed from the output.
--   
--   <pre>
--   unescapeArgs "hello\\ \\\"world\\\"\n" == ["hello \"world\""]
--   </pre>
unescapeArgs :: String -> [String]

-- | Given a list of strings, concatenate them into a single string with
--   escaping of certain characters, and the addition of a newline between
--   each string. The escaping is done by adding a single backslash
--   character before any whitespace, single quote, double quote, or
--   backslash character, so this escaping character must be removed.
--   Unescaped whitespace (in this case, newline) is part of this
--   "transport" format to indicate the end of the previous string and the
--   start of a new string.
--   
--   While <a>unescapeArgs</a> allows using quoting (i.e., convenient
--   escaping of many characters) by having matching sets of single- or
--   double-quotes,<a>escapeArgs</a> does not use the quoting mechanism,
--   and thus will always escape any whitespace, quotes, and backslashes.
--   
--   <pre>
--   escapeArgs ["hello \"world\""] == "hello\\ \\\"world\\\"\n"
--   </pre>
escapeArgs :: [String] -> String

-- | Arguments which look like <tt>@foo</tt> will be replaced with the
--   contents of file <tt>foo</tt>. A gcc-like syntax for response files
--   arguments is expected. This must re-constitute the argument list by
--   doing an inverse of the escaping mechanism done by the calling-program
--   side.
--   
--   We quit if the file is not found or reading somehow fails. (A
--   convenience routine for haddock or possibly other clients)
expandResponse :: [String] -> IO [String]


-- | Internals of the <a>GHC.ExecutionStack</a> module.
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.ExecutionStack.Internal

-- | Location information about an address from a backtrace.
data Location
Location :: String -> String -> Maybe SrcLoc -> Location
[objectName] :: Location -> String
[functionName] :: Location -> String
[srcLoc] :: Location -> Maybe SrcLoc

-- | Render a <a>Location</a> as a string
showLocation :: Location -> ShowS

-- | A location in the original program source.
data SrcLoc
SrcLoc :: String -> Int -> Int -> SrcLoc
[sourceFile] :: SrcLoc -> String
[sourceLine] :: SrcLoc -> Int
[sourceColumn] :: SrcLoc -> Int

-- | The state of the execution stack
data StackTrace

-- | List the frames of a stack trace.
stackFrames :: StackTrace -> Maybe [Location]

-- | How many stack frames in the given <a>StackTrace</a>
stackDepth :: StackTrace -> Int

-- | Get an execution stack.
collectStackTrace :: IO (Maybe StackTrace)

-- | Render a stacktrace as a string
showStackFrames :: [Location] -> ShowS

-- | Free the cached debug data.
invalidateDebugCache :: IO ()


-- | This is a module for efficient stack traces. This stack trace
--   implementation is considered low overhead. Basic usage looks like
--   this:
--   
--   <pre>
--   import GHC.Internal.ExecutionStack
--   
--   myFunction :: IO ()
--   myFunction = do
--        putStrLn =&lt;&lt; showStackTrace
--   </pre>
--   
--   Your GHC must have been built with <tt>libdw</tt> support for this to
--   work.
--   
--   <pre>
--   user@host:~$ ghc --info | grep libdw
--    ,("RTS expects libdw",<a>YES</a>)
--   </pre>
module GHC.Internal.ExecutionStack

-- | Location information about an address from a backtrace.
data Location
Location :: String -> String -> Maybe SrcLoc -> Location
[objectName] :: Location -> String
[functionName] :: Location -> String
[srcLoc] :: Location -> Maybe SrcLoc

-- | A location in the original program source.
data SrcLoc
SrcLoc :: String -> Int -> Int -> SrcLoc
[sourceFile] :: SrcLoc -> String
[sourceLine] :: SrcLoc -> Int
[sourceColumn] :: SrcLoc -> Int

-- | Get a trace of the current execution stack state.
--   
--   Returns <tt>Nothing</tt> if stack trace support isn't available on
--   host machine.
getStackTrace :: IO (Maybe [Location])

-- | Get a string representation of the current execution stack state.
showStackTrace :: IO (Maybe String)

module GHC.Internal.Exception.Backtrace

-- | How to collect a backtrace when an exception is thrown.
data BacktraceMechanism

-- | collect cost-centre stack backtraces (only available when built with
--   profiling)
CostCentreBacktrace :: BacktraceMechanism

-- | collect <tt>HasCallStack</tt> backtraces
HasCallStackBacktrace :: BacktraceMechanism

-- | collect backtraces via native execution stack unwinding (e.g. using
--   DWARF debug information)
ExecutionBacktrace :: BacktraceMechanism

-- | collect backtraces from Info Table Provenance Entries
IPEBacktrace :: BacktraceMechanism

-- | Will the given <a>BacktraceMechanism</a> be used when collecting
--   backtraces?
getBacktraceMechanismState :: BacktraceMechanism -> IO Bool

-- | Set whether the given <a>BacktraceMechanism</a> will be used when
--   collecting backtraces?
setBacktraceMechanismState :: BacktraceMechanism -> Bool -> IO ()

-- | A collection of backtraces.
data Backtraces

-- | Render a set of backtraces to a human-readable string.
displayBacktraces :: Backtraces -> String

-- | Collect a set of <a>Backtraces</a>.
collectBacktraces :: (?callStack :: CallStack) => IO Backtraces
instance GHC.Internal.Exception.Context.ExceptionAnnotation GHC.Internal.Exception.Backtrace.Backtraces


-- | Functions for tracing and monitoring execution.
--   
--   These can be useful for investigating bugs or performance problems.
--   They should <i>not</i> be used in production code.
module GHC.Internal.Debug.Trace

-- | The <a>trace</a> function outputs the trace message given as its first
--   argument, before returning the second argument as its result.
--   
--   For example, this returns the value of <tt>f x</tt> and outputs the
--   message to stderr. Depending on your terminal (settings), they may or
--   may not be mixed.
--   
--   <pre>
--   &gt;&gt;&gt; let x = 123; f = show
--   
--   &gt;&gt;&gt; trace ("calling f with x = " ++ show x) (f x)
--   calling f with x = 123
--   "123"
--   </pre>
--   
--   The <a>trace</a> function should <i>only</i> be used for debugging, or
--   for monitoring execution. The function is not referentially
--   transparent: its type indicates that it is a pure function but it has
--   the side effect of outputting the trace message.
trace :: String -> a -> a

-- | Like <a>trace</a> but returns the message instead of a third value.
--   
--   <pre>
--   &gt;&gt;&gt; traceId "hello"
--   hello
--   "hello"
--   </pre>
traceId :: String -> String

-- | Like <a>trace</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   This makes it convenient for printing the values of interesting
--   variables or expressions inside a function. For example, here we print
--   the values of the variables <tt>x</tt> and <tt>y</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let f x y = traceShow ("x", x, "y", y) (x + y) in f (1+2) 5
--   ("x",3,"y",5)
--   8
--   </pre>
--   
--   Note in this example we also create simple labels just by including
--   some strings.
traceShow :: Show a => a -> b -> b

-- | Like <a>traceShow</a> but returns the shown value instead of a third
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; traceShowId (1+2+3, "hello" ++ "world")
--   (6,"helloworld")
--   (6,"helloworld")
--   </pre>
traceShowId :: Show a => a -> a

-- | Like <a>trace</a>, but outputs the result of calling a function on the
--   argument.
--   
--   <pre>
--   &gt;&gt;&gt; traceWith fst ("hello","world")
--   hello
--   ("hello","world")
--   </pre>
traceWith :: (a -> String) -> a -> a

-- | Like <a>traceWith</a>, but uses <a>show</a> on the result of the
--   function to convert it to a <a>String</a>.
--   
--   <pre>
--   &gt;&gt;&gt; traceShowWith length [1,2,3]
--   3
--   [1,2,3]
--   </pre>
traceShowWith :: Show b => (a -> b) -> a -> a

-- | like <a>trace</a>, but additionally prints a call stack if one is
--   available.
--   
--   In the current GHC implementation, the call stack is only available if
--   the program was compiled with <tt>-prof</tt>; otherwise
--   <a>traceStack</a> behaves exactly like <a>trace</a>. Entries in the
--   call stack correspond to <tt>SCC</tt> annotations, so it is a good
--   idea to use <tt>-fprof-auto</tt> or <tt>-fprof-auto-calls</tt> to add
--   SCC annotations automatically.
traceStack :: String -> a -> a

-- | The <a>traceIO</a> function outputs the trace message from the IO
--   monad. This sequences the output with respect to other IO actions.
traceIO :: String -> IO ()

-- | Like <a>trace</a> but returning unit in an arbitrary
--   <a>Applicative</a> context. Allows for convenient use in do-notation.
--   
--   Note that the application of <a>traceM</a> is not an action in the
--   <a>Applicative</a> context, as <a>traceIO</a> is in the <a>IO</a>
--   type. While the fresh bindings in the following example will force the
--   <a>traceM</a> expressions to be reduced every time the
--   <tt>do</tt>-block is executed, <tt>traceM "not crashed"</tt> would
--   only be reduced once, and the message would only be printed once. If
--   your monad is in <a>MonadIO</a>, <tt><a>liftIO</a> .
--   <a>traceIO</a></tt> may be a better option.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   do
--       x &lt;- Just 3
--       traceM ("x: " ++ show x)
--       y &lt;- pure 12
--       traceM ("y: " ++ show y)
--       pure (x*2 + y)
--   :}
--   x: 3
--   y: 12
--   Just 18
--   </pre>
traceM :: Applicative f => String -> f ()

-- | Like <a>traceM</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   do
--       x &lt;- Just 3
--       traceShowM x
--       y &lt;- pure 12
--       traceShowM y
--       pure (x*2 + y)
--   :}
--   3
--   12
--   Just 18
--   </pre>
traceShowM :: (Show a, Applicative f) => a -> f ()

-- | <i>Deprecated: Use <a>traceIO</a></i>
putTraceMsg :: String -> IO ()

-- | The <a>traceEvent</a> function behaves like <a>trace</a> with the
--   difference that the message is emitted to the eventlog, if eventlog
--   tracing is available and user event tracing is enabled at runtime.
--   
--   It is suitable for use in pure code. In an IO context use
--   <a>traceEventIO</a> instead.
--   
--   Note that when using GHC's SMP runtime, it is possible (but rare) to
--   get duplicate events emitted if two CPUs simultaneously evaluate the
--   same thunk that uses <a>traceEvent</a>.
traceEvent :: String -> a -> a

-- | Like <a>traceEvent</a>, but emits the result of calling a function on
--   its argument.
traceEventWith :: (a -> String) -> a -> a

-- | The <a>traceEventIO</a> function emits a message to the eventlog, if
--   eventlog tracing is available and user event tracing is enabled at
--   runtime.
--   
--   Compared to <a>traceEvent</a>, <a>traceEventIO</a> sequences the event
--   with respect to other IO actions.
traceEventIO :: String -> IO ()

-- | Immediately flush the event log, if enabled.
flushEventLog :: IO ()

-- | The <a>traceMarker</a> function emits a marker to the eventlog, if
--   eventlog tracing is available and enabled at runtime. The
--   <tt>String</tt> is the name of the marker. The name is just used in
--   the profiling tools to help you keep clear which marker is which.
--   
--   This function is suitable for use in pure code. In an IO context use
--   <a>traceMarkerIO</a> instead.
--   
--   Note that when using GHC's SMP runtime, it is possible (but rare) to
--   get duplicate events emitted if two CPUs simultaneously evaluate the
--   same thunk that uses <a>traceMarker</a>.
traceMarker :: String -> a -> a

-- | The <a>traceMarkerIO</a> function emits a marker to the eventlog, if
--   eventlog tracing is available and user event tracing is enabled at
--   runtime.
--   
--   Compared to <a>traceMarker</a>, <a>traceMarkerIO</a> sequences the
--   event with respect to other IO actions.
traceMarkerIO :: String -> IO ()

module GHC.Internal.Data.List.NonEmpty

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|

-- | The <a>zip</a> function takes two streams and returns a stream of
--   corresponding pairs.
zip :: NonEmpty a -> NonEmpty b -> NonEmpty (a, b)

-- | The <a>zipWith</a> function generalizes <a>zip</a>. Rather than
--   tupling the elements, the elements are combined using the function
--   passed as the first argument.
zipWith :: (a -> b -> c) -> NonEmpty a -> NonEmpty b -> NonEmpty c


-- | The <a>Functor</a>, <a>Monad</a> and <a>MonadPlus</a> classes, with
--   some useful operations on monads.
module GHC.Internal.Control.Monad

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds. See these articles by <a>School of Haskell</a> or
--   <a>David Luposchainsky</a> for an explanation.
class Functor (f :: Type -> Type)

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for <a>List</a>, <a>Maybe</a> and
--   <a>IO</a> defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
--   
--   An alternative name for this function is 'bind', but some people may
--   refer to it as 'flatMap', which results from it being equivalent to
--   
--   <pre>
--   \x f -&gt; <a>join</a> (<a>fmap</a> f x) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
--   </pre>
--   
--   which can be seen as mapping a value with <tt>Monad m =&gt; m a -&gt;
--   m (m b)</tt> and then 'flattening' <tt>m (m b)</tt> to <tt>m b</tt>
--   using <a>join</a>.
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
--   
--   or in terms of <tt><a>(&gt;&gt;=)</a></tt> as
--   
--   <pre>
--   as &gt;&gt;= const bs
--   </pre>
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type. This function should <i>not</i>
--   be different from its default implementation as <a>pure</a>. The
--   justification for the existence of this function is merely historic.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
--   
--   <tt>fail s</tt> should be an action that runs in the monad itself, not
--   an exception (except in instances of <tt>MonadIO</tt>). In particular,
--   <tt>fail</tt> should not be implemented in terms of <tt>error</tt>.
class Monad m => MonadFail (m :: Type -> Type)
fail :: MonadFail m => String -> m a

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus (m :: Type -> Type)

-- | The identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
--   
--   The default definition is
--   
--   <pre>
--   mzero = <a>empty</a>
--   </pre>
mzero :: MonadPlus m => m a

-- | An associative operation. The default definition is
--   
--   <pre>
--   mplus = (<a>&lt;|&gt;</a>)
--   </pre>
mplus :: MonadPlus m => m a -> m a -> m a

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <a>mapM</a> is literally a <a>traverse</a> with a type signature
--   restricted to <a>Monad</a>. Its implementation may be more efficient
--   due to additional power of <a>Monad</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   <a>mapM_</a> is just like <a>traverse_</a>, but specialised to monadic
--   actions.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   <a>forM_</a> is just like <a>for_</a>, but specialised to monadic
--   actions.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   The first two examples are instances where the input and and output of
--   <a>sequence</a> are isomorphic.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Right [1,2,3,4]
--   [Right 1,Right 2,Right 3,Right 4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Right 1,Right 2,Right 3,Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   The following examples demonstrate short circuit behavior for
--   <a>sequence</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Left [1,2,3,4]
--   Left [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Left 0, Right 1,Right 2,Right 3,Right 4]
--   Left 0
--   </pre>
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   <a>sequence_</a> is just like <a>sequenceA_</a>, but specialised to
--   monadic actions.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
--   
--   <pre>
--   as &gt;&gt;= f == f =&lt;&lt; as
--   </pre>
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | Left-to-right composition of <a>Kleisli</a> arrows.
--   
--   '<tt>(bs <a>&gt;=&gt;</a> cs) a</tt>' can be understood as the
--   <tt>do</tt> expression
--   
--   <pre>
--   do b &lt;- bs a
--      cs b
--   </pre>
--   
--   or in terms of <tt><a>(&gt;&gt;=)</a></tt> as
--   
--   <pre>
--   bs a &gt;&gt;= cs
--   </pre>
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | Right-to-left composition of Kleisli arrows.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Repeat an action indefinitely.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>forever</a> is to process input from network
--   sockets, <a>Handle</a>s, and channels (e.g. <a>MVar</a> and
--   <a>Chan</a>).
--   
--   For example, here is how we might implement an <a>echo server</a>,
--   using <a>forever</a> both to listen for client connections on a
--   network socket and to echo client input on client connection handles:
--   
--   <pre>
--   echoServer :: Socket -&gt; IO ()
--   echoServer socket = <a>forever</a> $ do
--     client &lt;- accept socket
--     <a>forkFinally</a> (echo client) (\_ -&gt; hClose client)
--     where
--       echo :: Handle -&gt; IO ()
--       echo client = <a>forever</a> $
--         hGetLine client &gt;&gt;= hPutStrLn client
--   </pre>
--   
--   Note that "forever" isn't necessarily non-terminating. If the action
--   is in a <tt><a>MonadPlus</a></tt> and short-circuits after some number
--   of iterations. then <tt><a>forever</a></tt> actually returns
--   <a>mzero</a>, effectively short-circuiting its caller.
forever :: Applicative f => f a -> f b

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with unit, resulting in an <tt><a>Either</a>
--   <a>Int</a> <tt>()</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
--   
--   '<tt><a>join</a> bss</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do bs &lt;- bss
--      bs
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; join [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
--   [1,2,3,4,5,6,7,8,9]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; join (Just (Just 3))
--   Just 3
--   </pre>
--   
--   A common use of <a>join</a> is to run an <a>IO</a> computation
--   returned from an <a>STM</a> transaction, since <a>STM</a> transactions
--   can't perform <a>IO</a> directly. Recall that
--   
--   <pre>
--   <a>atomically</a> :: STM a -&gt; IO a
--   </pre>
--   
--   is used to run <a>STM</a> transactions atomically. So, by specializing
--   the types of <a>atomically</a> and <a>join</a> to
--   
--   <pre>
--   <a>atomically</a> :: STM (IO b) -&gt; IO (IO b)
--   <a>join</a>       :: IO (IO b)  -&gt; IO b
--   </pre>
--   
--   we can compose them as
--   
--   <pre>
--   <a>join</a> . <a>atomically</a> :: STM (IO b) -&gt; IO b
--   </pre>
--   
--   to run an <a>STM</a> transaction and the <a>IO</a> action it returns.
join :: Monad m => m (m a) -> m a

-- | The sum of a collection of actions using <a>(&lt;|&gt;)</a>,
--   generalizing <a>concat</a>.
--   
--   <a>msum</a> is just like <a>asum</a>, but specialised to
--   <a>MonadPlus</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage, using the <a>MonadPlus</a> instance for <a>Maybe</a>:
--   
--   <pre>
--   &gt;&gt;&gt; msum [Just "Hello", Nothing, Just "World"]
--   Just "Hello"
--   </pre>
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a

-- | Direct <a>MonadPlus</a> equivalent of <a>filter</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   The <a>filter</a> function is just <a>mfilter</a> specialized to the
--   list monad:
--   
--   <pre>
--   <a>filter</a> = ( <a>mfilter</a> :: (a -&gt; Bool) -&gt; [a] -&gt; [a] )
--   </pre>
--   
--   An example using <a>mfilter</a> with the <a>Maybe</a> monad:
--   
--   <pre>
--   &gt;&gt;&gt; mfilter odd (Just 1)
--   Just 1
--   
--   &gt;&gt;&gt; mfilter odd (Just 2)
--   Nothing
--   </pre>
mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a

-- | This generalizes the list-based <a>filter</a> function.
--   
--   <pre>
--   runIdentity (filterM (Identity . p) xs) == filter p xs
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; filterM (\x -&gt; do
--         putStrLn ("Keep: " ++ show x ++ "?")
--         answer &lt;- getLine
--         pure (answer == "y"))
--       [1, 2, 3]
--   Keep: 1?
--   y
--   Keep: 2?
--   n
--   Keep: 3?
--   y
--   [1,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filterM (\x -&gt; do
--         putStr (show x)
--         x' &lt;- readLn
--         pure (x == x'))
--       [1, 2, 3]
--   12
--   22
--   33
--   [2,3]
--   </pre>
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state monad.
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | The <a>zipWithM</a> function generalizes <a>zipWith</a> to arbitrary
--   applicative functors.
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | <a>zipWithM_</a> is the extension of <a>zipWithM</a> which ignores the
--   final result.
zipWithM_ :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | The <a>foldM</a> function is analogous to <a>foldl</a>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   
--   ==
--   
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
--   
--   Note: <a>foldM</a> is the same as <a>foldlM</a>
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Like <a>foldM</a>, but discards the result.
foldM_ :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()

-- | <tt><a>replicateM</a> n act</tt> performs the action <tt>act</tt>
--   <tt>n</tt> times, and then returns the list of results.
--   
--   <pre>
--   replicateM n (pure x) == <tt>replicate</tt> n x
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; replicateM 3 getLine
--   hi
--   heya
--   hiya
--   ["hi","heya","hiya"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad.State
--   
--   &gt;&gt;&gt; runState (replicateM 3 $ state $ \s -&gt; (s, s + 1)) 1
--   ([1,2,3],4)
--   </pre>
replicateM :: Applicative m => Int -> m a -> m [a]

-- | Like <a>replicateM</a>, but discards the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; replicateM_ 3 (putStr "a")
--   aaa
--   </pre>
replicateM_ :: Applicative m => Int -> m a -> m ()

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signalling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signalling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
--   
--   <pre>
--   &gt;&gt;&gt; putStr "pi:" &gt;&gt; when False (print 3.14159)
--   pi:
--   </pre>
when :: Applicative f => Bool -> f () -> f ()

-- | The reverse of <a>when</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; do x &lt;- getLine
--          unless (x == "hi") (putStrLn "hi!")
--   comingupwithexamplesisdifficult
--   hi!
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unless (pi &gt; exp 1) Nothing
--   Just ()
--   </pre>
unless :: Applicative f => Bool -> f () -> f ()

-- | Promote a function to a monad. This is equivalent to <a>fmap</a> but
--   specialised to Monads.
liftM :: Monad m => (a1 -> r) -> m a1 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; liftM2 (+) [0,1] [0,2]
--   [0,2,1,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; liftM2 (+) (Just 1) Nothing
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; liftM2 (+) (+ 3) (* 2) 5
--   18
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r

-- | In many situations, the <a>liftM</a> operations can be replaced by
--   uses of <a>ap</a>, which promotes function application.
--   
--   <pre>
--   return f `ap` x1 `ap` ... `ap` xn
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   liftM&lt;n&gt; f x1 x2 ... xn
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; pure (\x y z -&gt; x + y * z) `ap` Just 1 `ap` Just 5 `ap` Just 10
--   Just 51
--   </pre>
ap :: Monad m => m (a -> b) -> m a -> m b

-- | Strict version of <a>&lt;$&gt;</a>.
(<$!>) :: Monad m => (a -> b) -> m a -> m b
infixl 4 <$!>


-- | This module provides access to internal garbage collection and memory
--   usage statistics. These statistics are not available unless a program
--   is run with the <tt>-T</tt> RTS flag.
--   
--   <i>The API of this module is unstable and is tightly coupled to GHC's
--   internals.</i> If depend on it, make sure to use a tight upper bound,
--   e.g., <tt>base &lt; 4.X</tt> rather than <tt>base &lt; 5</tt>, because
--   the interface can change rapidly without much warning.
module GHC.Internal.Stats

-- | Statistics about runtime activity since the start of the program. This
--   is a mirror of the C <tt>struct RTSStats</tt> in <tt>RtsAPI.h</tt>
data RTSStats
RTSStats :: Word32 -> Word32 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> GCDetails -> RTSStats

-- | Total number of GCs
[gcs] :: RTSStats -> Word32

-- | Total number of major (oldest generation) GCs
[major_gcs] :: RTSStats -> Word32

-- | Total bytes allocated
[allocated_bytes] :: RTSStats -> Word64

-- | Maximum live data (including large objects + compact regions) in the
--   heap. Updated after a major GC.
[max_live_bytes] :: RTSStats -> Word64

-- | Maximum live data in large objects
[max_large_objects_bytes] :: RTSStats -> Word64

-- | Maximum live data in compact regions
[max_compact_bytes] :: RTSStats -> Word64

-- | Maximum slop
[max_slop_bytes] :: RTSStats -> Word64

-- | Maximum memory in use by the RTS
[max_mem_in_use_bytes] :: RTSStats -> Word64

-- | Sum of live bytes across all major GCs. Divided by major_gcs gives the
--   average live data over the lifetime of the program.
[cumulative_live_bytes] :: RTSStats -> Word64

-- | Sum of copied_bytes across all GCs
[copied_bytes] :: RTSStats -> Word64

-- | Sum of copied_bytes across all parallel GCs
[par_copied_bytes] :: RTSStats -> Word64

-- | Sum of par_max_copied_bytes across all parallel GCs. Deprecated.
[cumulative_par_max_copied_bytes] :: RTSStats -> Word64

-- | Sum of par_balanced_copied bytes across all parallel GCs
[cumulative_par_balanced_copied_bytes] :: RTSStats -> Word64

-- | Total CPU time used by the init phase @since base-4.12.0.0
[init_cpu_ns] :: RTSStats -> RtsTime

-- | Total elapsed time used by the init phase @since base-4.12.0.0
[init_elapsed_ns] :: RTSStats -> RtsTime

-- | Total CPU time used by the mutator
[mutator_cpu_ns] :: RTSStats -> RtsTime

-- | Total elapsed time used by the mutator
[mutator_elapsed_ns] :: RTSStats -> RtsTime

-- | Total CPU time used by the GC
[gc_cpu_ns] :: RTSStats -> RtsTime

-- | Total elapsed time used by the GC
[gc_elapsed_ns] :: RTSStats -> RtsTime

-- | Total CPU time (at the previous GC)
[cpu_ns] :: RTSStats -> RtsTime

-- | Total elapsed time (at the previous GC)
[elapsed_ns] :: RTSStats -> RtsTime

-- | The total CPU time used during the post-mark pause phase of the
--   concurrent nonmoving GC.
[nonmoving_gc_sync_cpu_ns] :: RTSStats -> RtsTime

-- | The total time elapsed during the post-mark pause phase of the
--   concurrent nonmoving GC.
[nonmoving_gc_sync_elapsed_ns] :: RTSStats -> RtsTime

-- | The maximum elapsed length of any post-mark pause phase of the
--   concurrent nonmoving GC.
[nonmoving_gc_sync_max_elapsed_ns] :: RTSStats -> RtsTime

-- | The total CPU time used by the nonmoving GC.
[nonmoving_gc_cpu_ns] :: RTSStats -> RtsTime

-- | The total time elapsed during which there is a nonmoving GC active.
[nonmoving_gc_elapsed_ns] :: RTSStats -> RtsTime

-- | The maximum time elapsed during any nonmoving GC cycle.
[nonmoving_gc_max_elapsed_ns] :: RTSStats -> RtsTime

-- | Details about the most recent GC
[gc] :: RTSStats -> GCDetails

-- | Statistics about a single GC. This is a mirror of the C <tt>struct
--   GCDetails</tt> in <tt>RtsAPI.h</tt>, with the field prefixed with
--   <tt>gc_</tt> to avoid collisions with <a>RTSStats</a>.
data GCDetails
GCDetails :: Word32 -> Word32 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> GCDetails

-- | The generation number of this GC
[gcdetails_gen] :: GCDetails -> Word32

-- | Number of threads used in this GC
[gcdetails_threads] :: GCDetails -> Word32

-- | Number of bytes allocated since the previous GC
[gcdetails_allocated_bytes] :: GCDetails -> Word64

-- | Total amount of live data in the heap (includes large + compact data).
--   Updated after every GC. Data in uncollected generations (in minor GCs)
--   are considered live.
[gcdetails_live_bytes] :: GCDetails -> Word64

-- | Total amount of live data in large objects
[gcdetails_large_objects_bytes] :: GCDetails -> Word64

-- | Total amount of live data in compact regions
[gcdetails_compact_bytes] :: GCDetails -> Word64

-- | Total amount of slop (wasted memory)
[gcdetails_slop_bytes] :: GCDetails -> Word64

-- | Total amount of memory in use by the RTS
[gcdetails_mem_in_use_bytes] :: GCDetails -> Word64

-- | Total amount of data copied during this GC
[gcdetails_copied_bytes] :: GCDetails -> Word64

-- | In parallel GC, the max amount of data copied by any one thread.
--   Deprecated.
[gcdetails_par_max_copied_bytes] :: GCDetails -> Word64

-- | In parallel GC, the amount of balanced data copied by all threads
[gcdetails_par_balanced_copied_bytes] :: GCDetails -> Word64

-- | The amount of memory lost due to block fragmentation in bytes. Block
--   fragmentation is the difference between the amount of blocks retained
--   by the RTS and the blocks that are in use. This occurs when megablocks
--   are only sparsely used, eg, when data that cannot be moved retains a
--   megablock.
[gcdetails_block_fragmentation_bytes] :: GCDetails -> Word64

-- | The time elapsed during synchronisation before GC
[gcdetails_sync_elapsed_ns] :: GCDetails -> RtsTime

-- | The CPU time used during GC itself
[gcdetails_cpu_ns] :: GCDetails -> RtsTime

-- | The time elapsed during GC itself
[gcdetails_elapsed_ns] :: GCDetails -> RtsTime

-- | The CPU time used during the post-mark pause phase of the concurrent
--   nonmoving GC.
[gcdetails_nonmoving_gc_sync_cpu_ns] :: GCDetails -> RtsTime

-- | The time elapsed during the post-mark pause phase of the concurrent
--   nonmoving GC.
[gcdetails_nonmoving_gc_sync_elapsed_ns] :: GCDetails -> RtsTime

-- | Time values from the RTS, using a fixed resolution of nanoseconds.
type RtsTime = Int64

-- | Get current runtime system statistics.
getRTSStats :: IO RTSStats

-- | Returns whether GC stats have been enabled (with <tt>+RTS -T</tt>, for
--   example).
getRTSStatsEnabled :: IO Bool
instance GHC.Internal.Generics.Generic GHC.Internal.Stats.GCDetails
instance GHC.Internal.Generics.Generic GHC.Internal.Stats.RTSStats
instance GHC.Internal.Read.Read GHC.Internal.Stats.GCDetails
instance GHC.Internal.Read.Read GHC.Internal.Stats.RTSStats
instance GHC.Internal.Show.Show GHC.Internal.Stats.GCDetails
instance GHC.Internal.Show.Show GHC.Internal.Stats.RTSStats


-- | The <tt>String</tt> type and associated operations.
module GHC.Internal.Data.String

-- | <a>String</a> is an alias for a list of characters.
--   
--   String constants in Haskell are values of type <a>String</a>. That
--   means if you write a string literal like <tt>"hello world"</tt>, it
--   will have the type <tt>[Char]</tt>, which is the same as
--   <tt>String</tt>.
--   
--   <b>Note:</b> You can ask the compiler to automatically infer different
--   types with the <tt>-XOverloadedStrings</tt> language extension, for
--   example <tt>"hello world" :: Text</tt>. See <a>IsString</a> for more
--   information.
--   
--   Because <tt>String</tt> is just a list of characters, you can use
--   normal list functions to do basic string manipulation. See
--   <a>Data.List</a> for operations on lists.
--   
--   <h3><b>Performance considerations</b></h3>
--   
--   <tt>[Char]</tt> is a relatively memory-inefficient type. It is a
--   linked list of boxed word-size characters, internally it looks
--   something like:
--   
--   <pre>
--   ╭─────┬───┬──╮  ╭─────┬───┬──╮  ╭─────┬───┬──╮  ╭────╮
--   │ (:) │   │ ─┼─&gt;│ (:) │   │ ─┼─&gt;│ (:) │   │ ─┼─&gt;│ [] │
--   ╰─────┴─┼─┴──╯  ╰─────┴─┼─┴──╯  ╰─────┴─┼─┴──╯  ╰────╯
--           v               v               v
--          'a'             'b'             'c'
--   </pre>
--   
--   The <tt>String</tt> "abc" will use <tt>5*3+1 = 16</tt> (in general
--   <tt>5n+1</tt>) words of space in memory.
--   
--   Furthermore, operations like <a>(++)</a> (string concatenation) are
--   <tt>O(n)</tt> (in the left argument).
--   
--   For historical reasons, the <tt>base</tt> library uses <tt>String</tt>
--   in a lot of places for the conceptual simplicity, but library code
--   dealing with user-data should use the <a>text</a> package for Unicode
--   text, or the the <a>bytestring</a> package for binary data.
type String = [Char]

-- | <a>IsString</a> is used in combination with the
--   <tt>-XOverloadedStrings</tt> language extension to convert the
--   literals to different string types.
--   
--   For example, if you use the <a>text</a> package, you can say
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings  #-}
--   
--   myText = "hello world" :: Text
--   </pre>
--   
--   Internally, the extension will convert this to the equivalent of
--   
--   <pre>
--   myText = fromString @Text ("hello world" :: String)
--   </pre>
--   
--   <b>Note:</b> You can use <tt>fromString</tt> in normal code as well,
--   but the usual performance/memory efficiency problems with
--   <a>String</a> apply.
class IsString a
fromString :: IsString a => String -> a

-- | Splits the argument into a list of <i>lines</i> stripped of their
--   terminating <tt>\n</tt> characters. The <tt>\n</tt> terminator is
--   optional in a final non-empty line of the argument string.
--   
--   When the argument string is empty, or ends in a <tt>\n</tt> character,
--   it can be recovered by passing the result of <a>lines</a> to the
--   <a>unlines</a> function. Otherwise, <a>unlines</a> appends the missing
--   terminating <tt>\n</tt>. This makes <tt>unlines . lines</tt>
--   <i>idempotent</i>:
--   
--   <pre>
--   (unlines . lines) . (unlines . lines) = (unlines . lines)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; lines ""           -- empty input contains no lines
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"         -- single empty line
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"        -- single unterminated line
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"      -- single non-empty line
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"    -- second line is empty
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"   -- second line is unterminated
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n" -- two non-empty lines
--   ["one","two"]
--   </pre>
lines :: String -> [String]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space (as defined by <a>isSpace</a>). This function
--   trims any white spaces at the beginning and at the end.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; words " foo bar "
--   ["foo","bar"]
--   </pre>
words :: String -> [String]

-- | Appends a <tt>\n</tt> character to each input string, then
--   concatenates the results. Equivalent to <tt><tt>foldMap</tt> (s -&gt;
--   s <a>++</a> "\n")</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
--   
--   Note that <tt><a>unlines</a> <a>.</a> <a>lines</a> <a>/=</a>
--   <a>id</a></tt> when the input is not <tt>\n</tt>-terminated:
--   
--   <pre>
--   &gt;&gt;&gt; unlines . lines $ "foo\nbar"
--   "foo\nbar\n"
--   </pre>
unlines :: [String] -> String

-- | <a>unwords</a> joins words with separating spaces (U+0020 SPACE).
--   
--   <a>unwords</a> is neither left nor right inverse of <a>words</a>:
--   
--   <pre>
--   &gt;&gt;&gt; words (unwords [" "])
--   []
--   
--   &gt;&gt;&gt; unwords (words "foo\nbar")
--   "foo bar"
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["foo", "bar", "", "baz"]
--   "foo bar  baz"
--   </pre>
unwords :: [String] -> String
instance forall a k (b :: k). GHC.Internal.Data.String.IsString a => GHC.Internal.Data.String.IsString (GHC.Internal.Data.Functor.Const.Const a b)
instance GHC.Internal.Data.String.IsString a => GHC.Internal.Data.String.IsString (GHC.Internal.Data.Functor.Identity.Identity a)
instance (a GHC.Types.~ GHC.Types.Char) => GHC.Internal.Data.String.IsString [a]


-- | A general library for representation and manipulation of versions.
--   
--   Versioning schemes are many and varied, so the version representation
--   provided by this library is intended to be a compromise between
--   complete generality, where almost no common functionality could
--   reasonably be provided, and fixing a particular versioning scheme,
--   which would probably be too restrictive.
--   
--   So the approach taken here is to provide a representation which
--   subsumes many of the versioning schemes commonly in use, and we
--   provide implementations of <a>Eq</a>, <a>Ord</a> and conversion
--   to/from <a>String</a> which will be appropriate for some applications,
--   but not all.
module GHC.Internal.Data.Version

-- | A <a>Version</a> represents the version of a software entity.
--   
--   An instance of <a>Eq</a> is provided, which implements exact equality
--   modulo reordering of the tags in the <a>versionTags</a> field.
--   
--   An instance of <a>Ord</a> is also provided, which gives lexicographic
--   ordering on the <a>versionBranch</a> fields (i.e. 2.1 &gt; 2.0, 1.2.3
--   &gt; 1.2.2, etc.). This is expected to be sufficient for many uses,
--   but note that you may need to use a more specific ordering for your
--   versioning scheme. For example, some versioning schemes may include
--   pre-releases which have tags <tt>"pre1"</tt>, <tt>"pre2"</tt>, and so
--   on, and these would need to be taken into account when determining
--   ordering. In some cases, date ordering may be more appropriate, so the
--   application would have to look for <tt>date</tt> tags in the
--   <a>versionTags</a> field and compare those. The bottom line is, don't
--   always assume that <a>compare</a> and other <a>Ord</a> operations are
--   the right thing for every <a>Version</a>.
--   
--   Similarly, concrete representations of versions may differ. One
--   possible concrete representation is provided (see <a>showVersion</a>
--   and <a>parseVersion</a>), but depending on the application a different
--   concrete representation may be more appropriate.
data Version
Version :: [Int] -> [String] -> Version

-- | The numeric branch for this version. This reflects the fact that most
--   software versions are tree-structured; there is a main trunk which is
--   tagged with versions at various points (1,2,3...), and the first
--   branch off the trunk after version 3 is 3.1, the second branch off the
--   trunk after version 3 is 3.2, and so on. The tree can be branched
--   arbitrarily, just by adding more digits.
--   
--   We represent the branch as a list of <a>Int</a>, so version 3.2.1
--   becomes [3,2,1]. Lexicographic ordering (i.e. the default instance of
--   <a>Ord</a> for <tt>[Int]</tt>) gives the natural ordering of branches.
[versionBranch] :: Version -> [Int]

-- | A version can be tagged with an arbitrary list of strings. The
--   interpretation of the list of tags is entirely dependent on the entity
--   that this version applies to.

-- | <i>Deprecated: See GHC ticket #2496</i>
[versionTags] :: Version -> [String]

-- | Provides one possible concrete representation for <a>Version</a>. For
--   a version with <a>versionBranch</a> <tt>= [1,2,3]</tt> and
--   <a>versionTags</a> <tt>= ["tag1","tag2"]</tt>, the output will be
--   <tt>1.2.3-tag1-tag2</tt>.
showVersion :: Version -> String

-- | A parser for versions in the format produced by <a>showVersion</a>.
parseVersion :: ReadP Version

-- | Construct tag-less <a>Version</a>
makeVersion :: [Int] -> Version
instance GHC.Classes.Eq GHC.Internal.Data.Version.Version
instance GHC.Internal.Generics.Generic GHC.Internal.Data.Version.Version
instance GHC.Classes.Ord GHC.Internal.Data.Version.Version
instance GHC.Internal.Read.Read GHC.Internal.Data.Version.Version
instance GHC.Internal.Show.Show GHC.Internal.Data.Version.Version


-- | This module provides the <a>Data</a> class with its primitives for
--   generic programming, along with instances for many datatypes. It
--   corresponds to a merge between the previous
--   <a>Data.Generics.Basics</a> and almost all of
--   <a>Data.Generics.Instances</a>. The instances that are not present in
--   this module were moved to the <tt>Data.Generics.Instances</tt> module
--   in the <tt>syb</tt> package.
--   
--   "Scrap your boilerplate" --- Generic programming in Haskell. See
--   <a>https://wiki.haskell.org/Research_papers/Generics#Scrap_your_boilerplate.21</a>.
module GHC.Internal.Data.Data

-- | The <a>Data</a> class comprehends a fundamental primitive
--   <a>gfoldl</a> for folding over constructor applications, say terms.
--   This primitive can be instantiated in several ways to map over the
--   immediate subterms of a term; see the <tt>gmap</tt> combinators later
--   in this class. Indeed, a generic programmer does not necessarily need
--   to use the ingenious gfoldl primitive but rather the intuitive
--   <tt>gmap</tt> combinators. The <a>gfoldl</a> primitive is completed by
--   means to query top-level constructors, to turn constructor
--   representations into proper terms, and to list all possible datatype
--   constructors. This completion allows us to serve generic programming
--   scenarios like read, show, equality, term generation.
--   
--   The combinators <a>gmapT</a>, <a>gmapQ</a>, <a>gmapM</a>, etc are all
--   provided with default definitions in terms of <a>gfoldl</a>, leaving
--   open the opportunity to provide datatype-specific definitions. (The
--   inclusion of the <tt>gmap</tt> combinators as members of class
--   <a>Data</a> allows the programmer or the compiler to derive
--   specialised, and maybe more efficient code per datatype. <i>Note</i>:
--   <a>gfoldl</a> is more higher-order than the <tt>gmap</tt> combinators.
--   This is subject to ongoing benchmarking experiments. It might turn out
--   that the <tt>gmap</tt> combinators will be moved out of the class
--   <a>Data</a>.)
--   
--   Conceptually, the definition of the <tt>gmap</tt> combinators in terms
--   of the primitive <a>gfoldl</a> requires the identification of the
--   <a>gfoldl</a> function arguments. Technically, we also need to
--   identify the type constructor <tt>c</tt> for the construction of the
--   result type from the folded term type.
--   
--   In the definition of <tt>gmapQ</tt><i>x</i> combinators, we use
--   phantom type constructors for the <tt>c</tt> in the type of
--   <a>gfoldl</a> because the result type of a query does not involve the
--   (polymorphic) type of the term argument. In the definition of
--   <a>gmapQl</a> we simply use the plain constant type constructor
--   because <a>gfoldl</a> is left-associative anyway and so it is readily
--   suited to fold a left-associative binary operation over the immediate
--   subterms. In the definition of gmapQr, extra effort is needed. We use
--   a higher-order accumulation trick to mediate between left-associative
--   constructor application vs. right-associative binary operation (e.g.,
--   <tt>(:)</tt>). When the query is meant to compute a value of type
--   <tt>r</tt>, then the result type within generic folding is <tt>r -&gt;
--   r</tt>. So the result of folding is a function to which we finally
--   pass the right unit.
--   
--   With the <tt>-XDeriveDataTypeable</tt> option, GHC can generate
--   instances of the <a>Data</a> class automatically. For example, given
--   the declaration
--   
--   <pre>
--   data T a b = C1 a b | C2 deriving (Typeable, Data)
--   </pre>
--   
--   GHC will generate an instance that is equivalent to
--   
--   <pre>
--   instance (Data a, Data b) =&gt; Data (T a b) where
--       gfoldl k z (C1 a b) = z C1 `k` a `k` b
--       gfoldl k z C2       = z C2
--   
--       gunfold k z c = case constrIndex c of
--                           1 -&gt; k (k (z C1))
--                           2 -&gt; z C2
--   
--       toConstr (C1 _ _) = con_C1
--       toConstr C2       = con_C2
--   
--       dataTypeOf _ = ty_T
--   
--   con_C1 = mkConstr ty_T "C1" [] Prefix
--   con_C2 = mkConstr ty_T "C2" [] Prefix
--   ty_T   = mkDataType "Module.T" [con_C1, con_C2]
--   </pre>
--   
--   This is suitable for datatypes that are exported transparently.
class Typeable a => Data a

-- | Left-associative fold operation for constructor applications.
--   
--   The type of <a>gfoldl</a> is a headache, but operationally it is a
--   simple generalisation of a list fold.
--   
--   The default definition for <a>gfoldl</a> is <tt><a>const</a>
--   <a>id</a></tt>, which is suitable for abstract datatypes with no
--   substructures.
gfoldl :: Data a => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. () => g -> c g) -> a -> c a

-- | Unfolding constructor applications
gunfold :: Data a => (forall b r. Data b => c (b -> r) -> c r) -> (forall r. () => r -> c r) -> Constr -> c a

-- | Obtaining the constructor from a given datum. For proper terms, this
--   is meant to be the top-level constructor. Primitive datatypes are here
--   viewed as potentially infinite sets of values (i.e., constructors).
toConstr :: Data a => a -> Constr

-- | The outer type constructor of the type
dataTypeOf :: Data a => a -> DataType

-- | Mediate types and unary type constructors.
--   
--   In <a>Data</a> instances of the form
--   
--   <pre>
--   instance (Data a, ...) =&gt; Data (T a)
--   </pre>
--   
--   <a>dataCast1</a> should be defined as <a>gcast1</a>.
--   
--   The default definition is <tt><a>const</a> <a>Nothing</a></tt>, which
--   is appropriate for instances of other forms.
dataCast1 :: (Data a, Typeable t) => (forall d. Data d => c (t d)) -> Maybe (c a)

-- | Mediate types and binary type constructors.
--   
--   In <a>Data</a> instances of the form
--   
--   <pre>
--   instance (Data a, Data b, ...) =&gt; Data (T a b)
--   </pre>
--   
--   <a>dataCast2</a> should be defined as <a>gcast2</a>.
--   
--   The default definition is <tt><a>const</a> <a>Nothing</a></tt>, which
--   is appropriate for instances of other forms.
dataCast2 :: (Data a, Typeable t) => (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c a)

-- | A generic transformation that maps over the immediate subterms
--   
--   The default definition instantiates the type constructor <tt>c</tt> in
--   the type of <a>gfoldl</a> to an identity datatype constructor, using
--   the isomorphism pair as injection and projection.
gmapT :: Data a => (forall b. Data b => b -> b) -> a -> a

-- | A generic query with a left-associative binary operator
gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r

-- | A generic query with a right-associative binary operator
gmapQr :: forall r r'. Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r

-- | A generic query that processes the immediate subterms and returns a
--   list of results. The list is given in the same order as originally
--   specified in the declaration of the data constructors.
gmapQ :: Data a => (forall d. Data d => d -> u) -> a -> [u]

-- | A generic query that processes one child by index (zero-based)
gmapQi :: Data a => Int -> (forall d. Data d => d -> u) -> a -> u

-- | A generic monadic transformation that maps over the immediate subterms
--   
--   The default definition instantiates the type constructor <tt>c</tt> in
--   the type of <a>gfoldl</a> to the monad datatype constructor, defining
--   injection and projection using <a>return</a> and <a>&gt;&gt;=</a>.
gmapM :: (Data a, Monad m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Transformation of at least one immediate subterm does not fail
gmapMp :: (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Transformation of one immediate subterm with success
gmapMo :: (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Representation of datatypes. A package of constructor representations
--   with names of type and module.
data DataType

-- | Constructs an algebraic datatype
mkDataType :: String -> [Constr] -> DataType

-- | Constructs the <a>Int</a> type
mkIntType :: String -> DataType

-- | Constructs the <a>Float</a> type
mkFloatType :: String -> DataType

-- | Constructs the <a>Char</a> type
mkCharType :: String -> DataType

-- | Constructs a non-representation for a non-representable type
mkNoRepType :: String -> DataType

-- | Gets the type constructor including the module
dataTypeName :: DataType -> String

-- | Public representation of datatypes
data DataRep
AlgRep :: [Constr] -> DataRep
IntRep :: DataRep
FloatRep :: DataRep
CharRep :: DataRep
NoRep :: DataRep

-- | Gets the public presentation of a datatype
dataTypeRep :: DataType -> DataRep

-- | Look up a constructor by its representation
repConstr :: DataType -> ConstrRep -> Constr

-- | Test for an algebraic type
isAlgType :: DataType -> Bool

-- | Gets the constructors of an algebraic datatype
dataTypeConstrs :: DataType -> [Constr]

-- | Gets the constructor for an index (algebraic datatypes only)
indexConstr :: DataType -> ConIndex -> Constr

-- | Gets the maximum constructor index of an algebraic datatype
maxConstrIndex :: DataType -> ConIndex

-- | Test for a non-representable type
isNorepType :: DataType -> Bool

-- | Representation of constructors. Note that equality on constructors
--   with different types may not work -- i.e. the constructors for
--   <a>False</a> and <a>Nothing</a> may compare equal.
data Constr

-- | Unique index for datatype constructors, counting from 1 in the order
--   they are given in the program text.
type ConIndex = Int

-- | Fixity of constructors
data Fixity
Prefix :: Fixity
Infix :: Fixity

-- | Constructs a constructor
mkConstr :: DataType -> String -> [String] -> Fixity -> Constr

-- | Constructs a constructor
mkConstrTag :: DataType -> String -> Int -> [String] -> Fixity -> Constr
mkIntegralConstr :: (Integral a, Show a) => DataType -> a -> Constr
mkRealConstr :: (Real a, Show a) => DataType -> a -> Constr

-- | Makes a constructor for <a>Char</a>.
mkCharConstr :: DataType -> Char -> Constr

-- | Gets the datatype of a constructor
constrType :: Constr -> DataType

-- | Public representation of constructors
data ConstrRep
AlgConstr :: ConIndex -> ConstrRep
IntConstr :: Integer -> ConstrRep
FloatConstr :: Rational -> ConstrRep
CharConstr :: Char -> ConstrRep

-- | Gets the public presentation of constructors
constrRep :: Constr -> ConstrRep

-- | Gets the field labels of a constructor. The list of labels is returned
--   in the same order as they were given in the original constructor
--   declaration.
constrFields :: Constr -> [String]

-- | Gets the fixity of a constructor
constrFixity :: Constr -> Fixity

-- | Gets the index of a constructor (algebraic datatypes only)
constrIndex :: Constr -> ConIndex

-- | Gets the string for a constructor
showConstr :: Constr -> String

-- | Lookup a constructor via a string
readConstr :: DataType -> String -> Maybe Constr

-- | Gets the unqualified type constructor: drop *.*.*... before name
tyconUQname :: String -> String

-- | Gets the module of a type constructor: take *.*.*... before name
tyconModule :: String -> String

-- | Build a term skeleton
fromConstr :: Data a => Constr -> a

-- | Build a term and use a generic function for subterms
fromConstrB :: Data a => (forall d. Data d => d) -> Constr -> a

-- | Monadic variation on <a>fromConstrB</a>
fromConstrM :: (Monad m, Data a) => (forall d. Data d => m d) -> Constr -> m a
instance (GHC.Internal.Data.Typeable.Internal.Typeable f, GHC.Internal.Data.Typeable.Internal.Typeable g, GHC.Internal.Data.Data.Data p, GHC.Internal.Data.Data.Data (f p), GHC.Internal.Data.Data.Data (g p)) => GHC.Internal.Data.Data.Data ((GHC.Internal.Generics.:*:) f g p)
instance (GHC.Internal.Data.Typeable.Internal.Typeable f, GHC.Internal.Data.Typeable.Internal.Typeable g, GHC.Internal.Data.Data.Data p, GHC.Internal.Data.Data.Data (f p), GHC.Internal.Data.Data.Data (g p)) => GHC.Internal.Data.Data.Data ((GHC.Internal.Generics.:+:) f g p)
instance (GHC.Internal.Data.Typeable.Internal.Typeable f, GHC.Internal.Data.Typeable.Internal.Typeable g, GHC.Internal.Data.Data.Data p, GHC.Internal.Data.Data.Data (f (g p))) => GHC.Internal.Data.Data.Data ((GHC.Internal.Generics.:.:) f g p)
instance (a GHC.Types.~ b, GHC.Internal.Data.Data.Data a) => GHC.Internal.Data.Data.Data (a GHC.Internal.Data.Type.Equality.:~: b)
instance forall i j (a :: i) (b :: j). (GHC.Internal.Data.Typeable.Internal.Typeable i, GHC.Internal.Data.Typeable.Internal.Typeable j, GHC.Internal.Data.Typeable.Internal.Typeable a, GHC.Internal.Data.Typeable.Internal.Typeable b, a GHC.Types.~~ b) => GHC.Internal.Data.Data.Data (a GHC.Internal.Data.Type.Equality.:~~: b)
instance GHC.Internal.Data.Data.Data GHC.Internal.Data.Semigroup.Internal.All
instance (GHC.Internal.Data.Data.Data (f a), GHC.Internal.Data.Data.Data a, GHC.Internal.Data.Typeable.Internal.Typeable f) => GHC.Internal.Data.Data.Data (GHC.Internal.Data.Semigroup.Internal.Alt f a)
instance GHC.Internal.Data.Data.Data GHC.Internal.Data.Semigroup.Internal.Any
instance (GHC.Internal.Data.Data.Data (f a), GHC.Internal.Data.Data.Data a, GHC.Internal.Data.Typeable.Internal.Typeable f) => GHC.Internal.Data.Data.Data (GHC.Internal.Data.Monoid.Ap f a)
instance (GHC.Internal.Data.Data.Data a, GHC.Internal.Data.Data.Data b, GHC.Internal.Ix.Ix a) => GHC.Internal.Data.Data.Data (GHC.Internal.Arr.Array a b)
instance GHC.Internal.Data.Data.Data GHC.Internal.Generics.Associativity
instance GHC.Internal.Data.Data.Data GHC.Types.Bool
instance GHC.Internal.Data.Data.Data GHC.Types.Char
instance (GHC.Types.Coercible a b, GHC.Internal.Data.Data.Data a, GHC.Internal.Data.Data.Data b) => GHC.Internal.Data.Data.Data (GHC.Internal.Data.Type.Coercion.Coercion a b)
instance forall k a (b :: k). (GHC.Internal.Data.Typeable.Internal.Typeable k, GHC.Internal.Data.Data.Data a, GHC.Internal.Data.Typeable.Internal.Typeable b) => GHC.Internal.Data.Data.Data (GHC.Internal.Data.Functor.Const.Const a b)
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Internal.Foreign.C.ConstPtr.ConstPtr a)
instance GHC.Internal.Data.Data.Data GHC.Internal.Generics.DecidedStrictness
instance GHC.Internal.Data.Data.Data GHC.Types.Double
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Internal.Data.Ord.Down a)
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Internal.Data.Semigroup.Internal.Dual a)
instance (GHC.Internal.Data.Data.Data a, GHC.Internal.Data.Data.Data b) => GHC.Internal.Data.Data.Data (GHC.Internal.Data.Either.Either a b)
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Internal.Data.Monoid.First a)
instance GHC.Internal.Data.Data.Data GHC.Internal.Generics.Fixity
instance GHC.Internal.Data.Data.Data GHC.Types.Float
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Internal.ForeignPtr.ForeignPtr a)
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Internal.Data.Functor.Identity.Identity a)
instance GHC.Internal.Data.Data.Data GHC.Types.Int
instance GHC.Internal.Data.Data.Data GHC.Internal.Int.Int16
instance GHC.Internal.Data.Data.Data GHC.Internal.Int.Int32
instance GHC.Internal.Data.Data.Data GHC.Internal.Int.Int64
instance GHC.Internal.Data.Data.Data GHC.Internal.Int.Int8
instance GHC.Internal.Data.Data.Data GHC.Internal.Foreign.Ptr.IntPtr
instance GHC.Internal.Data.Data.Data GHC.Num.Integer.Integer
instance (GHC.Internal.Data.Typeable.Internal.Typeable i, GHC.Internal.Data.Data.Data p, GHC.Internal.Data.Data.Data c) => GHC.Internal.Data.Data.Data (GHC.Internal.Generics.K1 i c p)
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Internal.Data.Monoid.Last a)
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data [a]
instance (GHC.Internal.Data.Data.Data p, GHC.Internal.Data.Data.Data (f p), GHC.Internal.Data.Typeable.Internal.Typeable c, GHC.Internal.Data.Typeable.Internal.Typeable i, GHC.Internal.Data.Typeable.Internal.Typeable f) => GHC.Internal.Data.Data.Data (GHC.Internal.Generics.M1 i c f p)
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Internal.Maybe.Maybe a)
instance GHC.Internal.Data.Data.Data GHC.Num.Natural.Natural
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Internal.Base.NonEmpty a)
instance GHC.Internal.Data.Data.Data GHC.Types.Ordering
instance GHC.Internal.Data.Data.Data p => GHC.Internal.Data.Data.Data (GHC.Internal.Generics.Par1 p)
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Internal.Data.Semigroup.Internal.Product a)
instance GHC.Internal.Data.Data.Data t => GHC.Internal.Data.Data.Data (GHC.Internal.Data.Proxy.Proxy t)
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Internal.Ptr.Ptr a)
instance (GHC.Internal.Data.Data.Data a, GHC.Internal.Real.Integral a) => GHC.Internal.Data.Data.Data (GHC.Internal.Real.Ratio a)
instance (GHC.Internal.Data.Data.Data (f p), GHC.Internal.Data.Typeable.Internal.Typeable f, GHC.Internal.Data.Data.Data p) => GHC.Internal.Data.Data.Data (GHC.Internal.Generics.Rec1 f p)
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Tuple.Solo a)
instance GHC.Internal.Data.Data.Data GHC.Internal.Generics.SourceStrictness
instance GHC.Internal.Data.Data.Data GHC.Internal.Generics.SourceUnpackedness
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Internal.Data.Semigroup.Internal.Sum a)
instance (GHC.Internal.Data.Data.Data a, GHC.Internal.Data.Data.Data b) => GHC.Internal.Data.Data.Data (a, b)
instance (GHC.Internal.Data.Data.Data a, GHC.Internal.Data.Data.Data b, GHC.Internal.Data.Data.Data c) => GHC.Internal.Data.Data.Data (a, b, c)
instance (GHC.Internal.Data.Data.Data a, GHC.Internal.Data.Data.Data b, GHC.Internal.Data.Data.Data c, GHC.Internal.Data.Data.Data d) => GHC.Internal.Data.Data.Data (a, b, c, d)
instance (GHC.Internal.Data.Data.Data a, GHC.Internal.Data.Data.Data b, GHC.Internal.Data.Data.Data c, GHC.Internal.Data.Data.Data d, GHC.Internal.Data.Data.Data e) => GHC.Internal.Data.Data.Data (a, b, c, d, e)
instance (GHC.Internal.Data.Data.Data a, GHC.Internal.Data.Data.Data b, GHC.Internal.Data.Data.Data c, GHC.Internal.Data.Data.Data d, GHC.Internal.Data.Data.Data e, GHC.Internal.Data.Data.Data f) => GHC.Internal.Data.Data.Data (a, b, c, d, e, f)
instance (GHC.Internal.Data.Data.Data a, GHC.Internal.Data.Data.Data b, GHC.Internal.Data.Data.Data c, GHC.Internal.Data.Data.Data d, GHC.Internal.Data.Data.Data e, GHC.Internal.Data.Data.Data f, GHC.Internal.Data.Data.Data g) => GHC.Internal.Data.Data.Data (a, b, c, d, e, f, g)
instance GHC.Internal.Data.Data.Data p => GHC.Internal.Data.Data.Data (GHC.Internal.Generics.U1 p)
instance GHC.Internal.Data.Data.Data ()
instance GHC.Internal.Data.Data.Data p => GHC.Internal.Data.Data.Data (GHC.Internal.Generics.V1 p)
instance GHC.Internal.Data.Data.Data GHC.Internal.Data.Version.Version
instance GHC.Internal.Data.Data.Data GHC.Internal.Base.Void
instance GHC.Internal.Data.Data.Data GHC.Types.Word
instance GHC.Internal.Data.Data.Data GHC.Internal.Word.Word16
instance GHC.Internal.Data.Data.Data GHC.Internal.Word.Word32
instance GHC.Internal.Data.Data.Data GHC.Internal.Word.Word64
instance GHC.Internal.Data.Data.Data GHC.Internal.Word.Word8
instance GHC.Internal.Data.Data.Data GHC.Internal.Foreign.Ptr.WordPtr
instance GHC.Classes.Eq GHC.Internal.Data.Data.Constr
instance GHC.Classes.Eq GHC.Internal.Data.Data.ConstrRep
instance GHC.Classes.Eq GHC.Internal.Data.Data.DataRep
instance GHC.Classes.Eq GHC.Internal.Data.Data.Fixity
instance GHC.Internal.Show.Show GHC.Internal.Data.Data.Constr
instance GHC.Internal.Show.Show GHC.Internal.Data.Data.ConstrRep
instance GHC.Internal.Show.Show GHC.Internal.Data.Data.DataRep
instance GHC.Internal.Show.Show GHC.Internal.Data.Data.DataType
instance GHC.Internal.Show.Show GHC.Internal.Data.Data.Fixity


-- | This module is used internally in GHC's integration with Template
--   Haskell and defines the abstract syntax of Template Haskell.
--   
--   This is not a part of the public API, and as such, there are no API
--   guarantees for this module from version to version.
--   
--   Import <a>Language.Haskell.TH</a> or <a>Language.Haskell.TH.Syntax</a>
--   instead!
module GHC.Internal.TH.Syntax

-- | Adds a core plugin to the compilation pipeline.
--   
--   <tt>addCorePlugin m</tt> has almost the same effect as passing
--   <tt>-fplugin=m</tt> to ghc in the command line. The major difference
--   is that the plugin module <tt>m</tt> must not belong to the current
--   package. When TH executes, it is too late to tell the compiler that we
--   needed to compile first a plugin module in the current package.
addCorePlugin :: String -> Q ()

-- | Record external files that runIO is using (dependent upon). The
--   compiler can then recognize that it should re-compile the Haskell file
--   when an external file changes.
--   
--   Expects an absolute file path.
--   
--   Notes:
--   
--   <ul>
--   <li>ghc -M does not know about these dependencies - it does not
--   execute TH.</li>
--   <li>The dependency is based on file content, not a modification
--   time</li>
--   </ul>
addDependentFile :: FilePath -> Q ()

-- | <i>Deprecated: Use <a>addForeignSource</a> instead</i>
addForeignFile :: ForeignSrcLang -> String -> Q ()

-- | Same as <a>addForeignSource</a>, but expects to receive a path
--   pointing to the foreign file instead of a <a>String</a> of its
--   contents. Consider using this in conjunction with <a>addTempFile</a>.
--   
--   This is a good alternative to <a>addForeignSource</a> when you are
--   trying to directly link in an object file.
addForeignFilePath :: ForeignSrcLang -> FilePath -> Q ()

-- | Emit a foreign file which will be compiled and linked to the object
--   for the current module. Currently only languages that can be compiled
--   with the C compiler are supported, and the flags passed as part of
--   -optc will be also applied to the C compiler invocation that will
--   compile them.
--   
--   Note that for non-C languages (for example C++) <tt>extern
--   <a>C</a></tt> directives must be used to get symbols that we can
--   access from Haskell.
--   
--   To get better errors, it is recommended to use #line pragmas when
--   emitting C files, e.g.
--   
--   <pre>
--   {-# LANGUAGE CPP #-}
--   ...
--   addForeignSource LangC $ unlines
--     [ "#line " ++ show (870 + 1) ++ " " ++ show "libraries/ghc-internal/src/GHC/Internal/TH/Syntax.hs"
--     , ...
--     ]
--   </pre>
addForeignSource :: ForeignSrcLang -> String -> Q ()

-- | Add a finalizer that will run in the Q monad after the current module
--   has been type checked. This only makes sense when run within a
--   top-level splice.
--   
--   The finalizer is given the local type environment at the splice point.
--   Thus <a>reify</a> is able to find the local definitions when executed
--   inside the finalizer.
addModFinalizer :: Q () -> Q ()

-- | Obtain a temporary file path with the given suffix. The compiler will
--   delete this file after compilation.
addTempFile :: String -> Q FilePath

-- | Add additional top-level declarations. The added declarations will be
--   type checked along with the current declaration group.
addTopDecls :: [Dec] -> Q ()
badIO :: String -> IO a

-- | Variant of <a>(&gt;&gt;=)</a> which allows effectful computations to
--   be injected into code generation.
bindCode :: Monad m => m a -> (a -> Code m b) -> Code m b

-- | Variant of <a>(&gt;&gt;)</a> which allows effectful computations to be
--   injected into code generation.
bindCode_ :: Monad m => m a -> Code m b -> Code m b

-- | Internal helper function.
cmpEq :: Ordering -> Bool
compareBytes :: Bytes -> Bytes -> Ordering
counter :: IORef Uniq

-- | Default fixity: <tt>infixl 9</tt>
defaultFixity :: Fixity
eqBytes :: Bytes -> Bytes -> Bool

-- | List all enabled language extensions.
extsEnabled :: Q [Extension]

-- | Retrieves the Haddock documentation at the specified location, if one
--   exists. It can be used to read documentation on things defined outside
--   of the current module, provided that those modules were compiled with
--   the <tt>-haddock</tt> flag.
getDoc :: DocLoc -> Q (Maybe String)

-- | Get the package root for the current package which is being compiled.
--   This can be set explicitly with the -package-root flag but is normally
--   just the current working directory.
--   
--   The motivation for this flag is to provide a principled means to
--   remove the assumption from splices that they will be executed in the
--   directory where the cabal file resides. Projects such as
--   haskell-language-server can't and don't change directory when
--   compiling files but instead set the -package-root flag appropriately.
getPackageRoot :: Q FilePath

-- | Get state from the <a>Q</a> monad. Note that the state is local to the
--   Haskell module in which the Template Haskell expression is executed.
getQ :: Typeable a => Q (Maybe a)

-- | Internal helper function.
get_cons_names :: Con -> [Name]

-- | Modify the ambient monad used during code generation. For example, you
--   can use <a>hoistCode</a> to handle a state effect: <tt> handleState ::
--   Code (StateT Int Q) a -&gt; Code Q a handleState = hoistCode (flip
--   runState 0) </tt>
hoistCode :: Monad m => (forall x. () => m x -> n x) -> Code m a -> Code n a

-- | Determine whether the given language extension is enabled in the
--   <a>Q</a> monad.
isExtEnabled :: Extension -> Q Bool

-- | Is the list of instances returned by <a>reifyInstances</a> nonempty?
--   
--   If you're confused by an instance not being visible despite being
--   defined in the same module and above the splice in question, see the
--   docs for <a>newDeclarationGroup</a> for a possible explanation.
isInstance :: Name -> [Type] -> Q Bool

-- | A useful combinator for embedding monadic actions into <a>Code</a>
--   <tt> myCode :: ... =&gt; Code m a myCode = joinCode $ do x &lt;-
--   someSideEffect return (makeCodeWith x) </tt>
joinCode :: Monad m => m (Code m a) -> Code m a

-- | Lift a monadic action producing code into the typed <a>Code</a>
--   representation
liftCode :: forall a m. m (TExp a) -> Code m a

-- | The location at which this computation is spliced.
location :: Q Loc
lookupName :: Bool -> String -> Q (Maybe Name)

-- | Look up the given name in the (type namespace of the) current splice's
--   scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for more
--   details.
lookupTypeName :: String -> Q (Maybe Name)

-- | Look up the given name in the (value namespace of the) current
--   splice's scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for
--   more details.
lookupValueName :: String -> Q (Maybe Name)

-- | Synonym for <tt>'<a>Many</a></tt>, from <tt>ghc-prim</tt>.
manyName :: Name

-- | Highest allowed operator precedence for <a>Fixity</a> constructor
--   (answer: 9)
maxPrecedence :: Int
memcmp :: Ptr a -> Ptr b -> CSize -> IO CInt

-- | Smart constructor for <a>ModName</a>
mkModName :: String -> ModName

-- | Generate a capturable name. Occurrences of such names will be resolved
--   according to the Haskell scoping rules at the occurrence site.
--   
--   For example:
--   
--   <pre>
--   f = [| pi + $(varE (mkName "pi")) |]
--   ...
--   g = let pi = 3 in $f
--   </pre>
--   
--   In this case, <tt>g</tt> is desugared to
--   
--   <pre>
--   g = Prelude.pi + 3
--   </pre>
--   
--   Note that <tt>mkName</tt> may be used with qualified names:
--   
--   <pre>
--   mkName "Prelude.pi"
--   </pre>
--   
--   See also <a>dyn</a> for a useful combinator. The above example could
--   be rewritten using <a>dyn</a> as
--   
--   <pre>
--   f = [| pi + $(dyn "pi") |]
--   </pre>
mkName :: String -> Name

-- | Used for 'x etc, but not available to the programmer
mkNameG :: NameSpace -> String -> String -> String -> Name
mkNameG_d :: String -> String -> String -> Name
mkNameG_fld :: String -> String -> String -> String -> Name
mkNameG_tc :: String -> String -> String -> Name
mkNameG_v :: String -> String -> String -> Name

-- | Only used internally
mkNameL :: String -> Uniq -> Name

-- | Only used internally
mkNameQ :: String -> String -> Name
mkNameS :: String -> Name

-- | Only used internally
mkNameU :: String -> Uniq -> Name

-- | Smart constructor for <a>OccName</a>
mkOccName :: String -> OccName

-- | Smart constructor for <a>PkgName</a>
mkPkgName :: String -> PkgName
mk_tup_name :: Int -> NameSpace -> Bool -> Name

-- | Accessor for <a>ModName</a>
modString :: ModName -> String

-- | The name without its module prefix.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nameBase ''Data.Either.Either
--   "Either"
--   
--   &gt;&gt;&gt; nameBase (mkName "foo")
--   "foo"
--   
--   &gt;&gt;&gt; nameBase (mkName "Module.foo")
--   "foo"
--   </pre>
nameBase :: Name -> String

-- | Module prefix of a name, if it exists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nameModule ''Data.Either.Either
--   Just "Data.Either"
--   
--   &gt;&gt;&gt; nameModule (mkName "foo")
--   Nothing
--   
--   &gt;&gt;&gt; nameModule (mkName "Module.foo")
--   Just "Module"
--   </pre>
nameModule :: Name -> Maybe String

-- | A name's package, if it exists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; namePackage ''Data.Either.Either
--   Just "base"
--   
--   &gt;&gt;&gt; namePackage (mkName "foo")
--   Nothing
--   
--   &gt;&gt;&gt; namePackage (mkName "Module.foo")
--   Nothing
--   </pre>
namePackage :: Name -> Maybe String

-- | Returns whether a name represents an occurrence of a top-level
--   variable (<a>VarName</a>), data constructor (<a>DataName</a>), type
--   constructor, or type class (<a>TcClsName</a>). If we can't be sure, it
--   returns <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nameSpace 'Prelude.id
--   Just VarName
--   
--   &gt;&gt;&gt; nameSpace (mkName "id")
--   Nothing -- only works for top-level variable names
--   
--   &gt;&gt;&gt; nameSpace 'Data.Maybe.Just
--   Just DataName
--   
--   &gt;&gt;&gt; nameSpace ''Data.Maybe.Maybe
--   Just TcClsName
--   
--   &gt;&gt;&gt; nameSpace ''Data.Ord.Ord
--   Just TcClsName
--   </pre>
nameSpace :: Name -> Maybe NameSpace

-- | Template Haskell is capable of reifying information about types and
--   terms defined in previous declaration groups. Top-level declaration
--   splices break up declaration groups.
--   
--   For an example, consider this code block. We define a datatype
--   <tt>X</tt> and then try to call <a>reify</a> on the datatype.
--   
--   <pre>
--   module Check where
--   
--   data X = X
--       deriving Eq
--   
--   $(do
--       info &lt;- reify ''X
--       runIO $ print info
--    )
--   </pre>
--   
--   This code fails to compile, noting that <tt>X</tt> is not available
--   for reification at the site of <a>reify</a>. We can fix this by
--   creating a new declaration group using an empty top-level splice:
--   
--   <pre>
--   data X = X
--       deriving Eq
--   
--   $(pure [])
--   
--   $(do
--       info &lt;- reify ''X
--       runIO $ print info
--    )
--   </pre>
--   
--   We provide <a>newDeclarationGroup</a> as a means of documenting this
--   behavior and providing a name for the pattern.
--   
--   Since top level splices infer the presence of the <tt>$( ... )</tt>
--   brackets, we can also write:
--   
--   <pre>
--   data X = X
--       deriving Eq
--   
--   newDeclarationGroup
--   
--   $(do
--       info &lt;- reify ''X
--       runIO $ print info
--    )
--   </pre>
newDeclarationGroup :: Q [Dec]
newNameIO :: String -> IO Name

-- | Accessor for <a>OccName</a>
occString :: OccName -> String

-- | Synonym for <tt>'<a>One</a></tt>, from <tt>ghc-prim</tt>.
oneName :: Name

-- | Accessor for <a>PkgName</a>
pkgString :: PkgName -> String

-- | Add Haddock documentation to the specified location. This will
--   overwrite any documentation at the location if it already exists. This
--   will reify the specified name, so it must be in scope when you call
--   it. If you want to add documentation to something that you are
--   currently splicing, you can use <a>addModFinalizer</a> e.g.
--   
--   <pre>
--   do
--     let nm = mkName "x"
--     addModFinalizer $ putDoc (DeclDoc nm) "Hello"
--     [d| $(varP nm) = 42 |]
--   </pre>
--   
--   The helper functions <tt>withDecDoc</tt> and <tt>withDecsDoc</tt> will
--   do this for you, as will the <tt>funD_doc</tt> and other <tt>_doc</tt>
--   combinators. You most likely want to have the <tt>-haddock</tt> flag
--   turned on when using this. Adding documentation to anything outside of
--   the current module will cause an error.
putDoc :: DocLoc -> String -> Q ()

-- | Replace the state in the <a>Q</a> monad. Note that the state is local
--   to the Haskell module in which the Template Haskell expression is
--   executed.
putQ :: Typeable a => a -> Q ()

-- | Recover from errors raised by <a>reportError</a> or <a>fail</a>.
recover :: Q a -> Q a -> Q a

-- | <a>reify</a> looks up information about the <a>Name</a>. It will fail
--   with a compile error if the <a>Name</a> is not visible. A <a>Name</a>
--   is visible if it is imported or defined in a prior top-level
--   declaration group. See the documentation for
--   <a>newDeclarationGroup</a> for more details.
--   
--   It is sometimes useful to construct the argument name using
--   <a>lookupTypeName</a> or <a>lookupValueName</a> to ensure that we are
--   reifying from the right namespace. For instance, in this context:
--   
--   <pre>
--   data D = D
--   </pre>
--   
--   which <tt>D</tt> does <tt>reify (mkName "D")</tt> return information
--   about? (Answer: <tt>D</tt>-the-type, but don't rely on it.) To ensure
--   we get information about <tt>D</tt>-the-value, use
--   <a>lookupValueName</a>:
--   
--   <pre>
--   do
--     Just nm &lt;- lookupValueName "D"
--     reify nm
--   </pre>
--   
--   and to get information about <tt>D</tt>-the-type, use
--   <a>lookupTypeName</a>.
reify :: Name -> Q Info

-- | <tt>reifyAnnotations target</tt> returns the list of annotations
--   associated with <tt>target</tt>. Only the annotations that are
--   appropriately typed is returned. So if you have <tt>Int</tt> and
--   <tt>String</tt> annotations for the same target, you have to call this
--   function twice.
reifyAnnotations :: Data a => AnnLookup -> Q [a]

-- | <tt>reifyConStrictness nm</tt> looks up the strictness information for
--   the fields of the constructor with the name <tt>nm</tt>. Note that the
--   strictness information that <a>reifyConStrictness</a> returns may not
--   correspond to what is written in the source code. For example, in the
--   following data declaration:
--   
--   <pre>
--   data Pair a = Pair a a
--   </pre>
--   
--   <a>reifyConStrictness</a> would return <tt>[<a>DecidedLazy</a>,
--   DecidedLazy]</tt> under most circumstances, but it would return
--   <tt>[<a>DecidedStrict</a>, DecidedStrict]</tt> if the
--   <tt>-XStrictData</tt> language extension was enabled.
reifyConStrictness :: Name -> Q [DecidedStrictness]

-- | <tt>reifyFixity nm</tt> attempts to find a fixity declaration for
--   <tt>nm</tt>. For example, if the function <tt>foo</tt> has the fixity
--   declaration <tt>infixr 7 foo</tt>, then <tt>reifyFixity 'foo</tt>
--   would return <tt><a>Just</a> (<a>Fixity</a> 7 <a>InfixR</a>)</tt>. If
--   the function <tt>bar</tt> does not have a fixity declaration, then
--   <tt>reifyFixity 'bar</tt> returns <a>Nothing</a>, so you may assume
--   <tt>bar</tt> has <a>defaultFixity</a>.
reifyFixity :: Name -> Q (Maybe Fixity)

-- | <tt>reifyInstances nm tys</tt> returns a list of all visible instances
--   (see below for "visible") of <tt>nm tys</tt>. That is, if <tt>nm</tt>
--   is the name of a type class, then all instances of this class at the
--   types <tt>tys</tt> are returned. Alternatively, if <tt>nm</tt> is the
--   name of a data family or type family, all instances of this family at
--   the types <tt>tys</tt> are returned.
--   
--   Note that this is a "shallow" test; the declarations returned merely
--   have instance heads which unify with <tt>nm tys</tt>, they need not
--   actually be satisfiable.
--   
--   <ul>
--   <li><tt>reifyInstances ''Eq [ <a>TupleT</a> 2 `<a>AppT</a>`
--   <a>ConT</a> ''A `<a>AppT</a>` <a>ConT</a> ''B ]</tt> contains the
--   <tt>instance (Eq a, Eq b) =&gt; Eq (a, b)</tt> regardless of whether
--   <tt>A</tt> and <tt>B</tt> themselves implement <a>Eq</a></li>
--   <li><tt>reifyInstances ''Show [ <a>VarT</a> (<a>mkName</a> "a") ]</tt>
--   produces every available instance of <a>Show</a></li>
--   </ul>
--   
--   There is one edge case: <tt>reifyInstances ''Typeable tys</tt>
--   currently always produces an empty list (no matter what <tt>tys</tt>
--   are given).
--   
--   In principle, the *visible* instances are * all instances defined in a
--   prior top-level declaration group (see docs on
--   <tt>newDeclarationGroup</tt>), or * all instances defined in any
--   module transitively imported by the module being compiled
--   
--   However, actually searching all modules transitively below the one
--   being compiled is unreasonably expensive, so <tt>reifyInstances</tt>
--   will report only the instance for modules that GHC has had some cause
--   to visit during this compilation. This is a shortcoming:
--   <tt>reifyInstances</tt> might fail to report instances for a type that
--   is otherwise unusued, or instances defined in a different component.
--   You can work around this shortcoming by explicitly importing the
--   modules whose instances you want to be visible. GHC issue
--   <a>#20529</a> has some discussion around this.
reifyInstances :: Name -> [Type] -> Q [InstanceDec]

-- | <tt>reifyModule mod</tt> looks up information about module
--   <tt>mod</tt>. To look up the current module, call this function with
--   the return value of <a>thisModule</a>.
reifyModule :: Module -> Q ModuleInfo

-- | <tt>reifyRoles nm</tt> returns the list of roles associated with the
--   parameters (both visible and invisible) of the tycon <tt>nm</tt>.
--   Fails if <tt>nm</tt> cannot be found or is not a tycon. The returned
--   list should never contain <a>InferR</a>.
--   
--   An invisible parameter to a tycon is often a kind parameter. For
--   example, if we have
--   
--   <pre>
--   type Proxy :: forall k. k -&gt; Type
--   data Proxy a = MkProxy
--   </pre>
--   
--   and <tt>reifyRoles Proxy</tt>, we will get <tt>[<a>NominalR</a>,
--   <a>PhantomR</a>]</tt>. The <a>NominalR</a> is the role of the
--   invisible <tt>k</tt> parameter. Kind parameters are always nominal.
reifyRoles :: Name -> Q [Role]

-- | <tt>reifyType nm</tt> attempts to find the type or kind of
--   <tt>nm</tt>. For example, <tt>reifyType 'not</tt> returns <tt>Bool
--   -&gt; Bool</tt>, and <tt>reifyType ''Bool</tt> returns <tt>Type</tt>.
--   This works even if there's no explicit signature and the type or kind
--   is inferred.
reifyType :: Name -> Q Type

-- | Report an error (True) or warning (False), but carry on; use
--   <a>fail</a> to stop.

-- | <i>Deprecated: Use reportError or reportWarning instead</i>
report :: Bool -> String -> Q ()

-- | Report an error to the user, but allow the current splice's
--   computation to carry on. To abort the computation, use <a>fail</a>.
reportError :: String -> Q ()

-- | Report a warning to the user, and carry on.
reportWarning :: String -> Q ()

-- | The <a>runIO</a> function lets you run an I/O computation in the
--   <a>Q</a> monad. Take care: you are guaranteed the ordering of calls to
--   <a>runIO</a> within a single <a>Q</a> computation, but not about the
--   order in which splices are run.
--   
--   Note: for various murky reasons, stdout and stderr handles are not
--   necessarily flushed when the compiler finishes running, so you should
--   flush them yourself.
runIO :: IO a -> Q a

-- | "Runs" the <a>Q</a> monad. Normal users of Template Haskell should not
--   need this function, as the splice brackets <tt>$( ... )</tt> are the
--   usual way of running a <a>Q</a> computation.
--   
--   This function is primarily used in GHC internals, and for debugging
--   splices by running them in <a>IO</a>.
--   
--   Note that many functions in <a>Q</a>, such as <a>reify</a> and other
--   compiler queries, are not supported when running <a>Q</a> in
--   <a>IO</a>; these operations simply fail at runtime. Indeed, the only
--   operations guaranteed to succeed are <a>newName</a>, <a>runIO</a>,
--   <a>reportError</a> and <a>reportWarning</a>.
runQ :: Quasi m => Q a -> m a

-- | This function is only used in <a>Quote</a> when desugaring brackets.
--   This is not necessary for the user, who can use the ordinary
--   <a>return</a> and <a>(&gt;&gt;=)</a> operations.
sequenceQ :: Monad m => forall a. () => [m a] -> m [a]
showName :: Name -> String
showName' :: NameIs -> Name -> String

-- | Internal helper function.
thenCmp :: Ordering -> Ordering -> Ordering

-- | Tuple data constructor
tupleDataName :: Int -> Name

-- | Tuple type constructor
tupleTypeName :: Int -> Name

-- | Extract the untyped representation from the typed representation
unTypeCode :: forall a m. Quote m => Code m a -> m Exp

-- | Discard the type annotation and produce a plain Template Haskell
--   expression
--   
--   Representation-polymorphic since <i>template-haskell-2.16.0.0</i>.
unTypeQ :: forall a m. Quote m => m (TExp a) -> m Exp

-- | Unboxed sum data constructor
unboxedSumDataName :: SumAlt -> SumArity -> Name

-- | Unboxed sum type constructor
unboxedSumTypeName :: SumArity -> Name

-- | Unboxed tuple data constructor
unboxedTupleDataName :: Int -> Name

-- | Unboxed tuple type constructor
unboxedTupleTypeName :: Int -> Name

-- | Unsafely convert an untyped code representation into a typed code
--   representation.
unsafeCodeCoerce :: forall a m. Quote m => m Exp -> Code m a

-- | Annotate the Template Haskell expression with a type
--   
--   This is unsafe because GHC cannot check for you that the expression
--   really does have the type you claim it has.
--   
--   Representation-polymorphic since <i>template-haskell-2.16.0.0</i>.
unsafeTExpCoerce :: forall a m. Quote m => m Exp -> m (TExp a)

-- | Annotation target for reifyAnnotations
data AnnLookup
AnnLookupModule :: Module -> AnnLookup
AnnLookupName :: Name -> AnnLookup

-- | The target of an <tt>ANN</tt> pragma
data AnnTarget

-- | <pre>
--   {-# ANN {module} ... #-}
--   </pre>
ModuleAnnotation :: AnnTarget

-- | <pre>
--   {-# ANN type {name} ... #-}
--   </pre>
TypeAnnotation :: Name -> AnnTarget

-- | <pre>
--   {-# ANN {name} ... #-}
--   </pre>
ValueAnnotation :: Name -> AnnTarget

-- | In <a>PrimTyConI</a>, arity of the type constructor
type Arity = Int

-- | Strictness information in a data constructor's argument.
data Bang

-- | <pre>
--   C { {-# UNPACK #-} !}a
--   </pre>
Bang :: SourceUnpackedness -> SourceStrictness -> Bang

-- | A type with a strictness annotation, as in data constructors. See
--   <a>Con</a>.
type BangType = (Bang, Type)

-- | Visibility of a type variable. See <a>Inferred vs. specified type
--   variables</a>.
data BndrVis

-- | <pre>
--   a
--   </pre>
BndrReq :: BndrVis

-- | <pre>
--   @a
--   </pre>
BndrInvis :: BndrVis

-- | A potentially guarded expression, as in function definitions or case
--   alternatives.
data Body

-- | <pre>
--   f p { | e1 = e2
--         | e3 = e4 }
--    where ds
--   </pre>
GuardedB :: [(Guard, Exp)] -> Body

-- | <pre>
--   f p { = e } where ds
--   </pre>
NormalB :: Exp -> Body

-- | Raw bytes embedded into the binary.
--   
--   Avoid using Bytes constructor directly as it is likely to change in
--   the future. Use helpers such as <tt>mkBytes</tt> in
--   Language.Haskell.TH.Lib instead.
data Bytes
Bytes :: ForeignPtr Word8 -> Word -> Word -> Bytes

-- | Pointer to the data
[bytesPtr] :: Bytes -> ForeignPtr Word8

-- | Offset from the pointer
[bytesOffset] :: Bytes -> Word

-- | Number of bytes
[bytesSize] :: Bytes -> Word

-- | A calling convention identifier, as in a <a>Foreign</a> declaration.
data Callconv
CCall :: Callconv
StdCall :: Callconv
CApi :: Callconv
Prim :: Callconv
JavaScript :: Callconv
type CharPos = (Int, Int)

-- | A clause consists of patterns, guards, a body expression, and a list
--   of declarations under a <tt>where</tt>. Clauses are seen in equations
--   for function definitions, <tt>case</tt>-experssions,
--   explicitly-bidirectional pattern synonyms, etc.
data Clause

-- | <pre>
--   f { p1 p2 = body where decs }
--   </pre>
Clause :: [Pat] -> Body -> [Dec] -> Clause

-- | Represents an expression which has type <tt>a</tt>, built in monadic
--   context <tt>m</tt>. Built on top of <a>TExp</a>, typed expressions
--   allow for type-safe splicing via:
--   
--   <ul>
--   <li>typed quotes, written as <tt>[|| ... ||]</tt> where <tt>...</tt>
--   is an expression; if that expression has type <tt>a</tt>, then the
--   quotation has type <tt>Quote m =&gt; Code m a</tt></li>
--   <li>typed splices inside of typed quotes, written as <tt>$$(...)</tt>
--   where <tt>...</tt> is an arbitrary expression of type <tt>Quote m
--   =&gt; Code m a</tt></li>
--   </ul>
--   
--   Traditional expression quotes and splices let us construct ill-typed
--   expressions:
--   
--   <pre>
--   &gt;&gt;&gt; fmap ppr $ runQ (unTypeCode [| True == $( [| "foo" |] ) |])
--   GHC.Types.True GHC.Classes.== "foo"
--   
--   &gt;&gt;&gt; GHC.Types.True GHC.Classes.== "foo"
--   &lt;interactive&gt; error:
--       • Couldn't match expected type ‘Bool’ with actual type ‘[Char]’
--       • In the second argument of ‘(==)’, namely ‘"foo"’
--         In the expression: True == "foo"
--         In an equation for ‘it’: it = True == "foo"
--   </pre>
--   
--   With typed expressions, the type error occurs when <i>constructing</i>
--   the Template Haskell expression:
--   
--   <pre>
--   &gt;&gt;&gt; fmap ppr $ runQ (unTypeCode [|| True == $$( [|| "foo" ||] ) ||])
--   &lt;interactive&gt; error:
--       • Couldn't match type ‘[Char]’ with ‘Bool’
--         Expected type: Code Q Bool
--           Actual type: Code Q [Char]
--       • In the Template Haskell quotation [|| "foo" ||]
--         In the expression: [|| "foo" ||]
--         In the Template Haskell splice $$([|| "foo" ||])
--   </pre>
newtype Code (m :: Type -> Type) (a :: TYPE r)
Code :: m (TExp a) -> Code (m :: Type -> Type) (a :: TYPE r)

-- | Underlying monadic value
[examineCode] :: Code (m :: Type -> Type) (a :: TYPE r) -> m (TExp a)

-- | A data constructor.
--   
--   The constructors for <a>Con</a> can roughly be divided up into two
--   categories: those for constructors with "vanilla" syntax
--   (<a>NormalC</a>, <a>RecC</a>, and <a>InfixC</a>), and those for
--   constructors with GADT syntax (<a>GadtC</a> and <a>RecGadtC</a>). The
--   <a>ForallC</a> constructor, which quantifies additional type variables
--   and class contexts, can surround either variety of constructor.
--   However, the type variables that it quantifies are different depending
--   on what constructor syntax is used:
--   
--   <ul>
--   <li>If a <a>ForallC</a> surrounds a constructor with vanilla syntax,
--   then the <a>ForallC</a> will only quantify <i>existential</i> type
--   variables. For example:</li>
--   </ul>
--   
--   <pre>
--   data Foo a = forall b. MkFoo a b
--   
--   </pre>
--   
--   In <tt>MkFoo</tt>, <a>ForallC</a> will quantify <tt>b</tt>, but not
--   <tt>a</tt>.
--   
--   <ul>
--   <li>If a <a>ForallC</a> surrounds a constructor with GADT syntax, then
--   the <a>ForallC</a> will quantify <i>all</i> type variables used in the
--   constructor. For example:</li>
--   </ul>
--   
--   <pre>
--   data Bar a b where
--     MkBar :: (a ~ b) =&gt; c -&gt; MkBar a b
--   
--   </pre>
--   
--   In <tt>MkBar</tt>, <a>ForallC</a> will quantify <tt>a</tt>,
--   <tt>b</tt>, and <tt>c</tt>.
--   
--   Multiplicity annotations for data types are currently not supported in
--   Template Haskell (i.e. all fields represented by Template Haskell will
--   be linear).
data Con

-- | <pre>
--   C Int a
--   </pre>
NormalC :: Name -> [BangType] -> Con

-- | <pre>
--   C { v :: Int, w :: a }
--   </pre>
RecC :: Name -> [VarBangType] -> Con

-- | <pre>
--   Int :+ a
--   </pre>
InfixC :: BangType -> Name -> BangType -> Con

-- | <pre>
--   forall a. Eq a =&gt; C [a]
--   </pre>
ForallC :: [TyVarBndr Specificity] -> Cxt -> Con -> Con
GadtC :: [Name] -> [BangType] -> Type -> Con

-- | <pre>
--   C :: { v :: Int } -&gt; T b Int
--   </pre>
RecGadtC :: [Name] -> [VarBangType] -> Type -> Con

-- | A context, as found on the left side of a <tt>=&gt;</tt> in a type.
type Cxt = [Pred]

-- | A single declaration.
data Dec

-- | <pre>
--   { f p1 p2 = b where decs }
--   </pre>
FunD :: Name -> [Clause] -> Dec

-- | <pre>
--   { p = b where decs }
--   </pre>
ValD :: Pat -> Body -> [Dec] -> Dec

-- | <pre>
--   { data Cxt x =&gt; T x = A x | B (T x)
--          deriving (Z,W)
--          deriving stock Eq }
--   </pre>
DataD :: Cxt -> Name -> [TyVarBndr BndrVis] -> Maybe Kind -> [Con] -> [DerivClause] -> Dec

-- | <pre>
--   { newtype Cxt x =&gt; T x = A (B x)
--          deriving (Z,W Q)
--          deriving stock Eq }
--   </pre>
NewtypeD :: Cxt -> Name -> [TyVarBndr BndrVis] -> Maybe Kind -> Con -> [DerivClause] -> Dec

-- | <pre>
--   { type data T x = A x | B (T x) }
--   </pre>
TypeDataD :: Name -> [TyVarBndr BndrVis] -> Maybe Kind -> [Con] -> Dec

-- | <pre>
--   { type T x = (x,x) }
--   </pre>
TySynD :: Name -> [TyVarBndr BndrVis] -> Type -> Dec

-- | <pre>
--   { class Eq a =&gt; Ord a where ds }
--   </pre>
ClassD :: Cxt -> Name -> [TyVarBndr BndrVis] -> [FunDep] -> [Dec] -> Dec

-- | <pre>
--   { instance {-# OVERLAPS #-}
--           Show w =&gt; Show [w] where ds }
--   </pre>
InstanceD :: Maybe Overlap -> Cxt -> Type -> [Dec] -> Dec

-- | <pre>
--   { length :: [a] -&gt; Int }
--   </pre>
SigD :: Name -> Type -> Dec

-- | <pre>
--   { type TypeRep :: k -&gt; Type }
--   </pre>
KiSigD :: Name -> Kind -> Dec

-- | <pre>
--   { foreign import ... }
--   { foreign export ... }
--   </pre>
ForeignD :: Foreign -> Dec

-- | <pre>
--   { infix 3 data foo }
--   </pre>
InfixD :: Fixity -> NamespaceSpecifier -> Name -> Dec

-- | <pre>
--   { default (Integer, Double) }
--   </pre>
DefaultD :: [Type] -> Dec

-- | pragmas
PragmaD :: Pragma -> Dec

-- | data families (may also appear in [Dec] of <a>ClassD</a> and
--   <a>InstanceD</a>)
DataFamilyD :: Name -> [TyVarBndr BndrVis] -> Maybe Kind -> Dec

-- | <pre>
--   { data instance Cxt x =&gt; T [x]
--          = A x | B (T x)
--          deriving (Z,W)
--          deriving stock Eq }
--   </pre>
DataInstD :: Cxt -> Maybe [TyVarBndr ()] -> Type -> Maybe Kind -> [Con] -> [DerivClause] -> Dec

-- | <pre>
--   { newtype instance Cxt x =&gt; T [x]
--           = A (B x)
--           deriving (Z,W)
--           deriving stock Eq }
--   </pre>
NewtypeInstD :: Cxt -> Maybe [TyVarBndr ()] -> Type -> Maybe Kind -> Con -> [DerivClause] -> Dec

-- | <pre>
--   { type instance ... }
--   </pre>
TySynInstD :: TySynEqn -> Dec

-- | open type families (may also appear in [Dec] of <a>ClassD</a> and
--   <a>InstanceD</a>)
OpenTypeFamilyD :: TypeFamilyHead -> Dec

-- | <pre>
--   { type family F a b = (r :: *) | r -&gt; a where ... }
--   </pre>
ClosedTypeFamilyD :: TypeFamilyHead -> [TySynEqn] -> Dec

-- | <pre>
--   { type role T nominal representational }
--   </pre>
RoleAnnotD :: Name -> [Role] -> Dec

-- | <pre>
--   { deriving stock instance Ord a =&gt; Ord (Foo a) }
--   </pre>
StandaloneDerivD :: Maybe DerivStrategy -> Cxt -> Type -> Dec

-- | <pre>
--   { default size :: Data a =&gt; a -&gt; Int }
--   </pre>
DefaultSigD :: Name -> Type -> Dec

-- | Pattern Synonyms
PatSynD :: Name -> PatSynArgs -> PatSynDir -> Pat -> Dec

-- | A pattern synonym's type signature.
PatSynSigD :: Name -> PatSynType -> Dec

-- | <pre>
--   { ?x = expr }
--   </pre>
--   
--   Implicit parameter binding declaration. Can only be used in let and
--   where clauses which consist entirely of implicit bindings.
ImplicitParamBindD :: String -> Exp -> Dec

-- | Unlike <a>SourceStrictness</a> and <a>SourceUnpackedness</a>,
--   <a>DecidedStrictness</a> refers to the strictness annotations that the
--   compiler chooses for a data constructor field, which may be different
--   from what is written in source code.
--   
--   Note that non-unpacked strict fields are assigned <a>DecidedLazy</a>
--   when a bang would be inappropriate, such as the field of a newtype
--   constructor and fields that have an unlifted type.
--   
--   See <a>reifyConStrictness</a> for more information.
data DecidedStrictness

-- | Field inferred to not have a bang.
DecidedLazy :: DecidedStrictness

-- | Field inferred to have a bang.
DecidedStrict :: DecidedStrictness

-- | Field inferred to be unpacked.
DecidedUnpack :: DecidedStrictness

-- | A single <tt>deriving</tt> clause at the end of a datatype
--   declaration.
data DerivClause

-- | <pre>
--   { deriving stock (Eq, Ord) }
--   </pre>
DerivClause :: Maybe DerivStrategy -> Cxt -> DerivClause

-- | What the user explicitly requests when deriving an instance with
--   <tt>-XDerivingStrategies</tt>.
data DerivStrategy

-- | <pre>
--   deriving {stock} C
--   </pre>
StockStrategy :: DerivStrategy

-- | <tt>deriving {anyclass} C</tt>, <tt>-XDeriveAnyClass</tt>
AnyclassStrategy :: DerivStrategy

-- | <tt>deriving {newtype} C</tt>, <tt>-XGeneralizedNewtypeDeriving</tt>
NewtypeStrategy :: DerivStrategy

-- | <tt>deriving C {via T}</tt>, <tt>-XDerivingVia</tt>
ViaStrategy :: Type -> DerivStrategy

-- | A location at which to attach Haddock documentation. Note that adding
--   documentation to a <a>Name</a> defined oustide of the current module
--   will cause an error.
data DocLoc

-- | At the current module's header.
ModuleDoc :: DocLoc

-- | At a declaration, not necessarily top level.
DeclDoc :: Name -> DocLoc

-- | At a specific argument of a function, indexed by its position.
ArgDoc :: Name -> Int -> DocLoc

-- | At a class or family instance.
InstDoc :: Type -> DocLoc

-- | A Haskell expression.
data Exp

-- | <pre>
--   { x }
--   </pre>
VarE :: Name -> Exp

-- | <pre>
--   data T1 = C1 t1 t2; p = {C1} e1 e2
--   </pre>
ConE :: Name -> Exp

-- | <pre>
--   { 5 or 'c'}
--   </pre>
LitE :: Lit -> Exp

-- | <pre>
--   { f x }
--   </pre>
AppE :: Exp -> Exp -> Exp

-- | <pre>
--   { f @Int }
--   </pre>
AppTypeE :: Exp -> Type -> Exp

-- | <pre>
--   {x + y} or {(x+)} or {(+ x)} or {(+)}
--   </pre>
InfixE :: Maybe Exp -> Exp -> Maybe Exp -> Exp

-- | <pre>
--   {x + y}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { (e) }
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensE :: Exp -> Exp

-- | <pre>
--   { \ p1 p2 -&gt; e }
--   </pre>
LamE :: [Pat] -> Exp -> Exp

-- | <pre>
--   { \case m1; m2 }
--   </pre>
LamCaseE :: [Match] -> Exp

-- | <pre>
--   { \cases m1; m2 }
--   </pre>
LamCasesE :: [Clause] -> Exp

-- | <pre>
--   { (e1,e2) }
--   </pre>
--   
--   The <a>Maybe</a> is necessary for handling tuple sections.
--   
--   <pre>
--   (1,)
--   </pre>
--   
--   translates to
--   
--   <pre>
--   TupE [Just (LitE (IntegerL 1)),Nothing]
--   </pre>
TupE :: [Maybe Exp] -> Exp

-- | <pre>
--   { (# e1,e2 #) }
--   </pre>
--   
--   The <a>Maybe</a> is necessary for handling tuple sections.
--   
--   <pre>
--   (# 'c', #)
--   </pre>
--   
--   translates to
--   
--   <pre>
--   UnboxedTupE [Just (LitE (CharL 'c')),Nothing]
--   </pre>
UnboxedTupE :: [Maybe Exp] -> Exp

-- | <pre>
--   { (#|e|#) }
--   </pre>
UnboxedSumE :: Exp -> SumAlt -> SumArity -> Exp

-- | <pre>
--   { if e1 then e2 else e3 }
--   </pre>
CondE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { if | g1 -&gt; e1 | g2 -&gt; e2 }
--   </pre>
MultiIfE :: [(Guard, Exp)] -> Exp

-- | <pre>
--   { let { x=e1; y=e2 } in e3 }
--   </pre>
LetE :: [Dec] -> Exp -> Exp

-- | <pre>
--   { case e of m1; m2 }
--   </pre>
CaseE :: Exp -> [Match] -> Exp

-- | <tt>{ do { p &lt;- e1; e2 } }</tt> or a qualified do if the module
--   name is present
DoE :: Maybe ModName -> [Stmt] -> Exp

-- | <tt>{ mdo { x &lt;- e1 y; y &lt;- e2 x; } }</tt> or a qualified mdo if
--   the module name is present
MDoE :: Maybe ModName -> [Stmt] -> Exp

-- | <pre>
--   { [ (x,y) | x &lt;- xs, y &lt;- ys ] }
--   </pre>
--   
--   The result expression of the comprehension is the <i>last</i> of the
--   <tt><a>Stmt</a></tt>s, and should be a <a>NoBindS</a>.
--   
--   E.g. translation:
--   
--   <pre>
--   [ f x | x &lt;- xs ]
--   </pre>
--   
--   <pre>
--   CompE [BindS (VarP x) (VarE xs), NoBindS (AppE (VarE f) (VarE x))]
--   </pre>
CompE :: [Stmt] -> Exp

-- | <pre>
--   { [ 1 ,2 .. 10 ] }
--   </pre>
ArithSeqE :: Range -> Exp

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListE :: [Exp] -> Exp

-- | <pre>
--   { e :: t }
--   </pre>
SigE :: Exp -> Type -> Exp

-- | <pre>
--   { T { x = y, z = w } }
--   </pre>
RecConE :: Name -> [FieldExp] -> Exp

-- | <pre>
--   { (f x) { z = w } }
--   </pre>
RecUpdE :: Exp -> [FieldExp] -> Exp

-- | <pre>
--   { static e }
--   </pre>
StaticE :: Exp -> Exp

-- | <pre>
--   { _x }
--   </pre>
--   
--   This is used for holes or unresolved identifiers in AST quotes. Note
--   that it could either have a variable name or constructor name.
UnboundVarE :: Name -> Exp

-- | <tt>{ #x }</tt> ( Overloaded label )
LabelE :: String -> Exp

-- | <tt>{ ?x }</tt> ( Implicit parameter )
ImplicitParamVarE :: String -> Exp

-- | <tt>{ exp.field }</tt> ( Overloaded Record Dot )
GetFieldE :: Exp -> String -> Exp

-- | <tt>(.x)</tt> or <tt>(.x.y)</tt> (Record projections)
ProjectionE :: NonEmpty String -> Exp

-- | <pre>
--   [|| e ||]
--   </pre>
TypedBracketE :: Exp -> Exp

-- | <pre>
--   $$e
--   </pre>
TypedSpliceE :: Exp -> Exp

-- | <pre>
--   { type t }
--   </pre>
TypeE :: Type -> Exp

-- | <pre>
--   forall &lt;vars&gt;. &lt;expr&gt;
--   </pre>
ForallE :: [TyVarBndr Specificity] -> Exp -> Exp

-- | <pre>
--   forall &lt;vars&gt; -&gt; &lt;expr&gt;
--   </pre>
ForallVisE :: [TyVarBndr ()] -> Exp -> Exp

-- | <pre>
--   &lt;ctxt&gt; =&gt; &lt;expr&gt;
--   </pre>
ConstrainedE :: [Exp] -> Exp -> Exp

-- | Type family result signature
data FamilyResultSig

-- | no signature
NoSig :: FamilyResultSig

-- | <pre>
--   k
--   </pre>
KindSig :: Kind -> FamilyResultSig

-- | <pre>
--   = r, = (r :: k)
--   </pre>
TyVarSig :: TyVarBndr () -> FamilyResultSig

-- | A (field name, expression) pair. See <a>RecConE</a> and
--   <a>RecUpdE</a>.
type FieldExp = (Name, Exp)

-- | A (field name, pattern) pair. See <a>RecP</a>.
type FieldPat = (Name, Pat)

-- | Fixity, as specified in a <tt>infix[lr] n</tt> declaration.
data Fixity
Fixity :: Int -> FixityDirection -> Fixity

-- | The associativity of an operator, as in an <tt>infix</tt> declaration.
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection

-- | A <tt>foreign</tt> declaration.
data Foreign

-- | <pre>
--   foreign import callconv safety "foreign_name" haskellName :: type
--   </pre>
ImportF :: Callconv -> Safety -> String -> Name -> Type -> Foreign

-- | <pre>
--   foreign export callconv "foreign_name" haskellName :: type
--   </pre>
ExportF :: Callconv -> String -> Name -> Type -> Foreign

-- | <a>Functional dependency</a> syntax, as in a class declaration.
data FunDep

-- | <pre>
--   class C a b {| a -&gt; b}
--   </pre>
FunDep :: [Name] -> [Name] -> FunDep

-- | A single guard.
data Guard

-- | <pre>
--   f x { | odd x } = x
--   </pre>
NormalG :: Exp -> Guard

-- | <pre>
--   f x { | Just y &lt;- x, Just z &lt;- y } = z
--   </pre>
PatG :: [Stmt] -> Guard

-- | Obtained from <a>reify</a> in the <a>Q</a> Monad.
data Info

-- | A class, with a list of its visible instances
ClassI :: Dec -> [InstanceDec] -> Info

-- | A class method
ClassOpI :: Name -> Type -> ParentName -> Info

-- | A "plain" type constructor. "Fancier" type constructors are returned
--   using <a>PrimTyConI</a> or <a>FamilyI</a> as appropriate. At present,
--   this reified declaration will never have derived instances attached to
--   it (if you wish to check for an instance, see <a>reifyInstances</a>).
TyConI :: Dec -> Info

-- | A type or data family, with a list of its visible instances. A closed
--   type family is returned with 0 instances.
FamilyI :: Dec -> [InstanceDec] -> Info

-- | A "primitive" type constructor, which can't be expressed with a
--   <a>Dec</a>. Examples: <tt>(-&gt;)</tt>, <tt>Int#</tt>.
PrimTyConI :: Name -> Arity -> Unlifted -> Info

-- | A data constructor
DataConI :: Name -> Type -> ParentName -> Info

-- | A pattern synonym
PatSynI :: Name -> PatSynType -> Info

-- | A "value" variable (as opposed to a type variable, see <a>TyVarI</a>).
--   
--   The <tt>Maybe Dec</tt> field contains <tt>Just</tt> the declaration
--   which defined the variable - including the RHS of the declaration - or
--   else <tt>Nothing</tt>, in the case where the RHS is unavailable to the
--   compiler.
--   
--   At present, this value is <i>always</i> <tt>Nothing</tt>: returning
--   the RHS has not yet been implemented and is tracked by <a>GHC
--   #14474</a>.
VarI :: Name -> Type -> Maybe Dec -> Info

-- | A type variable.
--   
--   The <tt>Type</tt> field contains the type which underlies the
--   variable. At present, this is always <tt><a>VarT</a> theName</tt>, but
--   future changes may permit refinement of this.
TyVarI :: Name -> Type -> Info

-- | Injectivity annotation as in an <a>injective type family</a>
data InjectivityAnn
InjectivityAnn :: Name -> [Name] -> InjectivityAnn

-- | An inline pragma.
data Inline

-- | <pre>
--   { {-# NOINLINE ... #-} }
--   </pre>
NoInline :: Inline

-- | <pre>
--   { {-# INLINE ... #-} }
--   </pre>
Inline :: Inline

-- | <pre>
--   { {-# INLINABLE ... #-} }
--   </pre>
Inlinable :: Inline

-- | <a>InstanceDec</a> describes a single instance of a class or type
--   function. It is just a <a>Dec</a>, but guaranteed to be one of the
--   following:
--   
--   <ul>
--   <li><a>InstanceD</a> (with empty <tt>[<a>Dec</a>]</tt>)</li>
--   <li><a>DataInstD</a> or <a>NewtypeInstD</a> (with empty derived
--   <tt>[<a>Name</a>]</tt>)</li>
--   <li><a>TySynInstD</a></li>
--   </ul>
type InstanceDec = Dec

-- | To avoid duplication between kinds and types, they are defined to be
--   the same. Naturally, you would never have a type be <a>StarT</a> and
--   you would never have a kind be <a>SigT</a>, but many of the other
--   constructors are shared. Note that the kind <tt>Bool</tt> is denoted
--   with <a>ConT</a>, not <a>PromotedT</a>. Similarly, tuple kinds are
--   made with <a>TupleT</a>, not <a>PromotedTupleT</a>.
type Kind = Type

-- | A Haskell literal. Note that the numeric types are all in terms of
--   either <a>Integer</a> or <a>Rational</a>, regardless of the type they
--   represent. The extra precision reflects the textual representation in
--   source code.
data Lit

-- | <pre>
--   'c'
--   </pre>
CharL :: Char -> Lit

-- | <pre>
--   "string"
--   </pre>
StringL :: String -> Lit

-- | <tt>123</tt>. Used for overloaded and non-overloaded literals. We
--   don't have a good way to represent non-overloaded literals at the
--   moment. Maybe that doesn't matter?
IntegerL :: Integer -> Lit

-- | <tt>1.23</tt>. See above comment on <a>IntegerL</a>.
RationalL :: Rational -> Lit

-- | <pre>
--   123#
--   </pre>
IntPrimL :: Integer -> Lit

-- | <pre>
--   123##
--   </pre>
WordPrimL :: Integer -> Lit

-- | <pre>
--   1.23#
--   </pre>
FloatPrimL :: Rational -> Lit

-- | <pre>
--   1.23##
--   </pre>
DoublePrimL :: Rational -> Lit

-- | <tt>"string"#</tt>. A primitive C-style string, type <a>Addr#</a>
StringPrimL :: [Word8] -> Lit

-- | Some raw bytes, type <a>Addr#</a>:
BytesPrimL :: Bytes -> Lit

-- | <pre>
--   'c'#
--   </pre>
CharPrimL :: Char -> Lit

-- | A location within a source file.
data Loc
Loc :: String -> String -> String -> CharPos -> CharPos -> Loc
[loc_filename] :: Loc -> String
[loc_package] :: Loc -> String
[loc_module] :: Loc -> String
[loc_start] :: Loc -> CharPos
[loc_end] :: Loc -> CharPos

-- | A <tt>case</tt>-alternative
data Match

-- | <pre>
--   case e of { pat -&gt; body where decs }
--   </pre>
Match :: Pat -> Body -> [Dec] -> Match

-- | The name of a module.
newtype ModName
ModName :: String -> ModName

-- | Obtained from <a>reifyModule</a> and <a>thisModule</a>.
data Module
Module :: PkgName -> ModName -> Module

-- | Obtained from <a>reifyModule</a> in the <a>Q</a> Monad.
data ModuleInfo

-- | Contains the import list of the module.
ModuleInfo :: [Module] -> ModuleInfo

-- | An abstract type representing names in the syntax tree.
--   
--   <a>Name</a>s can be constructed in several ways, which come with
--   different name-capture guarantees (see
--   <a>Language.Haskell.TH.Syntax#namecapture</a> for an explanation of
--   name capture):
--   
--   <ul>
--   <li>the built-in syntax <tt>'f</tt> and <tt>''T</tt> can be used to
--   construct names, The expression <tt>'f</tt> gives a <tt>Name</tt>
--   which refers to the value <tt>f</tt> currently in scope, and
--   <tt>''T</tt> gives a <tt>Name</tt> which refers to the type <tt>T</tt>
--   currently in scope. These names can never be captured.</li>
--   <li><a>lookupValueName</a> and <a>lookupTypeName</a> are similar to
--   <tt>'f</tt> and <tt>''T</tt> respectively, but the <tt>Name</tt>s are
--   looked up at the point where the current splice is being run. These
--   names can never be captured.</li>
--   <li><a>newName</a> monadically generates a new name, which can never
--   be captured.</li>
--   <li><a>mkName</a> generates a capturable name.</li>
--   </ul>
--   
--   Names constructed using <tt>newName</tt> and <tt>mkName</tt> may be
--   used in bindings (such as <tt>let x = ...</tt> or <tt>x -&gt;
--   ...</tt>), but names constructed using <tt>lookupValueName</tt>,
--   <tt>lookupTypeName</tt>, <tt>'f</tt>, <tt>''T</tt> may not.
data Name
Name :: OccName -> NameFlavour -> Name
data NameFlavour

-- | An unqualified name; dynamically bound
NameS :: NameFlavour

-- | A qualified name; dynamically bound
NameQ :: ModName -> NameFlavour

-- | A unique local name
NameU :: !Uniq -> NameFlavour

-- | Local name bound outside of the TH AST
NameL :: !Uniq -> NameFlavour

-- | Global name bound outside of the TH AST: An original name (occurrences
--   only, not binders) Need the namespace too to be sure which thing we
--   are naming
NameG :: NameSpace -> PkgName -> ModName -> NameFlavour
data NameIs

-- | <pre>
--   name
--   </pre>
Alone :: NameIs

-- | <pre>
--   (name)
--   </pre>
Applied :: NameIs

-- | <pre>
--   `name`
--   </pre>
Infix :: NameIs
data NameSpace

-- | Variables
VarName :: NameSpace

-- | Data constructors
DataName :: NameSpace

-- | Type constructors and classes; Haskell has them in the same name space
--   for now.
TcClsName :: NameSpace
FldName :: !String -> NameSpace

-- | The textual name of the parent of the field.
--   
--   <ul>
--   <li>For a field of a datatype, this is the name of the first
--   constructor of the datatype (regardless of whether this constructor
--   has this field).</li>
--   <li>For a field of a pattern synonym, this is the name of the pattern
--   synonym.</li>
--   </ul>
[fldParent] :: NameSpace -> !String

-- | A way to specify a namespace to look in when GHC needs to find a
--   name's source
data NamespaceSpecifier

-- | Name may be everything; If there are two names in different
--   namespaces, then consider both
NoNamespaceSpecifier :: NamespaceSpecifier

-- | Name should be a type-level entity, such as a data type, type alias,
--   type family, type class, or type variable
TypeNamespaceSpecifier :: NamespaceSpecifier

-- | Name should be a term-level entity, such as a function, data
--   constructor, or pattern synonym
DataNamespaceSpecifier :: NamespaceSpecifier

-- | An "Occurence Name".
newtype OccName
OccName :: String -> OccName

-- | Varieties of allowed instance overlap.
data Overlap

-- | May be overlapped by more specific instances
Overlappable :: Overlap

-- | May overlap a more general instance
Overlapping :: Overlap

-- | Both <a>Overlapping</a> and <a>Overlappable</a>
Overlaps :: Overlap

-- | Both <a>Overlapping</a> and <a>Overlappable</a>, and pick an arbitrary
--   one if multiple choices are available.
Incoherent :: Overlap

-- | In <a>ClassOpI</a> and <a>DataConI</a>, name of the parent class or
--   type
type ParentName = Name

-- | Pattern in Haskell given in <tt>{}</tt>
data Pat

-- | <pre>
--   { 5 or 'c' }
--   </pre>
LitP :: Lit -> Pat

-- | <pre>
--   { x }
--   </pre>
VarP :: Name -> Pat

-- | <pre>
--   { (p1,p2) }
--   </pre>
TupP :: [Pat] -> Pat

-- | <pre>
--   { (# p1,p2 #) }
--   </pre>
UnboxedTupP :: [Pat] -> Pat

-- | <pre>
--   { (#|p|#) }
--   </pre>
UnboxedSumP :: Pat -> SumAlt -> SumArity -> Pat

-- | <pre>
--   data T1 = C1 t1 t2; {C1 @ty1 p1 p2} = e
--   </pre>
ConP :: Name -> [Type] -> [Pat] -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
InfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   {(p)}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensP :: Pat -> Pat

-- | <pre>
--   { ~p }
--   </pre>
TildeP :: Pat -> Pat

-- | <pre>
--   { !p }
--   </pre>
BangP :: Pat -> Pat

-- | <pre>
--   { x @ p }
--   </pre>
AsP :: Name -> Pat -> Pat

-- | <pre>
--   { _ }
--   </pre>
WildP :: Pat

-- | <pre>
--   f (Pt { pointx = x }) = g x
--   </pre>
RecP :: Name -> [FieldPat] -> Pat

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListP :: [Pat] -> Pat

-- | <pre>
--   { p :: t }
--   </pre>
SigP :: Pat -> Type -> Pat

-- | <pre>
--   { e -&gt; p }
--   </pre>
ViewP :: Exp -> Pat -> Pat

-- | <pre>
--   { type p }
--   </pre>
TypeP :: Type -> Pat

-- | <tt>{ </tt>p }@
InvisP :: Type -> Pat

-- | <pre>
--   { p1; p2 }
--   </pre>
OrP :: NonEmpty Pat -> Pat

-- | A pattern synonym's argument type.
data PatSynArgs

-- | <pre>
--   pattern P {x y z} = p
--   </pre>
PrefixPatSyn :: [Name] -> PatSynArgs

-- | <pre>
--   pattern {x P y} = p
--   </pre>
InfixPatSyn :: Name -> Name -> PatSynArgs

-- | <pre>
--   pattern P { {x,y,z} } = p
--   </pre>
RecordPatSyn :: [Name] -> PatSynArgs

-- | A pattern synonym's directionality.
data PatSynDir

-- | <pre>
--   pattern P x {&lt;-} p
--   </pre>
Unidir :: PatSynDir

-- | <pre>
--   pattern P x {=} p
--   </pre>
ImplBidir :: PatSynDir

-- | <pre>
--   pattern P x {&lt;-} p where P x = e
--   </pre>
ExplBidir :: [Clause] -> PatSynDir

-- | A pattern synonym's type. Note that a pattern synonym's <i>fully</i>
--   specified type has a peculiar shape coming with two forall quantifiers
--   and two constraint contexts. For example, consider the pattern synonym
--   
--   <pre>
--   pattern P x1 x2 ... xn = &lt;some-pattern&gt;
--   </pre>
--   
--   P's complete type is of the following form
--   
--   <pre>
--   pattern P :: forall universals.   required constraints
--             =&gt; forall existentials. provided constraints
--             =&gt; t1 -&gt; t2 -&gt; ... -&gt; tn -&gt; t
--   </pre>
--   
--   consisting of four parts:
--   
--   <ol>
--   <li>the (possibly empty lists of) universally quantified type
--   variables and required constraints on them.</li>
--   <li>the (possibly empty lists of) existentially quantified type
--   variables and the provided constraints on them.</li>
--   <li>the types <tt>t1</tt>, <tt>t2</tt>, .., <tt>tn</tt> of
--   <tt>x1</tt>, <tt>x2</tt>, .., <tt>xn</tt>, respectively</li>
--   <li>the type <tt>t</tt> of <tt>&lt;some-pattern&gt;</tt>, mentioning
--   only universals.</li>
--   </ol>
--   
--   Pattern synonym types interact with TH when (a) reifying a pattern
--   synonym, (b) pretty printing, or (c) specifying a pattern synonym's
--   type signature explicitly:
--   
--   <ul>
--   <li>Reification always returns a pattern synonym's <i>fully</i>
--   specified type in abstract syntax.</li>
--   <li>Pretty printing via <a>pprPatSynType</a> abbreviates a pattern
--   synonym's type unambiguously in concrete syntax: The rule of thumb is
--   to print initial empty universals and the required context as <tt>()
--   =&gt;</tt>, if existentials and a provided context follow. If only
--   universals and their required context, but no existentials are
--   specified, only the universals and their required context are printed.
--   If both or none are specified, so both (or none) are printed.</li>
--   <li>When specifying a pattern synonym's type explicitly with
--   <a>PatSynSigD</a> either one of the universals, the existentials, or
--   their contexts may be left empty.</li>
--   </ul>
--   
--   See the GHC user's guide for more information on pattern synonyms and
--   their types:
--   <a>https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-synonyms</a>.
type PatSynType = Type

-- | Phase control syntax.
data Phases

-- | The default when unspecified
AllPhases :: Phases

-- | <pre>
--   [n]
--   </pre>
FromPhase :: Int -> Phases

-- | <pre>
--   [~n]
--   </pre>
BeforePhase :: Int -> Phases

-- | The name of a package.
newtype PkgName
PkgName :: String -> PkgName
data Pragma

-- | <tt>{ {-# [inline] [rule match] [phases] [phases] name #-} }</tt>. See
--   <a>Inline</a> and <a>RuleMatch</a>.
InlineP :: Name -> Inline -> RuleMatch -> Phases -> Pragma

-- | <pre>
--   { {-# OPAQUE T #-} }
--   </pre>
OpaqueP :: Name -> Pragma

-- | <pre>
--   { {-# SPECIALISE [INLINE] [phases] T #-} }
--   </pre>
SpecialiseP :: Name -> Type -> Maybe Inline -> Phases -> Pragma

-- | <pre>
--   { {-# SPECIALISE instance I #-} }
--   </pre>
SpecialiseInstP :: Type -> Pragma

-- | <pre>
--   { {-# RULES "name" [phases] [forall t_1 ... t_i]. [forall b_1 ... b_j] rules... e_1 = e_2 #-} }
--   </pre>
RuleP :: String -> Maybe [TyVarBndr ()] -> [RuleBndr] -> Exp -> Exp -> Phases -> Pragma

-- | <pre>
--   { {-# ANN target exp #-} }
--   </pre>
AnnP :: AnnTarget -> Exp -> Pragma

-- | <pre>
--   { {-# LINE n "file name" #-} }
--   </pre>
LineP :: Int -> String -> Pragma

-- | <pre>
--   { {-# COMPLETE C_1, ..., C_i [ :: T ] #-} }
--   </pre>
CompleteP :: [Name] -> Maybe Name -> Pragma

-- | <pre>
--   { {-# SCC fun "optional_name" #-} }
--   </pre>
SCCP :: Name -> Maybe String -> Pragma

-- | Since the advent of <tt>ConstraintKinds</tt>, constraints are really
--   just types. Equality constraints use the <a>EqualityT</a> constructor.
--   Constraints may also be tuples of other constraints.
type Pred = Type

-- | In short, <a>Q</a> provides the <a>Quasi</a> operations in one neat
--   monad for the user.
--   
--   The longer story, is that <a>Q</a> wraps an arbitrary
--   <a>Quasi</a>-able monad. The perceptive reader notices that
--   <a>Quasi</a> has only two instances, <a>Q</a> itself and <a>IO</a>,
--   neither of which have concrete implementations.<a>Q</a> plays the
--   trick of <a>dependency inversion</a>, providing an abstract interface
--   for the user which is later concretely fufilled by an concrete
--   <a>Quasi</a> instance, internal to GHC.
newtype Q a
Q :: (forall (m :: Type -> Type). Quasi m => m a) -> Q a
[unQ] :: Q a -> forall (m :: Type -> Type). Quasi m => m a
class (MonadIO m, MonadFail m) => Quasi (m :: Type -> Type)

-- | Fresh names. See <a>newName</a>.
qNewName :: Quasi m => String -> m Name

-- | Report an error (True) or warning (False) ...but carry on; use
--   <a>fail</a> to stop. See <a>report</a>.
qReport :: Quasi m => Bool -> String -> m ()

-- | See <a>recover</a>.
qRecover :: Quasi m => m a -> m a -> m a

-- | True <a>=</a> type namespace, False <a>=</a> value namespace. See
--   <a>lookupName</a>.
qLookupName :: Quasi m => Bool -> String -> m (Maybe Name)

-- | See <a>reify</a>.
qReify :: Quasi m => Name -> m Info

-- | See <a>reifyFixity</a>.
qReifyFixity :: Quasi m => Name -> m (Maybe Fixity)

-- | See <a>reifyType</a>.
qReifyType :: Quasi m => Name -> m Type

-- | Is (n tys) an instance? Returns list of matching instance Decs (with
--   empty sub-Decs) Works for classes and type functions. See
--   <a>reifyInstances</a>.
qReifyInstances :: Quasi m => Name -> [Type] -> m [Dec]

-- | See <a>reifyRoles</a>.
qReifyRoles :: Quasi m => Name -> m [Role]

-- | See <a>reifyAnnotations</a>.
qReifyAnnotations :: (Quasi m, Data a) => AnnLookup -> m [a]

-- | See <a>reifyModule</a>.
qReifyModule :: Quasi m => Module -> m ModuleInfo

-- | See <a>reifyConStrictness</a>.
qReifyConStrictness :: Quasi m => Name -> m [DecidedStrictness]

-- | See <a>location</a>.
qLocation :: Quasi m => m Loc

-- | Input/output (dangerous). See <a>runIO</a>.
qRunIO :: Quasi m => IO a -> m a

-- | See <a>getPackageRoot</a>.
qGetPackageRoot :: Quasi m => m FilePath

-- | See <a>addDependentFile</a>.
qAddDependentFile :: Quasi m => FilePath -> m ()

-- | See <a>addTempFile</a>.
qAddTempFile :: Quasi m => String -> m FilePath

-- | See <a>addTopDecls</a>.
qAddTopDecls :: Quasi m => [Dec] -> m ()

-- | See <a>addForeignFilePath</a>.
qAddForeignFilePath :: Quasi m => ForeignSrcLang -> String -> m ()

-- | See <a>addModFinalizer</a>.
qAddModFinalizer :: Quasi m => Q () -> m ()

-- | See <a>addCorePlugin</a>.
qAddCorePlugin :: Quasi m => String -> m ()

-- | See <a>getQ</a>.
qGetQ :: (Quasi m, Typeable a) => m (Maybe a)

-- | See <a>putQ</a>.
qPutQ :: (Quasi m, Typeable a) => a -> m ()

-- | See <a>isExtEnabled</a>.
qIsExtEnabled :: Quasi m => Extension -> m Bool

-- | See <a>extsEnabled</a>.
qExtsEnabled :: Quasi m => m [Extension]

-- | See <a>putDoc</a>.
qPutDoc :: Quasi m => DocLoc -> String -> m ()

-- | See <a>getDoc</a>.
qGetDoc :: Quasi m => DocLoc -> m (Maybe String)

-- | The <a>Quote</a> class implements the minimal interface which is
--   necessary for desugaring quotations.
--   
--   <ul>
--   <li>The <tt>Monad m</tt> superclass is needed to stitch together the
--   different AST fragments.</li>
--   <li><a>newName</a> is used when desugaring binding structures such as
--   lambdas to generate fresh names.</li>
--   </ul>
--   
--   Therefore the type of an untyped quotation in GHC is `Quote m =&gt; m
--   Exp`
--   
--   For many years the type of a quotation was fixed to be `Q Exp` but by
--   more precisely specifying the minimal interface it enables the
--   <a>Exp</a> to be extracted purely from the quotation without
--   interacting with <a>Q</a>.
class Monad m => Quote (m :: Type -> Type)

-- | Generate a fresh name, which cannot be captured.
--   
--   For example, this:
--   
--   <pre>
--   f = $(do
--       nm1 &lt;- newName "x"
--       let nm2 = <a>mkName</a> "x"
--       return (<a>LamE</a> [<a>VarP</a> nm1] (LamE [VarP nm2] (<a>VarE</a> nm1)))
--      )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   f = \x0 -&gt; \x -&gt; x0
--   </pre>
--   
--   In particular, the occurrence <tt>VarE nm1</tt> refers to the binding
--   <tt>VarP nm1</tt>, and is not captured by the binding <tt>VarP
--   nm2</tt>.
--   
--   Although names generated by <tt>newName</tt> cannot <i>be
--   captured</i>, they can <i>capture</i> other names. For example, this:
--   
--   <pre>
--   g = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = mkName "x"
--     return (LamE [VarP nm2] (LamE [VarP nm1] (VarE nm2)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   g = \x -&gt; \x0 -&gt; x0
--   </pre>
--   
--   since the occurrence <tt>VarE nm2</tt> is captured by the innermost
--   binding of <tt>x</tt>, namely <tt>VarP nm1</tt>.
newName :: Quote m => String -> m Name

-- | A list/enum range expression.
data Range

-- | <pre>
--   [n ..]
--   </pre>
FromR :: Exp -> Range

-- | <pre>
--   [n, m ..]
--   </pre>
FromThenR :: Exp -> Exp -> Range

-- | <pre>
--   [n .. m]
--   </pre>
FromToR :: Exp -> Exp -> Range

-- | <pre>
--   [n, m .. k]
--   </pre>
FromThenToR :: Exp -> Exp -> Exp -> Range

-- | Role annotations
data Role

-- | <pre>
--   nominal
--   </pre>
NominalR :: Role

-- | <pre>
--   representational
--   </pre>
RepresentationalR :: Role

-- | <pre>
--   phantom
--   </pre>
PhantomR :: Role

-- | <pre>
--   _
--   </pre>
InferR :: Role

-- | A binder found in the <tt>forall</tt> of a <tt>RULES</tt> pragma.
data RuleBndr

-- | <pre>
--   forall {a} ... .
--   </pre>
RuleVar :: Name -> RuleBndr

-- | <pre>
--   forall {(a :: t)} ... .
--   </pre>
TypedRuleVar :: Name -> Type -> RuleBndr

-- | A <tt>CONLIKE</tt> modifier, as in one of the various inline pragmas,
--   or lack thereof (<a>FunLike</a>).
data RuleMatch

-- | <pre>
--   { {-# CONLIKE [inline] ... #-} }
--   </pre>
ConLike :: RuleMatch

-- | <pre>
--   { {-# [inline] ... #-} }
--   </pre>
FunLike :: RuleMatch

-- | A safety level, as in a <a>Foreign</a> declaration.
data Safety
Unsafe :: Safety
Safe :: Safety
Interruptible :: Safety

-- | <a>SourceStrictness</a> corresponds to strictness annotations found in
--   the source code.
--   
--   This may not agree with the annotations returned by
--   <a>reifyConStrictness</a>. See <a>reifyConStrictness</a> for more
--   information.
data SourceStrictness

-- | <pre>
--   C a
--   </pre>
NoSourceStrictness :: SourceStrictness

-- | <pre>
--   C {~}a
--   </pre>
SourceLazy :: SourceStrictness

-- | <pre>
--   C {!}a
--   </pre>
SourceStrict :: SourceStrictness

-- | <a>SourceUnpackedness</a> corresponds to unpack annotations found in
--   the source code.
--   
--   This may not agree with the annotations returned by
--   <a>reifyConStrictness</a>. See <a>reifyConStrictness</a> for more
--   information.
data SourceUnpackedness

-- | <pre>
--   C a
--   </pre>
NoSourceUnpackedness :: SourceUnpackedness

-- | <pre>
--   C { {-# NOUNPACK #-} } a
--   </pre>
SourceNoUnpack :: SourceUnpackedness

-- | <pre>
--   C { {-# UNPACK #-} } a
--   </pre>
SourceUnpack :: SourceUnpackedness

-- | The specificity of a type variable in a <tt>forall ...</tt>.
data Specificity

-- | <pre>
--   a
--   </pre>
SpecifiedSpec :: Specificity

-- | <pre>
--   {a}
--   </pre>
InferredSpec :: Specificity

-- | A single statement, as in <tt>do</tt>-notation.
data Stmt

-- | <pre>
--   p &lt;- e
--   </pre>
BindS :: Pat -> Exp -> Stmt

-- | <pre>
--   { let { x=e1; y=e2 } }
--   </pre>
LetS :: [Dec] -> Stmt

-- | <pre>
--   e
--   </pre>
NoBindS :: Exp -> Stmt

-- | <tt>x &lt;- e1 | s2, s3 | s4</tt> (in <a>CompE</a>)
ParS :: [[Stmt]] -> Stmt

-- | <pre>
--   rec { s1; s2 }
--   </pre>
RecS :: [Stmt] -> Stmt

-- | As of <tt>template-haskell-2.11.0.0</tt>, <a>Strict</a> has been
--   replaced by <a>Bang</a>.
type Strict = Bang

-- | As of <tt>template-haskell-2.11.0.0</tt>, <a>StrictType</a> has been
--   replaced by <a>BangType</a>.
type StrictType = BangType

-- | In <a>UnboxedSumE</a> and <a>UnboxedSumP</a>, the number associated
--   with a particular data constructor. <a>SumAlt</a>s are one-indexed and
--   should never exceed the value of its corresponding <a>SumArity</a>.
--   For example:
--   
--   <ul>
--   <li><tt>(#_|#)</tt> has <a>SumAlt</a> 1 (out of a total
--   <a>SumArity</a> of 2)</li>
--   <li><tt>(#|_#)</tt> has <a>SumAlt</a> 2 (out of a total
--   <a>SumArity</a> of 2)</li>
--   </ul>
type SumAlt = Int

-- | In <a>UnboxedSumE</a>, <a>UnboxedSumT</a>, and <a>UnboxedSumP</a>, the
--   total number of <a>SumAlt</a>s. For example, <tt>(#|#)</tt> has a
--   <a>SumArity</a> of 2.
type SumArity = Int

-- | Typed wrapper around an <a>Exp</a>.
--   
--   This is the typed representation of terms produced by typed quotes.
--   
--   Representation-polymorphic since <i>template-haskell-2.16.0.0</i>.
newtype TExp (a :: TYPE r)
TExp :: Exp -> TExp (a :: TYPE r)

-- | Underlying untyped Template Haskell expression
[unType] :: TExp (a :: TYPE r) -> Exp

-- | Type-level literals.
data TyLit

-- | <pre>
--   2
--   </pre>
NumTyLit :: Integer -> TyLit

-- | <pre>
--   "Hello"
--   </pre>
StrTyLit :: String -> TyLit

-- | <tt>'C'</tt>, @since 4.16.0.0
CharTyLit :: Char -> TyLit

-- | One equation of a type family instance or closed type family. The
--   arguments are the left-hand-side type and the right-hand-side result.
--   
--   For instance, if you had the following type family:
--   
--   <pre>
--   type family Foo (a :: k) :: k where
--     forall k (a :: k). Foo @k a = a
--   </pre>
--   
--   The <tt>Foo @k a = a</tt> equation would be represented as follows:
--   
--   <pre>
--   <a>TySynEqn</a> (<a>Just</a> [<a>PlainTV</a> k, <a>KindedTV</a> a (<a>VarT</a> k)])
--              (<a>AppT</a> (<a>AppKindT</a> (<a>ConT</a> ''Foo) (<a>VarT</a> k)) (<a>VarT</a> a))
--              (<a>VarT</a> a)
--   </pre>
data TySynEqn
TySynEqn :: Maybe [TyVarBndr ()] -> Type -> Type -> TySynEqn

-- | The <tt>flag</tt> type parameter is instantiated to one of the
--   following types:
--   
--   <ul>
--   <li><a>Specificity</a> (examples: <a>ForallC</a>, <a>ForallT</a>)</li>
--   <li><a>BndrVis</a> (examples: <a>DataD</a>, <a>ClassD</a>, etc.)</li>
--   <li><tt>()</tt>, a catch-all type for other forms of binders,
--   including <a>ForallVisT</a>, <a>DataInstD</a>, <a>RuleP</a>, and
--   <a>TyVarSig</a></li>
--   </ul>
data TyVarBndr flag

-- | <pre>
--   a
--   </pre>
PlainTV :: Name -> flag -> TyVarBndr flag

-- | <pre>
--   (a :: k)
--   </pre>
KindedTV :: Name -> flag -> Kind -> TyVarBndr flag

-- | A Haskell type.
data Type

-- | <pre>
--   forall &lt;vars&gt;. &lt;ctxt&gt; =&gt; &lt;type&gt;
--   </pre>
ForallT :: [TyVarBndr Specificity] -> Cxt -> Type -> Type

-- | <pre>
--   forall &lt;vars&gt; -&gt; &lt;type&gt;
--   </pre>
ForallVisT :: [TyVarBndr ()] -> Type -> Type

-- | <pre>
--   T a b
--   </pre>
AppT :: Type -> Type -> Type

-- | <pre>
--   T @k t
--   </pre>
AppKindT :: Type -> Kind -> Type

-- | <pre>
--   t :: k
--   </pre>
SigT :: Type -> Kind -> Type

-- | <pre>
--   a
--   </pre>
VarT :: Name -> Type

-- | <pre>
--   T
--   </pre>
ConT :: Name -> Type

-- | <pre>
--   'T
--   </pre>
PromotedT :: Name -> Type

-- | <pre>
--   T + T
--   </pre>
InfixT :: Type -> Name -> Type -> Type

-- | <pre>
--   T + T
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixT :: Type -> Name -> Type -> Type

-- | <pre>
--   T :+: T
--   </pre>
PromotedInfixT :: Type -> Name -> Type -> Type

-- | <pre>
--   T :+: T
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
PromotedUInfixT :: Type -> Name -> Type -> Type

-- | <pre>
--   (T)
--   </pre>
ParensT :: Type -> Type

-- | <tt>(,)</tt>, <tt>(,,)</tt>, etc.
TupleT :: Int -> Type

-- | <tt>(#,#)</tt>, <tt>(#,,#)</tt>, etc.
UnboxedTupleT :: Int -> Type

-- | <tt>(#|#)</tt>, <tt>(#||#)</tt>, etc.
UnboxedSumT :: SumArity -> Type

-- | <pre>
--   -&gt;
--   </pre>
ArrowT :: Type

-- | <pre>
--   %n -&gt;
--   </pre>
--   
--   Generalised arrow type with multiplicity argument
MulArrowT :: Type

-- | <pre>
--   ~
--   </pre>
EqualityT :: Type

-- | <pre>
--   []
--   </pre>
ListT :: Type

-- | <tt>'()</tt>, <tt>'(,)</tt>, <tt>'(,,)</tt>, etc.
PromotedTupleT :: Int -> Type

-- | <pre>
--   '[]
--   </pre>
PromotedNilT :: Type

-- | <pre>
--   '(:)
--   </pre>
PromotedConsT :: Type

-- | <pre>
--   *
--   </pre>
StarT :: Type

-- | <pre>
--   Constraint
--   </pre>
ConstraintT :: Type

-- | <tt>0</tt>, <tt>1</tt>, <tt>2</tt>, etc.
LitT :: TyLit -> Type

-- | <pre>
--   _
--   </pre>
WildCardT :: Type

-- | <pre>
--   ?x :: t
--   </pre>
ImplicitParamT :: String -> Type -> Type

-- | Common elements of <a>OpenTypeFamilyD</a> and
--   <a>ClosedTypeFamilyD</a>. By analogy with "head" for type classes and
--   type class instances as defined in <i>Type classes: an exploration of
--   the design space</i>, the <tt>TypeFamilyHead</tt> is defined to be the
--   elements of the declaration between <tt>type family</tt> and
--   <tt>where</tt>.
data TypeFamilyHead
TypeFamilyHead :: Name -> [TyVarBndr BndrVis] -> FamilyResultSig -> Maybe InjectivityAnn -> TypeFamilyHead

-- | <tt>Uniq</tt> is used by GHC to distinguish names from each other.
type Uniq = Integer

-- | In <a>PrimTyConI</a>, is the type constructor unlifted?
type Unlifted = Bool

-- | <a>BangType</a>, but for record fields. See <a>Con</a>.
type VarBangType = (Name, Bang, Type)

-- | As of <tt>template-haskell-2.11.0.0</tt>, <a>VarStrictType</a> has
--   been replaced by <a>VarBangType</a>.
type VarStrictType = VarBangType

-- | Foreign formats supported by GHC via TH
data ForeignSrcLang

-- | C
LangC :: ForeignSrcLang

-- | C++
LangCxx :: ForeignSrcLang

-- | Objective C
LangObjc :: ForeignSrcLang

-- | Objective C++
LangObjcxx :: ForeignSrcLang

-- | Assembly language (.s)
LangAsm :: ForeignSrcLang

-- | JavaScript
LangJs :: ForeignSrcLang

-- | Object (.o)
RawObject :: ForeignSrcLang
instance GHC.Internal.Base.Applicative GHC.Internal.TH.Syntax.Q
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.AnnLookup
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.AnnTarget
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Bang
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.BndrVis
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Body
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Bytes
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Callconv
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Clause
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Con
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Dec
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.DecidedStrictness
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.DerivClause
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.DerivStrategy
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.DocLoc
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Exp
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.FamilyResultSig
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Fixity
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.FixityDirection
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Foreign
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.FunDep
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Guard
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Info
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.InjectivityAnn
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Inline
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Lit
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Loc
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Match
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.ModName
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Module
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.ModuleInfo
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Name
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.NameFlavour
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.NameSpace
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.NamespaceSpecifier
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.OccName
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Overlap
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Pat
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.PatSynArgs
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.PatSynDir
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Phases
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.PkgName
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Pragma
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Range
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Role
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.RuleBndr
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.RuleMatch
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Safety
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.SourceStrictness
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.SourceUnpackedness
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Specificity
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Stmt
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.TyLit
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.TySynEqn
instance GHC.Internal.Data.Data.Data flag => GHC.Internal.Data.Data.Data (GHC.Internal.TH.Syntax.TyVarBndr flag)
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.Type
instance GHC.Internal.Data.Data.Data GHC.Internal.TH.Syntax.TypeFamilyHead
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.AnnLookup
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.AnnTarget
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Bang
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.BndrVis
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Body
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Bytes
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Callconv
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Clause
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Con
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Dec
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.DecidedStrictness
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.DerivClause
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.DerivStrategy
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.DocLoc
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Exp
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.FamilyResultSig
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Fixity
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.FixityDirection
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Foreign
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.FunDep
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Guard
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Info
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.InjectivityAnn
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Inline
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Lit
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Loc
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Match
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.ModName
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Module
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.ModuleInfo
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Name
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.NameFlavour
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.NameSpace
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.NamespaceSpecifier
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.OccName
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Overlap
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Pat
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.PatSynArgs
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.PatSynDir
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Phases
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.PkgName
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Pragma
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Range
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Role
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.RuleBndr
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.RuleMatch
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Safety
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.SourceStrictness
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.SourceUnpackedness
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Specificity
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Stmt
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.TyLit
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.TySynEqn
instance GHC.Classes.Eq flag => GHC.Classes.Eq (GHC.Internal.TH.Syntax.TyVarBndr flag)
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.Type
instance GHC.Classes.Eq GHC.Internal.TH.Syntax.TypeFamilyHead
instance GHC.Internal.Data.Foldable.Foldable GHC.Internal.TH.Syntax.TyVarBndr
instance GHC.Internal.Base.Functor GHC.Internal.TH.Syntax.Q
instance GHC.Internal.Base.Functor GHC.Internal.TH.Syntax.TyVarBndr
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.AnnLookup
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.AnnTarget
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Bang
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.BndrVis
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Body
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Bytes
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Callconv
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Clause
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Con
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Dec
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.DecidedStrictness
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.DerivClause
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.DerivStrategy
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.DocLoc
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Exp
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.FamilyResultSig
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Fixity
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.FixityDirection
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Foreign
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.FunDep
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Guard
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Info
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.InjectivityAnn
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Inline
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Lit
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Loc
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Match
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.ModName
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Module
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.ModuleInfo
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Name
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.NameFlavour
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.NameSpace
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.NamespaceSpecifier
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.OccName
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Overlap
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Pat
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.PatSynArgs
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.PatSynDir
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Phases
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.PkgName
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Pragma
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Range
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Role
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.RuleBndr
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.RuleMatch
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Safety
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.SourceStrictness
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.SourceUnpackedness
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Specificity
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Stmt
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.TyLit
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.TySynEqn
instance GHC.Internal.Generics.Generic (GHC.Internal.TH.Syntax.TyVarBndr flag)
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.Type
instance GHC.Internal.Generics.Generic GHC.Internal.TH.Syntax.TypeFamilyHead
instance GHC.Internal.Control.Monad.Fail.MonadFail GHC.Internal.TH.Syntax.Q
instance GHC.Internal.Control.Monad.Fix.MonadFix GHC.Internal.TH.Syntax.Q
instance GHC.Internal.Control.Monad.IO.Class.MonadIO GHC.Internal.TH.Syntax.Q
instance GHC.Internal.Base.Monad GHC.Internal.TH.Syntax.Q
instance GHC.Internal.Base.Monoid a => GHC.Internal.Base.Monoid (GHC.Internal.TH.Syntax.Q a)
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.AnnLookup
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.AnnTarget
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Bang
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.BndrVis
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Body
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Bytes
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Callconv
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Clause
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Con
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Dec
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.DecidedStrictness
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.DerivClause
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.DerivStrategy
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.DocLoc
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Exp
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.FamilyResultSig
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Fixity
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.FixityDirection
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Foreign
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.FunDep
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Guard
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Info
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.InjectivityAnn
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Inline
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Lit
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Loc
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Match
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.ModName
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Module
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.ModuleInfo
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Name
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.NameFlavour
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.NameSpace
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.NamespaceSpecifier
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.OccName
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Overlap
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Pat
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.PatSynArgs
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.PatSynDir
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Phases
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.PkgName
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Pragma
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Range
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Role
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.RuleBndr
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.RuleMatch
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Safety
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.SourceStrictness
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.SourceUnpackedness
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Specificity
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Stmt
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.TyLit
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.TySynEqn
instance GHC.Classes.Ord flag => GHC.Classes.Ord (GHC.Internal.TH.Syntax.TyVarBndr flag)
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.Type
instance GHC.Classes.Ord GHC.Internal.TH.Syntax.TypeFamilyHead
instance GHC.Internal.TH.Syntax.Quasi GHC.Types.IO
instance GHC.Internal.TH.Syntax.Quasi GHC.Internal.TH.Syntax.Q
instance GHC.Internal.TH.Syntax.Quote GHC.Types.IO
instance GHC.Internal.TH.Syntax.Quote GHC.Internal.TH.Syntax.Q
instance GHC.Internal.Base.Semigroup a => GHC.Internal.Base.Semigroup (GHC.Internal.TH.Syntax.Q a)
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.AnnLookup
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.AnnTarget
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Bang
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.BndrVis
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Body
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Bytes
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Callconv
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Clause
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Con
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Dec
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.DecidedStrictness
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.DerivClause
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.DerivStrategy
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.DocLoc
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Exp
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.FamilyResultSig
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Fixity
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.FixityDirection
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Foreign
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.FunDep
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Guard
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Info
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.InjectivityAnn
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Inline
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Lit
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Loc
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Match
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.ModName
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Module
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.ModuleInfo
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Name
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.NameFlavour
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.NameSpace
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.NamespaceSpecifier
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.OccName
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Overlap
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Pat
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.PatSynArgs
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.PatSynDir
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Phases
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.PkgName
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Pragma
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Range
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Role
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.RuleBndr
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.RuleMatch
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Safety
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.SourceStrictness
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.SourceUnpackedness
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Specificity
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Stmt
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.TyLit
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.TySynEqn
instance GHC.Internal.Show.Show flag => GHC.Internal.Show.Show (GHC.Internal.TH.Syntax.TyVarBndr flag)
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.Type
instance GHC.Internal.Show.Show GHC.Internal.TH.Syntax.TypeFamilyHead
instance GHC.Internal.Data.Traversable.Traversable GHC.Internal.TH.Syntax.TyVarBndr


-- | Template Haskell supports quasiquoting, which permits users to
--   construct program fragments by directly writing concrete syntax. A
--   quasiquoter is essentially a function with takes a string to a
--   Template Haskell AST. This module defines the <a>QuasiQuoter</a>
--   datatype, which specifies a quasiquoter <tt>q</tt> which can be
--   invoked using the syntax <tt>[q| ... string to parse ... |]</tt> when
--   the <tt>QuasiQuotes</tt> language extension is enabled, and some
--   utility functions for manipulating quasiquoters. Nota bene: this
--   package does not define any parsers, that is up to you.
--   
--   This is an internal module. Please import <a>Quote</a> instead.
module GHC.Internal.TH.Quote

-- | The <a>QuasiQuoter</a> type, a value <tt>q</tt> of this type can be
--   used in the syntax <tt>[q| ... string to parse ...|]</tt>. In fact,
--   for convenience, a <a>QuasiQuoter</a> actually defines multiple
--   quasiquoters to be used in different splice contexts; if you are only
--   interested in defining a quasiquoter to be used for expressions, you
--   would define a <a>QuasiQuoter</a> with only <a>quoteExp</a>, and leave
--   the other fields stubbed out with errors.
data QuasiQuoter
QuasiQuoter :: (String -> Q Exp) -> (String -> Q Pat) -> (String -> Q Type) -> (String -> Q [Dec]) -> QuasiQuoter

-- | Quasi-quoter for expressions, invoked by quotes like <tt>lhs =
--   $[q|...]</tt>
[quoteExp] :: QuasiQuoter -> String -> Q Exp

-- | Quasi-quoter for patterns, invoked by quotes like <tt>f $[q|...] =
--   rhs</tt>
[quotePat] :: QuasiQuoter -> String -> Q Pat

-- | Quasi-quoter for types, invoked by quotes like <tt>f :: $[q|...]</tt>
[quoteType] :: QuasiQuoter -> String -> Q Type

-- | Quasi-quoter for declarations, invoked by top-level quotes
[quoteDec] :: QuasiQuoter -> String -> Q [Dec]


-- | GHC.Internal.TH.Lib exposes some additional functionality that is used
--   internally in GHC's integration with Template Haskell. This is not a
--   part of the public API, and as such, there are no API guarantees for
--   this module from version to version.
module GHC.Internal.TH.Lib

-- | Representation-polymorphic since <i>template-haskell-2.17.0.0</i>.
type TExpQ (a :: TYPE r) = Q TExp a
type CodeQ = Code Q
type InfoQ = Q Info
type PatQ = Q Pat
type FieldPatQ = Q FieldPat
type ExpQ = Q Exp
type DecQ = Q Dec
type DecsQ = Q [Dec]
type Decs = [Dec]
type ConQ = Q Con
type TypeQ = Q Type
type KindQ = Q Kind
type TyLitQ = Q TyLit
type CxtQ = Q Cxt
type PredQ = Q Pred
type DerivClauseQ = Q DerivClause
type MatchQ = Q Match
type ClauseQ = Q Clause
type BodyQ = Q Body
type GuardQ = Q Guard
type StmtQ = Q Stmt
type RangeQ = Q Range
type SourceStrictnessQ = Q SourceStrictness
type SourceUnpackednessQ = Q SourceUnpackedness
type BangQ = Q Bang
type BangTypeQ = Q BangType
type VarBangTypeQ = Q VarBangType
type StrictTypeQ = Q StrictType
type VarStrictTypeQ = Q VarStrictType
type FieldExpQ = Q FieldExp
type RuleBndrQ = Q RuleBndr
type TySynEqnQ = Q TySynEqn
type PatSynDirQ = Q PatSynDir
type PatSynArgsQ = Q PatSynArgs
type FamilyResultSigQ = Q FamilyResultSig
type DerivStrategyQ = Q DerivStrategy
type Role = Role
type InjectivityAnn = InjectivityAnn
type TyVarBndrUnit = TyVarBndr ()
type TyVarBndrSpec = TyVarBndr Specificity
type TyVarBndrVis = TyVarBndr BndrVis
intPrimL :: Integer -> Lit
wordPrimL :: Integer -> Lit
floatPrimL :: Rational -> Lit
doublePrimL :: Rational -> Lit
integerL :: Integer -> Lit
charL :: Char -> Lit
charPrimL :: Char -> Lit
stringL :: String -> Lit
stringPrimL :: [Word8] -> Lit
bytesPrimL :: Bytes -> Lit
rationalL :: Rational -> Lit
litP :: Quote m => Lit -> m Pat
varP :: Quote m => Name -> m Pat
tupP :: Quote m => [m Pat] -> m Pat
unboxedTupP :: Quote m => [m Pat] -> m Pat
unboxedSumP :: Quote m => m Pat -> SumAlt -> SumArity -> m Pat
conP :: Quote m => Name -> [m Type] -> [m Pat] -> m Pat
infixP :: Quote m => m Pat -> Name -> m Pat -> m Pat
uInfixP :: Quote m => m Pat -> Name -> m Pat -> m Pat
parensP :: Quote m => m Pat -> m Pat
tildeP :: Quote m => m Pat -> m Pat
bangP :: Quote m => m Pat -> m Pat
asP :: Quote m => Name -> m Pat -> m Pat
wildP :: Quote m => m Pat
recP :: Quote m => Name -> [m FieldPat] -> m Pat
listP :: Quote m => [m Pat] -> m Pat
sigP :: Quote m => m Pat -> m Type -> m Pat
typeP :: Quote m => m Type -> m Pat
invisP :: Quote m => m Type -> m Pat
viewP :: Quote m => m Exp -> m Pat -> m Pat
orP :: Quote m => NonEmpty (m Pat) -> m Pat
fieldPat :: Quote m => Name -> m Pat -> m FieldPat
bindS :: Quote m => m Pat -> m Exp -> m Stmt
letS :: Quote m => [m Dec] -> m Stmt
noBindS :: Quote m => m Exp -> m Stmt
parS :: Quote m => [[m Stmt]] -> m Stmt
recS :: Quote m => [m Stmt] -> m Stmt
fromR :: Quote m => m Exp -> m Range
fromThenR :: Quote m => m Exp -> m Exp -> m Range
fromToR :: Quote m => m Exp -> m Exp -> m Range
fromThenToR :: Quote m => m Exp -> m Exp -> m Exp -> m Range
normalB :: Quote m => m Exp -> m Body
guardedB :: Quote m => [m (Guard, Exp)] -> m Body
normalG :: Quote m => m Exp -> m Guard
normalGE :: Quote m => m Exp -> m Exp -> m (Guard, Exp)
patG :: Quote m => [m Stmt] -> m Guard
patGE :: Quote m => [m Stmt] -> m Exp -> m (Guard, Exp)

-- | Use with <a>caseE</a>
match :: Quote m => m Pat -> m Body -> [m Dec] -> m Match

-- | Use with <a>funD</a>
clause :: Quote m => [m Pat] -> m Body -> [m Dec] -> m Clause

-- | Dynamically binding a variable (unhygienic)
dyn :: Quote m => String -> m Exp
varE :: Quote m => Name -> m Exp
conE :: Quote m => Name -> m Exp
litE :: Quote m => Lit -> m Exp
appE :: Quote m => m Exp -> m Exp -> m Exp
appTypeE :: Quote m => m Exp -> m Type -> m Exp
parensE :: Quote m => m Exp -> m Exp
uInfixE :: Quote m => m Exp -> m Exp -> m Exp -> m Exp
infixE :: Quote m => Maybe (m Exp) -> m Exp -> Maybe (m Exp) -> m Exp
infixApp :: Quote m => m Exp -> m Exp -> m Exp -> m Exp
sectionL :: Quote m => m Exp -> m Exp -> m Exp
sectionR :: Quote m => m Exp -> m Exp -> m Exp
lamE :: Quote m => [m Pat] -> m Exp -> m Exp

-- | Single-arg lambda
lam1E :: Quote m => m Pat -> m Exp -> m Exp

-- | Lambda-case (<tt>case</tt>)
lamCaseE :: Quote m => [m Match] -> m Exp

-- | Lambda-cases (<tt>cases</tt>)
lamCasesE :: Quote m => [m Clause] -> m Exp
tupE :: Quote m => [Maybe (m Exp)] -> m Exp
unboxedTupE :: Quote m => [Maybe (m Exp)] -> m Exp
unboxedSumE :: Quote m => m Exp -> SumAlt -> SumArity -> m Exp
condE :: Quote m => m Exp -> m Exp -> m Exp -> m Exp
multiIfE :: Quote m => [m (Guard, Exp)] -> m Exp
letE :: Quote m => [m Dec] -> m Exp -> m Exp
caseE :: Quote m => m Exp -> [m Match] -> m Exp
doE :: Quote m => Maybe ModName -> [m Stmt] -> m Exp
mdoE :: Quote m => Maybe ModName -> [m Stmt] -> m Exp
compE :: Quote m => [m Stmt] -> m Exp
arithSeqE :: Quote m => m Range -> m Exp
listE :: Quote m => [m Exp] -> m Exp
sigE :: Quote m => m Exp -> m Type -> m Exp
recConE :: Quote m => Name -> [m (Name, Exp)] -> m Exp
recUpdE :: Quote m => m Exp -> [m (Name, Exp)] -> m Exp
stringE :: Quote m => String -> m Exp
fieldExp :: Quote m => Name -> m Exp -> m (Name, Exp)

-- | <pre>
--   staticE x = [| static x |]
--   </pre>
staticE :: Quote m => m Exp -> m Exp
unboundVarE :: Quote m => Name -> m Exp
labelE :: Quote m => String -> m Exp
implicitParamVarE :: Quote m => String -> m Exp
getFieldE :: Quote m => m Exp -> String -> m Exp
projectionE :: Quote m => NonEmpty String -> m Exp
typedSpliceE :: Quote m => m Exp -> m Exp
typedBracketE :: Quote m => m Exp -> m Exp
fromE :: Quote m => m Exp -> m Exp
fromThenE :: Quote m => m Exp -> m Exp -> m Exp
fromToE :: Quote m => m Exp -> m Exp -> m Exp
fromThenToE :: Quote m => m Exp -> m Exp -> m Exp -> m Exp
typeE :: Quote m => m Type -> m Exp
forallE :: Quote m => [m (TyVarBndr Specificity)] -> m Exp -> m Exp
forallVisE :: Quote m => [m (TyVarBndr ())] -> m Exp -> m Exp
constrainedE :: Quote m => [m Exp] -> m Exp -> m Exp
valD :: Quote m => m Pat -> m Body -> [m Dec] -> m Dec
funD :: Quote m => Name -> [m Clause] -> m Dec
tySynD :: Quote m => Name -> [m (TyVarBndr BndrVis)] -> m Type -> m Dec
dataD :: Quote m => m Cxt -> Name -> [m (TyVarBndr BndrVis)] -> Maybe (m Kind) -> [m Con] -> [m DerivClause] -> m Dec
newtypeD :: Quote m => m Cxt -> Name -> [m (TyVarBndr BndrVis)] -> Maybe (m Kind) -> m Con -> [m DerivClause] -> m Dec
typeDataD :: Quote m => Name -> [m (TyVarBndr BndrVis)] -> Maybe (m Kind) -> [m Con] -> m Dec
classD :: Quote m => m Cxt -> Name -> [m (TyVarBndr BndrVis)] -> [FunDep] -> [m Dec] -> m Dec
instanceD :: Quote m => m Cxt -> m Type -> [m Dec] -> m Dec
instanceWithOverlapD :: Quote m => Maybe Overlap -> m Cxt -> m Type -> [m Dec] -> m Dec
sigD :: Quote m => Name -> m Type -> m Dec
kiSigD :: Quote m => Name -> m Kind -> m Dec
forImpD :: Quote m => Callconv -> Safety -> String -> Name -> m Type -> m Dec
infixLD :: Quote m => Int -> Name -> m Dec
infixRD :: Quote m => Int -> Name -> m Dec
infixND :: Quote m => Int -> Name -> m Dec
infixLWithSpecD :: Quote m => Int -> NamespaceSpecifier -> Name -> m Dec
infixRWithSpecD :: Quote m => Int -> NamespaceSpecifier -> Name -> m Dec
infixNWithSpecD :: Quote m => Int -> NamespaceSpecifier -> Name -> m Dec
defaultD :: Quote m => [m Type] -> m Dec
pragInlD :: Quote m => Name -> Inline -> RuleMatch -> Phases -> m Dec
pragOpaqueD :: Quote m => Name -> m Dec
pragSpecD :: Quote m => Name -> m Type -> Phases -> m Dec
pragSpecInlD :: Quote m => Name -> m Type -> Inline -> Phases -> m Dec
pragSpecInstD :: Quote m => m Type -> m Dec
pragRuleD :: Quote m => String -> Maybe [m (TyVarBndr ())] -> [m RuleBndr] -> m Exp -> m Exp -> Phases -> m Dec
pragAnnD :: Quote m => AnnTarget -> m Exp -> m Dec
pragLineD :: Quote m => Int -> String -> m Dec
pragCompleteD :: Quote m => [Name] -> Maybe Name -> m Dec
pragSCCFunD :: Quote m => Name -> m Dec
pragSCCFunNamedD :: Quote m => Name -> String -> m Dec
dataInstD :: Quote m => m Cxt -> Maybe [m (TyVarBndr ())] -> m Type -> Maybe (m Kind) -> [m Con] -> [m DerivClause] -> m Dec
newtypeInstD :: Quote m => m Cxt -> Maybe [m (TyVarBndr ())] -> m Type -> Maybe (m Kind) -> m Con -> [m DerivClause] -> m Dec
tySynInstD :: Quote m => m TySynEqn -> m Dec
dataFamilyD :: Quote m => Name -> [m (TyVarBndr BndrVis)] -> Maybe (m Kind) -> m Dec
openTypeFamilyD :: Quote m => Name -> [m (TyVarBndr BndrVis)] -> m FamilyResultSig -> Maybe InjectivityAnn -> m Dec
closedTypeFamilyD :: Quote m => Name -> [m (TyVarBndr BndrVis)] -> m FamilyResultSig -> Maybe InjectivityAnn -> [m TySynEqn] -> m Dec
roleAnnotD :: Quote m => Name -> [Role] -> m Dec
standaloneDerivD :: Quote m => m Cxt -> m Type -> m Dec
standaloneDerivWithStrategyD :: Quote m => Maybe (m DerivStrategy) -> m Cxt -> m Type -> m Dec
defaultSigD :: Quote m => Name -> m Type -> m Dec

-- | Pattern synonym declaration
patSynD :: Quote m => Name -> m PatSynArgs -> m PatSynDir -> m Pat -> m Dec

-- | Pattern synonym type signature
patSynSigD :: Quote m => Name -> m Type -> m Dec

-- | Implicit parameter binding declaration. Can only be used in let and
--   where clauses which consist entirely of implicit bindings.
implicitParamBindD :: Quote m => String -> m Exp -> m Dec
tySynEqn :: Quote m => Maybe [m (TyVarBndr ())] -> m Type -> m Type -> m TySynEqn
cxt :: Quote m => [m Pred] -> m Cxt
derivClause :: Quote m => Maybe (m DerivStrategy) -> [m Pred] -> m DerivClause
stockStrategy :: Quote m => m DerivStrategy
anyclassStrategy :: Quote m => m DerivStrategy
newtypeStrategy :: Quote m => m DerivStrategy
viaStrategy :: Quote m => m Type -> m DerivStrategy
normalC :: Quote m => Name -> [m BangType] -> m Con
recC :: Quote m => Name -> [m VarBangType] -> m Con
infixC :: Quote m => m (Bang, Type) -> Name -> m (Bang, Type) -> m Con
forallC :: Quote m => [m (TyVarBndr Specificity)] -> m Cxt -> m Con -> m Con
gadtC :: Quote m => [Name] -> [m StrictType] -> m Type -> m Con
recGadtC :: Quote m => [Name] -> [m VarStrictType] -> m Type -> m Con
forallT :: Quote m => [m (TyVarBndr Specificity)] -> m Cxt -> m Type -> m Type
forallVisT :: Quote m => [m (TyVarBndr ())] -> m Type -> m Type
varT :: Quote m => Name -> m Type
conT :: Quote m => Name -> m Type
infixT :: Quote m => m Type -> Name -> m Type -> m Type
uInfixT :: Quote m => m Type -> Name -> m Type -> m Type
promotedInfixT :: Quote m => m Type -> Name -> m Type -> m Type
promotedUInfixT :: Quote m => m Type -> Name -> m Type -> m Type
parensT :: Quote m => m Type -> m Type
appT :: Quote m => m Type -> m Type -> m Type
appKindT :: Quote m => m Type -> m Kind -> m Type
arrowT :: Quote m => m Type
mulArrowT :: Quote m => m Type
listT :: Quote m => m Type
litT :: Quote m => m TyLit -> m Type
tupleT :: Quote m => Int -> m Type
unboxedTupleT :: Quote m => Int -> m Type
unboxedSumT :: Quote m => SumArity -> m Type
sigT :: Quote m => m Type -> m Kind -> m Type
equalityT :: Quote m => m Type
wildCardT :: Quote m => m Type
implicitParamT :: Quote m => String -> m Type -> m Type

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   use <a>conT</a> and <a>appT</a>.</i>
classP :: Quote m => Name -> [m Type] -> m Pred

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   see <a>equalityT</a>.</i>
equalP :: Quote m => m Type -> m Type -> m Pred
promotedT :: Quote m => Name -> m Type
promotedTupleT :: Quote m => Int -> m Type
promotedNilT :: Quote m => m Type
promotedConsT :: Quote m => m Type
noSourceUnpackedness :: Quote m => m SourceUnpackedness
sourceNoUnpack :: Quote m => m SourceUnpackedness
sourceUnpack :: Quote m => m SourceUnpackedness
noSourceStrictness :: Quote m => m SourceStrictness
sourceLazy :: Quote m => m SourceStrictness
sourceStrict :: Quote m => m SourceStrictness

-- | <i>Deprecated: Use <a>bang</a>. See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/migration/8.0</a>. Example
--   usage: 'bang noSourceUnpackedness sourceStrict'</i>
isStrict :: Quote m => m Strict

-- | <i>Deprecated: Use <a>bang</a>. See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/migration/8.0</a>. Example
--   usage: 'bang noSourceUnpackedness noSourceStrictness'</i>
notStrict :: Quote m => m Strict

-- | <i>Deprecated: Use <a>bang</a>. See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/migration/8.0</a>. Example
--   usage: 'bang sourceUnpack sourceStrict'</i>
unpacked :: Quote m => m Strict
bang :: Quote m => m SourceUnpackedness -> m SourceStrictness -> m Bang
bangType :: Quote m => m Bang -> m Type -> m BangType
varBangType :: Quote m => Name -> m BangType -> m VarBangType

-- | <i>Deprecated: As of <tt>template-haskell-2.11.0.0</tt>,
--   <a>StrictType</a> has been replaced by <a>BangType</a>. Please use
--   <a>bangType</a> instead.</i>
strictType :: Quote m => m Strict -> m Type -> m StrictType

-- | <i>Deprecated: As of <tt>template-haskell-2.11.0.0</tt>,
--   <a>VarStrictType</a> has been replaced by <a>VarBangType</a>. Please
--   use <a>varBangType</a> instead.</i>
varStrictType :: Quote m => Name -> m StrictType -> m VarStrictType
numTyLit :: Quote m => Integer -> m TyLit
strTyLit :: Quote m => String -> m TyLit
charTyLit :: Quote m => Char -> m TyLit
plainTV :: Quote m => Name -> m (TyVarBndr ())
plainInvisTV :: Quote m => Name -> Specificity -> m (TyVarBndr Specificity)
plainBndrTV :: Quote m => Name -> BndrVis -> m (TyVarBndr BndrVis)
kindedTV :: Quote m => Name -> m Kind -> m (TyVarBndr ())
kindedInvisTV :: Quote m => Name -> Specificity -> m Kind -> m (TyVarBndr Specificity)
kindedBndrTV :: Quote m => Name -> BndrVis -> m Kind -> m (TyVarBndr BndrVis)
specifiedSpec :: Specificity
inferredSpec :: Specificity
bndrReq :: BndrVis
bndrInvis :: BndrVis
varK :: Name -> Kind
conK :: Name -> Kind
tupleK :: Int -> Kind
arrowK :: Kind
listK :: Kind
appK :: Kind -> Kind -> Kind
starK :: Quote m => m Kind
constraintK :: Quote m => m Kind
noSig :: Quote m => m FamilyResultSig
kindSig :: Quote m => m Kind -> m FamilyResultSig
tyVarSig :: Quote m => m (TyVarBndr ()) -> m FamilyResultSig
injectivityAnn :: Name -> [Name] -> InjectivityAnn
nominalR :: Role
representationalR :: Role
phantomR :: Role
inferR :: Role
cCall :: Callconv
stdCall :: Callconv
cApi :: Callconv
prim :: Callconv
javaScript :: Callconv
unsafe :: Safety
safe :: Safety
interruptible :: Safety
funDep :: [Name] -> [Name] -> FunDep
ruleVar :: Quote m => Name -> m RuleBndr
typedRuleVar :: Quote m => Name -> m Type -> m RuleBndr
valueAnnotation :: Name -> AnnTarget
typeAnnotation :: Name -> AnnTarget
moduleAnnotation :: AnnTarget
unidir :: Quote m => m PatSynDir
implBidir :: Quote m => m PatSynDir
explBidir :: Quote m => [m Clause] -> m PatSynDir
prefixPatSyn :: Quote m => [Name] -> m PatSynArgs
recordPatSyn :: Quote m => [Name] -> m PatSynArgs
infixPatSyn :: Quote m => Name -> Name -> m PatSynArgs
appsE :: Quote m => [m Exp] -> m Exp

-- | pure the Module at the place of splicing. Can be used as an input for
--   <a>reifyModule</a>.
thisModule :: Q Module

-- | Attaches Haddock documentation to the declaration provided. Unlike
--   <a>putDoc</a>, the names do not need to be in scope when calling this
--   function so it can be used for quoted declarations and anything else
--   currently being spliced. Not all declarations can have documentation
--   attached to them. For those that can't, <a>withDecDoc</a> will return
--   it unchanged without any side effects.
withDecDoc :: String -> Q Dec -> Q Dec

-- | Variant of <a>withDecDoc</a> that applies the same documentation to
--   multiple declarations. Useful for documenting quoted declarations.
withDecsDoc :: String -> Q [Dec] -> Q [Dec]

-- | Variant of <a>funD</a> that attaches Haddock documentation.
funD_doc :: Name -> [Q Clause] -> Maybe String -> [Maybe String] -> Q Dec

-- | Variant of <a>dataD</a> that attaches Haddock documentation.
dataD_doc :: Q Cxt -> Name -> [Q (TyVarBndr BndrVis)] -> Maybe (Q Kind) -> [(Q Con, Maybe String, [Maybe String])] -> [Q DerivClause] -> Maybe String -> Q Dec

-- | Variant of <a>newtypeD</a> that attaches Haddock documentation.
newtypeD_doc :: Q Cxt -> Name -> [Q (TyVarBndr BndrVis)] -> Maybe (Q Kind) -> (Q Con, Maybe String, [Maybe String]) -> [Q DerivClause] -> Maybe String -> Q Dec

-- | Variant of <a>typeDataD</a> that attaches Haddock documentation.
typeDataD_doc :: Name -> [Q (TyVarBndr BndrVis)] -> Maybe (Q Kind) -> [(Q Con, Maybe String, [Maybe String])] -> Maybe String -> Q Dec

-- | Variant of <a>dataInstD</a> that attaches Haddock documentation.
dataInstD_doc :: Q Cxt -> Maybe [Q (TyVarBndr ())] -> Q Type -> Maybe (Q Kind) -> [(Q Con, Maybe String, [Maybe String])] -> [Q DerivClause] -> Maybe String -> Q Dec

-- | Variant of <a>newtypeInstD</a> that attaches Haddock documentation.
newtypeInstD_doc :: Q Cxt -> Maybe [Q (TyVarBndr ())] -> Q Type -> Maybe (Q Kind) -> (Q Con, Maybe String, [Maybe String]) -> [Q DerivClause] -> Maybe String -> Q Dec

-- | Variant of <a>patSynD</a> that attaches Haddock documentation.
patSynD_doc :: Name -> Q PatSynArgs -> Q PatSynDir -> Q Pat -> Maybe String -> [Maybe String] -> Q Dec

-- | Document a data/newtype constructor with its arguments.
docCons :: (Q Con, Maybe String, [Maybe String]) -> Q ()


-- | This module gives the definition of the <a>Lift</a> class.
--   
--   This is an internal module. Please import <a>Language.Haskell.TH</a>
--   or <a>Language.Haskell.TH.Syntax</a> instead!
module GHC.Internal.TH.Lift

-- | A <a>Lift</a> instance can have any of its values turned into a
--   Template Haskell expression. This is needed when a value used within a
--   Template Haskell quotation is bound outside the Oxford brackets
--   (<tt>[| ... |]</tt> or <tt>[|| ... ||]</tt>) but not at the top level.
--   As an example:
--   
--   <pre>
--   add1 :: Int -&gt; Code Q Int
--   add1 x = [|| x + 1 ||]
--   </pre>
--   
--   Template Haskell has no way of knowing what value <tt>x</tt> will take
--   on at splice-time, so it requires the type of <tt>x</tt> to be an
--   instance of <a>Lift</a>.
--   
--   A <a>Lift</a> instance must satisfy <tt>$(lift x) ≡ x</tt> and
--   <tt>$$(liftTyped x) ≡ x</tt> for all <tt>x</tt>, where <tt>$(...)</tt>
--   and <tt>$$(...)</tt> are Template Haskell splices. It is additionally
--   expected that <tt><a>lift</a> x ≡ <a>unTypeCode</a> (<a>liftTyped</a>
--   x)</tt>.
--   
--   <a>Lift</a> instances can be derived automatically by use of the
--   <tt>-XDeriveLift</tt> GHC language extension:
--   
--   <pre>
--   {-# LANGUAGE DeriveLift #-}
--   module Foo where
--   
--   import Language.Haskell.TH.Syntax
--   
--   data Bar a = Bar1 a (Bar a) | Bar2 String
--     deriving Lift
--   </pre>
--   
--   Representation-polymorphic since <i>template-haskell-2.16.0.0</i>.
class Lift (t :: TYPE r)

-- | Turn a value into a Template Haskell expression, suitable for use in a
--   splice.
lift :: (Lift t, Quote m) => t -> m Exp
($dmlift) :: forall m. (Lift t, r ~ LiftedRep, Quote m) => t -> m Exp

-- | Turn a value into a Template Haskell typed expression, suitable for
--   use in a typed splice.
liftTyped :: forall (m :: Type -> Type). (Lift t, Quote m) => t -> Code m t

-- | <a>dataToQa</a> is an internal utility function for constructing
--   generic conversion functions from types with <a>Data</a> instances to
--   various quasi-quoting representations. See the source of
--   <a>dataToExpQ</a> and <a>dataToPatQ</a> for two example usages:
--   <tt>mkCon</tt>, <tt>mkLit</tt> and <tt>appQ</tt> are overloadable to
--   account for different syntax for expressions and patterns;
--   <tt>antiQ</tt> allows you to override type-specific cases, a common
--   usage is just <tt>const Nothing</tt>, which results in no overloading.
dataToQa :: (Quote m, Data a) => (Name -> k) -> (Lit -> m q) -> (k -> [m q] -> m q) -> (forall b. Data b => b -> Maybe (m q)) -> a -> m q

-- | <a>dataToExpQ</a> converts a value to a <a>Exp</a> representation of
--   the same value, in the SYB style. It is generalized to take a function
--   override type-specific cases; see <a>liftData</a> for a more commonly
--   used variant.
dataToExpQ :: (Quote m, Data a) => (forall b. Data b => b -> Maybe (m Exp)) -> a -> m Exp

-- | <a>liftData</a> is a variant of <a>lift</a> in the <a>Lift</a> type
--   class which works for any type with a <a>Data</a> instance.
liftData :: (Quote m, Data a) => a -> m Exp

-- | <a>dataToPatQ</a> converts a value to a <a>Pat</a> representation of
--   the same value, in the SYB style. It takes a function to handle
--   type-specific cases, alternatively, pass <tt>const Nothing</tt> to get
--   default behavior.
dataToPatQ :: (Quote m, Data a) => (forall b. Data b => b -> Maybe (m Pat)) -> a -> m Pat
liftString :: Quote m => String -> m Exp
trueName :: Name
falseName :: Name
nothingName :: Name
justName :: Name
leftName :: Name
rightName :: Name
nonemptyName :: Name
instance GHC.Internal.TH.Lift.Lift GHC.Prim.Addr#
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.AnnLookup
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.AnnTarget
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Bang
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.BndrVis
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Body
instance GHC.Internal.TH.Lift.Lift GHC.Types.Bool
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Bytes
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Callconv
instance GHC.Internal.TH.Lift.Lift GHC.Types.Char
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Clause
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Con
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Dec
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.DecidedStrictness
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.DerivClause
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.DerivStrategy
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.DocLoc
instance GHC.Internal.TH.Lift.Lift GHC.Types.Double
instance (GHC.Internal.TH.Lift.Lift a, GHC.Internal.TH.Lift.Lift b) => GHC.Internal.TH.Lift.Lift (GHC.Internal.Data.Either.Either a b)
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Exp
instance GHC.Internal.TH.Lift.Lift GHC.Internal.LanguageExtensions.Extension
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.FamilyResultSig
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Fixity
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.FixityDirection
instance GHC.Internal.TH.Lift.Lift GHC.Types.Float
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Foreign
instance GHC.Internal.TH.Lift.Lift GHC.Internal.ForeignSrcLang.ForeignSrcLang
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.FunDep
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Guard
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Info
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.InjectivityAnn
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Inline
instance GHC.Internal.TH.Lift.Lift GHC.Types.Int
instance GHC.Internal.TH.Lift.Lift GHC.Internal.Int.Int16
instance GHC.Internal.TH.Lift.Lift GHC.Internal.Int.Int32
instance GHC.Internal.TH.Lift.Lift GHC.Internal.Int.Int64
instance GHC.Internal.TH.Lift.Lift GHC.Internal.Int.Int8
instance GHC.Internal.TH.Lift.Lift GHC.Num.Integer.Integer
instance GHC.Internal.TH.Lift.Lift a => GHC.Internal.TH.Lift.Lift [a]
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Lit
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Loc
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Match
instance GHC.Internal.TH.Lift.Lift a => GHC.Internal.TH.Lift.Lift (GHC.Internal.Maybe.Maybe a)
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.ModName
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Module
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Name
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.NameFlavour
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.NameIs
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.NameSpace
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.NamespaceSpecifier
instance GHC.Internal.TH.Lift.Lift GHC.Num.Natural.Natural
instance GHC.Internal.TH.Lift.Lift a => GHC.Internal.TH.Lift.Lift (GHC.Internal.Base.NonEmpty a)
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.OccName
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Overlap
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Pat
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.PatSynArgs
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.PatSynDir
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Phases
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.PkgName
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Pragma
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Range
instance GHC.Internal.Real.Integral a => GHC.Internal.TH.Lift.Lift (GHC.Internal.Real.Ratio a)
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Role
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.RuleBndr
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.RuleMatch
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Safety
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.SourceStrictness
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.SourceUnpackedness
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Specificity
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Stmt
instance GHC.Internal.TH.Lift.Lift (GHC.Internal.TH.Syntax.TExp a)
instance (GHC.Internal.TH.Lift.Lift a, GHC.Internal.TH.Lift.Lift b) => GHC.Internal.TH.Lift.Lift (a, b)
instance (GHC.Internal.TH.Lift.Lift a, GHC.Internal.TH.Lift.Lift b, GHC.Internal.TH.Lift.Lift c) => GHC.Internal.TH.Lift.Lift (a, b, c)
instance (GHC.Internal.TH.Lift.Lift a, GHC.Internal.TH.Lift.Lift b, GHC.Internal.TH.Lift.Lift c, GHC.Internal.TH.Lift.Lift d) => GHC.Internal.TH.Lift.Lift (a, b, c, d)
instance (GHC.Internal.TH.Lift.Lift a, GHC.Internal.TH.Lift.Lift b, GHC.Internal.TH.Lift.Lift c, GHC.Internal.TH.Lift.Lift d, GHC.Internal.TH.Lift.Lift e) => GHC.Internal.TH.Lift.Lift (a, b, c, d, e)
instance (GHC.Internal.TH.Lift.Lift a, GHC.Internal.TH.Lift.Lift b, GHC.Internal.TH.Lift.Lift c, GHC.Internal.TH.Lift.Lift d, GHC.Internal.TH.Lift.Lift e, GHC.Internal.TH.Lift.Lift f) => GHC.Internal.TH.Lift.Lift (a, b, c, d, e, f)
instance (GHC.Internal.TH.Lift.Lift a, GHC.Internal.TH.Lift.Lift b, GHC.Internal.TH.Lift.Lift c, GHC.Internal.TH.Lift.Lift d, GHC.Internal.TH.Lift.Lift e, GHC.Internal.TH.Lift.Lift f, GHC.Internal.TH.Lift.Lift g) => GHC.Internal.TH.Lift.Lift (a, b, c, d, e, f, g)
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.TyLit
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.TySynEqn
instance GHC.Internal.TH.Lift.Lift a => GHC.Internal.TH.Lift.Lift (GHC.Internal.TH.Syntax.TyVarBndr a)
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.Type
instance GHC.Internal.TH.Lift.Lift GHC.Internal.TH.Syntax.TypeFamilyHead
instance GHC.Internal.TH.Lift.Lift ()
instance GHC.Internal.TH.Lift.Lift GHC.Internal.Base.Void
instance GHC.Internal.TH.Lift.Lift GHC.Types.Word
instance GHC.Internal.TH.Lift.Lift GHC.Internal.Word.Word16
instance GHC.Internal.TH.Lift.Lift GHC.Internal.Word.Word32
instance GHC.Internal.TH.Lift.Lift GHC.Internal.Word.Word64
instance GHC.Internal.TH.Lift.Lift GHC.Internal.Word.Word8
instance GHC.Internal.TH.Lift.Lift GHC.Prim.Double#
instance GHC.Internal.TH.Lift.Lift GHC.Prim.Float#
instance GHC.Internal.TH.Lift.Lift GHC.Prim.Int#
instance (GHC.Internal.TH.Lift.Lift a, GHC.Internal.TH.Lift.Lift b) => GHC.Internal.TH.Lift.Lift (# a | b #)
instance (GHC.Internal.TH.Lift.Lift a, GHC.Internal.TH.Lift.Lift b, GHC.Internal.TH.Lift.Lift c) => GHC.Internal.TH.Lift.Lift (# a | b | c #)
instance (GHC.Internal.TH.Lift.Lift a, GHC.Internal.TH.Lift.Lift b, GHC.Internal.TH.Lift.Lift c, GHC.Internal.TH.Lift.Lift d) => GHC.Internal.TH.Lift.Lift (# a | b | c | d #)
instance (GHC.Internal.TH.Lift.Lift a, GHC.Internal.TH.Lift.Lift b, GHC.Internal.TH.Lift.Lift c, GHC.Internal.TH.Lift.Lift d, GHC.Internal.TH.Lift.Lift e) => GHC.Internal.TH.Lift.Lift (# a | b | c | d | e #)
instance (GHC.Internal.TH.Lift.Lift a, GHC.Internal.TH.Lift.Lift b, GHC.Internal.TH.Lift.Lift c, GHC.Internal.TH.Lift.Lift d, GHC.Internal.TH.Lift.Lift e, GHC.Internal.TH.Lift.Lift f) => GHC.Internal.TH.Lift.Lift (# a | b | c | d | e | f #)
instance (GHC.Internal.TH.Lift.Lift a, GHC.Internal.TH.Lift.Lift b, GHC.Internal.TH.Lift.Lift c, GHC.Internal.TH.Lift.Lift d, GHC.Internal.TH.Lift.Lift e, GHC.Internal.TH.Lift.Lift f, GHC.Internal.TH.Lift.Lift g) => GHC.Internal.TH.Lift.Lift (# a | b | c | d | e | f | g #)
instance GHC.Internal.TH.Lift.Lift a => GHC.Internal.TH.Lift.Lift (# a #)
instance (GHC.Internal.TH.Lift.Lift a, GHC.Internal.TH.Lift.Lift b) => GHC.Internal.TH.Lift.Lift (# a, b #)
instance (GHC.Internal.TH.Lift.Lift a, GHC.Internal.TH.Lift.Lift b, GHC.Internal.TH.Lift.Lift c) => GHC.Internal.TH.Lift.Lift (# a, b, c #)
instance (GHC.Internal.TH.Lift.Lift a, GHC.Internal.TH.Lift.Lift b, GHC.Internal.TH.Lift.Lift c, GHC.Internal.TH.Lift.Lift d) => GHC.Internal.TH.Lift.Lift (# a, b, c, d #)
instance (GHC.Internal.TH.Lift.Lift a, GHC.Internal.TH.Lift.Lift b, GHC.Internal.TH.Lift.Lift c, GHC.Internal.TH.Lift.Lift d, GHC.Internal.TH.Lift.Lift e) => GHC.Internal.TH.Lift.Lift (# a, b, c, d, e #)
instance (GHC.Internal.TH.Lift.Lift a, GHC.Internal.TH.Lift.Lift b, GHC.Internal.TH.Lift.Lift c, GHC.Internal.TH.Lift.Lift d, GHC.Internal.TH.Lift.Lift e, GHC.Internal.TH.Lift.Lift f) => GHC.Internal.TH.Lift.Lift (# a, b, c, d, e, f #)
instance (GHC.Internal.TH.Lift.Lift a, GHC.Internal.TH.Lift.Lift b, GHC.Internal.TH.Lift.Lift c, GHC.Internal.TH.Lift.Lift d, GHC.Internal.TH.Lift.Lift e, GHC.Internal.TH.Lift.Lift f, GHC.Internal.TH.Lift.Lift g) => GHC.Internal.TH.Lift.Lift (# a, b, c, d, e, f, g #)
instance GHC.Internal.TH.Lift.Lift (# #)
instance GHC.Internal.TH.Lift.Lift GHC.Prim.Char#
instance GHC.Internal.TH.Lift.Lift GHC.Prim.Word#

module GHC.Internal.Functor.ZipList

-- | Lists, but with an <a>Applicative</a> functor based on zipping.
--   
--   <h4><b>Examples</b></h4>
--   
--   In contrast to the <a>Applicative</a> for <a>List</a>:
--   
--   <pre>
--   &gt;&gt;&gt; (+) &lt;$&gt; [1, 2, 3] &lt;*&gt; [4, 5, 6]
--   [5,6,7,6,7,8,7,8,9]
--   </pre>
--   
--   The Applicative instance of ZipList applies the operation by pairing
--   up the elements, analogous to <a>zipWith</a>N
--   
--   <pre>
--   &gt;&gt;&gt; (+) &lt;$&gt; ZipList [1, 2, 3] &lt;*&gt; ZipList [4, 5, 6]
--   ZipList {getZipList = [5,7,9]}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (,,,) &lt;$&gt; ZipList [1, 2] &lt;*&gt; ZipList [3, 4] &lt;*&gt; ZipList [5, 6] &lt;*&gt; ZipList [7, 8]
--   ZipList {getZipList = [(1,3,5,7),(2,4,6,8)]}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ZipList [(+1), (^2), (/ 2)] &lt;*&gt; ZipList [5, 5, 5]
--   ZipList {getZipList = [6.0,25.0,2.5]}
--   </pre>
newtype ZipList a
ZipList :: [a] -> ZipList a
[getZipList] :: ZipList a -> [a]
instance GHC.Internal.Base.Alternative GHC.Internal.Functor.ZipList.ZipList
instance GHC.Internal.Base.Applicative GHC.Internal.Functor.ZipList.ZipList
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (GHC.Internal.Functor.ZipList.ZipList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Internal.Functor.ZipList.ZipList a)
instance GHC.Internal.Data.Foldable.Foldable GHC.Internal.Functor.ZipList.ZipList
instance GHC.Internal.Base.Functor GHC.Internal.Functor.ZipList.ZipList
instance GHC.Internal.Generics.Generic1 GHC.Internal.Functor.ZipList.ZipList
instance GHC.Internal.Generics.Generic (GHC.Internal.Functor.ZipList.ZipList a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Internal.Functor.ZipList.ZipList a)
instance GHC.Internal.Read.Read a => GHC.Internal.Read.Read (GHC.Internal.Functor.ZipList.ZipList a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (GHC.Internal.Functor.ZipList.ZipList a)
instance GHC.Internal.Data.Traversable.Traversable GHC.Internal.Functor.ZipList.ZipList


module GHC.Internal.IsList

-- | The <a>IsList</a> class and its methods are intended to be used in
--   conjunction with the OverloadedLists extension.
class IsList l where {
    
    -- | The <a>Item</a> type function returns the type of items of the
    --   structure <tt>l</tt>.
    type Item l;
}

-- | The <a>fromList</a> function constructs the structure <tt>l</tt> from
--   the given list of <tt>Item l</tt>
fromList :: IsList l => [Item l] -> l

-- | The <a>fromListN</a> function takes the input list's length and
--   potentially uses it to construct the structure <tt>l</tt> more
--   efficiently compared to <a>fromList</a>. If the given number does not
--   equal to the input list's length the behaviour of <a>fromListN</a> is
--   not specified.
--   
--   <pre>
--   fromListN (length xs) xs == fromList xs
--   </pre>
fromListN :: IsList l => Int -> [Item l] -> l

-- | The <a>toList</a> function extracts a list of <tt>Item l</tt> from the
--   structure <tt>l</tt>. It should satisfy fromList . toList = id.
toList :: IsList l => l -> [Item l]
instance GHC.Internal.IsList.IsList GHC.Internal.Stack.Types.CallStack
instance GHC.Internal.IsList.IsList [a]
instance GHC.Internal.IsList.IsList (GHC.Internal.Base.NonEmpty a)
instance GHC.Internal.IsList.IsList GHC.Internal.Data.Version.Version
instance GHC.Internal.IsList.IsList (GHC.Internal.Functor.ZipList.ZipList a)


-- | GHC Extensions: This is a unstable way to get at GHC-specific
--   extensions. If possible prefer using GHC.PrimOps from ghc-experimental
--   or GHC.Exts from base.
--   
--   Note: no other ghc-internal module should import this module.
module GHC.Internal.Exts

-- | A value of type <tt><a>Ptr</a> a</tt> represents a pointer to an
--   object, or an array of objects, which may be marshalled to or from
--   Haskell values of type <tt>a</tt>.
--   
--   The type <tt>a</tt> will often be an instance of class <a>Storable</a>
--   which provides the marshalling operations. However this is not
--   essential, and you can provide your own operations to access the
--   pointer. For example you might write small foreign functions to get or
--   set the fields of a C <tt>struct</tt>.
data Ptr a
Ptr :: Addr# -> Ptr a

-- | A value of type <tt><a>FunPtr</a> a</tt> is a pointer to a function
--   callable from foreign code. The type <tt>a</tt> will normally be a
--   <i>foreign type</i>, a function type with zero or more arguments where
--   
--   <ul>
--   <li>the argument types are <i>marshallable foreign types</i>, i.e.
--   <a>Char</a>, <a>Int</a>, <a>Double</a>, <a>Float</a>, <a>Bool</a>,
--   <a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>, <a>Word8</a>,
--   <a>Word16</a>, <a>Word32</a>, <a>Word64</a>, <tt><a>Ptr</a> a</tt>,
--   <tt><a>FunPtr</a> a</tt>, <tt><a>StablePtr</a> a</tt> or a renaming of
--   any of these using <tt>newtype</tt>.</li>
--   <li>the return type is either a marshallable foreign type or has the
--   form <tt><a>IO</a> t</tt> where <tt>t</tt> is a marshallable foreign
--   type or <tt>()</tt>.</li>
--   </ul>
--   
--   A value of type <tt><a>FunPtr</a> a</tt> may be a pointer to a foreign
--   function, either returned by another foreign function or imported with
--   a a static address import like
--   
--   <pre>
--   foreign import ccall "stdlib.h &amp;free"
--     p_free :: FunPtr (Ptr a -&gt; IO ())
--   </pre>
--   
--   or a pointer to a Haskell function created using a <i>wrapper</i> stub
--   declared to produce a <a>FunPtr</a> of the correct type. For example:
--   
--   <pre>
--   type Compare = Int -&gt; Int -&gt; Bool
--   foreign import ccall "wrapper"
--     mkCompare :: Compare -&gt; IO (FunPtr Compare)
--   </pre>
--   
--   Calls to wrapper stubs like <tt>mkCompare</tt> allocate storage, which
--   should be released with <a>freeHaskellFunPtr</a> when no longer
--   required.
--   
--   To convert <a>FunPtr</a> values to corresponding Haskell functions,
--   one can define a <i>dynamic</i> stub for the specific foreign type,
--   e.g.
--   
--   <pre>
--   type IntFunction = CInt -&gt; IO ()
--   foreign import ccall "dynamic"
--     mkFun :: FunPtr IntFunction -&gt; IntFunction
--   </pre>
data FunPtr a
FunPtr :: Addr# -> FunPtr a

-- | Alias for <a>tagToEnum#</a>. Returns True if its parameter is 1# and
--   False if it is 0#.
isTrue# :: Int# -> Bool
pattern KindRepApp :: () => KindRep -> KindRep -> KindRep
pattern KindRepFun :: () => KindRep -> KindRep -> KindRep
pattern KindRepTYPE :: () => !RuntimeRep -> KindRep
pattern KindRepTyConApp :: () => TyCon -> [KindRep] -> KindRep
pattern KindRepTypeLitD :: () => TypeLitSort -> [Char] -> KindRep
pattern KindRepTypeLitS :: () => TypeLitSort -> Addr# -> KindRep
pattern KindRepVar :: () => !KindBndr -> KindRep
type family MultMul (a :: Multiplicity) (b :: Multiplicity) :: Multiplicity
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | <a>SPEC</a> is used by GHC in the <tt>SpecConstr</tt> pass in order to
--   inform the compiler when to be particularly aggressive. In particular,
--   it tells GHC to specialize regardless of size or the number of
--   specializations. However, not all loops fall into this category.
--   
--   Libraries can specify this by using <a>SPEC</a> data type to inform
--   which loops should be aggressively specialized. For example, instead
--   of
--   
--   <pre>
--   loop x where loop arg = ...
--   </pre>
--   
--   write
--   
--   <pre>
--   loop SPEC x where loop !_ arg = ...
--   </pre>
--   
--   There is no semantic difference between <a>SPEC</a> and <a>SPEC2</a>,
--   we just need a type with two constructors lest it is optimised away
--   before <tt>SpecConstr</tt>.
--   
--   This type is reexported from <a>GHC.Exts</a> since GHC 9.0 and
--   <tt>base-4.15</tt>. For compatibility with earlier releases import it
--   from <a>GHC.Types</a> in <tt>ghc-prim</tt> package.
data SPEC
SPEC :: SPEC
SPEC2 :: SPEC

-- | Dynamic
pattern TrNameD :: () => [Char] -> TrName

-- | Static
pattern TrNameS :: () => Addr# -> TrName
pattern TypeLitChar :: () => TypeLitSort
pattern TypeLitNat :: () => TypeLitSort
pattern TypeLitSymbol :: () => TypeLitSort

-- | <i>Deprecated: Void# is now an alias for the unboxed tuple (# #).</i>
type Void# = (# #)
data CONSTRAINT (a :: RuntimeRep)
data TYPE (a :: RuntimeRep)

-- | The type constructor <tt>Any :: forall k. k</tt> is a type to which
--   you can unsafely coerce any type, and back.
--   
--   For <tt>unsafeCoerce</tt> this means for all lifted types <tt>t</tt>
--   that <tt>unsafeCoerce (unsafeCoerce x :: Any) :: t</tt> is equivalent
--   to <tt>x</tt> and safe.
--   
--   The same is true for *all* types when using <tt> unsafeCoerce# ::
--   forall (r1 :: RuntimeRep) (r2 :: RuntimeRep) (a :: TYPE r1) (b :: TYPE
--   r2). a -&gt; b </tt> but <i>only</i> if you instantiate <tt>r1</tt>
--   and <tt>r2</tt> to the <i>same</i> runtime representation. For example
--   using <tt>(unsafeCoerce# :: forall (a :: TYPE IntRep) (b :: TYPE
--   IntRep). a -&gt; b) x</tt> is fine, but <tt>(unsafeCoerce# :: forall
--   (a :: TYPE IntRep) (b :: TYPE FloatRep). a -&gt; b)</tt> will likely
--   cause seg-faults or worse. For this resason, users should always
--   prefer unsafeCoerce over unsafeCoerce# when possible.
--   
--   Here are some more examples: <tt> bad_a1 :: Any </tt>(TYPE 'IntRep)
--   bad_a1 = unsafeCoerce# True
--   
--   bad_a2 :: Any <tt>(TYPE ('BoxedRep 'UnliftedRep)) bad_a2 =
--   unsafeCoerce# True </tt> Here <tt>bad_a1</tt> is bad because we
--   started with <tt>True :: (Bool :: Type)</tt>, represented by a boxed
--   heap pointer, and coerced it to <tt>a1 :: Any </tt>(TYPE 'IntRep)<tt>,
--   whose representation is a non-pointer integer. That's why we had to
--   use <tt>unsafeCoerce#</tt>; it is really unsafe because it can change
--   representations. Similarly </tt>bad_a2<tt> is bad because although
--   both </tt>True<tt> and </tt>bad_a2<tt> are represented by a heap
--   pointer, </tt>True<tt> is lifted but </tt>bad_a2@ is not; bugs here
--   may be rather subtle.
--   
--   If you must use unsafeCoerce# to cast to <a>Any</a>, type annotations
--   are recommended to make sure that <tt>Any</tt> has the correct kind.
--   As casting between different runtimereps is unsound. For example to
--   cast a <tt>ByteArray#</tt> to <tt>Any</tt> you might use: <tt>
--   unsafeCoerce# b :: (Any :: TYPE ('BoxedRep 'Unlifted)) </tt>
type family Any :: k
data Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> represents Unicode codespace and its
--   elements are code points as in definitions <a>D9 and D10 of the
--   Unicode Standard</a>.
--   
--   Character literals in Haskell are single-quoted: <tt>'Q'</tt>,
--   <tt>'Я'</tt> or <tt>'Ω'</tt>. To represent a single quote itself use
--   <tt>'\''</tt>, and to represent a backslash use <tt>'\\'</tt>. The
--   full grammar can be found in the section 2.6 of the <a>Haskell 2010
--   Language Report</a>.
--   
--   To specify a character by its code point one can use decimal,
--   hexadecimal or octal notation: <tt>'\65'</tt>, <tt>'\x41'</tt> and
--   <tt>'\o101'</tt> are all alternative forms of <tt>'A'</tt>. The
--   largest code point is <tt>'\x10ffff'</tt>.
--   
--   There is a special escape syntax for ASCII control characters:
--   
--   TODO: table
--   
--   <a>Data.Char</a> provides utilities to work with <a>Char</a>.
data Char
C# :: Char# -> Char

-- | <tt>Coercible</tt> is a two-parameter class that has instances for
--   types <tt>a</tt> and <tt>b</tt> if the compiler can infer that they
--   have the same representation. This class does not have regular
--   instances; instead they are created on-the-fly during type-checking.
--   Trying to manually declare an instance of <tt>Coercible</tt> is an
--   error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance Coercible a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class a ~R# b => Coercible (a :: k) (b :: k)

-- | The kind of lifted constraints
type Constraint = CONSTRAINT LiftedRep

-- | Data type <tt>Dict</tt> provides a simple way to wrap up a (lifted)
--   constraint as a type
data DictBox a
MkDictBox :: DictBox a

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double
D# :: Double# -> Double
data DoubleBox (a :: TYPE 'DoubleRep)
MkDoubleBox :: a -> DoubleBox (a :: TYPE 'DoubleRep)

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float
F# :: Float# -> Float
data FloatBox (a :: TYPE 'FloatRep)
MkFloatBox :: a -> FloatBox (a :: TYPE 'FloatRep)

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int
I# :: Int# -> Int
data IntBox (a :: TYPE 'IntRep)
MkIntBox :: a -> IntBox (a :: TYPE 'IntRep)

-- | Whether a boxed type is lifted or unlifted.
data Levity
Lifted :: Levity
Unlifted :: Levity

-- | The runtime representation of lifted types.
type LiftedRep = 'BoxedRep 'Lifted

-- | The builtin linked list type.
--   
--   In Haskell, lists are one of the most important data types as they are
--   often used analogous to loops in imperative programming languages.
--   These lists are singly linked, which makes them unsuited for
--   operations that require &lt;math&gt; access. Instead, they are
--   intended to be traversed.
--   
--   You can use <tt>List a</tt> or <tt>[a]</tt> in type signatures:
--   
--   <pre>
--   length :: [a] -&gt; Int
--   </pre>
--   
--   or
--   
--   <pre>
--   length :: List a -&gt; Int
--   </pre>
--   
--   They are fully equivalent, and <tt>List a</tt> will be normalised to
--   <tt>[a]</tt>.
--   
--   <h4>Usage</h4>
--   
--   Lists are constructed recursively using the right-associative
--   constructor operator (or <i>cons</i>) <tt>(:) :: a -&gt; [a] -&gt;
--   [a]</tt>, which prepends an element to a list, and the empty list
--   <tt>[]</tt>.
--   
--   <pre>
--   (1 : 2 : 3 : []) == (1 : (2 : (3 : []))) == [1, 2, 3]
--   </pre>
--   
--   Lists can also be constructed using list literals of the form
--   <tt>[x_1, x_2, ..., x_n]</tt> which are syntactic sugar and, unless
--   <tt>-XOverloadedLists</tt> is enabled, are translated into uses of
--   <tt>(:)</tt> and <tt>[]</tt>
--   
--   <a>String</a> literals, like <tt>"I 💜 hs"</tt>, are translated into
--   Lists of characters, <tt>['I', ' ', '💜', ' ', 'h', 's']</tt>.
--   
--   <h4><b>Implementation</b></h4>
--   
--   Internally and in memory, all the above are represented like this,
--   with arrows being pointers to locations in memory.
--   
--   <pre>
--   ╭───┬───┬──╮   ╭───┬───┬──╮   ╭───┬───┬──╮   ╭────╮
--   │(:)│   │ ─┼──&gt;│(:)│   │ ─┼──&gt;│(:)│   │ ─┼──&gt;│ [] │
--   ╰───┴─┼─┴──╯   ╰───┴─┼─┴──╯   ╰───┴─┼─┴──╯   ╰────╯
--         v              v              v
--         1              2              3
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; ['H', 'a', 's', 'k', 'e', 'l', 'l']
--   "Haskell"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 : [4, 1, 5, 9]
--   [1,4,1,5,9]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] : [] : []
--   [[],[]]
--   </pre>
data [] a
data Multiplicity
One :: Multiplicity
Many :: Multiplicity

-- | GHC maintains a property that the kind of all inhabited types (as
--   distinct from type constructors or type-level data) tells us the
--   runtime representation of values of that type. This datatype encodes
--   the choice of runtime value. Note that <a>TYPE</a> is parameterised by
--   <a>RuntimeRep</a>; this is precisely what we mean by the fact that a
--   type's kind encodes the runtime representation.
--   
--   For boxed values (that is, values that are represented by a pointer),
--   a further distinction is made, between lifted types (that contain ⊥),
--   and unlifted ones (that don't).
data RuntimeRep

-- | a SIMD vector type
VecRep :: VecCount -> VecElem -> RuntimeRep

-- | An unboxed tuple of the given reps
TupleRep :: [RuntimeRep] -> RuntimeRep

-- | An unboxed sum of the given reps
SumRep :: [RuntimeRep] -> RuntimeRep

-- | boxed; represented by a pointer
BoxedRep :: Levity -> RuntimeRep

-- | signed, word-sized value
IntRep :: RuntimeRep

-- | signed, 8-bit value
Int8Rep :: RuntimeRep

-- | signed, 16-bit value
Int16Rep :: RuntimeRep

-- | signed, 32-bit value
Int32Rep :: RuntimeRep

-- | signed, 64-bit value
Int64Rep :: RuntimeRep

-- | unsigned, word-sized value
WordRep :: RuntimeRep

-- | unsigned, 8-bit value
Word8Rep :: RuntimeRep

-- | unsigned, 16-bit value
Word16Rep :: RuntimeRep

-- | unsigned, 32-bit value
Word32Rep :: RuntimeRep

-- | unsigned, 64-bit value
Word64Rep :: RuntimeRep

-- | A pointer, but <i>not</i> to a Haskell value
AddrRep :: RuntimeRep

-- | a 32-bit floating point number
FloatRep :: RuntimeRep

-- | a 64-bit floating point number
DoubleRep :: RuntimeRep

-- | (Kind) This is the kind of type-level symbols.
data Symbol

-- | The runtime representation of unlifted types.
type UnliftedRep = 'BoxedRep 'Unlifted

-- | The kind of boxed, unlifted values, for example <tt>Array#</tt> or a
--   user-defined unlifted data type, using <tt>-XUnliftedDataTypes</tt>.
type UnliftedType = TYPE UnliftedRep

-- | Length of a SIMD vector type
data VecCount
Vec2 :: VecCount
Vec4 :: VecCount
Vec8 :: VecCount
Vec16 :: VecCount
Vec32 :: VecCount
Vec64 :: VecCount

-- | Element of a SIMD vector type
data VecElem
Int8ElemRep :: VecElem
Int16ElemRep :: VecElem
Int32ElemRep :: VecElem
Int64ElemRep :: VecElem
Word8ElemRep :: VecElem
Word16ElemRep :: VecElem
Word32ElemRep :: VecElem
Word64ElemRep :: VecElem
FloatElemRep :: VecElem
DoubleElemRep :: VecElem

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word
W# :: Word# -> Word
data WordBox (a :: TYPE 'WordRep)
MkWordBox :: a -> WordBox (a :: TYPE 'WordRep)

-- | The runtime representation of a zero-width tuple, represented by no
--   bits at all
type ZeroBitRep = 'TupleRep '[] :: [RuntimeRep]

-- | The kind of the empty unboxed tuple type (# #)
type ZeroBitType = TYPE ZeroBitRep

-- | Lifted, homogeneous equality. By lifted, we mean that it can be bogus
--   (deferred type error). By homogeneous, the two types <tt>a</tt> and
--   <tt>b</tt> must have the same kinds.
class a ~# b => (a :: k) ~ (b :: k)
infix 4 ~

-- | Lifted, heterogeneous equality. By lifted, we mean that it can be
--   bogus (deferred type error). By heterogeneous, the two types
--   <tt>a</tt> and <tt>b</tt> might have different kinds. Because
--   <tt>~~</tt> can appear unexpectedly in error messages to users who do
--   not care about the difference between heterogeneous equality
--   <tt>~~</tt> and homogeneous equality <tt>~</tt>, this is printed as
--   <tt>~</tt> unless <tt>-fprint-equality-relations</tt> is set.
--   
--   In <tt>0.7.0</tt>, the fixity was set to <tt>infix 4</tt> to match the
--   fixity of <a>:~~:</a>.
class a ~# b => (a :: k0) ~~ (b :: k1)
infix 4 ~~

-- | Low word of signed integer multiply.
(*#) :: Int# -> Int# -> Int#
infixl 7 *#
(*##) :: Double# -> Double# -> Double#
infixl 7 *##

-- | Exponentiation.
(**##) :: Double# -> Double# -> Double#
(+#) :: Int# -> Int# -> Int#
infixl 6 +#
(+##) :: Double# -> Double# -> Double#
infixl 6 +##
(-#) :: Int# -> Int# -> Int#
infixl 6 -#
(-##) :: Double# -> Double# -> Double#
infixl 6 -##
(/##) :: Double# -> Double# -> Double#
infixl 7 /##
(/=#) :: Int# -> Int# -> Int#
infix 4 /=#
(/=##) :: Double# -> Double# -> Int#
infix 4 /=##
(<#) :: Int# -> Int# -> Int#
infix 4 <#
(<##) :: Double# -> Double# -> Int#
infix 4 <##
(<=#) :: Int# -> Int# -> Int#
infix 4 <=#
(<=##) :: Double# -> Double# -> Int#
infix 4 <=##
(==#) :: Int# -> Int# -> Int#
infix 4 ==#
(==##) :: Double# -> Double# -> Int#
infix 4 ==##
(>#) :: Int# -> Int# -> Int#
infix 4 >#
(>##) :: Double# -> Double# -> Int#
infix 4 >##
(>=#) :: Int# -> Int# -> Int#
infix 4 >=#
(>=##) :: Double# -> Double# -> Int#
infix 4 >=##
acosDouble# :: Double# -> Double#
acosFloat# :: Float# -> Float#
acoshDouble# :: Double# -> Double#
acoshFloat# :: Float# -> Float#

-- | <tt><a>addCFinalizerToWeak#</a> fptr ptr flag eptr w</tt> attaches a C
--   function pointer <tt>fptr</tt> to a weak pointer <tt>w</tt> as a
--   finalizer. If <tt>flag</tt> is zero, <tt>fptr</tt> will be called with
--   one argument, <tt>ptr</tt>. Otherwise, it will be called with two
--   arguments, <tt>eptr</tt> and <tt>ptr</tt>. <a>addCFinalizerToWeak#</a>
--   returns 1 on success, or 0 if <tt>w</tt> is already dead.
addCFinalizerToWeak# :: forall {k :: Levity} (b :: TYPE ('BoxedRep k)). Addr# -> Addr# -> Int# -> Addr# -> Weak# b -> State# RealWorld -> (# State# RealWorld, Int# #)

-- | Add signed integers reporting overflow. First member of result is the
--   sum truncated to an <a>Int#</a>; second member is zero if the true sum
--   fits in an <a>Int#</a>, nonzero if overflow occurred (the sum is
--   either too large or too small to fit in an <a>Int#</a>).
addIntC# :: Int# -> Int# -> (# Int#, Int# #)

-- | Add unsigned integers reporting overflow. The first element of the
--   pair is the result. The second element is the carry flag, which is
--   nonzero on overflow. See also <a>plusWord2#</a>.
addWordC# :: Word# -> Word# -> (# Word#, Int# #)

-- | Coerce directly from address to int. Users are discouraged from using
--   this operation as it makes little sense on platforms with tagged
--   pointers.
addr2Int# :: Addr# -> Int#

-- | Convert an <a>Addr#</a> to a followable Any type.
addrToAny# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Addr# -> (# a #)
and# :: Word# -> Word# -> Word#
and64# :: Word64# -> Word64# -> Word64#

-- | Bitwise "and".
andI# :: Int# -> Int# -> Int#
andWord16# :: Word16# -> Word16# -> Word16#
andWord32# :: Word32# -> Word32# -> Word32#
andWord8# :: Word8# -> Word8# -> Word8#

-- | Retrieve the address of any Haskell value. This is essentially an
--   <tt>unsafeCoerce#</tt>, but if implemented as such the core lint pass
--   complains and fails to compile. As a primop, it is opaque to core/stg,
--   and only appears in cmm (where the copy propagation pass will get rid
--   of it). Note that "a" must be a value, not a thunk! It's too late for
--   strictness analysis to enforce this, so you're on your own to
--   guarantee this. Also note that <a>Addr#</a> is not a GC pointer - up
--   to you to guarantee that it does not become a dangling pointer
--   immediately after you get it.
anyToAddr# :: a -> State# RealWorld -> (# State# RealWorld, Addr# #)
asinDouble# :: Double# -> Double#
asinFloat# :: Float# -> Float#
asinhDouble# :: Double# -> Double#
asinhFloat# :: Float# -> Float#
atanDouble# :: Double# -> Double#
atanFloat# :: Float# -> Float#
atanhDouble# :: Double# -> Double#
atanhFloat# :: Float# -> Float#

-- | Compare and swap on a word-sized memory location.
--   
--   Use as: s -&gt; atomicCasAddrAddr# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasAddrAddr# :: Addr# -> Addr# -> Addr# -> State# d -> (# State# d, Addr# #)

-- | Compare and swap on a 16 bit-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr16# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWord16Addr# :: Addr# -> Word16# -> Word16# -> State# d -> (# State# d, Word16# #)

-- | Compare and swap on a 32 bit-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr32# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWord32Addr# :: Addr# -> Word32# -> Word32# -> State# d -> (# State# d, Word32# #)

-- | Compare and swap on a 64 bit-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr64# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWord64Addr# :: Addr# -> Word64# -> Word64# -> State# d -> (# State# d, Word64# #)

-- | Compare and swap on a 8 bit-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr8# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWord8Addr# :: Addr# -> Word8# -> Word8# -> State# d -> (# State# d, Word8# #)

-- | Compare and swap on a word-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWordAddr# :: Addr# -> Word# -> Word# -> State# d -> (# State# d, Word# #)

-- | The atomic exchange operation. Atomically exchanges the value at the
--   first address with the Addr# given as second argument. Implies a read
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicExchangeAddrAddr# :: Addr# -> Addr# -> State# d -> (# State# d, Addr# #)

-- | The atomic exchange operation. Atomically exchanges the value at the
--   address with the given value. Returns the old value. Implies a read
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicExchangeWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Modify the contents of a <a>MutVar#</a>, returning the previous
--   contents <tt>x :: a</tt> and the result of applying the given function
--   to the previous contents <tt>f x :: c</tt>.
--   
--   The <tt>data</tt> type <tt>c</tt> (not a <tt>newtype</tt>!) must be a
--   record whose first field is of lifted type <tt>a :: Type</tt> and is
--   not unpacked. For example, product types <tt>c ~ Solo a</tt> or <tt>c
--   ~ (a, b)</tt> work well. If the record type is both monomorphic and
--   strict in its first field, it's recommended to mark the latter <tt>{-#
--   NOUNPACK #-}</tt> explicitly.
--   
--   Under the hood <a>atomicModifyMutVar2#</a> atomically replaces a
--   pointer to an old <tt>x :: a</tt> with a pointer to a selector thunk
--   <tt>fst r</tt>, where <tt>fst</tt> is a selector for the first field
--   of the record and <tt>r</tt> is a function application thunk <tt>r = f
--   x</tt>.
--   
--   <tt>atomicModifyIORef2Native</tt> from <tt>atomic-modify-general</tt>
--   package makes an effort to reflect restrictions on <tt>c</tt>
--   faithfully, providing a well-typed high-level wrapper.
atomicModifyMutVar2# :: MutVar# d a -> (a -> c) -> State# d -> (# State# d, a, c #)

-- | Modify the contents of a <a>MutVar#</a>, returning the previous
--   contents and the result of applying the given function to the previous
--   contents.
atomicModifyMutVar_# :: MutVar# d a -> (a -> a) -> State# d -> (# State# d, a, a #)

-- | Given an array and an offset in machine words, read an element. The
--   index is assumed to be in bounds. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicReadIntArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an address, read a machine word. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicReadWordAddr# :: Addr# -> State# d -> (# State# d, Word# #)

-- | Atomically exchange the value of a <a>MutVar#</a>.
atomicSwapMutVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutVar# d a -> a -> State# d -> (# State# d, a #)

-- | Given an array and an offset in machine words, write an element. The
--   index is assumed to be in bounds. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicWriteIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Given an address, write a machine word. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicWriteWordAddr# :: Addr# -> Word# -> State# d -> State# d
atomically# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)

-- | Reverse the order of the bits in a word.
bitReverse# :: Word# -> Word#

-- | Reverse the order of the bits in a 16-bit word.
bitReverse16# :: Word# -> Word#

-- | Reverse the order of the bits in a 32-bit word.
bitReverse32# :: Word# -> Word#

-- | Reverse the order of the bits in a 64-bit word.
bitReverse64# :: Word64# -> Word64#

-- | Reverse the order of the bits in a 8-bit word.
bitReverse8# :: Word# -> Word#

-- | Broadcast a scalar to all elements of a vector.
broadcastDoubleX2# :: Double# -> DoubleX2#

-- | Broadcast a scalar to all elements of a vector.
broadcastDoubleX4# :: Double# -> DoubleX4#

-- | Broadcast a scalar to all elements of a vector.
broadcastDoubleX8# :: Double# -> DoubleX8#

-- | Broadcast a scalar to all elements of a vector.
broadcastFloatX16# :: Float# -> FloatX16#

-- | Broadcast a scalar to all elements of a vector.
broadcastFloatX4# :: Float# -> FloatX4#

-- | Broadcast a scalar to all elements of a vector.
broadcastFloatX8# :: Float# -> FloatX8#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt16X16# :: Int16# -> Int16X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt16X32# :: Int16# -> Int16X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt16X8# :: Int16# -> Int16X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt32X16# :: Int32# -> Int32X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt32X4# :: Int32# -> Int32X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt32X8# :: Int32# -> Int32X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt64X2# :: Int64# -> Int64X2#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt64X4# :: Int64# -> Int64X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt64X8# :: Int64# -> Int64X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt8X16# :: Int8# -> Int8X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt8X32# :: Int8# -> Int8X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt8X64# :: Int8# -> Int8X64#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord16X16# :: Word16# -> Word16X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord16X32# :: Word16# -> Word16X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord16X8# :: Word16# -> Word16X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord32X16# :: Word32# -> Word32X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord32X4# :: Word32# -> Word32X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord32X8# :: Word32# -> Word32X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord64X2# :: Word64# -> Word64X2#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord64X4# :: Word64# -> Word64X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord64X8# :: Word64# -> Word64X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord8X16# :: Word8# -> Word8X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord8X32# :: Word8# -> Word8X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord8X64# :: Word8# -> Word8X64#

-- | Intended for use with pinned arrays; otherwise very unsafe!
byteArrayContents# :: ByteArray# -> Addr#

-- | Swap bytes in a word.
byteSwap# :: Word# -> Word#

-- | Swap bytes in the lower 16 bits of a word. The higher bytes are
--   undefined.
byteSwap16# :: Word# -> Word#

-- | Swap bytes in the lower 32 bits of a word. The higher bytes are
--   undefined.
byteSwap32# :: Word# -> Word#

-- | Swap bytes in a 64 bits of a word.
byteSwap64# :: Word64# -> Word64#

-- | Given an array, an offset, the expected old value, and the new value,
--   perform an atomic compare and swap (i.e. write the new value if the
--   current value and the old value are the same pointer). Returns 0 if
--   the swap succeeds and 1 if it fails. Additionally, returns the element
--   at the offset after the operation completes. This means that on a
--   success the new value is returned, and on a failure the actual old
--   value (not the expected one) is returned. Implies a full memory
--   barrier. The use of a pointer equality on a boxed value makes this
--   function harder to use correctly than <a>casIntArray#</a>. All of the
--   difficulties of using <a>reallyUnsafePtrEquality#</a> correctly apply
--   to <a>casArray#</a> as well.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)

-- | Given an array, an offset in 16 bit units, the expected old value, and
--   the new value, perform an atomic compare and swap i.e. write the new
--   value if the current value matches the provided old value. Returns the
--   value of the element before the operation. Implies a full memory
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casInt16Array# :: MutableByteArray# d -> Int# -> Int16# -> Int16# -> State# d -> (# State# d, Int16# #)

-- | Given an array, an offset in 32 bit units, the expected old value, and
--   the new value, perform an atomic compare and swap i.e. write the new
--   value if the current value matches the provided old value. Returns the
--   value of the element before the operation. Implies a full memory
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casInt32Array# :: MutableByteArray# d -> Int# -> Int32# -> Int32# -> State# d -> (# State# d, Int32# #)

-- | Given an array, an offset in 64 bit units, the expected old value, and
--   the new value, perform an atomic compare and swap i.e. write the new
--   value if the current value matches the provided old value. Returns the
--   value of the element before the operation. Implies a full memory
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casInt64Array# :: MutableByteArray# d -> Int# -> Int64# -> Int64# -> State# d -> (# State# d, Int64# #)

-- | Given an array, an offset in bytes, the expected old value, and the
--   new value, perform an atomic compare and swap i.e. write the new value
--   if the current value matches the provided old value. Returns the value
--   of the element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casInt8Array# :: MutableByteArray# d -> Int# -> Int8# -> Int8# -> State# d -> (# State# d, Int8# #)

-- | Given an array, an offset in machine words, the expected old value,
--   and the new value, perform an atomic compare and swap i.e. write the
--   new value if the current value matches the provided old value. Returns
--   the value of the element before the operation. Implies a full memory
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casIntArray# :: MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Compare-and-swap: perform a pointer equality test between the first
--   value passed to this function and the value stored inside the
--   <a>MutVar#</a>. If the pointers are equal, replace the stored value
--   with the second value passed to this function, otherwise do nothing.
--   Returns the final value stored inside the <a>MutVar#</a>. The
--   <a>Int#</a> indicates whether a swap took place, with <tt>1#</tt>
--   meaning that we didn't swap, and <tt>0#</tt> that we did. Implies a
--   full memory barrier. Because the comparison is done on the level of
--   pointers, all of the difficulties of using
--   <a>reallyUnsafePtrEquality#</a> correctly apply to <a>casMutVar#</a>
--   as well.
casMutVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutVar# d a -> a -> a -> State# d -> (# State# d, Int#, a #)

-- | Unsafe, machine-level atomic compare and swap on an element within an
--   array. See the documentation of <a>casArray#</a>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casSmallArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)

-- | Bitcast a <a>Double#</a> into a <a>Word64#</a>
castDoubleToWord64# :: Double# -> Word64#

-- | Bitcast a <a>Float#</a> into a <a>Word32#</a>
castFloatToWord32# :: Float# -> Word32#

-- | Bitcast a <a>Word32#</a> into a <a>Float#</a>
castWord32ToFloat# :: Word32# -> Float#

-- | Bitcast a <a>Word64#</a> into a <a>Double#</a>
castWord64ToDouble# :: Word64# -> Double#

-- | <tt><a>catch#</a> k handler s</tt> evaluates <tt>k s</tt>, invoking
--   <tt>handler</tt> on any exceptions thrown.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
catch# :: forall {q :: RuntimeRep} {k :: Levity} (a :: TYPE q) (b :: TYPE ('BoxedRep k)). (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
catchRetry# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). (State# RealWorld -> (# State# RealWorld, a #)) -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
catchSTM# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) b. (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
chr# :: Int# -> Char#

-- | Run the supplied IO action with an empty CCS. For example, this is
--   used by the interpreter to run an interpreted computation without the
--   call stack showing that it was invoked from GHC.
clearCCS# :: (State# d -> (# State# d, a #)) -> State# d -> (# State# d, a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Array# a -> Int# -> Int# -> Array# a

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). SmallArray# a -> Int# -> Int# -> SmallArray# a

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)

-- | <tt><a>closureSize#</a> closure</tt> returns the size of the given
--   closure in machine words.
closureSize# :: a -> Int#

-- | Count leading zeros in a word.
clz# :: Word# -> Word#

-- | Count leading zeros in the lower 16 bits of a word.
clz16# :: Word# -> Word#

-- | Count leading zeros in the lower 32 bits of a word.
clz32# :: Word# -> Word#

-- | Count leading zeros in a 64-bit word.
clz64# :: Word64# -> Word#

-- | Count leading zeros in the lower 8 bits of a word.
clz8# :: Word# -> Word#

-- | Recursively add a closure and its transitive closure to a
--   <a>Compact#</a> (a CNF), evaluating any unevaluated components at the
--   same time. Note: <a>compactAdd#</a> is not thread-safe, so only one
--   thread may call <a>compactAdd#</a> with a particular <a>Compact#</a>
--   at any given time. The primop does not enforce any mutual exclusion;
--   the caller is expected to arrange this.
compactAdd# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)

-- | Like <a>compactAdd#</a>, but retains sharing and cycles during
--   compaction.
compactAddWithSharing# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)

-- | Attempt to allocate a compact block with the capacity (in bytes) given
--   by the first argument. The <a>Addr#</a> is a pointer to previous
--   compact block of the CNF or <a>nullAddr#</a> to create a new CNF with
--   a single compact block.
--   
--   The resulting block is not known to the GC until
--   <a>compactFixupPointers#</a> is called on it, and care must be taken
--   so that the address does not escape or memory will be leaked.
compactAllocateBlock# :: Word# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr# #)

-- | Returns 1# if the object is contained in the CNF, 0# otherwise.
compactContains# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, Int# #)

-- | Returns 1# if the object is in any CNF at all, 0# otherwise.
compactContainsAny# :: a -> State# RealWorld -> (# State# RealWorld, Int# #)

-- | Given the pointer to the first block of a CNF and the address of the
--   root object in the old address space, fix up the internal pointers
--   inside the CNF to account for a different position in memory than when
--   it was serialized. This method must be called exactly once after
--   importing a serialized CNF. It returns the new CNF and the new
--   adjusted root address.
compactFixupPointers# :: Addr# -> Addr# -> State# RealWorld -> (# State# RealWorld, Compact#, Addr# #)

-- | Returns the address and the utilized size (in bytes) of the first
--   compact block of a CNF.
compactGetFirstBlock# :: Compact# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)

-- | Given a CNF and the address of one its compact blocks, returns the
--   next compact block and its utilized size, or <a>nullAddr#</a> if the
--   argument was the last compact block in the CNF.
compactGetNextBlock# :: Compact# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)

-- | Create a new CNF with a single compact block. The argument is the
--   capacity of the compact block (in bytes, not words). The capacity is
--   rounded up to a multiple of the allocator block size and is capped to
--   one mega block.
compactNew# :: Word# -> State# RealWorld -> (# State# RealWorld, Compact# #)

-- | Set the new allocation size of the CNF. This value (in bytes)
--   determines the capacity of each compact block in the CNF. It does not
--   retroactively affect existing compact blocks in the CNF.
compactResize# :: Compact# -> Word# -> State# RealWorld -> State# RealWorld

-- | Return the total capacity (in bytes) of all the compact blocks in the
--   CNF.
compactSize# :: Compact# -> State# RealWorld -> (# State# RealWorld, Word# #)

-- | <tt><a>compareByteArrays#</a> src1 src1_ofs src2 src2_ofs n</tt>
--   compares <tt>n</tt> bytes starting at offset <tt>src1_ofs</tt> in the
--   first <a>ByteArray#</a> <tt>src1</tt> to the range of <tt>n</tt> bytes
--   (i.e. same length) starting at offset <tt>src2_ofs</tt> of the second
--   <a>ByteArray#</a> <tt>src2</tt>. Both arrays must fully contain the
--   specified ranges, but this is not checked. Returns an <a>Int#</a> less
--   than, equal to, or greater than zero if the range is found,
--   respectively, to be byte-wise lexicographically less than, to match,
--   or be greater than the second range.
compareByteArrays# :: ByteArray# -> Int# -> ByteArray# -> Int# -> Int# -> Int#

-- | See <a>GHC.Prim#continuations</a>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
control0# :: forall {r :: RuntimeRep} a (b :: TYPE r). PromptTag# a -> (((State# RealWorld -> (# State# RealWorld, b #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, b #)

-- | <tt><a>copyAddrToAddr#</a> src dest len</tt> copies <tt>len</tt> bytes
--   from <tt>src</tt> to <tt>dest</tt>. These two memory ranges are
--   allowed to overlap.
--   
--   Analogous to the standard C function <tt>memmove</tt>, but with a
--   different argument order.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyAddrToAddr# :: Addr# -> Addr# -> Int# -> State# RealWorld -> State# RealWorld

-- | <tt><a>copyAddrToAddrNonOverlapping#</a> src dest len</tt> copies
--   <tt>len</tt> bytes from <tt>src</tt> to <tt>dest</tt>. As the name
--   suggests, these two memory ranges <i>must not overlap</i>, although
--   this pre-condition is not checked.
--   
--   Analogous to the standard C function <tt>memcpy</tt>, but with a
--   different argument order.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyAddrToAddrNonOverlapping# :: Addr# -> Addr# -> Int# -> State# RealWorld -> State# RealWorld

-- | Copy a memory range starting at the Addr# to the specified range in
--   the MutableByteArray#. The memory region at Addr# and the ByteArray#
--   must fully contain the specified ranges, but this is not checked. The
--   Addr# must not point into the MutableByteArray# (e.g. if the
--   MutableByteArray# were pinned), but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyAddrToByteArray# :: Addr# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. The two arrays must not be the same array in different
--   states, but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. Array# a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d

-- | <tt><a>copyByteArray#</a> src src_ofs dst dst_ofs len</tt> copies the
--   range starting at offset <tt>src_ofs</tt> of length <tt>len</tt> from
--   the <a>ByteArray#</a> <tt>src</tt> to the <a>MutableByteArray#</a>
--   <tt>dst</tt> starting at offset <tt>dst_ofs</tt>. Both arrays must
--   fully contain the specified ranges, but this is not checked. The two
--   arrays must not be the same array in different states, but this is not
--   checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyByteArray# :: ByteArray# -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Copy a range of the ByteArray# to the memory range starting at the
--   Addr#. The ByteArray# and the memory region at Addr# must fully
--   contain the specified ranges, but this is not checked. The Addr# must
--   not point into the ByteArray# (e.g. if the ByteArray# were pinned),
--   but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyByteArrayToAddr# :: ByteArray# -> Int# -> Addr# -> Int# -> State# d -> State# d

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. In the case where the source and destination are the
--   same array the source and destination regions may overlap.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d

-- | <tt><a>copyMutableByteArray#</a> src src_ofs dst dst_ofs len</tt>
--   copies the range starting at offset <tt>src_ofs</tt> of length
--   <tt>len</tt> from the <a>MutableByteArray#</a> <tt>src</tt> to the
--   <a>MutableByteArray#</a> <tt>dst</tt> starting at offset
--   <tt>dst_ofs</tt>. Both arrays must fully contain the specified ranges,
--   but this is not checked. The regions are allowed to overlap, although
--   this is only possible when the same array is provided as both the
--   source and the destination.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableByteArray# :: MutableByteArray# d -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | <tt><a>copyMutableByteArrayNonOverlapping#</a> src src_ofs dst dst_ofs
--   len</tt> copies the range starting at offset <tt>src_ofs</tt> of
--   length <tt>len</tt> from the <a>MutableByteArray#</a> <tt>src</tt> to
--   the <a>MutableByteArray#</a> <tt>dst</tt> starting at offset
--   <tt>dst_ofs</tt>. Both arrays must fully contain the specified ranges,
--   but this is not checked. The regions are <i>not</i> allowed to
--   overlap, but this is also not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableByteArrayNonOverlapping# :: MutableByteArray# d -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Copy a range of the MutableByteArray# to the memory range starting at
--   the Addr#. The MutableByteArray# and the memory region at Addr# must
--   fully contain the specified ranges, but this is not checked. The Addr#
--   must not point into the MutableByteArray# (e.g. if the
--   MutableByteArray# were pinned), but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableByteArrayToAddr# :: MutableByteArray# d -> Int# -> Addr# -> Int# -> State# d -> State# d

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. The two arrays must not be the same array in different
--   states, but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copySmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. SmallArray# a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. The source and destination arrays can refer to the same array.
--   Both arrays must fully contain the specified ranges, but this is not
--   checked. The regions are allowed to overlap, although this is only
--   possible when the same array is provided as both the source and the
--   destination.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copySmallMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d
cosDouble# :: Double# -> Double#
cosFloat# :: Float# -> Float#
coshDouble# :: Double# -> Double#
coshFloat# :: Float# -> Float#

-- | Count trailing zeros in a word.
ctz# :: Word# -> Word#

-- | Count trailing zeros in the lower 16 bits of a word.
ctz16# :: Word# -> Word#

-- | Count trailing zeros in the lower 32 bits of a word.
ctz32# :: Word# -> Word#

-- | Count trailing zeros in a 64-bit word.
ctz64# :: Word64# -> Word#

-- | Count trailing zeros in the lower 8 bits of a word.
ctz8# :: Word# -> Word#
deRefStablePtr# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). StablePtr# a -> State# RealWorld -> (# State# RealWorld, a #)
deRefWeak# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, a #)

-- | Convert to integer. First component of the result is -1 or 1,
--   indicating the sign of the mantissa. The next two are the high and low
--   32 bits of the mantissa respectively, and the last is the exponent.
decodeDouble_2Int# :: Double# -> (# Int#, Word#, Word#, Int# #)

-- | Decode <a>Double#</a> into mantissa and base-2 exponent.
decodeDouble_Int64# :: Double# -> (# Int64#, Int# #)

-- | Convert to integers. First <a>Int#</a> in result is the mantissa;
--   second is the exponent.
decodeFloat_Int# :: Float# -> (# Int#, Int# #)

-- | Sleep specified number of microseconds.
delay# :: Int# -> State# d -> State# d

-- | Divide two vectors element-wise.
divideDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Divide two vectors element-wise.
divideDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Divide two vectors element-wise.
divideDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
divideFloat# :: Float# -> Float# -> Float#

-- | Divide two vectors element-wise.
divideFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Divide two vectors element-wise.
divideFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Divide two vectors element-wise.
divideFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
double2Float# :: Double# -> Float#

-- | Truncates a <a>Double#</a> value to the nearest <a>Int#</a>. Results
--   are undefined if the truncation if truncation yields a value outside
--   the range of <a>Int#</a>.
double2Int# :: Double# -> Int#
eqAddr# :: Addr# -> Addr# -> Int#
eqChar# :: Char# -> Char# -> Int#
eqFloat# :: Float# -> Float# -> Int#
eqInt16# :: Int16# -> Int16# -> Int#
eqInt32# :: Int32# -> Int32# -> Int#
eqInt64# :: Int64# -> Int64# -> Int#
eqInt8# :: Int8# -> Int8# -> Int#
eqStablePtr# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). StablePtr# a -> StablePtr# a -> Int#
eqWord# :: Word# -> Word# -> Int#
eqWord16# :: Word16# -> Word16# -> Int#
eqWord32# :: Word32# -> Word32# -> Int#
eqWord64# :: Word64# -> Word64# -> Int#
eqWord8# :: Word8# -> Word8# -> Int#
expDouble# :: Double# -> Double#
expFloat# :: Float# -> Float#
expm1Double# :: Double# -> Double#
expm1Float# :: Float# -> Float#
fabsDouble# :: Double# -> Double#
fabsFloat# :: Float# -> Float#

-- | Given an array, and offset in machine words, and a value to add,
--   atomically add the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAddIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an address, and a value to add, atomically add the value to the
--   element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAddWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Given an array, and offset in machine words, and a value to AND,
--   atomically AND the value into the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAndIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an address, and a value to AND, atomically AND the value into
--   the element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAndWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Given an array, and offset in machine words, and a value to NAND,
--   atomically NAND the value into the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchNandIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an address, and a value to NAND, atomically NAND the value into
--   the element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchNandWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Given an array, and offset in machine words, and a value to OR,
--   atomically OR the value into the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchOrIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an address, and a value to OR, atomically OR the value into the
--   element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchOrWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Given an array, and offset in machine words, and a value to subtract,
--   atomically subtract the value from the element. Returns the value of
--   the element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchSubIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an address, and a value to subtract, atomically subtract the
--   value from the element. Returns the value of the element before the
--   operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchSubWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Given an array, and offset in machine words, and a value to XOR,
--   atomically XOR the value into the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchXorIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an address, and a value to XOR, atomically XOR the value into
--   the element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchXorWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Finalize a weak pointer. The return value is an unboxed tuple
--   containing the new state of the world and an "unboxed Maybe",
--   represented by an <a>Int#</a> and a (possibly invalid) finalization
--   action. An <a>Int#</a> of <tt>1</tt> indicates that the finalizer is
--   valid. The return value <tt>b</tt> from the finalizer should be
--   ignored.
finalizeWeak# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) b. Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, State# RealWorld -> (# State# RealWorld, b #) #)
float2Double# :: Float# -> Double#

-- | Truncates a <a>Float#</a> value to the nearest <a>Int#</a>. Results
--   are undefined if the truncation if truncation yields a value outside
--   the range of <a>Int#</a>.
float2Int# :: Float# -> Int#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddDouble# :: Double# -> Double# -> Double# -> Double#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddFloat# :: Float# -> Float# -> Float# -> Float#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddFloatX16# :: FloatX16# -> FloatX16# -> FloatX16# -> FloatX16#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddFloatX4# :: FloatX4# -> FloatX4# -> FloatX4# -> FloatX4#

-- | Fused multiply-add operation <tt>x*y+z</tt>. See <a>GHC.Prim#fma</a>.
fmaddFloatX8# :: FloatX8# -> FloatX8# -> FloatX8# -> FloatX8#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubDouble# :: Double# -> Double# -> Double# -> Double#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubFloat# :: Float# -> Float# -> Float# -> Float#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubFloatX16# :: FloatX16# -> FloatX16# -> FloatX16# -> FloatX16#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubFloatX4# :: FloatX4# -> FloatX4# -> FloatX4# -> FloatX4#

-- | Fused multiply-subtract operation <tt>x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fmsubFloatX8# :: FloatX8# -> FloatX8# -> FloatX8# -> FloatX8#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddDouble# :: Double# -> Double# -> Double# -> Double#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddFloat# :: Float# -> Float# -> Float# -> Float#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddFloatX16# :: FloatX16# -> FloatX16# -> FloatX16# -> FloatX16#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddFloatX4# :: FloatX4# -> FloatX4# -> FloatX4# -> FloatX4#

-- | Fused negate-multiply-add operation <tt>-x*y+z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmaddFloatX8# :: FloatX8# -> FloatX8# -> FloatX8# -> FloatX8#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubDouble# :: Double# -> Double# -> Double# -> Double#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubFloat# :: Float# -> Float# -> Float# -> Float#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubFloatX16# :: FloatX16# -> FloatX16# -> FloatX16# -> FloatX16#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubFloatX4# :: FloatX4# -> FloatX4# -> FloatX4# -> FloatX4#

-- | Fused negate-multiply-subtract operation <tt>-x*y-z</tt>. See
--   <a>GHC.Prim#fma</a>.
fnmsubFloatX8# :: FloatX8# -> FloatX8# -> FloatX8# -> FloatX8#
fork# :: forall {q :: RuntimeRep} (a :: TYPE q). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
forkOn# :: forall {q :: RuntimeRep} (a :: TYPE q). Int# -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
freezeArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, Array# a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
freezeSmallArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallArray# a #)
geAddr# :: Addr# -> Addr# -> Int#
geChar# :: Char# -> Char# -> Int#
geFloat# :: Float# -> Float# -> Int#
geInt16# :: Int16# -> Int16# -> Int#
geInt32# :: Int32# -> Int32# -> Int#
geInt64# :: Int64# -> Int64# -> Int#
geInt8# :: Int8# -> Int8# -> Int#
geWord# :: Word# -> Word# -> Int#
geWord16# :: Word16# -> Word16# -> Int#
geWord32# :: Word32# -> Word32# -> Int#
geWord64# :: Word64# -> Word64# -> Int#
geWord8# :: Word8# -> Word8# -> Int#
getApStackVal# :: a -> Int# -> (# Int#, b #)
getCCSOf# :: a -> State# d -> (# State# d, Addr# #)

-- | Returns the current <tt>CostCentreStack</tt> (value is <tt>NULL</tt>
--   if not profiling). Takes a dummy argument which can be used to avoid
--   the call to <a>getCurrentCCS#</a> being floated out by the simplifier,
--   which would result in an uninformative stack (<a>CAF</a>).
getCurrentCCS# :: a -> State# d -> (# State# d, Addr# #)
getMaskingState# :: State# RealWorld -> (# State# RealWorld, Int# #)

-- | Return the number of elements in the array, correctly accounting for
--   the effect of <a>shrinkMutableByteArray#</a> and
--   <a>resizeMutableByteArray#</a>.
getSizeofMutableByteArray# :: MutableByteArray# d -> State# d -> (# State# d, Int# #)

-- | Return the number of elements in the array, correctly accounting for
--   the effect of <a>shrinkSmallMutableArray#</a> and
--   <tt>resizeSmallMutableArray#</tt>.
getSizeofSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> State# d -> (# State# d, Int# #)
getSpark# :: State# d -> (# State# d, Int#, a #)
gtAddr# :: Addr# -> Addr# -> Int#
gtChar# :: Char# -> Char# -> Int#
gtFloat# :: Float# -> Float# -> Int#
gtInt16# :: Int16# -> Int16# -> Int#
gtInt32# :: Int32# -> Int32# -> Int#
gtInt64# :: Int64# -> Int64# -> Int#
gtInt8# :: Int8# -> Int8# -> Int#
gtWord# :: Word# -> Word# -> Int#
gtWord16# :: Word16# -> Word16# -> Int#
gtWord32# :: Word32# -> Word32# -> Int#
gtWord64# :: Word64# -> Word64# -> Int#
gtWord8# :: Word8# -> Word8# -> Int#

-- | Read a machine address from immutable array; offset in machine words.
indexAddrArray# :: ByteArray# -> Int# -> Addr#

-- | Read a machine address from immutable address; offset in machine
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexAddrOffAddr# :: Addr# -> Int# -> Addr#

-- | Read from the specified index of an immutable array. The result is
--   packaged into an unboxed unary tuple; the result itself is not yet
--   evaluated. Pattern matching on the tuple forces the indexing of the
--   array to happen but does not evaluate the element itself. Evaluating
--   the thunk prevents additional thunks from building up on the heap.
--   Avoiding these thunks, in turn, reduces references to the argument
--   array, allowing it to be garbage collected more promptly.
indexArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Array# a -> Int# -> (# a #)

-- | Read an 8-bit character from immutable array; offset in bytes.
indexCharArray# :: ByteArray# -> Int# -> Char#

-- | Read an 8-bit character from immutable address; offset in bytes.
indexCharOffAddr# :: Addr# -> Int# -> Char#

-- | Read a double-precision floating-point value from immutable array;
--   offset in 8-byte words.
indexDoubleArray# :: ByteArray# -> Int# -> Double#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexDoubleArrayAsDoubleX2# :: ByteArray# -> Int# -> DoubleX2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexDoubleArrayAsDoubleX4# :: ByteArray# -> Int# -> DoubleX4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexDoubleArrayAsDoubleX8# :: ByteArray# -> Int# -> DoubleX8#

-- | Read a double-precision floating-point value from immutable address;
--   offset in 8-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexDoubleOffAddr# :: Addr# -> Int# -> Double#

-- | Reads vector; offset in scalar elements.
indexDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2#

-- | Reads vector; offset in scalar elements.
indexDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4#

-- | Reads vector; offset in scalar elements.
indexDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8#

-- | Read a vector from specified index of immutable array.
indexDoubleX2Array# :: ByteArray# -> Int# -> DoubleX2#

-- | Reads vector; offset in bytes.
indexDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2#

-- | Read a vector from specified index of immutable array.
indexDoubleX4Array# :: ByteArray# -> Int# -> DoubleX4#

-- | Reads vector; offset in bytes.
indexDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4#

-- | Read a vector from specified index of immutable array.
indexDoubleX8Array# :: ByteArray# -> Int# -> DoubleX8#

-- | Reads vector; offset in bytes.
indexDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8#

-- | Read a single-precision floating-point value from immutable array;
--   offset in 4-byte words.
indexFloatArray# :: ByteArray# -> Int# -> Float#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexFloatArrayAsFloatX16# :: ByteArray# -> Int# -> FloatX16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexFloatArrayAsFloatX4# :: ByteArray# -> Int# -> FloatX4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexFloatArrayAsFloatX8# :: ByteArray# -> Int# -> FloatX8#

-- | Read a single-precision floating-point value from immutable address;
--   offset in 4-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexFloatOffAddr# :: Addr# -> Int# -> Float#

-- | Reads vector; offset in scalar elements.
indexFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16#

-- | Reads vector; offset in scalar elements.
indexFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4#

-- | Reads vector; offset in scalar elements.
indexFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8#

-- | Read a vector from specified index of immutable array.
indexFloatX16Array# :: ByteArray# -> Int# -> FloatX16#

-- | Reads vector; offset in bytes.
indexFloatX16OffAddr# :: Addr# -> Int# -> FloatX16#

-- | Read a vector from specified index of immutable array.
indexFloatX4Array# :: ByteArray# -> Int# -> FloatX4#

-- | Reads vector; offset in bytes.
indexFloatX4OffAddr# :: Addr# -> Int# -> FloatX4#

-- | Read a vector from specified index of immutable array.
indexFloatX8Array# :: ByteArray# -> Int# -> FloatX8#

-- | Reads vector; offset in bytes.
indexFloatX8OffAddr# :: Addr# -> Int# -> FloatX8#

-- | Read a 16-bit signed integer from immutable array; offset in 2-byte
--   words.
indexInt16Array# :: ByteArray# -> Int# -> Int16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt16ArrayAsInt16X16# :: ByteArray# -> Int# -> Int16X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt16ArrayAsInt16X32# :: ByteArray# -> Int# -> Int16X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt16ArrayAsInt16X8# :: ByteArray# -> Int# -> Int16X8#

-- | Read a 16-bit signed integer from immutable address; offset in 2-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexInt16OffAddr# :: Addr# -> Int# -> Int16#

-- | Reads vector; offset in scalar elements.
indexInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16#

-- | Reads vector; offset in scalar elements.
indexInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32#

-- | Reads vector; offset in scalar elements.
indexInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8#

-- | Read a vector from specified index of immutable array.
indexInt16X16Array# :: ByteArray# -> Int# -> Int16X16#

-- | Reads vector; offset in bytes.
indexInt16X16OffAddr# :: Addr# -> Int# -> Int16X16#

-- | Read a vector from specified index of immutable array.
indexInt16X32Array# :: ByteArray# -> Int# -> Int16X32#

-- | Reads vector; offset in bytes.
indexInt16X32OffAddr# :: Addr# -> Int# -> Int16X32#

-- | Read a vector from specified index of immutable array.
indexInt16X8Array# :: ByteArray# -> Int# -> Int16X8#

-- | Reads vector; offset in bytes.
indexInt16X8OffAddr# :: Addr# -> Int# -> Int16X8#

-- | Read a 32-bit signed integer from immutable array; offset in 4-byte
--   words.
indexInt32Array# :: ByteArray# -> Int# -> Int32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt32ArrayAsInt32X16# :: ByteArray# -> Int# -> Int32X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt32ArrayAsInt32X4# :: ByteArray# -> Int# -> Int32X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt32ArrayAsInt32X8# :: ByteArray# -> Int# -> Int32X8#

-- | Read a 32-bit signed integer from immutable address; offset in 4-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexInt32OffAddr# :: Addr# -> Int# -> Int32#

-- | Reads vector; offset in scalar elements.
indexInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16#

-- | Reads vector; offset in scalar elements.
indexInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4#

-- | Reads vector; offset in scalar elements.
indexInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8#

-- | Read a vector from specified index of immutable array.
indexInt32X16Array# :: ByteArray# -> Int# -> Int32X16#

-- | Reads vector; offset in bytes.
indexInt32X16OffAddr# :: Addr# -> Int# -> Int32X16#

-- | Read a vector from specified index of immutable array.
indexInt32X4Array# :: ByteArray# -> Int# -> Int32X4#

-- | Reads vector; offset in bytes.
indexInt32X4OffAddr# :: Addr# -> Int# -> Int32X4#

-- | Read a vector from specified index of immutable array.
indexInt32X8Array# :: ByteArray# -> Int# -> Int32X8#

-- | Reads vector; offset in bytes.
indexInt32X8OffAddr# :: Addr# -> Int# -> Int32X8#

-- | Read a 64-bit signed integer from immutable array; offset in 8-byte
--   words.
indexInt64Array# :: ByteArray# -> Int# -> Int64#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt64ArrayAsInt64X2# :: ByteArray# -> Int# -> Int64X2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt64ArrayAsInt64X4# :: ByteArray# -> Int# -> Int64X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt64ArrayAsInt64X8# :: ByteArray# -> Int# -> Int64X8#

-- | Read a 64-bit signed integer from immutable address; offset in 8-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexInt64OffAddr# :: Addr# -> Int# -> Int64#

-- | Reads vector; offset in scalar elements.
indexInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2#

-- | Reads vector; offset in scalar elements.
indexInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4#

-- | Reads vector; offset in scalar elements.
indexInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8#

-- | Read a vector from specified index of immutable array.
indexInt64X2Array# :: ByteArray# -> Int# -> Int64X2#

-- | Reads vector; offset in bytes.
indexInt64X2OffAddr# :: Addr# -> Int# -> Int64X2#

-- | Read a vector from specified index of immutable array.
indexInt64X4Array# :: ByteArray# -> Int# -> Int64X4#

-- | Reads vector; offset in bytes.
indexInt64X4OffAddr# :: Addr# -> Int# -> Int64X4#

-- | Read a vector from specified index of immutable array.
indexInt64X8Array# :: ByteArray# -> Int# -> Int64X8#

-- | Reads vector; offset in bytes.
indexInt64X8OffAddr# :: Addr# -> Int# -> Int64X8#

-- | Read an 8-bit signed integer from immutable array; offset in bytes.
indexInt8Array# :: ByteArray# -> Int# -> Int8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt8ArrayAsInt8X16# :: ByteArray# -> Int# -> Int8X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt8ArrayAsInt8X32# :: ByteArray# -> Int# -> Int8X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt8ArrayAsInt8X64# :: ByteArray# -> Int# -> Int8X64#

-- | Read an 8-bit signed integer from immutable address; offset in bytes.
indexInt8OffAddr# :: Addr# -> Int# -> Int8#

-- | Reads vector; offset in scalar elements.
indexInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16#

-- | Reads vector; offset in scalar elements.
indexInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32#

-- | Reads vector; offset in scalar elements.
indexInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64#

-- | Read a vector from specified index of immutable array.
indexInt8X16Array# :: ByteArray# -> Int# -> Int8X16#

-- | Reads vector; offset in bytes.
indexInt8X16OffAddr# :: Addr# -> Int# -> Int8X16#

-- | Read a vector from specified index of immutable array.
indexInt8X32Array# :: ByteArray# -> Int# -> Int8X32#

-- | Reads vector; offset in bytes.
indexInt8X32OffAddr# :: Addr# -> Int# -> Int8X32#

-- | Read a vector from specified index of immutable array.
indexInt8X64Array# :: ByteArray# -> Int# -> Int8X64#

-- | Reads vector; offset in bytes.
indexInt8X64OffAddr# :: Addr# -> Int# -> Int8X64#

-- | Read a word-sized integer from immutable array; offset in machine
--   words.
indexIntArray# :: ByteArray# -> Int# -> Int#

-- | Read a word-sized integer from immutable address; offset in machine
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexIntOffAddr# :: Addr# -> Int# -> Int#

-- | Read from specified index of immutable array. Result is packaged into
--   an unboxed singleton; the result itself is not yet evaluated.
indexSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). SmallArray# a -> Int# -> (# a #)

-- | Read a <a>StablePtr#</a> value from immutable array; offset in machine
--   words.
indexStablePtrArray# :: ByteArray# -> Int# -> StablePtr# a

-- | Read a <a>StablePtr#</a> value from immutable address; offset in
--   machine words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a

-- | Read a 32-bit character from immutable array; offset in 4-byte words.
indexWideCharArray# :: ByteArray# -> Int# -> Char#

-- | Read a 32-bit character from immutable address; offset in 4-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexWideCharOffAddr# :: Addr# -> Int# -> Char#

-- | Read a 16-bit unsigned integer from immutable array; offset in 2-byte
--   words.
indexWord16Array# :: ByteArray# -> Int# -> Word16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord16ArrayAsWord16X16# :: ByteArray# -> Int# -> Word16X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord16ArrayAsWord16X32# :: ByteArray# -> Int# -> Word16X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord16ArrayAsWord16X8# :: ByteArray# -> Int# -> Word16X8#

-- | Read a 16-bit unsigned integer from immutable address; offset in
--   2-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexWord16OffAddr# :: Addr# -> Int# -> Word16#

-- | Reads vector; offset in scalar elements.
indexWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16#

-- | Reads vector; offset in scalar elements.
indexWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32#

-- | Reads vector; offset in scalar elements.
indexWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8#

-- | Read a vector from specified index of immutable array.
indexWord16X16Array# :: ByteArray# -> Int# -> Word16X16#

-- | Reads vector; offset in bytes.
indexWord16X16OffAddr# :: Addr# -> Int# -> Word16X16#

-- | Read a vector from specified index of immutable array.
indexWord16X32Array# :: ByteArray# -> Int# -> Word16X32#

-- | Reads vector; offset in bytes.
indexWord16X32OffAddr# :: Addr# -> Int# -> Word16X32#

-- | Read a vector from specified index of immutable array.
indexWord16X8Array# :: ByteArray# -> Int# -> Word16X8#

-- | Reads vector; offset in bytes.
indexWord16X8OffAddr# :: Addr# -> Int# -> Word16X8#

-- | Read a 32-bit unsigned integer from immutable array; offset in 4-byte
--   words.
indexWord32Array# :: ByteArray# -> Int# -> Word32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord32ArrayAsWord32X16# :: ByteArray# -> Int# -> Word32X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord32ArrayAsWord32X4# :: ByteArray# -> Int# -> Word32X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord32ArrayAsWord32X8# :: ByteArray# -> Int# -> Word32X8#

-- | Read a 32-bit unsigned integer from immutable address; offset in
--   4-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexWord32OffAddr# :: Addr# -> Int# -> Word32#

-- | Reads vector; offset in scalar elements.
indexWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16#

-- | Reads vector; offset in scalar elements.
indexWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4#

-- | Reads vector; offset in scalar elements.
indexWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8#

-- | Read a vector from specified index of immutable array.
indexWord32X16Array# :: ByteArray# -> Int# -> Word32X16#

-- | Reads vector; offset in bytes.
indexWord32X16OffAddr# :: Addr# -> Int# -> Word32X16#

-- | Read a vector from specified index of immutable array.
indexWord32X4Array# :: ByteArray# -> Int# -> Word32X4#

-- | Reads vector; offset in bytes.
indexWord32X4OffAddr# :: Addr# -> Int# -> Word32X4#

-- | Read a vector from specified index of immutable array.
indexWord32X8Array# :: ByteArray# -> Int# -> Word32X8#

-- | Reads vector; offset in bytes.
indexWord32X8OffAddr# :: Addr# -> Int# -> Word32X8#

-- | Read a 64-bit unsigned integer from immutable array; offset in 8-byte
--   words.
indexWord64Array# :: ByteArray# -> Int# -> Word64#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord64ArrayAsWord64X2# :: ByteArray# -> Int# -> Word64X2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord64ArrayAsWord64X4# :: ByteArray# -> Int# -> Word64X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord64ArrayAsWord64X8# :: ByteArray# -> Int# -> Word64X8#

-- | Read a 64-bit unsigned integer from immutable address; offset in
--   8-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexWord64OffAddr# :: Addr# -> Int# -> Word64#

-- | Reads vector; offset in scalar elements.
indexWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2#

-- | Reads vector; offset in scalar elements.
indexWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4#

-- | Reads vector; offset in scalar elements.
indexWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8#

-- | Read a vector from specified index of immutable array.
indexWord64X2Array# :: ByteArray# -> Int# -> Word64X2#

-- | Reads vector; offset in bytes.
indexWord64X2OffAddr# :: Addr# -> Int# -> Word64X2#

-- | Read a vector from specified index of immutable array.
indexWord64X4Array# :: ByteArray# -> Int# -> Word64X4#

-- | Reads vector; offset in bytes.
indexWord64X4OffAddr# :: Addr# -> Int# -> Word64X4#

-- | Read a vector from specified index of immutable array.
indexWord64X8Array# :: ByteArray# -> Int# -> Word64X8#

-- | Reads vector; offset in bytes.
indexWord64X8OffAddr# :: Addr# -> Int# -> Word64X8#

-- | Read an 8-bit unsigned integer from immutable array; offset in bytes.
indexWord8Array# :: ByteArray# -> Int# -> Word8#

-- | Read a machine address from immutable array; offset in bytes.
indexWord8ArrayAsAddr# :: ByteArray# -> Int# -> Addr#

-- | Read an 8-bit character from immutable array; offset in bytes.
indexWord8ArrayAsChar# :: ByteArray# -> Int# -> Char#

-- | Read a double-precision floating-point value from immutable array;
--   offset in bytes.
indexWord8ArrayAsDouble# :: ByteArray# -> Int# -> Double#

-- | Read a single-precision floating-point value from immutable array;
--   offset in bytes.
indexWord8ArrayAsFloat# :: ByteArray# -> Int# -> Float#

-- | Read a word-sized integer from immutable array; offset in bytes.
indexWord8ArrayAsInt# :: ByteArray# -> Int# -> Int#

-- | Read a 16-bit signed integer from immutable array; offset in bytes.
indexWord8ArrayAsInt16# :: ByteArray# -> Int# -> Int16#

-- | Read a 32-bit signed integer from immutable array; offset in bytes.
indexWord8ArrayAsInt32# :: ByteArray# -> Int# -> Int32#

-- | Read a 64-bit signed integer from immutable array; offset in bytes.
indexWord8ArrayAsInt64# :: ByteArray# -> Int# -> Int64#

-- | Read a <a>StablePtr#</a> value from immutable array; offset in bytes.
indexWord8ArrayAsStablePtr# :: ByteArray# -> Int# -> StablePtr# a

-- | Read a 32-bit character from immutable array; offset in bytes.
indexWord8ArrayAsWideChar# :: ByteArray# -> Int# -> Char#

-- | Read a word-sized unsigned integer from immutable array; offset in
--   bytes.
indexWord8ArrayAsWord# :: ByteArray# -> Int# -> Word#

-- | Read a 16-bit unsigned integer from immutable array; offset in bytes.
indexWord8ArrayAsWord16# :: ByteArray# -> Int# -> Word16#

-- | Read a 32-bit unsigned integer from immutable array; offset in bytes.
indexWord8ArrayAsWord32# :: ByteArray# -> Int# -> Word32#

-- | Read a 64-bit unsigned integer from immutable array; offset in bytes.
indexWord8ArrayAsWord64# :: ByteArray# -> Int# -> Word64#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord8ArrayAsWord8X16# :: ByteArray# -> Int# -> Word8X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord8ArrayAsWord8X32# :: ByteArray# -> Int# -> Word8X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord8ArrayAsWord8X64# :: ByteArray# -> Int# -> Word8X64#

-- | Read an 8-bit unsigned integer from immutable address; offset in
--   bytes.
indexWord8OffAddr# :: Addr# -> Int# -> Word8#

-- | Read a machine address from immutable address; offset in bytes.
indexWord8OffAddrAsAddr# :: Addr# -> Int# -> Addr#

-- | Read an 8-bit character from immutable address; offset in bytes.
indexWord8OffAddrAsChar# :: Addr# -> Int# -> Char#

-- | Read a double-precision floating-point value from immutable address;
--   offset in bytes.
indexWord8OffAddrAsDouble# :: Addr# -> Int# -> Double#

-- | Read a single-precision floating-point value from immutable address;
--   offset in bytes.
indexWord8OffAddrAsFloat# :: Addr# -> Int# -> Float#

-- | Read a word-sized integer from immutable address; offset in bytes.
indexWord8OffAddrAsInt# :: Addr# -> Int# -> Int#

-- | Read a 16-bit signed integer from immutable address; offset in bytes.
indexWord8OffAddrAsInt16# :: Addr# -> Int# -> Int16#

-- | Read a 32-bit signed integer from immutable address; offset in bytes.
indexWord8OffAddrAsInt32# :: Addr# -> Int# -> Int32#

-- | Read a 64-bit signed integer from immutable address; offset in bytes.
indexWord8OffAddrAsInt64# :: Addr# -> Int# -> Int64#

-- | Read a <a>StablePtr#</a> value from immutable address; offset in
--   bytes.
indexWord8OffAddrAsStablePtr# :: Addr# -> Int# -> StablePtr# a

-- | Read a 32-bit character from immutable address; offset in bytes.
indexWord8OffAddrAsWideChar# :: Addr# -> Int# -> Char#

-- | Read a word-sized unsigned integer from immutable address; offset in
--   bytes.
indexWord8OffAddrAsWord# :: Addr# -> Int# -> Word#

-- | Read a 16-bit unsigned integer from immutable address; offset in
--   bytes.
indexWord8OffAddrAsWord16# :: Addr# -> Int# -> Word16#

-- | Read a 32-bit unsigned integer from immutable address; offset in
--   bytes.
indexWord8OffAddrAsWord32# :: Addr# -> Int# -> Word32#

-- | Read a 64-bit unsigned integer from immutable address; offset in
--   bytes.
indexWord8OffAddrAsWord64# :: Addr# -> Int# -> Word64#

-- | Reads vector; offset in scalar elements.
indexWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16#

-- | Reads vector; offset in scalar elements.
indexWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32#

-- | Reads vector; offset in scalar elements.
indexWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64#

-- | Read a vector from specified index of immutable array.
indexWord8X16Array# :: ByteArray# -> Int# -> Word8X16#

-- | Reads vector; offset in bytes.
indexWord8X16OffAddr# :: Addr# -> Int# -> Word8X16#

-- | Read a vector from specified index of immutable array.
indexWord8X32Array# :: ByteArray# -> Int# -> Word8X32#

-- | Reads vector; offset in bytes.
indexWord8X32OffAddr# :: Addr# -> Int# -> Word8X32#

-- | Read a vector from specified index of immutable array.
indexWord8X64Array# :: ByteArray# -> Int# -> Word8X64#

-- | Reads vector; offset in bytes.
indexWord8X64OffAddr# :: Addr# -> Int# -> Word8X64#

-- | Read a word-sized unsigned integer from immutable array; offset in
--   machine words.
indexWordArray# :: ByteArray# -> Int# -> Word#

-- | Read a word-sized unsigned integer from immutable address; offset in
--   machine words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
indexWordOffAddr# :: Addr# -> Int# -> Word#

-- | Insert a scalar at the given position in a vector.
insertDoubleX2# :: DoubleX2# -> Double# -> Int# -> DoubleX2#

-- | Insert a scalar at the given position in a vector.
insertDoubleX4# :: DoubleX4# -> Double# -> Int# -> DoubleX4#

-- | Insert a scalar at the given position in a vector.
insertDoubleX8# :: DoubleX8# -> Double# -> Int# -> DoubleX8#

-- | Insert a scalar at the given position in a vector.
insertFloatX16# :: FloatX16# -> Float# -> Int# -> FloatX16#

-- | Insert a scalar at the given position in a vector.
insertFloatX4# :: FloatX4# -> Float# -> Int# -> FloatX4#

-- | Insert a scalar at the given position in a vector.
insertFloatX8# :: FloatX8# -> Float# -> Int# -> FloatX8#

-- | Insert a scalar at the given position in a vector.
insertInt16X16# :: Int16X16# -> Int16# -> Int# -> Int16X16#

-- | Insert a scalar at the given position in a vector.
insertInt16X32# :: Int16X32# -> Int16# -> Int# -> Int16X32#

-- | Insert a scalar at the given position in a vector.
insertInt16X8# :: Int16X8# -> Int16# -> Int# -> Int16X8#

-- | Insert a scalar at the given position in a vector.
insertInt32X16# :: Int32X16# -> Int32# -> Int# -> Int32X16#

-- | Insert a scalar at the given position in a vector.
insertInt32X4# :: Int32X4# -> Int32# -> Int# -> Int32X4#

-- | Insert a scalar at the given position in a vector.
insertInt32X8# :: Int32X8# -> Int32# -> Int# -> Int32X8#

-- | Insert a scalar at the given position in a vector.
insertInt64X2# :: Int64X2# -> Int64# -> Int# -> Int64X2#

-- | Insert a scalar at the given position in a vector.
insertInt64X4# :: Int64X4# -> Int64# -> Int# -> Int64X4#

-- | Insert a scalar at the given position in a vector.
insertInt64X8# :: Int64X8# -> Int64# -> Int# -> Int64X8#

-- | Insert a scalar at the given position in a vector.
insertInt8X16# :: Int8X16# -> Int8# -> Int# -> Int8X16#

-- | Insert a scalar at the given position in a vector.
insertInt8X32# :: Int8X32# -> Int8# -> Int# -> Int8X32#

-- | Insert a scalar at the given position in a vector.
insertInt8X64# :: Int8X64# -> Int8# -> Int# -> Int8X64#

-- | Insert a scalar at the given position in a vector.
insertWord16X16# :: Word16X16# -> Word16# -> Int# -> Word16X16#

-- | Insert a scalar at the given position in a vector.
insertWord16X32# :: Word16X32# -> Word16# -> Int# -> Word16X32#

-- | Insert a scalar at the given position in a vector.
insertWord16X8# :: Word16X8# -> Word16# -> Int# -> Word16X8#

-- | Insert a scalar at the given position in a vector.
insertWord32X16# :: Word32X16# -> Word32# -> Int# -> Word32X16#

-- | Insert a scalar at the given position in a vector.
insertWord32X4# :: Word32X4# -> Word32# -> Int# -> Word32X4#

-- | Insert a scalar at the given position in a vector.
insertWord32X8# :: Word32X8# -> Word32# -> Int# -> Word32X8#

-- | Insert a scalar at the given position in a vector.
insertWord64X2# :: Word64X2# -> Word64# -> Int# -> Word64X2#

-- | Insert a scalar at the given position in a vector.
insertWord64X4# :: Word64X4# -> Word64# -> Int# -> Word64X4#

-- | Insert a scalar at the given position in a vector.
insertWord64X8# :: Word64X8# -> Word64# -> Int# -> Word64X8#

-- | Insert a scalar at the given position in a vector.
insertWord8X16# :: Word8X16# -> Word8# -> Int# -> Word8X16#

-- | Insert a scalar at the given position in a vector.
insertWord8X32# :: Word8X32# -> Word8# -> Int# -> Word8X32#

-- | Insert a scalar at the given position in a vector.
insertWord8X64# :: Word8X64# -> Word8# -> Int# -> Word8X64#
int16ToInt# :: Int16# -> Int#
int16ToWord16# :: Int16# -> Word16#

-- | Coerce directly from int to address. Users are discouraged from using
--   this operation as it makes little sense on platforms with tagged
--   pointers.
int2Addr# :: Int# -> Addr#

-- | Convert an <a>Int#</a> to the corresponding <a>Double#</a> with the
--   same integral value (up to truncation due to floating-point
--   precision). e.g. <tt><a>int2Double#</a> 1# == 1.0##</tt>
int2Double# :: Int# -> Double#

-- | Convert an <a>Int#</a> to the corresponding <a>Float#</a> with the
--   same integral value (up to truncation due to floating-point
--   precision). e.g. <tt><a>int2Float#</a> 1# == 1.0#</tt>
int2Float# :: Int# -> Float#
int2Word# :: Int# -> Word#
int32ToInt# :: Int32# -> Int#
int32ToWord32# :: Int32# -> Word32#
int64ToInt# :: Int64# -> Int#
int64ToWord64# :: Int64# -> Word64#
int8ToInt# :: Int8# -> Int#
int8ToWord8# :: Int8# -> Word8#
intToInt16# :: Int# -> Int16#
intToInt32# :: Int# -> Int32#
intToInt64# :: Int# -> Int64#
intToInt8# :: Int# -> Int8#

-- | Determine whether a <a>ByteArray#</a> is guaranteed not to move.
isByteArrayPinned# :: ByteArray# -> Int#

-- | Similar to <a>isByteArrayPinned#</a>. Weakly pinned byte arrays are
--   allowed to be copied into compact regions by the user, potentially
--   invalidating the results of earlier calls to
--   <a>byteArrayContents#</a>.
--   
--   See the section `Pinned Byte Arrays` in the user guide for more
--   information.
--   
--   This function also returns true for regular pinned bytearrays.
isByteArrayWeaklyPinned# :: ByteArray# -> Int#
isCurrentThreadBound# :: State# RealWorld -> (# State# RealWorld, Int# #)

-- | Return 1 if <a>MVar#</a> is empty; 0 otherwise.
isEmptyMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> State# d -> (# State# d, Int# #)

-- | Determine whether a <a>MutableByteArray#</a> is guaranteed not to move
--   during GC.
isMutableByteArrayPinned# :: MutableByteArray# d -> Int#

-- | <a>isByteArrayWeaklyPinned#</a> but for mutable arrays.
isMutableByteArrayWeaklyPinned# :: MutableByteArray# d -> Int#

-- | <tt><a>keepAlive#</a> x s k</tt> keeps the value <tt>x</tt> alive
--   during the execution of the computation <tt>k</tt>.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
keepAlive# :: forall {l :: Levity} {r :: RuntimeRep} (a :: TYPE ('BoxedRep l)) d (b :: TYPE r). a -> State# d -> (State# d -> b) -> b
killThread# :: ThreadId# -> a -> State# RealWorld -> State# RealWorld

-- | Set the label of the given thread. The <tt>ByteArray#</tt> should
--   contain a UTF-8-encoded string.
labelThread# :: ThreadId# -> ByteArray# -> State# RealWorld -> State# RealWorld
leAddr# :: Addr# -> Addr# -> Int#
leChar# :: Char# -> Char# -> Int#
leFloat# :: Float# -> Float# -> Int#
leInt16# :: Int16# -> Int16# -> Int#
leInt32# :: Int32# -> Int32# -> Int#
leInt64# :: Int64# -> Int64# -> Int#
leInt8# :: Int8# -> Int8# -> Int#
leWord# :: Word# -> Word# -> Int#
leWord16# :: Word16# -> Word16# -> Int#
leWord32# :: Word32# -> Word32# -> Int#
leWord64# :: Word64# -> Word64# -> Int#
leWord8# :: Word8# -> Word8# -> Int#
leftSection :: forall {q :: RuntimeRep} {r :: RuntimeRep} {n :: Multiplicity} (a :: TYPE q) (b :: TYPE r). (a %n -> b) -> a %n -> b

-- | Returns an array of the threads started by the program. Note that this
--   threads which have finished execution may or may not be present in
--   this list, depending upon whether they have been collected by the
--   garbage collector.
listThreads# :: State# RealWorld -> (# State# RealWorld, Array# ThreadId# #)
log1pDouble# :: Double# -> Double#
log1pFloat# :: Float# -> Float#
logDouble# :: Double# -> Double#
logFloat# :: Float# -> Float#
ltAddr# :: Addr# -> Addr# -> Int#
ltChar# :: Char# -> Char# -> Int#
ltFloat# :: Float# -> Float# -> Int#
ltInt16# :: Int16# -> Int16# -> Int#
ltInt32# :: Int32# -> Int32# -> Int#
ltInt64# :: Int64# -> Int64# -> Int#
ltInt8# :: Int8# -> Int8# -> Int#
ltWord# :: Word# -> Word# -> Int#
ltWord16# :: Word16# -> Word16# -> Int#
ltWord32# :: Word32# -> Word32# -> Int#
ltWord64# :: Word64# -> Word64# -> Int#
ltWord8# :: Word8# -> Word8# -> Int#
makeStableName# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). a -> State# RealWorld -> (# State# RealWorld, StableName# a #)
makeStablePtr# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). a -> State# RealWorld -> (# State# RealWorld, StablePtr# a #)

-- | <tt><a>maskAsyncExceptions#</a> k s</tt> evaluates <tt>k s</tt> such
--   that asynchronous exceptions are deferred until after evaluation has
--   finished.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
maskAsyncExceptions# :: forall {q :: RuntimeRep} (a :: TYPE q). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)

-- | <tt><a>maskUninterruptible#</a> k s</tt> evaluates <tt>k s</tt> such
--   that asynchronous exceptions are deferred until after evaluation has
--   finished.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
maskUninterruptible# :: forall {q :: RuntimeRep} (a :: TYPE q). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
maxDouble# :: Double# -> Double# -> Double#

-- | Component-wise maximum of two vectors.
maxDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Component-wise maximum of two vectors.
maxDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Component-wise maximum of two vectors.
maxDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
maxFloat# :: Float# -> Float# -> Float#

-- | Component-wise maximum of two vectors.
maxFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Component-wise maximum of two vectors.
maxFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Component-wise maximum of two vectors.
maxFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Component-wise maximum of two vectors.
maxInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Component-wise maximum of two vectors.
maxInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Component-wise maximum of two vectors.
maxInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Component-wise maximum of two vectors.
maxInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Component-wise maximum of two vectors.
maxInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Component-wise maximum of two vectors.
maxInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Component-wise maximum of two vectors.
maxInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Component-wise maximum of two vectors.
maxInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Component-wise maximum of two vectors.
maxInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Component-wise maximum of two vectors.
maxInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Component-wise maximum of two vectors.
maxInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Component-wise maximum of two vectors.
maxInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Component-wise maximum of two vectors.
maxWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Component-wise maximum of two vectors.
maxWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Component-wise maximum of two vectors.
maxWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Component-wise maximum of two vectors.
maxWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Component-wise maximum of two vectors.
maxWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Component-wise maximum of two vectors.
maxWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Component-wise maximum of two vectors.
maxWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Component-wise maximum of two vectors.
maxWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Component-wise maximum of two vectors.
maxWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Component-wise maximum of two vectors.
maxWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Component-wise maximum of two vectors.
maxWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Component-wise maximum of two vectors.
maxWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
minDouble# :: Double# -> Double# -> Double#

-- | Component-wise minimum of two vectors.
minDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Component-wise minimum of two vectors.
minDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Component-wise minimum of two vectors.
minDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
minFloat# :: Float# -> Float# -> Float#

-- | Component-wise minimum of two vectors.
minFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Component-wise minimum of two vectors.
minFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Component-wise minimum of two vectors.
minFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Component-wise minimum of two vectors.
minInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Component-wise minimum of two vectors.
minInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Component-wise minimum of two vectors.
minInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Component-wise minimum of two vectors.
minInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Component-wise minimum of two vectors.
minInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Component-wise minimum of two vectors.
minInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Component-wise minimum of two vectors.
minInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Component-wise minimum of two vectors.
minInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Component-wise minimum of two vectors.
minInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Component-wise minimum of two vectors.
minInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Component-wise minimum of two vectors.
minInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Component-wise minimum of two vectors.
minInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Component-wise minimum of two vectors.
minWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Component-wise minimum of two vectors.
minWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Component-wise minimum of two vectors.
minWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Component-wise minimum of two vectors.
minWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Component-wise minimum of two vectors.
minWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Component-wise minimum of two vectors.
minWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Component-wise minimum of two vectors.
minWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Component-wise minimum of two vectors.
minWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Component-wise minimum of two vectors.
minWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Component-wise minimum of two vectors.
minWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Component-wise minimum of two vectors.
minWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Component-wise minimum of two vectors.
minWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Result is meaningless if two <a>Addr#</a>s are so far apart that their
--   difference doesn't fit in an <a>Int#</a>.
minusAddr# :: Addr# -> Addr# -> Int#

-- | Subtract two vectors element-wise.
minusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Subtract two vectors element-wise.
minusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Subtract two vectors element-wise.
minusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
minusFloat# :: Float# -> Float# -> Float#

-- | Subtract two vectors element-wise.
minusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Subtract two vectors element-wise.
minusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Subtract two vectors element-wise.
minusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Subtract two vectors element-wise.
minusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Subtract two vectors element-wise.
minusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Subtract two vectors element-wise.
minusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Subtract two vectors element-wise.
minusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Subtract two vectors element-wise.
minusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Subtract two vectors element-wise.
minusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Subtract two vectors element-wise.
minusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Subtract two vectors element-wise.
minusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Subtract two vectors element-wise.
minusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Subtract two vectors element-wise.
minusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Subtract two vectors element-wise.
minusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Subtract two vectors element-wise.
minusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
minusWord# :: Word# -> Word# -> Word#

-- | Subtract two vectors element-wise.
minusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Subtract two vectors element-wise.
minusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Subtract two vectors element-wise.
minusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Subtract two vectors element-wise.
minusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Subtract two vectors element-wise.
minusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Subtract two vectors element-wise.
minusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Subtract two vectors element-wise.
minusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Subtract two vectors element-wise.
minusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Subtract two vectors element-wise.
minusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Subtract two vectors element-wise.
minusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Subtract two vectors element-wise.
minusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Subtract two vectors element-wise.
minusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Wrap a BCO in a <tt>AP_UPD</tt> thunk which will be updated with the
--   value of the BCO when evaluated.
mkApUpd0# :: BCO -> (# a #)

-- | <tt><a>mkWeak#</a> k v finalizer s</tt> creates a weak reference to
--   value <tt>k</tt>, with an associated reference to some value
--   <tt>v</tt>. If <tt>k</tt> is still alive then <tt>v</tt> can be
--   retrieved using <a>deRefWeak#</a>. Note that the type of <tt>k</tt>
--   must be represented by a pointer (i.e. of kind <tt><tt>TYPE</tt>
--   '<tt>LiftedRep</tt> or </tt><tt>TYPE</tt> '<tt>UnliftedRep</tt>@).
mkWeak# :: forall {l :: Levity} {k :: Levity} (a :: TYPE ('BoxedRep l)) (b :: TYPE ('BoxedRep k)) c. a -> b -> (State# RealWorld -> (# State# RealWorld, c #)) -> State# RealWorld -> (# State# RealWorld, Weak# b #)
mkWeakNoFinalizer# :: forall {l :: Levity} {k :: Levity} (a :: TYPE ('BoxedRep l)) (b :: TYPE ('BoxedRep k)). a -> b -> State# RealWorld -> (# State# RealWorld, Weak# b #)

-- | Return non-zero if there is any possibility that the upper word of a
--   signed integer multiply might contain useful information. Return zero
--   only if you are completely sure that no overflow can occur. On a
--   32-bit platform, the recommended implementation is to do a 32 x 32
--   -&gt; 64 signed multiply, and subtract result[63:32] from (result[31]
--   &gt;&gt;signed 31). If this is zero, meaning that the upper word is
--   merely a sign extension of the lower one, no overflow can occur.
--   
--   On a 64-bit platform it is not always possible to acquire the top 64
--   bits of the result. Therefore, a recommended implementation is to take
--   the absolute value of both operands, and return 0 iff bits[63:31] of
--   them are zero, since that means that their magnitudes fit within 31
--   bits, so the magnitude of the product must fit into 62 bits.
--   
--   If in doubt, return non-zero, but do make an effort to create the
--   correct answer for small args, since otherwise the performance of
--   <tt>(*) :: Integer -&gt; Integer -&gt; Integer</tt> will be poor.
mulIntMayOflo# :: Int# -> Int# -> Int#

-- | Intended for use with pinned arrays; otherwise very unsafe!
mutableByteArrayContents# :: MutableByteArray# d -> Addr#
myThreadId# :: State# RealWorld -> (# State# RealWorld, ThreadId# #)
narrow16Int# :: Int# -> Int#
narrow16Word# :: Word# -> Word#
narrow32Int# :: Int# -> Int#
narrow32Word# :: Word# -> Word#
narrow8Int# :: Int# -> Int#
narrow8Word# :: Word# -> Word#
neAddr# :: Addr# -> Addr# -> Int#
neChar# :: Char# -> Char# -> Int#
neFloat# :: Float# -> Float# -> Int#
neInt16# :: Int16# -> Int16# -> Int#
neInt32# :: Int32# -> Int32# -> Int#
neInt64# :: Int64# -> Int64# -> Int#
neInt8# :: Int8# -> Int8# -> Int#
neWord# :: Word# -> Word# -> Int#
neWord16# :: Word16# -> Word16# -> Int#
neWord32# :: Word32# -> Word32# -> Int#
neWord64# :: Word64# -> Word64# -> Int#
neWord8# :: Word8# -> Word8# -> Int#
negateDouble# :: Double# -> Double#

-- | Negate element-wise.
negateDoubleX2# :: DoubleX2# -> DoubleX2#

-- | Negate element-wise.
negateDoubleX4# :: DoubleX4# -> DoubleX4#

-- | Negate element-wise.
negateDoubleX8# :: DoubleX8# -> DoubleX8#
negateFloat# :: Float# -> Float#

-- | Negate element-wise.
negateFloatX16# :: FloatX16# -> FloatX16#

-- | Negate element-wise.
negateFloatX4# :: FloatX4# -> FloatX4#

-- | Negate element-wise.
negateFloatX8# :: FloatX8# -> FloatX8#

-- | Unary negation. Since the negative <a>Int#</a> range extends one
--   further than the positive range, <a>negateInt#</a> of the most
--   negative number is an identity operation. This way, <a>negateInt#</a>
--   is always its own inverse.
negateInt# :: Int# -> Int#
negateInt16# :: Int16# -> Int16#

-- | Negate element-wise.
negateInt16X16# :: Int16X16# -> Int16X16#

-- | Negate element-wise.
negateInt16X32# :: Int16X32# -> Int16X32#

-- | Negate element-wise.
negateInt16X8# :: Int16X8# -> Int16X8#
negateInt32# :: Int32# -> Int32#

-- | Negate element-wise.
negateInt32X16# :: Int32X16# -> Int32X16#

-- | Negate element-wise.
negateInt32X4# :: Int32X4# -> Int32X4#

-- | Negate element-wise.
negateInt32X8# :: Int32X8# -> Int32X8#
negateInt64# :: Int64# -> Int64#

-- | Negate element-wise.
negateInt64X2# :: Int64X2# -> Int64X2#

-- | Negate element-wise.
negateInt64X4# :: Int64X4# -> Int64X4#

-- | Negate element-wise.
negateInt64X8# :: Int64X8# -> Int64X8#
negateInt8# :: Int8# -> Int8#

-- | Negate element-wise.
negateInt8X16# :: Int8X16# -> Int8X16#

-- | Negate element-wise.
negateInt8X32# :: Int8X32# -> Int8X32#

-- | Negate element-wise.
negateInt8X64# :: Int8X64# -> Int8X64#

-- | Like <a>newPinnedByteArray#</a> but allow specifying an arbitrary
--   alignment, which must be a power of two.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
newAlignedPinnedByteArray# :: Int# -> Int# -> State# d -> (# State# d, MutableByteArray# d #)

-- | Create a new mutable array with the specified number of elements, in
--   the specified state thread, with each element containing the specified
--   initial value.
newArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. Int# -> a -> State# d -> (# State# d, MutableArray# d a #)

-- | <tt><a>newBCO#</a> instrs lits ptrs arity bitmap</tt> creates a new
--   bytecode object. The resulting object encodes a function of the given
--   arity with the instructions encoded in <tt>instrs</tt>, and a static
--   reference table usage bitmap given by <tt>bitmap</tt>.
newBCO# :: ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# d -> (# State# d, BCO #)

-- | Create a new mutable byte array of specified size (in bytes), in the
--   specified state thread. The size of the memory underlying the array
--   will be rounded up to the platform's word size.
newByteArray# :: Int# -> State# d -> (# State# d, MutableByteArray# d #)

-- | Create new <a>IOPort#</a>; initially empty.
newIOPort# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). State# d -> (# State# d, IOPort# d a #)

-- | Create new <a>MVar#</a>; initially empty.
newMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). State# d -> (# State# d, MVar# d a #)

-- | Create <a>MutVar#</a> with specified initial value in specified state
--   thread.
newMutVar# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. a -> State# d -> (# State# d, MutVar# d a #)

-- | Like <a>newByteArray#</a> but GC guarantees not to move it.
newPinnedByteArray# :: Int# -> State# d -> (# State# d, MutableByteArray# d #)

-- | See <a>GHC.Prim#continuations</a>.
newPromptTag# :: State# RealWorld -> (# State# RealWorld, PromptTag# a #)

-- | Create a new mutable array with the specified number of elements, in
--   the specified state thread, with each element containing the specified
--   initial value.
newSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. Int# -> a -> State# d -> (# State# d, SmallMutableArray# d a #)

-- | Create a new <a>TVar#</a> holding a specified initial value.
newTVar# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. a -> State# d -> (# State# d, TVar# d a #)
noDuplicate# :: State# d -> State# d
not# :: Word# -> Word#
not64# :: Word64# -> Word64#

-- | Bitwise "not", also known as the binary complement.
notI# :: Int# -> Int#
notWord16# :: Word16# -> Word16#
notWord32# :: Word32# -> Word32#
notWord8# :: Word8# -> Word8#

-- | The null address.
nullAddr# :: Addr#

-- | Returns the number of sparks in the local spark pool.
numSparks# :: State# d -> (# State# d, Int# #)
or# :: Word# -> Word# -> Word#
or64# :: Word64# -> Word64# -> Word64#

-- | Bitwise "or".
orI# :: Int# -> Int# -> Int#
orWord16# :: Word16# -> Word16# -> Word16#
orWord32# :: Word32# -> Word32# -> Word32#
orWord8# :: Word8# -> Word8# -> Word8#
ord# :: Char# -> Int#

-- | Pack the elements of an unboxed tuple into a vector.
packDoubleX2# :: (# Double#, Double# #) -> DoubleX2#

-- | Pack the elements of an unboxed tuple into a vector.
packDoubleX4# :: (# Double#, Double#, Double#, Double# #) -> DoubleX4#

-- | Pack the elements of an unboxed tuple into a vector.
packDoubleX8# :: (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #) -> DoubleX8#

-- | Pack the elements of an unboxed tuple into a vector.
packFloatX16# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX16#

-- | Pack the elements of an unboxed tuple into a vector.
packFloatX4# :: (# Float#, Float#, Float#, Float# #) -> FloatX4#

-- | Pack the elements of an unboxed tuple into a vector.
packFloatX8# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX8#

-- | Pack the elements of an unboxed tuple into a vector.
packInt16X16# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X16#

-- | Pack the elements of an unboxed tuple into a vector.
packInt16X32# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X32#

-- | Pack the elements of an unboxed tuple into a vector.
packInt16X8# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X8#

-- | Pack the elements of an unboxed tuple into a vector.
packInt32X16# :: (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #) -> Int32X16#

-- | Pack the elements of an unboxed tuple into a vector.
packInt32X4# :: (# Int32#, Int32#, Int32#, Int32# #) -> Int32X4#

-- | Pack the elements of an unboxed tuple into a vector.
packInt32X8# :: (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #) -> Int32X8#

-- | Pack the elements of an unboxed tuple into a vector.
packInt64X2# :: (# Int64#, Int64# #) -> Int64X2#

-- | Pack the elements of an unboxed tuple into a vector.
packInt64X4# :: (# Int64#, Int64#, Int64#, Int64# #) -> Int64X4#

-- | Pack the elements of an unboxed tuple into a vector.
packInt64X8# :: (# Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64# #) -> Int64X8#

-- | Pack the elements of an unboxed tuple into a vector.
packInt8X16# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X16#

-- | Pack the elements of an unboxed tuple into a vector.
packInt8X32# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X32#

-- | Pack the elements of an unboxed tuple into a vector.
packInt8X64# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X64#

-- | Pack the elements of an unboxed tuple into a vector.
packWord16X16# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X16#

-- | Pack the elements of an unboxed tuple into a vector.
packWord16X32# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X32#

-- | Pack the elements of an unboxed tuple into a vector.
packWord16X8# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X8#

-- | Pack the elements of an unboxed tuple into a vector.
packWord32X16# :: (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #) -> Word32X16#

-- | Pack the elements of an unboxed tuple into a vector.
packWord32X4# :: (# Word32#, Word32#, Word32#, Word32# #) -> Word32X4#

-- | Pack the elements of an unboxed tuple into a vector.
packWord32X8# :: (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #) -> Word32X8#

-- | Pack the elements of an unboxed tuple into a vector.
packWord64X2# :: (# Word64#, Word64# #) -> Word64X2#

-- | Pack the elements of an unboxed tuple into a vector.
packWord64X4# :: (# Word64#, Word64#, Word64#, Word64# #) -> Word64X4#

-- | Pack the elements of an unboxed tuple into a vector.
packWord64X8# :: (# Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64# #) -> Word64X8#

-- | Pack the elements of an unboxed tuple into a vector.
packWord8X16# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X16#

-- | Pack the elements of an unboxed tuple into a vector.
packWord8X32# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X32#

-- | Pack the elements of an unboxed tuple into a vector.
packWord8X64# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X64#

-- | Create a new spark evaluating the given argument. The return value
--   should always be 1. Users are encouraged to use spark# instead.
par# :: a -> Int#

-- | Deposit bits to a word at locations specified by a mask, aka
--   <a>parallel bit deposit</a>.
--   
--   Software emulation:
--   
--   <pre>
--   pdep :: Word -&gt; Word -&gt; Word
--   pdep src mask = go 0 src mask
--     where
--       go :: Word -&gt; Word -&gt; Word -&gt; Word
--       go result _ 0 = result
--       go result src mask = go newResult newSrc newMask
--         where
--           maskCtz   = countTrailingZeros mask
--           newResult = if testBit src 0 then setBit result maskCtz else result
--           newSrc    = src `shiftR` 1
--           newMask   = clearBit mask maskCtz
--   </pre>
pdep# :: Word# -> Word# -> Word#

-- | Deposit bits to lower 16 bits of a word at locations specified by a
--   mask.
pdep16# :: Word# -> Word# -> Word#

-- | Deposit bits to lower 32 bits of a word at locations specified by a
--   mask.
pdep32# :: Word# -> Word# -> Word#

-- | Deposit bits to a word at locations specified by a mask.
pdep64# :: Word64# -> Word64# -> Word64#

-- | Deposit bits to lower 8 bits of a word at locations specified by a
--   mask.
pdep8# :: Word# -> Word# -> Word#

-- | Extract bits from a word at locations specified by a mask, aka
--   <a>parallel bit extract</a>.
--   
--   Software emulation:
--   
--   <pre>
--   pext :: Word -&gt; Word -&gt; Word
--   pext src mask = loop 0 0 0
--     where
--       loop i count result
--         | i &gt;= finiteBitSize (0 :: Word)
--         = result
--         | testBit mask i
--         = loop (i + 1) (count + 1) (if testBit src i then setBit result count else result)
--         | otherwise
--         = loop (i + 1) count result
--   </pre>
pext# :: Word# -> Word# -> Word#

-- | Extract bits from lower 16 bits of a word at locations specified by a
--   mask.
pext16# :: Word# -> Word# -> Word#

-- | Extract bits from lower 32 bits of a word at locations specified by a
--   mask.
pext32# :: Word# -> Word# -> Word#

-- | Extract bits from a word at locations specified by a mask.
pext64# :: Word64# -> Word64# -> Word64#

-- | Extract bits from lower 8 bits of a word at locations specified by a
--   mask.
pext8# :: Word# -> Word# -> Word#
plusAddr# :: Addr# -> Int# -> Addr#

-- | Add two vectors element-wise.
plusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Add two vectors element-wise.
plusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Add two vectors element-wise.
plusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
plusFloat# :: Float# -> Float# -> Float#

-- | Add two vectors element-wise.
plusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Add two vectors element-wise.
plusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Add two vectors element-wise.
plusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
plusInt16# :: Int16# -> Int16# -> Int16#

-- | Add two vectors element-wise.
plusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Add two vectors element-wise.
plusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Add two vectors element-wise.
plusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
plusInt32# :: Int32# -> Int32# -> Int32#

-- | Add two vectors element-wise.
plusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Add two vectors element-wise.
plusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Add two vectors element-wise.
plusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
plusInt64# :: Int64# -> Int64# -> Int64#

-- | Add two vectors element-wise.
plusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Add two vectors element-wise.
plusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Add two vectors element-wise.
plusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
plusInt8# :: Int8# -> Int8# -> Int8#

-- | Add two vectors element-wise.
plusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Add two vectors element-wise.
plusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Add two vectors element-wise.
plusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
plusWord# :: Word# -> Word# -> Word#
plusWord16# :: Word16# -> Word16# -> Word16#

-- | Add two vectors element-wise.
plusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Add two vectors element-wise.
plusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Add two vectors element-wise.
plusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Add unsigned integers, with the high part (carry) in the first
--   component of the returned pair and the low part in the second
--   component of the pair. See also <a>addWordC#</a>.
plusWord2# :: Word# -> Word# -> (# Word#, Word# #)
plusWord32# :: Word32# -> Word32# -> Word32#

-- | Add two vectors element-wise.
plusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Add two vectors element-wise.
plusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Add two vectors element-wise.
plusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
plusWord64# :: Word64# -> Word64# -> Word64#

-- | Add two vectors element-wise.
plusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Add two vectors element-wise.
plusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Add two vectors element-wise.
plusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
plusWord8# :: Word8# -> Word8# -> Word8#

-- | Add two vectors element-wise.
plusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Add two vectors element-wise.
plusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Add two vectors element-wise.
plusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Count the number of set bits in a word.
popCnt# :: Word# -> Word#

-- | Count the number of set bits in the lower 16 bits of a word.
popCnt16# :: Word# -> Word#

-- | Count the number of set bits in the lower 32 bits of a word.
popCnt32# :: Word# -> Word#

-- | Count the number of set bits in a 64-bit word.
popCnt64# :: Word64# -> Word#

-- | Count the number of set bits in the lower 8 bits of a word.
popCnt8# :: Word# -> Word#
powerFloat# :: Float# -> Float# -> Float#
prefetchAddr0# :: Addr# -> Int# -> State# d -> State# d
prefetchAddr1# :: Addr# -> Int# -> State# d -> State# d
prefetchAddr2# :: Addr# -> Int# -> State# d -> State# d
prefetchAddr3# :: Addr# -> Int# -> State# d -> State# d
prefetchByteArray0# :: ByteArray# -> Int# -> State# d -> State# d
prefetchByteArray1# :: ByteArray# -> Int# -> State# d -> State# d
prefetchByteArray2# :: ByteArray# -> Int# -> State# d -> State# d
prefetchByteArray3# :: ByteArray# -> Int# -> State# d -> State# d
prefetchMutableByteArray0# :: MutableByteArray# d -> Int# -> State# d -> State# d
prefetchMutableByteArray1# :: MutableByteArray# d -> Int# -> State# d -> State# d
prefetchMutableByteArray2# :: MutableByteArray# d -> Int# -> State# d -> State# d
prefetchMutableByteArray3# :: MutableByteArray# d -> Int# -> State# d -> State# d
prefetchValue0# :: a -> State# d -> State# d
prefetchValue1# :: a -> State# d -> State# d
prefetchValue2# :: a -> State# d -> State# d
prefetchValue3# :: a -> State# d -> State# d

-- | See <a>GHC.Prim#continuations</a>.
prompt# :: PromptTag# a -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)

-- | Witness for an unboxed <a>Proxy#</a> value, which has no runtime
--   representation.
proxy# :: forall {k} (a :: k). Proxy# a

-- | If <a>MVar#</a> is full, block until it becomes empty. Then store
--   value arg as its new contents.
putMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> a -> State# d -> State# d

-- | Rounds towards zero. The behavior is undefined if the second argument
--   is zero.
quotInt# :: Int# -> Int# -> Int#
quotInt16# :: Int16# -> Int16# -> Int16#

-- | Rounds towards zero element-wise.
quotInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Rounds towards zero element-wise.
quotInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Rounds towards zero element-wise.
quotInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
quotInt32# :: Int32# -> Int32# -> Int32#

-- | Rounds towards zero element-wise.
quotInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Rounds towards zero element-wise.
quotInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Rounds towards zero element-wise.
quotInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
quotInt64# :: Int64# -> Int64# -> Int64#

-- | Rounds towards zero element-wise.
quotInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Rounds towards zero element-wise.
quotInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Rounds towards zero element-wise.
quotInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
quotInt8# :: Int8# -> Int8# -> Int8#

-- | Rounds towards zero element-wise.
quotInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Rounds towards zero element-wise.
quotInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Rounds towards zero element-wise.
quotInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Rounds towards zero.
quotRemInt# :: Int# -> Int# -> (# Int#, Int# #)
quotRemInt16# :: Int16# -> Int16# -> (# Int16#, Int16# #)
quotRemInt32# :: Int32# -> Int32# -> (# Int32#, Int32# #)
quotRemInt8# :: Int8# -> Int8# -> (# Int8#, Int8# #)
quotRemWord# :: Word# -> Word# -> (# Word#, Word# #)
quotRemWord16# :: Word16# -> Word16# -> (# Word16#, Word16# #)

-- | Takes high word of dividend, then low word of dividend, then divisor.
--   Requires that high word &lt; divisor.
quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#, Word# #)
quotRemWord32# :: Word32# -> Word32# -> (# Word32#, Word32# #)
quotRemWord8# :: Word8# -> Word8# -> (# Word8#, Word8# #)
quotWord# :: Word# -> Word# -> Word#
quotWord16# :: Word16# -> Word16# -> Word16#

-- | Rounds towards zero element-wise.
quotWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Rounds towards zero element-wise.
quotWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Rounds towards zero element-wise.
quotWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
quotWord32# :: Word32# -> Word32# -> Word32#

-- | Rounds towards zero element-wise.
quotWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Rounds towards zero element-wise.
quotWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Rounds towards zero element-wise.
quotWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
quotWord64# :: Word64# -> Word64# -> Word64#

-- | Rounds towards zero element-wise.
quotWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Rounds towards zero element-wise.
quotWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Rounds towards zero element-wise.
quotWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
quotWord8# :: Word8# -> Word8# -> Word8#

-- | Rounds towards zero element-wise.
quotWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Rounds towards zero element-wise.
quotWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Rounds towards zero element-wise.
quotWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
raise# :: forall {l :: Levity} {r :: RuntimeRep} (a :: TYPE ('BoxedRep l)) (b :: TYPE r). a -> b
raiseDivZero# :: forall {r :: RuntimeRep} (b :: TYPE r). (# #) -> b
raiseIO# :: forall {l :: Levity} {r :: RuntimeRep} (a :: TYPE ('BoxedRep l)) (b :: TYPE r). a -> State# RealWorld -> (# State# RealWorld, b #)
raiseOverflow# :: forall {r :: RuntimeRep} (b :: TYPE r). (# #) -> b
raiseUnderflow# :: forall {r :: RuntimeRep} (b :: TYPE r). (# #) -> b

-- | Read a machine address from mutable array; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readAddrArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)

-- | Read a machine address from mutable address; offset in machine words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readAddrOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Addr# #)

-- | Read from specified index of mutable array. Result is not yet
--   evaluated.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> State# d -> (# State# d, a #)

-- | Read an 8-bit character from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readCharArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)

-- | Read an 8-bit character from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readCharOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a double-precision floating-point value from mutable array;
--   offset in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleArrayAsDoubleX2# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleArrayAsDoubleX4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleArrayAsDoubleX8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)

-- | Read a double-precision floating-point value from mutable address;
--   offset in 8-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Double# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleX2Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleX2OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleX4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleX4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleX8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleX8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)

-- | Read a single-precision floating-point value from mutable array;
--   offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatArrayAsFloatX16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatArrayAsFloatX4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatArrayAsFloatX8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)

-- | Read a single-precision floating-point value from mutable address;
--   offset in 4-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Float# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatOffAddrAsFloatX16# :: Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatOffAddrAsFloatX4# :: Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatOffAddrAsFloatX8# :: Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatX16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatX16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatX4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatX4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatX8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatX8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)

-- | If <a>IOPort#</a> is empty, block until it becomes full. Then remove
--   and return its contents, and set it empty. Throws an
--   <tt>IOPortException</tt> if another thread is already waiting to read
--   this <a>IOPort#</a>.
readIOPort# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). IOPort# d a -> State# d -> (# State# d, a #)

-- | Read a 16-bit signed integer from mutable array; offset in 2-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16ArrayAsInt16X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16ArrayAsInt16X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16ArrayAsInt16X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)

-- | Read a 16-bit signed integer from mutable address; offset in 2-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16OffAddrAsInt16X16# :: Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16OffAddrAsInt16X32# :: Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16OffAddrAsInt16X8# :: Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)

-- | Read a 32-bit signed integer from mutable array; offset in 4-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32ArrayAsInt32X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32ArrayAsInt32X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32ArrayAsInt32X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)

-- | Read a 32-bit signed integer from mutable address; offset in 4-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32OffAddrAsInt32X16# :: Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32OffAddrAsInt32X4# :: Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32OffAddrAsInt32X8# :: Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)

-- | Read a 64-bit signed integer from mutable array; offset in 8-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64ArrayAsInt64X2# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64ArrayAsInt64X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64ArrayAsInt64X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)

-- | Read a 64-bit signed integer from mutable address; offset in 8-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64OffAddrAsInt64X2# :: Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64OffAddrAsInt64X4# :: Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64OffAddrAsInt64X8# :: Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64X2Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64X2OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)

-- | Read an 8-bit signed integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8ArrayAsInt8X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8ArrayAsInt8X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8ArrayAsInt8X64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)

-- | Read an 8-bit signed integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8OffAddrAsInt8X16# :: Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8OffAddrAsInt8X32# :: Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8OffAddrAsInt8X64# :: Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8X64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8X64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)

-- | Read a word-sized integer from mutable array; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readIntArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)

-- | Read a word-sized integer from mutable address; offset in machine
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readIntOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int# #)

-- | If <a>MVar#</a> is empty, block until it becomes full. Then read its
--   contents without modifying the MVar, without possibility of
--   intervention from other threads.
readMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> State# d -> (# State# d, a #)

-- | Read contents of <a>MutVar#</a>. Result is not yet evaluated.
readMutVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutVar# d a -> State# d -> (# State# d, a #)

-- | Read from specified index of mutable array. Result is not yet
--   evaluated.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readSmallArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> State# d -> (# State# d, a #)

-- | Read a <a>StablePtr#</a> value from mutable array; offset in machine
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readStablePtrArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)

-- | Read a <a>StablePtr#</a> value from mutable address; offset in machine
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readStablePtrOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, StablePtr# a #)

-- | Read contents of <a>TVar#</a> inside an STM transaction, i.e. within a
--   call to <a>atomically#</a>. Does not force evaluation of the result.
readTVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). TVar# d a -> State# d -> (# State# d, a #)

-- | Read contents of <a>TVar#</a> outside an STM transaction. Does not
--   force evaluation of the result.
readTVarIO# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). TVar# d a -> State# d -> (# State# d, a #)

-- | Read a 32-bit character from mutable array; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWideCharArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a 32-bit character from mutable address; offset in 4-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWideCharOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a 16-bit unsigned integer from mutable array; offset in 2-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16ArrayAsWord16X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16ArrayAsWord16X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16ArrayAsWord16X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)

-- | Read a 16-bit unsigned integer from mutable address; offset in 2-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16OffAddrAsWord16X16# :: Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16OffAddrAsWord16X32# :: Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16OffAddrAsWord16X8# :: Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)

-- | Read a 32-bit unsigned integer from mutable array; offset in 4-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32ArrayAsWord32X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32ArrayAsWord32X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32ArrayAsWord32X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)

-- | Read a 32-bit unsigned integer from mutable address; offset in 4-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32OffAddrAsWord32X16# :: Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32OffAddrAsWord32X4# :: Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32OffAddrAsWord32X8# :: Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)

-- | Read a 64-bit unsigned integer from mutable array; offset in 8-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64ArrayAsWord64X2# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64ArrayAsWord64X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64ArrayAsWord64X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)

-- | Read a 64-bit unsigned integer from mutable address; offset in 8-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64OffAddrAsWord64X2# :: Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64OffAddrAsWord64X4# :: Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64OffAddrAsWord64X8# :: Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64X2Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64X2OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)

-- | Read an 8-bit unsigned integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8# #)

-- | Read a machine address from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsAddr# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)

-- | Read an 8-bit character from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsChar# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a double-precision floating-point value from mutable array;
--   offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsDouble# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)

-- | Read a single-precision floating-point value from mutable array;
--   offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsFloat# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)

-- | Read a word-sized integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)

-- | Read a 16-bit signed integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16# #)

-- | Read a 32-bit signed integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32# #)

-- | Read a 64-bit signed integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64# #)

-- | Read a <a>StablePtr#</a> value from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsStablePtr# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)

-- | Read a 32-bit character from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWideChar# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a word-sized unsigned integer from mutable array; offset in
--   bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)

-- | Read a 16-bit unsigned integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16# #)

-- | Read a 32-bit unsigned integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32# #)

-- | Read a 64-bit unsigned integer from mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord8X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord8X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord8X64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)

-- | Read an 8-bit unsigned integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8# #)

-- | Read a machine address from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsAddr# :: Addr# -> Int# -> State# d -> (# State# d, Addr# #)

-- | Read an 8-bit character from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsChar# :: Addr# -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a double-precision floating-point value from mutable address;
--   offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsDouble# :: Addr# -> Int# -> State# d -> (# State# d, Double# #)

-- | Read a single-precision floating-point value from mutable address;
--   offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsFloat# :: Addr# -> Int# -> State# d -> (# State# d, Float# #)

-- | Read a word-sized integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsInt# :: Addr# -> Int# -> State# d -> (# State# d, Int# #)

-- | Read a 16-bit signed integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsInt16# :: Addr# -> Int# -> State# d -> (# State# d, Int16# #)

-- | Read a 32-bit signed integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsInt32# :: Addr# -> Int# -> State# d -> (# State# d, Int32# #)

-- | Read a 64-bit signed integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsInt64# :: Addr# -> Int# -> State# d -> (# State# d, Int64# #)

-- | Read a <a>StablePtr#</a> value from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsStablePtr# :: Addr# -> Int# -> State# d -> (# State# d, StablePtr# a #)

-- | Read a 32-bit character from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWideChar# :: Addr# -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a word-sized unsigned integer from mutable address; offset in
--   bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWord# :: Addr# -> Int# -> State# d -> (# State# d, Word# #)

-- | Read a 16-bit unsigned integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWord16# :: Addr# -> Int# -> State# d -> (# State# d, Word16# #)

-- | Read a 32-bit unsigned integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWord32# :: Addr# -> Int# -> State# d -> (# State# d, Word32# #)

-- | Read a 64-bit unsigned integer from mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWord64# :: Addr# -> Int# -> State# d -> (# State# d, Word64# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWord8X16# :: Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWord8X32# :: Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddrAsWord8X64# :: Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8X64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8X64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)

-- | Read a word-sized unsigned integer from mutable array; offset in
--   machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWordArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)

-- | Read a word-sized unsigned integer from mutable address; offset in
--   machine words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWordOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word# #)

-- | The token used in the implementation of the IO monad as a state monad.
--   It does not pass any information at runtime. See also <a>runRW#</a>.
realWorld# :: State# RealWorld

-- | Returns <tt>1#</tt> if the given pointers are equal and <tt>0#</tt>
--   otherwise.
reallyUnsafePtrEquality# :: forall {l :: Levity} {k :: Levity} (a :: TYPE ('BoxedRep l)) (b :: TYPE ('BoxedRep k)). a -> b -> Int#

-- | Return the remainder when the <a>Addr#</a> arg, treated like an
--   <a>Int#</a>, is divided by the <a>Int#</a> arg.
remAddr# :: Addr# -> Int# -> Int#

-- | Satisfies <tt>(<a>quotInt#</a> x y) <a>*#</a> y <a>+#</a>
--   (<a>remInt#</a> x y) == x</tt>. The behavior is undefined if the
--   second argument is zero.
remInt# :: Int# -> Int# -> Int#
remInt16# :: Int16# -> Int16# -> Int16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
remInt32# :: Int32# -> Int32# -> Int32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
remInt64# :: Int64# -> Int64# -> Int64#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
remInt8# :: Int8# -> Int8# -> Int8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
remWord# :: Word# -> Word# -> Word#
remWord16# :: Word16# -> Word16# -> Word16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
remWord32# :: Word32# -> Word32# -> Word32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
remWord64# :: Word64# -> Word64# -> Word64#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
remWord8# :: Word8# -> Word8# -> Word8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
remWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Resize mutable byte array to new specified size (in bytes), shrinking
--   or growing it. The returned <a>MutableByteArray#</a> is either the
--   original <a>MutableByteArray#</a> resized in-place or, if not
--   possible, a newly allocated (unpinned) <a>MutableByteArray#</a> (with
--   the original content copied over).
--   
--   To avoid undefined behaviour, the original <a>MutableByteArray#</a>
--   shall not be accessed anymore after a <a>resizeMutableByteArray#</a>
--   has been performed. Moreover, no reference to the old one should be
--   kept in order to allow garbage collection of the original
--   <a>MutableByteArray#</a> in case a new <a>MutableByteArray#</a> had to
--   be allocated.
resizeMutableByteArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, MutableByteArray# d #)
retry# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). State# RealWorld -> (# State# RealWorld, a #)
rightSection :: forall {q :: RuntimeRep} {r :: RuntimeRep} {s :: RuntimeRep} {n :: Multiplicity} {o :: Multiplicity} (a :: TYPE q) (b :: TYPE r) (c :: TYPE s). (a %n -> b %o -> c) -> b %o -> a %n -> c

-- | The value of <tt><a>seq</a> a b</tt> is bottom if <tt>a</tt> is
--   bottom, and otherwise equal to <tt>b</tt>. In other words, it
--   evaluates the first argument <tt>a</tt> to weak head normal form
--   (WHNF). <a>seq</a> is usually introduced to improve performance by
--   avoiding unneeded laziness.
--   
--   A note on evaluation order: the expression <tt><a>seq</a> a b</tt>
--   does <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <a>seq</a> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <a>seq</a> returns
--   a value. In particular, this means that <tt>b</tt> may be evaluated
--   before <tt>a</tt>. If you need to guarantee a specific order of
--   evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: forall {r :: RuntimeRep} a (b :: TYPE r). a -> b -> b
infixr 0 `seq`

-- | <tt><a>setAddrRange#</a> dest len c</tt> sets all of the bytes in
--   <tt>[dest, dest+len)</tt> to the value <tt>c</tt>.
--   
--   Analogous to the standard C function <tt>memset</tt>, but with a
--   different argument order.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
setAddrRange# :: Addr# -> Int# -> Int# -> State# RealWorld -> State# RealWorld

-- | <tt><a>setByteArray#</a> ba off len c</tt> sets the byte range
--   <tt>[off, off+len)</tt> of the <a>MutableByteArray#</a> to the byte
--   <tt>c</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
setByteArray# :: MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> State# d

-- | Sets the allocation counter for the current thread to the given value.
setThreadAllocationCounter# :: Int64# -> State# RealWorld -> State# RealWorld

-- | Shrink mutable byte array to new specified size (in bytes), in the
--   specified state thread. The new size argument must be less than or
--   equal to the current size as reported by
--   <a>getSizeofMutableByteArray#</a>.
--   
--   Assuming the non-profiling RTS, this primitive compiles to an O(1)
--   operation in C--, modifying the array in-place. Backends bypassing C--
--   representation (such as JavaScript) might behave differently.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
shrinkMutableByteArray# :: MutableByteArray# d -> Int# -> State# d -> State# d

-- | Shrink mutable array to new specified size, in the specified state
--   thread. The new size argument must be less than or equal to the
--   current size as reported by <a>getSizeofSmallMutableArray#</a>.
--   
--   Assuming the non-profiling RTS, for the copying garbage collector
--   (default) this primitive compiles to an O(1) operation in C--,
--   modifying the array in-place. For the non-moving garbage collector,
--   however, the time is proportional to the number of elements shrinked
--   out. Backends bypassing C-- representation (such as JavaScript) might
--   behave differently.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
shrinkSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> State# d -> State# d

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleDoubleX2# :: DoubleX2# -> DoubleX2# -> (# Int#, Int# #) -> DoubleX2#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleDoubleX4# :: DoubleX4# -> DoubleX4# -> (# Int#, Int#, Int#, Int# #) -> DoubleX4#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleDoubleX8# :: DoubleX8# -> DoubleX8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> DoubleX8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleFloatX16# :: FloatX16# -> FloatX16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> FloatX16#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleFloatX4# :: FloatX4# -> FloatX4# -> (# Int#, Int#, Int#, Int# #) -> FloatX4#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleFloatX8# :: FloatX8# -> FloatX8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> FloatX8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt16X16# :: Int16X16# -> Int16X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X16#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt16X32# :: Int16X32# -> Int16X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X32#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt16X8# :: Int16X8# -> Int16X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt32X16# :: Int32X16# -> Int32X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int32X16#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt32X4# :: Int32X4# -> Int32X4# -> (# Int#, Int#, Int#, Int# #) -> Int32X4#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt32X8# :: Int32X8# -> Int32X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int32X8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt64X2# :: Int64X2# -> Int64X2# -> (# Int#, Int# #) -> Int64X2#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt64X4# :: Int64X4# -> Int64X4# -> (# Int#, Int#, Int#, Int# #) -> Int64X4#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt64X8# :: Int64X8# -> Int64X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int64X8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt8X16# :: Int8X16# -> Int8X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X16#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt8X32# :: Int8X32# -> Int8X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X32#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleInt8X64# :: Int8X64# -> Int8X64# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X64#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord16X16# :: Word16X16# -> Word16X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word16X16#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord16X32# :: Word16X32# -> Word16X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word16X32#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord16X8# :: Word16X8# -> Word16X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word16X8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord32X16# :: Word32X16# -> Word32X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word32X16#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord32X4# :: Word32X4# -> Word32X4# -> (# Int#, Int#, Int#, Int# #) -> Word32X4#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord32X8# :: Word32X8# -> Word32X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word32X8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord64X2# :: Word64X2# -> Word64X2# -> (# Int#, Int# #) -> Word64X2#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord64X4# :: Word64X4# -> Word64X4# -> (# Int#, Int#, Int#, Int# #) -> Word64X4#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord64X8# :: Word64X8# -> Word64X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word64X8#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord8X16# :: Word8X16# -> Word8X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word8X16#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord8X32# :: Word8X32# -> Word8X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word8X32#

-- | Shuffle elements of the concatenation of the input two vectors into
--   the result vector.
shuffleWord8X64# :: Word8X64# -> Word8X64# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Word8X64#
sinDouble# :: Double# -> Double#
sinFloat# :: Float# -> Float#
sinhDouble# :: Double# -> Double#
sinhFloat# :: Float# -> Float#

-- | Return the number of elements in the array.
sizeofArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Array# a -> Int#

-- | Return the size of the array in bytes.
sizeofByteArray# :: ByteArray# -> Int#

-- | Return the number of elements in the array.
sizeofMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int#

-- | Return the size of the array in bytes. <b>Deprecated</b>, it is unsafe
--   in the presence of <a>shrinkMutableByteArray#</a> and
--   <a>resizeMutableByteArray#</a> operations on the same mutable byte
--   array.

-- | <i>Deprecated: Use <a>getSizeofMutableByteArray#</a> instead </i>
sizeofMutableByteArray# :: MutableByteArray# d -> Int#

-- | Return the number of elements in the array.
sizeofSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). SmallArray# a -> Int#

-- | Return the number of elements in the array. <b>Deprecated</b>, it is
--   unsafe in the presence of <a>shrinkSmallMutableArray#</a> and
--   <tt>resizeSmallMutableArray#</tt> operations on the same small mutable
--   array.

-- | <i>Deprecated: Use <a>getSizeofSmallMutableArray#</a> instead </i>
sizeofSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int#
spark# :: a -> State# d -> (# State# d, a #)
sqrtDouble# :: Double# -> Double#
sqrtFloat# :: Float# -> Float#
stableNameToInt# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). StableName# a -> Int#
subInt16# :: Int16# -> Int16# -> Int16#
subInt32# :: Int32# -> Int32# -> Int32#
subInt64# :: Int64# -> Int64# -> Int64#
subInt8# :: Int8# -> Int8# -> Int8#

-- | Subtract signed integers reporting overflow. First member of result is
--   the difference truncated to an <a>Int#</a>; second member is zero if
--   the true difference fits in an <a>Int#</a>, nonzero if overflow
--   occurred (the difference is either too large or too small to fit in an
--   <a>Int#</a>).
subIntC# :: Int# -> Int# -> (# Int#, Int# #)
subWord16# :: Word16# -> Word16# -> Word16#
subWord32# :: Word32# -> Word32# -> Word32#
subWord64# :: Word64# -> Word64# -> Word64#
subWord8# :: Word8# -> Word8# -> Word8#

-- | Subtract unsigned integers reporting overflow. The first element of
--   the pair is the result. The second element is the carry flag, which is
--   nonzero on overflow.
subWordC# :: Word# -> Word# -> (# Word#, Int# #)
tagToEnum# :: Int# -> a

-- | If <a>MVar#</a> is empty, block until it becomes full. Then remove and
--   return its contents, and set it empty.
takeMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> State# d -> (# State# d, a #)
tanDouble# :: Double# -> Double#
tanFloat# :: Float# -> Float#
tanhDouble# :: Double# -> Double#
tanhFloat# :: Float# -> Float#

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
thawArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. Array# a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
thawSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. SmallArray# a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)

-- | Get the label of the given thread. Morally of type <tt>ThreadId# -&gt;
--   IO (Maybe ByteArray#)</tt>, with a <tt>1#</tt> tag denoting
--   <tt>Just</tt>.
threadLabel# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, ByteArray# #)

-- | Get the status of the given thread. Result is <tt>(ThreadStatus,
--   Capability, Locked)</tt> where <tt>ThreadStatus</tt> is one of the
--   status constants defined in <tt>rts/Constants.h</tt>,
--   <tt>Capability</tt> is the number of the capability which currently
--   owns the thread, and <tt>Locked</tt> is a boolean indicating whether
--   the thread is bound to that capability.
threadStatus# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, Int#, Int# #)

-- | Multiply two vectors element-wise.
timesDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Multiply two vectors element-wise.
timesDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Multiply two vectors element-wise.
timesDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
timesFloat# :: Float# -> Float# -> Float#

-- | Multiply two vectors element-wise.
timesFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Multiply two vectors element-wise.
timesFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Multiply two vectors element-wise.
timesFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
timesInt16# :: Int16# -> Int16# -> Int16#

-- | Multiply two vectors element-wise.
timesInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Multiply two vectors element-wise.
timesInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Multiply two vectors element-wise.
timesInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Return a triple (isHighNeeded,high,low) where high and low are
--   respectively the high and low bits of the double-word result.
--   isHighNeeded is a cheap way to test if the high word is a
--   sign-extension of the low word (isHighNeeded = 0#) or not
--   (isHighNeeded = 1#).
timesInt2# :: Int# -> Int# -> (# Int#, Int#, Int# #)
timesInt32# :: Int32# -> Int32# -> Int32#

-- | Multiply two vectors element-wise.
timesInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Multiply two vectors element-wise.
timesInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Multiply two vectors element-wise.
timesInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
timesInt64# :: Int64# -> Int64# -> Int64#

-- | Multiply two vectors element-wise.
timesInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Multiply two vectors element-wise.
timesInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Multiply two vectors element-wise.
timesInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
timesInt8# :: Int8# -> Int8# -> Int8#

-- | Multiply two vectors element-wise.
timesInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Multiply two vectors element-wise.
timesInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Multiply two vectors element-wise.
timesInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
timesWord# :: Word# -> Word# -> Word#
timesWord16# :: Word16# -> Word16# -> Word16#

-- | Multiply two vectors element-wise.
timesWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Multiply two vectors element-wise.
timesWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Multiply two vectors element-wise.
timesWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
timesWord2# :: Word# -> Word# -> (# Word#, Word# #)
timesWord32# :: Word32# -> Word32# -> Word32#

-- | Multiply two vectors element-wise.
timesWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Multiply two vectors element-wise.
timesWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Multiply two vectors element-wise.
timesWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
timesWord64# :: Word64# -> Word64# -> Word64#

-- | Multiply two vectors element-wise.
timesWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Multiply two vectors element-wise.
timesWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Multiply two vectors element-wise.
timesWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
timesWord8# :: Word8# -> Word8# -> Word8#

-- | Multiply two vectors element-wise.
timesWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Multiply two vectors element-wise.
timesWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Multiply two vectors element-wise.
timesWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
touch# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. a -> State# d -> State# d

-- | Emits an event via the RTS tracing framework. The contents of the
--   event is the binary object passed as the first argument with the given
--   length passed as the second argument. The event will be emitted to the
--   <tt>.eventlog</tt> file.
traceBinaryEvent# :: Addr# -> Int# -> State# d -> State# d

-- | Emits an event via the RTS tracing framework. The contents of the
--   event is the zero-terminated byte string passed as the first argument.
--   The event will be emitted either to the <tt>.eventlog</tt> file, or to
--   stderr, depending on the runtime RTS flags.
traceEvent# :: Addr# -> State# d -> State# d

-- | Emits a marker event via the RTS tracing framework. The contents of
--   the event is the zero-terminated byte string passed as the first
--   argument. The event will be emitted either to the <tt>.eventlog</tt>
--   file, or to stderr, depending on the runtime RTS flags.
traceMarker# :: Addr# -> State# d -> State# d

-- | If <a>MVar#</a> is full, immediately return with integer 0. Otherwise,
--   store value arg as 'MVar#''s new contents, and return with integer 1.
tryPutMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> a -> State# d -> (# State# d, Int# #)

-- | If <a>MVar#</a> is empty, immediately return with integer 0 and value
--   undefined. Otherwise, return with integer 1 and contents of
--   <a>MVar#</a>.
tryReadMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> State# d -> (# State# d, Int#, a #)

-- | If <a>MVar#</a> is empty, immediately return with integer 0 and value
--   undefined. Otherwise, return with integer 1 and contents of
--   <a>MVar#</a>, and set <a>MVar#</a> empty.
tryTakeMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> State# d -> (# State# d, Int#, a #)

-- | Shift left. Result undefined if shift amount is not in the range 0 to
--   word size - 1 inclusive.
uncheckedIShiftL# :: Int# -> Int# -> Int#
uncheckedIShiftL64# :: Int64# -> Int# -> Int64#

-- | Shift right arithmetic. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedIShiftRA# :: Int# -> Int# -> Int#
uncheckedIShiftRA64# :: Int64# -> Int# -> Int64#

-- | Shift right logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedIShiftRL# :: Int# -> Int# -> Int#
uncheckedIShiftRL64# :: Int64# -> Int# -> Int64#

-- | Shift left logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedShiftL# :: Word# -> Int# -> Word#
uncheckedShiftL64# :: Word64# -> Int# -> Word64#
uncheckedShiftLInt16# :: Int16# -> Int# -> Int16#
uncheckedShiftLInt32# :: Int32# -> Int# -> Int32#
uncheckedShiftLInt8# :: Int8# -> Int# -> Int8#
uncheckedShiftLWord16# :: Word16# -> Int# -> Word16#
uncheckedShiftLWord32# :: Word32# -> Int# -> Word32#
uncheckedShiftLWord8# :: Word8# -> Int# -> Word8#
uncheckedShiftRAInt16# :: Int16# -> Int# -> Int16#
uncheckedShiftRAInt32# :: Int32# -> Int# -> Int32#
uncheckedShiftRAInt8# :: Int8# -> Int# -> Int8#

-- | Shift right logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedShiftRL# :: Word# -> Int# -> Word#
uncheckedShiftRL64# :: Word64# -> Int# -> Word64#
uncheckedShiftRLInt16# :: Int16# -> Int# -> Int16#
uncheckedShiftRLInt32# :: Int32# -> Int# -> Int32#
uncheckedShiftRLInt8# :: Int8# -> Int# -> Int8#
uncheckedShiftRLWord16# :: Word16# -> Int# -> Word16#
uncheckedShiftRLWord32# :: Word32# -> Int# -> Word32#
uncheckedShiftRLWord8# :: Word8# -> Int# -> Word8#

-- | <tt><tt>unmaskAsyncUninterruptible#</tt> k s</tt> evaluates <tt>k
--   s</tt> such that asynchronous exceptions are unmasked.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
unmaskAsyncExceptions# :: forall {q :: RuntimeRep} (a :: TYPE q). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)

-- | <tt><a>unpackClosure#</a> closure</tt> copies the closure and pointers
--   in the payload of the given closure into two new arrays, and returns a
--   pointer to the first word of the closure's info table, a non-pointer
--   array for the raw bytes of the closure, and a pointer array for the
--   pointers in the payload.
unpackClosure# :: a -> (# Addr#, ByteArray#, Array# b #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackDoubleX2# :: DoubleX2# -> (# Double#, Double# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackDoubleX4# :: DoubleX4# -> (# Double#, Double#, Double#, Double# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackDoubleX8# :: DoubleX8# -> (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackFloatX16# :: FloatX16# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackFloatX4# :: FloatX4# -> (# Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackFloatX8# :: FloatX8# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt16X16# :: Int16X16# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt16X32# :: Int16X32# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt16X8# :: Int16X8# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt32X16# :: Int32X16# -> (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt32X4# :: Int32X4# -> (# Int32#, Int32#, Int32#, Int32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt32X8# :: Int32X8# -> (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt64X2# :: Int64X2# -> (# Int64#, Int64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt64X4# :: Int64X4# -> (# Int64#, Int64#, Int64#, Int64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt64X8# :: Int64X8# -> (# Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt8X16# :: Int8X16# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt8X32# :: Int8X32# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt8X64# :: Int8X64# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord16X16# :: Word16X16# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord16X32# :: Word16X32# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord16X8# :: Word16X8# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord32X16# :: Word32X16# -> (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord32X4# :: Word32X4# -> (# Word32#, Word32#, Word32#, Word32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord32X8# :: Word32X8# -> (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord64X2# :: Word64X2# -> (# Word64#, Word64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord64X4# :: Word64X4# -> (# Word64#, Word64#, Word64#, Word64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord64X8# :: Word64X8# -> (# Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord8X16# :: Word8X16# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord8X32# :: Word8X32# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord8X64# :: Word8X64# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)

-- | Make a mutable array immutable, without copying.
unsafeFreezeArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> State# d -> (# State# d, Array# a #)

-- | Make a mutable byte array immutable, without copying.
unsafeFreezeByteArray# :: MutableByteArray# d -> State# d -> (# State# d, ByteArray# #)

-- | Make a mutable array immutable, without copying.
unsafeFreezeSmallArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> State# d -> (# State# d, SmallArray# a #)

-- | Make an immutable array mutable, without copying.
unsafeThawArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. Array# a -> State# d -> (# State# d, MutableArray# d a #)

-- | Make an immutable byte array mutable, without copying.
unsafeThawByteArray# :: ByteArray# -> State# d -> (# State# d, MutableByteArray# d #)

-- | Make an immutable array mutable, without copying.
unsafeThawSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. SmallArray# a -> State# d -> (# State# d, SmallMutableArray# d a #)

-- | This is an alias for the unboxed unit tuple constructor. In earlier
--   versions of GHC, <a>void#</a> was a value of the primitive type
--   <tt>Void#</tt>, which is now defined to be <tt>(# #)</tt>.

-- | <i>Deprecated: Use an unboxed unit tuple instead </i>
void# :: (# #)

-- | Block until input is available on specified file descriptor.
waitRead# :: Int# -> State# d -> State# d

-- | Block until output is possible on specified file descriptor.
waitWrite# :: Int# -> State# d -> State# d
word16ToInt16# :: Word16# -> Int16#
word16ToWord# :: Word16# -> Word#

-- | Convert an <a>Word#</a> to the corresponding <a>Double#</a> with the
--   same integral value (up to truncation due to floating-point
--   precision). e.g. <tt><a>word2Double#</a> 1## == 1.0##</tt>
word2Double# :: Word# -> Double#

-- | Convert an <a>Word#</a> to the corresponding <a>Float#</a> with the
--   same integral value (up to truncation due to floating-point
--   precision). e.g. <tt><a>word2Float#</a> 1## == 1.0#</tt>
word2Float# :: Word# -> Float#
word2Int# :: Word# -> Int#
word32ToInt32# :: Word32# -> Int32#
word32ToWord# :: Word32# -> Word#
word64ToInt64# :: Word64# -> Int64#
word64ToWord# :: Word64# -> Word#
word8ToInt8# :: Word8# -> Int8#
word8ToWord# :: Word8# -> Word#
wordToWord16# :: Word# -> Word16#
wordToWord32# :: Word# -> Word32#
wordToWord64# :: Word# -> Word64#
wordToWord8# :: Word# -> Word8#

-- | Write a machine address to mutable array; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeAddrArray# :: MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d

-- | Write a machine address to mutable address; offset in machine words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeAddrOffAddr# :: Addr# -> Int# -> Addr# -> State# d -> State# d

-- | Write to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> a -> State# d -> State# d

-- | Write an 8-bit character to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeCharArray# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d

-- | Write an 8-bit character to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeCharOffAddr# :: Addr# -> Int# -> Char# -> State# d -> State# d

-- | Write a double-precision floating-point value to mutable array; offset
--   in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleArray# :: MutableByteArray# d -> Int# -> Double# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleArrayAsDoubleX2# :: MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleArrayAsDoubleX4# :: MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleArrayAsDoubleX8# :: MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d

-- | Write a double-precision floating-point value to mutable address;
--   offset in 8-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleOffAddr# :: Addr# -> Int# -> Double# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleX2Array# :: MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleX4Array# :: MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleX8Array# :: MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8# -> State# d -> State# d

-- | Write a single-precision floating-point value to mutable array; offset
--   in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatArray# :: MutableByteArray# d -> Int# -> Float# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatArrayAsFloatX16# :: MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatArrayAsFloatX4# :: MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatArrayAsFloatX8# :: MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d

-- | Write a single-precision floating-point value to mutable address;
--   offset in 4-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatOffAddr# :: Addr# -> Int# -> Float# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatX16Array# :: MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatX16OffAddr# :: Addr# -> Int# -> FloatX16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatX4Array# :: MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatX4OffAddr# :: Addr# -> Int# -> FloatX4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatX8Array# :: MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatX8OffAddr# :: Addr# -> Int# -> FloatX8# -> State# d -> State# d

-- | If <a>IOPort#</a> is full, immediately return with integer 0, throwing
--   an <tt>IOPortException</tt>. Otherwise, store value arg as 'IOPort#''s
--   new contents, and return with integer 1.
writeIOPort# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). IOPort# d a -> a -> State# d -> (# State# d, Int# #)

-- | Write a 16-bit signed integer to mutable array; offset in 2-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16Array# :: MutableByteArray# d -> Int# -> Int16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16ArrayAsInt16X16# :: MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16ArrayAsInt16X32# :: MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16ArrayAsInt16X8# :: MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d

-- | Write a 16-bit signed integer to mutable address; offset in 2-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16OffAddr# :: Addr# -> Int# -> Int16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16X16Array# :: MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16X16OffAddr# :: Addr# -> Int# -> Int16X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16X32Array# :: MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16X32OffAddr# :: Addr# -> Int# -> Int16X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16X8Array# :: MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16X8OffAddr# :: Addr# -> Int# -> Int16X8# -> State# d -> State# d

-- | Write a 32-bit signed integer to mutable array; offset in 4-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32Array# :: MutableByteArray# d -> Int# -> Int32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32ArrayAsInt32X16# :: MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32ArrayAsInt32X4# :: MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32ArrayAsInt32X8# :: MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d

-- | Write a 32-bit signed integer to mutable address; offset in 4-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32OffAddr# :: Addr# -> Int# -> Int32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32X16Array# :: MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32X16OffAddr# :: Addr# -> Int# -> Int32X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32X4Array# :: MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32X4OffAddr# :: Addr# -> Int# -> Int32X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32X8Array# :: MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32X8OffAddr# :: Addr# -> Int# -> Int32X8# -> State# d -> State# d

-- | Write a 64-bit signed integer to mutable array; offset in 8-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64Array# :: MutableByteArray# d -> Int# -> Int64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64ArrayAsInt64X2# :: MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64ArrayAsInt64X4# :: MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64ArrayAsInt64X8# :: MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d

-- | Write a 64-bit signed integer to mutable address; offset in 8-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64OffAddr# :: Addr# -> Int# -> Int64# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64X2Array# :: MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64X2OffAddr# :: Addr# -> Int# -> Int64X2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64X4Array# :: MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64X4OffAddr# :: Addr# -> Int# -> Int64X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64X8Array# :: MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64X8OffAddr# :: Addr# -> Int# -> Int64X8# -> State# d -> State# d

-- | Write an 8-bit signed integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8Array# :: MutableByteArray# d -> Int# -> Int8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8ArrayAsInt8X16# :: MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8ArrayAsInt8X32# :: MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8ArrayAsInt8X64# :: MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d

-- | Write an 8-bit signed integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8OffAddr# :: Addr# -> Int# -> Int8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8X16Array# :: MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8X16OffAddr# :: Addr# -> Int# -> Int8X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8X32Array# :: MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8X32OffAddr# :: Addr# -> Int# -> Int8X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8X64Array# :: MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8X64OffAddr# :: Addr# -> Int# -> Int8X64# -> State# d -> State# d

-- | Write a word-sized integer to mutable array; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Write a word-sized integer to mutable address; offset in machine
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeIntOffAddr# :: Addr# -> Int# -> Int# -> State# d -> State# d

-- | Write contents of <a>MutVar#</a>.
writeMutVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutVar# d a -> a -> State# d -> State# d

-- | Write to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeSmallArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> a -> State# d -> State# d

-- | Write a <a>StablePtr#</a> value to mutable array; offset in machine
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeStablePtrArray# :: MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d

-- | Write a <a>StablePtr#</a> value to mutable address; offset in machine
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a -> State# d -> State# d

-- | Write contents of <a>TVar#</a>.
writeTVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). TVar# d a -> a -> State# d -> State# d

-- | Write a 32-bit character to mutable array; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWideCharArray# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d

-- | Write a 32-bit character to mutable address; offset in 4-byte words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWideCharOffAddr# :: Addr# -> Int# -> Char# -> State# d -> State# d

-- | Write a 16-bit unsigned integer to mutable array; offset in 2-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16Array# :: MutableByteArray# d -> Int# -> Word16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16ArrayAsWord16X16# :: MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16ArrayAsWord16X32# :: MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16ArrayAsWord16X8# :: MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d

-- | Write a 16-bit unsigned integer to mutable address; offset in 2-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16OffAddr# :: Addr# -> Int# -> Word16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16X16Array# :: MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16X16OffAddr# :: Addr# -> Int# -> Word16X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16X32Array# :: MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16X32OffAddr# :: Addr# -> Int# -> Word16X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16X8Array# :: MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16X8OffAddr# :: Addr# -> Int# -> Word16X8# -> State# d -> State# d

-- | Write a 32-bit unsigned integer to mutable array; offset in 4-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32Array# :: MutableByteArray# d -> Int# -> Word32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32ArrayAsWord32X16# :: MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32ArrayAsWord32X4# :: MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32ArrayAsWord32X8# :: MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d

-- | Write a 32-bit unsigned integer to mutable address; offset in 4-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32OffAddr# :: Addr# -> Int# -> Word32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32X16Array# :: MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32X16OffAddr# :: Addr# -> Int# -> Word32X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32X4Array# :: MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32X4OffAddr# :: Addr# -> Int# -> Word32X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32X8Array# :: MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32X8OffAddr# :: Addr# -> Int# -> Word32X8# -> State# d -> State# d

-- | Write a 64-bit unsigned integer to mutable array; offset in 8-byte
--   words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64Array# :: MutableByteArray# d -> Int# -> Word64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64ArrayAsWord64X2# :: MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64ArrayAsWord64X4# :: MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64ArrayAsWord64X8# :: MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d

-- | Write a 64-bit unsigned integer to mutable address; offset in 8-byte
--   words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64OffAddr# :: Addr# -> Int# -> Word64# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64X2Array# :: MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64X2OffAddr# :: Addr# -> Int# -> Word64X2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64X4Array# :: MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64X4OffAddr# :: Addr# -> Int# -> Word64X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64X8Array# :: MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64X8OffAddr# :: Addr# -> Int# -> Word64X8# -> State# d -> State# d

-- | Write an 8-bit unsigned integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8Array# :: MutableByteArray# d -> Int# -> Word8# -> State# d -> State# d

-- | Write a machine address to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsAddr# :: MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d

-- | Write an 8-bit character to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsChar# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d

-- | Write a double-precision floating-point value to mutable array; offset
--   in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsDouble# :: MutableByteArray# d -> Int# -> Double# -> State# d -> State# d

-- | Write a single-precision floating-point value to mutable array; offset
--   in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsFloat# :: MutableByteArray# d -> Int# -> Float# -> State# d -> State# d

-- | Write a word-sized integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt# :: MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Write a 16-bit signed integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt16# :: MutableByteArray# d -> Int# -> Int16# -> State# d -> State# d

-- | Write a 32-bit signed integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt32# :: MutableByteArray# d -> Int# -> Int32# -> State# d -> State# d

-- | Write a 64-bit signed integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt64# :: MutableByteArray# d -> Int# -> Int64# -> State# d -> State# d

-- | Write a <a>StablePtr#</a> value to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsStablePtr# :: MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d

-- | Write a 32-bit character to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWideChar# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d

-- | Write a word-sized unsigned integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord# :: MutableByteArray# d -> Int# -> Word# -> State# d -> State# d

-- | Write a 16-bit unsigned integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord16# :: MutableByteArray# d -> Int# -> Word16# -> State# d -> State# d

-- | Write a 32-bit unsigned integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord32# :: MutableByteArray# d -> Int# -> Word32# -> State# d -> State# d

-- | Write a 64-bit unsigned integer to mutable array; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord64# :: MutableByteArray# d -> Int# -> Word64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord8X16# :: MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord8X32# :: MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord8X64# :: MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d

-- | Write an 8-bit unsigned integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddr# :: Addr# -> Int# -> Word8# -> State# d -> State# d

-- | Write a machine address to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsAddr# :: Addr# -> Int# -> Addr# -> State# d -> State# d

-- | Write an 8-bit character to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsChar# :: Addr# -> Int# -> Char# -> State# d -> State# d

-- | Write a double-precision floating-point value to mutable address;
--   offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsDouble# :: Addr# -> Int# -> Double# -> State# d -> State# d

-- | Write a single-precision floating-point value to mutable address;
--   offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsFloat# :: Addr# -> Int# -> Float# -> State# d -> State# d

-- | Write a word-sized integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsInt# :: Addr# -> Int# -> Int# -> State# d -> State# d

-- | Write a 16-bit signed integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsInt16# :: Addr# -> Int# -> Int16# -> State# d -> State# d

-- | Write a 32-bit signed integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsInt32# :: Addr# -> Int# -> Int32# -> State# d -> State# d

-- | Write a 64-bit signed integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsInt64# :: Addr# -> Int# -> Int64# -> State# d -> State# d

-- | Write a <a>StablePtr#</a> value to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsStablePtr# :: Addr# -> Int# -> StablePtr# a -> State# d -> State# d

-- | Write a 32-bit character to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWideChar# :: Addr# -> Int# -> Char# -> State# d -> State# d

-- | Write a word-sized unsigned integer to mutable address; offset in
--   bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWord# :: Addr# -> Int# -> Word# -> State# d -> State# d

-- | Write a 16-bit unsigned integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWord16# :: Addr# -> Int# -> Word16# -> State# d -> State# d

-- | Write a 32-bit unsigned integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWord32# :: Addr# -> Int# -> Word32# -> State# d -> State# d

-- | Write a 64-bit unsigned integer to mutable address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWord64# :: Addr# -> Int# -> Word64# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8X16Array# :: MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8X16OffAddr# :: Addr# -> Int# -> Word8X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8X32Array# :: MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8X32OffAddr# :: Addr# -> Int# -> Word8X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8X64Array# :: MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8X64OffAddr# :: Addr# -> Int# -> Word8X64# -> State# d -> State# d

-- | Write a word-sized unsigned integer to mutable array; offset in
--   machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWordArray# :: MutableByteArray# d -> Int# -> Word# -> State# d -> State# d

-- | Write a word-sized unsigned integer to mutable address; offset in
--   machine words.
--   
--   On some platforms, the access may fail for an insufficiently aligned
--   <tt>Addr#</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWordOffAddr# :: Addr# -> Int# -> Word# -> State# d -> State# d
xor# :: Word# -> Word# -> Word#
xor64# :: Word64# -> Word64# -> Word64#

-- | Bitwise "xor".
xorI# :: Int# -> Int# -> Int#
xorWord16# :: Word16# -> Word16# -> Word16#
xorWord32# :: Word32# -> Word32# -> Word32#
xorWord8# :: Word8# -> Word8# -> Word8#
yield# :: State# RealWorld -> State# RealWorld

-- | An arbitrary machine address assumed to point outside the
--   garbage-collected heap.
data Addr# :: TYPE 'AddrRep
data Array# (a :: TYPE 'BoxedRep l) :: UnliftedType

-- | Primitive bytecode type.
data BCO

-- | A boxed, unlifted datatype representing a region of raw memory in the
--   garbage-collected heap, which is not scanned for pointers during
--   garbage collection.
--   
--   It is created by freezing a <a>MutableByteArray#</a> with
--   <a>unsafeFreezeByteArray#</a>. Freezing is essentially a no-op, as
--   <a>MutableByteArray#</a> and <a>ByteArray#</a> share the same heap
--   structure under the hood.
--   
--   The immutable and mutable variants are commonly used for scenarios
--   requiring high-performance data structures, like <tt>Text</tt>,
--   <tt>Primitive Vector</tt>, <tt>Unboxed Array</tt>, and
--   <tt>ShortByteString</tt>.
--   
--   Another application of fundamental importance is <tt>Integer</tt>,
--   which is backed by <a>ByteArray#</a>.
--   
--   The representation on the heap of a Byte Array is:
--   
--   <pre>
--   +------------+-----------------+-----------------------+
--   |            |                 |                       |
--   |   HEADER   | SIZE (in bytes) |       PAYLOAD         |
--   |            |                 |                       |
--   +------------+-----------------+-----------------------+
--   </pre>
--   
--   To obtain a pointer to actual payload (e.g., for FFI purposes) use
--   <a>byteArrayContents#</a> or <a>mutableByteArrayContents#</a>.
--   
--   Alternatively, enabling the <tt>UnliftedFFITypes</tt> extension allows
--   to mention <a>ByteArray#</a> and <a>MutableByteArray#</a> in FFI type
--   signatures directly.
data ByteArray# :: UnliftedType
data CONSTRAINT (a :: RuntimeRep)
data Char# :: TYPE 'WordRep
data Compact# :: UnliftedType
data Double# :: TYPE 'DoubleRep
data DoubleX2# :: TYPE 'VecRep 'Vec2 'DoubleElemRep
data DoubleX4# :: TYPE 'VecRep 'Vec4 'DoubleElemRep
data DoubleX8# :: TYPE 'VecRep 'Vec8 'DoubleElemRep

-- | The builtin function type, written in infix form as <tt>a % m -&gt;
--   b</tt>. Values of this type are functions taking inputs of type
--   <tt>a</tt> and producing outputs of type <tt>b</tt>. The multiplicity
--   of the input is <tt>m</tt>.
--   
--   Note that <tt><a>FUN</a> m a b</tt> permits representation
--   polymorphism in both <tt>a</tt> and <tt>b</tt>, so that types like
--   <tt><a>Int#</a> -&gt; <a>Int#</a></tt> can still be well-kinded.
data FUN
data Float# :: TYPE 'FloatRep
data FloatX16# :: TYPE 'VecRep 'Vec16 'FloatElemRep
data FloatX4# :: TYPE 'VecRep 'Vec4 'FloatElemRep
data FloatX8# :: TYPE 'VecRep 'Vec8 'FloatElemRep

-- | A shared I/O port is almost the same as an <a>MVar#</a>. The main
--   difference is that IOPort has no deadlock detection or deadlock
--   breaking code that forcibly releases the lock.
data IOPort# a (b :: TYPE 'BoxedRep l) :: UnliftedType
data Int# :: TYPE 'IntRep
data Int16# :: TYPE 'Int16Rep
data Int16X16# :: TYPE 'VecRep 'Vec16 'Int16ElemRep
data Int16X32# :: TYPE 'VecRep 'Vec32 'Int16ElemRep
data Int16X8# :: TYPE 'VecRep 'Vec8 'Int16ElemRep
data Int32# :: TYPE 'Int32Rep
data Int32X16# :: TYPE 'VecRep 'Vec16 'Int32ElemRep
data Int32X4# :: TYPE 'VecRep 'Vec4 'Int32ElemRep
data Int32X8# :: TYPE 'VecRep 'Vec8 'Int32ElemRep
data Int64# :: TYPE 'Int64Rep
data Int64X2# :: TYPE 'VecRep 'Vec2 'Int64ElemRep
data Int64X4# :: TYPE 'VecRep 'Vec4 'Int64ElemRep
data Int64X8# :: TYPE 'VecRep 'Vec8 'Int64ElemRep
data Int8# :: TYPE 'Int8Rep
data Int8X16# :: TYPE 'VecRep 'Vec16 'Int8ElemRep
data Int8X32# :: TYPE 'VecRep 'Vec32 'Int8ElemRep
data Int8X64# :: TYPE 'VecRep 'Vec64 'Int8ElemRep

-- | A shared mutable variable (<i>not</i> the same as a <a>MutVar#</a>!).
--   (Note: in a non-concurrent implementation, <tt>(<a>MVar#</a> a)</tt>
--   can be represented by <tt>(<a>MutVar#</a> (Maybe a))</tt>.)
data MVar# a (b :: TYPE 'BoxedRep l) :: UnliftedType

-- | A <a>MutVar#</a> behaves like a single-element mutable array.
data MutVar# a (b :: TYPE 'BoxedRep l) :: UnliftedType
data MutableArray# a (b :: TYPE 'BoxedRep l) :: UnliftedType

-- | A mutable <tt>ByteAray#</tt>. It can be created in three ways:
--   
--   <ul>
--   <li><a>newByteArray#</a>: Create an unpinned array.</li>
--   <li><a>newPinnedByteArray#</a>: This will create a pinned array,</li>
--   <li><a>newAlignedPinnedByteArray#</a>: This will create a pinned
--   array, with a custom alignment.</li>
--   </ul>
--   
--   Unpinned arrays can be moved around during garbage collection, so you
--   must not store or pass pointers to these values if there is a chance
--   for the garbage collector to kick in. That said, even unpinned arrays
--   can be passed to unsafe FFI calls, because no garbage collection
--   happens during these unsafe calls (see <a>Guaranteed Call Safety</a>
--   in the GHC Manual). For safe FFI calls, byte arrays must be not only
--   pinned, but also kept alive by means of the keepAlive# function for
--   the duration of a call (that's because garbage collection cannot move
--   a pinned array, but is free to scrap it altogether).
data MutableByteArray# a :: UnliftedType

-- | See <a>GHC.Prim#continuations</a>.
data PromptTag# a :: UnliftedType

-- | The type constructor <a>Proxy#</a> is used to bear witness to some
--   type variable. It's used when you want to pass around proxy values for
--   doing things like modelling type applications. A <a>Proxy#</a> is not
--   only unboxed, it also has a polymorphic kind, and has no runtime
--   representation, being totally free.
data Proxy# (a :: k) :: ZeroBitType

-- | <a>RealWorld</a> is deeply magical. It is <i>primitive</i>, but it is
--   not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <a>RealWorld</a>; it's only used in the type system, to
--   parameterise <a>State#</a>.
data RealWorld
data SmallArray# (a :: TYPE 'BoxedRep l) :: UnliftedType
data SmallMutableArray# a (b :: TYPE 'BoxedRep l) :: UnliftedType
data StableName# (a :: TYPE 'BoxedRep l) :: UnliftedType
data StablePtr# (a :: TYPE 'BoxedRep l) :: TYPE 'AddrRep

-- | Haskell representation of a <tt>StgStack*</tt> that was created
--   (cloned) with a function in <a>GHC.Stack.CloneStack</a>. Please check
--   the documentation in that module for more detailed explanations.
data StackSnapshot# :: UnliftedType

-- | <a>State#</a> is the primitive, unlifted type of states. It has one
--   type parameter, thus <tt><a>State#</a> <a>RealWorld</a></tt>, or
--   <tt><a>State#</a> s</tt>, where s is a type variable. The only purpose
--   of the type parameter is to keep different state threads separate. It
--   is represented by nothing at all.
data State# a :: ZeroBitType
data TVar# a (b :: TYPE 'BoxedRep l) :: UnliftedType
data TYPE (a :: RuntimeRep)

-- | (In a non-concurrent implementation, this can be a singleton type,
--   whose (unique) value is returned by <a>myThreadId#</a>. The other
--   operations can be omitted.)
data ThreadId# :: UnliftedType
data Weak# (a :: TYPE 'BoxedRep l) :: UnliftedType
data Word# :: TYPE 'WordRep
data Word16# :: TYPE 'Word16Rep
data Word16X16# :: TYPE 'VecRep 'Vec16 'Word16ElemRep
data Word16X32# :: TYPE 'VecRep 'Vec32 'Word16ElemRep
data Word16X8# :: TYPE 'VecRep 'Vec8 'Word16ElemRep
data Word32# :: TYPE 'Word32Rep
data Word32X16# :: TYPE 'VecRep 'Vec16 'Word32ElemRep
data Word32X4# :: TYPE 'VecRep 'Vec4 'Word32ElemRep
data Word32X8# :: TYPE 'VecRep 'Vec8 'Word32ElemRep
data Word64# :: TYPE 'Word64Rep
data Word64X2# :: TYPE 'VecRep 'Vec2 'Word64ElemRep
data Word64X4# :: TYPE 'VecRep 'Vec4 'Word64ElemRep
data Word64X8# :: TYPE 'VecRep 'Vec8 'Word64ElemRep
data Word8# :: TYPE 'Word8Rep
data Word8X16# :: TYPE 'VecRep 'Vec16 'Word8ElemRep
data Word8X32# :: TYPE 'VecRep 'Vec32 'Word8ElemRep
data Word8X64# :: TYPE 'VecRep 'Vec64 'Word8ElemRep

-- | Apply a function to a <tt><a>State#</a> <a>RealWorld</a></tt> token.
--   When manually applying a function to <a>realWorld#</a>, it is
--   necessary to use <tt>NOINLINE</tt> to prevent semantically undesirable
--   floating. <a>runRW#</a> is inlined, but only very late in compilation
--   after all floating is complete.
runRW# :: forall (r :: RuntimeRep) (o :: TYPE r). (State# RealWorld -> o) -> o

-- | Shift the argument left by the specified number of bits (which must be
--   non-negative).
shiftL# :: Word# -> Int# -> Word#

-- | Shift the argument right by the specified number of bits (which must
--   be non-negative). The <a>RL</a> means "right, logical" (as opposed to
--   RA for arithmetic) (although an arithmetic right shift wouldn't make
--   sense for Word#)
shiftRL# :: Word# -> Int# -> Word#

-- | Shift the argument left by the specified number of bits (which must be
--   non-negative).
iShiftL# :: Int# -> Int# -> Int#

-- | Shift the argument right (signed) by the specified number of bits
--   (which must be non-negative). The <a>RA</a> means "right, arithmetic"
--   (as opposed to RL for logical)
iShiftRA# :: Int# -> Int# -> Int#

-- | Shift the argument right (unsigned) by the specified number of bits
--   (which must be non-negative). The <a>RL</a> means "right, logical" (as
--   opposed to RA for arithmetic)
iShiftRL# :: Int# -> Int# -> Int#

-- | Compare the underlying pointers of two values for equality.
--   
--   Returns <tt>1</tt> if the pointers are equal and <tt>0</tt> otherwise.
--   
--   The two values must be of the same type, of kind <tt>Type</tt>. See
--   also <a>reallyUnsafePtrEquality#</a>, which doesn't have such
--   restrictions.
reallyUnsafePtrEquality :: a -> a -> Int#

-- | Compare the underlying pointers of two unlifted values for equality.
--   
--   This is less dangerous than <a>reallyUnsafePtrEquality</a>, since the
--   arguments are guaranteed to be evaluated. This means there is no risk
--   of accidentally comparing a thunk. It's however still more dangerous
--   than e.g. <a>sameArray#</a>.
unsafePtrEquality# :: forall (a :: UnliftedType) (b :: UnliftedType). a -> b -> Int#

-- | Compare two stable names for equality.
eqStableName# :: forall {k :: Levity} {l :: Levity} (a :: TYPE ('BoxedRep k)) (b :: TYPE ('BoxedRep l)). StableName# a -> StableName# b -> Int#

-- | Compare the underlying pointers of two arrays.
sameArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Array# a -> Array# a -> Int#

-- | Compare the underlying pointers of two mutable arrays.
sameMutableArray# :: forall {l :: Levity} s (a :: TYPE ('BoxedRep l)). MutableArray# s a -> MutableArray# s a -> Int#

-- | Compare the underlying pointers of two small arrays.
sameSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). SmallArray# a -> SmallArray# a -> Int#

-- | Compare the underlying pointers of two small mutable arrays.
sameSmallMutableArray# :: forall {l :: Levity} s (a :: TYPE ('BoxedRep l)). SmallMutableArray# s a -> SmallMutableArray# s a -> Int#

-- | Compare the pointers of two byte arrays.
sameByteArray# :: ByteArray# -> ByteArray# -> Int#

-- | Compare the underlying pointers of two mutable byte arrays.
sameMutableByteArray# :: MutableByteArray# s -> MutableByteArray# s -> Int#

-- | Compare the underlying pointers of two <a>MVar#</a>s.
sameMVar# :: forall {l :: Levity} s (a :: TYPE ('BoxedRep l)). MVar# s a -> MVar# s a -> Int#

-- | Compare the underlying pointers of two <a>MutVar#</a>s.
sameMutVar# :: forall {l :: Levity} s (a :: TYPE ('BoxedRep l)). MutVar# s a -> MutVar# s a -> Int#

-- | Compare the underlying pointers of two <a>TVar#</a>s.
sameTVar# :: forall {l :: Levity} s (a :: TYPE ('BoxedRep l)). TVar# s a -> TVar# s a -> Int#

-- | Compare the underlying pointers of two <a>IOPort#</a>s.
sameIOPort# :: forall {l :: Levity} s (a :: TYPE ('BoxedRep l)). IOPort# s a -> IOPort# s a -> Int#

-- | Compare the underlying pointers of two <a>PromptTag#</a>s.
samePromptTag# :: PromptTag# a -> PromptTag# a -> Int#

-- | An implementation of the old <tt>atomicModifyMutVar#</tt> primop in
--   terms of the new <a>atomicModifyMutVar2#</a> primop, for backwards
--   compatibility. The type of this function is a bit bogus. It's best to
--   think of it as having type
--   
--   <pre>
--   atomicModifyMutVar#
--     :: MutVar# s a
--     -&gt; (a -&gt; (a, b))
--     -&gt; State# s
--     -&gt; (# State# s, b #)
--   </pre>
--   
--   but there may be code that uses this with other two-field record
--   types.
atomicModifyMutVar# :: MutVar# s a -> (a -> b) -> State# s -> (# State# s, c #)

-- | Resize a mutable array to new specified size. The returned
--   <a>SmallMutableArray#</a> is either the original
--   <a>SmallMutableArray#</a> resized in-place or, if not possible, a
--   newly allocated <a>SmallMutableArray#</a> with the original content
--   copied over.
--   
--   To avoid undefined behaviour, the original <a>SmallMutableArray#</a>
--   shall not be accessed anymore after a <a>resizeSmallMutableArray#</a>
--   has been performed. Moreover, no reference to the old one should be
--   kept in order to allow garbage collection of the original
--   <a>SmallMutableArray#</a> in case a new <a>SmallMutableArray#</a> had
--   to be allocated.
resizeSmallMutableArray# :: SmallMutableArray# s a -> Int# -> a -> State# s -> (# State# s, SmallMutableArray# s a #)

-- | A list producer that can be fused with <a>foldr</a>. This function is
--   merely
--   
--   <pre>
--   build g = g (:) []
--   </pre>
--   
--   but GHC's simplifier will transform an expression of the form
--   <tt><a>foldr</a> k z (<a>build</a> g)</tt>, which may arise after
--   inlining, to <tt>g k z</tt>, which avoids producing an intermediate
--   list.
build :: (forall b. () => (a -> b -> b) -> b -> b) -> [a]

-- | A list producer that can be fused with <a>foldr</a>. This function is
--   merely
--   
--   <pre>
--   augment g xs = g (:) xs
--   </pre>
--   
--   but GHC's simplifier will transform an expression of the form
--   <tt><a>foldr</a> k z (<a>augment</a> g xs)</tt>, which may arise after
--   inlining, to <tt>g k (<a>foldr</a> k z xs)</tt>, which avoids
--   producing an intermediate list.
augment :: (forall b. () => (a -> b -> b) -> b -> b) -> [a] -> [a]

-- | The <a>IsList</a> class and its methods are intended to be used in
--   conjunction with the OverloadedLists extension.
class IsList l where {
    
    -- | The <a>Item</a> type function returns the type of items of the
    --   structure <tt>l</tt>.
    type Item l;
}

-- | The <a>fromList</a> function constructs the structure <tt>l</tt> from
--   the given list of <tt>Item l</tt>
fromList :: IsList l => [Item l] -> l

-- | The <a>fromListN</a> function takes the input list's length and
--   potentially uses it to construct the structure <tt>l</tt> more
--   efficiently compared to <a>fromList</a>. If the given number does not
--   equal to the input list's length the behaviour of <a>fromListN</a> is
--   not specified.
--   
--   <pre>
--   fromListN (length xs) xs == fromList xs
--   </pre>
fromListN :: IsList l => Int -> [Item l] -> l

-- | The <a>toList</a> function extracts a list of <tt>Item l</tt> from the
--   structure <tt>l</tt>. It should satisfy fromList . toList = id.
toList :: IsList l => l -> [Item l]

-- | The <a>Down</a> type allows you to reverse sort order conveniently. A
--   value of type <tt><a>Down</a> a</tt> contains a value of type
--   <tt>a</tt> (represented as <tt><a>Down</a> a</tt>).
--   
--   If <tt>a</tt> has an <tt><a>Ord</a></tt> instance associated with it
--   then comparing two values thus wrapped will give you the opposite of
--   their normal sort order. This is particularly useful when sorting in
--   generalised list comprehensions, as in: <tt>then sortWith by
--   <a>Down</a> x</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; compare True False
--   GT
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; compare (Down True) (Down False)
--   LT
--   </pre>
--   
--   If <tt>a</tt> has a <tt><a>Bounded</a></tt> instance then the wrapped
--   instance also respects the reversed ordering by exchanging the values
--   of <tt><a>minBound</a></tt> and <tt><a>maxBound</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; minBound :: Int
--   -9223372036854775808
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minBound :: Down Int
--   Down 9223372036854775807
--   </pre>
--   
--   All other instances of <tt><a>Down</a> a</tt> behave as they do for
--   <tt>a</tt>.
newtype Down a
Down :: a -> Down a

[getDown] :: Down a -> a

-- | The <a>groupWith</a> function uses the user supplied function which
--   projects an element out of every list element in order to first sort
--   the input list and then to form groups by equality on these projected
--   elements
groupWith :: Ord b => (a -> b) -> [a] -> [[a]]

-- | The <a>sortWith</a> function sorts a list of elements using the user
--   supplied function to project something out of each element
--   
--   In general if the user supplied function is expensive to compute then
--   you should probably be using <a>sortOn</a>, as it only needs to
--   compute it once for each element. <a>sortWith</a>, on the other hand
--   must compute the mapping function for every comparison that it
--   performs.
sortWith :: Ord b => (a -> b) -> [a] -> [a]

-- | <a>the</a> ensures that all the elements of the list are identical and
--   then returns that unique element
the :: Eq a => [a] -> a

-- | <a>IsString</a> is used in combination with the
--   <tt>-XOverloadedStrings</tt> language extension to convert the
--   literals to different string types.
--   
--   For example, if you use the <a>text</a> package, you can say
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings  #-}
--   
--   myText = "hello world" :: Text
--   </pre>
--   
--   Internally, the extension will convert this to the equivalent of
--   
--   <pre>
--   myText = fromString @Text ("hello world" :: String)
--   </pre>
--   
--   <b>Note:</b> You can use <tt>fromString</tt> in normal code as well,
--   but the usual performance/memory efficiency problems with
--   <a>String</a> apply.
class IsString a
fromString :: IsString a => String -> a
unpackCString# :: Addr# -> [Char]
unpackAppendCString# :: Addr# -> [Char] -> [Char]
unpackFoldrCString# :: Addr# -> (Char -> a -> a) -> a -> a
unpackCStringUtf8# :: Addr# -> [Char]
unpackNBytes# :: Addr# -> Int# -> [Char]

-- | Compute the length of a NUL-terminated string. This address must refer
--   to immutable memory. GHC includes a built-in rule for constant folding
--   when the argument is a statically-known literal. That is, a
--   core-to-core pass reduces the expression <tt>cstringLength#
--   "hello"#</tt> to the constant <tt>5#</tt>.
cstringLength# :: Addr# -> Int#
breakpoint :: a -> a
breakpointCond :: Bool -> a -> a

-- | <i>Deprecated: Use <a>traceEvent</a> or <a>traceEventIO</a></i>
traceEvent :: String -> IO ()

-- | Returns a <tt>[String]</tt> representing the current call stack. This
--   can be useful for debugging.
--   
--   The implementation uses the call-stack simulation maintained by the
--   profiler, so it only works if the program was compiled with
--   <tt>-prof</tt> and contains suitable SCC annotations (e.g. by using
--   <tt>-fprof-auto</tt>). Otherwise, the list returned is likely to be
--   empty or uninformative.
currentCallStack :: IO [String]

-- | The call <tt>inline f</tt> arranges that <tt>f</tt> is inlined,
--   regardless of its size. More precisely, the call <tt>inline f</tt>
--   rewrites to the right-hand side of <tt>f</tt>'s definition. This
--   allows the programmer to control inlining from a particular call site
--   rather than the definition site of the function (c.f. <tt>INLINE</tt>
--   pragmas).
--   
--   This inlining occurs regardless of the argument to the call or the
--   size of <tt>f</tt>'s definition; it is unconditional. The main caveat
--   is that <tt>f</tt>'s definition must be visible to the compiler; it is
--   therefore recommended to mark the function with an <tt>INLINABLE</tt>
--   pragma at its definition so that GHC guarantees to record its
--   unfolding regardless of size.
--   
--   If no inlining takes place, the <a>inline</a> function expands to the
--   identity function in Phase zero, so its use imposes no overhead.
inline :: a -> a

-- | The call <tt>noinline f</tt> arranges that <tt>f</tt> will not be
--   inlined. It is removed during CorePrep so that its use imposes no
--   overhead (besides the fact that it blocks inlining.)
noinline :: a -> a

-- | The <a>lazy</a> function restrains strictness analysis a little. The
--   call <tt>lazy e</tt> means the same as <tt>e</tt>, but <a>lazy</a> has
--   a magical property so far as strictness analysis is concerned: it is
--   lazy in its first argument, even though its semantics is strict. After
--   strictness analysis has run, calls to <a>lazy</a> are inlined to be
--   the identity function.
--   
--   This behaviour is occasionally useful when controlling evaluation
--   order. Notably, <a>lazy</a> is used in the library definition of
--   <a>par</a>:
--   
--   <pre>
--   par :: a -&gt; b -&gt; b
--   par x y = case (par# x) of _ -&gt; lazy y
--   </pre>
--   
--   If <a>lazy</a> were not lazy, <a>par</a> would look strict in
--   <tt>y</tt> which would defeat the whole purpose of <a>par</a>.
lazy :: a -> a

-- | The <a>oneShot</a> function can be used to give a hint to the compiler
--   that its argument will be called at most once, which may (or may not)
--   enable certain optimizations. It can be useful to improve the
--   performance of code in continuation passing style.
--   
--   If <a>oneShot</a> is used wrongly, then it may be that computations
--   whose result that would otherwise be shared are re-evaluated every
--   time they are used. Otherwise, the use of <a>oneShot</a> is safe.
--   
--   <a>oneShot</a> is representation-polymorphic: the type variables may
--   refer to lifted or unlifted types.
oneShot :: forall {q :: RuntimeRep} {r :: RuntimeRep} (a :: TYPE q) (b :: TYPE r). (a -> b) -> a -> b

-- | Semantically, <tt>considerAccessible = True</tt>. But it has special
--   meaning to the pattern-match checker, which will never flag the clause
--   in which <a>considerAccessible</a> occurs as a guard as redundant or
--   inaccessible. Example:
--   
--   <pre>
--   case (x, x) of
--     (True,  True)  -&gt; 1
--     (False, False) -&gt; 2
--     (True,  False) -&gt; 3 -- Warning: redundant
--   </pre>
--   
--   The pattern-match checker will warn here that the third clause is
--   redundant. It will stop doing so if the clause is adorned with
--   <a>considerAccessible</a>:
--   
--   <pre>
--   case (x, x) of
--     (True,  True)  -&gt; 1
--     (False, False) -&gt; 2
--     (True,  False) | considerAccessible -&gt; 3 -- No warning
--   </pre>
--   
--   Put <a>considerAccessible</a> as the last statement of the guard to
--   avoid get confusing results from the pattern-match checker, which
--   takes "consider accessible" by word.
considerAccessible :: Bool

-- | The primitive used to implement <a>evaluate</a>. Prefer to use
--   <a>evaluate</a> whenever possible!
seq# :: a -> State# s -> (# State# s, a #)

-- | Deprecated, use <a>SPEC</a> directly instead.
--   
--   Annotating a type with <a>NoSpecConstr</a> will make
--   <tt>SpecConstr</tt> not specialise for arguments of that type, e. g.,
--   <tt>{-# ANN type SPEC ForceSpecConstr #-}</tt>.
data SpecConstrAnnotation
NoSpecConstr :: SpecConstrAnnotation
ForceSpecConstr :: SpecConstrAnnotation

-- | <a>SPEC</a> is used by GHC in the <tt>SpecConstr</tt> pass in order to
--   inform the compiler when to be particularly aggressive. In particular,
--   it tells GHC to specialize regardless of size or the number of
--   specializations. However, not all loops fall into this category.
--   
--   Libraries can specify this by using <a>SPEC</a> data type to inform
--   which loops should be aggressively specialized. For example, instead
--   of
--   
--   <pre>
--   loop x where loop arg = ...
--   </pre>
--   
--   write
--   
--   <pre>
--   loop SPEC x where loop !_ arg = ...
--   </pre>
--   
--   There is no semantic difference between <a>SPEC</a> and <a>SPEC2</a>,
--   we just need a type with two constructors lest it is optimised away
--   before <tt>SpecConstr</tt>.
--   
--   This type is reexported from <a>GHC.Exts</a> since GHC 9.0 and
--   <tt>base-4.15</tt>. For compatibility with earlier releases import it
--   from <a>GHC.Types</a> in <tt>ghc-prim</tt> package.
data SPEC
SPEC :: SPEC
SPEC2 :: SPEC

-- | The function <a>coerce</a> allows you to safely convert between values
--   of types that have the same representation with no run-time overhead.
--   In the simplest case you can use it instead of a newtype constructor,
--   to go from the newtype's concrete type to the abstract type. But it
--   also works in more complicated settings, e.g. converting a list of
--   newtypes to a list of concrete types.
--   
--   When used in conversions involving a newtype wrapper, make sure the
--   newtype constructor is in scope.
--   
--   This function is representation-polymorphic, but the
--   <tt>RuntimeRep</tt> type argument is marked as <tt>Inferred</tt>,
--   meaning that it is not available for visible type application. This
--   means the typechecker will accept <tt><a>coerce</a> @<tt>Int</tt> @Age
--   42</tt>.
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; newtype TTL = TTL Int deriving (Eq, Ord, Show)
--   
--   &gt;&gt;&gt; newtype Age = Age Int deriving (Eq, Ord, Show)
--   
--   &gt;&gt;&gt; coerce (Age 42) :: TTL
--   TTL 42
--   
--   &gt;&gt;&gt; coerce (+ (1 :: Int)) (Age 42) :: TTL
--   TTL 43
--   
--   &gt;&gt;&gt; coerce (map (+ (1 :: Int))) [Age 42, Age 24] :: [TTL]
--   [TTL 43,TTL 25]
--   </pre>
coerce :: forall {k :: RuntimeRep} (a :: TYPE k) (b :: TYPE k). Coercible a b => a -> b

-- | Highly, terribly dangerous coercion from one representation type to
--   another. Misuse of this function can invite the garbage collector to
--   trounce upon your data and then laugh in your face. You don't want
--   this function. Really.
--   
--   This becomes more obvious when looking at its actual type: <tt>forall
--   (r1 :: RuntimeRep) (r2 :: RuntimeRep) (a :: TYPE r1) (b :: TYPE r2). a
--   -&gt; b</tt> Which often get's rendered as <tt>a -&gt; b</tt> in
--   haddock for technical reasons.
unsafeCoerce# :: forall (r1 :: RuntimeRep) (r2 :: RuntimeRep) (a :: TYPE r1) (b :: TYPE r2). a -> b

-- | The constraint <tt><a>WithDict</a> cls meth</tt> can be solved when
--   evidence for the constraint <tt>cls</tt> can be provided in the form
--   of a dictionary of type <tt>meth</tt>. This requires <tt>cls</tt> to
--   be a class constraint whose single method has type <tt>meth</tt>.
--   
--   For more (important) details on how this works, see <tt>Note
--   [withDict]</tt> in <a>GHC.Tc.Instance.Class</a> in GHC.
class WithDict cls meth
withDict :: forall {rr :: RuntimeRep} (r :: TYPE rr). WithDict cls meth => meth -> (cls => r) -> r

-- | <tt><a>dataToTag#</a></tt> evaluates its argument and returns the
--   index (starting at zero) of the constructor used to produce that
--   argument. Any algebraic data type with all of its constructors in
--   scope may be used with <tt>dataToTag#</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dataToTag# (Left ())
--   0#
--   
--   &gt;&gt;&gt; dataToTag# (Right undefined)
--   1#
--   </pre>
class DataToTag (a :: TYPE 'BoxedRep lev)
dataToTag# :: DataToTag a => a -> Int#
maxTupleSize :: Int
instance GHC.Internal.Data.Data.Data GHC.Internal.Exts.SpecConstrAnnotation
instance GHC.Classes.Eq GHC.Internal.Exts.SpecConstrAnnotation


-- | Monadic zipping (used for monad comprehensions)
module GHC.Internal.Control.Monad.Zip

-- | Instances should satisfy the laws:
--   
--   <ul>
--   <li><i>Naturality</i> <pre><a>liftM</a> (f <a>***</a> g) (<a>mzip</a>
--   ma mb) = <a>mzip</a> (<a>liftM</a> f ma) (<a>liftM</a> g
--   mb)</pre></li>
--   <li><i>Information Preservation</i> <tt><a>liftM</a> (<a>const</a> ())
--   ma = <a>liftM</a> (<a>const</a> ()) mb</tt> implies <tt><a>munzip</a>
--   (<a>mzip</a> ma mb) = (ma, mb)</tt></li>
--   </ul>
class Monad m => MonadZip (m :: Type -> Type)
mzip :: MonadZip m => m a -> m b -> m (a, b)
mzipWith :: MonadZip m => (a -> b -> c) -> m a -> m b -> m c
munzip :: MonadZip m => m (a, b) -> (m a, m b)
instance (GHC.Internal.Control.Monad.Zip.MonadZip f, GHC.Internal.Control.Monad.Zip.MonadZip g) => GHC.Internal.Control.Monad.Zip.MonadZip (f GHC.Internal.Generics.:*: g)
instance GHC.Internal.Control.Monad.Zip.MonadZip f => GHC.Internal.Control.Monad.Zip.MonadZip (GHC.Internal.Data.Semigroup.Internal.Alt f)
instance GHC.Internal.Control.Monad.Zip.MonadZip GHC.Internal.Data.Ord.Down
instance GHC.Internal.Control.Monad.Zip.MonadZip GHC.Internal.Data.Semigroup.Internal.Dual
instance GHC.Internal.Control.Monad.Zip.MonadZip GHC.Internal.Data.Monoid.First
instance GHC.Internal.Control.Monad.Zip.MonadZip GHC.Internal.Data.Functor.Identity.Identity
instance GHC.Internal.Control.Monad.Zip.MonadZip GHC.Internal.Data.Monoid.Last
instance GHC.Internal.Control.Monad.Zip.MonadZip []
instance GHC.Internal.Control.Monad.Zip.MonadZip f => GHC.Internal.Control.Monad.Zip.MonadZip (GHC.Internal.Generics.M1 i c f)
instance GHC.Internal.Control.Monad.Zip.MonadZip GHC.Internal.Maybe.Maybe
instance GHC.Internal.Control.Monad.Zip.MonadZip GHC.Internal.Base.NonEmpty
instance GHC.Internal.Control.Monad.Zip.MonadZip GHC.Internal.Generics.Par1
instance GHC.Internal.Control.Monad.Zip.MonadZip GHC.Internal.Data.Semigroup.Internal.Product
instance GHC.Internal.Control.Monad.Zip.MonadZip GHC.Internal.Data.Proxy.Proxy
instance GHC.Internal.Control.Monad.Zip.MonadZip f => GHC.Internal.Control.Monad.Zip.MonadZip (GHC.Internal.Generics.Rec1 f)
instance GHC.Internal.Control.Monad.Zip.MonadZip GHC.Tuple.Solo
instance GHC.Internal.Control.Monad.Zip.MonadZip GHC.Internal.Data.Semigroup.Internal.Sum
instance GHC.Internal.Control.Monad.Zip.MonadZip GHC.Internal.Generics.U1


-- | This module presents an identical interface to
--   <a>Control.Monad.ST</a>, except that the monad delays evaluation of
--   <a>ST</a> operations until a value depending on them is required.
module GHC.Internal.Control.Monad.ST.Lazy.Imp

-- | The lazy <tt><a>ST</a></tt> monad. The ST monad allows for destructive
--   updates, but is escapable (unlike <tt>IO</tt>). A computation of type
--   <tt><a>ST</a> s a</tt> returns a value of type <tt>a</tt>, and
--   executes in "thread" <tt>s</tt>. The <tt>s</tt> parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are not strict in
--   the state. For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= readSTRef _|_ &gt;&gt; return 2) = 2
--   </pre>
data ST s a

-- | Return the value computed by an <a>ST</a> computation. The
--   <tt>forall</tt> ensures that the internal state used by the <a>ST</a>
--   computation is inaccessible to the rest of the program.
runST :: (forall s. () => ST s a) -> a

-- | Allow the result of an <a>ST</a> computation to be used (lazily)
--   inside the computation. Note that if <tt>f</tt> is strict,
--   <tt><a>fixST</a> f = _|_</tt>.
fixST :: (a -> ST s a) -> ST s a

-- | Convert a strict <a>ST</a> computation into a lazy one. The strict
--   state thread passed to <a>strictToLazyST</a> is not performed until
--   the result of the lazy state thread it returns is demanded.
strictToLazyST :: ST s a -> ST s a

-- | Convert a lazy <a>ST</a> computation into a strict one.
lazyToStrictST :: ST s a -> ST s a

-- | <a>RealWorld</a> is deeply magical. It is <i>primitive</i>, but it is
--   not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <a>RealWorld</a>; it's only used in the type system, to
--   parameterise <a>State#</a>.
data RealWorld

-- | A monad transformer embedding lazy <a>ST</a> in the <a>IO</a> monad.
--   The <a>RealWorld</a> parameter indicates that the internal state used
--   by the <a>ST</a> computation is a special one supplied by the
--   <a>IO</a> monad, and thus distinct from those used by invocations of
--   <a>runST</a>.
stToIO :: ST RealWorld a -> IO a
unsafeInterleaveST :: ST s a -> ST s a
unsafeIOToST :: IO a -> ST s a
instance GHC.Internal.Base.Applicative (GHC.Internal.Control.Monad.ST.Lazy.Imp.ST s)
instance GHC.Internal.Base.Functor (GHC.Internal.Control.Monad.ST.Lazy.Imp.ST s)
instance GHC.Internal.Control.Monad.Fix.MonadFix (GHC.Internal.Control.Monad.ST.Lazy.Imp.ST s)
instance GHC.Internal.Base.Monad (GHC.Internal.Control.Monad.ST.Lazy.Imp.ST s)


-- | This module presents an identical interface to
--   <a>Control.Monad.ST</a>, except that the monad delays evaluation of
--   state operations until a value depending on them is required.
module GHC.Internal.Control.Monad.ST.Lazy

-- | The lazy <tt><a>ST</a></tt> monad. The ST monad allows for destructive
--   updates, but is escapable (unlike <tt>IO</tt>). A computation of type
--   <tt><a>ST</a> s a</tt> returns a value of type <tt>a</tt>, and
--   executes in "thread" <tt>s</tt>. The <tt>s</tt> parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are not strict in
--   the state. For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= readSTRef _|_ &gt;&gt; return 2) = 2
--   </pre>
data ST s a

-- | Return the value computed by an <a>ST</a> computation. The
--   <tt>forall</tt> ensures that the internal state used by the <a>ST</a>
--   computation is inaccessible to the rest of the program.
runST :: (forall s. () => ST s a) -> a

-- | Allow the result of an <a>ST</a> computation to be used (lazily)
--   inside the computation. Note that if <tt>f</tt> is strict,
--   <tt><a>fixST</a> f = _|_</tt>.
fixST :: (a -> ST s a) -> ST s a

-- | Convert a strict <a>ST</a> computation into a lazy one. The strict
--   state thread passed to <a>strictToLazyST</a> is not performed until
--   the result of the lazy state thread it returns is demanded.
strictToLazyST :: ST s a -> ST s a

-- | Convert a lazy <a>ST</a> computation into a strict one.
lazyToStrictST :: ST s a -> ST s a

-- | <a>RealWorld</a> is deeply magical. It is <i>primitive</i>, but it is
--   not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <a>RealWorld</a>; it's only used in the type system, to
--   parameterise <a>State#</a>.
data RealWorld

-- | A monad transformer embedding lazy <a>ST</a> in the <a>IO</a> monad.
--   The <a>RealWorld</a> parameter indicates that the internal state used
--   by the <a>ST</a> computation is a special one supplied by the
--   <a>IO</a> monad, and thus distinct from those used by invocations of
--   <a>runST</a>.
stToIO :: ST RealWorld a -> IO a


-- | Basic arrow definitions, based on
--   
--   <ul>
--   <li><i>Generalising Monads to Arrows</i>, by John Hughes, <i>Science
--   of Computer Programming</i> 37, pp67-111, May 2000.</li>
--   </ul>
--   
--   plus a couple of definitions (<a>returnA</a> and <a>loop</a>) from
--   
--   <ul>
--   <li><i>A New Notation for Arrows</i>, by Ross Paterson, in <i>ICFP
--   2001</i>, Firenze, Italy, pp229-240.</li>
--   </ul>
--   
--   These papers and more information on arrows can be found at
--   <a>http://www.haskell.org/arrows/</a>.
module GHC.Internal.Control.Arrow

-- | The basic arrow class.
--   
--   Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>arr</a> id = <a>id</a></pre></li>
--   <li><pre><a>arr</a> (f &gt;&gt;&gt; g) = <a>arr</a> f &gt;&gt;&gt;
--   <a>arr</a> g</pre></li>
--   <li><pre><a>first</a> (<a>arr</a> f) = <a>arr</a> (<a>first</a>
--   f)</pre></li>
--   <li><pre><a>first</a> (f &gt;&gt;&gt; g) = <a>first</a> f &gt;&gt;&gt;
--   <a>first</a> g</pre></li>
--   <li><pre><a>first</a> f &gt;&gt;&gt; <a>arr</a> <a>fst</a> =
--   <a>arr</a> <a>fst</a> &gt;&gt;&gt; f</pre></li>
--   <li><pre><a>first</a> f &gt;&gt;&gt; <a>arr</a> (<a>id</a> *** g) =
--   <a>arr</a> (<a>id</a> *** g) &gt;&gt;&gt; <a>first</a> f</pre></li>
--   <li><pre><a>first</a> (<a>first</a> f) &gt;&gt;&gt; <a>arr</a> assoc =
--   <a>arr</a> assoc &gt;&gt;&gt; <a>first</a> f</pre></li>
--   </ul>
--   
--   where
--   
--   <pre>
--   assoc ((a,b),c) = (a,(b,c))
--   </pre>
--   
--   The other combinators have sensible default definitions, which may be
--   overridden for efficiency.
class Category a => Arrow (a :: Type -> Type -> Type)

-- | Lift a function to an arrow.
--   
--   <pre>
--     b ╭───╮ c
--   &gt;───┤ f ├───&gt;
--       ╰───╯
--   </pre>
arr :: Arrow a => (b -> c) -> a b c

-- | Send the first component of the input through the argument arrow, and
--   copy the rest unchanged to the output.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
--   
--   <pre>
--     b ╭─────╮ c
--   &gt;───┼─ f ─┼───&gt;
--   &gt;───┼─────┼───&gt;
--     d ╰─────╯ d
--   </pre>
first :: Arrow a => a b c -> a (b, d) (c, d)

-- | Send the second component of the input through the argument arrow, and
--   copy the rest unchanged to the output.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
--   
--   <pre>
--     d ╭─────╮ d
--   &gt;───┼─────┼───&gt;
--   &gt;───┼─ f ─┼───&gt;
--     b ╰─────╯ c
--   </pre>
second :: Arrow a => a b c -> a (d, b) (d, c)

-- | Split the input between the two argument arrows and combine their
--   output. Note that this is in general not a functor.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
--   
--   <pre>
--     b ╭─────╮ b'
--   &gt;───┼─ f ─┼───&gt;
--   &gt;───┼─ g ─┼───&gt;
--     c ╰─────╯ c'
--   </pre>
(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')

-- | Fanout: send the input to both argument arrows and combine their
--   output.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
--   
--   <pre>
--       ╭───────╮ c
--     b │ ┌─ f ─┼───&gt;
--   &gt;───┼─┤     │
--       │ └─ g ─┼───&gt;
--       ╰───────╯ c'
--   </pre>
(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
infixr 3 ***
infixr 3 &&&

-- | Kleisli arrows of a monad.
newtype Kleisli (m :: Type -> Type) a b
Kleisli :: (a -> m b) -> Kleisli (m :: Type -> Type) a b
[runKleisli] :: Kleisli (m :: Type -> Type) a b -> a -> m b

-- | The identity arrow, which plays the role of <a>return</a> in arrow
--   notation.
--   
--   <pre>
--     b
--   &gt;───&gt;
--   </pre>
returnA :: Arrow a => a b b

-- | Precomposition with a pure function.
(^>>) :: Arrow a => (b -> c) -> a c d -> a b d
infixr 1 ^>>

-- | Postcomposition with a pure function.
(>>^) :: Arrow a => a b c -> (c -> d) -> a b d
infixr 1 >>^

-- | Left-to-right composition. This is useful if you want to write a
--   morphism as a pipeline going from left to right.
(>>>) :: forall {k} cat (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
infixr 1 >>>

-- | Right-to-left composition. This is a synonym for <a>(.)</a>, but it
--   can be useful to make the order of composition more apparent.
(<<<) :: forall {k} cat (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
infixr 1 <<<

-- | Precomposition with a pure function (right-to-left variant).
(<<^) :: Arrow a => a c d -> (b -> c) -> a b d
infixr 1 <<^

-- | Postcomposition with a pure function (right-to-left variant).
(^<<) :: Arrow a => (c -> d) -> a b c -> a b d
infixr 1 ^<<
class Arrow a => ArrowZero (a :: Type -> Type -> Type)
zeroArrow :: ArrowZero a => a b c

-- | A monoid on arrows.
class ArrowZero a => ArrowPlus (a :: Type -> Type -> Type)

-- | An associative operation with identity <a>zeroArrow</a>.
(<+>) :: ArrowPlus a => a b c -> a b c -> a b c
infixr 5 <+>

-- | Choice, for arrows that support it. This class underlies the
--   <tt>if</tt> and <tt>case</tt> constructs in arrow notation.
--   
--   Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>left</a> (<a>arr</a> f) = <a>arr</a> (<a>left</a>
--   f)</pre></li>
--   <li><pre><a>left</a> (f &gt;&gt;&gt; g) = <a>left</a> f &gt;&gt;&gt;
--   <a>left</a> g</pre></li>
--   <li><pre>f &gt;&gt;&gt; <a>arr</a> <a>Left</a> = <a>arr</a>
--   <a>Left</a> &gt;&gt;&gt; <a>left</a> f</pre></li>
--   <li><pre><a>left</a> f &gt;&gt;&gt; <a>arr</a> (<a>id</a> +++ g) =
--   <a>arr</a> (<a>id</a> +++ g) &gt;&gt;&gt; <a>left</a> f</pre></li>
--   <li><pre><a>left</a> (<a>left</a> f) &gt;&gt;&gt; <a>arr</a> assocsum
--   = <a>arr</a> assocsum &gt;&gt;&gt; <a>left</a> f</pre></li>
--   </ul>
--   
--   where
--   
--   <pre>
--   assocsum (Left (Left x)) = Left x
--   assocsum (Left (Right y)) = Right (Left y)
--   assocsum (Right z) = Right (Right z)
--   </pre>
--   
--   The other combinators have sensible default definitions, which may be
--   overridden for efficiency.
class Arrow a => ArrowChoice (a :: Type -> Type -> Type)

-- | Feed marked inputs through the argument arrow, passing the rest
--   through unchanged to the output.
left :: ArrowChoice a => a b c -> a (Either b d) (Either c d)

-- | A mirror image of <a>left</a>.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
right :: ArrowChoice a => a b c -> a (Either d b) (Either d c)

-- | Split the input between the two argument arrows, retagging and merging
--   their outputs. Note that this is in general not a functor.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')

-- | Fanin: Split the input between the two argument arrows and merge their
--   outputs.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(|||) :: ArrowChoice a => a b d -> a c d -> a (Either b c) d
infixr 2 |||
infixr 2 +++

-- | Some arrows allow application of arrow inputs to other inputs.
--   Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>first</a> (<a>arr</a> (\x -&gt; <a>arr</a> (\y -&gt;
--   (x,y)))) &gt;&gt;&gt; <a>app</a> = <a>id</a></pre></li>
--   <li><pre><a>first</a> (<a>arr</a> (g &gt;&gt;&gt;)) &gt;&gt;&gt;
--   <a>app</a> = <a>second</a> g &gt;&gt;&gt; <a>app</a></pre></li>
--   <li><pre><a>first</a> (<a>arr</a> (&gt;&gt;&gt; h)) &gt;&gt;&gt;
--   <a>app</a> = <a>app</a> &gt;&gt;&gt; h</pre></li>
--   </ul>
--   
--   Such arrows are equivalent to monads (see <a>ArrowMonad</a>).
class Arrow a => ArrowApply (a :: Type -> Type -> Type)
app :: ArrowApply a => a (a b c, b) c

-- | The <a>ArrowApply</a> class is equivalent to <a>Monad</a>: any monad
--   gives rise to a <a>Kleisli</a> arrow, and any instance of
--   <a>ArrowApply</a> defines a monad.
newtype ArrowMonad (a :: Type -> Type -> Type) b
ArrowMonad :: a () b -> ArrowMonad (a :: Type -> Type -> Type) b

-- | Any instance of <a>ArrowApply</a> can be made into an instance of
--   <a>ArrowChoice</a> by defining <a>left</a> = <a>leftApp</a>.
leftApp :: ArrowApply a => a b c -> a (Either b d) (Either c d)

-- | The <a>loop</a> operator expresses computations in which an output
--   value is fed back as input, although the computation occurs only once.
--   It underlies the <tt>rec</tt> value recursion construct in arrow
--   notation. <a>loop</a> should satisfy the following laws:
--   
--   <ul>
--   <li><i><i>extension</i></i> <tt><a>loop</a> (<a>arr</a> f) =
--   <a>arr</a> (\ b -&gt; <a>fst</a> (<a>fix</a> (\ (c,d) -&gt; f
--   (b,d))))</tt></li>
--   <li><i><i>left tightening</i></i> <tt><a>loop</a> (<a>first</a> h
--   &gt;&gt;&gt; f) = h &gt;&gt;&gt; <a>loop</a> f</tt></li>
--   <li><i><i>right tightening</i></i> <tt><a>loop</a> (f &gt;&gt;&gt;
--   <a>first</a> h) = <a>loop</a> f &gt;&gt;&gt; h</tt></li>
--   <li><i><i>sliding</i></i> <tt><a>loop</a> (f &gt;&gt;&gt; <a>arr</a>
--   (<a>id</a> *** k)) = <a>loop</a> (<a>arr</a> (<a>id</a> *** k)
--   &gt;&gt;&gt; f)</tt></li>
--   <li><i><i>vanishing</i></i> <tt><a>loop</a> (<a>loop</a> f) =
--   <a>loop</a> (<a>arr</a> unassoc &gt;&gt;&gt; f &gt;&gt;&gt; <a>arr</a>
--   assoc)</tt></li>
--   <li><i><i>superposing</i></i> <tt><a>second</a> (<a>loop</a> f) =
--   <a>loop</a> (<a>arr</a> assoc &gt;&gt;&gt; <a>second</a> f
--   &gt;&gt;&gt; <a>arr</a> unassoc)</tt></li>
--   </ul>
--   
--   where
--   
--   <pre>
--   assoc ((a,b),c) = (a,(b,c))
--   unassoc (a,(b,c)) = ((a,b),c)
--   </pre>
class Arrow a => ArrowLoop (a :: Type -> Type -> Type)

-- | <pre>
--       ╭──────────────╮
--     b │     ╭───╮    │ c
--   &gt;───┼─────┤   ├────┼───&gt;
--       │   ┌─┤   ├─┐  │
--       │ d │ ╰───╯ │  │
--       │   └───&lt;───┘  │
--       ╰──────────────╯
--   </pre>
loop :: ArrowLoop a => a (b, d) (c, d) -> a b c
instance GHC.Internal.Control.Arrow.ArrowPlus a => GHC.Internal.Base.Alternative (GHC.Internal.Control.Arrow.ArrowMonad a)
instance GHC.Internal.Base.Alternative m => GHC.Internal.Base.Alternative (GHC.Internal.Control.Arrow.Kleisli m a)
instance GHC.Internal.Control.Arrow.Arrow a => GHC.Internal.Base.Applicative (GHC.Internal.Control.Arrow.ArrowMonad a)
instance GHC.Internal.Base.Applicative m => GHC.Internal.Base.Applicative (GHC.Internal.Control.Arrow.Kleisli m a)
instance GHC.Internal.Control.Arrow.ArrowApply (->)
instance GHC.Internal.Base.Monad m => GHC.Internal.Control.Arrow.ArrowApply (GHC.Internal.Control.Arrow.Kleisli m)
instance GHC.Internal.Control.Arrow.ArrowChoice (->)
instance GHC.Internal.Base.Monad m => GHC.Internal.Control.Arrow.ArrowChoice (GHC.Internal.Control.Arrow.Kleisli m)
instance GHC.Internal.Control.Arrow.Arrow (->)
instance GHC.Internal.Base.Monad m => GHC.Internal.Control.Arrow.Arrow (GHC.Internal.Control.Arrow.Kleisli m)
instance GHC.Internal.Control.Arrow.ArrowLoop (->)
instance GHC.Internal.Control.Monad.Fix.MonadFix m => GHC.Internal.Control.Arrow.ArrowLoop (GHC.Internal.Control.Arrow.Kleisli m)
instance GHC.Internal.Base.MonadPlus m => GHC.Internal.Control.Arrow.ArrowPlus (GHC.Internal.Control.Arrow.Kleisli m)
instance GHC.Internal.Base.MonadPlus m => GHC.Internal.Control.Arrow.ArrowZero (GHC.Internal.Control.Arrow.Kleisli m)
instance GHC.Internal.Base.Monad m => GHC.Internal.Control.Category.Category (GHC.Internal.Control.Arrow.Kleisli m)
instance GHC.Internal.Control.Arrow.Arrow a => GHC.Internal.Base.Functor (GHC.Internal.Control.Arrow.ArrowMonad a)
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (GHC.Internal.Control.Arrow.Kleisli m a)
instance GHC.Internal.Generics.Generic1 (GHC.Internal.Control.Arrow.Kleisli m a)
instance GHC.Internal.Generics.Generic (GHC.Internal.Control.Arrow.Kleisli m a b)
instance GHC.Internal.Control.Arrow.ArrowApply a => GHC.Internal.Base.Monad (GHC.Internal.Control.Arrow.ArrowMonad a)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (GHC.Internal.Control.Arrow.Kleisli m a)
instance (GHC.Internal.Control.Arrow.ArrowApply a, GHC.Internal.Control.Arrow.ArrowPlus a) => GHC.Internal.Base.MonadPlus (GHC.Internal.Control.Arrow.ArrowMonad a)
instance GHC.Internal.Base.MonadPlus m => GHC.Internal.Base.MonadPlus (GHC.Internal.Control.Arrow.Kleisli m a)


-- | Support code for desugaring in GHC
--   
--   <i>The API of this module is unstable and not meant to be consumed by
--   the general public.</i> If you absolutely must depend on it, make sure
--   to use a tight upper bound, e.g., <tt>base &lt; 4.X</tt> rather than
--   <tt>base &lt; 5</tt>, because the interface can change rapidly without
--   much warning.
module GHC.Internal.Desugar
(>>>) :: Arrow arr => forall a b c. () => arr a b -> arr b c -> arr a c
data AnnotationWrapper
AnnotationWrapper :: a -> AnnotationWrapper
toAnnotationWrapper :: Data a => a -> AnnotationWrapper


-- | This module provides scalable event notification for file descriptors
--   and timeouts.
--   
--   This module should be considered GHC internal.
--   
--   <ul>
--   
--   <li>---------------------------------------------------------------------------</li>
--   </ul>
module GHC.Internal.Event

-- | The event manager state.
data EventManager

-- | The event manager state.
data TimerManager

-- | Retrieve the system event manager for the capability on which the
--   calling thread is running.
--   
--   This function always returns <a>Just</a> the current thread's event
--   manager when using the threaded RTS and <a>Nothing</a> otherwise.
getSystemEventManager :: IO (Maybe EventManager)

-- | Create a new event manager.
new :: IO EventManager
getSystemTimerManager :: IO TimerManager

-- | An I/O event.
data Event

-- | Data is available to be read.
evtRead :: Event

-- | The file descriptor is ready to accept a write.
evtWrite :: Event

-- | Callback invoked on I/O events.
type IOCallback = FdKey -> Event -> IO ()

-- | A file descriptor registration cookie.
data FdKey

-- | The lifetime of an event registration.
data Lifetime

-- | the registration will be active for only one event
OneShot :: Lifetime

-- | the registration will trigger multiple times
MultiShot :: Lifetime

-- | <tt>registerFd mgr cb fd evs lt</tt> registers interest in the events
--   <tt>evs</tt> on the file descriptor <tt>fd</tt> for lifetime
--   <tt>lt</tt>. <tt>cb</tt> is called for each event that occurs. Returns
--   a cookie that can be handed to <a>unregisterFd</a>.
registerFd :: EventManager -> IOCallback -> Fd -> Event -> Lifetime -> IO FdKey

-- | Drop a previous file descriptor registration.
unregisterFd :: EventManager -> FdKey -> IO ()

-- | Drop a previous file descriptor registration, without waking the event
--   manager thread. The return value indicates whether the event manager
--   ought to be woken.
unregisterFd_ :: EventManager -> FdKey -> IO Bool

-- | Close a file descriptor in a race-safe way. It might block, although
--   for a very short time; and thus it is interruptible by asynchronous
--   exceptions.
closeFd :: EventManager -> (Fd -> IO ()) -> Fd -> IO ()

-- | Warning: since the <a>TimeoutCallback</a> is called from the I/O
--   manager, it must not throw an exception or block for a long period of
--   time. In particular, be wary of <a>throwTo</a> and <a>killThread</a>:
--   if the target thread is making a foreign call, these functions will
--   block until the call completes.
type TimeoutCallback = IO ()

-- | A timeout registration cookie.
data TimeoutKey

-- | Register a timeout in the given number of microseconds. The returned
--   <a>TimeoutKey</a> can be used to later unregister or update the
--   timeout. The timeout is automatically unregistered after the given
--   time has passed.
--   
--   Be careful not to exceed <tt>maxBound :: Int</tt>, which on 32-bit
--   machines is only 2147483647 μs, less than 36 minutes.
registerTimeout :: TimerManager -> Int -> TimeoutCallback -> IO TimeoutKey

-- | Update an active timeout to fire in the given number of microseconds.
--   
--   Be careful not to exceed <tt>maxBound :: Int</tt>, which on 32-bit
--   machines is only 2147483647 μs, less than 36 minutes.
updateTimeout :: TimerManager -> TimeoutKey -> Int -> IO ()

-- | Unregister an active timeout.
unregisterTimeout :: TimerManager -> TimeoutKey -> IO ()
