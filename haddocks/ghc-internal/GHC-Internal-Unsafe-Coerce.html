<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>GHC.Internal.Unsafe.Coerce</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">ghc-internal-9.1202.0: Basic libraries</span><ul class="links" id="page-menu"><li><a href="src/GHC.Internal.Unsafe.Coerce.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Unsafe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">GHC.Internal.Unsafe.Coerce</p></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:unsafeCoerce">unsafeCoerce</a> :: a -&gt; b</li><li class="src short"><a href="#v:unsafeCoerceUnlifted">unsafeCoerceUnlifted</a> :: <span class="keyword">forall</span> (a :: <a href="GHC-Internal-Exts.html#t:UnliftedType" title="GHC.Internal.Exts">UnliftedType</a>) (b :: <a href="GHC-Internal-Exts.html#t:UnliftedType" title="GHC.Internal.Exts">UnliftedType</a>). a -&gt; b</li><li class="src short"><a href="#v:unsafeCoerceAddr">unsafeCoerceAddr</a> :: <span class="keyword">forall</span> (a :: <a href="GHC-Internal-Exts.html#t:TYPE" title="GHC.Internal.Exts">TYPE</a> '<a href="GHC-Internal-Exts.html#v:AddrRep" title="GHC.Internal.Exts">AddrRep</a>) (b :: <a href="GHC-Internal-Exts.html#t:TYPE" title="GHC.Internal.Exts">TYPE</a> '<a href="GHC-Internal-Exts.html#v:AddrRep" title="GHC.Internal.Exts">AddrRep</a>). a -&gt; b</li><li class="src short"><a href="#v:unsafeEqualityProof">unsafeEqualityProof</a> :: <span class="keyword">forall</span> {k} (a :: k) (b :: k). <a href="GHC-Internal-Unsafe-Coerce.html#t:UnsafeEquality" title="GHC.Internal.Unsafe.Coerce">UnsafeEquality</a> a b</li><li class="src short"><span class="keyword">data</span> <a href="#t:UnsafeEquality">UnsafeEquality</a> (a :: k) (b :: k) <span class="keyword">where</span><ul class="subs"><li><a href="#v:UnsafeRefl">UnsafeRefl</a> :: <span class="keyword">forall</span> {k} (a :: k). <a href="GHC-Internal-Unsafe-Coerce.html#t:UnsafeEquality" title="GHC.Internal.Unsafe.Coerce">UnsafeEquality</a> a a</li></ul></li><li class="src short"><a href="#v:unsafeCoerce-35-">unsafeCoerce#</a> :: a -&gt; b</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:unsafeCoerce" class="def">unsafeCoerce</a> :: a -&gt; b <a href="src/GHC.Internal.Unsafe.Coerce.html#unsafeCoerce" class="link">Source</a> <a href="#v:unsafeCoerce" class="selflink">#</a></p><div class="doc"><p><code><a href="GHC-Internal-Unsafe-Coerce.html#v:unsafeCoerce" title="GHC.Internal.Unsafe.Coerce">unsafeCoerce</a></code> coerces a value from one type to another, bypassing the type-checker.</p><p>There are several legitimate ways to use <code><a href="GHC-Internal-Unsafe-Coerce.html#v:unsafeCoerce" title="GHC.Internal.Unsafe.Coerce">unsafeCoerce</a></code>:</p><ol><li value="1">To coerce a lifted type such as <code class="inline-code">Int</code> to <code class="inline-code">Any</code>, put it in a list of <code class="inline-code">Any</code>,
      and then later coerce it back to <code class="inline-code">Int</code> before using it.</li><li value="2">To produce e.g. <code class="inline-code">(a+b) :~: (b+a)</code> from <code class="inline-code">unsafeCoerce Refl</code>.
      Here the two sides really are the same type -- so nothing unsafe is happening
      -- but GHC is not clever enough to see it.</li><li value="3">In <code class="inline-code">Data.Typeable</code> we have</li></ol><pre>       eqTypeRep :: forall k1 k2 (a :: k1) (b :: k2).
                    TypeRep a -&gt; TypeRep b -&gt; Maybe (a :~~: b)
       eqTypeRep a b
         | sameTypeRep a b = Just (unsafeCoerce HRefl)
         | otherwise       = Nothing
     </pre><p>Here again, the <code class="inline-code">unsafeCoerce HRefl</code> is safe, because the two types really
      are the same  -- but the proof of that relies on the complex, trusted
      implementation of <code class="inline-code">Typeable</code>.</p><ol><li value="4">(superseded) The &quot;reflection trick&quot;, which takes advantage of the fact that in
      <code class="inline-code">class C a where { op :: ty }</code>, we can safely coerce between <code class="inline-code">C a</code> and <code class="inline-code">ty</code>
      (which have different kinds!) because it's really just a newtype.
      Note: there is <em>no guarantee, at all</em> that this behavior will be supported
      into perpetuity.
      It is now preferred to use <code><a href="GHC-Internal-Exts.html#v:withDict" title="GHC.Internal.Exts">withDict</a></code> in <code class="inline-code">GHC.Magic.Dict</code>, which
      is type-safe. See Note [withDict] in GHC.Tc.Instance.Class for details.</li><li value="5">(superseded) Casting between two types which have exactly the same structure:
      between a newtype of T and T, or between types which differ only
      in &quot;phantom&quot; type parameters.
      It is now preferred to use <code><a href="GHC-Internal-Data-Coerce.html#v:coerce" title="GHC.Internal.Data.Coerce">coerce</a></code> from <code class="inline-code">Data.Coerce</code>, which
      is type-safe.</li></ol><p>Other uses of <code><a href="GHC-Internal-Unsafe-Coerce.html#v:unsafeCoerce" title="GHC.Internal.Unsafe.Coerce">unsafeCoerce</a></code> are undefined.  In particular, you should not use
  <code><a href="GHC-Internal-Unsafe-Coerce.html#v:unsafeCoerce" title="GHC.Internal.Unsafe.Coerce">unsafeCoerce</a></code> to cast a T to an algebraic data type D, unless T is also
  an algebraic data type.  For example, do not cast <code class="inline-code"><code><a href="GHC-Internal-Exts.html#t:Int" title="GHC.Internal.Exts">Int</a></code>-&gt;<code><a href="GHC-Internal-Exts.html#t:Int" title="GHC.Internal.Exts">Int</a></code></code> to <code><a href="GHC-Internal-Data-Bool.html#t:Bool" title="GHC.Internal.Data.Bool">Bool</a></code>, even if
  you later cast that <code><a href="GHC-Internal-Data-Bool.html#t:Bool" title="GHC.Internal.Data.Bool">Bool</a></code> back to <code class="inline-code"><code><a href="GHC-Internal-Exts.html#t:Int" title="GHC.Internal.Exts">Int</a></code>-&gt;<code><a href="GHC-Internal-Exts.html#t:Int" title="GHC.Internal.Exts">Int</a></code></code> before applying it.  The reasons
  have to do with GHC's internal representation details (for the cognoscenti, data values
  can be entered but function closures cannot).  If you want a safe type to cast things
  to, use <code><a href="GHC-Internal-Exts.html#t:Any" title="GHC.Internal.Exts">Any</a></code>, which is not an algebraic data type.</p></div></div><div class="top"><p class="src"><a id="v:unsafeCoerceUnlifted" class="def">unsafeCoerceUnlifted</a> :: <span class="keyword">forall</span> (a :: <a href="GHC-Internal-Exts.html#t:UnliftedType" title="GHC.Internal.Exts">UnliftedType</a>) (b :: <a href="GHC-Internal-Exts.html#t:UnliftedType" title="GHC.Internal.Exts">UnliftedType</a>). a -&gt; b <a href="src/GHC.Internal.Unsafe.Coerce.html#unsafeCoerceUnlifted" class="link">Source</a> <a href="#v:unsafeCoerceUnlifted" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:unsafeCoerceAddr" class="def">unsafeCoerceAddr</a> :: <span class="keyword">forall</span> (a :: <a href="GHC-Internal-Exts.html#t:TYPE" title="GHC.Internal.Exts">TYPE</a> '<a href="GHC-Internal-Exts.html#v:AddrRep" title="GHC.Internal.Exts">AddrRep</a>) (b :: <a href="GHC-Internal-Exts.html#t:TYPE" title="GHC.Internal.Exts">TYPE</a> '<a href="GHC-Internal-Exts.html#v:AddrRep" title="GHC.Internal.Exts">AddrRep</a>). a -&gt; b <a href="src/GHC.Internal.Unsafe.Coerce.html#unsafeCoerceAddr" class="link">Source</a> <a href="#v:unsafeCoerceAddr" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:unsafeEqualityProof" class="def">unsafeEqualityProof</a> :: <span class="keyword">forall</span> {k} (a :: k) (b :: k). <a href="GHC-Internal-Unsafe-Coerce.html#t:UnsafeEquality" title="GHC.Internal.Unsafe.Coerce">UnsafeEquality</a> a b <a href="src/GHC.Internal.Unsafe.Coerce.html#unsafeEqualityProof" class="link">Source</a> <a href="#v:unsafeEqualityProof" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:UnsafeEquality" class="def">UnsafeEquality</a> (a :: k) (b :: k) <span class="keyword">where</span> <a href="src/GHC.Internal.Unsafe.Coerce.html#UnsafeEquality" class="link">Source</a> <a href="#t:UnsafeEquality" class="selflink">#</a></p><div class="doc"><p>This type is treated magically within GHC. Any pattern match of the
 form <code class="inline-code">case unsafeEqualityProof of UnsafeRefl -&gt; body</code> gets transformed just into <code class="inline-code">body</code>.
 This is ill-typed, but the transformation takes place after type-checking is
 complete. It is used to implement <code><a href="GHC-Internal-Unsafe-Coerce.html#v:unsafeCoerce" title="GHC.Internal.Unsafe.Coerce">unsafeCoerce</a></code>. You probably don't want to
 use <code><a href="GHC-Internal-Unsafe-Coerce.html#v:UnsafeRefl" title="GHC.Internal.Unsafe.Coerce">UnsafeRefl</a></code> in an expression, but you might conceivably want to pattern-match
 on it. Use <code><a href="GHC-Internal-Unsafe-Coerce.html#v:unsafeEqualityProof" title="GHC.Internal.Unsafe.Coerce">unsafeEqualityProof</a></code> to create one of these.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:UnsafeRefl" class="def">UnsafeRefl</a> :: <span class="keyword">forall</span> {k} (a :: k). <a href="GHC-Internal-Unsafe-Coerce.html#t:UnsafeEquality" title="GHC.Internal.Unsafe.Coerce">UnsafeEquality</a> a a</td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a id="v:unsafeCoerce-35-" class="def">unsafeCoerce#</a> :: a -&gt; b <a href="src/GHC.Internal.Unsafe.Coerce.html#unsafeCoerce%23" class="link">Source</a> <a href="#v:unsafeCoerce-35-" class="selflink">#</a></p><div class="doc"><p>Highly, terribly dangerous coercion from one representation type
 to another. Misuse of this function can invite the garbage collector
 to trounce upon your data and then laugh in your face. You don't want
 this function. Really.</p><p>This becomes more obvious when looking at its actual type:
 <code class="inline-code">forall (r1 :: RuntimeRep) (r2 :: RuntimeRep)  (a :: TYPE r1) (b :: TYPE r2). a -&gt; b</code>
 Which often get's rendered as <code class="inline-code">a -&gt; b</code> in haddock for technical reasons.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.30.0</p></div></body></html>