<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE CPP #-}</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 702
</span><span class="hs-pragma">{-# LANGUAGE Safe #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE DeriveGeneric #-}</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if __GLASGOW_HASKELL__ &gt;= 710 &amp;&amp; __GLASGOW_HASKELL__ &lt; 802
</span><span class="hs-pragma">{-# LANGUAGE AutoDeriveTypeable #-}</span><span class="hs-cpp">
#endif
</span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-10"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-11"></span><span class="hs-comment">-- Module      :  Control.Monad.Trans.State.Lazy</span><span>
</span><span id="line-12"></span><span class="hs-comment">-- Copyright   :  (c) Andy Gill 2001,</span><span>
</span><span id="line-13"></span><span class="hs-comment">--                (c) Oregon Graduate Institute of Science and Technology, 2001</span><span>
</span><span id="line-14"></span><span class="hs-comment">-- License     :  BSD-style (see the file LICENSE)</span><span>
</span><span id="line-15"></span><span class="hs-comment">--</span><span>
</span><span id="line-16"></span><span class="hs-comment">-- Maintainer  :  R.Paterson@city.ac.uk</span><span>
</span><span id="line-17"></span><span class="hs-comment">-- Stability   :  experimental</span><span>
</span><span id="line-18"></span><span class="hs-comment">-- Portability :  portable</span><span>
</span><span id="line-19"></span><span class="hs-comment">--</span><span>
</span><span id="line-20"></span><span class="hs-comment">-- Lazy state monads, passing an updatable state through a computation.</span><span>
</span><span id="line-21"></span><span class="hs-comment">-- See below for examples.</span><span>
</span><span id="line-22"></span><span class="hs-comment">--</span><span>
</span><span id="line-23"></span><span class="hs-comment">-- Some computations may not require the full power of state transformers:</span><span>
</span><span id="line-24"></span><span class="hs-comment">--</span><span>
</span><span id="line-25"></span><span class="hs-comment">-- * For a read-only state, see &quot;Control.Monad.Trans.Reader&quot;.</span><span>
</span><span id="line-26"></span><span class="hs-comment">--</span><span>
</span><span id="line-27"></span><span class="hs-comment">-- * To accumulate a value without using it on the way, see</span><span>
</span><span id="line-28"></span><span class="hs-comment">--   &quot;Control.Monad.Trans.Writer&quot;.</span><span>
</span><span id="line-29"></span><span class="hs-comment">--</span><span>
</span><span id="line-30"></span><span class="hs-comment">-- In this version, sequencing of computations is lazy, so that for</span><span>
</span><span id="line-31"></span><span class="hs-comment">-- example the following produces a usable result:</span><span>
</span><span id="line-32"></span><span class="hs-comment">--</span><span>
</span><span id="line-33"></span><span class="hs-comment">-- &gt; evalState (sequence $ repeat $ do { n &lt;- get; put (n*2); return n }) 1</span><span>
</span><span id="line-34"></span><span class="hs-comment">--</span><span>
</span><span id="line-35"></span><span class="hs-comment">-- For a strict version with the same interface, see</span><span>
</span><span id="line-36"></span><span class="hs-comment">-- &quot;Control.Monad.Trans.State.Strict&quot;.</span><span>
</span><span id="line-37"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-38"></span><span>
</span><span id="line-39"></span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html"><span class="hs-identifier">Control.Monad.Trans.State.Lazy</span></a></span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-40"></span><span>    </span><span class="annot"><span class="hs-comment">-- * The State monad</span></span><span>
</span><span id="line-41"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#State"><span class="hs-identifier">State</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-42"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#state"><span class="hs-identifier">state</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-43"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#runState"><span class="hs-identifier">runState</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-44"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#evalState"><span class="hs-identifier">evalState</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-45"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#execState"><span class="hs-identifier">execState</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-46"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#mapState"><span class="hs-identifier">mapState</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-47"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#withState"><span class="hs-identifier">withState</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-48"></span><span>    </span><span class="annot"><span class="hs-comment">-- * The StateT monad transformer</span></span><span>
</span><span id="line-49"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier">StateT</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-50"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#evalStateT"><span class="hs-identifier">evalStateT</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-51"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#execStateT"><span class="hs-identifier">execStateT</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-52"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#mapStateT"><span class="hs-identifier">mapStateT</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-53"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#withStateT"><span class="hs-identifier">withStateT</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-54"></span><span>    </span><span class="annot"><span class="hs-comment">-- * State operations</span></span><span>
</span><span id="line-55"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#get"><span class="hs-identifier">get</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-56"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#put"><span class="hs-identifier">put</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-57"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#modify"><span class="hs-identifier">modify</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-58"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#modify%27"><span class="hs-identifier">modify'</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-59"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#modifyM"><span class="hs-identifier">modifyM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-60"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#gets"><span class="hs-identifier">gets</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-61"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Lifting other operations</span></span><span>
</span><span id="line-62"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#liftCallCC"><span class="hs-identifier">liftCallCC</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-63"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#liftCallCC%27"><span class="hs-identifier">liftCallCC'</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-64"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#liftCatch"><span class="hs-identifier">liftCatch</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-65"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#liftListen"><span class="hs-identifier">liftListen</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-66"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#liftPass"><span class="hs-identifier">liftPass</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-67"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Examples</span></span><span>
</span><span id="line-68"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** State monads</span></span><span>
</span><span id="line-69"></span><span>    </span><span class="annot"><span class="hs-comment">-- $examples</span></span><span>
</span><span id="line-70"></span><span>
</span><span id="line-71"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Counting</span></span><span>
</span><span id="line-72"></span><span>    </span><span class="annot"><span class="hs-comment">-- $counting</span></span><span>
</span><span id="line-73"></span><span>
</span><span id="line-74"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Labelling trees</span></span><span>
</span><span id="line-75"></span><span>    </span><span class="annot"><span class="hs-comment">-- $labelling</span></span><span>
</span><span id="line-76"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-77"></span><span>
</span><span id="line-78"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.21.0.0-ae91/src/Control.Monad.IO.Class.html"><span class="hs-identifier">Control.Monad.IO.Class</span></a></span><span>
</span><span id="line-79"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Control.Monad.Signatures.html"><span class="hs-identifier">Control.Monad.Signatures</span></a></span><span>
</span><span id="line-80"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Control.Monad.Trans.Class.html"><span class="hs-identifier">Control.Monad.Trans.Class</span></a></span><span class="hs-cpp">
#if MIN_VERSION_base(4,12,0)
</span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.21.0.0-ae91/src/Data.Functor.Contravariant.html"><span class="hs-identifier">Data.Functor.Contravariant</span></a></span><span class="hs-cpp">
#endif
</span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.21.0.0-ae91/src/Data.Functor.Identity.html"><span class="hs-identifier">Data.Functor.Identity</span></a></span><span>
</span><span id="line-85"></span><span>
</span><span id="line-86"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.21.0.0-ae91/src/Control.Applicative.html"><span class="hs-identifier">Control.Applicative</span></a></span><span>
</span><span id="line-87"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.21.0.0-ae91/src/Control.Monad.html"><span class="hs-identifier">Control.Monad</span></a></span><span class="hs-cpp">
#if MIN_VERSION_base(4,9,0)
</span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="../../base-4.21.0.0-ae91/src/Control.Monad.Fail.html"><span class="hs-identifier">Control.Monad.Fail</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Fail</span></span><span class="hs-cpp">
#endif
</span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.21.0.0-ae91/src/Control.Monad.Fix.html"><span class="hs-identifier">Control.Monad.Fix</span></a></span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 704
</span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.21.0.0-ae91/src/GHC.Generics.html"><span class="hs-identifier">GHC.Generics</span></a></span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-96"></span><span class="hs-comment">-- ---------------------------------------------------------------------------</span><span>
</span><span id="line-97"></span><span class="hs-comment">-- | A state monad parameterized by the type @s@ of the state to carry.</span><span>
</span><span id="line-98"></span><span class="hs-comment">--</span><span>
</span><span id="line-99"></span><span class="hs-comment">-- The 'return' function leaves the state unchanged, while @&gt;&gt;=@ uses</span><span>
</span><span id="line-100"></span><span class="hs-comment">-- the final state of the first computation as the initial state of</span><span>
</span><span id="line-101"></span><span class="hs-comment">-- the second.</span><span>
</span><span id="line-102"></span><span class="hs-keyword">type</span><span> </span><span id="State"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#State"><span class="hs-identifier hs-var">State</span></a></span></span><span> </span><span id="local-6989586621679098108"><span class="annot"><a href="#local-6989586621679098108"><span class="hs-identifier hs-type">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098108"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Identity</span></span><span>
</span><span id="line-103"></span><span>
</span><span id="line-104"></span><span class="hs-comment">-- | Construct a state monad computation from a function.</span><span>
</span><span id="line-105"></span><span class="hs-comment">-- (The inverse of 'runState'.)</span><span>
</span><span id="line-106"></span><span id="local-6989586621679097826"><span id="local-6989586621679097827"><span id="local-6989586621679097828"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#state"><span class="hs-identifier hs-type">state</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679097826"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-107"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679097827"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679097828"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679097827"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>  </span><span class="annot"><span class="hs-comment">-- ^pure state transformer</span></span><span>
</span><span id="line-108"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097827"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097826"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097828"><span class="hs-identifier hs-type">a</span></a></span></span></span></span><span>   </span><span class="annot"><span class="hs-comment">-- ^equivalent state-passing computation</span></span><span>
</span><span id="line-109"></span><span id="state"><span class="annot"><span class="annottext">state :: forall (m :: * -&gt; *) s a. Monad m =&gt; (s -&gt; (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#state"><span class="hs-identifier hs-var hs-var">state</span></a></span></span><span> </span><span id="local-6989586621679098111"><span class="annot"><span class="annottext">s -&gt; (a, s)
</span><a href="#local-6989586621679098111"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; m (a, s)) -&gt; StateT s m a
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a, s) -&gt; m (a, s)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">((a, s) -&gt; m (a, s)) -&gt; (s -&gt; (a, s)) -&gt; s -&gt; m (a, s)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">s -&gt; (a, s)
</span><a href="#local-6989586621679098111"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-110"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#state"><span class="hs-pragma hs-type">state</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-111"></span><span>
</span><span id="line-112"></span><span class="hs-comment">-- | Unwrap a state monad computation as a function.</span><span>
</span><span id="line-113"></span><span class="hs-comment">-- (The inverse of 'state'.)</span><span>
</span><span id="line-114"></span><span id="local-6989586621679097841"><span id="local-6989586621679097842"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#runState"><span class="hs-identifier hs-type">runState</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#State"><span class="hs-identifier hs-type">State</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097841"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097842"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^state-passing computation to execute</span></span><span>
</span><span id="line-115"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679097841"><span class="hs-identifier hs-type">s</span></a></span><span>           </span><span class="annot"><span class="hs-comment">-- ^initial state</span></span><span>
</span><span id="line-116"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679097842"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679097841"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span></span></span><span>      </span><span class="annot"><span class="hs-comment">-- ^return value and final state</span></span><span>
</span><span id="line-117"></span><span id="runState"><span class="annot"><span class="annottext">runState :: forall s a. State s a -&gt; s -&gt; (a, s)
</span><a href="Control.Monad.Trans.State.Lazy.html#runState"><span class="hs-identifier hs-var hs-var">runState</span></a></span></span><span> </span><span id="local-6989586621679098114"><span class="annot"><span class="annottext">State s a
</span><a href="#local-6989586621679098114"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Identity (a, s) -&gt; (a, s)
forall a. Identity a -&gt; a
</span><span class="hs-identifier hs-var">runIdentity</span></span><span> </span><span class="annot"><span class="annottext">(Identity (a, s) -&gt; (a, s))
-&gt; (s -&gt; Identity (a, s)) -&gt; s -&gt; (a, s)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">State s a -&gt; s -&gt; Identity (a, s)
forall s (m :: * -&gt; *) a. StateT s m a -&gt; s -&gt; m (a, s)
</span><a href="Control.Monad.Trans.State.Lazy.html#runStateT"><span class="hs-identifier hs-var">runStateT</span></a></span><span> </span><span class="annot"><span class="annottext">State s a
</span><a href="#local-6989586621679098114"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-118"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#runState"><span class="hs-pragma hs-type">runState</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-119"></span><span>
</span><span id="line-120"></span><span class="hs-comment">-- | Evaluate a state computation with the given initial state</span><span>
</span><span id="line-121"></span><span class="hs-comment">-- and return the final value, discarding the final state.</span><span>
</span><span id="line-122"></span><span class="hs-comment">--</span><span>
</span><span id="line-123"></span><span class="hs-comment">-- * @'evalState' m s = 'fst' ('runState' m s)@</span><span>
</span><span id="line-124"></span><span id="local-6989586621679097848"><span id="local-6989586621679097849"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#evalState"><span class="hs-identifier hs-type">evalState</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#State"><span class="hs-identifier hs-type">State</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097848"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097849"><span class="hs-identifier hs-type">a</span></a></span><span>  </span><span class="annot"><span class="hs-comment">-- ^state-passing computation to execute</span></span><span>
</span><span id="line-125"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679097848"><span class="hs-identifier hs-type">s</span></a></span><span>          </span><span class="annot"><span class="hs-comment">-- ^initial value</span></span><span>
</span><span id="line-126"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679097849"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>          </span><span class="annot"><span class="hs-comment">-- ^return value of the state computation</span></span><span>
</span><span id="line-127"></span><span id="evalState"><span class="annot"><span class="annottext">evalState :: forall s a. State s a -&gt; s -&gt; a
</span><a href="Control.Monad.Trans.State.Lazy.html#evalState"><span class="hs-identifier hs-var hs-var">evalState</span></a></span></span><span> </span><span id="local-6989586621679098118"><span class="annot"><span class="annottext">State s a
</span><a href="#local-6989586621679098118"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679098119"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098119"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a, s) -&gt; a
forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">State s a -&gt; s -&gt; (a, s)
forall s a. State s a -&gt; s -&gt; (a, s)
</span><a href="Control.Monad.Trans.State.Lazy.html#runState"><span class="hs-identifier hs-var">runState</span></a></span><span> </span><span class="annot"><span class="annottext">State s a
</span><a href="#local-6989586621679098118"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098119"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-128"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#evalState"><span class="hs-pragma hs-type">evalState</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-129"></span><span>
</span><span id="line-130"></span><span class="hs-comment">-- | Evaluate a state computation with the given initial state</span><span>
</span><span id="line-131"></span><span class="hs-comment">-- and return the final state, discarding the final value.</span><span>
</span><span id="line-132"></span><span class="hs-comment">--</span><span>
</span><span id="line-133"></span><span class="hs-comment">-- * @'execState' m s = 'snd' ('runState' m s)@</span><span>
</span><span id="line-134"></span><span id="local-6989586621679097854"><span id="local-6989586621679097855"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#execState"><span class="hs-identifier hs-type">execState</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#State"><span class="hs-identifier hs-type">State</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097854"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097855"><span class="hs-identifier hs-type">a</span></a></span><span>  </span><span class="annot"><span class="hs-comment">-- ^state-passing computation to execute</span></span><span>
</span><span id="line-135"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679097854"><span class="hs-identifier hs-type">s</span></a></span><span>          </span><span class="annot"><span class="hs-comment">-- ^initial value</span></span><span>
</span><span id="line-136"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679097854"><span class="hs-identifier hs-type">s</span></a></span></span></span><span>          </span><span class="annot"><span class="hs-comment">-- ^final state</span></span><span>
</span><span id="line-137"></span><span id="execState"><span class="annot"><span class="annottext">execState :: forall s a. State s a -&gt; s -&gt; s
</span><a href="Control.Monad.Trans.State.Lazy.html#execState"><span class="hs-identifier hs-var hs-var">execState</span></a></span></span><span> </span><span id="local-6989586621679098121"><span class="annot"><span class="annottext">State s a
</span><a href="#local-6989586621679098121"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679098122"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098122"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a, s) -&gt; s
forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">State s a -&gt; s -&gt; (a, s)
forall s a. State s a -&gt; s -&gt; (a, s)
</span><a href="Control.Monad.Trans.State.Lazy.html#runState"><span class="hs-identifier hs-var">runState</span></a></span><span> </span><span class="annot"><span class="annottext">State s a
</span><a href="#local-6989586621679098121"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098122"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-138"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#execState"><span class="hs-pragma hs-type">execState</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-139"></span><span>
</span><span id="line-140"></span><span class="hs-comment">-- | Map both the return value and final state of a computation using</span><span>
</span><span id="line-141"></span><span class="hs-comment">-- the given function.</span><span>
</span><span id="line-142"></span><span class="hs-comment">--</span><span>
</span><span id="line-143"></span><span class="hs-comment">-- * @'runState' ('mapState' f m) = f . 'runState' m@</span><span>
</span><span id="line-144"></span><span id="local-6989586621679097860"><span id="local-6989586621679097861"><span id="local-6989586621679097862"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#mapState"><span class="hs-identifier hs-type">mapState</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679097860"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679097861"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679097862"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679097861"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#State"><span class="hs-identifier hs-type">State</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097861"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097860"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#State"><span class="hs-identifier hs-type">State</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097861"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097862"><span class="hs-identifier hs-type">b</span></a></span></span></span></span><span>
</span><span id="line-145"></span><span id="mapState"><span class="annot"><span class="annottext">mapState :: forall a s b. ((a, s) -&gt; (b, s)) -&gt; State s a -&gt; State s b
</span><a href="Control.Monad.Trans.State.Lazy.html#mapState"><span class="hs-identifier hs-var hs-var">mapState</span></a></span></span><span> </span><span id="local-6989586621679098123"><span class="annot"><span class="annottext">(a, s) -&gt; (b, s)
</span><a href="#local-6989586621679098123"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Identity (a, s) -&gt; Identity (b, s))
-&gt; StateT s Identity a -&gt; StateT s Identity b
forall (m :: * -&gt; *) a s (n :: * -&gt; *) b.
(m (a, s) -&gt; n (b, s)) -&gt; StateT s m a -&gt; StateT s n b
</span><a href="Control.Monad.Trans.State.Lazy.html#mapStateT"><span class="hs-identifier hs-var">mapStateT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(b, s) -&gt; Identity (b, s)
forall a. a -&gt; Identity a
</span><span class="hs-identifier hs-var">Identity</span></span><span> </span><span class="annot"><span class="annottext">((b, s) -&gt; Identity (b, s))
-&gt; (Identity (a, s) -&gt; (b, s))
-&gt; Identity (a, s)
-&gt; Identity (b, s)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(a, s) -&gt; (b, s)
</span><a href="#local-6989586621679098123"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">((a, s) -&gt; (b, s))
-&gt; (Identity (a, s) -&gt; (a, s)) -&gt; Identity (a, s) -&gt; (b, s)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Identity (a, s) -&gt; (a, s)
forall a. Identity a -&gt; a
</span><span class="hs-identifier hs-var">runIdentity</span></span><span class="hs-special">)</span><span>
</span><span id="line-146"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#mapState"><span class="hs-pragma hs-type">mapState</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-147"></span><span>
</span><span id="line-148"></span><span class="hs-comment">-- | @'withState' f m@ executes action @m@ on a state modified by</span><span>
</span><span id="line-149"></span><span class="hs-comment">-- applying @f@.</span><span>
</span><span id="line-150"></span><span class="hs-comment">--</span><span>
</span><span id="line-151"></span><span class="hs-comment">-- * @'withState' f m = 'modify' f &gt;&gt; m@</span><span>
</span><span id="line-152"></span><span id="local-6989586621679097872"><span id="local-6989586621679097873"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#withState"><span class="hs-identifier hs-type">withState</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679097872"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679097872"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#State"><span class="hs-identifier hs-type">State</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097872"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097873"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#State"><span class="hs-identifier hs-type">State</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097872"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097873"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-153"></span><span id="withState"><span class="annot"><span class="annottext">withState :: forall s a. (s -&gt; s) -&gt; State s a -&gt; State s a
</span><a href="Control.Monad.Trans.State.Lazy.html#withState"><span class="hs-identifier hs-var hs-var">withState</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; s) -&gt; StateT s Identity a -&gt; StateT s Identity a
forall s (m :: * -&gt; *) a. (s -&gt; s) -&gt; StateT s m a -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#withStateT"><span class="hs-identifier hs-var">withStateT</span></a></span><span>
</span><span id="line-154"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#withState"><span class="hs-pragma hs-type">withState</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-155"></span><span>
</span><span id="line-156"></span><span class="hs-comment">-- ---------------------------------------------------------------------------</span><span>
</span><span id="line-157"></span><span class="hs-comment">-- | A state transformer monad parameterized by:</span><span>
</span><span id="line-158"></span><span class="hs-comment">--</span><span>
</span><span id="line-159"></span><span class="hs-comment">--   * @s@ - The state.</span><span>
</span><span id="line-160"></span><span class="hs-comment">--</span><span>
</span><span id="line-161"></span><span class="hs-comment">--   * @m@ - The inner monad.</span><span>
</span><span id="line-162"></span><span class="hs-comment">--</span><span>
</span><span id="line-163"></span><span class="hs-comment">-- The 'return' function leaves the state unchanged, while @&gt;&gt;=@ uses</span><span>
</span><span id="line-164"></span><span class="hs-comment">-- the final state of the first computation as the initial state of</span><span>
</span><span id="line-165"></span><span class="hs-comment">-- the second.</span><span>
</span><span id="line-166"></span><span class="hs-keyword">newtype</span><span> </span><span id="StateT"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span></span><span> </span><span id="local-6989586621679097833"><span class="annot"><a href="#local-6989586621679097833"><span class="hs-identifier hs-type">s</span></a></span></span><span> </span><span id="local-6989586621679097834"><span class="annot"><a href="#local-6989586621679097834"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span id="local-6989586621679097835"><span class="annot"><a href="#local-6989586621679097835"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="StateT"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="runStateT"><span class="annot"><span class="annottext">forall s (m :: * -&gt; *) a. StateT s m a -&gt; s -&gt; m (a, s)
</span><a href="Control.Monad.Trans.State.Lazy.html#runStateT"><span class="hs-identifier hs-var hs-var">runStateT</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679097833"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679097834"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679097835"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span class="annot"><a href="#local-6989586621679097833"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 704
</span><span>    </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679098126"><span id="local-6989586621679098128"><span class="annot"><span class="annottext">(forall x. StateT s m a -&gt; Rep (StateT s m a) x)
-&gt; (forall x. Rep (StateT s m a) x -&gt; StateT s m a)
-&gt; Generic (StateT s m a)
forall x. Rep (StateT s m a) x -&gt; StateT s m a
forall x. StateT s m a -&gt; Rep (StateT s m a) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall s (m :: * -&gt; *) a x. Rep (StateT s m a) x -&gt; StateT s m a
forall s (m :: * -&gt; *) a x. StateT s m a -&gt; Rep (StateT s m a) x
$cfrom :: forall s (m :: * -&gt; *) a x. StateT s m a -&gt; Rep (StateT s m a) x
from :: forall x. StateT s m a -&gt; Rep (StateT s m a) x
$cto :: forall s (m :: * -&gt; *) a x. Rep (StateT s m a) x -&gt; StateT s m a
to :: forall x. Rep (StateT s m a) x -&gt; StateT s m a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-171"></span><span class="hs-comment">-- | Evaluate a state computation with the given initial state</span><span>
</span><span id="line-172"></span><span class="hs-comment">-- and return the final value, discarding the final state.</span><span>
</span><span id="line-173"></span><span class="hs-comment">--</span><span>
</span><span id="line-174"></span><span class="hs-comment">-- * @'evalStateT' m s = 'liftM' 'fst' ('runStateT' m s)@</span><span>
</span><span id="line-175"></span><span id="local-6989586621679097891"><span id="local-6989586621679097892"><span id="local-6989586621679097893"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#evalStateT"><span class="hs-identifier hs-type">evalStateT</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679097891"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097892"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097891"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097893"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679097892"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679097891"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097893"><span class="hs-identifier hs-type">a</span></a></span></span></span></span><span>
</span><span id="line-176"></span><span id="evalStateT"><span class="annot"><span class="annottext">evalStateT :: forall (m :: * -&gt; *) s a. Monad m =&gt; StateT s m a -&gt; s -&gt; m a
</span><a href="Control.Monad.Trans.State.Lazy.html#evalStateT"><span class="hs-identifier hs-var hs-var">evalStateT</span></a></span></span><span> </span><span id="local-6989586621679098137"><span class="annot"><span class="annottext">StateT s m a
</span><a href="#local-6989586621679098137"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679098138"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098138"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-177"></span><span>    </span><span class="hs-glyph">~</span><span class="hs-special">(</span><span id="local-6989586621679098139"><span class="annot"><a href="#local-6989586621679098139"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">StateT s m a -&gt; s -&gt; m (a, s)
forall s (m :: * -&gt; *) a. StateT s m a -&gt; s -&gt; m (a, s)
</span><a href="Control.Monad.Trans.State.Lazy.html#runStateT"><span class="hs-identifier hs-var">runStateT</span></a></span><span> </span><span class="annot"><span class="annottext">StateT s m a
</span><a href="#local-6989586621679098137"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098138"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-178"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="annot"><a href="#local-6989586621679098139"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-179"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#evalStateT"><span class="hs-pragma hs-type">evalStateT</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-180"></span><span>
</span><span id="line-181"></span><span class="hs-comment">-- | Evaluate a state computation with the given initial state</span><span>
</span><span id="line-182"></span><span class="hs-comment">-- and return the final state, discarding the final value.</span><span>
</span><span id="line-183"></span><span class="hs-comment">--</span><span>
</span><span id="line-184"></span><span class="hs-comment">-- * @'execStateT' m s = 'liftM' 'snd' ('runStateT' m s)@</span><span>
</span><span id="line-185"></span><span id="local-6989586621679097897"><span id="local-6989586621679097898"><span id="local-6989586621679097899"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#execStateT"><span class="hs-identifier hs-type">execStateT</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679097897"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097898"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097897"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097899"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679097898"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679097897"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097898"><span class="hs-identifier hs-type">s</span></a></span></span></span></span><span>
</span><span id="line-186"></span><span id="execStateT"><span class="annot"><span class="annottext">execStateT :: forall (m :: * -&gt; *) s a. Monad m =&gt; StateT s m a -&gt; s -&gt; m s
</span><a href="Control.Monad.Trans.State.Lazy.html#execStateT"><span class="hs-identifier hs-var hs-var">execStateT</span></a></span></span><span> </span><span id="local-6989586621679098143"><span class="annot"><span class="annottext">StateT s m a
</span><a href="#local-6989586621679098143"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679098144"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098144"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-187"></span><span>    </span><span class="hs-glyph">~</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679098145"><span class="annot"><a href="#local-6989586621679098145"><span class="hs-identifier hs-var">s'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">StateT s m a -&gt; s -&gt; m (a, s)
forall s (m :: * -&gt; *) a. StateT s m a -&gt; s -&gt; m (a, s)
</span><a href="Control.Monad.Trans.State.Lazy.html#runStateT"><span class="hs-identifier hs-var">runStateT</span></a></span><span> </span><span class="annot"><span class="annottext">StateT s m a
</span><a href="#local-6989586621679098143"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098144"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-188"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="annot"><a href="#local-6989586621679098145"><span class="hs-identifier hs-type">s'</span></a></span><span>
</span><span id="line-189"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#execStateT"><span class="hs-pragma hs-type">execStateT</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-190"></span><span>
</span><span id="line-191"></span><span class="hs-comment">-- | Map both the return value and final state of a computation using</span><span>
</span><span id="line-192"></span><span class="hs-comment">-- the given function.</span><span>
</span><span id="line-193"></span><span class="hs-comment">--</span><span>
</span><span id="line-194"></span><span class="hs-comment">-- * @'runStateT' ('mapStateT' f m) = f . 'runStateT' m@</span><span>
</span><span id="line-195"></span><span id="local-6989586621679097866"><span id="local-6989586621679097867"><span id="local-6989586621679097868"><span id="local-6989586621679097869"><span id="local-6989586621679097870"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#mapStateT"><span class="hs-identifier hs-type">mapStateT</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679097866"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679097867"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679097868"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679097869"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679097870"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679097868"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097868"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097866"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097867"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097868"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097869"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097870"><span class="hs-identifier hs-type">b</span></a></span></span></span></span></span></span><span>
</span><span id="line-196"></span><span id="mapStateT"><span class="annot"><span class="annottext">mapStateT :: forall (m :: * -&gt; *) a s (n :: * -&gt; *) b.
(m (a, s) -&gt; n (b, s)) -&gt; StateT s m a -&gt; StateT s n b
</span><a href="Control.Monad.Trans.State.Lazy.html#mapStateT"><span class="hs-identifier hs-var hs-var">mapStateT</span></a></span></span><span> </span><span id="local-6989586621679098146"><span class="annot"><span class="annottext">m (a, s) -&gt; n (b, s)
</span><a href="#local-6989586621679098146"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679098147"><span class="annot"><span class="annottext">StateT s m a
</span><a href="#local-6989586621679098147"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; n (b, s)) -&gt; StateT s n b
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; n (b, s)) -&gt; StateT s n b)
-&gt; (s -&gt; n (b, s)) -&gt; StateT s n b
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">m (a, s) -&gt; n (b, s)
</span><a href="#local-6989586621679098146"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(m (a, s) -&gt; n (b, s)) -&gt; (s -&gt; m (a, s)) -&gt; s -&gt; n (b, s)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">StateT s m a -&gt; s -&gt; m (a, s)
forall s (m :: * -&gt; *) a. StateT s m a -&gt; s -&gt; m (a, s)
</span><a href="Control.Monad.Trans.State.Lazy.html#runStateT"><span class="hs-identifier hs-var">runStateT</span></a></span><span> </span><span class="annot"><span class="annottext">StateT s m a
</span><a href="#local-6989586621679098147"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-197"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#mapStateT"><span class="hs-pragma hs-type">mapStateT</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-198"></span><span>
</span><span id="line-199"></span><span class="hs-comment">-- | @'withStateT' f m@ executes action @m@ on a state modified by</span><span>
</span><span id="line-200"></span><span class="hs-comment">-- applying @f@.</span><span>
</span><span id="line-201"></span><span class="hs-comment">--</span><span>
</span><span id="line-202"></span><span class="hs-comment">-- * @'withStateT' f m = 'modify' f &gt;&gt; m@</span><span>
</span><span id="line-203"></span><span id="local-6989586621679097876"><span id="local-6989586621679097877"><span id="local-6989586621679097878"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#withStateT"><span class="hs-identifier hs-type">withStateT</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679097876"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679097876"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097876"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097877"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097878"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097876"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097877"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097878"><span class="hs-identifier hs-type">a</span></a></span></span></span></span><span>
</span><span id="line-204"></span><span id="withStateT"><span class="annot"><span class="annottext">withStateT :: forall s (m :: * -&gt; *) a. (s -&gt; s) -&gt; StateT s m a -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#withStateT"><span class="hs-identifier hs-var hs-var">withStateT</span></a></span></span><span> </span><span id="local-6989586621679098148"><span class="annot"><span class="annottext">s -&gt; s
</span><a href="#local-6989586621679098148"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679098149"><span class="annot"><span class="annottext">StateT s m a
</span><a href="#local-6989586621679098149"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; m (a, s)) -&gt; StateT s m a
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m (a, s)) -&gt; StateT s m a)
-&gt; (s -&gt; m (a, s)) -&gt; StateT s m a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">StateT s m a -&gt; s -&gt; m (a, s)
forall s (m :: * -&gt; *) a. StateT s m a -&gt; s -&gt; m (a, s)
</span><a href="Control.Monad.Trans.State.Lazy.html#runStateT"><span class="hs-identifier hs-var">runStateT</span></a></span><span> </span><span class="annot"><span class="annottext">StateT s m a
</span><a href="#local-6989586621679098149"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">(s -&gt; m (a, s)) -&gt; (s -&gt; s) -&gt; s -&gt; m (a, s)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">s -&gt; s
</span><a href="#local-6989586621679098148"><span class="hs-identifier hs-var">f</span></a></span><span>
</span><span id="line-205"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#withStateT"><span class="hs-pragma hs-type">withStateT</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-206"></span><span>
</span><span id="line-207"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679097922"><span id="local-6989586621679097923"><span id="local-6989586621679098153"><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Functor</span></span><span> </span><span class="annot"><a href="#local-6989586621679097922"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Functor</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097923"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097922"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-208"></span><span>    </span><span id="local-6989586621679098158"><span class="annot"><span class="annottext">fmap :: forall a b. (a -&gt; b) -&gt; StateT s m a -&gt; StateT s m b
</span><span class="hs-identifier hs-var hs-var hs-var">fmap</span></span></span><span> </span><span id="local-6989586621679098159"><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679098159"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679098160"><span class="annot"><span class="annottext">StateT s m a
</span><a href="#local-6989586621679098160"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; m (b, s)) -&gt; StateT s m b
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m (b, s)) -&gt; StateT s m b)
-&gt; (s -&gt; m (b, s)) -&gt; StateT s m b
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098161"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098161"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-209"></span><span>        </span><span class="annot"><span class="annottext">((a, s) -&gt; (b, s)) -&gt; m (a, s) -&gt; m (b, s)
forall a b. (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span> </span><span class="hs-glyph">~</span><span class="hs-special">(</span><span id="local-6989586621679098162"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679098162"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679098163"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098163"><span class="hs-identifier hs-var">s'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679098159"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679098162"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098163"><span class="hs-identifier hs-var">s'</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(m (a, s) -&gt; m (b, s)) -&gt; m (a, s) -&gt; m (b, s)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">StateT s m a -&gt; s -&gt; m (a, s)
forall s (m :: * -&gt; *) a. StateT s m a -&gt; s -&gt; m (a, s)
</span><a href="Control.Monad.Trans.State.Lazy.html#runStateT"><span class="hs-identifier hs-var">runStateT</span></a></span><span> </span><span class="annot"><span class="annottext">StateT s m a
</span><a href="#local-6989586621679098160"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098161"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-210"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><span class="hs-pragma hs-type">fmap</span></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-211"></span><span>
</span><span id="line-212"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679097939"><span id="local-6989586621679097940"><span id="local-6989586621679098171"><span id="local-6989586621679098176"><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Functor</span></span><span> </span><span class="annot"><a href="#local-6989586621679097939"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679097939"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097940"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097939"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-213"></span><span>    </span><span id="local-6989586621679098180"><span class="annot"><span class="annottext">pure :: forall a. a -&gt; StateT s m a
</span><span class="hs-identifier hs-var hs-var hs-var">pure</span></span></span><span> </span><span id="local-6989586621679098181"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679098181"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; m (a, s)) -&gt; StateT s m a
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m (a, s)) -&gt; StateT s m a)
-&gt; (s -&gt; m (a, s)) -&gt; StateT s m a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098182"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098182"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(a, s) -&gt; m (a, s)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679098181"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098182"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-214"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><span class="hs-pragma hs-type">pure</span></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-215"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span id="local-6989586621679098186"><span class="annot"><span class="annottext">s -&gt; m (a -&gt; b, s)
</span><a href="#local-6989586621679098186"><span class="hs-identifier hs-var">mf</span></a></span></span><span> </span><span id="local-6989586621679098187"><span class="annot"><span class="annottext">&lt;*&gt; :: forall a b. StateT s m (a -&gt; b) -&gt; StateT s m a -&gt; StateT s m b
</span><span class="hs-operator hs-var hs-var hs-var">&lt;*&gt;</span></span></span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span id="local-6989586621679098188"><span class="annot"><span class="annottext">s -&gt; m (a, s)
</span><a href="#local-6989586621679098188"><span class="hs-identifier hs-var">mx</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; m (b, s)) -&gt; StateT s m b
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m (b, s)) -&gt; StateT s m b)
-&gt; (s -&gt; m (b, s)) -&gt; StateT s m b
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098189"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098189"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-216"></span><span>        </span><span class="hs-glyph">~</span><span class="hs-special">(</span><span id="local-6989586621679098190"><span class="annot"><a href="#local-6989586621679098190"><span class="hs-identifier hs-var">f</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679098191"><span class="annot"><a href="#local-6989586621679098191"><span class="hs-identifier hs-var">s'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">s -&gt; m (a -&gt; b, s)
</span><a href="#local-6989586621679098186"><span class="hs-identifier hs-var">mf</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098189"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-217"></span><span>        </span><span class="hs-glyph">~</span><span class="hs-special">(</span><span id="local-6989586621679098192"><span class="annot"><a href="#local-6989586621679098192"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679098193"><span class="annot"><a href="#local-6989586621679098193"><span class="hs-identifier hs-var">s''</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="#local-6989586621679098188"><span class="hs-identifier hs-type">mx</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098191"><span class="hs-identifier hs-type">s'</span></a></span><span>
</span><span id="line-218"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679098190"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098192"><span class="hs-identifier hs-type">x</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679098193"><span class="hs-identifier hs-type">s''</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-219"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="hs-pragma">(</span><span class="hs-pragma">&lt;*&gt;</span><span class="hs-pragma">)</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-220"></span><span>    </span><span id="local-6989586621679098196"><span class="annot"><span class="annottext">StateT s m a
</span><a href="#local-6989586621679098196"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679098197"><span class="annot"><span class="annottext">*&gt; :: forall a b. StateT s m a -&gt; StateT s m b -&gt; StateT s m b
</span><span class="hs-operator hs-var hs-var hs-var">*&gt;</span></span></span><span> </span><span id="local-6989586621679098198"><span class="annot"><span class="annottext">StateT s m b
</span><a href="#local-6989586621679098198"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">StateT s m a
</span><a href="#local-6989586621679098196"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">StateT s m a -&gt; (a -&gt; StateT s m b) -&gt; StateT s m b
forall a b. StateT s m a -&gt; (a -&gt; StateT s m b) -&gt; StateT s m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">StateT s m b
</span><a href="#local-6989586621679098198"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-221"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="hs-pragma">(</span><span class="hs-pragma">*&gt;</span><span class="hs-pragma">)</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-222"></span><span>
</span><span id="line-223"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679097959"><span id="local-6989586621679097960"><span id="local-6989586621679098207"><span id="local-6989586621679098211"><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Functor</span></span><span> </span><span class="annot"><a href="#local-6989586621679097959"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonadPlus</span></span><span> </span><span class="annot"><a href="#local-6989586621679097959"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097960"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097959"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-224"></span><span>    </span><span id="local-6989586621679098216"><span class="annot"><span class="annottext">empty :: forall a. StateT s m a
</span><a href="#local-6989586621679098216"><span class="hs-identifier hs-var hs-var hs-var">empty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; m (a, s)) -&gt; StateT s m a
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m (a, s)) -&gt; StateT s m a)
-&gt; (s -&gt; m (a, s)) -&gt; StateT s m a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span class="annot"><span class="annottext">s
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (a, s)
forall a. m a
forall (m :: * -&gt; *) a. MonadPlus m =&gt; m a
</span><span class="hs-identifier hs-var">mzero</span></span><span>
</span><span id="line-225"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><span class="hs-pragma hs-type">empty</span></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-226"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span id="local-6989586621679098220"><span class="annot"><span class="annottext">s -&gt; m (a, s)
</span><a href="#local-6989586621679098220"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679098221"><span class="annot"><span class="annottext">&lt;|&gt; :: forall a. StateT s m a -&gt; StateT s m a -&gt; StateT s m a
</span><a href="#local-6989586621679098221"><span class="hs-operator hs-var hs-var hs-var">&lt;|&gt;</span></a></span></span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span id="local-6989586621679098223"><span class="annot"><span class="annottext">s -&gt; m (a, s)
</span><a href="#local-6989586621679098223"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; m (a, s)) -&gt; StateT s m a
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m (a, s)) -&gt; StateT s m a)
-&gt; (s -&gt; m (a, s)) -&gt; StateT s m a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098224"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098224"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">s -&gt; m (a, s)
</span><a href="#local-6989586621679098220"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098224"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">m (a, s) -&gt; m (a, s) -&gt; m (a, s)
forall a. m a -&gt; m a -&gt; m a
forall (m :: * -&gt; *) a. MonadPlus m =&gt; m a -&gt; m a -&gt; m a
</span><span class="hs-operator hs-var">`mplus`</span></span><span> </span><span class="annot"><span class="annottext">s -&gt; m (a, s)
</span><a href="#local-6989586621679098223"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098224"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-227"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="hs-pragma">(</span><span class="hs-pragma">&lt;|&gt;</span><span class="hs-pragma">)</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-228"></span><span>
</span><span id="line-229"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679097944"><span id="local-6989586621679097945"><span id="local-6989586621679098232"><span id="local-6989586621679098235"><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679097944"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097945"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097944"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span class="hs-cpp">
#if !(MIN_VERSION_base(4,8,0))
</span><span>    </span><span class="hs-identifier">return</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">StateT</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-glyph">\</span><span> </span><span class="hs-identifier">s</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">a</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">s</span><span class="hs-special">)</span><span>
</span><span id="line-232"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="hs-pragma">return</span><span> </span><span class="hs-pragma">#-}</span><span class="hs-cpp">
#endif
</span><span>    </span><span id="local-6989586621679098242"><span class="annot"><span class="annottext">StateT s m a
</span><a href="#local-6989586621679098242"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679098243"><span class="annot"><span class="annottext">&gt;&gt;= :: forall a b. StateT s m a -&gt; (a -&gt; StateT s m b) -&gt; StateT s m b
</span><span class="hs-operator hs-var hs-var hs-var">&gt;&gt;=</span></span></span><span> </span><span id="local-6989586621679098244"><span class="annot"><span class="annottext">a -&gt; StateT s m b
</span><a href="#local-6989586621679098244"><span class="hs-identifier hs-var">k</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; m (b, s)) -&gt; StateT s m b
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m (b, s)) -&gt; StateT s m b)
-&gt; (s -&gt; m (b, s)) -&gt; StateT s m b
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098245"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098245"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-235"></span><span>        </span><span class="hs-glyph">~</span><span class="hs-special">(</span><span id="local-6989586621679098246"><span class="annot"><a href="#local-6989586621679098246"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679098247"><span class="annot"><a href="#local-6989586621679098247"><span class="hs-identifier hs-var">s'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">StateT s m a -&gt; s -&gt; m (a, s)
forall s (m :: * -&gt; *) a. StateT s m a -&gt; s -&gt; m (a, s)
</span><a href="Control.Monad.Trans.State.Lazy.html#runStateT"><span class="hs-identifier hs-var">runStateT</span></a></span><span> </span><span class="annot"><span class="annottext">StateT s m a
</span><a href="#local-6989586621679098242"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098245"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-236"></span><span>        </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#runStateT"><span class="hs-identifier hs-var">runStateT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679098244"><span class="hs-identifier hs-type">k</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098246"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679098247"><span class="hs-identifier hs-type">s'</span></a></span><span>
</span><span id="line-237"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="hs-pragma">(</span><span class="hs-pragma">&gt;&gt;=</span><span class="hs-pragma">)</span><span> </span><span class="hs-pragma">#-}</span><span class="hs-cpp">
#if !(MIN_VERSION_base(4,13,0))
</span><span>    </span><span class="hs-identifier">fail</span><span> </span><span class="hs-identifier">str</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">StateT</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-glyph">\</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">fail</span><span> </span><span class="hs-identifier">str</span><span>
</span><span id="line-240"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="hs-pragma">fail</span><span> </span><span class="hs-pragma">#-}</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">
#if MIN_VERSION_base(4,9,0)
</span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679097975"><span id="local-6989586621679097976"><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Fail.MonadFail</span></span><span> </span><span class="annot"><a href="#local-6989586621679097975"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fail.MonadFail</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097976"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097975"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-245"></span><span>    </span><span id="local-6989586621679098257"><span class="annot"><span class="annottext">fail :: forall a. String -&gt; StateT s m a
</span><span class="hs-identifier hs-var hs-var hs-var">fail</span></span></span><span> </span><span id="local-6989586621679098258"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679098258"><span class="hs-identifier hs-var">str</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; m (a, s)) -&gt; StateT s m a
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m (a, s)) -&gt; StateT s m a)
-&gt; (s -&gt; m (a, s)) -&gt; StateT s m a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span class="annot"><span class="annottext">s
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; m (a, s)
forall a. String -&gt; m a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">Fail.fail</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679098258"><span class="hs-identifier hs-var">str</span></a></span><span>
</span><span id="line-246"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><span class="hs-pragma hs-type">fail</span></span><span> </span><span class="hs-pragma">#-}</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-249"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679097980"><span id="local-6989586621679097981"><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">MonadPlus</span></span><span> </span><span class="annot"><a href="#local-6989586621679097980"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonadPlus</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097981"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097980"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-250"></span><span>    </span><span id="local-6989586621679098275"><span class="annot"><span class="annottext">mzero :: forall a. StateT s m a
</span><span class="hs-identifier hs-var hs-var hs-var">mzero</span></span></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; m (a, s)) -&gt; StateT s m a
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m (a, s)) -&gt; StateT s m a)
-&gt; (s -&gt; m (a, s)) -&gt; StateT s m a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span class="annot"><span class="annottext">s
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (a, s)
forall a. m a
forall (m :: * -&gt; *) a. MonadPlus m =&gt; m a
</span><span class="hs-identifier hs-var">mzero</span></span><span>
</span><span id="line-251"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><span class="hs-pragma hs-type">mzero</span></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-252"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span id="local-6989586621679098277"><span class="annot"><span class="annottext">s -&gt; m (a, s)
</span><a href="#local-6989586621679098277"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679098278"><span class="annot"><span class="annottext">mplus :: forall a. StateT s m a -&gt; StateT s m a -&gt; StateT s m a
</span><span class="hs-operator hs-var hs-var hs-var">`mplus`</span></span></span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span id="local-6989586621679098279"><span class="annot"><span class="annottext">s -&gt; m (a, s)
</span><a href="#local-6989586621679098279"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; m (a, s)) -&gt; StateT s m a
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m (a, s)) -&gt; StateT s m a)
-&gt; (s -&gt; m (a, s)) -&gt; StateT s m a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098280"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098280"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">s -&gt; m (a, s)
</span><a href="#local-6989586621679098277"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098280"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">m (a, s) -&gt; m (a, s) -&gt; m (a, s)
forall a. m a -&gt; m a -&gt; m a
forall (m :: * -&gt; *) a. MonadPlus m =&gt; m a -&gt; m a -&gt; m a
</span><span class="hs-operator hs-var">`mplus`</span></span><span> </span><span class="annot"><span class="annottext">s -&gt; m (a, s)
</span><a href="#local-6989586621679098279"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098280"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-253"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><span class="hs-pragma hs-type">mplus</span></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-254"></span><span>
</span><span id="line-255"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679097988"><span id="local-6989586621679097989"><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">MonadFix</span></span><span> </span><span class="annot"><a href="#local-6989586621679097988"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonadFix</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097989"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097988"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-256"></span><span>    </span><span id="local-6989586621679098290"><span class="annot"><span class="annottext">mfix :: forall a. (a -&gt; StateT s m a) -&gt; StateT s m a
</span><span class="hs-identifier hs-var hs-var hs-var">mfix</span></span></span><span> </span><span id="local-6989586621679098291"><span class="annot"><span class="annottext">a -&gt; StateT s m a
</span><a href="#local-6989586621679098291"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; m (a, s)) -&gt; StateT s m a
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m (a, s)) -&gt; StateT s m a)
-&gt; (s -&gt; m (a, s)) -&gt; StateT s m a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098292"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098292"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">((a, s) -&gt; m (a, s)) -&gt; m (a, s)
forall a. (a -&gt; m a) -&gt; m a
forall (m :: * -&gt; *) a. MonadFix m =&gt; (a -&gt; m a) -&gt; m a
</span><span class="hs-identifier hs-var">mfix</span></span><span> </span><span class="annot"><span class="annottext">(((a, s) -&gt; m (a, s)) -&gt; m (a, s))
-&gt; ((a, s) -&gt; m (a, s)) -&gt; m (a, s)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span class="hs-glyph">~</span><span class="hs-special">(</span><span id="local-6989586621679098293"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679098293"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">s
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">StateT s m a -&gt; s -&gt; m (a, s)
forall s (m :: * -&gt; *) a. StateT s m a -&gt; s -&gt; m (a, s)
</span><a href="Control.Monad.Trans.State.Lazy.html#runStateT"><span class="hs-identifier hs-var">runStateT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; StateT s m a
</span><a href="#local-6989586621679098291"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679098293"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098292"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-257"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><span class="hs-pragma hs-type">mfix</span></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-258"></span><span>
</span><span id="line-259"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679097997"><span class="annot"><a href="Control.Monad.Trans.Class.html#MonadTrans"><span class="hs-identifier hs-type">MonadTrans</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679097997"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-260"></span><span>    </span><span id="local-6989586621679098302"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *) a. Monad m =&gt; m a -&gt; StateT s m a
</span><a href="#local-6989586621679098302"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679098304"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679098304"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; m (a, s)) -&gt; StateT s m a
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m (a, s)) -&gt; StateT s m a)
-&gt; (s -&gt; m (a, s)) -&gt; StateT s m a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098305"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098305"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-261"></span><span>        </span><span id="local-6989586621679098306"><span class="annot"><a href="#local-6989586621679098306"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679098304"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-262"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679098306"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679098305"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-263"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.Class.html#lift"><span class="hs-pragma hs-type">lift</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-264"></span><span>
</span><span id="line-265"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679098005"><span id="local-6989586621679098006"><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">MonadIO</span></span><span> </span><span class="annot"><a href="#local-6989586621679098005"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonadIO</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098006"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098005"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-266"></span><span>    </span><span id="local-6989586621679098318"><span class="annot"><span class="annottext">liftIO :: forall a. IO a -&gt; StateT s m a
</span><a href="#local-6989586621679098318"><span class="hs-identifier hs-var hs-var hs-var">liftIO</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m a -&gt; StateT s m a
forall (m :: * -&gt; *) a. Monad m =&gt; m a -&gt; StateT s m a
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><a href="Control.Monad.Trans.Class.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(m a -&gt; StateT s m a) -&gt; (IO a -&gt; m a) -&gt; IO a -&gt; StateT s m a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">IO a -&gt; m a
forall a. IO a -&gt; m a
forall (m :: * -&gt; *) a. MonadIO m =&gt; IO a -&gt; m a
</span><span class="hs-identifier hs-var">liftIO</span></span><span>
</span><span id="line-267"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><span class="hs-pragma hs-type">liftIO</span></span><span> </span><span class="hs-pragma">#-}</span><span class="hs-cpp">

#if MIN_VERSION_base(4,12,0)
</span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679098016"><span id="local-6989586621679098017"><span id="local-6989586621679098323"><span class="annot"><a href="../../base-4.21.0.0-ae91/src/Data.Functor.Contravariant.html#Contravariant"><span class="hs-identifier hs-type">Contravariant</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098016"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="../../base-4.21.0.0-ae91/src/Data.Functor.Contravariant.html#Contravariant"><span class="hs-identifier hs-type">Contravariant</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098017"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098016"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-271"></span><span>    </span><span id="local-6989586621679098328"><span class="annot"><span class="annottext">contramap :: forall a' a. (a' -&gt; a) -&gt; StateT s m a -&gt; StateT s m a'
</span><a href="#local-6989586621679098328"><span class="hs-identifier hs-var hs-var hs-var">contramap</span></a></span></span><span> </span><span id="local-6989586621679098330"><span class="annot"><span class="annottext">a' -&gt; a
</span><a href="#local-6989586621679098330"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679098331"><span class="annot"><span class="annottext">StateT s m a
</span><a href="#local-6989586621679098331"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; m (a', s)) -&gt; StateT s m a'
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m (a', s)) -&gt; StateT s m a')
-&gt; (s -&gt; m (a', s)) -&gt; StateT s m a'
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679098332"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098332"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-272"></span><span>      </span><span class="annot"><span class="annottext">((a', s) -&gt; (a, s)) -&gt; m (a, s) -&gt; m (a', s)
forall a' a. (a' -&gt; a) -&gt; m a -&gt; m a'
forall (f :: * -&gt; *) a' a.
Contravariant f =&gt;
(a' -&gt; a) -&gt; f a -&gt; f a'
</span><a href="../../base-4.21.0.0-ae91/src/Data.Functor.Contravariant.html#contramap"><span class="hs-identifier hs-var">contramap</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span> </span><span class="hs-glyph">~</span><span class="hs-special">(</span><span id="local-6989586621679098333"><span class="annot"><span class="annottext">a'
</span><a href="#local-6989586621679098333"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679098334"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098334"><span class="hs-identifier hs-var">s'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a' -&gt; a
</span><a href="#local-6989586621679098330"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a'
</span><a href="#local-6989586621679098333"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098334"><span class="hs-identifier hs-var">s'</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(m (a, s) -&gt; m (a', s)) -&gt; m (a, s) -&gt; m (a', s)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">StateT s m a -&gt; s -&gt; m (a, s)
forall s (m :: * -&gt; *) a. StateT s m a -&gt; s -&gt; m (a, s)
</span><a href="Control.Monad.Trans.State.Lazy.html#runStateT"><span class="hs-identifier hs-var">runStateT</span></a></span><span> </span><span class="annot"><span class="annottext">StateT s m a
</span><a href="#local-6989586621679098331"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098332"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-273"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="../../base-4.21.0.0-ae91/src/Data.Functor.Contravariant.html#contramap"><span class="hs-pragma hs-type">contramap</span></a></span><span> </span><span class="hs-pragma">#-}</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-276"></span><span class="annot"><span class="hs-comment">-- | Fetch the current value of the state within the monad.</span></span><span>
</span><span id="line-277"></span><span id="local-6989586621679098020"><span id="local-6989586621679098021"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#get"><span class="hs-identifier hs-type">get</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679098020"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098021"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098020"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098021"><span class="hs-identifier hs-type">s</span></a></span></span></span><span>
</span><span id="line-278"></span><span id="get"><span class="annot"><span class="annottext">get :: forall (m :: * -&gt; *) s. Monad m =&gt; StateT s m s
</span><a href="Control.Monad.Trans.State.Lazy.html#get"><span class="hs-identifier hs-var hs-var">get</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; (s, s)) -&gt; StateT s m s
forall (m :: * -&gt; *) s a. Monad m =&gt; (s -&gt; (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#state"><span class="hs-identifier hs-var">state</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; (s, s)) -&gt; StateT s m s) -&gt; (s -&gt; (s, s)) -&gt; StateT s m s
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098337"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098337"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098337"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098337"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-279"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#get"><span class="hs-pragma hs-type">get</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-280"></span><span>
</span><span id="line-281"></span><span class="annot"><span class="hs-comment">-- | @'put' s@ sets the state within the monad to @s@.</span></span><span>
</span><span id="line-282"></span><span id="local-6989586621679098024"><span id="local-6989586621679098025"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#put"><span class="hs-identifier hs-type">put</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679098024"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679098025"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098025"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098024"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-283"></span><span id="put"><span class="annot"><span class="annottext">put :: forall (m :: * -&gt; *) s. Monad m =&gt; s -&gt; StateT s m ()
</span><a href="Control.Monad.Trans.State.Lazy.html#put"><span class="hs-identifier hs-var hs-var">put</span></a></span></span><span> </span><span id="local-6989586621679098340"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098340"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; ((), s)) -&gt; StateT s m ()
forall (m :: * -&gt; *) s a. Monad m =&gt; (s -&gt; (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#state"><span class="hs-identifier hs-var">state</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; ((), s)) -&gt; StateT s m ())
-&gt; (s -&gt; ((), s)) -&gt; StateT s m ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span class="annot"><span class="annottext">s
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098340"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-284"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#put"><span class="hs-pragma hs-type">put</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-285"></span><span>
</span><span id="line-286"></span><span class="hs-comment">-- | @'modify' f@ is an action that updates the state to the result of</span><span>
</span><span id="line-287"></span><span class="hs-comment">-- applying @f@ to the current state.</span><span>
</span><span id="line-288"></span><span class="hs-comment">--</span><span>
</span><span id="line-289"></span><span class="hs-comment">-- * @'modify' f = 'get' &gt;&gt;= ('put' . f)@</span><span>
</span><span id="line-290"></span><span id="local-6989586621679098028"><span id="local-6989586621679098029"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#modify"><span class="hs-identifier hs-type">modify</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679098028"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679098029"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679098029"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098029"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098028"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-291"></span><span id="modify"><span class="annot"><span class="annottext">modify :: forall (m :: * -&gt; *) s. Monad m =&gt; (s -&gt; s) -&gt; StateT s m ()
</span><a href="Control.Monad.Trans.State.Lazy.html#modify"><span class="hs-identifier hs-var hs-var">modify</span></a></span></span><span> </span><span id="local-6989586621679098343"><span class="annot"><span class="annottext">s -&gt; s
</span><a href="#local-6989586621679098343"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; ((), s)) -&gt; StateT s m ()
forall (m :: * -&gt; *) s a. Monad m =&gt; (s -&gt; (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#state"><span class="hs-identifier hs-var">state</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; ((), s)) -&gt; StateT s m ())
-&gt; (s -&gt; ((), s)) -&gt; StateT s m ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098344"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098344"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">s -&gt; s
</span><a href="#local-6989586621679098343"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098344"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-292"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#modify"><span class="hs-pragma hs-type">modify</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-293"></span><span>
</span><span id="line-294"></span><span class="hs-comment">-- | A variant of 'modify' in which the computation is strict in the</span><span>
</span><span id="line-295"></span><span class="hs-comment">-- new state.</span><span>
</span><span id="line-296"></span><span class="hs-comment">--</span><span>
</span><span id="line-297"></span><span class="hs-comment">-- * @'modify'' f = 'get' &gt;&gt;= (('$!') 'put' . f)@</span><span>
</span><span id="line-298"></span><span id="local-6989586621679098346"><span id="local-6989586621679098347"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#modify%27"><span class="hs-identifier hs-type">modify'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679098346"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679098347"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679098347"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098347"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098346"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-299"></span><span id="modify%27"><span class="annot"><span class="annottext">modify' :: forall (m :: * -&gt; *) s. Monad m =&gt; (s -&gt; s) -&gt; StateT s m ()
</span><a href="Control.Monad.Trans.State.Lazy.html#modify%27"><span class="hs-identifier hs-var hs-var">modify'</span></a></span></span><span> </span><span id="local-6989586621679098352"><span class="annot"><span class="annottext">s -&gt; s
</span><a href="#local-6989586621679098352"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-300"></span><span>    </span><span id="local-6989586621679098353"><span class="annot"><a href="#local-6989586621679098353"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">StateT s m s
forall (m :: * -&gt; *) s. Monad m =&gt; StateT s m s
</span><a href="Control.Monad.Trans.State.Lazy.html#get"><span class="hs-identifier hs-var">get</span></a></span><span>
</span><span id="line-301"></span><span>    </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#put"><span class="hs-identifier hs-type">put</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">$!</span></span><span> </span><span class="annot"><a href="#local-6989586621679098352"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098353"><span class="hs-identifier hs-type">s</span></a></span><span>
</span><span id="line-302"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#modify%27"><span class="hs-pragma hs-type">modify'</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-303"></span><span>
</span><span id="line-304"></span><span class="hs-comment">-- | A variant of 'modify' in which the new state is generated by a</span><span>
</span><span id="line-305"></span><span class="hs-comment">-- monadic action.</span><span>
</span><span id="line-306"></span><span id="local-6989586621679098037"><span id="local-6989586621679098038"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#modifyM"><span class="hs-identifier hs-type">modifyM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679098037"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679098038"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679098037"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098038"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098038"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098037"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-307"></span><span id="modifyM"><span class="annot"><span class="annottext">modifyM :: forall (m :: * -&gt; *) s. Monad m =&gt; (s -&gt; m s) -&gt; StateT s m ()
</span><a href="Control.Monad.Trans.State.Lazy.html#modifyM"><span class="hs-identifier hs-var hs-var">modifyM</span></a></span></span><span> </span><span id="local-6989586621679098357"><span class="annot"><span class="annottext">s -&gt; m s
</span><a href="#local-6989586621679098357"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; m ((), s)) -&gt; StateT s m ()
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m ((), s)) -&gt; StateT s m ())
-&gt; (s -&gt; m ((), s)) -&gt; StateT s m ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098358"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098358"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-308"></span><span>    </span><span id="local-6989586621679098359"><span class="annot"><a href="#local-6989586621679098359"><span class="hs-identifier hs-var">s'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">s -&gt; m s
</span><a href="#local-6989586621679098357"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098358"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-309"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679098359"><span class="hs-identifier hs-type">s'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-310"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#modifyM"><span class="hs-pragma hs-type">modifyM</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-311"></span><span>
</span><span id="line-312"></span><span class="hs-comment">-- | Get a specific component of the state, using a projection function</span><span>
</span><span id="line-313"></span><span class="hs-comment">-- supplied.</span><span>
</span><span id="line-314"></span><span class="hs-comment">--</span><span>
</span><span id="line-315"></span><span class="hs-comment">-- * @'gets' f = 'liftM' f 'get'@</span><span>
</span><span id="line-316"></span><span id="local-6989586621679098041"><span id="local-6989586621679098042"><span id="local-6989586621679098043"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#gets"><span class="hs-identifier hs-type">gets</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679098041"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679098042"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679098043"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098042"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098041"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098043"><span class="hs-identifier hs-type">a</span></a></span></span></span></span><span>
</span><span id="line-317"></span><span id="gets"><span class="annot"><span class="annottext">gets :: forall (m :: * -&gt; *) s a. Monad m =&gt; (s -&gt; a) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#gets"><span class="hs-identifier hs-var hs-var">gets</span></a></span></span><span> </span><span id="local-6989586621679098362"><span class="annot"><span class="annottext">s -&gt; a
</span><a href="#local-6989586621679098362"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; (a, s)) -&gt; StateT s m a
forall (m :: * -&gt; *) s a. Monad m =&gt; (s -&gt; (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#state"><span class="hs-identifier hs-var">state</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; (a, s)) -&gt; StateT s m a) -&gt; (s -&gt; (a, s)) -&gt; StateT s m a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098363"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098363"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">s -&gt; a
</span><a href="#local-6989586621679098362"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098363"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098363"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-318"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#gets"><span class="hs-pragma hs-type">gets</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-319"></span><span>
</span><span id="line-320"></span><span class="hs-comment">-- | Uniform lifting of a @callCC@ operation to the new monad.</span><span>
</span><span id="line-321"></span><span class="hs-comment">-- This version rolls back to the original state on entering the</span><span>
</span><span id="line-322"></span><span class="hs-comment">-- continuation.</span><span>
</span><span id="line-323"></span><span id="local-6989586621679098047"><span id="local-6989586621679098048"><span id="local-6989586621679098049"><span id="local-6989586621679098050"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#liftCallCC"><span class="hs-identifier hs-type">liftCallCC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Monad.Signatures.html#CallCC"><span class="hs-identifier hs-type">CallCC</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098047"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679098048"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span class="annot"><a href="#local-6989586621679098049"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679098050"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span class="annot"><a href="#local-6989586621679098049"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Signatures.html#CallCC"><span class="hs-identifier hs-type">CallCC</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098049"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098047"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679098048"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098050"><span class="hs-identifier hs-type">b</span></a></span></span></span></span></span><span>
</span><span id="line-324"></span><span id="liftCallCC"><span class="annot"><span class="annottext">liftCallCC :: forall (m :: * -&gt; *) a s b.
CallCC m (a, s) (b, s) -&gt; CallCC (StateT s m) a b
</span><a href="Control.Monad.Trans.State.Lazy.html#liftCallCC"><span class="hs-identifier hs-var hs-var">liftCallCC</span></a></span></span><span> </span><span id="local-6989586621679098364"><span class="annot"><span class="annottext">CallCC m (a, s) (b, s)
</span><a href="#local-6989586621679098364"><span class="hs-identifier hs-var">callCC</span></a></span></span><span> </span><span id="local-6989586621679098365"><span class="annot"><span class="annottext">(a -&gt; StateT s m b) -&gt; StateT s m a
</span><a href="#local-6989586621679098365"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; m (a, s)) -&gt; StateT s m a
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m (a, s)) -&gt; StateT s m a)
-&gt; (s -&gt; m (a, s)) -&gt; StateT s m a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098366"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098366"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-325"></span><span>    </span><span class="annot"><span class="annottext">CallCC m (a, s) (b, s)
</span><a href="#local-6989586621679098364"><span class="hs-identifier hs-var">callCC</span></a></span><span> </span><span class="annot"><span class="annottext">CallCC m (a, s) (b, s) -&gt; CallCC m (a, s) (b, s)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098367"><span class="annot"><span class="annottext">(a, s) -&gt; m (b, s)
</span><a href="#local-6989586621679098367"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-326"></span><span>    </span><span class="annot"><span class="annottext">StateT s m a -&gt; s -&gt; m (a, s)
forall s (m :: * -&gt; *) a. StateT s m a -&gt; s -&gt; m (a, s)
</span><a href="Control.Monad.Trans.State.Lazy.html#runStateT"><span class="hs-identifier hs-var">runStateT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; StateT s m b) -&gt; StateT s m a
</span><a href="#local-6989586621679098365"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098368"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679098368"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(s -&gt; m (b, s)) -&gt; StateT s m b
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m (b, s)) -&gt; StateT s m b)
-&gt; (s -&gt; m (b, s)) -&gt; StateT s m b
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span class="annot"><span class="annottext">s
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(a, s) -&gt; m (b, s)
</span><a href="#local-6989586621679098367"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679098368"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098366"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098366"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-327"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#liftCallCC"><span class="hs-pragma hs-type">liftCallCC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-328"></span><span>
</span><span id="line-329"></span><span class="hs-comment">-- | In-situ lifting of a @callCC@ operation to the new monad.</span><span>
</span><span id="line-330"></span><span class="hs-comment">-- This version uses the current state on entering the continuation.</span><span>
</span><span id="line-331"></span><span class="hs-comment">-- It does not satisfy the uniformity property (see &quot;Control.Monad.Signatures&quot;).</span><span>
</span><span id="line-332"></span><span id="local-6989586621679098369"><span id="local-6989586621679098370"><span id="local-6989586621679098371"><span id="local-6989586621679098372"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#liftCallCC%27"><span class="hs-identifier hs-type">liftCallCC'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Monad.Signatures.html#CallCC"><span class="hs-identifier hs-type">CallCC</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098369"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679098370"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span class="annot"><a href="#local-6989586621679098371"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679098372"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span class="annot"><a href="#local-6989586621679098371"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Signatures.html#CallCC"><span class="hs-identifier hs-type">CallCC</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098371"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098369"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679098370"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098372"><span class="hs-identifier hs-type">b</span></a></span></span></span></span></span><span>
</span><span id="line-333"></span><span id="liftCallCC%27"><span class="annot"><span class="annottext">liftCallCC' :: forall (m :: * -&gt; *) a s b.
CallCC m (a, s) (b, s) -&gt; CallCC (StateT s m) a b
</span><a href="Control.Monad.Trans.State.Lazy.html#liftCallCC%27"><span class="hs-identifier hs-var hs-var">liftCallCC'</span></a></span></span><span> </span><span id="local-6989586621679098373"><span class="annot"><span class="annottext">CallCC m (a, s) (b, s)
</span><a href="#local-6989586621679098373"><span class="hs-identifier hs-var">callCC</span></a></span></span><span> </span><span id="local-6989586621679098374"><span class="annot"><span class="annottext">(a -&gt; StateT s m b) -&gt; StateT s m a
</span><a href="#local-6989586621679098374"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; m (a, s)) -&gt; StateT s m a
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m (a, s)) -&gt; StateT s m a)
-&gt; (s -&gt; m (a, s)) -&gt; StateT s m a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098375"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098375"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-334"></span><span>    </span><span class="annot"><span class="annottext">CallCC m (a, s) (b, s)
</span><a href="#local-6989586621679098373"><span class="hs-identifier hs-var">callCC</span></a></span><span> </span><span class="annot"><span class="annottext">CallCC m (a, s) (b, s) -&gt; CallCC m (a, s) (b, s)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098376"><span class="annot"><span class="annottext">(a, s) -&gt; m (b, s)
</span><a href="#local-6989586621679098376"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-335"></span><span>    </span><span class="annot"><span class="annottext">StateT s m a -&gt; s -&gt; m (a, s)
forall s (m :: * -&gt; *) a. StateT s m a -&gt; s -&gt; m (a, s)
</span><a href="Control.Monad.Trans.State.Lazy.html#runStateT"><span class="hs-identifier hs-var">runStateT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; StateT s m b) -&gt; StateT s m a
</span><a href="#local-6989586621679098374"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098377"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679098377"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(s -&gt; m (b, s)) -&gt; StateT s m b
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m (b, s)) -&gt; StateT s m b)
-&gt; (s -&gt; m (b, s)) -&gt; StateT s m b
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098378"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098378"><span class="hs-identifier hs-var">s'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(a, s) -&gt; m (b, s)
</span><a href="#local-6989586621679098376"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679098377"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098378"><span class="hs-identifier hs-var">s'</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098375"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-336"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#liftCallCC%27"><span class="hs-pragma hs-type">liftCallCC'</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-337"></span><span>
</span><span id="line-338"></span><span class="hs-comment">-- | Lift a @catchE@ operation to the new monad.</span><span>
</span><span id="line-339"></span><span class="hs-comment">-- The uniformity property (see &quot;Control.Monad.Signatures&quot;) implies</span><span>
</span><span id="line-340"></span><span class="hs-comment">-- that the lifted @catchE@ rolls back to the original state on entering</span><span>
</span><span id="line-341"></span><span class="hs-comment">-- the handler.</span><span>
</span><span id="line-342"></span><span id="local-6989586621679098060"><span id="local-6989586621679098061"><span id="local-6989586621679098062"><span id="local-6989586621679098063"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#liftCatch"><span class="hs-identifier hs-type">liftCatch</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Monad.Signatures.html#Catch"><span class="hs-identifier hs-type">Catch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098060"><span class="hs-identifier hs-type">e</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098061"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679098062"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span class="annot"><a href="#local-6989586621679098063"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Signatures.html#Catch"><span class="hs-identifier hs-type">Catch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098060"><span class="hs-identifier hs-type">e</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098063"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098061"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679098062"><span class="hs-identifier hs-type">a</span></a></span></span></span></span></span><span>
</span><span id="line-343"></span><span id="liftCatch"><span class="annot"><span class="annottext">liftCatch :: forall e (m :: * -&gt; *) a s.
Catch e m (a, s) -&gt; Catch e (StateT s m) a
</span><a href="Control.Monad.Trans.State.Lazy.html#liftCatch"><span class="hs-identifier hs-var hs-var">liftCatch</span></a></span></span><span> </span><span id="local-6989586621679098379"><span class="annot"><span class="annottext">Catch e m (a, s)
</span><a href="#local-6989586621679098379"><span class="hs-identifier hs-var">catchE</span></a></span></span><span> </span><span id="local-6989586621679098380"><span class="annot"><span class="annottext">StateT s m a
</span><a href="#local-6989586621679098380"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679098381"><span class="annot"><span class="annottext">e -&gt; StateT s m a
</span><a href="#local-6989586621679098381"><span class="hs-identifier hs-var">h</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-344"></span><span>    </span><span class="annot"><span class="annottext">(s -&gt; m (a, s)) -&gt; StateT s m a
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m (a, s)) -&gt; StateT s m a)
-&gt; (s -&gt; m (a, s)) -&gt; StateT s m a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098382"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098382"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">StateT s m a -&gt; s -&gt; m (a, s)
forall s (m :: * -&gt; *) a. StateT s m a -&gt; s -&gt; m (a, s)
</span><a href="Control.Monad.Trans.State.Lazy.html#runStateT"><span class="hs-identifier hs-var">runStateT</span></a></span><span> </span><span class="annot"><span class="annottext">StateT s m a
</span><a href="#local-6989586621679098380"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098382"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">Catch e m (a, s)
</span><a href="#local-6989586621679098379"><span class="hs-operator hs-var">`catchE`</span></a></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098383"><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679098383"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">StateT s m a -&gt; s -&gt; m (a, s)
forall s (m :: * -&gt; *) a. StateT s m a -&gt; s -&gt; m (a, s)
</span><a href="Control.Monad.Trans.State.Lazy.html#runStateT"><span class="hs-identifier hs-var">runStateT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">e -&gt; StateT s m a
</span><a href="#local-6989586621679098381"><span class="hs-identifier hs-var">h</span></a></span><span> </span><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679098383"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098382"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-345"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#liftCatch"><span class="hs-pragma hs-type">liftCatch</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-346"></span><span>
</span><span id="line-347"></span><span class="annot"><span class="hs-comment">-- | Lift a @listen@ operation to the new monad.</span></span><span>
</span><span id="line-348"></span><span id="local-6989586621679098069"><span id="local-6989586621679098070"><span id="local-6989586621679098071"><span id="local-6989586621679098072"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#liftListen"><span class="hs-identifier hs-type">liftListen</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679098069"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Signatures.html#Listen"><span class="hs-identifier hs-type">Listen</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098070"><span class="hs-identifier hs-type">w</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098069"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679098071"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span class="annot"><a href="#local-6989586621679098072"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Signatures.html#Listen"><span class="hs-identifier hs-type">Listen</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098070"><span class="hs-identifier hs-type">w</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098072"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098069"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679098071"><span class="hs-identifier hs-type">a</span></a></span></span></span></span></span><span>
</span><span id="line-349"></span><span id="liftListen"><span class="annot"><span class="annottext">liftListen :: forall (m :: * -&gt; *) w a s.
Monad m =&gt;
Listen w m (a, s) -&gt; Listen w (StateT s m) a
</span><a href="Control.Monad.Trans.State.Lazy.html#liftListen"><span class="hs-identifier hs-var hs-var">liftListen</span></a></span></span><span> </span><span id="local-6989586621679098387"><span class="annot"><span class="annottext">Listen w m (a, s)
</span><a href="#local-6989586621679098387"><span class="hs-identifier hs-var">listen</span></a></span></span><span> </span><span id="local-6989586621679098388"><span class="annot"><span class="annottext">StateT s m a
</span><a href="#local-6989586621679098388"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; m ((a, w), s)) -&gt; StateT s m (a, w)
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m ((a, w), s)) -&gt; StateT s m (a, w))
-&gt; (s -&gt; m ((a, w), s)) -&gt; StateT s m (a, w)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098389"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098389"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-350"></span><span>    </span><span class="hs-glyph">~</span><span class="hs-special">(</span><span class="hs-special">(</span><span id="local-6989586621679098390"><span class="annot"><a href="#local-6989586621679098390"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679098391"><span class="annot"><a href="#local-6989586621679098391"><span class="hs-identifier hs-var">s'</span></a></span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span id="local-6989586621679098392"><span class="annot"><a href="#local-6989586621679098392"><span class="hs-identifier hs-var">w</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Listen w m (a, s)
</span><a href="#local-6989586621679098387"><span class="hs-identifier hs-var">listen</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">StateT s m a -&gt; s -&gt; m (a, s)
forall s (m :: * -&gt; *) a. StateT s m a -&gt; s -&gt; m (a, s)
</span><a href="Control.Monad.Trans.State.Lazy.html#runStateT"><span class="hs-identifier hs-var">runStateT</span></a></span><span> </span><span class="annot"><span class="annottext">StateT s m a
</span><a href="#local-6989586621679098388"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098389"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-351"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679098390"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679098392"><span class="hs-identifier hs-type">w</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679098391"><span class="hs-identifier hs-type">s'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-352"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#liftListen"><span class="hs-pragma hs-type">liftListen</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-353"></span><span>
</span><span id="line-354"></span><span class="annot"><span class="hs-comment">-- | Lift a @pass@ operation to the new monad.</span></span><span>
</span><span id="line-355"></span><span id="local-6989586621679098078"><span id="local-6989586621679098079"><span id="local-6989586621679098080"><span id="local-6989586621679098081"><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#liftPass"><span class="hs-identifier hs-type">liftPass</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679098078"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Signatures.html#Pass"><span class="hs-identifier hs-type">Pass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098079"><span class="hs-identifier hs-type">w</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098078"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679098080"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span class="annot"><a href="#local-6989586621679098081"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.Signatures.html#Pass"><span class="hs-identifier hs-type">Pass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098079"><span class="hs-identifier hs-type">w</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098081"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679098078"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679098080"><span class="hs-identifier hs-type">a</span></a></span></span></span></span></span><span>
</span><span id="line-356"></span><span id="liftPass"><span class="annot"><span class="annottext">liftPass :: forall (m :: * -&gt; *) w a s.
Monad m =&gt;
Pass w m (a, s) -&gt; Pass w (StateT s m) a
</span><a href="Control.Monad.Trans.State.Lazy.html#liftPass"><span class="hs-identifier hs-var hs-var">liftPass</span></a></span></span><span> </span><span id="local-6989586621679098396"><span class="annot"><span class="annottext">Pass w m (a, s)
</span><a href="#local-6989586621679098396"><span class="hs-identifier hs-var">pass</span></a></span></span><span> </span><span id="local-6989586621679098397"><span class="annot"><span class="annottext">StateT s m (a, w -&gt; w)
</span><a href="#local-6989586621679098397"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; m (a, s)) -&gt; StateT s m a
forall s (m :: * -&gt; *) a. (s -&gt; m (a, s)) -&gt; StateT s m a
</span><a href="Control.Monad.Trans.State.Lazy.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m (a, s)) -&gt; StateT s m a)
-&gt; (s -&gt; m (a, s)) -&gt; StateT s m a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679098398"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098398"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pass w m (a, s)
</span><a href="#local-6989586621679098396"><span class="hs-identifier hs-var">pass</span></a></span><span> </span><span class="annot"><span class="annottext">Pass w m (a, s) -&gt; Pass w m (a, s)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-357"></span><span>    </span><span class="hs-glyph">~</span><span class="hs-special">(</span><span class="hs-special">(</span><span id="local-6989586621679098399"><span class="annot"><a href="#local-6989586621679098399"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679098400"><span class="annot"><a href="#local-6989586621679098400"><span class="hs-identifier hs-var">f</span></a></span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span id="local-6989586621679098401"><span class="annot"><a href="#local-6989586621679098401"><span class="hs-identifier hs-var">s'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">StateT s m (a, w -&gt; w) -&gt; s -&gt; m ((a, w -&gt; w), s)
forall s (m :: * -&gt; *) a. StateT s m a -&gt; s -&gt; m (a, s)
</span><a href="Control.Monad.Trans.State.Lazy.html#runStateT"><span class="hs-identifier hs-var">runStateT</span></a></span><span> </span><span class="annot"><span class="annottext">StateT s m (a, w -&gt; w)
</span><a href="#local-6989586621679098397"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679098398"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-358"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679098399"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679098401"><span class="hs-identifier hs-type">s'</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679098400"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-359"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Trans.State.Lazy.html#liftPass"><span class="hs-pragma hs-type">liftPass</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-360"></span><span>
</span><span id="line-361"></span><span class="annot"><span class="hs-comment">{- $examples

Parser from ParseLib with Hugs:

&gt; type Parser a = StateT String [] a
&gt;    ==&gt; StateT (String -&gt; [(a,String)])

For example, item can be written as:

&gt; item = do (x:xs) &lt;- get
&gt;        put xs
&gt;        return x
&gt;
&gt; type BoringState s a = StateT s Identity a
&gt;      ==&gt; StateT (s -&gt; Identity (a,s))
&gt;
&gt; type StateWithIO s a = StateT s IO a
&gt;      ==&gt; StateT (s -&gt; IO (a,s))
&gt;
&gt; type StateWithErr s a = StateT s Maybe a
&gt;      ==&gt; StateT (s -&gt; Maybe (a,s))

-}</span></span><span>
</span><span id="line-384"></span><span>
</span><span id="line-385"></span><span class="annot"><span class="hs-comment">{- $counting

A function to increment a counter.
Taken from the paper \&quot;Generalising Monads to Arrows\&quot;,
John Hughes (&lt;http://www.cse.chalmers.se/~rjmh/&gt;), November 1998:

&gt; tick :: State Int Int
&gt; tick = do n &lt;- get
&gt;           put (n+1)
&gt;           return n

Add one to the given number using the state monad:

&gt; plusOne :: Int -&gt; Int
&gt; plusOne n = execState tick n

A contrived addition example. Works only with positive numbers:

&gt; plus :: Int -&gt; Int -&gt; Int
&gt; plus n x = execState (sequence $ replicate n tick) x

-}</span></span><span>
</span><span id="line-407"></span><span>
</span><span id="line-408"></span><span class="annot"><span class="hs-comment">{- $labelling

An example from /The Craft of Functional Programming/, Simon
Thompson (&lt;http://www.cs.kent.ac.uk/people/staff/sjt/&gt;),
Addison-Wesley 1999: \&quot;Given an arbitrary tree, transform it to a
tree of integers in which the original elements are replaced by
natural numbers, starting from 0.  The same element has to be
replaced by the same number at every occurrence, and when we meet
an as-yet-unvisited element we have to find a \'new\' number to match
it with:\&quot;

&gt; data Tree a = Nil | Node a (Tree a) (Tree a) deriving (Show, Eq)
&gt; type Table a = [a]

&gt; numberTree :: Eq a =&gt; Tree a -&gt; State (Table a) (Tree Int)
&gt; numberTree Nil = return Nil
&gt; numberTree (Node x t1 t2) = do
&gt;     num &lt;- numberNode x
&gt;     nt1 &lt;- numberTree t1
&gt;     nt2 &lt;- numberTree t2
&gt;     return (Node num nt1 nt2)
&gt;   where
&gt;     numberNode :: Eq a =&gt; a -&gt; State (Table a) Int
&gt;     numberNode x = do
&gt;         table &lt;- get
&gt;         case elemIndex x table of
&gt;             Nothing -&gt; do
&gt;                 put (table ++ [x])
&gt;                 return (length table)
&gt;             Just i -&gt; return i

numTree applies numberTree with an initial state:

&gt; numTree :: (Eq a) =&gt; Tree a -&gt; Tree Int
&gt; numTree t = evalState (numberTree t) []

&gt; testTree = Node &quot;Zero&quot; (Node &quot;One&quot; (Node &quot;Two&quot; Nil Nil) (Node &quot;One&quot; (Node &quot;Zero&quot; Nil Nil) Nil)) Nil
&gt; numTree testTree =&gt; Node 0 (Node 1 (Node 2 Nil Nil) (Node 1 (Node 0 Nil Nil) Nil)) Nil

-}</span></span><span>
</span><span id="line-448"></span></pre></body></html>